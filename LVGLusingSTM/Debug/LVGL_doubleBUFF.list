
LVGL_doubleBUFF.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001ac  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002e204  080001ac  080001ac  000101ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000c402c  0802e3b0  0802e3b0  0003e3b0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080f23dc  080f23dc  00117f68  2**0
                  CONTENTS
  4 .ARM          00000008  080f23dc  080f23dc  001023dc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080f23e4  080f23e4  00117f68  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080f23e4  080f23e4  001023e4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080f23e8  080f23e8  001023e8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000268  20000000  080f23ec  00110000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .sdram        00007d00  20000268  080f2654  00110268  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          0000a548  20007f68  080fa354  00117f68  2**2
                  ALLOC
 11 ._user_heap_stack 00004000  200124b0  080fa354  001224b0  2**0
                  ALLOC
 12 .ARM.attributes 00000030  00000000  00000000  00117f68  2**0
                  CONTENTS, READONLY
 13 .comment      00000043  00000000  00000000  00117f98  2**0
                  CONTENTS, READONLY
 14 .debug_info   0004816b  00000000  00000000  00117fdb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_abbrev 0000a496  00000000  00000000  00160146  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_aranges 00003288  00000000  00000000  0016a5e0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_rnglists 00002860  00000000  00000000  0016d868  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_macro  0000fce5  00000000  00000000  001700c8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_line   00051da5  00000000  00000000  0017fdad  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_str    000efb87  00000000  00000000  001d1b52  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_frame  0000d880  00000000  00000000  002c16dc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000054  00000000  00000000  002cef5c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001ac <__do_global_dtors_aux>:
 80001ac:	b510      	push	{r4, lr}
 80001ae:	4c05      	ldr	r4, [pc, #20]	; (80001c4 <__do_global_dtors_aux+0x18>)
 80001b0:	7823      	ldrb	r3, [r4, #0]
 80001b2:	b933      	cbnz	r3, 80001c2 <__do_global_dtors_aux+0x16>
 80001b4:	4b04      	ldr	r3, [pc, #16]	; (80001c8 <__do_global_dtors_aux+0x1c>)
 80001b6:	b113      	cbz	r3, 80001be <__do_global_dtors_aux+0x12>
 80001b8:	4804      	ldr	r0, [pc, #16]	; (80001cc <__do_global_dtors_aux+0x20>)
 80001ba:	f3af 8000 	nop.w
 80001be:	2301      	movs	r3, #1
 80001c0:	7023      	strb	r3, [r4, #0]
 80001c2:	bd10      	pop	{r4, pc}
 80001c4:	20007f68 	.word	0x20007f68
 80001c8:	00000000 	.word	0x00000000
 80001cc:	0802e398 	.word	0x0802e398

080001d0 <frame_dummy>:
 80001d0:	b508      	push	{r3, lr}
 80001d2:	4b03      	ldr	r3, [pc, #12]	; (80001e0 <frame_dummy+0x10>)
 80001d4:	b11b      	cbz	r3, 80001de <frame_dummy+0xe>
 80001d6:	4903      	ldr	r1, [pc, #12]	; (80001e4 <frame_dummy+0x14>)
 80001d8:	4803      	ldr	r0, [pc, #12]	; (80001e8 <frame_dummy+0x18>)
 80001da:	f3af 8000 	nop.w
 80001de:	bd08      	pop	{r3, pc}
 80001e0:	00000000 	.word	0x00000000
 80001e4:	20007f6c 	.word	0x20007f6c
 80001e8:	0802e398 	.word	0x0802e398

080001ec <strcmp>:
 80001ec:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001f0:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001f4:	2a01      	cmp	r2, #1
 80001f6:	bf28      	it	cs
 80001f8:	429a      	cmpcs	r2, r3
 80001fa:	d0f7      	beq.n	80001ec <strcmp>
 80001fc:	1ad0      	subs	r0, r2, r3
 80001fe:	4770      	bx	lr

08000200 <strlen>:
 8000200:	4603      	mov	r3, r0
 8000202:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000206:	2a00      	cmp	r2, #0
 8000208:	d1fb      	bne.n	8000202 <strlen+0x2>
 800020a:	1a18      	subs	r0, r3, r0
 800020c:	3801      	subs	r0, #1
 800020e:	4770      	bx	lr

08000210 <__aeabi_uldivmod>:
 8000210:	b953      	cbnz	r3, 8000228 <__aeabi_uldivmod+0x18>
 8000212:	b94a      	cbnz	r2, 8000228 <__aeabi_uldivmod+0x18>
 8000214:	2900      	cmp	r1, #0
 8000216:	bf08      	it	eq
 8000218:	2800      	cmpeq	r0, #0
 800021a:	bf1c      	itt	ne
 800021c:	f04f 31ff 	movne.w	r1, #4294967295
 8000220:	f04f 30ff 	movne.w	r0, #4294967295
 8000224:	f000 b970 	b.w	8000508 <__aeabi_idiv0>
 8000228:	f1ad 0c08 	sub.w	ip, sp, #8
 800022c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000230:	f000 f806 	bl	8000240 <__udivmoddi4>
 8000234:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000238:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800023c:	b004      	add	sp, #16
 800023e:	4770      	bx	lr

08000240 <__udivmoddi4>:
 8000240:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000244:	9e08      	ldr	r6, [sp, #32]
 8000246:	460d      	mov	r5, r1
 8000248:	4604      	mov	r4, r0
 800024a:	460f      	mov	r7, r1
 800024c:	2b00      	cmp	r3, #0
 800024e:	d14a      	bne.n	80002e6 <__udivmoddi4+0xa6>
 8000250:	428a      	cmp	r2, r1
 8000252:	4694      	mov	ip, r2
 8000254:	d965      	bls.n	8000322 <__udivmoddi4+0xe2>
 8000256:	fab2 f382 	clz	r3, r2
 800025a:	b143      	cbz	r3, 800026e <__udivmoddi4+0x2e>
 800025c:	fa02 fc03 	lsl.w	ip, r2, r3
 8000260:	f1c3 0220 	rsb	r2, r3, #32
 8000264:	409f      	lsls	r7, r3
 8000266:	fa20 f202 	lsr.w	r2, r0, r2
 800026a:	4317      	orrs	r7, r2
 800026c:	409c      	lsls	r4, r3
 800026e:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 8000272:	fa1f f58c 	uxth.w	r5, ip
 8000276:	fbb7 f1fe 	udiv	r1, r7, lr
 800027a:	0c22      	lsrs	r2, r4, #16
 800027c:	fb0e 7711 	mls	r7, lr, r1, r7
 8000280:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8000284:	fb01 f005 	mul.w	r0, r1, r5
 8000288:	4290      	cmp	r0, r2
 800028a:	d90a      	bls.n	80002a2 <__udivmoddi4+0x62>
 800028c:	eb1c 0202 	adds.w	r2, ip, r2
 8000290:	f101 37ff 	add.w	r7, r1, #4294967295
 8000294:	f080 811c 	bcs.w	80004d0 <__udivmoddi4+0x290>
 8000298:	4290      	cmp	r0, r2
 800029a:	f240 8119 	bls.w	80004d0 <__udivmoddi4+0x290>
 800029e:	3902      	subs	r1, #2
 80002a0:	4462      	add	r2, ip
 80002a2:	1a12      	subs	r2, r2, r0
 80002a4:	b2a4      	uxth	r4, r4
 80002a6:	fbb2 f0fe 	udiv	r0, r2, lr
 80002aa:	fb0e 2210 	mls	r2, lr, r0, r2
 80002ae:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80002b2:	fb00 f505 	mul.w	r5, r0, r5
 80002b6:	42a5      	cmp	r5, r4
 80002b8:	d90a      	bls.n	80002d0 <__udivmoddi4+0x90>
 80002ba:	eb1c 0404 	adds.w	r4, ip, r4
 80002be:	f100 32ff 	add.w	r2, r0, #4294967295
 80002c2:	f080 8107 	bcs.w	80004d4 <__udivmoddi4+0x294>
 80002c6:	42a5      	cmp	r5, r4
 80002c8:	f240 8104 	bls.w	80004d4 <__udivmoddi4+0x294>
 80002cc:	4464      	add	r4, ip
 80002ce:	3802      	subs	r0, #2
 80002d0:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 80002d4:	1b64      	subs	r4, r4, r5
 80002d6:	2100      	movs	r1, #0
 80002d8:	b11e      	cbz	r6, 80002e2 <__udivmoddi4+0xa2>
 80002da:	40dc      	lsrs	r4, r3
 80002dc:	2300      	movs	r3, #0
 80002de:	e9c6 4300 	strd	r4, r3, [r6]
 80002e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002e6:	428b      	cmp	r3, r1
 80002e8:	d908      	bls.n	80002fc <__udivmoddi4+0xbc>
 80002ea:	2e00      	cmp	r6, #0
 80002ec:	f000 80ed 	beq.w	80004ca <__udivmoddi4+0x28a>
 80002f0:	2100      	movs	r1, #0
 80002f2:	e9c6 0500 	strd	r0, r5, [r6]
 80002f6:	4608      	mov	r0, r1
 80002f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80002fc:	fab3 f183 	clz	r1, r3
 8000300:	2900      	cmp	r1, #0
 8000302:	d149      	bne.n	8000398 <__udivmoddi4+0x158>
 8000304:	42ab      	cmp	r3, r5
 8000306:	d302      	bcc.n	800030e <__udivmoddi4+0xce>
 8000308:	4282      	cmp	r2, r0
 800030a:	f200 80f8 	bhi.w	80004fe <__udivmoddi4+0x2be>
 800030e:	1a84      	subs	r4, r0, r2
 8000310:	eb65 0203 	sbc.w	r2, r5, r3
 8000314:	2001      	movs	r0, #1
 8000316:	4617      	mov	r7, r2
 8000318:	2e00      	cmp	r6, #0
 800031a:	d0e2      	beq.n	80002e2 <__udivmoddi4+0xa2>
 800031c:	e9c6 4700 	strd	r4, r7, [r6]
 8000320:	e7df      	b.n	80002e2 <__udivmoddi4+0xa2>
 8000322:	b902      	cbnz	r2, 8000326 <__udivmoddi4+0xe6>
 8000324:	deff      	udf	#255	; 0xff
 8000326:	fab2 f382 	clz	r3, r2
 800032a:	2b00      	cmp	r3, #0
 800032c:	f040 8090 	bne.w	8000450 <__udivmoddi4+0x210>
 8000330:	1a8a      	subs	r2, r1, r2
 8000332:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000336:	fa1f fe8c 	uxth.w	lr, ip
 800033a:	2101      	movs	r1, #1
 800033c:	fbb2 f5f7 	udiv	r5, r2, r7
 8000340:	fb07 2015 	mls	r0, r7, r5, r2
 8000344:	0c22      	lsrs	r2, r4, #16
 8000346:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 800034a:	fb0e f005 	mul.w	r0, lr, r5
 800034e:	4290      	cmp	r0, r2
 8000350:	d908      	bls.n	8000364 <__udivmoddi4+0x124>
 8000352:	eb1c 0202 	adds.w	r2, ip, r2
 8000356:	f105 38ff 	add.w	r8, r5, #4294967295
 800035a:	d202      	bcs.n	8000362 <__udivmoddi4+0x122>
 800035c:	4290      	cmp	r0, r2
 800035e:	f200 80cb 	bhi.w	80004f8 <__udivmoddi4+0x2b8>
 8000362:	4645      	mov	r5, r8
 8000364:	1a12      	subs	r2, r2, r0
 8000366:	b2a4      	uxth	r4, r4
 8000368:	fbb2 f0f7 	udiv	r0, r2, r7
 800036c:	fb07 2210 	mls	r2, r7, r0, r2
 8000370:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000374:	fb0e fe00 	mul.w	lr, lr, r0
 8000378:	45a6      	cmp	lr, r4
 800037a:	d908      	bls.n	800038e <__udivmoddi4+0x14e>
 800037c:	eb1c 0404 	adds.w	r4, ip, r4
 8000380:	f100 32ff 	add.w	r2, r0, #4294967295
 8000384:	d202      	bcs.n	800038c <__udivmoddi4+0x14c>
 8000386:	45a6      	cmp	lr, r4
 8000388:	f200 80bb 	bhi.w	8000502 <__udivmoddi4+0x2c2>
 800038c:	4610      	mov	r0, r2
 800038e:	eba4 040e 	sub.w	r4, r4, lr
 8000392:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 8000396:	e79f      	b.n	80002d8 <__udivmoddi4+0x98>
 8000398:	f1c1 0720 	rsb	r7, r1, #32
 800039c:	408b      	lsls	r3, r1
 800039e:	fa22 fc07 	lsr.w	ip, r2, r7
 80003a2:	ea4c 0c03 	orr.w	ip, ip, r3
 80003a6:	fa05 f401 	lsl.w	r4, r5, r1
 80003aa:	fa20 f307 	lsr.w	r3, r0, r7
 80003ae:	40fd      	lsrs	r5, r7
 80003b0:	ea4f 491c 	mov.w	r9, ip, lsr #16
 80003b4:	4323      	orrs	r3, r4
 80003b6:	fbb5 f8f9 	udiv	r8, r5, r9
 80003ba:	fa1f fe8c 	uxth.w	lr, ip
 80003be:	fb09 5518 	mls	r5, r9, r8, r5
 80003c2:	0c1c      	lsrs	r4, r3, #16
 80003c4:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 80003c8:	fb08 f50e 	mul.w	r5, r8, lr
 80003cc:	42a5      	cmp	r5, r4
 80003ce:	fa02 f201 	lsl.w	r2, r2, r1
 80003d2:	fa00 f001 	lsl.w	r0, r0, r1
 80003d6:	d90b      	bls.n	80003f0 <__udivmoddi4+0x1b0>
 80003d8:	eb1c 0404 	adds.w	r4, ip, r4
 80003dc:	f108 3aff 	add.w	sl, r8, #4294967295
 80003e0:	f080 8088 	bcs.w	80004f4 <__udivmoddi4+0x2b4>
 80003e4:	42a5      	cmp	r5, r4
 80003e6:	f240 8085 	bls.w	80004f4 <__udivmoddi4+0x2b4>
 80003ea:	f1a8 0802 	sub.w	r8, r8, #2
 80003ee:	4464      	add	r4, ip
 80003f0:	1b64      	subs	r4, r4, r5
 80003f2:	b29d      	uxth	r5, r3
 80003f4:	fbb4 f3f9 	udiv	r3, r4, r9
 80003f8:	fb09 4413 	mls	r4, r9, r3, r4
 80003fc:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 8000400:	fb03 fe0e 	mul.w	lr, r3, lr
 8000404:	45a6      	cmp	lr, r4
 8000406:	d908      	bls.n	800041a <__udivmoddi4+0x1da>
 8000408:	eb1c 0404 	adds.w	r4, ip, r4
 800040c:	f103 35ff 	add.w	r5, r3, #4294967295
 8000410:	d26c      	bcs.n	80004ec <__udivmoddi4+0x2ac>
 8000412:	45a6      	cmp	lr, r4
 8000414:	d96a      	bls.n	80004ec <__udivmoddi4+0x2ac>
 8000416:	3b02      	subs	r3, #2
 8000418:	4464      	add	r4, ip
 800041a:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 800041e:	fba3 9502 	umull	r9, r5, r3, r2
 8000422:	eba4 040e 	sub.w	r4, r4, lr
 8000426:	42ac      	cmp	r4, r5
 8000428:	46c8      	mov	r8, r9
 800042a:	46ae      	mov	lr, r5
 800042c:	d356      	bcc.n	80004dc <__udivmoddi4+0x29c>
 800042e:	d053      	beq.n	80004d8 <__udivmoddi4+0x298>
 8000430:	b156      	cbz	r6, 8000448 <__udivmoddi4+0x208>
 8000432:	ebb0 0208 	subs.w	r2, r0, r8
 8000436:	eb64 040e 	sbc.w	r4, r4, lr
 800043a:	fa04 f707 	lsl.w	r7, r4, r7
 800043e:	40ca      	lsrs	r2, r1
 8000440:	40cc      	lsrs	r4, r1
 8000442:	4317      	orrs	r7, r2
 8000444:	e9c6 7400 	strd	r7, r4, [r6]
 8000448:	4618      	mov	r0, r3
 800044a:	2100      	movs	r1, #0
 800044c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000450:	f1c3 0120 	rsb	r1, r3, #32
 8000454:	fa02 fc03 	lsl.w	ip, r2, r3
 8000458:	fa20 f201 	lsr.w	r2, r0, r1
 800045c:	fa25 f101 	lsr.w	r1, r5, r1
 8000460:	409d      	lsls	r5, r3
 8000462:	432a      	orrs	r2, r5
 8000464:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000468:	fa1f fe8c 	uxth.w	lr, ip
 800046c:	fbb1 f0f7 	udiv	r0, r1, r7
 8000470:	fb07 1510 	mls	r5, r7, r0, r1
 8000474:	0c11      	lsrs	r1, r2, #16
 8000476:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 800047a:	fb00 f50e 	mul.w	r5, r0, lr
 800047e:	428d      	cmp	r5, r1
 8000480:	fa04 f403 	lsl.w	r4, r4, r3
 8000484:	d908      	bls.n	8000498 <__udivmoddi4+0x258>
 8000486:	eb1c 0101 	adds.w	r1, ip, r1
 800048a:	f100 38ff 	add.w	r8, r0, #4294967295
 800048e:	d22f      	bcs.n	80004f0 <__udivmoddi4+0x2b0>
 8000490:	428d      	cmp	r5, r1
 8000492:	d92d      	bls.n	80004f0 <__udivmoddi4+0x2b0>
 8000494:	3802      	subs	r0, #2
 8000496:	4461      	add	r1, ip
 8000498:	1b49      	subs	r1, r1, r5
 800049a:	b292      	uxth	r2, r2
 800049c:	fbb1 f5f7 	udiv	r5, r1, r7
 80004a0:	fb07 1115 	mls	r1, r7, r5, r1
 80004a4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80004a8:	fb05 f10e 	mul.w	r1, r5, lr
 80004ac:	4291      	cmp	r1, r2
 80004ae:	d908      	bls.n	80004c2 <__udivmoddi4+0x282>
 80004b0:	eb1c 0202 	adds.w	r2, ip, r2
 80004b4:	f105 38ff 	add.w	r8, r5, #4294967295
 80004b8:	d216      	bcs.n	80004e8 <__udivmoddi4+0x2a8>
 80004ba:	4291      	cmp	r1, r2
 80004bc:	d914      	bls.n	80004e8 <__udivmoddi4+0x2a8>
 80004be:	3d02      	subs	r5, #2
 80004c0:	4462      	add	r2, ip
 80004c2:	1a52      	subs	r2, r2, r1
 80004c4:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 80004c8:	e738      	b.n	800033c <__udivmoddi4+0xfc>
 80004ca:	4631      	mov	r1, r6
 80004cc:	4630      	mov	r0, r6
 80004ce:	e708      	b.n	80002e2 <__udivmoddi4+0xa2>
 80004d0:	4639      	mov	r1, r7
 80004d2:	e6e6      	b.n	80002a2 <__udivmoddi4+0x62>
 80004d4:	4610      	mov	r0, r2
 80004d6:	e6fb      	b.n	80002d0 <__udivmoddi4+0x90>
 80004d8:	4548      	cmp	r0, r9
 80004da:	d2a9      	bcs.n	8000430 <__udivmoddi4+0x1f0>
 80004dc:	ebb9 0802 	subs.w	r8, r9, r2
 80004e0:	eb65 0e0c 	sbc.w	lr, r5, ip
 80004e4:	3b01      	subs	r3, #1
 80004e6:	e7a3      	b.n	8000430 <__udivmoddi4+0x1f0>
 80004e8:	4645      	mov	r5, r8
 80004ea:	e7ea      	b.n	80004c2 <__udivmoddi4+0x282>
 80004ec:	462b      	mov	r3, r5
 80004ee:	e794      	b.n	800041a <__udivmoddi4+0x1da>
 80004f0:	4640      	mov	r0, r8
 80004f2:	e7d1      	b.n	8000498 <__udivmoddi4+0x258>
 80004f4:	46d0      	mov	r8, sl
 80004f6:	e77b      	b.n	80003f0 <__udivmoddi4+0x1b0>
 80004f8:	3d02      	subs	r5, #2
 80004fa:	4462      	add	r2, ip
 80004fc:	e732      	b.n	8000364 <__udivmoddi4+0x124>
 80004fe:	4608      	mov	r0, r1
 8000500:	e70a      	b.n	8000318 <__udivmoddi4+0xd8>
 8000502:	4464      	add	r4, ip
 8000504:	3802      	subs	r0, #2
 8000506:	e742      	b.n	800038e <__udivmoddi4+0x14e>

08000508 <__aeabi_idiv0>:
 8000508:	4770      	bx	lr
 800050a:	bf00      	nop

0800050c <lv_style_set_text_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_STR, value_str, const char *, _ptr, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_BLEND_MODE, text_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
 800050c:	b580      	push	{r7, lr}
 800050e:	b082      	sub	sp, #8
 8000510:	af00      	add	r7, sp, #0
 8000512:	6078      	str	r0, [r7, #4]
 8000514:	460b      	mov	r3, r1
 8000516:	803a      	strh	r2, [r7, #0]
 8000518:	70fb      	strb	r3, [r7, #3]
 800051a:	78fb      	ldrb	r3, [r7, #3]
 800051c:	021b      	lsls	r3, r3, #8
 800051e:	b21a      	sxth	r2, r3
 8000520:	4b05      	ldr	r3, [pc, #20]	; (8000538 <lv_style_set_text_color+0x2c>)
 8000522:	4313      	orrs	r3, r2
 8000524:	b21b      	sxth	r3, r3
 8000526:	b29b      	uxth	r3, r3
 8000528:	883a      	ldrh	r2, [r7, #0]
 800052a:	4619      	mov	r1, r3
 800052c:	6878      	ldr	r0, [r7, #4]
 800052e:	f00f f9e3 	bl	800f8f8 <_lv_style_set_color>
 8000532:	3708      	adds	r7, #8
 8000534:	46bd      	mov	sp, r7
 8000536:	bd80      	pop	{r7, pc}
 8000538:	ffff8089 	.word	0xffff8089

0800053c <lv_obj_set_style_local_text_font>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_SEL_COLOR, text_sel_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_OPA, text_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
 800053c:	b580      	push	{r7, lr}
 800053e:	b084      	sub	sp, #16
 8000540:	af00      	add	r7, sp, #0
 8000542:	60f8      	str	r0, [r7, #12]
 8000544:	607b      	str	r3, [r7, #4]
 8000546:	460b      	mov	r3, r1
 8000548:	72fb      	strb	r3, [r7, #11]
 800054a:	4613      	mov	r3, r2
 800054c:	72bb      	strb	r3, [r7, #10]
 800054e:	7abb      	ldrb	r3, [r7, #10]
 8000550:	021b      	lsls	r3, r3, #8
 8000552:	b21a      	sxth	r2, r3
 8000554:	4b05      	ldr	r3, [pc, #20]	; (800056c <lv_obj_set_style_local_text_font+0x30>)
 8000556:	4313      	orrs	r3, r2
 8000558:	b21b      	sxth	r3, r3
 800055a:	b29a      	uxth	r2, r3
 800055c:	7af9      	ldrb	r1, [r7, #11]
 800055e:	687b      	ldr	r3, [r7, #4]
 8000560:	68f8      	ldr	r0, [r7, #12]
 8000562:	f009 fea5 	bl	800a2b0 <_lv_obj_set_style_local_ptr>
 8000566:	3710      	adds	r7, #16
 8000568:	46bd      	mov	sp, r7
 800056a:	bd80      	pop	{r7, pc}
 800056c:	ffff808e 	.word	0xffff808e

08000570 <lv_scr_act>:
/**
 * Get the active screen of the default display
 * @return pointer to the active screen
 */
static inline lv_obj_t * lv_scr_act(void)
{
 8000570:	b580      	push	{r7, lr}
 8000572:	af00      	add	r7, sp, #0
    return lv_disp_get_scr_act(lv_disp_get_default());
 8000574:	f01e fa7e 	bl	801ea74 <lv_disp_get_default>
 8000578:	4603      	mov	r3, r0
 800057a:	4618      	mov	r0, r3
 800057c:	f007 fc8e 	bl	8007e9c <lv_disp_get_scr_act>
 8000580:	4603      	mov	r3, r0
}
 8000582:	4618      	mov	r0, r3
 8000584:	bd80      	pop	{r7, pc}

08000586 <lv_cont_set_fit>:
 * It tells how to change the container's size automatically.
 * @param cont pointer to a container object
 * @param fit fit policy from `lv_fit_t`
 */
static inline void lv_cont_set_fit(lv_obj_t * cont, lv_fit_t fit)
{
 8000586:	b580      	push	{r7, lr}
 8000588:	b084      	sub	sp, #16
 800058a:	af02      	add	r7, sp, #8
 800058c:	6078      	str	r0, [r7, #4]
 800058e:	460b      	mov	r3, r1
 8000590:	70fb      	strb	r3, [r7, #3]
    lv_cont_set_fit4(cont, fit, fit, fit, fit);
 8000592:	78f8      	ldrb	r0, [r7, #3]
 8000594:	78fa      	ldrb	r2, [r7, #3]
 8000596:	78f9      	ldrb	r1, [r7, #3]
 8000598:	78fb      	ldrb	r3, [r7, #3]
 800059a:	9300      	str	r3, [sp, #0]
 800059c:	4603      	mov	r3, r0
 800059e:	6878      	ldr	r0, [r7, #4]
 80005a0:	f029 fb0e 	bl	8029bc0 <lv_cont_set_fit4>
}
 80005a4:	bf00      	nop
 80005a6:	3708      	adds	r7, #8
 80005a8:	46bd      	mov	sp, r7
 80005aa:	bd80      	pop	{r7, pc}

080005ac <SDRAM_Initialization_Sequence>:
#define SDRAM_MODEREG_WRITEBURST_MODE_SINGLE     ((uint16_t)0x0200)

#define REFRESH_COUNT       ((uint32_t)1835)   /* SDRAM refresh counter (90MHz SD clock) */

void SDRAM_Initialization_Sequence(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command)
{
 80005ac:	b580      	push	{r7, lr}
 80005ae:	b084      	sub	sp, #16
 80005b0:	af00      	add	r7, sp, #0
 80005b2:	6078      	str	r0, [r7, #4]
 80005b4:	6039      	str	r1, [r7, #0]
  __IO uint32_t tmpmrd =0;
 80005b6:	2300      	movs	r3, #0
 80005b8:	60fb      	str	r3, [r7, #12]
  /* Step 3:  Configure a clock configuration enable command */
  Command->CommandMode 			 = FMC_SDRAM_CMD_CLK_ENABLE;
 80005ba:	683b      	ldr	r3, [r7, #0]
 80005bc:	2201      	movs	r2, #1
 80005be:	601a      	str	r2, [r3, #0]
  Command->CommandTarget 		 = FMC_SDRAM_CMD_TARGET_BANK1;
 80005c0:	683b      	ldr	r3, [r7, #0]
 80005c2:	2210      	movs	r2, #16
 80005c4:	605a      	str	r2, [r3, #4]
  Command->AutoRefreshNumber 	 = 1;
 80005c6:	683b      	ldr	r3, [r7, #0]
 80005c8:	2201      	movs	r2, #1
 80005ca:	609a      	str	r2, [r3, #8]
  Command->ModeRegisterDefinition = 0;
 80005cc:	683b      	ldr	r3, [r7, #0]
 80005ce:	2200      	movs	r2, #0
 80005d0:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(hsdram, Command, 0x1000);
 80005d2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80005d6:	6839      	ldr	r1, [r7, #0]
 80005d8:	6878      	ldr	r0, [r7, #4]
 80005da:	f003 fef9 	bl	80043d0 <HAL_SDRAM_SendCommand>

  /* Step 4: Insert 100 ms delay */
  HAL_Delay(100);
 80005de:	2064      	movs	r0, #100	; 0x64
 80005e0:	f000 fed4 	bl	800138c <HAL_Delay>

  /* Step 5: Configure a PALL (precharge all) command */
  Command->CommandMode 			 = FMC_SDRAM_CMD_PALL;
 80005e4:	683b      	ldr	r3, [r7, #0]
 80005e6:	2202      	movs	r2, #2
 80005e8:	601a      	str	r2, [r3, #0]
  Command->CommandTarget 	     = FMC_SDRAM_CMD_TARGET_BANK1;
 80005ea:	683b      	ldr	r3, [r7, #0]
 80005ec:	2210      	movs	r2, #16
 80005ee:	605a      	str	r2, [r3, #4]
  Command->AutoRefreshNumber 	 = 1;
 80005f0:	683b      	ldr	r3, [r7, #0]
 80005f2:	2201      	movs	r2, #1
 80005f4:	609a      	str	r2, [r3, #8]
  Command->ModeRegisterDefinition = 0;
 80005f6:	683b      	ldr	r3, [r7, #0]
 80005f8:	2200      	movs	r2, #0
 80005fa:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(hsdram, Command, 0x1000);
 80005fc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000600:	6839      	ldr	r1, [r7, #0]
 8000602:	6878      	ldr	r0, [r7, #4]
 8000604:	f003 fee4 	bl	80043d0 <HAL_SDRAM_SendCommand>

  /* Step 6 : Configure a Auto-Refresh command */
  Command->CommandMode 			 = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 8000608:	683b      	ldr	r3, [r7, #0]
 800060a:	2203      	movs	r2, #3
 800060c:	601a      	str	r2, [r3, #0]
  Command->CommandTarget 		 = FMC_SDRAM_CMD_TARGET_BANK1;
 800060e:	683b      	ldr	r3, [r7, #0]
 8000610:	2210      	movs	r2, #16
 8000612:	605a      	str	r2, [r3, #4]
  Command->AutoRefreshNumber 	 = 8;
 8000614:	683b      	ldr	r3, [r7, #0]
 8000616:	2208      	movs	r2, #8
 8000618:	609a      	str	r2, [r3, #8]
  Command->ModeRegisterDefinition = 0;
 800061a:	683b      	ldr	r3, [r7, #0]
 800061c:	2200      	movs	r2, #0
 800061e:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(hsdram, Command, 0x1000);
 8000620:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000624:	6839      	ldr	r1, [r7, #0]
 8000626:	6878      	ldr	r0, [r7, #4]
 8000628:	f003 fed2 	bl	80043d0 <HAL_SDRAM_SendCommand>

  /* Step 7: Program the external memory mode register */
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_2          |
 800062c:	f240 2331 	movw	r3, #561	; 0x231
 8000630:	60fb      	str	r3, [r7, #12]
    SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |
      SDRAM_MODEREG_CAS_LATENCY_3           |
        SDRAM_MODEREG_OPERATING_MODE_STANDARD |
          SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;

  Command->CommandMode           = FMC_SDRAM_CMD_LOAD_MODE;
 8000632:	683b      	ldr	r3, [r7, #0]
 8000634:	2204      	movs	r2, #4
 8000636:	601a      	str	r2, [r3, #0]
  Command->CommandTarget 	 = FMC_SDRAM_CMD_TARGET_BANK1;
 8000638:	683b      	ldr	r3, [r7, #0]
 800063a:	2210      	movs	r2, #16
 800063c:	605a      	str	r2, [r3, #4]
  Command->AutoRefreshNumber 	 = 1;
 800063e:	683b      	ldr	r3, [r7, #0]
 8000640:	2201      	movs	r2, #1
 8000642:	609a      	str	r2, [r3, #8]
  Command->ModeRegisterDefinition = 0x0220;
 8000644:	683b      	ldr	r3, [r7, #0]
 8000646:	f44f 7208 	mov.w	r2, #544	; 0x220
 800064a:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(hsdram, Command, 0x1000);
 800064c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8000650:	6839      	ldr	r1, [r7, #0]
 8000652:	6878      	ldr	r0, [r7, #4]
 8000654:	f003 febc 	bl	80043d0 <HAL_SDRAM_SendCommand>

  /* Step 8: Set the refresh rate counter */
  /* (15.62 us x Freq) - 20 */
  /* Set the device refresh counter */
  HAL_SDRAM_ProgramRefreshRate(hsdram, REFRESH_COUNT);
 8000658:	f240 712b 	movw	r1, #1835	; 0x72b
 800065c:	6878      	ldr	r0, [r7, #4]
 800065e:	f003 fee2 	bl	8004426 <HAL_SDRAM_ProgramRefreshRate>
}
 8000662:	bf00      	nop
 8000664:	3710      	adds	r7, #16
 8000666:	46bd      	mov	sp, r7
 8000668:	bd80      	pop	{r7, pc}
	...

0800066c <monitor_cb>:
 */


static volatile uint32_t t_saved = 0;
void monitor_cb(lv_disp_drv_t * d, uint32_t t, uint32_t p)
{
 800066c:	b480      	push	{r7}
 800066e:	b085      	sub	sp, #20
 8000670:	af00      	add	r7, sp, #0
 8000672:	60f8      	str	r0, [r7, #12]
 8000674:	60b9      	str	r1, [r7, #8]
 8000676:	607a      	str	r2, [r7, #4]
	t_saved = t;
 8000678:	4a04      	ldr	r2, [pc, #16]	; (800068c <monitor_cb+0x20>)
 800067a:	68bb      	ldr	r3, [r7, #8]
 800067c:	6013      	str	r3, [r2, #0]
}
 800067e:	bf00      	nop
 8000680:	3714      	adds	r7, #20
 8000682:	46bd      	mov	sp, r7
 8000684:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000688:	4770      	bx	lr
 800068a:	bf00      	nop
 800068c:	20007f84 	.word	0x20007f84

08000690 <tft_flush>:
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

static void tft_flush(lv_disp_drv_t * drv, const lv_area_t * area, lv_color_t * color_p) {
 8000690:	b580      	push	{r7, lr}
 8000692:	b088      	sub	sp, #32
 8000694:	af00      	add	r7, sp, #0
 8000696:	60f8      	str	r0, [r7, #12]
 8000698:	60b9      	str	r1, [r7, #8]
 800069a:	607a      	str	r2, [r7, #4]

	int16_t x1, y1,x2,y2;
	x1=area->x1;
 800069c:	68bb      	ldr	r3, [r7, #8]
 800069e:	881b      	ldrh	r3, [r3, #0]
 80006a0:	83fb      	strh	r3, [r7, #30]
	x2=area->x2;
 80006a2:	68bb      	ldr	r3, [r7, #8]
 80006a4:	889b      	ldrh	r3, [r3, #4]
 80006a6:	837b      	strh	r3, [r7, #26]
	y1=area->y1;
 80006a8:	68bb      	ldr	r3, [r7, #8]
 80006aa:	885b      	ldrh	r3, [r3, #2]
 80006ac:	83bb      	strh	r3, [r7, #28]
	y2=area->y2;
 80006ae:	68bb      	ldr	r3, [r7, #8]
 80006b0:	88db      	ldrh	r3, [r3, #6]
 80006b2:	833b      	strh	r3, [r7, #24]
	if (x2>799)
 80006b4:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80006b8:	f5b3 7f48 	cmp.w	r3, #800	; 0x320
 80006bc:	db02      	blt.n	80006c4 <tft_flush+0x34>
		x2=799;
 80006be:	f240 331f 	movw	r3, #799	; 0x31f
 80006c2:	837b      	strh	r3, [r7, #26]
	if (y2>479)
 80006c4:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80006c8:	f5b3 7ff0 	cmp.w	r3, #480	; 0x1e0
 80006cc:	db02      	blt.n	80006d4 <tft_flush+0x44>
		y2=479;
 80006ce:	f240 13df 	movw	r3, #479	; 0x1df
 80006d2:	833b      	strh	r3, [r7, #24]
	if (y1<0)
 80006d4:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 80006d8:	2b00      	cmp	r3, #0
 80006da:	da01      	bge.n	80006e0 <tft_flush+0x50>
		y1=0;
 80006dc:	2300      	movs	r3, #0
 80006de:	83bb      	strh	r3, [r7, #28]
	if (y2<0)
 80006e0:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80006e4:	2b00      	cmp	r3, #0
 80006e6:	da01      	bge.n	80006ec <tft_flush+0x5c>
		y2=0;
 80006e8:	2300      	movs	r3, #0
 80006ea:	833b      	strh	r3, [r7, #24]
	if (x1<0)
 80006ec:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80006f0:	2b00      	cmp	r3, #0
 80006f2:	da01      	bge.n	80006f8 <tft_flush+0x68>
		x1=0;
 80006f4:	2300      	movs	r3, #0
 80006f6:	83fb      	strh	r3, [r7, #30]
	if (x2<0)
 80006f8:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80006fc:	2b00      	cmp	r3, #0
 80006fe:	da01      	bge.n	8000704 <tft_flush+0x74>
		x2=0;
 8000700:	2300      	movs	r3, #0
 8000702:	837b      	strh	r3, [r7, #26]
//lcd_fb = ( uint16_t*) (0xC0000000);
	for(int y = y1; y <= y2; y++) {
 8000704:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8000708:	617b      	str	r3, [r7, #20]
 800070a:	e01e      	b.n	800074a <tft_flush+0xba>
		for(int x = x1; x <= x2; x++) {
 800070c:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8000710:	613b      	str	r3, [r7, #16]
 8000712:	e012      	b.n	800073a <tft_flush+0xaa>
			lcd_fb[x+(y * MY_DISP_HOR_RES)]=(color_p++->full);  //pixelColor;
 8000714:	687b      	ldr	r3, [r7, #4]
 8000716:	1c9a      	adds	r2, r3, #2
 8000718:	607a      	str	r2, [r7, #4]
 800071a:	4a12      	ldr	r2, [pc, #72]	; (8000764 <tft_flush+0xd4>)
 800071c:	6811      	ldr	r1, [r2, #0]
 800071e:	697a      	ldr	r2, [r7, #20]
 8000720:	f44f 7048 	mov.w	r0, #800	; 0x320
 8000724:	fb02 f000 	mul.w	r0, r2, r0
 8000728:	693a      	ldr	r2, [r7, #16]
 800072a:	4402      	add	r2, r0
 800072c:	0052      	lsls	r2, r2, #1
 800072e:	440a      	add	r2, r1
 8000730:	881b      	ldrh	r3, [r3, #0]
 8000732:	8013      	strh	r3, [r2, #0]
		for(int x = x1; x <= x2; x++) {
 8000734:	693b      	ldr	r3, [r7, #16]
 8000736:	3301      	adds	r3, #1
 8000738:	613b      	str	r3, [r7, #16]
 800073a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800073e:	693a      	ldr	r2, [r7, #16]
 8000740:	429a      	cmp	r2, r3
 8000742:	dde7      	ble.n	8000714 <tft_flush+0x84>
	for(int y = y1; y <= y2; y++) {
 8000744:	697b      	ldr	r3, [r7, #20]
 8000746:	3301      	adds	r3, #1
 8000748:	617b      	str	r3, [r7, #20]
 800074a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800074e:	697a      	ldr	r2, [r7, #20]
 8000750:	429a      	cmp	r2, r3
 8000752:	dddb      	ble.n	800070c <tft_flush+0x7c>
		}
	}
	lv_disp_flush_ready(drv);
 8000754:	68f8      	ldr	r0, [r7, #12]
 8000756:	f01e fa2f 	bl	801ebb8 <lv_disp_flush_ready>
}
 800075a:	bf00      	nop
 800075c:	3720      	adds	r7, #32
 800075e:	46bd      	mov	sp, r7
 8000760:	bd80      	pop	{r7, pc}
 8000762:	bf00      	nop
 8000764:	20000000 	.word	0x20000000

08000768 <navBarPlugzmart>:
lv_color_t red_color = LV_COLOR_MAKE(255, 0, 0);
LV_IMG_DECLARE(img_cogwheel_argb);
LV_IMG_DECLARE(img_cogwheel_argb2);
void navBarPlugzmart(void)
{
 8000768:	b580      	push	{r7, lr}
 800076a:	b088      	sub	sp, #32
 800076c:	af02      	add	r7, sp, #8
    lv_obj_t * cont = lv_cont_create(lv_scr_act(), NULL);
 800076e:	f7ff feff 	bl	8000570 <lv_scr_act>
 8000772:	4603      	mov	r3, r0
 8000774:	2100      	movs	r1, #0
 8000776:	4618      	mov	r0, r3
 8000778:	f029 f956 	bl	8029a28 <lv_cont_create>
 800077c:	6178      	str	r0, [r7, #20]
    lv_cont_set_fit(cont, LV_FIT_TIGHT);
 800077e:	2101      	movs	r1, #1
 8000780:	6978      	ldr	r0, [r7, #20]
 8000782:	f7ff ff00 	bl	8000586 <lv_cont_set_fit>

    /* Create and configure image 1 */
    lv_obj_t * img1 = lv_img_create(cont, NULL);
 8000786:	2100      	movs	r1, #0
 8000788:	6978      	ldr	r0, [r7, #20]
 800078a:	f02a fbbf 	bl	802af0c <lv_img_create>
 800078e:	6138      	str	r0, [r7, #16]
    lv_img_set_src(img1, &img_cogwheel_argb);
 8000790:	4924      	ldr	r1, [pc, #144]	; (8000824 <navBarPlugzmart+0xbc>)
 8000792:	6938      	ldr	r0, [r7, #16]
 8000794:	f02a fcb2 	bl	802b0fc <lv_img_set_src>
    lv_obj_align(img1, NULL, LV_ALIGN_IN_TOP_MID, 0, 15);
 8000798:	230f      	movs	r3, #15
 800079a:	9300      	str	r3, [sp, #0]
 800079c:	2300      	movs	r3, #0
 800079e:	2202      	movs	r2, #2
 80007a0:	2100      	movs	r1, #0
 80007a2:	6938      	ldr	r0, [r7, #16]
 80007a4:	f009 fc1a 	bl	8009fdc <lv_obj_align>

    /* Create and configure image 2 */
    lv_obj_t * img2 = lv_img_create(cont, NULL);
 80007a8:	2100      	movs	r1, #0
 80007aa:	6978      	ldr	r0, [r7, #20]
 80007ac:	f02a fbae 	bl	802af0c <lv_img_create>
 80007b0:	60f8      	str	r0, [r7, #12]
    lv_img_set_src(img2, &img_cogwheel_argb2);
 80007b2:	491d      	ldr	r1, [pc, #116]	; (8000828 <navBarPlugzmart+0xc0>)
 80007b4:	68f8      	ldr	r0, [r7, #12]
 80007b6:	f02a fca1 	bl	802b0fc <lv_img_set_src>
    lv_obj_align(img2, img1, LV_ALIGN_OUT_BOTTOM_MID, 0, 20);
 80007ba:	2314      	movs	r3, #20
 80007bc:	9300      	str	r3, [sp, #0]
 80007be:	2300      	movs	r3, #0
 80007c0:	220d      	movs	r2, #13
 80007c2:	6939      	ldr	r1, [r7, #16]
 80007c4:	68f8      	ldr	r0, [r7, #12]
 80007c6:	f009 fc09 	bl	8009fdc <lv_obj_align>

    /* Create and configure the label */
    lv_obj_t * label = lv_label_create(cont, NULL);
 80007ca:	2100      	movs	r1, #0
 80007cc:	6978      	ldr	r0, [r7, #20]
 80007ce:	f02b fe63 	bl	802c498 <lv_label_create>
 80007d2:	60b8      	str	r0, [r7, #8]
    lv_label_set_text(label, "DISCONNECTED");
 80007d4:	4915      	ldr	r1, [pc, #84]	; (800082c <navBarPlugzmart+0xc4>)
 80007d6:	68b8      	ldr	r0, [r7, #8]
 80007d8:	f02b ffb0 	bl	802c73c <lv_label_set_text>

    lv_style_t style;
	lv_style_init(&style);
 80007dc:	1d3b      	adds	r3, r7, #4
 80007de:	4618      	mov	r0, r3
 80007e0:	f00e fcb7 	bl	800f152 <lv_style_init>
	lv_style_set_text_color(&style, LV_STATE_DEFAULT, red_color);
 80007e4:	4a12      	ldr	r2, [pc, #72]	; (8000830 <navBarPlugzmart+0xc8>)
 80007e6:	1d3b      	adds	r3, r7, #4
 80007e8:	8812      	ldrh	r2, [r2, #0]
 80007ea:	2100      	movs	r1, #0
 80007ec:	4618      	mov	r0, r3
 80007ee:	f7ff fe8d 	bl	800050c <lv_style_set_text_color>
	lv_obj_add_style(label, LV_LABEL_PART_MAIN, &style);
 80007f2:	1d3b      	adds	r3, r7, #4
 80007f4:	461a      	mov	r2, r3
 80007f6:	2100      	movs	r1, #0
 80007f8:	68b8      	ldr	r0, [r7, #8]
 80007fa:	f009 fcfd 	bl	800a1f8 <lv_obj_add_style>
	lv_obj_set_style_local_text_font(label, LV_LABEL_PART_MAIN, LV_STATE_DEFAULT, &lv_font_montserrat_28);
 80007fe:	4b0d      	ldr	r3, [pc, #52]	; (8000834 <navBarPlugzmart+0xcc>)
 8000800:	2200      	movs	r2, #0
 8000802:	2100      	movs	r1, #0
 8000804:	68b8      	ldr	r0, [r7, #8]
 8000806:	f7ff fe99 	bl	800053c <lv_obj_set_style_local_text_font>

    /* Position the label relative to image 2 */
    lv_obj_align(label, img2, LV_ALIGN_IN_BOTTOM_MID, 0, -25);
 800080a:	f06f 0318 	mvn.w	r3, #24
 800080e:	9300      	str	r3, [sp, #0]
 8000810:	2300      	movs	r3, #0
 8000812:	2205      	movs	r2, #5
 8000814:	68f9      	ldr	r1, [r7, #12]
 8000816:	68b8      	ldr	r0, [r7, #8]
 8000818:	f009 fbe0 	bl	8009fdc <lv_obj_align>
}
 800081c:	bf00      	nop
 800081e:	3718      	adds	r7, #24
 8000820:	46bd      	mov	sp, r7
 8000822:	bd80      	pop	{r7, pc}
 8000824:	0805573c 	.word	0x0805573c
 8000828:	080e5fc8 	.word	0x080e5fc8
 800082c:	0802e3b0 	.word	0x0802e3b0
 8000830:	20000004 	.word	0x20000004
 8000834:	200001dc 	.word	0x200001dc

08000838 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8000838:	b580      	push	{r7, lr}
 800083a:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800083c:	f000 fd34 	bl	80012a8 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8000840:	f000 f83c 	bl	80008bc <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8000844:	f000 fa10 	bl	8000c68 <MX_GPIO_Init>
  MX_LTDC_Init();
 8000848:	f000 f902 	bl	8000a50 <MX_LTDC_Init>
  MX_FMC_Init();
 800084c:	f000 f9b6 	bl	8000bbc <MX_FMC_Init>
  MX_CRC_Init();
 8000850:	f000 f8b8 	bl	80009c4 <MX_CRC_Init>
  MX_DMA2D_Init();
 8000854:	f000 f8ca 	bl	80009ec <MX_DMA2D_Init>
  MX_USB_DEVICE_Init();
 8000858:	f006 fe44 	bl	80074e4 <MX_USB_DEVICE_Init>
//	for (int i=0; i<32000;i++)
//	{
//	*test=0x37E0;//0xFFFF;
//	test++;
//	}
   lv_init();
 800085c:	f008 fd06 	bl	800926c <lv_init>
   /*Initialize `disp_buf` with the buffer(s) */
   lv_disp_buf_init(&disp_buf, buf_1, buf_2, MY_DISP_HOR_RES*10);
 8000860:	f44f 53fa 	mov.w	r3, #8000	; 0x1f40
 8000864:	4a0f      	ldr	r2, [pc, #60]	; (80008a4 <main+0x6c>)
 8000866:	4910      	ldr	r1, [pc, #64]	; (80008a8 <main+0x70>)
 8000868:	4810      	ldr	r0, [pc, #64]	; (80008ac <main+0x74>)
 800086a:	f01e f814 	bl	801e896 <lv_disp_buf_init>
   lv_disp_drv_init(&disp_drv);
 800086e:	4810      	ldr	r0, [pc, #64]	; (80008b0 <main+0x78>)
 8000870:	f01d ffcb 	bl	801e80a <lv_disp_drv_init>
   disp_drv.buffer = &disp_buf;
 8000874:	4b0e      	ldr	r3, [pc, #56]	; (80008b0 <main+0x78>)
 8000876:	4a0d      	ldr	r2, [pc, #52]	; (80008ac <main+0x74>)
 8000878:	605a      	str	r2, [r3, #4]
   disp_drv.flush_cb = tft_flush;
 800087a:	4b0d      	ldr	r3, [pc, #52]	; (80008b0 <main+0x78>)
 800087c:	4a0d      	ldr	r2, [pc, #52]	; (80008b4 <main+0x7c>)
 800087e:	60da      	str	r2, [r3, #12]
   disp_drv.monitor_cb = monitor_cb;
 8000880:	4b0b      	ldr	r3, [pc, #44]	; (80008b0 <main+0x78>)
 8000882:	4a0d      	ldr	r2, [pc, #52]	; (80008b8 <main+0x80>)
 8000884:	619a      	str	r2, [r3, #24]
   lv_disp_drv_register(&disp_drv);
 8000886:	480a      	ldr	r0, [pc, #40]	; (80008b0 <main+0x78>)
 8000888:	f01e f822 	bl	801e8d0 <lv_disp_drv_register>
   //lv_demo_widgets();
		//lv_demo_stress();
   //lv_demo_benchmark();
   navBarPlugzmart();
 800088c:	f7ff ff6c 	bl	8000768 <navBarPlugzmart>

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    HAL_Delay(10);
 8000890:	200a      	movs	r0, #10
 8000892:	f000 fd7b 	bl	800138c <HAL_Delay>
    lv_tick_inc(30);
 8000896:	201e      	movs	r0, #30
 8000898:	f01e fa14 	bl	801ecc4 <lv_tick_inc>
    lv_task_handler();
 800089c:	f021 f8be 	bl	8021a1c <lv_task_handler>
    HAL_Delay(10);
 80008a0:	e7f6      	b.n	8000890 <main+0x58>
 80008a2:	bf00      	nop
 80008a4:	200040e8 	.word	0x200040e8
 80008a8:	20000268 	.word	0x20000268
 80008ac:	200080ac 	.word	0x200080ac
 80008b0:	200080d0 	.word	0x200080d0
 80008b4:	08000691 	.word	0x08000691
 80008b8:	0800066d 	.word	0x0800066d

080008bc <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80008bc:	b580      	push	{r7, lr}
 80008be:	b0a0      	sub	sp, #128	; 0x80
 80008c0:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80008c2:	f107 0350 	add.w	r3, r7, #80	; 0x50
 80008c6:	2230      	movs	r2, #48	; 0x30
 80008c8:	2100      	movs	r1, #0
 80008ca:	4618      	mov	r0, r3
 80008cc:	f02d fccc 	bl	802e268 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80008d0:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 80008d4:	2200      	movs	r2, #0
 80008d6:	601a      	str	r2, [r3, #0]
 80008d8:	605a      	str	r2, [r3, #4]
 80008da:	609a      	str	r2, [r3, #8]
 80008dc:	60da      	str	r2, [r3, #12]
 80008de:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80008e0:	f107 030c 	add.w	r3, r7, #12
 80008e4:	2230      	movs	r2, #48	; 0x30
 80008e6:	2100      	movs	r1, #0
 80008e8:	4618      	mov	r0, r3
 80008ea:	f02d fcbd 	bl	802e268 <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 80008ee:	2300      	movs	r3, #0
 80008f0:	60bb      	str	r3, [r7, #8]
 80008f2:	4b32      	ldr	r3, [pc, #200]	; (80009bc <SystemClock_Config+0x100>)
 80008f4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80008f6:	4a31      	ldr	r2, [pc, #196]	; (80009bc <SystemClock_Config+0x100>)
 80008f8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80008fc:	6413      	str	r3, [r2, #64]	; 0x40
 80008fe:	4b2f      	ldr	r3, [pc, #188]	; (80009bc <SystemClock_Config+0x100>)
 8000900:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000902:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000906:	60bb      	str	r3, [r7, #8]
 8000908:	68bb      	ldr	r3, [r7, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800090a:	2300      	movs	r3, #0
 800090c:	607b      	str	r3, [r7, #4]
 800090e:	4b2c      	ldr	r3, [pc, #176]	; (80009c0 <SystemClock_Config+0x104>)
 8000910:	681b      	ldr	r3, [r3, #0]
 8000912:	4a2b      	ldr	r2, [pc, #172]	; (80009c0 <SystemClock_Config+0x104>)
 8000914:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8000918:	6013      	str	r3, [r2, #0]
 800091a:	4b29      	ldr	r3, [pc, #164]	; (80009c0 <SystemClock_Config+0x104>)
 800091c:	681b      	ldr	r3, [r3, #0]
 800091e:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8000922:	607b      	str	r3, [r7, #4]
 8000924:	687b      	ldr	r3, [r7, #4]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000926:	2301      	movs	r3, #1
 8000928:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800092a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800092e:	657b      	str	r3, [r7, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000930:	2302      	movs	r3, #2
 8000932:	66bb      	str	r3, [r7, #104]	; 0x68
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000934:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8000938:	66fb      	str	r3, [r7, #108]	; 0x6c
  RCC_OscInitStruct.PLL.PLLM = 25;
 800093a:	2319      	movs	r3, #25
 800093c:	673b      	str	r3, [r7, #112]	; 0x70
  RCC_OscInitStruct.PLL.PLLN = 288;
 800093e:	f44f 7390 	mov.w	r3, #288	; 0x120
 8000942:	677b      	str	r3, [r7, #116]	; 0x74
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8000944:	2302      	movs	r3, #2
 8000946:	67bb      	str	r3, [r7, #120]	; 0x78
  RCC_OscInitStruct.PLL.PLLQ = 6;
 8000948:	2306      	movs	r3, #6
 800094a:	67fb      	str	r3, [r7, #124]	; 0x7c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800094c:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8000950:	4618      	mov	r0, r3
 8000952:	f002 ff07 	bl	8003764 <HAL_RCC_OscConfig>
 8000956:	4603      	mov	r3, r0
 8000958:	2b00      	cmp	r3, #0
 800095a:	d001      	beq.n	8000960 <SystemClock_Config+0xa4>
  {
    Error_Handler();
 800095c:	f000 fa28 	bl	8000db0 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000960:	230f      	movs	r3, #15
 8000962:	63fb      	str	r3, [r7, #60]	; 0x3c
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000964:	2302      	movs	r3, #2
 8000966:	643b      	str	r3, [r7, #64]	; 0x40
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000968:	2300      	movs	r3, #0
 800096a:	647b      	str	r3, [r7, #68]	; 0x44
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 800096c:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8000970:	64bb      	str	r3, [r7, #72]	; 0x48
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 8000972:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000976:	64fb      	str	r3, [r7, #76]	; 0x4c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000978:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800097c:	2104      	movs	r1, #4
 800097e:	4618      	mov	r0, r3
 8000980:	f003 f95e 	bl	8003c40 <HAL_RCC_ClockConfig>
 8000984:	4603      	mov	r3, r0
 8000986:	2b00      	cmp	r3, #0
 8000988:	d001      	beq.n	800098e <SystemClock_Config+0xd2>
  {
    Error_Handler();
 800098a:	f000 fa11 	bl	8000db0 <Error_Handler>
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 800098e:	2308      	movs	r3, #8
 8000990:	60fb      	str	r3, [r7, #12]
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 200;
 8000992:	23c8      	movs	r3, #200	; 0xc8
 8000994:	61fb      	str	r3, [r7, #28]
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 3;
 8000996:	2303      	movs	r3, #3
 8000998:	627b      	str	r3, [r7, #36]	; 0x24
  PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_2;
 800099a:	2300      	movs	r3, #0
 800099c:	633b      	str	r3, [r7, #48]	; 0x30
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800099e:	f107 030c 	add.w	r3, r7, #12
 80009a2:	4618      	mov	r0, r3
 80009a4:	f003 fb20 	bl	8003fe8 <HAL_RCCEx_PeriphCLKConfig>
 80009a8:	4603      	mov	r3, r0
 80009aa:	2b00      	cmp	r3, #0
 80009ac:	d001      	beq.n	80009b2 <SystemClock_Config+0xf6>
  {
    Error_Handler();
 80009ae:	f000 f9ff 	bl	8000db0 <Error_Handler>
  }
}
 80009b2:	bf00      	nop
 80009b4:	3780      	adds	r7, #128	; 0x80
 80009b6:	46bd      	mov	sp, r7
 80009b8:	bd80      	pop	{r7, pc}
 80009ba:	bf00      	nop
 80009bc:	40023800 	.word	0x40023800
 80009c0:	40007000 	.word	0x40007000

080009c4 <MX_CRC_Init>:
  * @brief CRC Initialization Function
  * @param None
  * @retval None
  */
static void MX_CRC_Init(void)
{
 80009c4:	b580      	push	{r7, lr}
 80009c6:	af00      	add	r7, sp, #0
  /* USER CODE END CRC_Init 0 */

  /* USER CODE BEGIN CRC_Init 1 */

  /* USER CODE END CRC_Init 1 */
  hcrc.Instance = CRC;
 80009c8:	4b06      	ldr	r3, [pc, #24]	; (80009e4 <MX_CRC_Init+0x20>)
 80009ca:	4a07      	ldr	r2, [pc, #28]	; (80009e8 <MX_CRC_Init+0x24>)
 80009cc:	601a      	str	r2, [r3, #0]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 80009ce:	4805      	ldr	r0, [pc, #20]	; (80009e4 <MX_CRC_Init+0x20>)
 80009d0:	f000 fe11 	bl	80015f6 <HAL_CRC_Init>
 80009d4:	4603      	mov	r3, r0
 80009d6:	2b00      	cmp	r3, #0
 80009d8:	d001      	beq.n	80009de <MX_CRC_Init+0x1a>
  {
    Error_Handler();
 80009da:	f000 f9e9 	bl	8000db0 <Error_Handler>
  }
  /* USER CODE BEGIN CRC_Init 2 */

  /* USER CODE END CRC_Init 2 */

}
 80009de:	bf00      	nop
 80009e0:	bd80      	pop	{r7, pc}
 80009e2:	bf00      	nop
 80009e4:	20007f88 	.word	0x20007f88
 80009e8:	40023000 	.word	0x40023000

080009ec <MX_DMA2D_Init>:
  * @brief DMA2D Initialization Function
  * @param None
  * @retval None
  */
static void MX_DMA2D_Init(void)
{
 80009ec:	b580      	push	{r7, lr}
 80009ee:	af00      	add	r7, sp, #0
  /* USER CODE END DMA2D_Init 0 */

  /* USER CODE BEGIN DMA2D_Init 1 */

  /* USER CODE END DMA2D_Init 1 */
  hdma2d.Instance = DMA2D;
 80009f0:	4b15      	ldr	r3, [pc, #84]	; (8000a48 <MX_DMA2D_Init+0x5c>)
 80009f2:	4a16      	ldr	r2, [pc, #88]	; (8000a4c <MX_DMA2D_Init+0x60>)
 80009f4:	601a      	str	r2, [r3, #0]
  hdma2d.Init.Mode = DMA2D_M2M;
 80009f6:	4b14      	ldr	r3, [pc, #80]	; (8000a48 <MX_DMA2D_Init+0x5c>)
 80009f8:	2200      	movs	r2, #0
 80009fa:	605a      	str	r2, [r3, #4]
  hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB565;
 80009fc:	4b12      	ldr	r3, [pc, #72]	; (8000a48 <MX_DMA2D_Init+0x5c>)
 80009fe:	2202      	movs	r2, #2
 8000a00:	609a      	str	r2, [r3, #8]
  hdma2d.Init.OutputOffset = 0;
 8000a02:	4b11      	ldr	r3, [pc, #68]	; (8000a48 <MX_DMA2D_Init+0x5c>)
 8000a04:	2200      	movs	r2, #0
 8000a06:	60da      	str	r2, [r3, #12]
  hdma2d.LayerCfg[1].InputOffset = 0;
 8000a08:	4b0f      	ldr	r3, [pc, #60]	; (8000a48 <MX_DMA2D_Init+0x5c>)
 8000a0a:	2200      	movs	r2, #0
 8000a0c:	629a      	str	r2, [r3, #40]	; 0x28
  hdma2d.LayerCfg[1].InputColorMode = DMA2D_INPUT_RGB565;
 8000a0e:	4b0e      	ldr	r3, [pc, #56]	; (8000a48 <MX_DMA2D_Init+0x5c>)
 8000a10:	2202      	movs	r2, #2
 8000a12:	62da      	str	r2, [r3, #44]	; 0x2c
  hdma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
 8000a14:	4b0c      	ldr	r3, [pc, #48]	; (8000a48 <MX_DMA2D_Init+0x5c>)
 8000a16:	2200      	movs	r2, #0
 8000a18:	631a      	str	r2, [r3, #48]	; 0x30
  hdma2d.LayerCfg[1].InputAlpha = 0;
 8000a1a:	4b0b      	ldr	r3, [pc, #44]	; (8000a48 <MX_DMA2D_Init+0x5c>)
 8000a1c:	2200      	movs	r2, #0
 8000a1e:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
 8000a20:	4809      	ldr	r0, [pc, #36]	; (8000a48 <MX_DMA2D_Init+0x5c>)
 8000a22:	f000 fe04 	bl	800162e <HAL_DMA2D_Init>
 8000a26:	4603      	mov	r3, r0
 8000a28:	2b00      	cmp	r3, #0
 8000a2a:	d001      	beq.n	8000a30 <MX_DMA2D_Init+0x44>
  {
    Error_Handler();
 8000a2c:	f000 f9c0 	bl	8000db0 <Error_Handler>
  }
  if (HAL_DMA2D_ConfigLayer(&hdma2d, 1) != HAL_OK)
 8000a30:	2101      	movs	r1, #1
 8000a32:	4805      	ldr	r0, [pc, #20]	; (8000a48 <MX_DMA2D_Init+0x5c>)
 8000a34:	f000 ff54 	bl	80018e0 <HAL_DMA2D_ConfigLayer>
 8000a38:	4603      	mov	r3, r0
 8000a3a:	2b00      	cmp	r3, #0
 8000a3c:	d001      	beq.n	8000a42 <MX_DMA2D_Init+0x56>
  {
    Error_Handler();
 8000a3e:	f000 f9b7 	bl	8000db0 <Error_Handler>
  }
  /* USER CODE BEGIN DMA2D_Init 2 */

  /* USER CODE END DMA2D_Init 2 */

}
 8000a42:	bf00      	nop
 8000a44:	bd80      	pop	{r7, pc}
 8000a46:	bf00      	nop
 8000a48:	20007f90 	.word	0x20007f90
 8000a4c:	4002b000 	.word	0x4002b000

08000a50 <MX_LTDC_Init>:
  * @brief LTDC Initialization Function
  * @param None
  * @retval None
  */
static void MX_LTDC_Init(void)
{
 8000a50:	b580      	push	{r7, lr}
 8000a52:	b09a      	sub	sp, #104	; 0x68
 8000a54:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN LTDC_Init 0 */

  /* USER CODE END LTDC_Init 0 */

  LTDC_LayerCfgTypeDef pLayerCfg = {0};
 8000a56:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8000a5a:	2234      	movs	r2, #52	; 0x34
 8000a5c:	2100      	movs	r1, #0
 8000a5e:	4618      	mov	r0, r3
 8000a60:	f02d fc02 	bl	802e268 <memset>
  LTDC_LayerCfgTypeDef pLayerCfg1 = {0};
 8000a64:	463b      	mov	r3, r7
 8000a66:	2234      	movs	r2, #52	; 0x34
 8000a68:	2100      	movs	r1, #0
 8000a6a:	4618      	mov	r0, r3
 8000a6c:	f02d fbfc 	bl	802e268 <memset>

  /* USER CODE BEGIN LTDC_Init 1 */

  /* USER CODE END LTDC_Init 1 */
  hltdc.Instance = LTDC;
 8000a70:	4b50      	ldr	r3, [pc, #320]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000a72:	4a51      	ldr	r2, [pc, #324]	; (8000bb8 <MX_LTDC_Init+0x168>)
 8000a74:	601a      	str	r2, [r3, #0]
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
 8000a76:	4b4f      	ldr	r3, [pc, #316]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000a78:	2200      	movs	r2, #0
 8000a7a:	605a      	str	r2, [r3, #4]
  hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
 8000a7c:	4b4d      	ldr	r3, [pc, #308]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000a7e:	2200      	movs	r2, #0
 8000a80:	609a      	str	r2, [r3, #8]
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
 8000a82:	4b4c      	ldr	r3, [pc, #304]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000a84:	2200      	movs	r2, #0
 8000a86:	60da      	str	r2, [r3, #12]
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
 8000a88:	4b4a      	ldr	r3, [pc, #296]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000a8a:	2200      	movs	r2, #0
 8000a8c:	611a      	str	r2, [r3, #16]
  hltdc.Init.HorizontalSync = 0;
 8000a8e:	4b49      	ldr	r3, [pc, #292]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000a90:	2200      	movs	r2, #0
 8000a92:	615a      	str	r2, [r3, #20]
  hltdc.Init.VerticalSync = 0;
 8000a94:	4b47      	ldr	r3, [pc, #284]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000a96:	2200      	movs	r2, #0
 8000a98:	619a      	str	r2, [r3, #24]
  hltdc.Init.AccumulatedHBP = 46;
 8000a9a:	4b46      	ldr	r3, [pc, #280]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000a9c:	222e      	movs	r2, #46	; 0x2e
 8000a9e:	61da      	str	r2, [r3, #28]
  hltdc.Init.AccumulatedVBP = 23;
 8000aa0:	4b44      	ldr	r3, [pc, #272]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000aa2:	2217      	movs	r2, #23
 8000aa4:	621a      	str	r2, [r3, #32]
  hltdc.Init.AccumulatedActiveW = 846;
 8000aa6:	4b43      	ldr	r3, [pc, #268]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000aa8:	f240 324e 	movw	r2, #846	; 0x34e
 8000aac:	625a      	str	r2, [r3, #36]	; 0x24
  hltdc.Init.AccumulatedActiveH = 503;
 8000aae:	4b41      	ldr	r3, [pc, #260]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000ab0:	f240 12f7 	movw	r2, #503	; 0x1f7
 8000ab4:	629a      	str	r2, [r3, #40]	; 0x28
  hltdc.Init.TotalWidth = 1056;
 8000ab6:	4b3f      	ldr	r3, [pc, #252]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000ab8:	f44f 6284 	mov.w	r2, #1056	; 0x420
 8000abc:	62da      	str	r2, [r3, #44]	; 0x2c
  hltdc.Init.TotalHeigh = 525;
 8000abe:	4b3d      	ldr	r3, [pc, #244]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000ac0:	f240 220d 	movw	r2, #525	; 0x20d
 8000ac4:	631a      	str	r2, [r3, #48]	; 0x30
  hltdc.Init.Backcolor.Blue = 0;
 8000ac6:	4b3b      	ldr	r3, [pc, #236]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000ac8:	2200      	movs	r2, #0
 8000aca:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  hltdc.Init.Backcolor.Green = 0;
 8000ace:	4b39      	ldr	r3, [pc, #228]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000ad0:	2200      	movs	r2, #0
 8000ad2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  hltdc.Init.Backcolor.Red = 0;
 8000ad6:	4b37      	ldr	r3, [pc, #220]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000ad8:	2200      	movs	r2, #0
 8000ada:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
 8000ade:	4835      	ldr	r0, [pc, #212]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000ae0:	f001 f956 	bl	8001d90 <HAL_LTDC_Init>
 8000ae4:	4603      	mov	r3, r0
 8000ae6:	2b00      	cmp	r3, #0
 8000ae8:	d001      	beq.n	8000aee <MX_LTDC_Init+0x9e>
  {
    Error_Handler();
 8000aea:	f000 f961 	bl	8000db0 <Error_Handler>
  }
  pLayerCfg.WindowX0 = 0;
 8000aee:	2300      	movs	r3, #0
 8000af0:	637b      	str	r3, [r7, #52]	; 0x34
  pLayerCfg.WindowX1 = 800;
 8000af2:	f44f 7348 	mov.w	r3, #800	; 0x320
 8000af6:	63bb      	str	r3, [r7, #56]	; 0x38
  pLayerCfg.WindowY0 = 0;
 8000af8:	2300      	movs	r3, #0
 8000afa:	63fb      	str	r3, [r7, #60]	; 0x3c
  pLayerCfg.WindowY1 = 480;
 8000afc:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 8000b00:	643b      	str	r3, [r7, #64]	; 0x40
  pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
 8000b02:	2302      	movs	r3, #2
 8000b04:	647b      	str	r3, [r7, #68]	; 0x44
  pLayerCfg.Alpha = 255;
 8000b06:	23ff      	movs	r3, #255	; 0xff
 8000b08:	64bb      	str	r3, [r7, #72]	; 0x48
  pLayerCfg.Alpha0 = 0;
 8000b0a:	2300      	movs	r3, #0
 8000b0c:	64fb      	str	r3, [r7, #76]	; 0x4c
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
 8000b0e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000b12:	653b      	str	r3, [r7, #80]	; 0x50
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
 8000b14:	2305      	movs	r3, #5
 8000b16:	657b      	str	r3, [r7, #84]	; 0x54
  pLayerCfg.FBStartAdress = 0xC0000000;
 8000b18:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 8000b1c:	65bb      	str	r3, [r7, #88]	; 0x58
  pLayerCfg.ImageWidth = 800;
 8000b1e:	f44f 7348 	mov.w	r3, #800	; 0x320
 8000b22:	65fb      	str	r3, [r7, #92]	; 0x5c
  pLayerCfg.ImageHeight = 480;
 8000b24:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 8000b28:	663b      	str	r3, [r7, #96]	; 0x60
  pLayerCfg.Backcolor.Blue = 0;
 8000b2a:	2300      	movs	r3, #0
 8000b2c:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
  pLayerCfg.Backcolor.Green = 0;
 8000b30:	2300      	movs	r3, #0
 8000b32:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
  pLayerCfg.Backcolor.Red = 0;
 8000b36:	2300      	movs	r3, #0
 8000b38:	f887 3066 	strb.w	r3, [r7, #102]	; 0x66
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
 8000b3c:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8000b40:	2200      	movs	r2, #0
 8000b42:	4619      	mov	r1, r3
 8000b44:	481b      	ldr	r0, [pc, #108]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000b46:	f001 fab5 	bl	80020b4 <HAL_LTDC_ConfigLayer>
 8000b4a:	4603      	mov	r3, r0
 8000b4c:	2b00      	cmp	r3, #0
 8000b4e:	d001      	beq.n	8000b54 <MX_LTDC_Init+0x104>
  {
    Error_Handler();
 8000b50:	f000 f92e 	bl	8000db0 <Error_Handler>
  }
  pLayerCfg1.WindowX0 = 0;
 8000b54:	2300      	movs	r3, #0
 8000b56:	603b      	str	r3, [r7, #0]
  pLayerCfg1.WindowX1 = 0;
 8000b58:	2300      	movs	r3, #0
 8000b5a:	607b      	str	r3, [r7, #4]
  pLayerCfg1.WindowY0 = 0;
 8000b5c:	2300      	movs	r3, #0
 8000b5e:	60bb      	str	r3, [r7, #8]
  pLayerCfg1.WindowY1 = 0;
 8000b60:	2300      	movs	r3, #0
 8000b62:	60fb      	str	r3, [r7, #12]
  pLayerCfg1.Alpha = 0;
 8000b64:	2300      	movs	r3, #0
 8000b66:	617b      	str	r3, [r7, #20]
  pLayerCfg1.Alpha0 = 0;
 8000b68:	2300      	movs	r3, #0
 8000b6a:	61bb      	str	r3, [r7, #24]
  pLayerCfg1.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
 8000b6c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000b70:	61fb      	str	r3, [r7, #28]
  pLayerCfg1.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
 8000b72:	2305      	movs	r3, #5
 8000b74:	623b      	str	r3, [r7, #32]
  pLayerCfg1.FBStartAdress = 0;
 8000b76:	2300      	movs	r3, #0
 8000b78:	627b      	str	r3, [r7, #36]	; 0x24
  pLayerCfg1.ImageWidth = 0;
 8000b7a:	2300      	movs	r3, #0
 8000b7c:	62bb      	str	r3, [r7, #40]	; 0x28
  pLayerCfg1.ImageHeight = 0;
 8000b7e:	2300      	movs	r3, #0
 8000b80:	62fb      	str	r3, [r7, #44]	; 0x2c
  pLayerCfg1.Backcolor.Blue = 0;
 8000b82:	2300      	movs	r3, #0
 8000b84:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
  pLayerCfg1.Backcolor.Green = 0;
 8000b88:	2300      	movs	r3, #0
 8000b8a:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
  pLayerCfg1.Backcolor.Red = 0;
 8000b8e:	2300      	movs	r3, #0
 8000b90:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg1, 1) != HAL_OK)
 8000b94:	463b      	mov	r3, r7
 8000b96:	2201      	movs	r2, #1
 8000b98:	4619      	mov	r1, r3
 8000b9a:	4806      	ldr	r0, [pc, #24]	; (8000bb4 <MX_LTDC_Init+0x164>)
 8000b9c:	f001 fa8a 	bl	80020b4 <HAL_LTDC_ConfigLayer>
 8000ba0:	4603      	mov	r3, r0
 8000ba2:	2b00      	cmp	r3, #0
 8000ba4:	d001      	beq.n	8000baa <MX_LTDC_Init+0x15a>
  {
    Error_Handler();
 8000ba6:	f000 f903 	bl	8000db0 <Error_Handler>
  }
  /* USER CODE BEGIN LTDC_Init 2 */

  /* USER CODE END LTDC_Init 2 */

}
 8000baa:	bf00      	nop
 8000bac:	3768      	adds	r7, #104	; 0x68
 8000bae:	46bd      	mov	sp, r7
 8000bb0:	bd80      	pop	{r7, pc}
 8000bb2:	bf00      	nop
 8000bb4:	20007fd0 	.word	0x20007fd0
 8000bb8:	40016800 	.word	0x40016800

08000bbc <MX_FMC_Init>:

/* FMC initialization function */
static void MX_FMC_Init(void)
{
 8000bbc:	b580      	push	{r7, lr}
 8000bbe:	b08c      	sub	sp, #48	; 0x30
 8000bc0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN FMC_Init 0 */

  /* USER CODE END FMC_Init 0 */

  FMC_SDRAM_TimingTypeDef SdramTiming = {0};
 8000bc2:	f107 0314 	add.w	r3, r7, #20
 8000bc6:	2200      	movs	r2, #0
 8000bc8:	601a      	str	r2, [r3, #0]
 8000bca:	605a      	str	r2, [r3, #4]
 8000bcc:	609a      	str	r2, [r3, #8]
 8000bce:	60da      	str	r2, [r3, #12]
 8000bd0:	611a      	str	r2, [r3, #16]
 8000bd2:	615a      	str	r2, [r3, #20]
 8000bd4:	619a      	str	r2, [r3, #24]

  /* USER CODE END FMC_Init 1 */

  /** Perform the SDRAM1 memory initialization sequence
  */
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8000bd6:	4b22      	ldr	r3, [pc, #136]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000bd8:	4a22      	ldr	r2, [pc, #136]	; (8000c64 <MX_FMC_Init+0xa8>)
 8000bda:	601a      	str	r2, [r3, #0]
  /* hsdram1.Init */
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
 8000bdc:	4b20      	ldr	r3, [pc, #128]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000bde:	2200      	movs	r2, #0
 8000be0:	605a      	str	r2, [r3, #4]
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
 8000be2:	4b1f      	ldr	r3, [pc, #124]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000be4:	2201      	movs	r2, #1
 8000be6:	609a      	str	r2, [r3, #8]
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
 8000be8:	4b1d      	ldr	r3, [pc, #116]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000bea:	2208      	movs	r2, #8
 8000bec:	60da      	str	r2, [r3, #12]
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
 8000bee:	4b1c      	ldr	r3, [pc, #112]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000bf0:	2210      	movs	r2, #16
 8000bf2:	611a      	str	r2, [r3, #16]
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 8000bf4:	4b1a      	ldr	r3, [pc, #104]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000bf6:	2240      	movs	r2, #64	; 0x40
 8000bf8:	615a      	str	r2, [r3, #20]
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
 8000bfa:	4b19      	ldr	r3, [pc, #100]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000bfc:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000c00:	619a      	str	r2, [r3, #24]
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 8000c02:	4b17      	ldr	r3, [pc, #92]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000c04:	2200      	movs	r2, #0
 8000c06:	61da      	str	r2, [r3, #28]
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;
 8000c08:	4b15      	ldr	r3, [pc, #84]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000c0a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8000c0e:	621a      	str	r2, [r3, #32]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_DISABLE;
 8000c10:	4b13      	ldr	r3, [pc, #76]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000c12:	2200      	movs	r2, #0
 8000c14:	625a      	str	r2, [r3, #36]	; 0x24
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
 8000c16:	4b12      	ldr	r3, [pc, #72]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000c18:	2200      	movs	r2, #0
 8000c1a:	629a      	str	r2, [r3, #40]	; 0x28
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 2;
 8000c1c:	2302      	movs	r3, #2
 8000c1e:	617b      	str	r3, [r7, #20]
  SdramTiming.ExitSelfRefreshDelay = 7;
 8000c20:	2307      	movs	r3, #7
 8000c22:	61bb      	str	r3, [r7, #24]
  SdramTiming.SelfRefreshTime = 4;
 8000c24:	2304      	movs	r3, #4
 8000c26:	61fb      	str	r3, [r7, #28]
  SdramTiming.RowCycleDelay = 7;
 8000c28:	2307      	movs	r3, #7
 8000c2a:	623b      	str	r3, [r7, #32]
  SdramTiming.WriteRecoveryTime = 3;
 8000c2c:	2303      	movs	r3, #3
 8000c2e:	627b      	str	r3, [r7, #36]	; 0x24
  SdramTiming.RPDelay = 2;
 8000c30:	2302      	movs	r3, #2
 8000c32:	62bb      	str	r3, [r7, #40]	; 0x28
  SdramTiming.RCDDelay = 2;
 8000c34:	2302      	movs	r3, #2
 8000c36:	62fb      	str	r3, [r7, #44]	; 0x2c

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 8000c38:	f107 0314 	add.w	r3, r7, #20
 8000c3c:	4619      	mov	r1, r3
 8000c3e:	4808      	ldr	r0, [pc, #32]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000c40:	f003 fb92 	bl	8004368 <HAL_SDRAM_Init>
 8000c44:	4603      	mov	r3, r0
 8000c46:	2b00      	cmp	r3, #0
 8000c48:	d001      	beq.n	8000c4e <MX_FMC_Init+0x92>
  {
    Error_Handler( );
 8000c4a:	f000 f8b1 	bl	8000db0 <Error_Handler>
  }

  /* USER CODE BEGIN FMC_Init 2 */
    FMC_SDRAM_CommandTypeDef SDRAM_Command;
    SDRAM_Initialization_Sequence(&hsdram1, &SDRAM_Command);
 8000c4e:	1d3b      	adds	r3, r7, #4
 8000c50:	4619      	mov	r1, r3
 8000c52:	4803      	ldr	r0, [pc, #12]	; (8000c60 <MX_FMC_Init+0xa4>)
 8000c54:	f7ff fcaa 	bl	80005ac <SDRAM_Initialization_Sequence>
  /* USER CODE END FMC_Init 2 */
}
 8000c58:	bf00      	nop
 8000c5a:	3730      	adds	r7, #48	; 0x30
 8000c5c:	46bd      	mov	sp, r7
 8000c5e:	bd80      	pop	{r7, pc}
 8000c60:	20008078 	.word	0x20008078
 8000c64:	a0000140 	.word	0xa0000140

08000c68 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8000c68:	b580      	push	{r7, lr}
 8000c6a:	b08e      	sub	sp, #56	; 0x38
 8000c6c:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000c6e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000c72:	2200      	movs	r2, #0
 8000c74:	601a      	str	r2, [r3, #0]
 8000c76:	605a      	str	r2, [r3, #4]
 8000c78:	609a      	str	r2, [r3, #8]
 8000c7a:	60da      	str	r2, [r3, #12]
 8000c7c:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOI_CLK_ENABLE();
 8000c7e:	2300      	movs	r3, #0
 8000c80:	623b      	str	r3, [r7, #32]
 8000c82:	4b49      	ldr	r3, [pc, #292]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000c84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000c86:	4a48      	ldr	r2, [pc, #288]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000c88:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000c8c:	6313      	str	r3, [r2, #48]	; 0x30
 8000c8e:	4b46      	ldr	r3, [pc, #280]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000c90:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000c92:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8000c96:	623b      	str	r3, [r7, #32]
 8000c98:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8000c9a:	2300      	movs	r3, #0
 8000c9c:	61fb      	str	r3, [r7, #28]
 8000c9e:	4b42      	ldr	r3, [pc, #264]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000ca0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000ca2:	4a41      	ldr	r2, [pc, #260]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000ca4:	f043 0320 	orr.w	r3, r3, #32
 8000ca8:	6313      	str	r3, [r2, #48]	; 0x30
 8000caa:	4b3f      	ldr	r3, [pc, #252]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000cac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000cae:	f003 0320 	and.w	r3, r3, #32
 8000cb2:	61fb      	str	r3, [r7, #28]
 8000cb4:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8000cb6:	2300      	movs	r3, #0
 8000cb8:	61bb      	str	r3, [r7, #24]
 8000cba:	4b3b      	ldr	r3, [pc, #236]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000cbc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000cbe:	4a3a      	ldr	r2, [pc, #232]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000cc0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000cc4:	6313      	str	r3, [r2, #48]	; 0x30
 8000cc6:	4b38      	ldr	r3, [pc, #224]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000cc8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000cca:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000cce:	61bb      	str	r3, [r7, #24]
 8000cd0:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000cd2:	2300      	movs	r3, #0
 8000cd4:	617b      	str	r3, [r7, #20]
 8000cd6:	4b34      	ldr	r3, [pc, #208]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000cd8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000cda:	4a33      	ldr	r2, [pc, #204]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000cdc:	f043 0304 	orr.w	r3, r3, #4
 8000ce0:	6313      	str	r3, [r2, #48]	; 0x30
 8000ce2:	4b31      	ldr	r3, [pc, #196]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000ce4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000ce6:	f003 0304 	and.w	r3, r3, #4
 8000cea:	617b      	str	r3, [r7, #20]
 8000cec:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8000cee:	2300      	movs	r3, #0
 8000cf0:	613b      	str	r3, [r7, #16]
 8000cf2:	4b2d      	ldr	r3, [pc, #180]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000cf4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000cf6:	4a2c      	ldr	r2, [pc, #176]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000cf8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000cfc:	6313      	str	r3, [r2, #48]	; 0x30
 8000cfe:	4b2a      	ldr	r3, [pc, #168]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d00:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d02:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000d06:	613b      	str	r3, [r7, #16]
 8000d08:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8000d0a:	2300      	movs	r3, #0
 8000d0c:	60fb      	str	r3, [r7, #12]
 8000d0e:	4b26      	ldr	r3, [pc, #152]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d12:	4a25      	ldr	r2, [pc, #148]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d14:	f043 0310 	orr.w	r3, r3, #16
 8000d18:	6313      	str	r3, [r2, #48]	; 0x30
 8000d1a:	4b23      	ldr	r3, [pc, #140]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d1e:	f003 0310 	and.w	r3, r3, #16
 8000d22:	60fb      	str	r3, [r7, #12]
 8000d24:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000d26:	2300      	movs	r3, #0
 8000d28:	60bb      	str	r3, [r7, #8]
 8000d2a:	4b1f      	ldr	r3, [pc, #124]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d2c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d2e:	4a1e      	ldr	r2, [pc, #120]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d30:	f043 0308 	orr.w	r3, r3, #8
 8000d34:	6313      	str	r3, [r2, #48]	; 0x30
 8000d36:	4b1c      	ldr	r3, [pc, #112]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d38:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d3a:	f003 0308 	and.w	r3, r3, #8
 8000d3e:	60bb      	str	r3, [r7, #8]
 8000d40:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000d42:	2300      	movs	r3, #0
 8000d44:	607b      	str	r3, [r7, #4]
 8000d46:	4b18      	ldr	r3, [pc, #96]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d4a:	4a17      	ldr	r2, [pc, #92]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d4c:	f043 0301 	orr.w	r3, r3, #1
 8000d50:	6313      	str	r3, [r2, #48]	; 0x30
 8000d52:	4b15      	ldr	r3, [pc, #84]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d56:	f003 0301 	and.w	r3, r3, #1
 8000d5a:	607b      	str	r3, [r7, #4]
 8000d5c:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000d5e:	2300      	movs	r3, #0
 8000d60:	603b      	str	r3, [r7, #0]
 8000d62:	4b11      	ldr	r3, [pc, #68]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d66:	4a10      	ldr	r2, [pc, #64]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d68:	f043 0302 	orr.w	r3, r3, #2
 8000d6c:	6313      	str	r3, [r2, #48]	; 0x30
 8000d6e:	4b0e      	ldr	r3, [pc, #56]	; (8000da8 <MX_GPIO_Init+0x140>)
 8000d70:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d72:	f003 0302 	and.w	r3, r3, #2
 8000d76:	603b      	str	r3, [r7, #0]
 8000d78:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LCD_Enable_GPIO_Port, LCD_Enable_Pin, GPIO_PIN_SET);
 8000d7a:	2201      	movs	r2, #1
 8000d7c:	2120      	movs	r1, #32
 8000d7e:	480b      	ldr	r0, [pc, #44]	; (8000dac <MX_GPIO_Init+0x144>)
 8000d80:	f000 ffec 	bl	8001d5c <HAL_GPIO_WritePin>

  /*Configure GPIO pin : LCD_Enable_Pin */
  GPIO_InitStruct.Pin = LCD_Enable_Pin;
 8000d84:	2320      	movs	r3, #32
 8000d86:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000d88:	2301      	movs	r3, #1
 8000d8a:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000d8c:	2300      	movs	r3, #0
 8000d8e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000d90:	2300      	movs	r3, #0
 8000d92:	633b      	str	r3, [r7, #48]	; 0x30
  HAL_GPIO_Init(LCD_Enable_GPIO_Port, &GPIO_InitStruct);
 8000d94:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8000d98:	4619      	mov	r1, r3
 8000d9a:	4804      	ldr	r0, [pc, #16]	; (8000dac <MX_GPIO_Init+0x144>)
 8000d9c:	f000 fe32 	bl	8001a04 <HAL_GPIO_Init>

}
 8000da0:	bf00      	nop
 8000da2:	3738      	adds	r7, #56	; 0x38
 8000da4:	46bd      	mov	sp, r7
 8000da6:	bd80      	pop	{r7, pc}
 8000da8:	40023800 	.word	0x40023800
 8000dac:	40020400 	.word	0x40020400

08000db0 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8000db0:	b480      	push	{r7}
 8000db2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 8000db4:	bf00      	nop
 8000db6:	46bd      	mov	sp, r7
 8000db8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000dbc:	4770      	bx	lr
	...

08000dc0 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8000dc0:	b480      	push	{r7}
 8000dc2:	b083      	sub	sp, #12
 8000dc4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000dc6:	2300      	movs	r3, #0
 8000dc8:	607b      	str	r3, [r7, #4]
 8000dca:	4b10      	ldr	r3, [pc, #64]	; (8000e0c <HAL_MspInit+0x4c>)
 8000dcc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000dce:	4a0f      	ldr	r2, [pc, #60]	; (8000e0c <HAL_MspInit+0x4c>)
 8000dd0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000dd4:	6453      	str	r3, [r2, #68]	; 0x44
 8000dd6:	4b0d      	ldr	r3, [pc, #52]	; (8000e0c <HAL_MspInit+0x4c>)
 8000dd8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000dda:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000dde:	607b      	str	r3, [r7, #4]
 8000de0:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 8000de2:	2300      	movs	r3, #0
 8000de4:	603b      	str	r3, [r7, #0]
 8000de6:	4b09      	ldr	r3, [pc, #36]	; (8000e0c <HAL_MspInit+0x4c>)
 8000de8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000dea:	4a08      	ldr	r2, [pc, #32]	; (8000e0c <HAL_MspInit+0x4c>)
 8000dec:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000df0:	6413      	str	r3, [r2, #64]	; 0x40
 8000df2:	4b06      	ldr	r3, [pc, #24]	; (8000e0c <HAL_MspInit+0x4c>)
 8000df4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000df6:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000dfa:	603b      	str	r3, [r7, #0]
 8000dfc:	683b      	ldr	r3, [r7, #0]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000dfe:	bf00      	nop
 8000e00:	370c      	adds	r7, #12
 8000e02:	46bd      	mov	sp, r7
 8000e04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e08:	4770      	bx	lr
 8000e0a:	bf00      	nop
 8000e0c:	40023800 	.word	0x40023800

08000e10 <HAL_CRC_MspInit>:
* This function configures the hardware resources used in this example
* @param hcrc: CRC handle pointer
* @retval None
*/
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
 8000e10:	b480      	push	{r7}
 8000e12:	b085      	sub	sp, #20
 8000e14:	af00      	add	r7, sp, #0
 8000e16:	6078      	str	r0, [r7, #4]
  if(hcrc->Instance==CRC)
 8000e18:	687b      	ldr	r3, [r7, #4]
 8000e1a:	681b      	ldr	r3, [r3, #0]
 8000e1c:	4a0b      	ldr	r2, [pc, #44]	; (8000e4c <HAL_CRC_MspInit+0x3c>)
 8000e1e:	4293      	cmp	r3, r2
 8000e20:	d10d      	bne.n	8000e3e <HAL_CRC_MspInit+0x2e>
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 8000e22:	2300      	movs	r3, #0
 8000e24:	60fb      	str	r3, [r7, #12]
 8000e26:	4b0a      	ldr	r3, [pc, #40]	; (8000e50 <HAL_CRC_MspInit+0x40>)
 8000e28:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000e2a:	4a09      	ldr	r2, [pc, #36]	; (8000e50 <HAL_CRC_MspInit+0x40>)
 8000e2c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000e30:	6313      	str	r3, [r2, #48]	; 0x30
 8000e32:	4b07      	ldr	r3, [pc, #28]	; (8000e50 <HAL_CRC_MspInit+0x40>)
 8000e34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000e36:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000e3a:	60fb      	str	r3, [r7, #12]
 8000e3c:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }

}
 8000e3e:	bf00      	nop
 8000e40:	3714      	adds	r7, #20
 8000e42:	46bd      	mov	sp, r7
 8000e44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e48:	4770      	bx	lr
 8000e4a:	bf00      	nop
 8000e4c:	40023000 	.word	0x40023000
 8000e50:	40023800 	.word	0x40023800

08000e54 <HAL_DMA2D_MspInit>:
* This function configures the hardware resources used in this example
* @param hdma2d: DMA2D handle pointer
* @retval None
*/
void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* hdma2d)
{
 8000e54:	b580      	push	{r7, lr}
 8000e56:	b084      	sub	sp, #16
 8000e58:	af00      	add	r7, sp, #0
 8000e5a:	6078      	str	r0, [r7, #4]
  if(hdma2d->Instance==DMA2D)
 8000e5c:	687b      	ldr	r3, [r7, #4]
 8000e5e:	681b      	ldr	r3, [r3, #0]
 8000e60:	4a0e      	ldr	r2, [pc, #56]	; (8000e9c <HAL_DMA2D_MspInit+0x48>)
 8000e62:	4293      	cmp	r3, r2
 8000e64:	d115      	bne.n	8000e92 <HAL_DMA2D_MspInit+0x3e>
  {
  /* USER CODE BEGIN DMA2D_MspInit 0 */

  /* USER CODE END DMA2D_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_DMA2D_CLK_ENABLE();
 8000e66:	2300      	movs	r3, #0
 8000e68:	60fb      	str	r3, [r7, #12]
 8000e6a:	4b0d      	ldr	r3, [pc, #52]	; (8000ea0 <HAL_DMA2D_MspInit+0x4c>)
 8000e6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000e6e:	4a0c      	ldr	r2, [pc, #48]	; (8000ea0 <HAL_DMA2D_MspInit+0x4c>)
 8000e70:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8000e74:	6313      	str	r3, [r2, #48]	; 0x30
 8000e76:	4b0a      	ldr	r3, [pc, #40]	; (8000ea0 <HAL_DMA2D_MspInit+0x4c>)
 8000e78:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000e7a:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8000e7e:	60fb      	str	r3, [r7, #12]
 8000e80:	68fb      	ldr	r3, [r7, #12]
    /* DMA2D interrupt Init */
    HAL_NVIC_SetPriority(DMA2D_IRQn, 0, 0);
 8000e82:	2200      	movs	r2, #0
 8000e84:	2100      	movs	r1, #0
 8000e86:	205a      	movs	r0, #90	; 0x5a
 8000e88:	f000 fb7f 	bl	800158a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DMA2D_IRQn);
 8000e8c:	205a      	movs	r0, #90	; 0x5a
 8000e8e:	f000 fb98 	bl	80015c2 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN DMA2D_MspInit 1 */

  /* USER CODE END DMA2D_MspInit 1 */
  }

}
 8000e92:	bf00      	nop
 8000e94:	3710      	adds	r7, #16
 8000e96:	46bd      	mov	sp, r7
 8000e98:	bd80      	pop	{r7, pc}
 8000e9a:	bf00      	nop
 8000e9c:	4002b000 	.word	0x4002b000
 8000ea0:	40023800 	.word	0x40023800

08000ea4 <HAL_LTDC_MspInit>:
* This function configures the hardware resources used in this example
* @param hltdc: LTDC handle pointer
* @retval None
*/
void HAL_LTDC_MspInit(LTDC_HandleTypeDef* hltdc)
{
 8000ea4:	b580      	push	{r7, lr}
 8000ea6:	b08c      	sub	sp, #48	; 0x30
 8000ea8:	af00      	add	r7, sp, #0
 8000eaa:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000eac:	f107 031c 	add.w	r3, r7, #28
 8000eb0:	2200      	movs	r2, #0
 8000eb2:	601a      	str	r2, [r3, #0]
 8000eb4:	605a      	str	r2, [r3, #4]
 8000eb6:	609a      	str	r2, [r3, #8]
 8000eb8:	60da      	str	r2, [r3, #12]
 8000eba:	611a      	str	r2, [r3, #16]
  if(hltdc->Instance==LTDC)
 8000ebc:	687b      	ldr	r3, [r7, #4]
 8000ebe:	681b      	ldr	r3, [r3, #0]
 8000ec0:	4a4c      	ldr	r2, [pc, #304]	; (8000ff4 <HAL_LTDC_MspInit+0x150>)
 8000ec2:	4293      	cmp	r3, r2
 8000ec4:	f040 8092 	bne.w	8000fec <HAL_LTDC_MspInit+0x148>
  {
  /* USER CODE BEGIN LTDC_MspInit 0 */

  /* USER CODE END LTDC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_LTDC_CLK_ENABLE();
 8000ec8:	2300      	movs	r3, #0
 8000eca:	61bb      	str	r3, [r7, #24]
 8000ecc:	4b4a      	ldr	r3, [pc, #296]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000ece:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000ed0:	4a49      	ldr	r2, [pc, #292]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000ed2:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8000ed6:	6453      	str	r3, [r2, #68]	; 0x44
 8000ed8:	4b47      	ldr	r3, [pc, #284]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000eda:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000edc:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8000ee0:	61bb      	str	r3, [r7, #24]
 8000ee2:	69bb      	ldr	r3, [r7, #24]

    __HAL_RCC_GPIOI_CLK_ENABLE();
 8000ee4:	2300      	movs	r3, #0
 8000ee6:	617b      	str	r3, [r7, #20]
 8000ee8:	4b43      	ldr	r3, [pc, #268]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000eea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000eec:	4a42      	ldr	r2, [pc, #264]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000eee:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000ef2:	6313      	str	r3, [r2, #48]	; 0x30
 8000ef4:	4b40      	ldr	r3, [pc, #256]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000ef6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000ef8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8000efc:	617b      	str	r3, [r7, #20]
 8000efe:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOF_CLK_ENABLE();
 8000f00:	2300      	movs	r3, #0
 8000f02:	613b      	str	r3, [r7, #16]
 8000f04:	4b3c      	ldr	r3, [pc, #240]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000f06:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f08:	4a3b      	ldr	r2, [pc, #236]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000f0a:	f043 0320 	orr.w	r3, r3, #32
 8000f0e:	6313      	str	r3, [r2, #48]	; 0x30
 8000f10:	4b39      	ldr	r3, [pc, #228]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000f12:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f14:	f003 0320 	and.w	r3, r3, #32
 8000f18:	613b      	str	r3, [r7, #16]
 8000f1a:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOH_CLK_ENABLE();
 8000f1c:	2300      	movs	r3, #0
 8000f1e:	60fb      	str	r3, [r7, #12]
 8000f20:	4b35      	ldr	r3, [pc, #212]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000f22:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f24:	4a34      	ldr	r2, [pc, #208]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000f26:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000f2a:	6313      	str	r3, [r2, #48]	; 0x30
 8000f2c:	4b32      	ldr	r3, [pc, #200]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000f2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f30:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8000f34:	60fb      	str	r3, [r7, #12]
 8000f36:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 8000f38:	2300      	movs	r3, #0
 8000f3a:	60bb      	str	r3, [r7, #8]
 8000f3c:	4b2e      	ldr	r3, [pc, #184]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000f3e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f40:	4a2d      	ldr	r2, [pc, #180]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000f42:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000f46:	6313      	str	r3, [r2, #48]	; 0x30
 8000f48:	4b2b      	ldr	r3, [pc, #172]	; (8000ff8 <HAL_LTDC_MspInit+0x154>)
 8000f4a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f4c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000f50:	60bb      	str	r3, [r7, #8]
 8000f52:	68bb      	ldr	r3, [r7, #8]
    PI4     ------> LTDC_B4
    PI5     ------> LTDC_B5
    PI6     ------> LTDC_B6
    PI7     ------> LTDC_B7
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_0|GPIO_PIN_1
 8000f54:	f240 63f7 	movw	r3, #1783	; 0x6f7
 8000f58:	61fb      	str	r3, [r7, #28]
                          |GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6
                          |GPIO_PIN_7;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000f5a:	2302      	movs	r3, #2
 8000f5c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f5e:	2300      	movs	r3, #0
 8000f60:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000f62:	2303      	movs	r3, #3
 8000f64:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 8000f66:	230e      	movs	r3, #14
 8000f68:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8000f6a:	f107 031c 	add.w	r3, r7, #28
 8000f6e:	4619      	mov	r1, r3
 8000f70:	4822      	ldr	r0, [pc, #136]	; (8000ffc <HAL_LTDC_MspInit+0x158>)
 8000f72:	f000 fd47 	bl	8001a04 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8000f76:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8000f7a:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000f7c:	2302      	movs	r3, #2
 8000f7e:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f80:	2300      	movs	r3, #0
 8000f82:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000f84:	2303      	movs	r3, #3
 8000f86:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 8000f88:	230e      	movs	r3, #14
 8000f8a:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8000f8c:	f107 031c 	add.w	r3, r7, #28
 8000f90:	4619      	mov	r1, r3
 8000f92:	481b      	ldr	r0, [pc, #108]	; (8001000 <HAL_LTDC_MspInit+0x15c>)
 8000f94:	f000 fd36 	bl	8001a04 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12
 8000f98:	f44f 437e 	mov.w	r3, #65024	; 0xfe00
 8000f9c:	61fb      	str	r3, [r7, #28]
                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000f9e:	2302      	movs	r3, #2
 8000fa0:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000fa2:	2300      	movs	r3, #0
 8000fa4:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000fa6:	2303      	movs	r3, #3
 8000fa8:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 8000faa:	230e      	movs	r3, #14
 8000fac:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8000fae:	f107 031c 	add.w	r3, r7, #28
 8000fb2:	4619      	mov	r1, r3
 8000fb4:	4813      	ldr	r0, [pc, #76]	; (8001004 <HAL_LTDC_MspInit+0x160>)
 8000fb6:	f000 fd25 	bl	8001a04 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_11;
 8000fba:	f44f 630c 	mov.w	r3, #2240	; 0x8c0
 8000fbe:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000fc0:	2302      	movs	r3, #2
 8000fc2:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000fc4:	2300      	movs	r3, #0
 8000fc6:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8000fc8:	2303      	movs	r3, #3
 8000fca:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 8000fcc:	230e      	movs	r3, #14
 8000fce:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8000fd0:	f107 031c 	add.w	r3, r7, #28
 8000fd4:	4619      	mov	r1, r3
 8000fd6:	480c      	ldr	r0, [pc, #48]	; (8001008 <HAL_LTDC_MspInit+0x164>)
 8000fd8:	f000 fd14 	bl	8001a04 <HAL_GPIO_Init>

    /* LTDC interrupt Init */
    HAL_NVIC_SetPriority(LTDC_IRQn, 0, 0);
 8000fdc:	2200      	movs	r2, #0
 8000fde:	2100      	movs	r1, #0
 8000fe0:	2058      	movs	r0, #88	; 0x58
 8000fe2:	f000 fad2 	bl	800158a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(LTDC_IRQn);
 8000fe6:	2058      	movs	r0, #88	; 0x58
 8000fe8:	f000 faeb 	bl	80015c2 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN LTDC_MspInit 1 */

  /* USER CODE END LTDC_MspInit 1 */
  }

}
 8000fec:	bf00      	nop
 8000fee:	3730      	adds	r7, #48	; 0x30
 8000ff0:	46bd      	mov	sp, r7
 8000ff2:	bd80      	pop	{r7, pc}
 8000ff4:	40016800 	.word	0x40016800
 8000ff8:	40023800 	.word	0x40023800
 8000ffc:	40022000 	.word	0x40022000
 8001000:	40021400 	.word	0x40021400
 8001004:	40021c00 	.word	0x40021c00
 8001008:	40021800 	.word	0x40021800

0800100c <HAL_FMC_MspInit>:

}

static uint32_t FMC_Initialized = 0;

static void HAL_FMC_MspInit(void){
 800100c:	b580      	push	{r7, lr}
 800100e:	b086      	sub	sp, #24
 8001010:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct ={0};
 8001012:	1d3b      	adds	r3, r7, #4
 8001014:	2200      	movs	r2, #0
 8001016:	601a      	str	r2, [r3, #0]
 8001018:	605a      	str	r2, [r3, #4]
 800101a:	609a      	str	r2, [r3, #8]
 800101c:	60da      	str	r2, [r3, #12]
 800101e:	611a      	str	r2, [r3, #16]
  if (FMC_Initialized) {
 8001020:	4b34      	ldr	r3, [pc, #208]	; (80010f4 <HAL_FMC_MspInit+0xe8>)
 8001022:	681b      	ldr	r3, [r3, #0]
 8001024:	2b00      	cmp	r3, #0
 8001026:	d160      	bne.n	80010ea <HAL_FMC_MspInit+0xde>
    return;
  }
  FMC_Initialized = 1;
 8001028:	4b32      	ldr	r3, [pc, #200]	; (80010f4 <HAL_FMC_MspInit+0xe8>)
 800102a:	2201      	movs	r2, #1
 800102c:	601a      	str	r2, [r3, #0]

  /* Peripheral clock enable */
  __HAL_RCC_FMC_CLK_ENABLE();
 800102e:	2300      	movs	r3, #0
 8001030:	603b      	str	r3, [r7, #0]
 8001032:	4b31      	ldr	r3, [pc, #196]	; (80010f8 <HAL_FMC_MspInit+0xec>)
 8001034:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001036:	4a30      	ldr	r2, [pc, #192]	; (80010f8 <HAL_FMC_MspInit+0xec>)
 8001038:	f043 0301 	orr.w	r3, r3, #1
 800103c:	6393      	str	r3, [r2, #56]	; 0x38
 800103e:	4b2e      	ldr	r3, [pc, #184]	; (80010f8 <HAL_FMC_MspInit+0xec>)
 8001040:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001042:	f003 0301 	and.w	r3, r3, #1
 8001046:	603b      	str	r3, [r7, #0]
 8001048:	683b      	ldr	r3, [r7, #0]
  PG9   ------> FMC_NCE3
  PG15   ------> FMC_SDNCAS
  PE0   ------> FMC_NBL0
  PE1   ------> FMC_NBL1
  */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
 800104a:	f64f 033f 	movw	r3, #63551	; 0xf83f
 800104e:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_11|GPIO_PIN_12
                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001050:	2302      	movs	r3, #2
 8001052:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001054:	2300      	movs	r3, #0
 8001056:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001058:	2303      	movs	r3, #3
 800105a:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800105c:	230c      	movs	r3, #12
 800105e:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8001060:	1d3b      	adds	r3, r7, #4
 8001062:	4619      	mov	r1, r3
 8001064:	4825      	ldr	r0, [pc, #148]	; (80010fc <HAL_FMC_MspInit+0xf0>)
 8001066:	f000 fccd 	bl	8001a04 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
 800106a:	230d      	movs	r3, #13
 800106c:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800106e:	2302      	movs	r3, #2
 8001070:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001072:	2300      	movs	r3, #0
 8001074:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001076:	2303      	movs	r3, #3
 8001078:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800107a:	230c      	movs	r3, #12
 800107c:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800107e:	1d3b      	adds	r3, r7, #4
 8001080:	4619      	mov	r1, r3
 8001082:	481f      	ldr	r0, [pc, #124]	; (8001100 <HAL_FMC_MspInit+0xf4>)
 8001084:	f000 fcbe 	bl	8001a04 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4
 8001088:	f248 3337 	movw	r3, #33591	; 0x8337
 800108c:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_5|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800108e:	2302      	movs	r3, #2
 8001090:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001092:	2300      	movs	r3, #0
 8001094:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001096:	2303      	movs	r3, #3
 8001098:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800109a:	230c      	movs	r3, #12
 800109c:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 800109e:	1d3b      	adds	r3, r7, #4
 80010a0:	4619      	mov	r1, r3
 80010a2:	4818      	ldr	r0, [pc, #96]	; (8001104 <HAL_FMC_MspInit+0xf8>)
 80010a4:	f000 fcae 	bl	8001a04 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10
 80010a8:	f64f 7383 	movw	r3, #65411	; 0xff83
 80010ac:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80010ae:	2302      	movs	r3, #2
 80010b0:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010b2:	2300      	movs	r3, #0
 80010b4:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80010b6:	2303      	movs	r3, #3
 80010b8:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 80010ba:	230c      	movs	r3, #12
 80010bc:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80010be:	1d3b      	adds	r3, r7, #4
 80010c0:	4619      	mov	r1, r3
 80010c2:	4811      	ldr	r0, [pc, #68]	; (8001108 <HAL_FMC_MspInit+0xfc>)
 80010c4:	f000 fc9e 	bl	8001a04 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
 80010c8:	f64d 7373 	movw	r3, #57203	; 0xdf73
 80010cc:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_12|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_0
                          |GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80010ce:	2302      	movs	r3, #2
 80010d0:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010d2:	2300      	movs	r3, #0
 80010d4:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80010d6:	2303      	movs	r3, #3
 80010d8:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 80010da:	230c      	movs	r3, #12
 80010dc:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80010de:	1d3b      	adds	r3, r7, #4
 80010e0:	4619      	mov	r1, r3
 80010e2:	480a      	ldr	r0, [pc, #40]	; (800110c <HAL_FMC_MspInit+0x100>)
 80010e4:	f000 fc8e 	bl	8001a04 <HAL_GPIO_Init>
 80010e8:	e000      	b.n	80010ec <HAL_FMC_MspInit+0xe0>
    return;
 80010ea:	bf00      	nop

  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}
 80010ec:	3718      	adds	r7, #24
 80010ee:	46bd      	mov	sp, r7
 80010f0:	bd80      	pop	{r7, pc}
 80010f2:	bf00      	nop
 80010f4:	200080fc 	.word	0x200080fc
 80010f8:	40023800 	.word	0x40023800
 80010fc:	40021400 	.word	0x40021400
 8001100:	40020800 	.word	0x40020800
 8001104:	40021800 	.word	0x40021800
 8001108:	40021000 	.word	0x40021000
 800110c:	40020c00 	.word	0x40020c00

08001110 <HAL_SDRAM_MspInit>:
  /* USER CODE BEGIN NAND_MspInit 1 */

  /* USER CODE END NAND_MspInit 1 */
}

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* hsdram){
 8001110:	b580      	push	{r7, lr}
 8001112:	b082      	sub	sp, #8
 8001114:	af00      	add	r7, sp, #0
 8001116:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN SDRAM_MspInit 0 */

  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
 8001118:	f7ff ff78 	bl	800100c <HAL_FMC_MspInit>
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
 800111c:	bf00      	nop
 800111e:	3708      	adds	r7, #8
 8001120:	46bd      	mov	sp, r7
 8001122:	bd80      	pop	{r7, pc}

08001124 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8001124:	b580      	push	{r7, lr}
 8001126:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  HAL_RCC_NMI_IRQHandler();
 8001128:	f002 ff42 	bl	8003fb0 <HAL_RCC_NMI_IRQHandler>
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 800112c:	bf00      	nop
 800112e:	bd80      	pop	{r7, pc}

08001130 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8001130:	b480      	push	{r7}
 8001132:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8001134:	e7fe      	b.n	8001134 <HardFault_Handler+0x4>

08001136 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8001136:	b480      	push	{r7}
 8001138:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800113a:	e7fe      	b.n	800113a <MemManage_Handler+0x4>

0800113c <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800113c:	b480      	push	{r7}
 800113e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8001140:	e7fe      	b.n	8001140 <BusFault_Handler+0x4>

08001142 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8001142:	b480      	push	{r7}
 8001144:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001146:	e7fe      	b.n	8001146 <UsageFault_Handler+0x4>

08001148 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8001148:	b480      	push	{r7}
 800114a:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800114c:	bf00      	nop
 800114e:	46bd      	mov	sp, r7
 8001150:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001154:	4770      	bx	lr

08001156 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8001156:	b480      	push	{r7}
 8001158:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800115a:	bf00      	nop
 800115c:	46bd      	mov	sp, r7
 800115e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001162:	4770      	bx	lr

08001164 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8001164:	b480      	push	{r7}
 8001166:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8001168:	bf00      	nop
 800116a:	46bd      	mov	sp, r7
 800116c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001170:	4770      	bx	lr

08001172 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8001172:	b580      	push	{r7, lr}
 8001174:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8001176:	f000 f8e9 	bl	800134c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 800117a:	bf00      	nop
 800117c:	bd80      	pop	{r7, pc}
	...

08001180 <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 8001180:	b580      	push	{r7, lr}
 8001182:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 8001184:	4802      	ldr	r0, [pc, #8]	; (8001190 <OTG_FS_IRQHandler+0x10>)
 8001186:	f001 faba 	bl	80026fe <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 800118a:	bf00      	nop
 800118c:	bd80      	pop	{r7, pc}
 800118e:	bf00      	nop
 8001190:	200095dc 	.word	0x200095dc

08001194 <LTDC_IRQHandler>:

/**
  * @brief This function handles LTDC global interrupt.
  */
void LTDC_IRQHandler(void)
{
 8001194:	b580      	push	{r7, lr}
 8001196:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN LTDC_IRQn 0 */

  /* USER CODE END LTDC_IRQn 0 */
  HAL_LTDC_IRQHandler(&hltdc);
 8001198:	4802      	ldr	r0, [pc, #8]	; (80011a4 <LTDC_IRQHandler+0x10>)
 800119a:	f000 fec9 	bl	8001f30 <HAL_LTDC_IRQHandler>
  /* USER CODE BEGIN LTDC_IRQn 1 */

  /* USER CODE END LTDC_IRQn 1 */
}
 800119e:	bf00      	nop
 80011a0:	bd80      	pop	{r7, pc}
 80011a2:	bf00      	nop
 80011a4:	20007fd0 	.word	0x20007fd0

080011a8 <DMA2D_IRQHandler>:

/**
  * @brief This function handles DMA2D global interrupt.
  */
void DMA2D_IRQHandler(void)
{
 80011a8:	b580      	push	{r7, lr}
 80011aa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2D_IRQn 0 */

  /* USER CODE END DMA2D_IRQn 0 */
  HAL_DMA2D_IRQHandler(&hdma2d);
 80011ac:	4802      	ldr	r0, [pc, #8]	; (80011b8 <DMA2D_IRQHandler+0x10>)
 80011ae:	f000 fa87 	bl	80016c0 <HAL_DMA2D_IRQHandler>
  /* USER CODE BEGIN DMA2D_IRQn 1 */

  /* USER CODE END DMA2D_IRQn 1 */
}
 80011b2:	bf00      	nop
 80011b4:	bd80      	pop	{r7, pc}
 80011b6:	bf00      	nop
 80011b8:	20007f90 	.word	0x20007f90

080011bc <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 80011bc:	b580      	push	{r7, lr}
 80011be:	b086      	sub	sp, #24
 80011c0:	af00      	add	r7, sp, #0
 80011c2:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80011c4:	4a14      	ldr	r2, [pc, #80]	; (8001218 <_sbrk+0x5c>)
 80011c6:	4b15      	ldr	r3, [pc, #84]	; (800121c <_sbrk+0x60>)
 80011c8:	1ad3      	subs	r3, r2, r3
 80011ca:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 80011cc:	697b      	ldr	r3, [r7, #20]
 80011ce:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initalize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80011d0:	4b13      	ldr	r3, [pc, #76]	; (8001220 <_sbrk+0x64>)
 80011d2:	681b      	ldr	r3, [r3, #0]
 80011d4:	2b00      	cmp	r3, #0
 80011d6:	d102      	bne.n	80011de <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 80011d8:	4b11      	ldr	r3, [pc, #68]	; (8001220 <_sbrk+0x64>)
 80011da:	4a12      	ldr	r2, [pc, #72]	; (8001224 <_sbrk+0x68>)
 80011dc:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 80011de:	4b10      	ldr	r3, [pc, #64]	; (8001220 <_sbrk+0x64>)
 80011e0:	681a      	ldr	r2, [r3, #0]
 80011e2:	687b      	ldr	r3, [r7, #4]
 80011e4:	4413      	add	r3, r2
 80011e6:	693a      	ldr	r2, [r7, #16]
 80011e8:	429a      	cmp	r2, r3
 80011ea:	d207      	bcs.n	80011fc <_sbrk+0x40>
  {
    errno = ENOMEM;
 80011ec:	f02d f854 	bl	802e298 <__errno>
 80011f0:	4603      	mov	r3, r0
 80011f2:	220c      	movs	r2, #12
 80011f4:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 80011f6:	f04f 33ff 	mov.w	r3, #4294967295
 80011fa:	e009      	b.n	8001210 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 80011fc:	4b08      	ldr	r3, [pc, #32]	; (8001220 <_sbrk+0x64>)
 80011fe:	681b      	ldr	r3, [r3, #0]
 8001200:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8001202:	4b07      	ldr	r3, [pc, #28]	; (8001220 <_sbrk+0x64>)
 8001204:	681a      	ldr	r2, [r3, #0]
 8001206:	687b      	ldr	r3, [r7, #4]
 8001208:	4413      	add	r3, r2
 800120a:	4a05      	ldr	r2, [pc, #20]	; (8001220 <_sbrk+0x64>)
 800120c:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 800120e:	68fb      	ldr	r3, [r7, #12]
}
 8001210:	4618      	mov	r0, r3
 8001212:	3718      	adds	r7, #24
 8001214:	46bd      	mov	sp, r7
 8001216:	bd80      	pop	{r7, pc}
 8001218:	20030000 	.word	0x20030000
 800121c:	00002000 	.word	0x00002000
 8001220:	20008100 	.word	0x20008100
 8001224:	200124b0 	.word	0x200124b0

08001228 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8001228:	b480      	push	{r7}
 800122a:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800122c:	4b08      	ldr	r3, [pc, #32]	; (8001250 <SystemInit+0x28>)
 800122e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8001232:	4a07      	ldr	r2, [pc, #28]	; (8001250 <SystemInit+0x28>)
 8001234:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8001238:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800123c:	4b04      	ldr	r3, [pc, #16]	; (8001250 <SystemInit+0x28>)
 800123e:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8001242:	609a      	str	r2, [r3, #8]
#endif
}
 8001244:	bf00      	nop
 8001246:	46bd      	mov	sp, r7
 8001248:	f85d 7b04 	ldr.w	r7, [sp], #4
 800124c:	4770      	bx	lr
 800124e:	bf00      	nop
 8001250:	e000ed00 	.word	0xe000ed00

08001254 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler: 
  ldr   sp, =_estack       /* set stack pointer */
 8001254:	f8df d034 	ldr.w	sp, [pc, #52]	; 800128c <LoopFillZerobss+0x14>
 
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8001258:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800125a:	e003      	b.n	8001264 <LoopCopyDataInit>

0800125c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800125c:	4b0c      	ldr	r3, [pc, #48]	; (8001290 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800125e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8001260:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8001262:	3104      	adds	r1, #4

08001264 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8001264:	480b      	ldr	r0, [pc, #44]	; (8001294 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8001266:	4b0c      	ldr	r3, [pc, #48]	; (8001298 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8001268:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800126a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800126c:	d3f6      	bcc.n	800125c <CopyDataInit>
  ldr  r2, =_sbss
 800126e:	4a0b      	ldr	r2, [pc, #44]	; (800129c <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8001270:	e002      	b.n	8001278 <LoopFillZerobss>

08001272 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8001272:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8001274:	f842 3b04 	str.w	r3, [r2], #4

08001278 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8001278:	4b09      	ldr	r3, [pc, #36]	; (80012a0 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800127a:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800127c:	d3f9      	bcc.n	8001272 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800127e:	f7ff ffd3 	bl	8001228 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8001282:	f02d f80f 	bl	802e2a4 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001286:	f7ff fad7 	bl	8000838 <main>
  bx  lr    
 800128a:	4770      	bx	lr
  ldr   sp, =_estack       /* set stack pointer */
 800128c:	20030000 	.word	0x20030000
  ldr  r3, =_sidata
 8001290:	080f23ec 	.word	0x080f23ec
  ldr  r0, =_sdata
 8001294:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8001298:	20000268 	.word	0x20000268
  ldr  r2, =_sbss
 800129c:	20007f68 	.word	0x20007f68
  ldr  r3, = _ebss
 80012a0:	200124b0 	.word	0x200124b0

080012a4 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80012a4:	e7fe      	b.n	80012a4 <ADC_IRQHandler>
	...

080012a8 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80012a8:	b580      	push	{r7, lr}
 80012aa:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80012ac:	4b0e      	ldr	r3, [pc, #56]	; (80012e8 <HAL_Init+0x40>)
 80012ae:	681b      	ldr	r3, [r3, #0]
 80012b0:	4a0d      	ldr	r2, [pc, #52]	; (80012e8 <HAL_Init+0x40>)
 80012b2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80012b6:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 80012b8:	4b0b      	ldr	r3, [pc, #44]	; (80012e8 <HAL_Init+0x40>)
 80012ba:	681b      	ldr	r3, [r3, #0]
 80012bc:	4a0a      	ldr	r2, [pc, #40]	; (80012e8 <HAL_Init+0x40>)
 80012be:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80012c2:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80012c4:	4b08      	ldr	r3, [pc, #32]	; (80012e8 <HAL_Init+0x40>)
 80012c6:	681b      	ldr	r3, [r3, #0]
 80012c8:	4a07      	ldr	r2, [pc, #28]	; (80012e8 <HAL_Init+0x40>)
 80012ca:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80012ce:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80012d0:	2003      	movs	r0, #3
 80012d2:	f000 f94f 	bl	8001574 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80012d6:	2000      	movs	r0, #0
 80012d8:	f000 f808 	bl	80012ec <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 80012dc:	f7ff fd70 	bl	8000dc0 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 80012e0:	2300      	movs	r3, #0
}
 80012e2:	4618      	mov	r0, r3
 80012e4:	bd80      	pop	{r7, pc}
 80012e6:	bf00      	nop
 80012e8:	40023c00 	.word	0x40023c00

080012ec <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80012ec:	b580      	push	{r7, lr}
 80012ee:	b082      	sub	sp, #8
 80012f0:	af00      	add	r7, sp, #0
 80012f2:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 80012f4:	4b12      	ldr	r3, [pc, #72]	; (8001340 <HAL_InitTick+0x54>)
 80012f6:	681a      	ldr	r2, [r3, #0]
 80012f8:	4b12      	ldr	r3, [pc, #72]	; (8001344 <HAL_InitTick+0x58>)
 80012fa:	781b      	ldrb	r3, [r3, #0]
 80012fc:	4619      	mov	r1, r3
 80012fe:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001302:	fbb3 f3f1 	udiv	r3, r3, r1
 8001306:	fbb2 f3f3 	udiv	r3, r2, r3
 800130a:	4618      	mov	r0, r3
 800130c:	f000 f967 	bl	80015de <HAL_SYSTICK_Config>
 8001310:	4603      	mov	r3, r0
 8001312:	2b00      	cmp	r3, #0
 8001314:	d001      	beq.n	800131a <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 8001316:	2301      	movs	r3, #1
 8001318:	e00e      	b.n	8001338 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800131a:	687b      	ldr	r3, [r7, #4]
 800131c:	2b0f      	cmp	r3, #15
 800131e:	d80a      	bhi.n	8001336 <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001320:	2200      	movs	r2, #0
 8001322:	6879      	ldr	r1, [r7, #4]
 8001324:	f04f 30ff 	mov.w	r0, #4294967295
 8001328:	f000 f92f 	bl	800158a <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 800132c:	4a06      	ldr	r2, [pc, #24]	; (8001348 <HAL_InitTick+0x5c>)
 800132e:	687b      	ldr	r3, [r7, #4]
 8001330:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8001332:	2300      	movs	r3, #0
 8001334:	e000      	b.n	8001338 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 8001336:	2301      	movs	r3, #1
}
 8001338:	4618      	mov	r0, r3
 800133a:	3708      	adds	r7, #8
 800133c:	46bd      	mov	sp, r7
 800133e:	bd80      	pop	{r7, pc}
 8001340:	20000008 	.word	0x20000008
 8001344:	20000010 	.word	0x20000010
 8001348:	2000000c 	.word	0x2000000c

0800134c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 800134c:	b480      	push	{r7}
 800134e:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8001350:	4b06      	ldr	r3, [pc, #24]	; (800136c <HAL_IncTick+0x20>)
 8001352:	781b      	ldrb	r3, [r3, #0]
 8001354:	461a      	mov	r2, r3
 8001356:	4b06      	ldr	r3, [pc, #24]	; (8001370 <HAL_IncTick+0x24>)
 8001358:	681b      	ldr	r3, [r3, #0]
 800135a:	4413      	add	r3, r2
 800135c:	4a04      	ldr	r2, [pc, #16]	; (8001370 <HAL_IncTick+0x24>)
 800135e:	6013      	str	r3, [r2, #0]
}
 8001360:	bf00      	nop
 8001362:	46bd      	mov	sp, r7
 8001364:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001368:	4770      	bx	lr
 800136a:	bf00      	nop
 800136c:	20000010 	.word	0x20000010
 8001370:	20008104 	.word	0x20008104

08001374 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001374:	b480      	push	{r7}
 8001376:	af00      	add	r7, sp, #0
  return uwTick;
 8001378:	4b03      	ldr	r3, [pc, #12]	; (8001388 <HAL_GetTick+0x14>)
 800137a:	681b      	ldr	r3, [r3, #0]
}
 800137c:	4618      	mov	r0, r3
 800137e:	46bd      	mov	sp, r7
 8001380:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001384:	4770      	bx	lr
 8001386:	bf00      	nop
 8001388:	20008104 	.word	0x20008104

0800138c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800138c:	b580      	push	{r7, lr}
 800138e:	b084      	sub	sp, #16
 8001390:	af00      	add	r7, sp, #0
 8001392:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8001394:	f7ff ffee 	bl	8001374 <HAL_GetTick>
 8001398:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 800139a:	687b      	ldr	r3, [r7, #4]
 800139c:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800139e:	68fb      	ldr	r3, [r7, #12]
 80013a0:	f1b3 3fff 	cmp.w	r3, #4294967295
 80013a4:	d005      	beq.n	80013b2 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 80013a6:	4b0a      	ldr	r3, [pc, #40]	; (80013d0 <HAL_Delay+0x44>)
 80013a8:	781b      	ldrb	r3, [r3, #0]
 80013aa:	461a      	mov	r2, r3
 80013ac:	68fb      	ldr	r3, [r7, #12]
 80013ae:	4413      	add	r3, r2
 80013b0:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 80013b2:	bf00      	nop
 80013b4:	f7ff ffde 	bl	8001374 <HAL_GetTick>
 80013b8:	4602      	mov	r2, r0
 80013ba:	68bb      	ldr	r3, [r7, #8]
 80013bc:	1ad3      	subs	r3, r2, r3
 80013be:	68fa      	ldr	r2, [r7, #12]
 80013c0:	429a      	cmp	r2, r3
 80013c2:	d8f7      	bhi.n	80013b4 <HAL_Delay+0x28>
  {
  }
}
 80013c4:	bf00      	nop
 80013c6:	bf00      	nop
 80013c8:	3710      	adds	r7, #16
 80013ca:	46bd      	mov	sp, r7
 80013cc:	bd80      	pop	{r7, pc}
 80013ce:	bf00      	nop
 80013d0:	20000010 	.word	0x20000010

080013d4 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80013d4:	b480      	push	{r7}
 80013d6:	b085      	sub	sp, #20
 80013d8:	af00      	add	r7, sp, #0
 80013da:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80013dc:	687b      	ldr	r3, [r7, #4]
 80013de:	f003 0307 	and.w	r3, r3, #7
 80013e2:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80013e4:	4b0c      	ldr	r3, [pc, #48]	; (8001418 <__NVIC_SetPriorityGrouping+0x44>)
 80013e6:	68db      	ldr	r3, [r3, #12]
 80013e8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80013ea:	68ba      	ldr	r2, [r7, #8]
 80013ec:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80013f0:	4013      	ands	r3, r2
 80013f2:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80013f4:	68fb      	ldr	r3, [r7, #12]
 80013f6:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80013f8:	68bb      	ldr	r3, [r7, #8]
 80013fa:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80013fc:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8001400:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001404:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8001406:	4a04      	ldr	r2, [pc, #16]	; (8001418 <__NVIC_SetPriorityGrouping+0x44>)
 8001408:	68bb      	ldr	r3, [r7, #8]
 800140a:	60d3      	str	r3, [r2, #12]
}
 800140c:	bf00      	nop
 800140e:	3714      	adds	r7, #20
 8001410:	46bd      	mov	sp, r7
 8001412:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001416:	4770      	bx	lr
 8001418:	e000ed00 	.word	0xe000ed00

0800141c <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 800141c:	b480      	push	{r7}
 800141e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001420:	4b04      	ldr	r3, [pc, #16]	; (8001434 <__NVIC_GetPriorityGrouping+0x18>)
 8001422:	68db      	ldr	r3, [r3, #12]
 8001424:	0a1b      	lsrs	r3, r3, #8
 8001426:	f003 0307 	and.w	r3, r3, #7
}
 800142a:	4618      	mov	r0, r3
 800142c:	46bd      	mov	sp, r7
 800142e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001432:	4770      	bx	lr
 8001434:	e000ed00 	.word	0xe000ed00

08001438 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8001438:	b480      	push	{r7}
 800143a:	b083      	sub	sp, #12
 800143c:	af00      	add	r7, sp, #0
 800143e:	4603      	mov	r3, r0
 8001440:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001442:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001446:	2b00      	cmp	r3, #0
 8001448:	db0b      	blt.n	8001462 <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800144a:	79fb      	ldrb	r3, [r7, #7]
 800144c:	f003 021f 	and.w	r2, r3, #31
 8001450:	4907      	ldr	r1, [pc, #28]	; (8001470 <__NVIC_EnableIRQ+0x38>)
 8001452:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001456:	095b      	lsrs	r3, r3, #5
 8001458:	2001      	movs	r0, #1
 800145a:	fa00 f202 	lsl.w	r2, r0, r2
 800145e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 8001462:	bf00      	nop
 8001464:	370c      	adds	r7, #12
 8001466:	46bd      	mov	sp, r7
 8001468:	f85d 7b04 	ldr.w	r7, [sp], #4
 800146c:	4770      	bx	lr
 800146e:	bf00      	nop
 8001470:	e000e100 	.word	0xe000e100

08001474 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8001474:	b480      	push	{r7}
 8001476:	b083      	sub	sp, #12
 8001478:	af00      	add	r7, sp, #0
 800147a:	4603      	mov	r3, r0
 800147c:	6039      	str	r1, [r7, #0]
 800147e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8001480:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001484:	2b00      	cmp	r3, #0
 8001486:	db0a      	blt.n	800149e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001488:	683b      	ldr	r3, [r7, #0]
 800148a:	b2da      	uxtb	r2, r3
 800148c:	490c      	ldr	r1, [pc, #48]	; (80014c0 <__NVIC_SetPriority+0x4c>)
 800148e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8001492:	0112      	lsls	r2, r2, #4
 8001494:	b2d2      	uxtb	r2, r2
 8001496:	440b      	add	r3, r1
 8001498:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 800149c:	e00a      	b.n	80014b4 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800149e:	683b      	ldr	r3, [r7, #0]
 80014a0:	b2da      	uxtb	r2, r3
 80014a2:	4908      	ldr	r1, [pc, #32]	; (80014c4 <__NVIC_SetPriority+0x50>)
 80014a4:	79fb      	ldrb	r3, [r7, #7]
 80014a6:	f003 030f 	and.w	r3, r3, #15
 80014aa:	3b04      	subs	r3, #4
 80014ac:	0112      	lsls	r2, r2, #4
 80014ae:	b2d2      	uxtb	r2, r2
 80014b0:	440b      	add	r3, r1
 80014b2:	761a      	strb	r2, [r3, #24]
}
 80014b4:	bf00      	nop
 80014b6:	370c      	adds	r7, #12
 80014b8:	46bd      	mov	sp, r7
 80014ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80014be:	4770      	bx	lr
 80014c0:	e000e100 	.word	0xe000e100
 80014c4:	e000ed00 	.word	0xe000ed00

080014c8 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80014c8:	b480      	push	{r7}
 80014ca:	b089      	sub	sp, #36	; 0x24
 80014cc:	af00      	add	r7, sp, #0
 80014ce:	60f8      	str	r0, [r7, #12]
 80014d0:	60b9      	str	r1, [r7, #8]
 80014d2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80014d4:	68fb      	ldr	r3, [r7, #12]
 80014d6:	f003 0307 	and.w	r3, r3, #7
 80014da:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80014dc:	69fb      	ldr	r3, [r7, #28]
 80014de:	f1c3 0307 	rsb	r3, r3, #7
 80014e2:	2b04      	cmp	r3, #4
 80014e4:	bf28      	it	cs
 80014e6:	2304      	movcs	r3, #4
 80014e8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80014ea:	69fb      	ldr	r3, [r7, #28]
 80014ec:	3304      	adds	r3, #4
 80014ee:	2b06      	cmp	r3, #6
 80014f0:	d902      	bls.n	80014f8 <NVIC_EncodePriority+0x30>
 80014f2:	69fb      	ldr	r3, [r7, #28]
 80014f4:	3b03      	subs	r3, #3
 80014f6:	e000      	b.n	80014fa <NVIC_EncodePriority+0x32>
 80014f8:	2300      	movs	r3, #0
 80014fa:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80014fc:	f04f 32ff 	mov.w	r2, #4294967295
 8001500:	69bb      	ldr	r3, [r7, #24]
 8001502:	fa02 f303 	lsl.w	r3, r2, r3
 8001506:	43da      	mvns	r2, r3
 8001508:	68bb      	ldr	r3, [r7, #8]
 800150a:	401a      	ands	r2, r3
 800150c:	697b      	ldr	r3, [r7, #20]
 800150e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001510:	f04f 31ff 	mov.w	r1, #4294967295
 8001514:	697b      	ldr	r3, [r7, #20]
 8001516:	fa01 f303 	lsl.w	r3, r1, r3
 800151a:	43d9      	mvns	r1, r3
 800151c:	687b      	ldr	r3, [r7, #4]
 800151e:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001520:	4313      	orrs	r3, r2
         );
}
 8001522:	4618      	mov	r0, r3
 8001524:	3724      	adds	r7, #36	; 0x24
 8001526:	46bd      	mov	sp, r7
 8001528:	f85d 7b04 	ldr.w	r7, [sp], #4
 800152c:	4770      	bx	lr
	...

08001530 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8001530:	b580      	push	{r7, lr}
 8001532:	b082      	sub	sp, #8
 8001534:	af00      	add	r7, sp, #0
 8001536:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001538:	687b      	ldr	r3, [r7, #4]
 800153a:	3b01      	subs	r3, #1
 800153c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8001540:	d301      	bcc.n	8001546 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8001542:	2301      	movs	r3, #1
 8001544:	e00f      	b.n	8001566 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001546:	4a0a      	ldr	r2, [pc, #40]	; (8001570 <SysTick_Config+0x40>)
 8001548:	687b      	ldr	r3, [r7, #4]
 800154a:	3b01      	subs	r3, #1
 800154c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 800154e:	210f      	movs	r1, #15
 8001550:	f04f 30ff 	mov.w	r0, #4294967295
 8001554:	f7ff ff8e 	bl	8001474 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001558:	4b05      	ldr	r3, [pc, #20]	; (8001570 <SysTick_Config+0x40>)
 800155a:	2200      	movs	r2, #0
 800155c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800155e:	4b04      	ldr	r3, [pc, #16]	; (8001570 <SysTick_Config+0x40>)
 8001560:	2207      	movs	r2, #7
 8001562:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8001564:	2300      	movs	r3, #0
}
 8001566:	4618      	mov	r0, r3
 8001568:	3708      	adds	r7, #8
 800156a:	46bd      	mov	sp, r7
 800156c:	bd80      	pop	{r7, pc}
 800156e:	bf00      	nop
 8001570:	e000e010 	.word	0xe000e010

08001574 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8001574:	b580      	push	{r7, lr}
 8001576:	b082      	sub	sp, #8
 8001578:	af00      	add	r7, sp, #0
 800157a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 800157c:	6878      	ldr	r0, [r7, #4]
 800157e:	f7ff ff29 	bl	80013d4 <__NVIC_SetPriorityGrouping>
}
 8001582:	bf00      	nop
 8001584:	3708      	adds	r7, #8
 8001586:	46bd      	mov	sp, r7
 8001588:	bd80      	pop	{r7, pc}

0800158a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 800158a:	b580      	push	{r7, lr}
 800158c:	b086      	sub	sp, #24
 800158e:	af00      	add	r7, sp, #0
 8001590:	4603      	mov	r3, r0
 8001592:	60b9      	str	r1, [r7, #8]
 8001594:	607a      	str	r2, [r7, #4]
 8001596:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8001598:	2300      	movs	r3, #0
 800159a:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 800159c:	f7ff ff3e 	bl	800141c <__NVIC_GetPriorityGrouping>
 80015a0:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 80015a2:	687a      	ldr	r2, [r7, #4]
 80015a4:	68b9      	ldr	r1, [r7, #8]
 80015a6:	6978      	ldr	r0, [r7, #20]
 80015a8:	f7ff ff8e 	bl	80014c8 <NVIC_EncodePriority>
 80015ac:	4602      	mov	r2, r0
 80015ae:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80015b2:	4611      	mov	r1, r2
 80015b4:	4618      	mov	r0, r3
 80015b6:	f7ff ff5d 	bl	8001474 <__NVIC_SetPriority>
}
 80015ba:	bf00      	nop
 80015bc:	3718      	adds	r7, #24
 80015be:	46bd      	mov	sp, r7
 80015c0:	bd80      	pop	{r7, pc}

080015c2 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80015c2:	b580      	push	{r7, lr}
 80015c4:	b082      	sub	sp, #8
 80015c6:	af00      	add	r7, sp, #0
 80015c8:	4603      	mov	r3, r0
 80015ca:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 80015cc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80015d0:	4618      	mov	r0, r3
 80015d2:	f7ff ff31 	bl	8001438 <__NVIC_EnableIRQ>
}
 80015d6:	bf00      	nop
 80015d8:	3708      	adds	r7, #8
 80015da:	46bd      	mov	sp, r7
 80015dc:	bd80      	pop	{r7, pc}

080015de <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80015de:	b580      	push	{r7, lr}
 80015e0:	b082      	sub	sp, #8
 80015e2:	af00      	add	r7, sp, #0
 80015e4:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 80015e6:	6878      	ldr	r0, [r7, #4]
 80015e8:	f7ff ffa2 	bl	8001530 <SysTick_Config>
 80015ec:	4603      	mov	r3, r0
}
 80015ee:	4618      	mov	r0, r3
 80015f0:	3708      	adds	r7, #8
 80015f2:	46bd      	mov	sp, r7
 80015f4:	bd80      	pop	{r7, pc}

080015f6 <HAL_CRC_Init>:
  *         parameters in the CRC_InitTypeDef and create the associated handle.
  * @param  hcrc CRC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
 80015f6:	b580      	push	{r7, lr}
 80015f8:	b082      	sub	sp, #8
 80015fa:	af00      	add	r7, sp, #0
 80015fc:	6078      	str	r0, [r7, #4]
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 80015fe:	687b      	ldr	r3, [r7, #4]
 8001600:	2b00      	cmp	r3, #0
 8001602:	d101      	bne.n	8001608 <HAL_CRC_Init+0x12>
  {
    return HAL_ERROR;
 8001604:	2301      	movs	r3, #1
 8001606:	e00e      	b.n	8001626 <HAL_CRC_Init+0x30>
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if (hcrc->State == HAL_CRC_STATE_RESET)
 8001608:	687b      	ldr	r3, [r7, #4]
 800160a:	795b      	ldrb	r3, [r3, #5]
 800160c:	b2db      	uxtb	r3, r3
 800160e:	2b00      	cmp	r3, #0
 8001610:	d105      	bne.n	800161e <HAL_CRC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
 8001612:	687b      	ldr	r3, [r7, #4]
 8001614:	2200      	movs	r2, #0
 8001616:	711a      	strb	r2, [r3, #4]
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
 8001618:	6878      	ldr	r0, [r7, #4]
 800161a:	f7ff fbf9 	bl	8000e10 <HAL_CRC_MspInit>
  }

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 800161e:	687b      	ldr	r3, [r7, #4]
 8001620:	2201      	movs	r2, #1
 8001622:	715a      	strb	r2, [r3, #5]

  /* Return function status */
  return HAL_OK;
 8001624:	2300      	movs	r3, #0
}
 8001626:	4618      	mov	r0, r3
 8001628:	3708      	adds	r7, #8
 800162a:	46bd      	mov	sp, r7
 800162c:	bd80      	pop	{r7, pc}

0800162e <HAL_DMA2D_Init>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
 800162e:	b580      	push	{r7, lr}
 8001630:	b082      	sub	sp, #8
 8001632:	af00      	add	r7, sp, #0
 8001634:	6078      	str	r0, [r7, #4]
  /* Check the DMA2D peripheral state */
  if(hdma2d == NULL)
 8001636:	687b      	ldr	r3, [r7, #4]
 8001638:	2b00      	cmp	r3, #0
 800163a:	d101      	bne.n	8001640 <HAL_DMA2D_Init+0x12>
  {
     return HAL_ERROR;
 800163c:	2301      	movs	r3, #1
 800163e:	e03b      	b.n	80016b8 <HAL_DMA2D_Init+0x8a>

    /* Init the low level hardware */
    hdma2d->MspInitCallback(hdma2d);
  }
#else
  if(hdma2d->State == HAL_DMA2D_STATE_RESET)
 8001640:	687b      	ldr	r3, [r7, #4]
 8001642:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8001646:	b2db      	uxtb	r3, r3
 8001648:	2b00      	cmp	r3, #0
 800164a:	d106      	bne.n	800165a <HAL_DMA2D_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hdma2d->Lock = HAL_UNLOCKED;
 800164c:	687b      	ldr	r3, [r7, #4]
 800164e:	2200      	movs	r2, #0
 8001650:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware */
    HAL_DMA2D_MspInit(hdma2d);
 8001654:	6878      	ldr	r0, [r7, #4]
 8001656:	f7ff fbfd 	bl	8000e54 <HAL_DMA2D_MspInit>
  }
#endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 800165a:	687b      	ldr	r3, [r7, #4]
 800165c:	2202      	movs	r2, #2
 800165e:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8001662:	687b      	ldr	r3, [r7, #4]
 8001664:	681b      	ldr	r3, [r3, #0]
 8001666:	681b      	ldr	r3, [r3, #0]
 8001668:	f423 3140 	bic.w	r1, r3, #196608	; 0x30000
 800166c:	687b      	ldr	r3, [r7, #4]
 800166e:	685a      	ldr	r2, [r3, #4]
 8001670:	687b      	ldr	r3, [r7, #4]
 8001672:	681b      	ldr	r3, [r3, #0]
 8001674:	430a      	orrs	r2, r1
 8001676:	601a      	str	r2, [r3, #0]

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 8001678:	687b      	ldr	r3, [r7, #4]
 800167a:	681b      	ldr	r3, [r3, #0]
 800167c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800167e:	f023 0107 	bic.w	r1, r3, #7
 8001682:	687b      	ldr	r3, [r7, #4]
 8001684:	689a      	ldr	r2, [r3, #8]
 8001686:	687b      	ldr	r3, [r7, #4]
 8001688:	681b      	ldr	r3, [r3, #0]
 800168a:	430a      	orrs	r2, r1
 800168c:	635a      	str	r2, [r3, #52]	; 0x34

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
 800168e:	687b      	ldr	r3, [r7, #4]
 8001690:	681b      	ldr	r3, [r3, #0]
 8001692:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001694:	f423 537f 	bic.w	r3, r3, #16320	; 0x3fc0
 8001698:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800169c:	687a      	ldr	r2, [r7, #4]
 800169e:	68d1      	ldr	r1, [r2, #12]
 80016a0:	687a      	ldr	r2, [r7, #4]
 80016a2:	6812      	ldr	r2, [r2, #0]
 80016a4:	430b      	orrs	r3, r1
 80016a6:	6413      	str	r3, [r2, #64]	; 0x40


  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 80016a8:	687b      	ldr	r3, [r7, #4]
 80016aa:	2200      	movs	r2, #0
 80016ac:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 80016ae:	687b      	ldr	r3, [r7, #4]
 80016b0:	2201      	movs	r2, #1
 80016b2:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  return HAL_OK;
 80016b6:	2300      	movs	r3, #0
}
 80016b8:	4618      	mov	r0, r3
 80016ba:	3708      	adds	r7, #8
 80016bc:	46bd      	mov	sp, r7
 80016be:	bd80      	pop	{r7, pc}

080016c0 <HAL_DMA2D_IRQHandler>:
  * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
void HAL_DMA2D_IRQHandler(DMA2D_HandleTypeDef *hdma2d)
{
 80016c0:	b580      	push	{r7, lr}
 80016c2:	b084      	sub	sp, #16
 80016c4:	af00      	add	r7, sp, #0
 80016c6:	6078      	str	r0, [r7, #4]
  uint32_t isrflags = READ_REG(hdma2d->Instance->ISR);
 80016c8:	687b      	ldr	r3, [r7, #4]
 80016ca:	681b      	ldr	r3, [r3, #0]
 80016cc:	685b      	ldr	r3, [r3, #4]
 80016ce:	60fb      	str	r3, [r7, #12]
  uint32_t crflags = READ_REG(hdma2d->Instance->CR);
 80016d0:	687b      	ldr	r3, [r7, #4]
 80016d2:	681b      	ldr	r3, [r3, #0]
 80016d4:	681b      	ldr	r3, [r3, #0]
 80016d6:	60bb      	str	r3, [r7, #8]

  /* Transfer Error Interrupt management ***************************************/
  if ((isrflags & DMA2D_FLAG_TE) != 0U)
 80016d8:	68fb      	ldr	r3, [r7, #12]
 80016da:	f003 0301 	and.w	r3, r3, #1
 80016de:	2b00      	cmp	r3, #0
 80016e0:	d026      	beq.n	8001730 <HAL_DMA2D_IRQHandler+0x70>
  {
    if ((crflags & DMA2D_IT_TE) != 0U)
 80016e2:	68bb      	ldr	r3, [r7, #8]
 80016e4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80016e8:	2b00      	cmp	r3, #0
 80016ea:	d021      	beq.n	8001730 <HAL_DMA2D_IRQHandler+0x70>
    {
      /* Disable the transfer Error interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TE);
 80016ec:	687b      	ldr	r3, [r7, #4]
 80016ee:	681b      	ldr	r3, [r3, #0]
 80016f0:	681a      	ldr	r2, [r3, #0]
 80016f2:	687b      	ldr	r3, [r7, #4]
 80016f4:	681b      	ldr	r3, [r3, #0]
 80016f6:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80016fa:	601a      	str	r2, [r3, #0]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
 80016fc:	687b      	ldr	r3, [r7, #4]
 80016fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001700:	f043 0201 	orr.w	r2, r3, #1
 8001704:	687b      	ldr	r3, [r7, #4]
 8001706:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Clear the transfer error flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
 8001708:	687b      	ldr	r3, [r7, #4]
 800170a:	681b      	ldr	r3, [r3, #0]
 800170c:	2201      	movs	r2, #1
 800170e:	609a      	str	r2, [r3, #8]

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
 8001710:	687b      	ldr	r3, [r7, #4]
 8001712:	2204      	movs	r2, #4
 8001714:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
 8001718:	687b      	ldr	r3, [r7, #4]
 800171a:	2200      	movs	r2, #0
 800171c:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

      if(hdma2d->XferErrorCallback != NULL)
 8001720:	687b      	ldr	r3, [r7, #4]
 8001722:	695b      	ldr	r3, [r3, #20]
 8001724:	2b00      	cmp	r3, #0
 8001726:	d003      	beq.n	8001730 <HAL_DMA2D_IRQHandler+0x70>
      {
        /* Transfer error Callback */
        hdma2d->XferErrorCallback(hdma2d);
 8001728:	687b      	ldr	r3, [r7, #4]
 800172a:	695b      	ldr	r3, [r3, #20]
 800172c:	6878      	ldr	r0, [r7, #4]
 800172e:	4798      	blx	r3
      }
    }
  }
  /* Configuration Error Interrupt management **********************************/
  if ((isrflags & DMA2D_FLAG_CE) != 0U)
 8001730:	68fb      	ldr	r3, [r7, #12]
 8001732:	f003 0320 	and.w	r3, r3, #32
 8001736:	2b00      	cmp	r3, #0
 8001738:	d026      	beq.n	8001788 <HAL_DMA2D_IRQHandler+0xc8>
  {
    if ((crflags & DMA2D_IT_CE) != 0U)
 800173a:	68bb      	ldr	r3, [r7, #8]
 800173c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8001740:	2b00      	cmp	r3, #0
 8001742:	d021      	beq.n	8001788 <HAL_DMA2D_IRQHandler+0xc8>
    {
      /* Disable the Configuration Error interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CE);
 8001744:	687b      	ldr	r3, [r7, #4]
 8001746:	681b      	ldr	r3, [r3, #0]
 8001748:	681a      	ldr	r2, [r3, #0]
 800174a:	687b      	ldr	r3, [r7, #4]
 800174c:	681b      	ldr	r3, [r3, #0]
 800174e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8001752:	601a      	str	r2, [r3, #0]

      /* Clear the Configuration error flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
 8001754:	687b      	ldr	r3, [r7, #4]
 8001756:	681b      	ldr	r3, [r3, #0]
 8001758:	2220      	movs	r2, #32
 800175a:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
 800175c:	687b      	ldr	r3, [r7, #4]
 800175e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001760:	f043 0202 	orr.w	r2, r3, #2
 8001764:	687b      	ldr	r3, [r7, #4]
 8001766:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
 8001768:	687b      	ldr	r3, [r7, #4]
 800176a:	2204      	movs	r2, #4
 800176c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
 8001770:	687b      	ldr	r3, [r7, #4]
 8001772:	2200      	movs	r2, #0
 8001774:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

      if(hdma2d->XferErrorCallback != NULL)
 8001778:	687b      	ldr	r3, [r7, #4]
 800177a:	695b      	ldr	r3, [r3, #20]
 800177c:	2b00      	cmp	r3, #0
 800177e:	d003      	beq.n	8001788 <HAL_DMA2D_IRQHandler+0xc8>
      {
        /* Transfer error Callback */
        hdma2d->XferErrorCallback(hdma2d);
 8001780:	687b      	ldr	r3, [r7, #4]
 8001782:	695b      	ldr	r3, [r3, #20]
 8001784:	6878      	ldr	r0, [r7, #4]
 8001786:	4798      	blx	r3
      }
    }
  }
  /* CLUT access Error Interrupt management ***********************************/
  if ((isrflags & DMA2D_FLAG_CAE) != 0U)
 8001788:	68fb      	ldr	r3, [r7, #12]
 800178a:	f003 0308 	and.w	r3, r3, #8
 800178e:	2b00      	cmp	r3, #0
 8001790:	d026      	beq.n	80017e0 <HAL_DMA2D_IRQHandler+0x120>
  {
    if ((crflags & DMA2D_IT_CAE) != 0U)
 8001792:	68bb      	ldr	r3, [r7, #8]
 8001794:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8001798:	2b00      	cmp	r3, #0
 800179a:	d021      	beq.n	80017e0 <HAL_DMA2D_IRQHandler+0x120>
    {
      /* Disable the CLUT access error interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CAE);
 800179c:	687b      	ldr	r3, [r7, #4]
 800179e:	681b      	ldr	r3, [r3, #0]
 80017a0:	681a      	ldr	r2, [r3, #0]
 80017a2:	687b      	ldr	r3, [r7, #4]
 80017a4:	681b      	ldr	r3, [r3, #0]
 80017a6:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80017aa:	601a      	str	r2, [r3, #0]

      /* Clear the CLUT access error flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE);
 80017ac:	687b      	ldr	r3, [r7, #4]
 80017ae:	681b      	ldr	r3, [r3, #0]
 80017b0:	2208      	movs	r2, #8
 80017b2:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
 80017b4:	687b      	ldr	r3, [r7, #4]
 80017b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80017b8:	f043 0204 	orr.w	r2, r3, #4
 80017bc:	687b      	ldr	r3, [r7, #4]
 80017be:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
 80017c0:	687b      	ldr	r3, [r7, #4]
 80017c2:	2204      	movs	r2, #4
 80017c4:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
 80017c8:	687b      	ldr	r3, [r7, #4]
 80017ca:	2200      	movs	r2, #0
 80017cc:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

      if(hdma2d->XferErrorCallback != NULL)
 80017d0:	687b      	ldr	r3, [r7, #4]
 80017d2:	695b      	ldr	r3, [r3, #20]
 80017d4:	2b00      	cmp	r3, #0
 80017d6:	d003      	beq.n	80017e0 <HAL_DMA2D_IRQHandler+0x120>
      {
        /* Transfer error Callback */
        hdma2d->XferErrorCallback(hdma2d);
 80017d8:	687b      	ldr	r3, [r7, #4]
 80017da:	695b      	ldr	r3, [r3, #20]
 80017dc:	6878      	ldr	r0, [r7, #4]
 80017de:	4798      	blx	r3
      }
    }
  }
  /* Transfer watermark Interrupt management **********************************/
  if ((isrflags & DMA2D_FLAG_TW) != 0U)
 80017e0:	68fb      	ldr	r3, [r7, #12]
 80017e2:	f003 0304 	and.w	r3, r3, #4
 80017e6:	2b00      	cmp	r3, #0
 80017e8:	d013      	beq.n	8001812 <HAL_DMA2D_IRQHandler+0x152>
  {
    if ((crflags & DMA2D_IT_TW) != 0U)
 80017ea:	68bb      	ldr	r3, [r7, #8]
 80017ec:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80017f0:	2b00      	cmp	r3, #0
 80017f2:	d00e      	beq.n	8001812 <HAL_DMA2D_IRQHandler+0x152>
    {
      /* Disable the transfer watermark interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TW);
 80017f4:	687b      	ldr	r3, [r7, #4]
 80017f6:	681b      	ldr	r3, [r3, #0]
 80017f8:	681a      	ldr	r2, [r3, #0]
 80017fa:	687b      	ldr	r3, [r7, #4]
 80017fc:	681b      	ldr	r3, [r3, #0]
 80017fe:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001802:	601a      	str	r2, [r3, #0]

      /* Clear the transfer watermark flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TW);
 8001804:	687b      	ldr	r3, [r7, #4]
 8001806:	681b      	ldr	r3, [r3, #0]
 8001808:	2204      	movs	r2, #4
 800180a:	609a      	str	r2, [r3, #8]

      /* Transfer watermark Callback */
#if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
      hdma2d->LineEventCallback(hdma2d);
#else
      HAL_DMA2D_LineEventCallback(hdma2d);
 800180c:	6878      	ldr	r0, [r7, #4]
 800180e:	f000 f853 	bl	80018b8 <HAL_DMA2D_LineEventCallback>
#endif /* USE_HAL_DMA2D_REGISTER_CALLBACKS */

    }
  }
  /* Transfer Complete Interrupt management ************************************/
  if ((isrflags & DMA2D_FLAG_TC) != 0U)
 8001812:	68fb      	ldr	r3, [r7, #12]
 8001814:	f003 0302 	and.w	r3, r3, #2
 8001818:	2b00      	cmp	r3, #0
 800181a:	d024      	beq.n	8001866 <HAL_DMA2D_IRQHandler+0x1a6>
  {
    if ((crflags & DMA2D_IT_TC) != 0U)
 800181c:	68bb      	ldr	r3, [r7, #8]
 800181e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8001822:	2b00      	cmp	r3, #0
 8001824:	d01f      	beq.n	8001866 <HAL_DMA2D_IRQHandler+0x1a6>
    {
      /* Disable the transfer complete interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TC);
 8001826:	687b      	ldr	r3, [r7, #4]
 8001828:	681b      	ldr	r3, [r3, #0]
 800182a:	681a      	ldr	r2, [r3, #0]
 800182c:	687b      	ldr	r3, [r7, #4]
 800182e:	681b      	ldr	r3, [r3, #0]
 8001830:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001834:	601a      	str	r2, [r3, #0]

      /* Clear the transfer complete flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
 8001836:	687b      	ldr	r3, [r7, #4]
 8001838:	681b      	ldr	r3, [r3, #0]
 800183a:	2202      	movs	r2, #2
 800183c:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;
 800183e:	687b      	ldr	r3, [r7, #4]
 8001840:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001842:	687b      	ldr	r3, [r7, #4]
 8001844:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_READY;
 8001846:	687b      	ldr	r3, [r7, #4]
 8001848:	2201      	movs	r2, #1
 800184a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
 800184e:	687b      	ldr	r3, [r7, #4]
 8001850:	2200      	movs	r2, #0
 8001852:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

      if(hdma2d->XferCpltCallback != NULL)
 8001856:	687b      	ldr	r3, [r7, #4]
 8001858:	691b      	ldr	r3, [r3, #16]
 800185a:	2b00      	cmp	r3, #0
 800185c:	d003      	beq.n	8001866 <HAL_DMA2D_IRQHandler+0x1a6>
      {
        /* Transfer complete Callback */
        hdma2d->XferCpltCallback(hdma2d);
 800185e:	687b      	ldr	r3, [r7, #4]
 8001860:	691b      	ldr	r3, [r3, #16]
 8001862:	6878      	ldr	r0, [r7, #4]
 8001864:	4798      	blx	r3
      }
    }
  }
  /* CLUT Transfer Complete Interrupt management ******************************/
  if ((isrflags & DMA2D_FLAG_CTC) != 0U)
 8001866:	68fb      	ldr	r3, [r7, #12]
 8001868:	f003 0310 	and.w	r3, r3, #16
 800186c:	2b00      	cmp	r3, #0
 800186e:	d01f      	beq.n	80018b0 <HAL_DMA2D_IRQHandler+0x1f0>
  {
    if ((crflags & DMA2D_IT_CTC) != 0U)
 8001870:	68bb      	ldr	r3, [r7, #8]
 8001872:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8001876:	2b00      	cmp	r3, #0
 8001878:	d01a      	beq.n	80018b0 <HAL_DMA2D_IRQHandler+0x1f0>
    {
      /* Disable the CLUT transfer complete interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CTC);
 800187a:	687b      	ldr	r3, [r7, #4]
 800187c:	681b      	ldr	r3, [r3, #0]
 800187e:	681a      	ldr	r2, [r3, #0]
 8001880:	687b      	ldr	r3, [r7, #4]
 8001882:	681b      	ldr	r3, [r3, #0]
 8001884:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8001888:	601a      	str	r2, [r3, #0]

      /* Clear the CLUT transfer complete flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CTC);
 800188a:	687b      	ldr	r3, [r7, #4]
 800188c:	681b      	ldr	r3, [r3, #0]
 800188e:	2210      	movs	r2, #16
 8001890:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;
 8001892:	687b      	ldr	r3, [r7, #4]
 8001894:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001896:	687b      	ldr	r3, [r7, #4]
 8001898:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_READY;
 800189a:	687b      	ldr	r3, [r7, #4]
 800189c:	2201      	movs	r2, #1
 800189e:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
 80018a2:	687b      	ldr	r3, [r7, #4]
 80018a4:	2200      	movs	r2, #0
 80018a6:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

      /* CLUT Transfer complete Callback */
#if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
      hdma2d->CLUTLoadingCpltCallback(hdma2d);
#else
      HAL_DMA2D_CLUTLoadingCpltCallback(hdma2d);
 80018aa:	6878      	ldr	r0, [r7, #4]
 80018ac:	f000 f80e 	bl	80018cc <HAL_DMA2D_CLUTLoadingCpltCallback>
#endif /* USE_HAL_DMA2D_REGISTER_CALLBACKS */
    }
  }

}
 80018b0:	bf00      	nop
 80018b2:	3710      	adds	r7, #16
 80018b4:	46bd      	mov	sp, r7
 80018b6:	bd80      	pop	{r7, pc}

080018b8 <HAL_DMA2D_LineEventCallback>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_LineEventCallback(DMA2D_HandleTypeDef *hdma2d)
{
 80018b8:	b480      	push	{r7}
 80018ba:	b083      	sub	sp, #12
 80018bc:	af00      	add	r7, sp, #0
 80018be:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_LineEventCallback can be implemented in the user file.
   */
}
 80018c0:	bf00      	nop
 80018c2:	370c      	adds	r7, #12
 80018c4:	46bd      	mov	sp, r7
 80018c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80018ca:	4770      	bx	lr

080018cc <HAL_DMA2D_CLUTLoadingCpltCallback>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_CLUTLoadingCpltCallback(DMA2D_HandleTypeDef *hdma2d)
{
 80018cc:	b480      	push	{r7}
 80018ce:	b083      	sub	sp, #12
 80018d0:	af00      	add	r7, sp, #0
 80018d2:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_CLUTLoadingCpltCallback can be implemented in the user file.
   */
}
 80018d4:	bf00      	nop
 80018d6:	370c      	adds	r7, #12
 80018d8:	46bd      	mov	sp, r7
 80018da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80018de:	4770      	bx	lr

080018e0 <HAL_DMA2D_ConfigLayer>:
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
{
 80018e0:	b480      	push	{r7}
 80018e2:	b087      	sub	sp, #28
 80018e4:	af00      	add	r7, sp, #0
 80018e6:	6078      	str	r0, [r7, #4]
 80018e8:	6039      	str	r1, [r7, #0]
  uint32_t regMask, regValue;

  /* Check the parameters */
  assert_param(IS_DMA2D_LAYER(LayerIdx));
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
  if(hdma2d->Init.Mode != DMA2D_R2M)
 80018ea:	687b      	ldr	r3, [r7, #4]
 80018ec:	685b      	ldr	r3, [r3, #4]
 80018ee:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
      assert_param(IS_DMA2D_ALPHA_MODE(hdma2d->LayerCfg[LayerIdx].AlphaMode));
    }
  }

  /* Process locked */
  __HAL_LOCK(hdma2d);
 80018f2:	687b      	ldr	r3, [r7, #4]
 80018f4:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 80018f8:	2b01      	cmp	r3, #1
 80018fa:	d101      	bne.n	8001900 <HAL_DMA2D_ConfigLayer+0x20>
 80018fc:	2302      	movs	r3, #2
 80018fe:	e079      	b.n	80019f4 <HAL_DMA2D_ConfigLayer+0x114>
 8001900:	687b      	ldr	r3, [r7, #4]
 8001902:	2201      	movs	r2, #1
 8001904:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8001908:	687b      	ldr	r3, [r7, #4]
 800190a:	2202      	movs	r2, #2
 800190c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
 8001910:	683b      	ldr	r3, [r7, #0]
 8001912:	011b      	lsls	r3, r3, #4
 8001914:	3318      	adds	r3, #24
 8001916:	687a      	ldr	r2, [r7, #4]
 8001918:	4413      	add	r3, r2
 800191a:	613b      	str	r3, [r7, #16]

  /* Prepare the value to be written to the BGPFCCR or FGPFCCR register */
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
 800191c:	693b      	ldr	r3, [r7, #16]
 800191e:	685a      	ldr	r2, [r3, #4]
 8001920:	693b      	ldr	r3, [r7, #16]
 8001922:	689b      	ldr	r3, [r3, #8]
 8001924:	041b      	lsls	r3, r3, #16
 8001926:	4313      	orrs	r3, r2
 8001928:	617b      	str	r3, [r7, #20]
  regMask  = DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA;
 800192a:	4b35      	ldr	r3, [pc, #212]	; (8001a00 <HAL_DMA2D_ConfigLayer+0x120>)
 800192c:	60fb      	str	r3, [r7, #12]


  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 800192e:	693b      	ldr	r3, [r7, #16]
 8001930:	685b      	ldr	r3, [r3, #4]
 8001932:	2b0a      	cmp	r3, #10
 8001934:	d003      	beq.n	800193e <HAL_DMA2D_ConfigLayer+0x5e>
 8001936:	693b      	ldr	r3, [r7, #16]
 8001938:	685b      	ldr	r3, [r3, #4]
 800193a:	2b09      	cmp	r3, #9
 800193c:	d107      	bne.n	800194e <HAL_DMA2D_ConfigLayer+0x6e>
  {
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
 800193e:	693b      	ldr	r3, [r7, #16]
 8001940:	68db      	ldr	r3, [r3, #12]
 8001942:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8001946:	697a      	ldr	r2, [r7, #20]
 8001948:	4313      	orrs	r3, r2
 800194a:	617b      	str	r3, [r7, #20]
 800194c:	e005      	b.n	800195a <HAL_DMA2D_ConfigLayer+0x7a>
  }
  else
  {
    regValue |=  (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
 800194e:	693b      	ldr	r3, [r7, #16]
 8001950:	68db      	ldr	r3, [r3, #12]
 8001952:	061b      	lsls	r3, r3, #24
 8001954:	697a      	ldr	r2, [r7, #20]
 8001956:	4313      	orrs	r3, r2
 8001958:	617b      	str	r3, [r7, #20]
  }

  /* Configure the background DMA2D layer */
  if(LayerIdx == DMA2D_BACKGROUND_LAYER)
 800195a:	683b      	ldr	r3, [r7, #0]
 800195c:	2b00      	cmp	r3, #0
 800195e:	d120      	bne.n	80019a2 <HAL_DMA2D_ConfigLayer+0xc2>
  {
    /* Write DMA2D BGPFCCR register */
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 8001960:	687b      	ldr	r3, [r7, #4]
 8001962:	681b      	ldr	r3, [r3, #0]
 8001964:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001966:	68fb      	ldr	r3, [r7, #12]
 8001968:	43db      	mvns	r3, r3
 800196a:	ea02 0103 	and.w	r1, r2, r3
 800196e:	687b      	ldr	r3, [r7, #4]
 8001970:	681b      	ldr	r3, [r3, #0]
 8001972:	697a      	ldr	r2, [r7, #20]
 8001974:	430a      	orrs	r2, r1
 8001976:	625a      	str	r2, [r3, #36]	; 0x24

    /* DMA2D BGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 8001978:	687b      	ldr	r3, [r7, #4]
 800197a:	681b      	ldr	r3, [r3, #0]
 800197c:	693a      	ldr	r2, [r7, #16]
 800197e:	6812      	ldr	r2, [r2, #0]
 8001980:	619a      	str	r2, [r3, #24]

    /* DMA2D BGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8001982:	693b      	ldr	r3, [r7, #16]
 8001984:	685b      	ldr	r3, [r3, #4]
 8001986:	2b0a      	cmp	r3, #10
 8001988:	d003      	beq.n	8001992 <HAL_DMA2D_ConfigLayer+0xb2>
 800198a:	693b      	ldr	r3, [r7, #16]
 800198c:	685b      	ldr	r3, [r3, #4]
 800198e:	2b09      	cmp	r3, #9
 8001990:	d127      	bne.n	80019e2 <HAL_DMA2D_ConfigLayer+0x102>
    {
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE|DMA2D_BGCOLR_GREEN|DMA2D_BGCOLR_RED));
 8001992:	693b      	ldr	r3, [r7, #16]
 8001994:	68da      	ldr	r2, [r3, #12]
 8001996:	687b      	ldr	r3, [r7, #4]
 8001998:	681b      	ldr	r3, [r3, #0]
 800199a:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 800199e:	629a      	str	r2, [r3, #40]	; 0x28
 80019a0:	e01f      	b.n	80019e2 <HAL_DMA2D_ConfigLayer+0x102>
  else
  {


     /* Write DMA2D FGPFCCR register */
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 80019a2:	687b      	ldr	r3, [r7, #4]
 80019a4:	681b      	ldr	r3, [r3, #0]
 80019a6:	69da      	ldr	r2, [r3, #28]
 80019a8:	68fb      	ldr	r3, [r7, #12]
 80019aa:	43db      	mvns	r3, r3
 80019ac:	ea02 0103 	and.w	r1, r2, r3
 80019b0:	687b      	ldr	r3, [r7, #4]
 80019b2:	681b      	ldr	r3, [r3, #0]
 80019b4:	697a      	ldr	r2, [r7, #20]
 80019b6:	430a      	orrs	r2, r1
 80019b8:	61da      	str	r2, [r3, #28]

    /* DMA2D FGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
 80019ba:	687b      	ldr	r3, [r7, #4]
 80019bc:	681b      	ldr	r3, [r3, #0]
 80019be:	693a      	ldr	r2, [r7, #16]
 80019c0:	6812      	ldr	r2, [r2, #0]
 80019c2:	611a      	str	r2, [r3, #16]

    /* DMA2D FGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 80019c4:	693b      	ldr	r3, [r7, #16]
 80019c6:	685b      	ldr	r3, [r3, #4]
 80019c8:	2b0a      	cmp	r3, #10
 80019ca:	d003      	beq.n	80019d4 <HAL_DMA2D_ConfigLayer+0xf4>
 80019cc:	693b      	ldr	r3, [r7, #16]
 80019ce:	685b      	ldr	r3, [r3, #4]
 80019d0:	2b09      	cmp	r3, #9
 80019d2:	d106      	bne.n	80019e2 <HAL_DMA2D_ConfigLayer+0x102>
    {
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE|DMA2D_FGCOLR_GREEN|DMA2D_FGCOLR_RED));
 80019d4:	693b      	ldr	r3, [r7, #16]
 80019d6:	68da      	ldr	r2, [r3, #12]
 80019d8:	687b      	ldr	r3, [r7, #4]
 80019da:	681b      	ldr	r3, [r3, #0]
 80019dc:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 80019e0:	621a      	str	r2, [r3, #32]
    }
  }
  /* Initialize the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;
 80019e2:	687b      	ldr	r3, [r7, #4]
 80019e4:	2201      	movs	r2, #1
 80019e6:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
 80019ea:	687b      	ldr	r3, [r7, #4]
 80019ec:	2200      	movs	r2, #0
 80019ee:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 80019f2:	2300      	movs	r3, #0
}
 80019f4:	4618      	mov	r0, r3
 80019f6:	371c      	adds	r7, #28
 80019f8:	46bd      	mov	sp, r7
 80019fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019fe:	4770      	bx	lr
 8001a00:	ff03000f 	.word	0xff03000f

08001a04 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001a04:	b480      	push	{r7}
 8001a06:	b089      	sub	sp, #36	; 0x24
 8001a08:	af00      	add	r7, sp, #0
 8001a0a:	6078      	str	r0, [r7, #4]
 8001a0c:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 8001a0e:	2300      	movs	r3, #0
 8001a10:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 8001a12:	2300      	movs	r3, #0
 8001a14:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 8001a16:	2300      	movs	r3, #0
 8001a18:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001a1a:	2300      	movs	r3, #0
 8001a1c:	61fb      	str	r3, [r7, #28]
 8001a1e:	e177      	b.n	8001d10 <HAL_GPIO_Init+0x30c>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 8001a20:	2201      	movs	r2, #1
 8001a22:	69fb      	ldr	r3, [r7, #28]
 8001a24:	fa02 f303 	lsl.w	r3, r2, r3
 8001a28:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001a2a:	683b      	ldr	r3, [r7, #0]
 8001a2c:	681b      	ldr	r3, [r3, #0]
 8001a2e:	697a      	ldr	r2, [r7, #20]
 8001a30:	4013      	ands	r3, r2
 8001a32:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8001a34:	693a      	ldr	r2, [r7, #16]
 8001a36:	697b      	ldr	r3, [r7, #20]
 8001a38:	429a      	cmp	r2, r3
 8001a3a:	f040 8166 	bne.w	8001d0a <HAL_GPIO_Init+0x306>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001a3e:	683b      	ldr	r3, [r7, #0]
 8001a40:	685b      	ldr	r3, [r3, #4]
 8001a42:	2b01      	cmp	r3, #1
 8001a44:	d00b      	beq.n	8001a5e <HAL_GPIO_Init+0x5a>
 8001a46:	683b      	ldr	r3, [r7, #0]
 8001a48:	685b      	ldr	r3, [r3, #4]
 8001a4a:	2b02      	cmp	r3, #2
 8001a4c:	d007      	beq.n	8001a5e <HAL_GPIO_Init+0x5a>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001a4e:	683b      	ldr	r3, [r7, #0]
 8001a50:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001a52:	2b11      	cmp	r3, #17
 8001a54:	d003      	beq.n	8001a5e <HAL_GPIO_Init+0x5a>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001a56:	683b      	ldr	r3, [r7, #0]
 8001a58:	685b      	ldr	r3, [r3, #4]
 8001a5a:	2b12      	cmp	r3, #18
 8001a5c:	d130      	bne.n	8001ac0 <HAL_GPIO_Init+0xbc>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8001a5e:	687b      	ldr	r3, [r7, #4]
 8001a60:	689b      	ldr	r3, [r3, #8]
 8001a62:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8001a64:	69fb      	ldr	r3, [r7, #28]
 8001a66:	005b      	lsls	r3, r3, #1
 8001a68:	2203      	movs	r2, #3
 8001a6a:	fa02 f303 	lsl.w	r3, r2, r3
 8001a6e:	43db      	mvns	r3, r3
 8001a70:	69ba      	ldr	r2, [r7, #24]
 8001a72:	4013      	ands	r3, r2
 8001a74:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8001a76:	683b      	ldr	r3, [r7, #0]
 8001a78:	68da      	ldr	r2, [r3, #12]
 8001a7a:	69fb      	ldr	r3, [r7, #28]
 8001a7c:	005b      	lsls	r3, r3, #1
 8001a7e:	fa02 f303 	lsl.w	r3, r2, r3
 8001a82:	69ba      	ldr	r2, [r7, #24]
 8001a84:	4313      	orrs	r3, r2
 8001a86:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8001a88:	687b      	ldr	r3, [r7, #4]
 8001a8a:	69ba      	ldr	r2, [r7, #24]
 8001a8c:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8001a8e:	687b      	ldr	r3, [r7, #4]
 8001a90:	685b      	ldr	r3, [r3, #4]
 8001a92:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001a94:	2201      	movs	r2, #1
 8001a96:	69fb      	ldr	r3, [r7, #28]
 8001a98:	fa02 f303 	lsl.w	r3, r2, r3
 8001a9c:	43db      	mvns	r3, r3
 8001a9e:	69ba      	ldr	r2, [r7, #24]
 8001aa0:	4013      	ands	r3, r2
 8001aa2:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8001aa4:	683b      	ldr	r3, [r7, #0]
 8001aa6:	685b      	ldr	r3, [r3, #4]
 8001aa8:	091b      	lsrs	r3, r3, #4
 8001aaa:	f003 0201 	and.w	r2, r3, #1
 8001aae:	69fb      	ldr	r3, [r7, #28]
 8001ab0:	fa02 f303 	lsl.w	r3, r2, r3
 8001ab4:	69ba      	ldr	r2, [r7, #24]
 8001ab6:	4313      	orrs	r3, r2
 8001ab8:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8001aba:	687b      	ldr	r3, [r7, #4]
 8001abc:	69ba      	ldr	r2, [r7, #24]
 8001abe:	605a      	str	r2, [r3, #4]
       }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8001ac0:	687b      	ldr	r3, [r7, #4]
 8001ac2:	68db      	ldr	r3, [r3, #12]
 8001ac4:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8001ac6:	69fb      	ldr	r3, [r7, #28]
 8001ac8:	005b      	lsls	r3, r3, #1
 8001aca:	2203      	movs	r2, #3
 8001acc:	fa02 f303 	lsl.w	r3, r2, r3
 8001ad0:	43db      	mvns	r3, r3
 8001ad2:	69ba      	ldr	r2, [r7, #24]
 8001ad4:	4013      	ands	r3, r2
 8001ad6:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8001ad8:	683b      	ldr	r3, [r7, #0]
 8001ada:	689a      	ldr	r2, [r3, #8]
 8001adc:	69fb      	ldr	r3, [r7, #28]
 8001ade:	005b      	lsls	r3, r3, #1
 8001ae0:	fa02 f303 	lsl.w	r3, r2, r3
 8001ae4:	69ba      	ldr	r2, [r7, #24]
 8001ae6:	4313      	orrs	r3, r2
 8001ae8:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 8001aea:	687b      	ldr	r3, [r7, #4]
 8001aec:	69ba      	ldr	r2, [r7, #24]
 8001aee:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001af0:	683b      	ldr	r3, [r7, #0]
 8001af2:	685b      	ldr	r3, [r3, #4]
 8001af4:	2b02      	cmp	r3, #2
 8001af6:	d003      	beq.n	8001b00 <HAL_GPIO_Init+0xfc>
 8001af8:	683b      	ldr	r3, [r7, #0]
 8001afa:	685b      	ldr	r3, [r3, #4]
 8001afc:	2b12      	cmp	r3, #18
 8001afe:	d123      	bne.n	8001b48 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8001b00:	69fb      	ldr	r3, [r7, #28]
 8001b02:	08da      	lsrs	r2, r3, #3
 8001b04:	687b      	ldr	r3, [r7, #4]
 8001b06:	3208      	adds	r2, #8
 8001b08:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8001b0c:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8001b0e:	69fb      	ldr	r3, [r7, #28]
 8001b10:	f003 0307 	and.w	r3, r3, #7
 8001b14:	009b      	lsls	r3, r3, #2
 8001b16:	220f      	movs	r2, #15
 8001b18:	fa02 f303 	lsl.w	r3, r2, r3
 8001b1c:	43db      	mvns	r3, r3
 8001b1e:	69ba      	ldr	r2, [r7, #24]
 8001b20:	4013      	ands	r3, r2
 8001b22:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8001b24:	683b      	ldr	r3, [r7, #0]
 8001b26:	691a      	ldr	r2, [r3, #16]
 8001b28:	69fb      	ldr	r3, [r7, #28]
 8001b2a:	f003 0307 	and.w	r3, r3, #7
 8001b2e:	009b      	lsls	r3, r3, #2
 8001b30:	fa02 f303 	lsl.w	r3, r2, r3
 8001b34:	69ba      	ldr	r2, [r7, #24]
 8001b36:	4313      	orrs	r3, r2
 8001b38:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8001b3a:	69fb      	ldr	r3, [r7, #28]
 8001b3c:	08da      	lsrs	r2, r3, #3
 8001b3e:	687b      	ldr	r3, [r7, #4]
 8001b40:	3208      	adds	r2, #8
 8001b42:	69b9      	ldr	r1, [r7, #24]
 8001b44:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8001b48:	687b      	ldr	r3, [r7, #4]
 8001b4a:	681b      	ldr	r3, [r3, #0]
 8001b4c:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001b4e:	69fb      	ldr	r3, [r7, #28]
 8001b50:	005b      	lsls	r3, r3, #1
 8001b52:	2203      	movs	r2, #3
 8001b54:	fa02 f303 	lsl.w	r3, r2, r3
 8001b58:	43db      	mvns	r3, r3
 8001b5a:	69ba      	ldr	r2, [r7, #24]
 8001b5c:	4013      	ands	r3, r2
 8001b5e:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001b60:	683b      	ldr	r3, [r7, #0]
 8001b62:	685b      	ldr	r3, [r3, #4]
 8001b64:	f003 0203 	and.w	r2, r3, #3
 8001b68:	69fb      	ldr	r3, [r7, #28]
 8001b6a:	005b      	lsls	r3, r3, #1
 8001b6c:	fa02 f303 	lsl.w	r3, r2, r3
 8001b70:	69ba      	ldr	r2, [r7, #24]
 8001b72:	4313      	orrs	r3, r2
 8001b74:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8001b76:	687b      	ldr	r3, [r7, #4]
 8001b78:	69ba      	ldr	r2, [r7, #24]
 8001b7a:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001b7c:	683b      	ldr	r3, [r7, #0]
 8001b7e:	685b      	ldr	r3, [r3, #4]
 8001b80:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001b84:	2b00      	cmp	r3, #0
 8001b86:	f000 80c0 	beq.w	8001d0a <HAL_GPIO_Init+0x306>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001b8a:	2300      	movs	r3, #0
 8001b8c:	60fb      	str	r3, [r7, #12]
 8001b8e:	4b66      	ldr	r3, [pc, #408]	; (8001d28 <HAL_GPIO_Init+0x324>)
 8001b90:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001b92:	4a65      	ldr	r2, [pc, #404]	; (8001d28 <HAL_GPIO_Init+0x324>)
 8001b94:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001b98:	6453      	str	r3, [r2, #68]	; 0x44
 8001b9a:	4b63      	ldr	r3, [pc, #396]	; (8001d28 <HAL_GPIO_Init+0x324>)
 8001b9c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001b9e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001ba2:	60fb      	str	r3, [r7, #12]
 8001ba4:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8001ba6:	4a61      	ldr	r2, [pc, #388]	; (8001d2c <HAL_GPIO_Init+0x328>)
 8001ba8:	69fb      	ldr	r3, [r7, #28]
 8001baa:	089b      	lsrs	r3, r3, #2
 8001bac:	3302      	adds	r3, #2
 8001bae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001bb2:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8001bb4:	69fb      	ldr	r3, [r7, #28]
 8001bb6:	f003 0303 	and.w	r3, r3, #3
 8001bba:	009b      	lsls	r3, r3, #2
 8001bbc:	220f      	movs	r2, #15
 8001bbe:	fa02 f303 	lsl.w	r3, r2, r3
 8001bc2:	43db      	mvns	r3, r3
 8001bc4:	69ba      	ldr	r2, [r7, #24]
 8001bc6:	4013      	ands	r3, r2
 8001bc8:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8001bca:	687b      	ldr	r3, [r7, #4]
 8001bcc:	4a58      	ldr	r2, [pc, #352]	; (8001d30 <HAL_GPIO_Init+0x32c>)
 8001bce:	4293      	cmp	r3, r2
 8001bd0:	d037      	beq.n	8001c42 <HAL_GPIO_Init+0x23e>
 8001bd2:	687b      	ldr	r3, [r7, #4]
 8001bd4:	4a57      	ldr	r2, [pc, #348]	; (8001d34 <HAL_GPIO_Init+0x330>)
 8001bd6:	4293      	cmp	r3, r2
 8001bd8:	d031      	beq.n	8001c3e <HAL_GPIO_Init+0x23a>
 8001bda:	687b      	ldr	r3, [r7, #4]
 8001bdc:	4a56      	ldr	r2, [pc, #344]	; (8001d38 <HAL_GPIO_Init+0x334>)
 8001bde:	4293      	cmp	r3, r2
 8001be0:	d02b      	beq.n	8001c3a <HAL_GPIO_Init+0x236>
 8001be2:	687b      	ldr	r3, [r7, #4]
 8001be4:	4a55      	ldr	r2, [pc, #340]	; (8001d3c <HAL_GPIO_Init+0x338>)
 8001be6:	4293      	cmp	r3, r2
 8001be8:	d025      	beq.n	8001c36 <HAL_GPIO_Init+0x232>
 8001bea:	687b      	ldr	r3, [r7, #4]
 8001bec:	4a54      	ldr	r2, [pc, #336]	; (8001d40 <HAL_GPIO_Init+0x33c>)
 8001bee:	4293      	cmp	r3, r2
 8001bf0:	d01f      	beq.n	8001c32 <HAL_GPIO_Init+0x22e>
 8001bf2:	687b      	ldr	r3, [r7, #4]
 8001bf4:	4a53      	ldr	r2, [pc, #332]	; (8001d44 <HAL_GPIO_Init+0x340>)
 8001bf6:	4293      	cmp	r3, r2
 8001bf8:	d019      	beq.n	8001c2e <HAL_GPIO_Init+0x22a>
 8001bfa:	687b      	ldr	r3, [r7, #4]
 8001bfc:	4a52      	ldr	r2, [pc, #328]	; (8001d48 <HAL_GPIO_Init+0x344>)
 8001bfe:	4293      	cmp	r3, r2
 8001c00:	d013      	beq.n	8001c2a <HAL_GPIO_Init+0x226>
 8001c02:	687b      	ldr	r3, [r7, #4]
 8001c04:	4a51      	ldr	r2, [pc, #324]	; (8001d4c <HAL_GPIO_Init+0x348>)
 8001c06:	4293      	cmp	r3, r2
 8001c08:	d00d      	beq.n	8001c26 <HAL_GPIO_Init+0x222>
 8001c0a:	687b      	ldr	r3, [r7, #4]
 8001c0c:	4a50      	ldr	r2, [pc, #320]	; (8001d50 <HAL_GPIO_Init+0x34c>)
 8001c0e:	4293      	cmp	r3, r2
 8001c10:	d007      	beq.n	8001c22 <HAL_GPIO_Init+0x21e>
 8001c12:	687b      	ldr	r3, [r7, #4]
 8001c14:	4a4f      	ldr	r2, [pc, #316]	; (8001d54 <HAL_GPIO_Init+0x350>)
 8001c16:	4293      	cmp	r3, r2
 8001c18:	d101      	bne.n	8001c1e <HAL_GPIO_Init+0x21a>
 8001c1a:	2309      	movs	r3, #9
 8001c1c:	e012      	b.n	8001c44 <HAL_GPIO_Init+0x240>
 8001c1e:	230a      	movs	r3, #10
 8001c20:	e010      	b.n	8001c44 <HAL_GPIO_Init+0x240>
 8001c22:	2308      	movs	r3, #8
 8001c24:	e00e      	b.n	8001c44 <HAL_GPIO_Init+0x240>
 8001c26:	2307      	movs	r3, #7
 8001c28:	e00c      	b.n	8001c44 <HAL_GPIO_Init+0x240>
 8001c2a:	2306      	movs	r3, #6
 8001c2c:	e00a      	b.n	8001c44 <HAL_GPIO_Init+0x240>
 8001c2e:	2305      	movs	r3, #5
 8001c30:	e008      	b.n	8001c44 <HAL_GPIO_Init+0x240>
 8001c32:	2304      	movs	r3, #4
 8001c34:	e006      	b.n	8001c44 <HAL_GPIO_Init+0x240>
 8001c36:	2303      	movs	r3, #3
 8001c38:	e004      	b.n	8001c44 <HAL_GPIO_Init+0x240>
 8001c3a:	2302      	movs	r3, #2
 8001c3c:	e002      	b.n	8001c44 <HAL_GPIO_Init+0x240>
 8001c3e:	2301      	movs	r3, #1
 8001c40:	e000      	b.n	8001c44 <HAL_GPIO_Init+0x240>
 8001c42:	2300      	movs	r3, #0
 8001c44:	69fa      	ldr	r2, [r7, #28]
 8001c46:	f002 0203 	and.w	r2, r2, #3
 8001c4a:	0092      	lsls	r2, r2, #2
 8001c4c:	4093      	lsls	r3, r2
 8001c4e:	69ba      	ldr	r2, [r7, #24]
 8001c50:	4313      	orrs	r3, r2
 8001c52:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8001c54:	4935      	ldr	r1, [pc, #212]	; (8001d2c <HAL_GPIO_Init+0x328>)
 8001c56:	69fb      	ldr	r3, [r7, #28]
 8001c58:	089b      	lsrs	r3, r3, #2
 8001c5a:	3302      	adds	r3, #2
 8001c5c:	69ba      	ldr	r2, [r7, #24]
 8001c5e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001c62:	4b3d      	ldr	r3, [pc, #244]	; (8001d58 <HAL_GPIO_Init+0x354>)
 8001c64:	681b      	ldr	r3, [r3, #0]
 8001c66:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8001c68:	693b      	ldr	r3, [r7, #16]
 8001c6a:	43db      	mvns	r3, r3
 8001c6c:	69ba      	ldr	r2, [r7, #24]
 8001c6e:	4013      	ands	r3, r2
 8001c70:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001c72:	683b      	ldr	r3, [r7, #0]
 8001c74:	685b      	ldr	r3, [r3, #4]
 8001c76:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001c7a:	2b00      	cmp	r3, #0
 8001c7c:	d003      	beq.n	8001c86 <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
 8001c7e:	69ba      	ldr	r2, [r7, #24]
 8001c80:	693b      	ldr	r3, [r7, #16]
 8001c82:	4313      	orrs	r3, r2
 8001c84:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 8001c86:	4a34      	ldr	r2, [pc, #208]	; (8001d58 <HAL_GPIO_Init+0x354>)
 8001c88:	69bb      	ldr	r3, [r7, #24]
 8001c8a:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
 8001c8c:	4b32      	ldr	r3, [pc, #200]	; (8001d58 <HAL_GPIO_Init+0x354>)
 8001c8e:	685b      	ldr	r3, [r3, #4]
 8001c90:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8001c92:	693b      	ldr	r3, [r7, #16]
 8001c94:	43db      	mvns	r3, r3
 8001c96:	69ba      	ldr	r2, [r7, #24]
 8001c98:	4013      	ands	r3, r2
 8001c9a:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001c9c:	683b      	ldr	r3, [r7, #0]
 8001c9e:	685b      	ldr	r3, [r3, #4]
 8001ca0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001ca4:	2b00      	cmp	r3, #0
 8001ca6:	d003      	beq.n	8001cb0 <HAL_GPIO_Init+0x2ac>
        {
          temp |= iocurrent;
 8001ca8:	69ba      	ldr	r2, [r7, #24]
 8001caa:	693b      	ldr	r3, [r7, #16]
 8001cac:	4313      	orrs	r3, r2
 8001cae:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 8001cb0:	4a29      	ldr	r2, [pc, #164]	; (8001d58 <HAL_GPIO_Init+0x354>)
 8001cb2:	69bb      	ldr	r3, [r7, #24]
 8001cb4:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8001cb6:	4b28      	ldr	r3, [pc, #160]	; (8001d58 <HAL_GPIO_Init+0x354>)
 8001cb8:	689b      	ldr	r3, [r3, #8]
 8001cba:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8001cbc:	693b      	ldr	r3, [r7, #16]
 8001cbe:	43db      	mvns	r3, r3
 8001cc0:	69ba      	ldr	r2, [r7, #24]
 8001cc2:	4013      	ands	r3, r2
 8001cc4:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001cc6:	683b      	ldr	r3, [r7, #0]
 8001cc8:	685b      	ldr	r3, [r3, #4]
 8001cca:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001cce:	2b00      	cmp	r3, #0
 8001cd0:	d003      	beq.n	8001cda <HAL_GPIO_Init+0x2d6>
        {
          temp |= iocurrent;
 8001cd2:	69ba      	ldr	r2, [r7, #24]
 8001cd4:	693b      	ldr	r3, [r7, #16]
 8001cd6:	4313      	orrs	r3, r2
 8001cd8:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 8001cda:	4a1f      	ldr	r2, [pc, #124]	; (8001d58 <HAL_GPIO_Init+0x354>)
 8001cdc:	69bb      	ldr	r3, [r7, #24]
 8001cde:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 8001ce0:	4b1d      	ldr	r3, [pc, #116]	; (8001d58 <HAL_GPIO_Init+0x354>)
 8001ce2:	68db      	ldr	r3, [r3, #12]
 8001ce4:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8001ce6:	693b      	ldr	r3, [r7, #16]
 8001ce8:	43db      	mvns	r3, r3
 8001cea:	69ba      	ldr	r2, [r7, #24]
 8001cec:	4013      	ands	r3, r2
 8001cee:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001cf0:	683b      	ldr	r3, [r7, #0]
 8001cf2:	685b      	ldr	r3, [r3, #4]
 8001cf4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001cf8:	2b00      	cmp	r3, #0
 8001cfa:	d003      	beq.n	8001d04 <HAL_GPIO_Init+0x300>
        {
          temp |= iocurrent;
 8001cfc:	69ba      	ldr	r2, [r7, #24]
 8001cfe:	693b      	ldr	r3, [r7, #16]
 8001d00:	4313      	orrs	r3, r2
 8001d02:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 8001d04:	4a14      	ldr	r2, [pc, #80]	; (8001d58 <HAL_GPIO_Init+0x354>)
 8001d06:	69bb      	ldr	r3, [r7, #24]
 8001d08:	60d3      	str	r3, [r2, #12]
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001d0a:	69fb      	ldr	r3, [r7, #28]
 8001d0c:	3301      	adds	r3, #1
 8001d0e:	61fb      	str	r3, [r7, #28]
 8001d10:	69fb      	ldr	r3, [r7, #28]
 8001d12:	2b0f      	cmp	r3, #15
 8001d14:	f67f ae84 	bls.w	8001a20 <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 8001d18:	bf00      	nop
 8001d1a:	bf00      	nop
 8001d1c:	3724      	adds	r7, #36	; 0x24
 8001d1e:	46bd      	mov	sp, r7
 8001d20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d24:	4770      	bx	lr
 8001d26:	bf00      	nop
 8001d28:	40023800 	.word	0x40023800
 8001d2c:	40013800 	.word	0x40013800
 8001d30:	40020000 	.word	0x40020000
 8001d34:	40020400 	.word	0x40020400
 8001d38:	40020800 	.word	0x40020800
 8001d3c:	40020c00 	.word	0x40020c00
 8001d40:	40021000 	.word	0x40021000
 8001d44:	40021400 	.word	0x40021400
 8001d48:	40021800 	.word	0x40021800
 8001d4c:	40021c00 	.word	0x40021c00
 8001d50:	40022000 	.word	0x40022000
 8001d54:	40022400 	.word	0x40022400
 8001d58:	40013c00 	.word	0x40013c00

08001d5c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8001d5c:	b480      	push	{r7}
 8001d5e:	b083      	sub	sp, #12
 8001d60:	af00      	add	r7, sp, #0
 8001d62:	6078      	str	r0, [r7, #4]
 8001d64:	460b      	mov	r3, r1
 8001d66:	807b      	strh	r3, [r7, #2]
 8001d68:	4613      	mov	r3, r2
 8001d6a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8001d6c:	787b      	ldrb	r3, [r7, #1]
 8001d6e:	2b00      	cmp	r3, #0
 8001d70:	d003      	beq.n	8001d7a <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8001d72:	887a      	ldrh	r2, [r7, #2]
 8001d74:	687b      	ldr	r3, [r7, #4]
 8001d76:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 8001d78:	e003      	b.n	8001d82 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 8001d7a:	887b      	ldrh	r3, [r7, #2]
 8001d7c:	041a      	lsls	r2, r3, #16
 8001d7e:	687b      	ldr	r3, [r7, #4]
 8001d80:	619a      	str	r2, [r3, #24]
}
 8001d82:	bf00      	nop
 8001d84:	370c      	adds	r7, #12
 8001d86:	46bd      	mov	sp, r7
 8001d88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001d8c:	4770      	bx	lr
	...

08001d90 <HAL_LTDC_Init>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
 8001d90:	b580      	push	{r7, lr}
 8001d92:	b084      	sub	sp, #16
 8001d94:	af00      	add	r7, sp, #0
 8001d96:	6078      	str	r0, [r7, #4]
  uint32_t tmp, tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
 8001d98:	687b      	ldr	r3, [r7, #4]
 8001d9a:	2b00      	cmp	r3, #0
 8001d9c:	d101      	bne.n	8001da2 <HAL_LTDC_Init+0x12>
  {
    return HAL_ERROR;
 8001d9e:	2301      	movs	r3, #1
 8001da0:	e0bf      	b.n	8001f22 <HAL_LTDC_Init+0x192>
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
 8001da2:	687b      	ldr	r3, [r7, #4]
 8001da4:	f893 30a1 	ldrb.w	r3, [r3, #161]	; 0xa1
 8001da8:	b2db      	uxtb	r3, r3
 8001daa:	2b00      	cmp	r3, #0
 8001dac:	d106      	bne.n	8001dbc <HAL_LTDC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
 8001dae:	687b      	ldr	r3, [r7, #4]
 8001db0:	2200      	movs	r2, #0
 8001db2:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
 8001db6:	6878      	ldr	r0, [r7, #4]
 8001db8:	f7ff f874 	bl	8000ea4 <HAL_LTDC_MspInit>
  }
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8001dbc:	687b      	ldr	r3, [r7, #4]
 8001dbe:	2202      	movs	r2, #2
 8001dc0:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8001dc4:	687b      	ldr	r3, [r7, #4]
 8001dc6:	681b      	ldr	r3, [r3, #0]
 8001dc8:	699a      	ldr	r2, [r3, #24]
 8001dca:	687b      	ldr	r3, [r7, #4]
 8001dcc:	681b      	ldr	r3, [r3, #0]
 8001dce:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8001dd2:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8001dd4:	687b      	ldr	r3, [r7, #4]
 8001dd6:	681b      	ldr	r3, [r3, #0]
 8001dd8:	6999      	ldr	r1, [r3, #24]
 8001dda:	687b      	ldr	r3, [r7, #4]
 8001ddc:	685a      	ldr	r2, [r3, #4]
 8001dde:	687b      	ldr	r3, [r7, #4]
 8001de0:	689b      	ldr	r3, [r3, #8]
 8001de2:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 8001de4:	687b      	ldr	r3, [r7, #4]
 8001de6:	68db      	ldr	r3, [r3, #12]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8001de8:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 8001dea:	687b      	ldr	r3, [r7, #4]
 8001dec:	691b      	ldr	r3, [r3, #16]
 8001dee:	431a      	orrs	r2, r3
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8001df0:	687b      	ldr	r3, [r7, #4]
 8001df2:	681b      	ldr	r3, [r3, #0]
 8001df4:	430a      	orrs	r2, r1
 8001df6:	619a      	str	r2, [r3, #24]

  /* Set Synchronization size */
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 8001df8:	687b      	ldr	r3, [r7, #4]
 8001dfa:	681b      	ldr	r3, [r3, #0]
 8001dfc:	6899      	ldr	r1, [r3, #8]
 8001dfe:	687b      	ldr	r3, [r7, #4]
 8001e00:	681a      	ldr	r2, [r3, #0]
 8001e02:	4b4a      	ldr	r3, [pc, #296]	; (8001f2c <HAL_LTDC_Init+0x19c>)
 8001e04:	400b      	ands	r3, r1
 8001e06:	6093      	str	r3, [r2, #8]
  tmp = (hltdc->Init.HorizontalSync << 16U);
 8001e08:	687b      	ldr	r3, [r7, #4]
 8001e0a:	695b      	ldr	r3, [r3, #20]
 8001e0c:	041b      	lsls	r3, r3, #16
 8001e0e:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 8001e10:	687b      	ldr	r3, [r7, #4]
 8001e12:	681b      	ldr	r3, [r3, #0]
 8001e14:	6899      	ldr	r1, [r3, #8]
 8001e16:	687b      	ldr	r3, [r7, #4]
 8001e18:	699a      	ldr	r2, [r3, #24]
 8001e1a:	68fb      	ldr	r3, [r7, #12]
 8001e1c:	431a      	orrs	r2, r3
 8001e1e:	687b      	ldr	r3, [r7, #4]
 8001e20:	681b      	ldr	r3, [r3, #0]
 8001e22:	430a      	orrs	r2, r1
 8001e24:	609a      	str	r2, [r3, #8]

  /* Set Accumulated Back porch */
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
 8001e26:	687b      	ldr	r3, [r7, #4]
 8001e28:	681b      	ldr	r3, [r3, #0]
 8001e2a:	68d9      	ldr	r1, [r3, #12]
 8001e2c:	687b      	ldr	r3, [r7, #4]
 8001e2e:	681a      	ldr	r2, [r3, #0]
 8001e30:	4b3e      	ldr	r3, [pc, #248]	; (8001f2c <HAL_LTDC_Init+0x19c>)
 8001e32:	400b      	ands	r3, r1
 8001e34:	60d3      	str	r3, [r2, #12]
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
 8001e36:	687b      	ldr	r3, [r7, #4]
 8001e38:	69db      	ldr	r3, [r3, #28]
 8001e3a:	041b      	lsls	r3, r3, #16
 8001e3c:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8001e3e:	687b      	ldr	r3, [r7, #4]
 8001e40:	681b      	ldr	r3, [r3, #0]
 8001e42:	68d9      	ldr	r1, [r3, #12]
 8001e44:	687b      	ldr	r3, [r7, #4]
 8001e46:	6a1a      	ldr	r2, [r3, #32]
 8001e48:	68fb      	ldr	r3, [r7, #12]
 8001e4a:	431a      	orrs	r2, r3
 8001e4c:	687b      	ldr	r3, [r7, #4]
 8001e4e:	681b      	ldr	r3, [r3, #0]
 8001e50:	430a      	orrs	r2, r1
 8001e52:	60da      	str	r2, [r3, #12]

  /* Set Accumulated Active Width */
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
 8001e54:	687b      	ldr	r3, [r7, #4]
 8001e56:	681b      	ldr	r3, [r3, #0]
 8001e58:	6919      	ldr	r1, [r3, #16]
 8001e5a:	687b      	ldr	r3, [r7, #4]
 8001e5c:	681a      	ldr	r2, [r3, #0]
 8001e5e:	4b33      	ldr	r3, [pc, #204]	; (8001f2c <HAL_LTDC_Init+0x19c>)
 8001e60:	400b      	ands	r3, r1
 8001e62:	6113      	str	r3, [r2, #16]
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
 8001e64:	687b      	ldr	r3, [r7, #4]
 8001e66:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001e68:	041b      	lsls	r3, r3, #16
 8001e6a:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 8001e6c:	687b      	ldr	r3, [r7, #4]
 8001e6e:	681b      	ldr	r3, [r3, #0]
 8001e70:	6919      	ldr	r1, [r3, #16]
 8001e72:	687b      	ldr	r3, [r7, #4]
 8001e74:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001e76:	68fb      	ldr	r3, [r7, #12]
 8001e78:	431a      	orrs	r2, r3
 8001e7a:	687b      	ldr	r3, [r7, #4]
 8001e7c:	681b      	ldr	r3, [r3, #0]
 8001e7e:	430a      	orrs	r2, r1
 8001e80:	611a      	str	r2, [r3, #16]

  /* Set Total Width */
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
 8001e82:	687b      	ldr	r3, [r7, #4]
 8001e84:	681b      	ldr	r3, [r3, #0]
 8001e86:	6959      	ldr	r1, [r3, #20]
 8001e88:	687b      	ldr	r3, [r7, #4]
 8001e8a:	681a      	ldr	r2, [r3, #0]
 8001e8c:	4b27      	ldr	r3, [pc, #156]	; (8001f2c <HAL_LTDC_Init+0x19c>)
 8001e8e:	400b      	ands	r3, r1
 8001e90:	6153      	str	r3, [r2, #20]
  tmp = (hltdc->Init.TotalWidth << 16U);
 8001e92:	687b      	ldr	r3, [r7, #4]
 8001e94:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001e96:	041b      	lsls	r3, r3, #16
 8001e98:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
 8001e9a:	687b      	ldr	r3, [r7, #4]
 8001e9c:	681b      	ldr	r3, [r3, #0]
 8001e9e:	6959      	ldr	r1, [r3, #20]
 8001ea0:	687b      	ldr	r3, [r7, #4]
 8001ea2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001ea4:	68fb      	ldr	r3, [r7, #12]
 8001ea6:	431a      	orrs	r2, r3
 8001ea8:	687b      	ldr	r3, [r7, #4]
 8001eaa:	681b      	ldr	r3, [r3, #0]
 8001eac:	430a      	orrs	r2, r1
 8001eae:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
 8001eb0:	687b      	ldr	r3, [r7, #4]
 8001eb2:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8001eb6:	021b      	lsls	r3, r3, #8
 8001eb8:	60fb      	str	r3, [r7, #12]
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
 8001eba:	687b      	ldr	r3, [r7, #4]
 8001ebc:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 8001ec0:	041b      	lsls	r3, r3, #16
 8001ec2:	60bb      	str	r3, [r7, #8]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8001ec4:	687b      	ldr	r3, [r7, #4]
 8001ec6:	681b      	ldr	r3, [r3, #0]
 8001ec8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001eca:	687b      	ldr	r3, [r7, #4]
 8001ecc:	681b      	ldr	r3, [r3, #0]
 8001ece:	f002 427f 	and.w	r2, r2, #4278190080	; 0xff000000
 8001ed2:	62da      	str	r2, [r3, #44]	; 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8001ed4:	687b      	ldr	r3, [r7, #4]
 8001ed6:	681b      	ldr	r3, [r3, #0]
 8001ed8:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8001eda:	68ba      	ldr	r2, [r7, #8]
 8001edc:	68fb      	ldr	r3, [r7, #12]
 8001ede:	4313      	orrs	r3, r2
 8001ee0:	687a      	ldr	r2, [r7, #4]
 8001ee2:	f892 2034 	ldrb.w	r2, [r2, #52]	; 0x34
 8001ee6:	431a      	orrs	r2, r3
 8001ee8:	687b      	ldr	r3, [r7, #4]
 8001eea:	681b      	ldr	r3, [r3, #0]
 8001eec:	430a      	orrs	r2, r1
 8001eee:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Enable the Transfer Error and FIFO underrun interrupts */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
 8001ef0:	687b      	ldr	r3, [r7, #4]
 8001ef2:	681b      	ldr	r3, [r3, #0]
 8001ef4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001ef6:	687b      	ldr	r3, [r7, #4]
 8001ef8:	681b      	ldr	r3, [r3, #0]
 8001efa:	f042 0206 	orr.w	r2, r2, #6
 8001efe:	635a      	str	r2, [r3, #52]	; 0x34

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);
 8001f00:	687b      	ldr	r3, [r7, #4]
 8001f02:	681b      	ldr	r3, [r3, #0]
 8001f04:	699a      	ldr	r2, [r3, #24]
 8001f06:	687b      	ldr	r3, [r7, #4]
 8001f08:	681b      	ldr	r3, [r3, #0]
 8001f0a:	f042 0201 	orr.w	r2, r2, #1
 8001f0e:	619a      	str	r2, [r3, #24]

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
 8001f10:	687b      	ldr	r3, [r7, #4]
 8001f12:	2200      	movs	r2, #0
 8001f14:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
 8001f18:	687b      	ldr	r3, [r7, #4]
 8001f1a:	2201      	movs	r2, #1
 8001f1c:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  return HAL_OK;
 8001f20:	2300      	movs	r3, #0
}
 8001f22:	4618      	mov	r0, r3
 8001f24:	3710      	adds	r7, #16
 8001f26:	46bd      	mov	sp, r7
 8001f28:	bd80      	pop	{r7, pc}
 8001f2a:	bf00      	nop
 8001f2c:	f000f800 	.word	0xf000f800

08001f30 <HAL_LTDC_IRQHandler>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
void HAL_LTDC_IRQHandler(LTDC_HandleTypeDef *hltdc)
{
 8001f30:	b580      	push	{r7, lr}
 8001f32:	b084      	sub	sp, #16
 8001f34:	af00      	add	r7, sp, #0
 8001f36:	6078      	str	r0, [r7, #4]
  uint32_t isrflags  = READ_REG(hltdc->Instance->ISR);
 8001f38:	687b      	ldr	r3, [r7, #4]
 8001f3a:	681b      	ldr	r3, [r3, #0]
 8001f3c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001f3e:	60fb      	str	r3, [r7, #12]
  uint32_t itsources = READ_REG(hltdc->Instance->IER);
 8001f40:	687b      	ldr	r3, [r7, #4]
 8001f42:	681b      	ldr	r3, [r3, #0]
 8001f44:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001f46:	60bb      	str	r3, [r7, #8]

  /* Transfer Error Interrupt management ***************************************/
  if (((isrflags & LTDC_ISR_TERRIF) != 0U) && ((itsources & LTDC_IER_TERRIE) != 0U))
 8001f48:	68fb      	ldr	r3, [r7, #12]
 8001f4a:	f003 0304 	and.w	r3, r3, #4
 8001f4e:	2b00      	cmp	r3, #0
 8001f50:	d023      	beq.n	8001f9a <HAL_LTDC_IRQHandler+0x6a>
 8001f52:	68bb      	ldr	r3, [r7, #8]
 8001f54:	f003 0304 	and.w	r3, r3, #4
 8001f58:	2b00      	cmp	r3, #0
 8001f5a:	d01e      	beq.n	8001f9a <HAL_LTDC_IRQHandler+0x6a>
  {
    /* Disable the transfer Error interrupt */
    __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_TE);
 8001f5c:	687b      	ldr	r3, [r7, #4]
 8001f5e:	681b      	ldr	r3, [r3, #0]
 8001f60:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001f62:	687b      	ldr	r3, [r7, #4]
 8001f64:	681b      	ldr	r3, [r3, #0]
 8001f66:	f022 0204 	bic.w	r2, r2, #4
 8001f6a:	635a      	str	r2, [r3, #52]	; 0x34

    /* Clear the transfer error flag */
    __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_TE);
 8001f6c:	687b      	ldr	r3, [r7, #4]
 8001f6e:	681b      	ldr	r3, [r3, #0]
 8001f70:	2204      	movs	r2, #4
 8001f72:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Update error code */
    hltdc->ErrorCode |= HAL_LTDC_ERROR_TE;
 8001f74:	687b      	ldr	r3, [r7, #4]
 8001f76:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8001f7a:	f043 0201 	orr.w	r2, r3, #1
 8001f7e:	687b      	ldr	r3, [r7, #4]
 8001f80:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4

    /* Change LTDC state */
    hltdc->State = HAL_LTDC_STATE_ERROR;
 8001f84:	687b      	ldr	r3, [r7, #4]
 8001f86:	2204      	movs	r2, #4
 8001f88:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

    /* Process unlocked */
    __HAL_UNLOCK(hltdc);
 8001f8c:	687b      	ldr	r3, [r7, #4]
 8001f8e:	2200      	movs	r2, #0
 8001f90:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
#if (USE_HAL_LTDC_REGISTER_CALLBACKS == 1)
    /*Call registered error callback*/
    hltdc->ErrorCallback(hltdc);
#else
    /* Call legacy error callback*/
    HAL_LTDC_ErrorCallback(hltdc);
 8001f94:	6878      	ldr	r0, [r7, #4]
 8001f96:	f000 f86f 	bl	8002078 <HAL_LTDC_ErrorCallback>
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */
  }

  /* FIFO underrun Interrupt management ***************************************/
  if (((isrflags & LTDC_ISR_FUIF) != 0U) && ((itsources & LTDC_IER_FUIE) != 0U))
 8001f9a:	68fb      	ldr	r3, [r7, #12]
 8001f9c:	f003 0302 	and.w	r3, r3, #2
 8001fa0:	2b00      	cmp	r3, #0
 8001fa2:	d023      	beq.n	8001fec <HAL_LTDC_IRQHandler+0xbc>
 8001fa4:	68bb      	ldr	r3, [r7, #8]
 8001fa6:	f003 0302 	and.w	r3, r3, #2
 8001faa:	2b00      	cmp	r3, #0
 8001fac:	d01e      	beq.n	8001fec <HAL_LTDC_IRQHandler+0xbc>
  {
    /* Disable the FIFO underrun interrupt */
    __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_FU);
 8001fae:	687b      	ldr	r3, [r7, #4]
 8001fb0:	681b      	ldr	r3, [r3, #0]
 8001fb2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001fb4:	687b      	ldr	r3, [r7, #4]
 8001fb6:	681b      	ldr	r3, [r3, #0]
 8001fb8:	f022 0202 	bic.w	r2, r2, #2
 8001fbc:	635a      	str	r2, [r3, #52]	; 0x34

    /* Clear the FIFO underrun flag */
    __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_FU);
 8001fbe:	687b      	ldr	r3, [r7, #4]
 8001fc0:	681b      	ldr	r3, [r3, #0]
 8001fc2:	2202      	movs	r2, #2
 8001fc4:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Update error code */
    hltdc->ErrorCode |= HAL_LTDC_ERROR_FU;
 8001fc6:	687b      	ldr	r3, [r7, #4]
 8001fc8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 8001fcc:	f043 0202 	orr.w	r2, r3, #2
 8001fd0:	687b      	ldr	r3, [r7, #4]
 8001fd2:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4

    /* Change LTDC state */
    hltdc->State = HAL_LTDC_STATE_ERROR;
 8001fd6:	687b      	ldr	r3, [r7, #4]
 8001fd8:	2204      	movs	r2, #4
 8001fda:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

    /* Process unlocked */
    __HAL_UNLOCK(hltdc);
 8001fde:	687b      	ldr	r3, [r7, #4]
 8001fe0:	2200      	movs	r2, #0
 8001fe2:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
#if (USE_HAL_LTDC_REGISTER_CALLBACKS == 1)
    /*Call registered error callback*/
    hltdc->ErrorCallback(hltdc);
#else
    /* Call legacy error callback*/
    HAL_LTDC_ErrorCallback(hltdc);
 8001fe6:	6878      	ldr	r0, [r7, #4]
 8001fe8:	f000 f846 	bl	8002078 <HAL_LTDC_ErrorCallback>
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */
  }

  /* Line Interrupt management ************************************************/
  if (((isrflags & LTDC_ISR_LIF) != 0U) && ((itsources & LTDC_IER_LIE) != 0U))
 8001fec:	68fb      	ldr	r3, [r7, #12]
 8001fee:	f003 0301 	and.w	r3, r3, #1
 8001ff2:	2b00      	cmp	r3, #0
 8001ff4:	d01b      	beq.n	800202e <HAL_LTDC_IRQHandler+0xfe>
 8001ff6:	68bb      	ldr	r3, [r7, #8]
 8001ff8:	f003 0301 	and.w	r3, r3, #1
 8001ffc:	2b00      	cmp	r3, #0
 8001ffe:	d016      	beq.n	800202e <HAL_LTDC_IRQHandler+0xfe>
  {
    /* Disable the Line interrupt */
    __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_LI);
 8002000:	687b      	ldr	r3, [r7, #4]
 8002002:	681b      	ldr	r3, [r3, #0]
 8002004:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002006:	687b      	ldr	r3, [r7, #4]
 8002008:	681b      	ldr	r3, [r3, #0]
 800200a:	f022 0201 	bic.w	r2, r2, #1
 800200e:	635a      	str	r2, [r3, #52]	; 0x34

    /* Clear the Line interrupt flag */
    __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_LI);
 8002010:	687b      	ldr	r3, [r7, #4]
 8002012:	681b      	ldr	r3, [r3, #0]
 8002014:	2201      	movs	r2, #1
 8002016:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Change LTDC state */
    hltdc->State = HAL_LTDC_STATE_READY;
 8002018:	687b      	ldr	r3, [r7, #4]
 800201a:	2201      	movs	r2, #1
 800201c:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

    /* Process unlocked */
    __HAL_UNLOCK(hltdc);
 8002020:	687b      	ldr	r3, [r7, #4]
 8002022:	2200      	movs	r2, #0
 8002024:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
#if (USE_HAL_LTDC_REGISTER_CALLBACKS == 1)
    /*Call registered Line Event callback */
    hltdc->LineEventCallback(hltdc);
#else
    /*Call Legacy Line Event callback */
    HAL_LTDC_LineEventCallback(hltdc);
 8002028:	6878      	ldr	r0, [r7, #4]
 800202a:	f000 f82f 	bl	800208c <HAL_LTDC_LineEventCallback>
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */
  }

  /* Register reload Interrupt management ***************************************/
  if (((isrflags & LTDC_ISR_RRIF) != 0U) && ((itsources & LTDC_IER_RRIE) != 0U))
 800202e:	68fb      	ldr	r3, [r7, #12]
 8002030:	f003 0308 	and.w	r3, r3, #8
 8002034:	2b00      	cmp	r3, #0
 8002036:	d01b      	beq.n	8002070 <HAL_LTDC_IRQHandler+0x140>
 8002038:	68bb      	ldr	r3, [r7, #8]
 800203a:	f003 0308 	and.w	r3, r3, #8
 800203e:	2b00      	cmp	r3, #0
 8002040:	d016      	beq.n	8002070 <HAL_LTDC_IRQHandler+0x140>
  {
    /* Disable the register reload interrupt */
    __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_RR);
 8002042:	687b      	ldr	r3, [r7, #4]
 8002044:	681b      	ldr	r3, [r3, #0]
 8002046:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002048:	687b      	ldr	r3, [r7, #4]
 800204a:	681b      	ldr	r3, [r3, #0]
 800204c:	f022 0208 	bic.w	r2, r2, #8
 8002050:	635a      	str	r2, [r3, #52]	; 0x34

    /* Clear the register reload flag */
    __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_RR);
 8002052:	687b      	ldr	r3, [r7, #4]
 8002054:	681b      	ldr	r3, [r3, #0]
 8002056:	2208      	movs	r2, #8
 8002058:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Change LTDC state */
    hltdc->State = HAL_LTDC_STATE_READY;
 800205a:	687b      	ldr	r3, [r7, #4]
 800205c:	2201      	movs	r2, #1
 800205e:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

    /* Process unlocked */
    __HAL_UNLOCK(hltdc);
 8002062:	687b      	ldr	r3, [r7, #4]
 8002064:	2200      	movs	r2, #0
 8002066:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
#if (USE_HAL_LTDC_REGISTER_CALLBACKS == 1)
    /*Call registered reload Event callback */
    hltdc->ReloadEventCallback(hltdc);
#else
    /*Call Legacy Reload Event callback */
    HAL_LTDC_ReloadEventCallback(hltdc);
 800206a:	6878      	ldr	r0, [r7, #4]
 800206c:	f000 f818 	bl	80020a0 <HAL_LTDC_ReloadEventCallback>
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */
  }
}
 8002070:	bf00      	nop
 8002072:	3710      	adds	r7, #16
 8002074:	46bd      	mov	sp, r7
 8002076:	bd80      	pop	{r7, pc}

08002078 <HAL_LTDC_ErrorCallback>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_ErrorCallback(LTDC_HandleTypeDef *hltdc)
{
 8002078:	b480      	push	{r7}
 800207a:	b083      	sub	sp, #12
 800207c:	af00      	add	r7, sp, #0
 800207e:	6078      	str	r0, [r7, #4]
  UNUSED(hltdc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_ErrorCallback could be implemented in the user file
   */
}
 8002080:	bf00      	nop
 8002082:	370c      	adds	r7, #12
 8002084:	46bd      	mov	sp, r7
 8002086:	f85d 7b04 	ldr.w	r7, [sp], #4
 800208a:	4770      	bx	lr

0800208c <HAL_LTDC_LineEventCallback>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_LineEventCallback(LTDC_HandleTypeDef *hltdc)
{
 800208c:	b480      	push	{r7}
 800208e:	b083      	sub	sp, #12
 8002090:	af00      	add	r7, sp, #0
 8002092:	6078      	str	r0, [r7, #4]
  UNUSED(hltdc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_LineEventCallback could be implemented in the user file
   */
}
 8002094:	bf00      	nop
 8002096:	370c      	adds	r7, #12
 8002098:	46bd      	mov	sp, r7
 800209a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800209e:	4770      	bx	lr

080020a0 <HAL_LTDC_ReloadEventCallback>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_ReloadEventCallback(LTDC_HandleTypeDef *hltdc)
{
 80020a0:	b480      	push	{r7}
 80020a2:	b083      	sub	sp, #12
 80020a4:	af00      	add	r7, sp, #0
 80020a6:	6078      	str	r0, [r7, #4]
  UNUSED(hltdc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_ReloadEvenCallback could be implemented in the user file
   */
}
 80020a8:	bf00      	nop
 80020aa:	370c      	adds	r7, #12
 80020ac:	46bd      	mov	sp, r7
 80020ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 80020b2:	4770      	bx	lr

080020b4 <HAL_LTDC_ConfigLayer>:
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
 80020b4:	b5b0      	push	{r4, r5, r7, lr}
 80020b6:	b084      	sub	sp, #16
 80020b8:	af00      	add	r7, sp, #0
 80020ba:	60f8      	str	r0, [r7, #12]
 80020bc:	60b9      	str	r1, [r7, #8]
 80020be:	607a      	str	r2, [r7, #4]
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));

  /* Process locked */
  __HAL_LOCK(hltdc);
 80020c0:	68fb      	ldr	r3, [r7, #12]
 80020c2:	f893 30a0 	ldrb.w	r3, [r3, #160]	; 0xa0
 80020c6:	2b01      	cmp	r3, #1
 80020c8:	d101      	bne.n	80020ce <HAL_LTDC_ConfigLayer+0x1a>
 80020ca:	2302      	movs	r3, #2
 80020cc:	e02c      	b.n	8002128 <HAL_LTDC_ConfigLayer+0x74>
 80020ce:	68fb      	ldr	r3, [r7, #12]
 80020d0:	2201      	movs	r2, #1
 80020d2:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 80020d6:	68fb      	ldr	r3, [r7, #12]
 80020d8:	2202      	movs	r2, #2
 80020da:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 80020de:	68fa      	ldr	r2, [r7, #12]
 80020e0:	687b      	ldr	r3, [r7, #4]
 80020e2:	2134      	movs	r1, #52	; 0x34
 80020e4:	fb01 f303 	mul.w	r3, r1, r3
 80020e8:	4413      	add	r3, r2
 80020ea:	f103 0238 	add.w	r2, r3, #56	; 0x38
 80020ee:	68bb      	ldr	r3, [r7, #8]
 80020f0:	4614      	mov	r4, r2
 80020f2:	461d      	mov	r5, r3
 80020f4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80020f6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80020f8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80020fa:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80020fc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80020fe:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8002100:	682b      	ldr	r3, [r5, #0]
 8002102:	6023      	str	r3, [r4, #0]

  /* Configure the LTDC Layer */
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8002104:	687a      	ldr	r2, [r7, #4]
 8002106:	68b9      	ldr	r1, [r7, #8]
 8002108:	68f8      	ldr	r0, [r7, #12]
 800210a:	f000 f811 	bl	8002130 <LTDC_SetConfig>

  /* Set the Immediate Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 800210e:	68fb      	ldr	r3, [r7, #12]
 8002110:	681b      	ldr	r3, [r3, #0]
 8002112:	2201      	movs	r2, #1
 8002114:	625a      	str	r2, [r3, #36]	; 0x24

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;
 8002116:	68fb      	ldr	r3, [r7, #12]
 8002118:	2201      	movs	r2, #1
 800211a:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 800211e:	68fb      	ldr	r3, [r7, #12]
 8002120:	2200      	movs	r2, #0
 8002122:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0

  return HAL_OK;
 8002126:	2300      	movs	r3, #0
}
 8002128:	4618      	mov	r0, r3
 800212a:	3710      	adds	r7, #16
 800212c:	46bd      	mov	sp, r7
 800212e:	bdb0      	pop	{r4, r5, r7, pc}

08002130 <LTDC_SetConfig>:
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values: LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval None
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
 8002130:	b480      	push	{r7}
 8002132:	b089      	sub	sp, #36	; 0x24
 8002134:	af00      	add	r7, sp, #0
 8002136:	60f8      	str	r0, [r7, #12]
 8002138:	60b9      	str	r1, [r7, #8]
 800213a:	607a      	str	r2, [r7, #4]
  uint32_t tmp;
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 800213c:	68bb      	ldr	r3, [r7, #8]
 800213e:	685a      	ldr	r2, [r3, #4]
 8002140:	68fb      	ldr	r3, [r7, #12]
 8002142:	681b      	ldr	r3, [r3, #0]
 8002144:	68db      	ldr	r3, [r3, #12]
 8002146:	0c1b      	lsrs	r3, r3, #16
 8002148:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800214c:	4413      	add	r3, r2
 800214e:	041b      	lsls	r3, r3, #16
 8002150:	61fb      	str	r3, [r7, #28]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8002152:	68fb      	ldr	r3, [r7, #12]
 8002154:	681b      	ldr	r3, [r3, #0]
 8002156:	461a      	mov	r2, r3
 8002158:	687b      	ldr	r3, [r7, #4]
 800215a:	01db      	lsls	r3, r3, #7
 800215c:	4413      	add	r3, r2
 800215e:	3384      	adds	r3, #132	; 0x84
 8002160:	685b      	ldr	r3, [r3, #4]
 8002162:	68fa      	ldr	r2, [r7, #12]
 8002164:	6812      	ldr	r2, [r2, #0]
 8002166:	4611      	mov	r1, r2
 8002168:	687a      	ldr	r2, [r7, #4]
 800216a:	01d2      	lsls	r2, r2, #7
 800216c:	440a      	add	r2, r1
 800216e:	3284      	adds	r2, #132	; 0x84
 8002170:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
 8002174:	6053      	str	r3, [r2, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 8002176:	68bb      	ldr	r3, [r7, #8]
 8002178:	681a      	ldr	r2, [r3, #0]
 800217a:	68fb      	ldr	r3, [r7, #12]
 800217c:	681b      	ldr	r3, [r3, #0]
 800217e:	68db      	ldr	r3, [r3, #12]
 8002180:	0c1b      	lsrs	r3, r3, #16
 8002182:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8002186:	4413      	add	r3, r2
 8002188:	1c5a      	adds	r2, r3, #1
 800218a:	68fb      	ldr	r3, [r7, #12]
 800218c:	681b      	ldr	r3, [r3, #0]
 800218e:	4619      	mov	r1, r3
 8002190:	687b      	ldr	r3, [r7, #4]
 8002192:	01db      	lsls	r3, r3, #7
 8002194:	440b      	add	r3, r1
 8002196:	3384      	adds	r3, #132	; 0x84
 8002198:	4619      	mov	r1, r3
 800219a:	69fb      	ldr	r3, [r7, #28]
 800219c:	4313      	orrs	r3, r2
 800219e:	604b      	str	r3, [r1, #4]

  /* Configure the vertical start and stop position */
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 80021a0:	68bb      	ldr	r3, [r7, #8]
 80021a2:	68da      	ldr	r2, [r3, #12]
 80021a4:	68fb      	ldr	r3, [r7, #12]
 80021a6:	681b      	ldr	r3, [r3, #0]
 80021a8:	68db      	ldr	r3, [r3, #12]
 80021aa:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80021ae:	4413      	add	r3, r2
 80021b0:	041b      	lsls	r3, r3, #16
 80021b2:	61fb      	str	r3, [r7, #28]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 80021b4:	68fb      	ldr	r3, [r7, #12]
 80021b6:	681b      	ldr	r3, [r3, #0]
 80021b8:	461a      	mov	r2, r3
 80021ba:	687b      	ldr	r3, [r7, #4]
 80021bc:	01db      	lsls	r3, r3, #7
 80021be:	4413      	add	r3, r2
 80021c0:	3384      	adds	r3, #132	; 0x84
 80021c2:	689b      	ldr	r3, [r3, #8]
 80021c4:	68fa      	ldr	r2, [r7, #12]
 80021c6:	6812      	ldr	r2, [r2, #0]
 80021c8:	4611      	mov	r1, r2
 80021ca:	687a      	ldr	r2, [r7, #4]
 80021cc:	01d2      	lsls	r2, r2, #7
 80021ce:	440a      	add	r2, r1
 80021d0:	3284      	adds	r2, #132	; 0x84
 80021d2:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
 80021d6:	6093      	str	r3, [r2, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 80021d8:	68bb      	ldr	r3, [r7, #8]
 80021da:	689a      	ldr	r2, [r3, #8]
 80021dc:	68fb      	ldr	r3, [r7, #12]
 80021de:	681b      	ldr	r3, [r3, #0]
 80021e0:	68db      	ldr	r3, [r3, #12]
 80021e2:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80021e6:	4413      	add	r3, r2
 80021e8:	1c5a      	adds	r2, r3, #1
 80021ea:	68fb      	ldr	r3, [r7, #12]
 80021ec:	681b      	ldr	r3, [r3, #0]
 80021ee:	4619      	mov	r1, r3
 80021f0:	687b      	ldr	r3, [r7, #4]
 80021f2:	01db      	lsls	r3, r3, #7
 80021f4:	440b      	add	r3, r1
 80021f6:	3384      	adds	r3, #132	; 0x84
 80021f8:	4619      	mov	r1, r3
 80021fa:	69fb      	ldr	r3, [r7, #28]
 80021fc:	4313      	orrs	r3, r2
 80021fe:	608b      	str	r3, [r1, #8]

  /* Specifies the pixel format */
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 8002200:	68fb      	ldr	r3, [r7, #12]
 8002202:	681b      	ldr	r3, [r3, #0]
 8002204:	461a      	mov	r2, r3
 8002206:	687b      	ldr	r3, [r7, #4]
 8002208:	01db      	lsls	r3, r3, #7
 800220a:	4413      	add	r3, r2
 800220c:	3384      	adds	r3, #132	; 0x84
 800220e:	691b      	ldr	r3, [r3, #16]
 8002210:	68fa      	ldr	r2, [r7, #12]
 8002212:	6812      	ldr	r2, [r2, #0]
 8002214:	4611      	mov	r1, r2
 8002216:	687a      	ldr	r2, [r7, #4]
 8002218:	01d2      	lsls	r2, r2, #7
 800221a:	440a      	add	r2, r1
 800221c:	3284      	adds	r2, #132	; 0x84
 800221e:	f023 0307 	bic.w	r3, r3, #7
 8002222:	6113      	str	r3, [r2, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 8002224:	68fb      	ldr	r3, [r7, #12]
 8002226:	681b      	ldr	r3, [r3, #0]
 8002228:	461a      	mov	r2, r3
 800222a:	687b      	ldr	r3, [r7, #4]
 800222c:	01db      	lsls	r3, r3, #7
 800222e:	4413      	add	r3, r2
 8002230:	3384      	adds	r3, #132	; 0x84
 8002232:	461a      	mov	r2, r3
 8002234:	68bb      	ldr	r3, [r7, #8]
 8002236:	691b      	ldr	r3, [r3, #16]
 8002238:	6113      	str	r3, [r2, #16]

  /* Configure the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
 800223a:	68bb      	ldr	r3, [r7, #8]
 800223c:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8002240:	021b      	lsls	r3, r3, #8
 8002242:	61fb      	str	r3, [r7, #28]
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
 8002244:	68bb      	ldr	r3, [r7, #8]
 8002246:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 800224a:	041b      	lsls	r3, r3, #16
 800224c:	61bb      	str	r3, [r7, #24]
  tmp2 = (pLayerCfg->Alpha0 << 24U);
 800224e:	68bb      	ldr	r3, [r7, #8]
 8002250:	699b      	ldr	r3, [r3, #24]
 8002252:	061b      	lsls	r3, r3, #24
 8002254:	617b      	str	r3, [r7, #20]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 8002256:	68fb      	ldr	r3, [r7, #12]
 8002258:	681b      	ldr	r3, [r3, #0]
 800225a:	461a      	mov	r2, r3
 800225c:	687b      	ldr	r3, [r7, #4]
 800225e:	01db      	lsls	r3, r3, #7
 8002260:	4413      	add	r3, r2
 8002262:	3384      	adds	r3, #132	; 0x84
 8002264:	699b      	ldr	r3, [r3, #24]
 8002266:	68fb      	ldr	r3, [r7, #12]
 8002268:	681b      	ldr	r3, [r3, #0]
 800226a:	461a      	mov	r2, r3
 800226c:	687b      	ldr	r3, [r7, #4]
 800226e:	01db      	lsls	r3, r3, #7
 8002270:	4413      	add	r3, r2
 8002272:	3384      	adds	r3, #132	; 0x84
 8002274:	461a      	mov	r2, r3
 8002276:	2300      	movs	r3, #0
 8002278:	6193      	str	r3, [r2, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 800227a:	68bb      	ldr	r3, [r7, #8]
 800227c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8002280:	461a      	mov	r2, r3
 8002282:	69fb      	ldr	r3, [r7, #28]
 8002284:	431a      	orrs	r2, r3
 8002286:	69bb      	ldr	r3, [r7, #24]
 8002288:	431a      	orrs	r2, r3
 800228a:	68fb      	ldr	r3, [r7, #12]
 800228c:	681b      	ldr	r3, [r3, #0]
 800228e:	4619      	mov	r1, r3
 8002290:	687b      	ldr	r3, [r7, #4]
 8002292:	01db      	lsls	r3, r3, #7
 8002294:	440b      	add	r3, r1
 8002296:	3384      	adds	r3, #132	; 0x84
 8002298:	4619      	mov	r1, r3
 800229a:	697b      	ldr	r3, [r7, #20]
 800229c:	4313      	orrs	r3, r2
 800229e:	618b      	str	r3, [r1, #24]

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 80022a0:	68fb      	ldr	r3, [r7, #12]
 80022a2:	681b      	ldr	r3, [r3, #0]
 80022a4:	461a      	mov	r2, r3
 80022a6:	687b      	ldr	r3, [r7, #4]
 80022a8:	01db      	lsls	r3, r3, #7
 80022aa:	4413      	add	r3, r2
 80022ac:	3384      	adds	r3, #132	; 0x84
 80022ae:	695b      	ldr	r3, [r3, #20]
 80022b0:	68fa      	ldr	r2, [r7, #12]
 80022b2:	6812      	ldr	r2, [r2, #0]
 80022b4:	4611      	mov	r1, r2
 80022b6:	687a      	ldr	r2, [r7, #4]
 80022b8:	01d2      	lsls	r2, r2, #7
 80022ba:	440a      	add	r2, r1
 80022bc:	3284      	adds	r2, #132	; 0x84
 80022be:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 80022c2:	6153      	str	r3, [r2, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 80022c4:	68fb      	ldr	r3, [r7, #12]
 80022c6:	681b      	ldr	r3, [r3, #0]
 80022c8:	461a      	mov	r2, r3
 80022ca:	687b      	ldr	r3, [r7, #4]
 80022cc:	01db      	lsls	r3, r3, #7
 80022ce:	4413      	add	r3, r2
 80022d0:	3384      	adds	r3, #132	; 0x84
 80022d2:	461a      	mov	r2, r3
 80022d4:	68bb      	ldr	r3, [r7, #8]
 80022d6:	695b      	ldr	r3, [r3, #20]
 80022d8:	6153      	str	r3, [r2, #20]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 80022da:	68fb      	ldr	r3, [r7, #12]
 80022dc:	681b      	ldr	r3, [r3, #0]
 80022de:	461a      	mov	r2, r3
 80022e0:	687b      	ldr	r3, [r7, #4]
 80022e2:	01db      	lsls	r3, r3, #7
 80022e4:	4413      	add	r3, r2
 80022e6:	3384      	adds	r3, #132	; 0x84
 80022e8:	69db      	ldr	r3, [r3, #28]
 80022ea:	68fa      	ldr	r2, [r7, #12]
 80022ec:	6812      	ldr	r2, [r2, #0]
 80022ee:	4611      	mov	r1, r2
 80022f0:	687a      	ldr	r2, [r7, #4]
 80022f2:	01d2      	lsls	r2, r2, #7
 80022f4:	440a      	add	r2, r1
 80022f6:	3284      	adds	r2, #132	; 0x84
 80022f8:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80022fc:	f023 0307 	bic.w	r3, r3, #7
 8002300:	61d3      	str	r3, [r2, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 8002302:	68bb      	ldr	r3, [r7, #8]
 8002304:	69da      	ldr	r2, [r3, #28]
 8002306:	68bb      	ldr	r3, [r7, #8]
 8002308:	6a1b      	ldr	r3, [r3, #32]
 800230a:	68f9      	ldr	r1, [r7, #12]
 800230c:	6809      	ldr	r1, [r1, #0]
 800230e:	4608      	mov	r0, r1
 8002310:	6879      	ldr	r1, [r7, #4]
 8002312:	01c9      	lsls	r1, r1, #7
 8002314:	4401      	add	r1, r0
 8002316:	3184      	adds	r1, #132	; 0x84
 8002318:	4313      	orrs	r3, r2
 800231a:	61cb      	str	r3, [r1, #28]

  /* Configure the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 800231c:	68fb      	ldr	r3, [r7, #12]
 800231e:	681b      	ldr	r3, [r3, #0]
 8002320:	461a      	mov	r2, r3
 8002322:	687b      	ldr	r3, [r7, #4]
 8002324:	01db      	lsls	r3, r3, #7
 8002326:	4413      	add	r3, r2
 8002328:	3384      	adds	r3, #132	; 0x84
 800232a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800232c:	68fb      	ldr	r3, [r7, #12]
 800232e:	681b      	ldr	r3, [r3, #0]
 8002330:	461a      	mov	r2, r3
 8002332:	687b      	ldr	r3, [r7, #4]
 8002334:	01db      	lsls	r3, r3, #7
 8002336:	4413      	add	r3, r2
 8002338:	3384      	adds	r3, #132	; 0x84
 800233a:	461a      	mov	r2, r3
 800233c:	2300      	movs	r3, #0
 800233e:	6293      	str	r3, [r2, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 8002340:	68fb      	ldr	r3, [r7, #12]
 8002342:	681b      	ldr	r3, [r3, #0]
 8002344:	461a      	mov	r2, r3
 8002346:	687b      	ldr	r3, [r7, #4]
 8002348:	01db      	lsls	r3, r3, #7
 800234a:	4413      	add	r3, r2
 800234c:	3384      	adds	r3, #132	; 0x84
 800234e:	461a      	mov	r2, r3
 8002350:	68bb      	ldr	r3, [r7, #8]
 8002352:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002354:	6293      	str	r3, [r2, #40]	; 0x28

  if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 8002356:	68bb      	ldr	r3, [r7, #8]
 8002358:	691b      	ldr	r3, [r3, #16]
 800235a:	2b00      	cmp	r3, #0
 800235c:	d102      	bne.n	8002364 <LTDC_SetConfig+0x234>
  {
    tmp = 4U;
 800235e:	2304      	movs	r3, #4
 8002360:	61fb      	str	r3, [r7, #28]
 8002362:	e01b      	b.n	800239c <LTDC_SetConfig+0x26c>
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 8002364:	68bb      	ldr	r3, [r7, #8]
 8002366:	691b      	ldr	r3, [r3, #16]
 8002368:	2b01      	cmp	r3, #1
 800236a:	d102      	bne.n	8002372 <LTDC_SetConfig+0x242>
  {
    tmp = 3U;
 800236c:	2303      	movs	r3, #3
 800236e:	61fb      	str	r3, [r7, #28]
 8002370:	e014      	b.n	800239c <LTDC_SetConfig+0x26c>
  }
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 8002372:	68bb      	ldr	r3, [r7, #8]
 8002374:	691b      	ldr	r3, [r3, #16]
 8002376:	2b04      	cmp	r3, #4
 8002378:	d00b      	beq.n	8002392 <LTDC_SetConfig+0x262>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
 800237a:	68bb      	ldr	r3, [r7, #8]
 800237c:	691b      	ldr	r3, [r3, #16]
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 800237e:	2b02      	cmp	r3, #2
 8002380:	d007      	beq.n	8002392 <LTDC_SetConfig+0x262>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 8002382:	68bb      	ldr	r3, [r7, #8]
 8002384:	691b      	ldr	r3, [r3, #16]
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
 8002386:	2b03      	cmp	r3, #3
 8002388:	d003      	beq.n	8002392 <LTDC_SetConfig+0x262>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_AL88))
 800238a:	68bb      	ldr	r3, [r7, #8]
 800238c:	691b      	ldr	r3, [r3, #16]
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 800238e:	2b07      	cmp	r3, #7
 8002390:	d102      	bne.n	8002398 <LTDC_SetConfig+0x268>
  {
    tmp = 2U;
 8002392:	2302      	movs	r3, #2
 8002394:	61fb      	str	r3, [r7, #28]
 8002396:	e001      	b.n	800239c <LTDC_SetConfig+0x26c>
  }
  else
  {
    tmp = 1U;
 8002398:	2301      	movs	r3, #1
 800239a:	61fb      	str	r3, [r7, #28]
  }

  /* Configure the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 800239c:	68fb      	ldr	r3, [r7, #12]
 800239e:	681b      	ldr	r3, [r3, #0]
 80023a0:	461a      	mov	r2, r3
 80023a2:	687b      	ldr	r3, [r7, #4]
 80023a4:	01db      	lsls	r3, r3, #7
 80023a6:	4413      	add	r3, r2
 80023a8:	3384      	adds	r3, #132	; 0x84
 80023aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80023ac:	68fa      	ldr	r2, [r7, #12]
 80023ae:	6812      	ldr	r2, [r2, #0]
 80023b0:	4611      	mov	r1, r2
 80023b2:	687a      	ldr	r2, [r7, #4]
 80023b4:	01d2      	lsls	r2, r2, #7
 80023b6:	440a      	add	r2, r1
 80023b8:	3284      	adds	r2, #132	; 0x84
 80023ba:	f003 23e0 	and.w	r3, r3, #3758153728	; 0xe000e000
 80023be:	62d3      	str	r3, [r2, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 80023c0:	68bb      	ldr	r3, [r7, #8]
 80023c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80023c4:	69fa      	ldr	r2, [r7, #28]
 80023c6:	fb02 f303 	mul.w	r3, r2, r3
 80023ca:	041a      	lsls	r2, r3, #16
 80023cc:	68bb      	ldr	r3, [r7, #8]
 80023ce:	6859      	ldr	r1, [r3, #4]
 80023d0:	68bb      	ldr	r3, [r7, #8]
 80023d2:	681b      	ldr	r3, [r3, #0]
 80023d4:	1acb      	subs	r3, r1, r3
 80023d6:	69f9      	ldr	r1, [r7, #28]
 80023d8:	fb01 f303 	mul.w	r3, r1, r3
 80023dc:	3303      	adds	r3, #3
 80023de:	68f9      	ldr	r1, [r7, #12]
 80023e0:	6809      	ldr	r1, [r1, #0]
 80023e2:	4608      	mov	r0, r1
 80023e4:	6879      	ldr	r1, [r7, #4]
 80023e6:	01c9      	lsls	r1, r1, #7
 80023e8:	4401      	add	r1, r0
 80023ea:	3184      	adds	r1, #132	; 0x84
 80023ec:	4313      	orrs	r3, r2
 80023ee:	62cb      	str	r3, [r1, #44]	; 0x2c
  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 80023f0:	68fb      	ldr	r3, [r7, #12]
 80023f2:	681b      	ldr	r3, [r3, #0]
 80023f4:	461a      	mov	r2, r3
 80023f6:	687b      	ldr	r3, [r7, #4]
 80023f8:	01db      	lsls	r3, r3, #7
 80023fa:	4413      	add	r3, r2
 80023fc:	3384      	adds	r3, #132	; 0x84
 80023fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002400:	68fa      	ldr	r2, [r7, #12]
 8002402:	6812      	ldr	r2, [r2, #0]
 8002404:	4611      	mov	r1, r2
 8002406:	687a      	ldr	r2, [r7, #4]
 8002408:	01d2      	lsls	r2, r2, #7
 800240a:	440a      	add	r2, r1
 800240c:	3284      	adds	r2, #132	; 0x84
 800240e:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8002412:	f023 0307 	bic.w	r3, r3, #7
 8002416:	6313      	str	r3, [r2, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8002418:	68fb      	ldr	r3, [r7, #12]
 800241a:	681b      	ldr	r3, [r3, #0]
 800241c:	461a      	mov	r2, r3
 800241e:	687b      	ldr	r3, [r7, #4]
 8002420:	01db      	lsls	r3, r3, #7
 8002422:	4413      	add	r3, r2
 8002424:	3384      	adds	r3, #132	; 0x84
 8002426:	461a      	mov	r2, r3
 8002428:	68bb      	ldr	r3, [r7, #8]
 800242a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800242c:	6313      	str	r3, [r2, #48]	; 0x30

  /* Enable LTDC_Layer by setting LEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 800242e:	68fb      	ldr	r3, [r7, #12]
 8002430:	681b      	ldr	r3, [r3, #0]
 8002432:	461a      	mov	r2, r3
 8002434:	687b      	ldr	r3, [r7, #4]
 8002436:	01db      	lsls	r3, r3, #7
 8002438:	4413      	add	r3, r2
 800243a:	3384      	adds	r3, #132	; 0x84
 800243c:	681b      	ldr	r3, [r3, #0]
 800243e:	68fa      	ldr	r2, [r7, #12]
 8002440:	6812      	ldr	r2, [r2, #0]
 8002442:	4611      	mov	r1, r2
 8002444:	687a      	ldr	r2, [r7, #4]
 8002446:	01d2      	lsls	r2, r2, #7
 8002448:	440a      	add	r2, r1
 800244a:	3284      	adds	r2, #132	; 0x84
 800244c:	f043 0301 	orr.w	r3, r3, #1
 8002450:	6013      	str	r3, [r2, #0]
}
 8002452:	bf00      	nop
 8002454:	3724      	adds	r7, #36	; 0x24
 8002456:	46bd      	mov	sp, r7
 8002458:	f85d 7b04 	ldr.w	r7, [sp], #4
 800245c:	4770      	bx	lr

0800245e <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 800245e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002460:	b08f      	sub	sp, #60	; 0x3c
 8002462:	af0a      	add	r7, sp, #40	; 0x28
 8002464:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx;
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 8002466:	687b      	ldr	r3, [r7, #4]
 8002468:	2b00      	cmp	r3, #0
 800246a:	d101      	bne.n	8002470 <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 800246c:	2301      	movs	r3, #1
 800246e:	e10f      	b.n	8002690 <HAL_PCD_Init+0x232>
  }

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  USBx = hpcd->Instance;
 8002470:	687b      	ldr	r3, [r7, #4]
 8002472:	681b      	ldr	r3, [r3, #0]
 8002474:	60bb      	str	r3, [r7, #8]

  if (hpcd->State == HAL_PCD_STATE_RESET)
 8002476:	687b      	ldr	r3, [r7, #4]
 8002478:	f893 33bd 	ldrb.w	r3, [r3, #957]	; 0x3bd
 800247c:	b2db      	uxtb	r3, r3
 800247e:	2b00      	cmp	r3, #0
 8002480:	d106      	bne.n	8002490 <HAL_PCD_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 8002482:	687b      	ldr	r3, [r7, #4]
 8002484:	2200      	movs	r2, #0
 8002486:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 800248a:	6878      	ldr	r0, [r7, #4]
 800248c:	f005 fa0a 	bl	80078a4 <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 8002490:	687b      	ldr	r3, [r7, #4]
 8002492:	2203      	movs	r2, #3
 8002494:	f883 23bd 	strb.w	r2, [r3, #957]	; 0x3bd

  /* Disable DMA mode for FS instance */
  if ((USBx->CID & (0x1U << 8)) == 0U)
 8002498:	68bb      	ldr	r3, [r7, #8]
 800249a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800249c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80024a0:	2b00      	cmp	r3, #0
 80024a2:	d102      	bne.n	80024aa <HAL_PCD_Init+0x4c>
  {
    hpcd->Init.dma_enable = 0U;
 80024a4:	687b      	ldr	r3, [r7, #4]
 80024a6:	2200      	movs	r2, #0
 80024a8:	611a      	str	r2, [r3, #16]
  }

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 80024aa:	687b      	ldr	r3, [r7, #4]
 80024ac:	681b      	ldr	r3, [r3, #0]
 80024ae:	4618      	mov	r0, r3
 80024b0:	f002 fa2f 	bl	8004912 <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 80024b4:	687b      	ldr	r3, [r7, #4]
 80024b6:	681b      	ldr	r3, [r3, #0]
 80024b8:	603b      	str	r3, [r7, #0]
 80024ba:	687e      	ldr	r6, [r7, #4]
 80024bc:	466d      	mov	r5, sp
 80024be:	f106 0410 	add.w	r4, r6, #16
 80024c2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80024c4:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80024c6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80024c8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80024ca:	e894 0003 	ldmia.w	r4, {r0, r1}
 80024ce:	e885 0003 	stmia.w	r5, {r0, r1}
 80024d2:	1d33      	adds	r3, r6, #4
 80024d4:	cb0e      	ldmia	r3, {r1, r2, r3}
 80024d6:	6838      	ldr	r0, [r7, #0]
 80024d8:	f002 f906 	bl	80046e8 <USB_CoreInit>
 80024dc:	4603      	mov	r3, r0
 80024de:	2b00      	cmp	r3, #0
 80024e0:	d005      	beq.n	80024ee <HAL_PCD_Init+0x90>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 80024e2:	687b      	ldr	r3, [r7, #4]
 80024e4:	2202      	movs	r2, #2
 80024e6:	f883 23bd 	strb.w	r2, [r3, #957]	; 0x3bd
    return HAL_ERROR;
 80024ea:	2301      	movs	r3, #1
 80024ec:	e0d0      	b.n	8002690 <HAL_PCD_Init+0x232>
  }

  /* Force Device Mode*/
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 80024ee:	687b      	ldr	r3, [r7, #4]
 80024f0:	681b      	ldr	r3, [r3, #0]
 80024f2:	2100      	movs	r1, #0
 80024f4:	4618      	mov	r0, r3
 80024f6:	f002 fa1d 	bl	8004934 <USB_SetCurrentMode>

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80024fa:	2300      	movs	r3, #0
 80024fc:	73fb      	strb	r3, [r7, #15]
 80024fe:	e04a      	b.n	8002596 <HAL_PCD_Init+0x138>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 8002500:	7bfa      	ldrb	r2, [r7, #15]
 8002502:	6879      	ldr	r1, [r7, #4]
 8002504:	4613      	mov	r3, r2
 8002506:	00db      	lsls	r3, r3, #3
 8002508:	1a9b      	subs	r3, r3, r2
 800250a:	009b      	lsls	r3, r3, #2
 800250c:	440b      	add	r3, r1
 800250e:	333d      	adds	r3, #61	; 0x3d
 8002510:	2201      	movs	r2, #1
 8002512:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 8002514:	7bfa      	ldrb	r2, [r7, #15]
 8002516:	6879      	ldr	r1, [r7, #4]
 8002518:	4613      	mov	r3, r2
 800251a:	00db      	lsls	r3, r3, #3
 800251c:	1a9b      	subs	r3, r3, r2
 800251e:	009b      	lsls	r3, r3, #2
 8002520:	440b      	add	r3, r1
 8002522:	333c      	adds	r3, #60	; 0x3c
 8002524:	7bfa      	ldrb	r2, [r7, #15]
 8002526:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].tx_fifo_num = i;
 8002528:	7bfa      	ldrb	r2, [r7, #15]
 800252a:	7bfb      	ldrb	r3, [r7, #15]
 800252c:	b298      	uxth	r0, r3
 800252e:	6879      	ldr	r1, [r7, #4]
 8002530:	4613      	mov	r3, r2
 8002532:	00db      	lsls	r3, r3, #3
 8002534:	1a9b      	subs	r3, r3, r2
 8002536:	009b      	lsls	r3, r3, #2
 8002538:	440b      	add	r3, r1
 800253a:	3342      	adds	r3, #66	; 0x42
 800253c:	4602      	mov	r2, r0
 800253e:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8002540:	7bfa      	ldrb	r2, [r7, #15]
 8002542:	6879      	ldr	r1, [r7, #4]
 8002544:	4613      	mov	r3, r2
 8002546:	00db      	lsls	r3, r3, #3
 8002548:	1a9b      	subs	r3, r3, r2
 800254a:	009b      	lsls	r3, r3, #2
 800254c:	440b      	add	r3, r1
 800254e:	333f      	adds	r3, #63	; 0x3f
 8002550:	2200      	movs	r2, #0
 8002552:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 8002554:	7bfa      	ldrb	r2, [r7, #15]
 8002556:	6879      	ldr	r1, [r7, #4]
 8002558:	4613      	mov	r3, r2
 800255a:	00db      	lsls	r3, r3, #3
 800255c:	1a9b      	subs	r3, r3, r2
 800255e:	009b      	lsls	r3, r3, #2
 8002560:	440b      	add	r3, r1
 8002562:	3344      	adds	r3, #68	; 0x44
 8002564:	2200      	movs	r2, #0
 8002566:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 8002568:	7bfa      	ldrb	r2, [r7, #15]
 800256a:	6879      	ldr	r1, [r7, #4]
 800256c:	4613      	mov	r3, r2
 800256e:	00db      	lsls	r3, r3, #3
 8002570:	1a9b      	subs	r3, r3, r2
 8002572:	009b      	lsls	r3, r3, #2
 8002574:	440b      	add	r3, r1
 8002576:	3348      	adds	r3, #72	; 0x48
 8002578:	2200      	movs	r2, #0
 800257a:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 800257c:	7bfa      	ldrb	r2, [r7, #15]
 800257e:	6879      	ldr	r1, [r7, #4]
 8002580:	4613      	mov	r3, r2
 8002582:	00db      	lsls	r3, r3, #3
 8002584:	1a9b      	subs	r3, r3, r2
 8002586:	009b      	lsls	r3, r3, #2
 8002588:	440b      	add	r3, r1
 800258a:	3350      	adds	r3, #80	; 0x50
 800258c:	2200      	movs	r2, #0
 800258e:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8002590:	7bfb      	ldrb	r3, [r7, #15]
 8002592:	3301      	adds	r3, #1
 8002594:	73fb      	strb	r3, [r7, #15]
 8002596:	7bfa      	ldrb	r2, [r7, #15]
 8002598:	687b      	ldr	r3, [r7, #4]
 800259a:	685b      	ldr	r3, [r3, #4]
 800259c:	429a      	cmp	r2, r3
 800259e:	d3af      	bcc.n	8002500 <HAL_PCD_Init+0xa2>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 80025a0:	2300      	movs	r3, #0
 80025a2:	73fb      	strb	r3, [r7, #15]
 80025a4:	e044      	b.n	8002630 <HAL_PCD_Init+0x1d2>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 80025a6:	7bfa      	ldrb	r2, [r7, #15]
 80025a8:	6879      	ldr	r1, [r7, #4]
 80025aa:	4613      	mov	r3, r2
 80025ac:	00db      	lsls	r3, r3, #3
 80025ae:	1a9b      	subs	r3, r3, r2
 80025b0:	009b      	lsls	r3, r3, #2
 80025b2:	440b      	add	r3, r1
 80025b4:	f203 13fd 	addw	r3, r3, #509	; 0x1fd
 80025b8:	2200      	movs	r2, #0
 80025ba:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 80025bc:	7bfa      	ldrb	r2, [r7, #15]
 80025be:	6879      	ldr	r1, [r7, #4]
 80025c0:	4613      	mov	r3, r2
 80025c2:	00db      	lsls	r3, r3, #3
 80025c4:	1a9b      	subs	r3, r3, r2
 80025c6:	009b      	lsls	r3, r3, #2
 80025c8:	440b      	add	r3, r1
 80025ca:	f503 73fe 	add.w	r3, r3, #508	; 0x1fc
 80025ce:	7bfa      	ldrb	r2, [r7, #15]
 80025d0:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 80025d2:	7bfa      	ldrb	r2, [r7, #15]
 80025d4:	6879      	ldr	r1, [r7, #4]
 80025d6:	4613      	mov	r3, r2
 80025d8:	00db      	lsls	r3, r3, #3
 80025da:	1a9b      	subs	r3, r3, r2
 80025dc:	009b      	lsls	r3, r3, #2
 80025de:	440b      	add	r3, r1
 80025e0:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
 80025e4:	2200      	movs	r2, #0
 80025e6:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 80025e8:	7bfa      	ldrb	r2, [r7, #15]
 80025ea:	6879      	ldr	r1, [r7, #4]
 80025ec:	4613      	mov	r3, r2
 80025ee:	00db      	lsls	r3, r3, #3
 80025f0:	1a9b      	subs	r3, r3, r2
 80025f2:	009b      	lsls	r3, r3, #2
 80025f4:	440b      	add	r3, r1
 80025f6:	f503 7301 	add.w	r3, r3, #516	; 0x204
 80025fa:	2200      	movs	r2, #0
 80025fc:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 80025fe:	7bfa      	ldrb	r2, [r7, #15]
 8002600:	6879      	ldr	r1, [r7, #4]
 8002602:	4613      	mov	r3, r2
 8002604:	00db      	lsls	r3, r3, #3
 8002606:	1a9b      	subs	r3, r3, r2
 8002608:	009b      	lsls	r3, r3, #2
 800260a:	440b      	add	r3, r1
 800260c:	f503 7302 	add.w	r3, r3, #520	; 0x208
 8002610:	2200      	movs	r2, #0
 8002612:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 8002614:	7bfa      	ldrb	r2, [r7, #15]
 8002616:	6879      	ldr	r1, [r7, #4]
 8002618:	4613      	mov	r3, r2
 800261a:	00db      	lsls	r3, r3, #3
 800261c:	1a9b      	subs	r3, r3, r2
 800261e:	009b      	lsls	r3, r3, #2
 8002620:	440b      	add	r3, r1
 8002622:	f503 7304 	add.w	r3, r3, #528	; 0x210
 8002626:	2200      	movs	r2, #0
 8002628:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800262a:	7bfb      	ldrb	r3, [r7, #15]
 800262c:	3301      	adds	r3, #1
 800262e:	73fb      	strb	r3, [r7, #15]
 8002630:	7bfa      	ldrb	r2, [r7, #15]
 8002632:	687b      	ldr	r3, [r7, #4]
 8002634:	685b      	ldr	r3, [r3, #4]
 8002636:	429a      	cmp	r2, r3
 8002638:	d3b5      	bcc.n	80025a6 <HAL_PCD_Init+0x148>
  }

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800263a:	687b      	ldr	r3, [r7, #4]
 800263c:	681b      	ldr	r3, [r3, #0]
 800263e:	603b      	str	r3, [r7, #0]
 8002640:	687e      	ldr	r6, [r7, #4]
 8002642:	466d      	mov	r5, sp
 8002644:	f106 0410 	add.w	r4, r6, #16
 8002648:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800264a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800264c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800264e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8002650:	e894 0003 	ldmia.w	r4, {r0, r1}
 8002654:	e885 0003 	stmia.w	r5, {r0, r1}
 8002658:	1d33      	adds	r3, r6, #4
 800265a:	cb0e      	ldmia	r3, {r1, r2, r3}
 800265c:	6838      	ldr	r0, [r7, #0]
 800265e:	f002 f993 	bl	8004988 <USB_DevInit>
 8002662:	4603      	mov	r3, r0
 8002664:	2b00      	cmp	r3, #0
 8002666:	d005      	beq.n	8002674 <HAL_PCD_Init+0x216>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 8002668:	687b      	ldr	r3, [r7, #4]
 800266a:	2202      	movs	r2, #2
 800266c:	f883 23bd 	strb.w	r2, [r3, #957]	; 0x3bd
    return HAL_ERROR;
 8002670:	2301      	movs	r3, #1
 8002672:	e00d      	b.n	8002690 <HAL_PCD_Init+0x232>
  }

  hpcd->USB_Address = 0U;
 8002674:	687b      	ldr	r3, [r7, #4]
 8002676:	2200      	movs	r2, #0
 8002678:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  hpcd->State = HAL_PCD_STATE_READY;
 800267c:	687b      	ldr	r3, [r7, #4]
 800267e:	2201      	movs	r2, #1
 8002680:	f883 23bd 	strb.w	r2, [r3, #957]	; 0x3bd
  if (hpcd->Init.lpm_enable == 1U)
  {
    (void)HAL_PCDEx_ActivateLPM(hpcd);
  }
  #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
  (void)USB_DevDisconnect(hpcd->Instance);
 8002684:	687b      	ldr	r3, [r7, #4]
 8002686:	681b      	ldr	r3, [r3, #0]
 8002688:	4618      	mov	r0, r3
 800268a:	f003 f9d2 	bl	8005a32 <USB_DevDisconnect>

  return HAL_OK;
 800268e:	2300      	movs	r3, #0
}
 8002690:	4618      	mov	r0, r3
 8002692:	3714      	adds	r7, #20
 8002694:	46bd      	mov	sp, r7
 8002696:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002698 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 8002698:	b580      	push	{r7, lr}
 800269a:	b084      	sub	sp, #16
 800269c:	af00      	add	r7, sp, #0
 800269e:	6078      	str	r0, [r7, #4]
#if defined (USB_OTG_FS) || defined (USB_OTG_HS)
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80026a0:	687b      	ldr	r3, [r7, #4]
 80026a2:	681b      	ldr	r3, [r3, #0]
 80026a4:	60fb      	str	r3, [r7, #12]
#endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */

  __HAL_LOCK(hpcd);
 80026a6:	687b      	ldr	r3, [r7, #4]
 80026a8:	f893 33bc 	ldrb.w	r3, [r3, #956]	; 0x3bc
 80026ac:	2b01      	cmp	r3, #1
 80026ae:	d101      	bne.n	80026b4 <HAL_PCD_Start+0x1c>
 80026b0:	2302      	movs	r3, #2
 80026b2:	e020      	b.n	80026f6 <HAL_PCD_Start+0x5e>
 80026b4:	687b      	ldr	r3, [r7, #4]
 80026b6:	2201      	movs	r2, #1
 80026b8:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc
#if defined (USB_OTG_FS) || defined (USB_OTG_HS)
  if ((hpcd->Init.battery_charging_enable == 1U) &&
 80026bc:	687b      	ldr	r3, [r7, #4]
 80026be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80026c0:	2b01      	cmp	r3, #1
 80026c2:	d109      	bne.n	80026d8 <HAL_PCD_Start+0x40>
      (hpcd->Init.phy_itface != USB_OTG_ULPI_PHY))
 80026c4:	687b      	ldr	r3, [r7, #4]
 80026c6:	699b      	ldr	r3, [r3, #24]
  if ((hpcd->Init.battery_charging_enable == 1U) &&
 80026c8:	2b01      	cmp	r3, #1
 80026ca:	d005      	beq.n	80026d8 <HAL_PCD_Start+0x40>
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 80026cc:	68fb      	ldr	r3, [r7, #12]
 80026ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80026d0:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 80026d4:	68fb      	ldr	r3, [r7, #12]
 80026d6:	639a      	str	r2, [r3, #56]	; 0x38
  }
#endif /* defined (USB_OTG_FS) || defined (USB_OTG_HS) */
  (void)USB_DevConnect(hpcd->Instance);
 80026d8:	687b      	ldr	r3, [r7, #4]
 80026da:	681b      	ldr	r3, [r3, #0]
 80026dc:	4618      	mov	r0, r3
 80026de:	f003 f990 	bl	8005a02 <USB_DevConnect>
  __HAL_PCD_ENABLE(hpcd);
 80026e2:	687b      	ldr	r3, [r7, #4]
 80026e4:	681b      	ldr	r3, [r3, #0]
 80026e6:	4618      	mov	r0, r3
 80026e8:	f002 f902 	bl	80048f0 <USB_EnableGlobalInt>
  __HAL_UNLOCK(hpcd);
 80026ec:	687b      	ldr	r3, [r7, #4]
 80026ee:	2200      	movs	r2, #0
 80026f0:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc
  return HAL_OK;
 80026f4:	2300      	movs	r3, #0
}
 80026f6:	4618      	mov	r0, r3
 80026f8:	3710      	adds	r7, #16
 80026fa:	46bd      	mov	sp, r7
 80026fc:	bd80      	pop	{r7, pc}

080026fe <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 80026fe:	b590      	push	{r4, r7, lr}
 8002700:	b08d      	sub	sp, #52	; 0x34
 8002702:	af00      	add	r7, sp, #0
 8002704:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8002706:	687b      	ldr	r3, [r7, #4]
 8002708:	681b      	ldr	r3, [r3, #0]
 800270a:	623b      	str	r3, [r7, #32]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800270c:	6a3b      	ldr	r3, [r7, #32]
 800270e:	61fb      	str	r3, [r7, #28]
  uint32_t i, ep_intr, epint, epnum;
  uint32_t fifoemptymsk, temp;
  USB_OTG_EPTypeDef *ep;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 8002710:	687b      	ldr	r3, [r7, #4]
 8002712:	681b      	ldr	r3, [r3, #0]
 8002714:	4618      	mov	r0, r3
 8002716:	f003 fa37 	bl	8005b88 <USB_GetMode>
 800271a:	4603      	mov	r3, r0
 800271c:	2b00      	cmp	r3, #0
 800271e:	f040 839d 	bne.w	8002e5c <HAL_PCD_IRQHandler+0x75e>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 8002722:	687b      	ldr	r3, [r7, #4]
 8002724:	681b      	ldr	r3, [r3, #0]
 8002726:	4618      	mov	r0, r3
 8002728:	f003 f99b 	bl	8005a62 <USB_ReadInterrupts>
 800272c:	4603      	mov	r3, r0
 800272e:	2b00      	cmp	r3, #0
 8002730:	f000 8393 	beq.w	8002e5a <HAL_PCD_IRQHandler+0x75c>
    {
      return;
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 8002734:	687b      	ldr	r3, [r7, #4]
 8002736:	681b      	ldr	r3, [r3, #0]
 8002738:	4618      	mov	r0, r3
 800273a:	f003 f992 	bl	8005a62 <USB_ReadInterrupts>
 800273e:	4603      	mov	r3, r0
 8002740:	f003 0302 	and.w	r3, r3, #2
 8002744:	2b02      	cmp	r3, #2
 8002746:	d107      	bne.n	8002758 <HAL_PCD_IRQHandler+0x5a>
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 8002748:	687b      	ldr	r3, [r7, #4]
 800274a:	681b      	ldr	r3, [r3, #0]
 800274c:	695a      	ldr	r2, [r3, #20]
 800274e:	687b      	ldr	r3, [r7, #4]
 8002750:	681b      	ldr	r3, [r3, #0]
 8002752:	f002 0202 	and.w	r2, r2, #2
 8002756:	615a      	str	r2, [r3, #20]
    }

     /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 8002758:	687b      	ldr	r3, [r7, #4]
 800275a:	681b      	ldr	r3, [r3, #0]
 800275c:	4618      	mov	r0, r3
 800275e:	f003 f980 	bl	8005a62 <USB_ReadInterrupts>
 8002762:	4603      	mov	r3, r0
 8002764:	f003 0310 	and.w	r3, r3, #16
 8002768:	2b10      	cmp	r3, #16
 800276a:	d161      	bne.n	8002830 <HAL_PCD_IRQHandler+0x132>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800276c:	687b      	ldr	r3, [r7, #4]
 800276e:	681b      	ldr	r3, [r3, #0]
 8002770:	699a      	ldr	r2, [r3, #24]
 8002772:	687b      	ldr	r3, [r7, #4]
 8002774:	681b      	ldr	r3, [r3, #0]
 8002776:	f022 0210 	bic.w	r2, r2, #16
 800277a:	619a      	str	r2, [r3, #24]

      temp = USBx->GRXSTSP;
 800277c:	6a3b      	ldr	r3, [r7, #32]
 800277e:	6a1b      	ldr	r3, [r3, #32]
 8002780:	61bb      	str	r3, [r7, #24]

      ep = &hpcd->OUT_ep[temp & USB_OTG_GRXSTSP_EPNUM];
 8002782:	69bb      	ldr	r3, [r7, #24]
 8002784:	f003 020f 	and.w	r2, r3, #15
 8002788:	4613      	mov	r3, r2
 800278a:	00db      	lsls	r3, r3, #3
 800278c:	1a9b      	subs	r3, r3, r2
 800278e:	009b      	lsls	r3, r3, #2
 8002790:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
 8002794:	687a      	ldr	r2, [r7, #4]
 8002796:	4413      	add	r3, r2
 8002798:	3304      	adds	r3, #4
 800279a:	617b      	str	r3, [r7, #20]

      if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800279c:	69bb      	ldr	r3, [r7, #24]
 800279e:	0c5b      	lsrs	r3, r3, #17
 80027a0:	f003 030f 	and.w	r3, r3, #15
 80027a4:	2b02      	cmp	r3, #2
 80027a6:	d124      	bne.n	80027f2 <HAL_PCD_IRQHandler+0xf4>
      {
        if ((temp & USB_OTG_GRXSTSP_BCNT) != 0U)
 80027a8:	69ba      	ldr	r2, [r7, #24]
 80027aa:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 80027ae:	4013      	ands	r3, r2
 80027b0:	2b00      	cmp	r3, #0
 80027b2:	d035      	beq.n	8002820 <HAL_PCD_IRQHandler+0x122>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 80027b4:	697b      	ldr	r3, [r7, #20]
 80027b6:	68d9      	ldr	r1, [r3, #12]
                               (uint16_t)((temp & USB_OTG_GRXSTSP_BCNT) >> 4));
 80027b8:	69bb      	ldr	r3, [r7, #24]
 80027ba:	091b      	lsrs	r3, r3, #4
 80027bc:	b29b      	uxth	r3, r3
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 80027be:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80027c2:	b29b      	uxth	r3, r3
 80027c4:	461a      	mov	r2, r3
 80027c6:	6a38      	ldr	r0, [r7, #32]
 80027c8:	f002 fff8 	bl	80057bc <USB_ReadPacket>

          ep->xfer_buff += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80027cc:	697b      	ldr	r3, [r7, #20]
 80027ce:	68da      	ldr	r2, [r3, #12]
 80027d0:	69bb      	ldr	r3, [r7, #24]
 80027d2:	091b      	lsrs	r3, r3, #4
 80027d4:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80027d8:	441a      	add	r2, r3
 80027da:	697b      	ldr	r3, [r7, #20]
 80027dc:	60da      	str	r2, [r3, #12]
          ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80027de:	697b      	ldr	r3, [r7, #20]
 80027e0:	699a      	ldr	r2, [r3, #24]
 80027e2:	69bb      	ldr	r3, [r7, #24]
 80027e4:	091b      	lsrs	r3, r3, #4
 80027e6:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80027ea:	441a      	add	r2, r3
 80027ec:	697b      	ldr	r3, [r7, #20]
 80027ee:	619a      	str	r2, [r3, #24]
 80027f0:	e016      	b.n	8002820 <HAL_PCD_IRQHandler+0x122>
        }
      }
      else if (((temp & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_SETUP_UPDT)
 80027f2:	69bb      	ldr	r3, [r7, #24]
 80027f4:	0c5b      	lsrs	r3, r3, #17
 80027f6:	f003 030f 	and.w	r3, r3, #15
 80027fa:	2b06      	cmp	r3, #6
 80027fc:	d110      	bne.n	8002820 <HAL_PCD_IRQHandler+0x122>
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 80027fe:	687b      	ldr	r3, [r7, #4]
 8002800:	f503 7371 	add.w	r3, r3, #964	; 0x3c4
 8002804:	2208      	movs	r2, #8
 8002806:	4619      	mov	r1, r3
 8002808:	6a38      	ldr	r0, [r7, #32]
 800280a:	f002 ffd7 	bl	80057bc <USB_ReadPacket>
        ep->xfer_count += (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 800280e:	697b      	ldr	r3, [r7, #20]
 8002810:	699a      	ldr	r2, [r3, #24]
 8002812:	69bb      	ldr	r3, [r7, #24]
 8002814:	091b      	lsrs	r3, r3, #4
 8002816:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800281a:	441a      	add	r2, r3
 800281c:	697b      	ldr	r3, [r7, #20]
 800281e:	619a      	str	r2, [r3, #24]
      }
      else
      {
        /* ... */
      }
      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8002820:	687b      	ldr	r3, [r7, #4]
 8002822:	681b      	ldr	r3, [r3, #0]
 8002824:	699a      	ldr	r2, [r3, #24]
 8002826:	687b      	ldr	r3, [r7, #4]
 8002828:	681b      	ldr	r3, [r3, #0]
 800282a:	f042 0210 	orr.w	r2, r2, #16
 800282e:	619a      	str	r2, [r3, #24]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 8002830:	687b      	ldr	r3, [r7, #4]
 8002832:	681b      	ldr	r3, [r3, #0]
 8002834:	4618      	mov	r0, r3
 8002836:	f003 f914 	bl	8005a62 <USB_ReadInterrupts>
 800283a:	4603      	mov	r3, r0
 800283c:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8002840:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8002844:	d16e      	bne.n	8002924 <HAL_PCD_IRQHandler+0x226>
    {
      epnum = 0U;
 8002846:	2300      	movs	r3, #0
 8002848:	627b      	str	r3, [r7, #36]	; 0x24

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 800284a:	687b      	ldr	r3, [r7, #4]
 800284c:	681b      	ldr	r3, [r3, #0]
 800284e:	4618      	mov	r0, r3
 8002850:	f003 f91a 	bl	8005a88 <USB_ReadDevAllOutEpInterrupt>
 8002854:	62b8      	str	r0, [r7, #40]	; 0x28

      while (ep_intr != 0U)
 8002856:	e062      	b.n	800291e <HAL_PCD_IRQHandler+0x220>
      {
        if ((ep_intr & 0x1U) != 0U)
 8002858:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800285a:	f003 0301 	and.w	r3, r3, #1
 800285e:	2b00      	cmp	r3, #0
 8002860:	d057      	beq.n	8002912 <HAL_PCD_IRQHandler+0x214>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 8002862:	687b      	ldr	r3, [r7, #4]
 8002864:	681b      	ldr	r3, [r3, #0]
 8002866:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002868:	b2d2      	uxtb	r2, r2
 800286a:	4611      	mov	r1, r2
 800286c:	4618      	mov	r0, r3
 800286e:	f003 f93f 	bl	8005af0 <USB_ReadDevOutEPInterrupt>
 8002872:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 8002874:	693b      	ldr	r3, [r7, #16]
 8002876:	f003 0301 	and.w	r3, r3, #1
 800287a:	2b00      	cmp	r3, #0
 800287c:	d00c      	beq.n	8002898 <HAL_PCD_IRQHandler+0x19a>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 800287e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002880:	015a      	lsls	r2, r3, #5
 8002882:	69fb      	ldr	r3, [r7, #28]
 8002884:	4413      	add	r3, r2
 8002886:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 800288a:	461a      	mov	r2, r3
 800288c:	2301      	movs	r3, #1
 800288e:	6093      	str	r3, [r2, #8]
            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
 8002890:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8002892:	6878      	ldr	r0, [r7, #4]
 8002894:	f000 fdb0 	bl	80033f8 <PCD_EP_OutXfrComplete_int>
          }

          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 8002898:	693b      	ldr	r3, [r7, #16]
 800289a:	f003 0308 	and.w	r3, r3, #8
 800289e:	2b00      	cmp	r3, #0
 80028a0:	d00c      	beq.n	80028bc <HAL_PCD_IRQHandler+0x1be>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 80028a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80028a4:	015a      	lsls	r2, r3, #5
 80028a6:	69fb      	ldr	r3, [r7, #28]
 80028a8:	4413      	add	r3, r2
 80028aa:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80028ae:	461a      	mov	r2, r3
 80028b0:	2308      	movs	r3, #8
 80028b2:	6093      	str	r3, [r2, #8]
            /* Class B setup phase done for previous decoded setup */
            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
 80028b4:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80028b6:	6878      	ldr	r0, [r7, #4]
 80028b8:	f000 feaa 	bl	8003610 <PCD_EP_OutSetupPacket_int>
          }

          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 80028bc:	693b      	ldr	r3, [r7, #16]
 80028be:	f003 0310 	and.w	r3, r3, #16
 80028c2:	2b00      	cmp	r3, #0
 80028c4:	d008      	beq.n	80028d8 <HAL_PCD_IRQHandler+0x1da>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 80028c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80028c8:	015a      	lsls	r2, r3, #5
 80028ca:	69fb      	ldr	r3, [r7, #28]
 80028cc:	4413      	add	r3, r2
 80028ce:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80028d2:	461a      	mov	r2, r3
 80028d4:	2310      	movs	r3, #16
 80028d6:	6093      	str	r3, [r2, #8]
          }

          /* Clear Status Phase Received interrupt */
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 80028d8:	693b      	ldr	r3, [r7, #16]
 80028da:	f003 0320 	and.w	r3, r3, #32
 80028de:	2b00      	cmp	r3, #0
 80028e0:	d008      	beq.n	80028f4 <HAL_PCD_IRQHandler+0x1f6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80028e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80028e4:	015a      	lsls	r2, r3, #5
 80028e6:	69fb      	ldr	r3, [r7, #28]
 80028e8:	4413      	add	r3, r2
 80028ea:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80028ee:	461a      	mov	r2, r3
 80028f0:	2320      	movs	r3, #32
 80028f2:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT NAK interrupt */
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 80028f4:	693b      	ldr	r3, [r7, #16]
 80028f6:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80028fa:	2b00      	cmp	r3, #0
 80028fc:	d009      	beq.n	8002912 <HAL_PCD_IRQHandler+0x214>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 80028fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002900:	015a      	lsls	r2, r3, #5
 8002902:	69fb      	ldr	r3, [r7, #28]
 8002904:	4413      	add	r3, r2
 8002906:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 800290a:	461a      	mov	r2, r3
 800290c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8002910:	6093      	str	r3, [r2, #8]
          }
        }
        epnum++;
 8002912:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002914:	3301      	adds	r3, #1
 8002916:	627b      	str	r3, [r7, #36]	; 0x24
        ep_intr >>= 1U;
 8002918:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800291a:	085b      	lsrs	r3, r3, #1
 800291c:	62bb      	str	r3, [r7, #40]	; 0x28
      while (ep_intr != 0U)
 800291e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002920:	2b00      	cmp	r3, #0
 8002922:	d199      	bne.n	8002858 <HAL_PCD_IRQHandler+0x15a>
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 8002924:	687b      	ldr	r3, [r7, #4]
 8002926:	681b      	ldr	r3, [r3, #0]
 8002928:	4618      	mov	r0, r3
 800292a:	f003 f89a 	bl	8005a62 <USB_ReadInterrupts>
 800292e:	4603      	mov	r3, r0
 8002930:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8002934:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8002938:	f040 80c0 	bne.w	8002abc <HAL_PCD_IRQHandler+0x3be>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 800293c:	687b      	ldr	r3, [r7, #4]
 800293e:	681b      	ldr	r3, [r3, #0]
 8002940:	4618      	mov	r0, r3
 8002942:	f003 f8bb 	bl	8005abc <USB_ReadDevAllInEpInterrupt>
 8002946:	62b8      	str	r0, [r7, #40]	; 0x28

      epnum = 0U;
 8002948:	2300      	movs	r3, #0
 800294a:	627b      	str	r3, [r7, #36]	; 0x24

      while (ep_intr != 0U)
 800294c:	e0b2      	b.n	8002ab4 <HAL_PCD_IRQHandler+0x3b6>
      {
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 800294e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002950:	f003 0301 	and.w	r3, r3, #1
 8002954:	2b00      	cmp	r3, #0
 8002956:	f000 80a7 	beq.w	8002aa8 <HAL_PCD_IRQHandler+0x3aa>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800295a:	687b      	ldr	r3, [r7, #4]
 800295c:	681b      	ldr	r3, [r3, #0]
 800295e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002960:	b2d2      	uxtb	r2, r2
 8002962:	4611      	mov	r1, r2
 8002964:	4618      	mov	r0, r3
 8002966:	f003 f8e1 	bl	8005b2c <USB_ReadDevInEPInterrupt>
 800296a:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 800296c:	693b      	ldr	r3, [r7, #16]
 800296e:	f003 0301 	and.w	r3, r3, #1
 8002972:	2b00      	cmp	r3, #0
 8002974:	d057      	beq.n	8002a26 <HAL_PCD_IRQHandler+0x328>
          {
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 8002976:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002978:	f003 030f 	and.w	r3, r3, #15
 800297c:	2201      	movs	r2, #1
 800297e:	fa02 f303 	lsl.w	r3, r2, r3
 8002982:	60fb      	str	r3, [r7, #12]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 8002984:	69fb      	ldr	r3, [r7, #28]
 8002986:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 800298a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800298c:	68fb      	ldr	r3, [r7, #12]
 800298e:	43db      	mvns	r3, r3
 8002990:	69f9      	ldr	r1, [r7, #28]
 8002992:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8002996:	4013      	ands	r3, r2
 8002998:	634b      	str	r3, [r1, #52]	; 0x34

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 800299a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800299c:	015a      	lsls	r2, r3, #5
 800299e:	69fb      	ldr	r3, [r7, #28]
 80029a0:	4413      	add	r3, r2
 80029a2:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80029a6:	461a      	mov	r2, r3
 80029a8:	2301      	movs	r3, #1
 80029aa:	6093      	str	r3, [r2, #8]

            if (hpcd->Init.dma_enable == 1U)
 80029ac:	687b      	ldr	r3, [r7, #4]
 80029ae:	691b      	ldr	r3, [r3, #16]
 80029b0:	2b01      	cmp	r3, #1
 80029b2:	d132      	bne.n	8002a1a <HAL_PCD_IRQHandler+0x31c>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 80029b4:	6879      	ldr	r1, [r7, #4]
 80029b6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80029b8:	4613      	mov	r3, r2
 80029ba:	00db      	lsls	r3, r3, #3
 80029bc:	1a9b      	subs	r3, r3, r2
 80029be:	009b      	lsls	r3, r3, #2
 80029c0:	440b      	add	r3, r1
 80029c2:	3348      	adds	r3, #72	; 0x48
 80029c4:	6819      	ldr	r1, [r3, #0]
 80029c6:	6878      	ldr	r0, [r7, #4]
 80029c8:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80029ca:	4613      	mov	r3, r2
 80029cc:	00db      	lsls	r3, r3, #3
 80029ce:	1a9b      	subs	r3, r3, r2
 80029d0:	009b      	lsls	r3, r3, #2
 80029d2:	4403      	add	r3, r0
 80029d4:	3344      	adds	r3, #68	; 0x44
 80029d6:	681b      	ldr	r3, [r3, #0]
 80029d8:	4419      	add	r1, r3
 80029da:	6878      	ldr	r0, [r7, #4]
 80029dc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80029de:	4613      	mov	r3, r2
 80029e0:	00db      	lsls	r3, r3, #3
 80029e2:	1a9b      	subs	r3, r3, r2
 80029e4:	009b      	lsls	r3, r3, #2
 80029e6:	4403      	add	r3, r0
 80029e8:	3348      	adds	r3, #72	; 0x48
 80029ea:	6019      	str	r1, [r3, #0]

              /* this is ZLP, so prepare EP0 for next setup */
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 80029ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80029ee:	2b00      	cmp	r3, #0
 80029f0:	d113      	bne.n	8002a1a <HAL_PCD_IRQHandler+0x31c>
 80029f2:	6879      	ldr	r1, [r7, #4]
 80029f4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80029f6:	4613      	mov	r3, r2
 80029f8:	00db      	lsls	r3, r3, #3
 80029fa:	1a9b      	subs	r3, r3, r2
 80029fc:	009b      	lsls	r3, r3, #2
 80029fe:	440b      	add	r3, r1
 8002a00:	3350      	adds	r3, #80	; 0x50
 8002a02:	681b      	ldr	r3, [r3, #0]
 8002a04:	2b00      	cmp	r3, #0
 8002a06:	d108      	bne.n	8002a1a <HAL_PCD_IRQHandler+0x31c>
              {
                /* prepare to rx more setup packets */
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8002a08:	687b      	ldr	r3, [r7, #4]
 8002a0a:	6818      	ldr	r0, [r3, #0]
 8002a0c:	687b      	ldr	r3, [r7, #4]
 8002a0e:	f503 7371 	add.w	r3, r3, #964	; 0x3c4
 8002a12:	461a      	mov	r2, r3
 8002a14:	2101      	movs	r1, #1
 8002a16:	f003 f8e9 	bl	8005bec <USB_EP0_OutStart>
            }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
#else
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 8002a1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002a1c:	b2db      	uxtb	r3, r3
 8002a1e:	4619      	mov	r1, r3
 8002a20:	6878      	ldr	r0, [r7, #4]
 8002a22:	f004 ffc0 	bl	80079a6 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 8002a26:	693b      	ldr	r3, [r7, #16]
 8002a28:	f003 0308 	and.w	r3, r3, #8
 8002a2c:	2b00      	cmp	r3, #0
 8002a2e:	d008      	beq.n	8002a42 <HAL_PCD_IRQHandler+0x344>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 8002a30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002a32:	015a      	lsls	r2, r3, #5
 8002a34:	69fb      	ldr	r3, [r7, #28]
 8002a36:	4413      	add	r3, r2
 8002a38:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8002a3c:	461a      	mov	r2, r3
 8002a3e:	2308      	movs	r3, #8
 8002a40:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 8002a42:	693b      	ldr	r3, [r7, #16]
 8002a44:	f003 0310 	and.w	r3, r3, #16
 8002a48:	2b00      	cmp	r3, #0
 8002a4a:	d008      	beq.n	8002a5e <HAL_PCD_IRQHandler+0x360>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 8002a4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002a4e:	015a      	lsls	r2, r3, #5
 8002a50:	69fb      	ldr	r3, [r7, #28]
 8002a52:	4413      	add	r3, r2
 8002a54:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8002a58:	461a      	mov	r2, r3
 8002a5a:	2310      	movs	r3, #16
 8002a5c:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 8002a5e:	693b      	ldr	r3, [r7, #16]
 8002a60:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002a64:	2b00      	cmp	r3, #0
 8002a66:	d008      	beq.n	8002a7a <HAL_PCD_IRQHandler+0x37c>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 8002a68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002a6a:	015a      	lsls	r2, r3, #5
 8002a6c:	69fb      	ldr	r3, [r7, #28]
 8002a6e:	4413      	add	r3, r2
 8002a70:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8002a74:	461a      	mov	r2, r3
 8002a76:	2340      	movs	r3, #64	; 0x40
 8002a78:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 8002a7a:	693b      	ldr	r3, [r7, #16]
 8002a7c:	f003 0302 	and.w	r3, r3, #2
 8002a80:	2b00      	cmp	r3, #0
 8002a82:	d008      	beq.n	8002a96 <HAL_PCD_IRQHandler+0x398>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 8002a84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002a86:	015a      	lsls	r2, r3, #5
 8002a88:	69fb      	ldr	r3, [r7, #28]
 8002a8a:	4413      	add	r3, r2
 8002a8c:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8002a90:	461a      	mov	r2, r3
 8002a92:	2302      	movs	r3, #2
 8002a94:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 8002a96:	693b      	ldr	r3, [r7, #16]
 8002a98:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002a9c:	2b00      	cmp	r3, #0
 8002a9e:	d003      	beq.n	8002aa8 <HAL_PCD_IRQHandler+0x3aa>
          {
            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
 8002aa0:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8002aa2:	6878      	ldr	r0, [r7, #4]
 8002aa4:	f000 fc1b 	bl	80032de <PCD_WriteEmptyTxFifo>
          }
        }
        epnum++;
 8002aa8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002aaa:	3301      	adds	r3, #1
 8002aac:	627b      	str	r3, [r7, #36]	; 0x24
        ep_intr >>= 1U;
 8002aae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002ab0:	085b      	lsrs	r3, r3, #1
 8002ab2:	62bb      	str	r3, [r7, #40]	; 0x28
      while (ep_intr != 0U)
 8002ab4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002ab6:	2b00      	cmp	r3, #0
 8002ab8:	f47f af49 	bne.w	800294e <HAL_PCD_IRQHandler+0x250>
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 8002abc:	687b      	ldr	r3, [r7, #4]
 8002abe:	681b      	ldr	r3, [r3, #0]
 8002ac0:	4618      	mov	r0, r3
 8002ac2:	f002 ffce 	bl	8005a62 <USB_ReadInterrupts>
 8002ac6:	4603      	mov	r3, r0
 8002ac8:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8002acc:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8002ad0:	d122      	bne.n	8002b18 <HAL_PCD_IRQHandler+0x41a>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8002ad2:	69fb      	ldr	r3, [r7, #28]
 8002ad4:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002ad8:	685b      	ldr	r3, [r3, #4]
 8002ada:	69fa      	ldr	r2, [r7, #28]
 8002adc:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8002ae0:	f023 0301 	bic.w	r3, r3, #1
 8002ae4:	6053      	str	r3, [r2, #4]

      if (hpcd->LPM_State == LPM_L1)
 8002ae6:	687b      	ldr	r3, [r7, #4]
 8002ae8:	f893 33f4 	ldrb.w	r3, [r3, #1012]	; 0x3f4
 8002aec:	2b01      	cmp	r3, #1
 8002aee:	d108      	bne.n	8002b02 <HAL_PCD_IRQHandler+0x404>
      {
        hpcd->LPM_State = LPM_L0;
 8002af0:	687b      	ldr	r3, [r7, #4]
 8002af2:	2200      	movs	r2, #0
 8002af4:	f883 23f4 	strb.w	r2, [r3, #1012]	; 0x3f4

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 8002af8:	2100      	movs	r1, #0
 8002afa:	6878      	ldr	r0, [r7, #4]
 8002afc:	f000 fe26 	bl	800374c <HAL_PCDEx_LPM_Callback>
 8002b00:	e002      	b.n	8002b08 <HAL_PCD_IRQHandler+0x40a>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->ResumeCallback(hpcd);
#else
        HAL_PCD_ResumeCallback(hpcd);
 8002b02:	6878      	ldr	r0, [r7, #4]
 8002b04:	f004 ffc6 	bl	8007a94 <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 8002b08:	687b      	ldr	r3, [r7, #4]
 8002b0a:	681b      	ldr	r3, [r3, #0]
 8002b0c:	695a      	ldr	r2, [r3, #20]
 8002b0e:	687b      	ldr	r3, [r7, #4]
 8002b10:	681b      	ldr	r3, [r3, #0]
 8002b12:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 8002b16:	615a      	str	r2, [r3, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 8002b18:	687b      	ldr	r3, [r7, #4]
 8002b1a:	681b      	ldr	r3, [r3, #0]
 8002b1c:	4618      	mov	r0, r3
 8002b1e:	f002 ffa0 	bl	8005a62 <USB_ReadInterrupts>
 8002b22:	4603      	mov	r3, r0
 8002b24:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8002b28:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8002b2c:	d112      	bne.n	8002b54 <HAL_PCD_IRQHandler+0x456>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 8002b2e:	69fb      	ldr	r3, [r7, #28]
 8002b30:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002b34:	689b      	ldr	r3, [r3, #8]
 8002b36:	f003 0301 	and.w	r3, r3, #1
 8002b3a:	2b01      	cmp	r3, #1
 8002b3c:	d102      	bne.n	8002b44 <HAL_PCD_IRQHandler+0x446>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 8002b3e:	6878      	ldr	r0, [r7, #4]
 8002b40:	f004 ff82 	bl	8007a48 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 8002b44:	687b      	ldr	r3, [r7, #4]
 8002b46:	681b      	ldr	r3, [r3, #0]
 8002b48:	695a      	ldr	r2, [r3, #20]
 8002b4a:	687b      	ldr	r3, [r7, #4]
 8002b4c:	681b      	ldr	r3, [r3, #0]
 8002b4e:	f402 6200 	and.w	r2, r2, #2048	; 0x800
 8002b52:	615a      	str	r2, [r3, #20]
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    #endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */
    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 8002b54:	687b      	ldr	r3, [r7, #4]
 8002b56:	681b      	ldr	r3, [r3, #0]
 8002b58:	4618      	mov	r0, r3
 8002b5a:	f002 ff82 	bl	8005a62 <USB_ReadInterrupts>
 8002b5e:	4603      	mov	r3, r0
 8002b60:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8002b64:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8002b68:	f040 80c7 	bne.w	8002cfa <HAL_PCD_IRQHandler+0x5fc>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 8002b6c:	69fb      	ldr	r3, [r7, #28]
 8002b6e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002b72:	685b      	ldr	r3, [r3, #4]
 8002b74:	69fa      	ldr	r2, [r7, #28]
 8002b76:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8002b7a:	f023 0301 	bic.w	r3, r3, #1
 8002b7e:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 8002b80:	687b      	ldr	r3, [r7, #4]
 8002b82:	681b      	ldr	r3, [r3, #0]
 8002b84:	2110      	movs	r1, #16
 8002b86:	4618      	mov	r0, r3
 8002b88:	f002 f862 	bl	8004c50 <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8002b8c:	2300      	movs	r3, #0
 8002b8e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002b90:	e056      	b.n	8002c40 <HAL_PCD_IRQHandler+0x542>
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 8002b92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002b94:	015a      	lsls	r2, r3, #5
 8002b96:	69fb      	ldr	r3, [r7, #28]
 8002b98:	4413      	add	r3, r2
 8002b9a:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8002b9e:	461a      	mov	r2, r3
 8002ba0:	f64f 337f 	movw	r3, #64383	; 0xfb7f
 8002ba4:	6093      	str	r3, [r2, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8002ba6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002ba8:	015a      	lsls	r2, r3, #5
 8002baa:	69fb      	ldr	r3, [r7, #28]
 8002bac:	4413      	add	r3, r2
 8002bae:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8002bb2:	681b      	ldr	r3, [r3, #0]
 8002bb4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8002bb6:	0151      	lsls	r1, r2, #5
 8002bb8:	69fa      	ldr	r2, [r7, #28]
 8002bba:	440a      	add	r2, r1
 8002bbc:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8002bc0:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8002bc4:	6013      	str	r3, [r2, #0]
        USBx_INEP(i)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 8002bc6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002bc8:	015a      	lsls	r2, r3, #5
 8002bca:	69fb      	ldr	r3, [r7, #28]
 8002bcc:	4413      	add	r3, r2
 8002bce:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8002bd2:	681b      	ldr	r3, [r3, #0]
 8002bd4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8002bd6:	0151      	lsls	r1, r2, #5
 8002bd8:	69fa      	ldr	r2, [r7, #28]
 8002bda:	440a      	add	r2, r1
 8002bdc:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8002be0:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8002be4:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 8002be6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002be8:	015a      	lsls	r2, r3, #5
 8002bea:	69fb      	ldr	r3, [r7, #28]
 8002bec:	4413      	add	r3, r2
 8002bee:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8002bf2:	461a      	mov	r2, r3
 8002bf4:	f64f 337f 	movw	r3, #64383	; 0xfb7f
 8002bf8:	6093      	str	r3, [r2, #8]
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8002bfa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002bfc:	015a      	lsls	r2, r3, #5
 8002bfe:	69fb      	ldr	r3, [r7, #28]
 8002c00:	4413      	add	r3, r2
 8002c02:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8002c06:	681b      	ldr	r3, [r3, #0]
 8002c08:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8002c0a:	0151      	lsls	r1, r2, #5
 8002c0c:	69fa      	ldr	r2, [r7, #28]
 8002c0e:	440a      	add	r2, r1
 8002c10:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8002c14:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8002c18:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8002c1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002c1c:	015a      	lsls	r2, r3, #5
 8002c1e:	69fb      	ldr	r3, [r7, #28]
 8002c20:	4413      	add	r3, r2
 8002c22:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8002c26:	681b      	ldr	r3, [r3, #0]
 8002c28:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8002c2a:	0151      	lsls	r1, r2, #5
 8002c2c:	69fa      	ldr	r2, [r7, #28]
 8002c2e:	440a      	add	r2, r1
 8002c30:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8002c34:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8002c38:	6013      	str	r3, [r2, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8002c3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002c3c:	3301      	adds	r3, #1
 8002c3e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002c40:	687b      	ldr	r3, [r7, #4]
 8002c42:	685b      	ldr	r3, [r3, #4]
 8002c44:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8002c46:	429a      	cmp	r2, r3
 8002c48:	d3a3      	bcc.n	8002b92 <HAL_PCD_IRQHandler+0x494>
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 8002c4a:	69fb      	ldr	r3, [r7, #28]
 8002c4c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002c50:	69db      	ldr	r3, [r3, #28]
 8002c52:	69fa      	ldr	r2, [r7, #28]
 8002c54:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8002c58:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
 8002c5c:	61d3      	str	r3, [r2, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
 8002c5e:	687b      	ldr	r3, [r7, #4]
 8002c60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002c62:	2b00      	cmp	r3, #0
 8002c64:	d016      	beq.n	8002c94 <HAL_PCD_IRQHandler+0x596>
      {
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 8002c66:	69fb      	ldr	r3, [r7, #28]
 8002c68:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002c6c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8002c70:	69fa      	ldr	r2, [r7, #28]
 8002c72:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8002c76:	f043 030b 	orr.w	r3, r3, #11
 8002c7a:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
                                   USB_OTG_DOEPMSK_XFRCM |
                                   USB_OTG_DOEPMSK_EPDM;

        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 8002c7e:	69fb      	ldr	r3, [r7, #28]
 8002c80:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002c84:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002c86:	69fa      	ldr	r2, [r7, #28]
 8002c88:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8002c8c:	f043 030b 	orr.w	r3, r3, #11
 8002c90:	6453      	str	r3, [r2, #68]	; 0x44
 8002c92:	e015      	b.n	8002cc0 <HAL_PCD_IRQHandler+0x5c2>
                                  USB_OTG_DIEPMSK_XFRCM |
                                  USB_OTG_DIEPMSK_EPDM;
      }
      else
      {
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 8002c94:	69fb      	ldr	r3, [r7, #28]
 8002c96:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002c9a:	695b      	ldr	r3, [r3, #20]
 8002c9c:	69fa      	ldr	r2, [r7, #28]
 8002c9e:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8002ca2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8002ca6:	f043 032b 	orr.w	r3, r3, #43	; 0x2b
 8002caa:	6153      	str	r3, [r2, #20]
                                USB_OTG_DOEPMSK_XFRCM |
                                USB_OTG_DOEPMSK_EPDM |
                                USB_OTG_DOEPMSK_OTEPSPRM |
                                USB_OTG_DOEPMSK_NAKM;

        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 8002cac:	69fb      	ldr	r3, [r7, #28]
 8002cae:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002cb2:	691b      	ldr	r3, [r3, #16]
 8002cb4:	69fa      	ldr	r2, [r7, #28]
 8002cb6:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8002cba:	f043 030b 	orr.w	r3, r3, #11
 8002cbe:	6113      	str	r3, [r2, #16]
                                USB_OTG_DIEPMSK_XFRCM |
                                USB_OTG_DIEPMSK_EPDM;
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 8002cc0:	69fb      	ldr	r3, [r7, #28]
 8002cc2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8002cc6:	681b      	ldr	r3, [r3, #0]
 8002cc8:	69fa      	ldr	r2, [r7, #28]
 8002cca:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8002cce:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8002cd2:	6013      	str	r3, [r2, #0]

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8002cd4:	687b      	ldr	r3, [r7, #4]
 8002cd6:	6818      	ldr	r0, [r3, #0]
 8002cd8:	687b      	ldr	r3, [r7, #4]
 8002cda:	691b      	ldr	r3, [r3, #16]
 8002cdc:	b2d9      	uxtb	r1, r3
                             (uint8_t *)hpcd->Setup);
 8002cde:	687b      	ldr	r3, [r7, #4]
 8002ce0:	f503 7371 	add.w	r3, r3, #964	; 0x3c4
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 8002ce4:	461a      	mov	r2, r3
 8002ce6:	f002 ff81 	bl	8005bec <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 8002cea:	687b      	ldr	r3, [r7, #4]
 8002cec:	681b      	ldr	r3, [r3, #0]
 8002cee:	695a      	ldr	r2, [r3, #20]
 8002cf0:	687b      	ldr	r3, [r7, #4]
 8002cf2:	681b      	ldr	r3, [r3, #0]
 8002cf4:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 8002cf8:	615a      	str	r2, [r3, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 8002cfa:	687b      	ldr	r3, [r7, #4]
 8002cfc:	681b      	ldr	r3, [r3, #0]
 8002cfe:	4618      	mov	r0, r3
 8002d00:	f002 feaf 	bl	8005a62 <USB_ReadInterrupts>
 8002d04:	4603      	mov	r3, r0
 8002d06:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8002d0a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8002d0e:	d124      	bne.n	8002d5a <HAL_PCD_IRQHandler+0x65c>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
 8002d10:	687b      	ldr	r3, [r7, #4]
 8002d12:	681b      	ldr	r3, [r3, #0]
 8002d14:	4618      	mov	r0, r3
 8002d16:	f002 ff45 	bl	8005ba4 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 8002d1a:	687b      	ldr	r3, [r7, #4]
 8002d1c:	681b      	ldr	r3, [r3, #0]
 8002d1e:	4618      	mov	r0, r3
 8002d20:	f001 fff7 	bl	8004d12 <USB_GetDevSpeed>
 8002d24:	4603      	mov	r3, r0
 8002d26:	461a      	mov	r2, r3
 8002d28:	687b      	ldr	r3, [r7, #4]
 8002d2a:	60da      	str	r2, [r3, #12]

      /* Set USB Turnaround time */
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8002d2c:	687b      	ldr	r3, [r7, #4]
 8002d2e:	681c      	ldr	r4, [r3, #0]
 8002d30:	f001 f932 	bl	8003f98 <HAL_RCC_GetHCLKFreq>
 8002d34:	4601      	mov	r1, r0
                                  HAL_RCC_GetHCLKFreq(),
                                  (uint8_t)hpcd->Init.speed);
 8002d36:	687b      	ldr	r3, [r7, #4]
 8002d38:	68db      	ldr	r3, [r3, #12]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 8002d3a:	b2db      	uxtb	r3, r3
 8002d3c:	461a      	mov	r2, r3
 8002d3e:	4620      	mov	r0, r4
 8002d40:	f001 fd34 	bl	80047ac <USB_SetTurnaroundTime>

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
 8002d44:	6878      	ldr	r0, [r7, #4]
 8002d46:	f004 fe56 	bl	80079f6 <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 8002d4a:	687b      	ldr	r3, [r7, #4]
 8002d4c:	681b      	ldr	r3, [r3, #0]
 8002d4e:	695a      	ldr	r2, [r3, #20]
 8002d50:	687b      	ldr	r3, [r7, #4]
 8002d52:	681b      	ldr	r3, [r3, #0]
 8002d54:	f402 5200 	and.w	r2, r2, #8192	; 0x2000
 8002d58:	615a      	str	r2, [r3, #20]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 8002d5a:	687b      	ldr	r3, [r7, #4]
 8002d5c:	681b      	ldr	r3, [r3, #0]
 8002d5e:	4618      	mov	r0, r3
 8002d60:	f002 fe7f 	bl	8005a62 <USB_ReadInterrupts>
 8002d64:	4603      	mov	r3, r0
 8002d66:	f003 0308 	and.w	r3, r3, #8
 8002d6a:	2b08      	cmp	r3, #8
 8002d6c:	d10a      	bne.n	8002d84 <HAL_PCD_IRQHandler+0x686>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
 8002d6e:	6878      	ldr	r0, [r7, #4]
 8002d70:	f004 fe33 	bl	80079da <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 8002d74:	687b      	ldr	r3, [r7, #4]
 8002d76:	681b      	ldr	r3, [r3, #0]
 8002d78:	695a      	ldr	r2, [r3, #20]
 8002d7a:	687b      	ldr	r3, [r7, #4]
 8002d7c:	681b      	ldr	r3, [r3, #0]
 8002d7e:	f002 0208 	and.w	r2, r2, #8
 8002d82:	615a      	str	r2, [r3, #20]
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 8002d84:	687b      	ldr	r3, [r7, #4]
 8002d86:	681b      	ldr	r3, [r3, #0]
 8002d88:	4618      	mov	r0, r3
 8002d8a:	f002 fe6a 	bl	8005a62 <USB_ReadInterrupts>
 8002d8e:	4603      	mov	r3, r0
 8002d90:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8002d94:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8002d98:	d10f      	bne.n	8002dba <HAL_PCD_IRQHandler+0x6bc>
    {
      /* Keep application checking the corresponding Iso IN endpoint
      causing the incomplete Interrupt */
      epnum = 0U;
 8002d9a:	2300      	movs	r3, #0
 8002d9c:	627b      	str	r3, [r7, #36]	; 0x24

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 8002d9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002da0:	b2db      	uxtb	r3, r3
 8002da2:	4619      	mov	r1, r3
 8002da4:	6878      	ldr	r0, [r7, #4]
 8002da6:	f004 fe95 	bl	8007ad4 <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 8002daa:	687b      	ldr	r3, [r7, #4]
 8002dac:	681b      	ldr	r3, [r3, #0]
 8002dae:	695a      	ldr	r2, [r3, #20]
 8002db0:	687b      	ldr	r3, [r7, #4]
 8002db2:	681b      	ldr	r3, [r3, #0]
 8002db4:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
 8002db8:	615a      	str	r2, [r3, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 8002dba:	687b      	ldr	r3, [r7, #4]
 8002dbc:	681b      	ldr	r3, [r3, #0]
 8002dbe:	4618      	mov	r0, r3
 8002dc0:	f002 fe4f 	bl	8005a62 <USB_ReadInterrupts>
 8002dc4:	4603      	mov	r3, r0
 8002dc6:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8002dca:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8002dce:	d10f      	bne.n	8002df0 <HAL_PCD_IRQHandler+0x6f2>
    {
      /* Keep application checking the corresponding Iso OUT endpoint
      causing the incomplete Interrupt */
      epnum = 0U;
 8002dd0:	2300      	movs	r3, #0
 8002dd2:	627b      	str	r3, [r7, #36]	; 0x24

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 8002dd4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002dd6:	b2db      	uxtb	r3, r3
 8002dd8:	4619      	mov	r1, r3
 8002dda:	6878      	ldr	r0, [r7, #4]
 8002ddc:	f004 fe68 	bl	8007ab0 <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8002de0:	687b      	ldr	r3, [r7, #4]
 8002de2:	681b      	ldr	r3, [r3, #0]
 8002de4:	695a      	ldr	r2, [r3, #20]
 8002de6:	687b      	ldr	r3, [r7, #4]
 8002de8:	681b      	ldr	r3, [r3, #0]
 8002dea:	f402 1200 	and.w	r2, r2, #2097152	; 0x200000
 8002dee:	615a      	str	r2, [r3, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 8002df0:	687b      	ldr	r3, [r7, #4]
 8002df2:	681b      	ldr	r3, [r3, #0]
 8002df4:	4618      	mov	r0, r3
 8002df6:	f002 fe34 	bl	8005a62 <USB_ReadInterrupts>
 8002dfa:	4603      	mov	r3, r0
 8002dfc:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8002e00:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002e04:	d10a      	bne.n	8002e1c <HAL_PCD_IRQHandler+0x71e>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
 8002e06:	6878      	ldr	r0, [r7, #4]
 8002e08:	f004 fe76 	bl	8007af8 <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 8002e0c:	687b      	ldr	r3, [r7, #4]
 8002e0e:	681b      	ldr	r3, [r3, #0]
 8002e10:	695a      	ldr	r2, [r3, #20]
 8002e12:	687b      	ldr	r3, [r7, #4]
 8002e14:	681b      	ldr	r3, [r3, #0]
 8002e16:	f002 4280 	and.w	r2, r2, #1073741824	; 0x40000000
 8002e1a:	615a      	str	r2, [r3, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 8002e1c:	687b      	ldr	r3, [r7, #4]
 8002e1e:	681b      	ldr	r3, [r3, #0]
 8002e20:	4618      	mov	r0, r3
 8002e22:	f002 fe1e 	bl	8005a62 <USB_ReadInterrupts>
 8002e26:	4603      	mov	r3, r0
 8002e28:	f003 0304 	and.w	r3, r3, #4
 8002e2c:	2b04      	cmp	r3, #4
 8002e2e:	d115      	bne.n	8002e5c <HAL_PCD_IRQHandler+0x75e>
    {
      temp = hpcd->Instance->GOTGINT;
 8002e30:	687b      	ldr	r3, [r7, #4]
 8002e32:	681b      	ldr	r3, [r3, #0]
 8002e34:	685b      	ldr	r3, [r3, #4]
 8002e36:	61bb      	str	r3, [r7, #24]

      if ((temp & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 8002e38:	69bb      	ldr	r3, [r7, #24]
 8002e3a:	f003 0304 	and.w	r3, r3, #4
 8002e3e:	2b00      	cmp	r3, #0
 8002e40:	d002      	beq.n	8002e48 <HAL_PCD_IRQHandler+0x74a>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
 8002e42:	6878      	ldr	r0, [r7, #4]
 8002e44:	f004 fe66 	bl	8007b14 <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= temp;
 8002e48:	687b      	ldr	r3, [r7, #4]
 8002e4a:	681b      	ldr	r3, [r3, #0]
 8002e4c:	6859      	ldr	r1, [r3, #4]
 8002e4e:	687b      	ldr	r3, [r7, #4]
 8002e50:	681b      	ldr	r3, [r3, #0]
 8002e52:	69ba      	ldr	r2, [r7, #24]
 8002e54:	430a      	orrs	r2, r1
 8002e56:	605a      	str	r2, [r3, #4]
 8002e58:	e000      	b.n	8002e5c <HAL_PCD_IRQHandler+0x75e>
      return;
 8002e5a:	bf00      	nop
    }
  }
}
 8002e5c:	3734      	adds	r7, #52	; 0x34
 8002e5e:	46bd      	mov	sp, r7
 8002e60:	bd90      	pop	{r4, r7, pc}

08002e62 <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 8002e62:	b580      	push	{r7, lr}
 8002e64:	b082      	sub	sp, #8
 8002e66:	af00      	add	r7, sp, #0
 8002e68:	6078      	str	r0, [r7, #4]
 8002e6a:	460b      	mov	r3, r1
 8002e6c:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
 8002e6e:	687b      	ldr	r3, [r7, #4]
 8002e70:	f893 33bc 	ldrb.w	r3, [r3, #956]	; 0x3bc
 8002e74:	2b01      	cmp	r3, #1
 8002e76:	d101      	bne.n	8002e7c <HAL_PCD_SetAddress+0x1a>
 8002e78:	2302      	movs	r3, #2
 8002e7a:	e013      	b.n	8002ea4 <HAL_PCD_SetAddress+0x42>
 8002e7c:	687b      	ldr	r3, [r7, #4]
 8002e7e:	2201      	movs	r2, #1
 8002e80:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc
  hpcd->USB_Address = address;
 8002e84:	687b      	ldr	r3, [r7, #4]
 8002e86:	78fa      	ldrb	r2, [r7, #3]
 8002e88:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  (void)USB_SetDevAddress(hpcd->Instance, address);
 8002e8c:	687b      	ldr	r3, [r7, #4]
 8002e8e:	681b      	ldr	r3, [r3, #0]
 8002e90:	78fa      	ldrb	r2, [r7, #3]
 8002e92:	4611      	mov	r1, r2
 8002e94:	4618      	mov	r0, r3
 8002e96:	f002 fd8e 	bl	80059b6 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 8002e9a:	687b      	ldr	r3, [r7, #4]
 8002e9c:	2200      	movs	r2, #0
 8002e9e:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc
  return HAL_OK;
 8002ea2:	2300      	movs	r3, #0
}
 8002ea4:	4618      	mov	r0, r3
 8002ea6:	3708      	adds	r7, #8
 8002ea8:	46bd      	mov	sp, r7
 8002eaa:	bd80      	pop	{r7, pc}

08002eac <HAL_PCD_EP_Open>:
  * @param  ep_mps endpoint max packet size
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 8002eac:	b580      	push	{r7, lr}
 8002eae:	b084      	sub	sp, #16
 8002eb0:	af00      	add	r7, sp, #0
 8002eb2:	6078      	str	r0, [r7, #4]
 8002eb4:	4608      	mov	r0, r1
 8002eb6:	4611      	mov	r1, r2
 8002eb8:	461a      	mov	r2, r3
 8002eba:	4603      	mov	r3, r0
 8002ebc:	70fb      	strb	r3, [r7, #3]
 8002ebe:	460b      	mov	r3, r1
 8002ec0:	803b      	strh	r3, [r7, #0]
 8002ec2:	4613      	mov	r3, r2
 8002ec4:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef  ret = HAL_OK;
 8002ec6:	2300      	movs	r3, #0
 8002ec8:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8002eca:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8002ece:	2b00      	cmp	r3, #0
 8002ed0:	da0f      	bge.n	8002ef2 <HAL_PCD_EP_Open+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8002ed2:	78fb      	ldrb	r3, [r7, #3]
 8002ed4:	f003 020f 	and.w	r2, r3, #15
 8002ed8:	4613      	mov	r3, r2
 8002eda:	00db      	lsls	r3, r3, #3
 8002edc:	1a9b      	subs	r3, r3, r2
 8002ede:	009b      	lsls	r3, r3, #2
 8002ee0:	3338      	adds	r3, #56	; 0x38
 8002ee2:	687a      	ldr	r2, [r7, #4]
 8002ee4:	4413      	add	r3, r2
 8002ee6:	3304      	adds	r3, #4
 8002ee8:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8002eea:	68fb      	ldr	r3, [r7, #12]
 8002eec:	2201      	movs	r2, #1
 8002eee:	705a      	strb	r2, [r3, #1]
 8002ef0:	e00f      	b.n	8002f12 <HAL_PCD_EP_Open+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8002ef2:	78fb      	ldrb	r3, [r7, #3]
 8002ef4:	f003 020f 	and.w	r2, r3, #15
 8002ef8:	4613      	mov	r3, r2
 8002efa:	00db      	lsls	r3, r3, #3
 8002efc:	1a9b      	subs	r3, r3, r2
 8002efe:	009b      	lsls	r3, r3, #2
 8002f00:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
 8002f04:	687a      	ldr	r2, [r7, #4]
 8002f06:	4413      	add	r3, r2
 8002f08:	3304      	adds	r3, #4
 8002f0a:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8002f0c:	68fb      	ldr	r3, [r7, #12]
 8002f0e:	2200      	movs	r2, #0
 8002f10:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 8002f12:	78fb      	ldrb	r3, [r7, #3]
 8002f14:	f003 030f 	and.w	r3, r3, #15
 8002f18:	b2da      	uxtb	r2, r3
 8002f1a:	68fb      	ldr	r3, [r7, #12]
 8002f1c:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = ep_mps;
 8002f1e:	883a      	ldrh	r2, [r7, #0]
 8002f20:	68fb      	ldr	r3, [r7, #12]
 8002f22:	609a      	str	r2, [r3, #8]
  ep->type = ep_type;
 8002f24:	68fb      	ldr	r3, [r7, #12]
 8002f26:	78ba      	ldrb	r2, [r7, #2]
 8002f28:	70da      	strb	r2, [r3, #3]

  if (ep->is_in != 0U)
 8002f2a:	68fb      	ldr	r3, [r7, #12]
 8002f2c:	785b      	ldrb	r3, [r3, #1]
 8002f2e:	2b00      	cmp	r3, #0
 8002f30:	d004      	beq.n	8002f3c <HAL_PCD_EP_Open+0x90>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 8002f32:	68fb      	ldr	r3, [r7, #12]
 8002f34:	781b      	ldrb	r3, [r3, #0]
 8002f36:	b29a      	uxth	r2, r3
 8002f38:	68fb      	ldr	r3, [r7, #12]
 8002f3a:	80da      	strh	r2, [r3, #6]
  }
  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 8002f3c:	78bb      	ldrb	r3, [r7, #2]
 8002f3e:	2b02      	cmp	r3, #2
 8002f40:	d102      	bne.n	8002f48 <HAL_PCD_EP_Open+0x9c>
  {
    ep->data_pid_start = 0U;
 8002f42:	68fb      	ldr	r3, [r7, #12]
 8002f44:	2200      	movs	r2, #0
 8002f46:	711a      	strb	r2, [r3, #4]
  }

  __HAL_LOCK(hpcd);
 8002f48:	687b      	ldr	r3, [r7, #4]
 8002f4a:	f893 33bc 	ldrb.w	r3, [r3, #956]	; 0x3bc
 8002f4e:	2b01      	cmp	r3, #1
 8002f50:	d101      	bne.n	8002f56 <HAL_PCD_EP_Open+0xaa>
 8002f52:	2302      	movs	r3, #2
 8002f54:	e00e      	b.n	8002f74 <HAL_PCD_EP_Open+0xc8>
 8002f56:	687b      	ldr	r3, [r7, #4]
 8002f58:	2201      	movs	r2, #1
 8002f5a:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 8002f5e:	687b      	ldr	r3, [r7, #4]
 8002f60:	681b      	ldr	r3, [r3, #0]
 8002f62:	68f9      	ldr	r1, [r7, #12]
 8002f64:	4618      	mov	r0, r3
 8002f66:	f001 fef9 	bl	8004d5c <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8002f6a:	687b      	ldr	r3, [r7, #4]
 8002f6c:	2200      	movs	r2, #0
 8002f6e:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc

  return ret;
 8002f72:	7afb      	ldrb	r3, [r7, #11]
}
 8002f74:	4618      	mov	r0, r3
 8002f76:	3710      	adds	r7, #16
 8002f78:	46bd      	mov	sp, r7
 8002f7a:	bd80      	pop	{r7, pc}

08002f7c <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8002f7c:	b580      	push	{r7, lr}
 8002f7e:	b084      	sub	sp, #16
 8002f80:	af00      	add	r7, sp, #0
 8002f82:	6078      	str	r0, [r7, #4]
 8002f84:	460b      	mov	r3, r1
 8002f86:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 8002f88:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8002f8c:	2b00      	cmp	r3, #0
 8002f8e:	da0f      	bge.n	8002fb0 <HAL_PCD_EP_Close+0x34>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8002f90:	78fb      	ldrb	r3, [r7, #3]
 8002f92:	f003 020f 	and.w	r2, r3, #15
 8002f96:	4613      	mov	r3, r2
 8002f98:	00db      	lsls	r3, r3, #3
 8002f9a:	1a9b      	subs	r3, r3, r2
 8002f9c:	009b      	lsls	r3, r3, #2
 8002f9e:	3338      	adds	r3, #56	; 0x38
 8002fa0:	687a      	ldr	r2, [r7, #4]
 8002fa2:	4413      	add	r3, r2
 8002fa4:	3304      	adds	r3, #4
 8002fa6:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8002fa8:	68fb      	ldr	r3, [r7, #12]
 8002faa:	2201      	movs	r2, #1
 8002fac:	705a      	strb	r2, [r3, #1]
 8002fae:	e00f      	b.n	8002fd0 <HAL_PCD_EP_Close+0x54>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8002fb0:	78fb      	ldrb	r3, [r7, #3]
 8002fb2:	f003 020f 	and.w	r2, r3, #15
 8002fb6:	4613      	mov	r3, r2
 8002fb8:	00db      	lsls	r3, r3, #3
 8002fba:	1a9b      	subs	r3, r3, r2
 8002fbc:	009b      	lsls	r3, r3, #2
 8002fbe:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
 8002fc2:	687a      	ldr	r2, [r7, #4]
 8002fc4:	4413      	add	r3, r2
 8002fc6:	3304      	adds	r3, #4
 8002fc8:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8002fca:	68fb      	ldr	r3, [r7, #12]
 8002fcc:	2200      	movs	r2, #0
 8002fce:	705a      	strb	r2, [r3, #1]
  }
  ep->num   = ep_addr & EP_ADDR_MSK;
 8002fd0:	78fb      	ldrb	r3, [r7, #3]
 8002fd2:	f003 030f 	and.w	r3, r3, #15
 8002fd6:	b2da      	uxtb	r2, r3
 8002fd8:	68fb      	ldr	r3, [r7, #12]
 8002fda:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 8002fdc:	687b      	ldr	r3, [r7, #4]
 8002fde:	f893 33bc 	ldrb.w	r3, [r3, #956]	; 0x3bc
 8002fe2:	2b01      	cmp	r3, #1
 8002fe4:	d101      	bne.n	8002fea <HAL_PCD_EP_Close+0x6e>
 8002fe6:	2302      	movs	r3, #2
 8002fe8:	e00e      	b.n	8003008 <HAL_PCD_EP_Close+0x8c>
 8002fea:	687b      	ldr	r3, [r7, #4]
 8002fec:	2201      	movs	r2, #1
 8002fee:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 8002ff2:	687b      	ldr	r3, [r7, #4]
 8002ff4:	681b      	ldr	r3, [r3, #0]
 8002ff6:	68f9      	ldr	r1, [r7, #12]
 8002ff8:	4618      	mov	r0, r3
 8002ffa:	f001 ff37 	bl	8004e6c <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 8002ffe:	687b      	ldr	r3, [r7, #4]
 8003000:	2200      	movs	r2, #0
 8003002:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc
  return HAL_OK;
 8003006:	2300      	movs	r3, #0
}
 8003008:	4618      	mov	r0, r3
 800300a:	3710      	adds	r7, #16
 800300c:	46bd      	mov	sp, r7
 800300e:	bd80      	pop	{r7, pc}

08003010 <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8003010:	b580      	push	{r7, lr}
 8003012:	b086      	sub	sp, #24
 8003014:	af00      	add	r7, sp, #0
 8003016:	60f8      	str	r0, [r7, #12]
 8003018:	607a      	str	r2, [r7, #4]
 800301a:	603b      	str	r3, [r7, #0]
 800301c:	460b      	mov	r3, r1
 800301e:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003020:	7afb      	ldrb	r3, [r7, #11]
 8003022:	f003 020f 	and.w	r2, r3, #15
 8003026:	4613      	mov	r3, r2
 8003028:	00db      	lsls	r3, r3, #3
 800302a:	1a9b      	subs	r3, r3, r2
 800302c:	009b      	lsls	r3, r3, #2
 800302e:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
 8003032:	68fa      	ldr	r2, [r7, #12]
 8003034:	4413      	add	r3, r2
 8003036:	3304      	adds	r3, #4
 8003038:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 800303a:	697b      	ldr	r3, [r7, #20]
 800303c:	687a      	ldr	r2, [r7, #4]
 800303e:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8003040:	697b      	ldr	r3, [r7, #20]
 8003042:	683a      	ldr	r2, [r7, #0]
 8003044:	615a      	str	r2, [r3, #20]
  ep->xfer_count = 0U;
 8003046:	697b      	ldr	r3, [r7, #20]
 8003048:	2200      	movs	r2, #0
 800304a:	619a      	str	r2, [r3, #24]
  ep->is_in = 0U;
 800304c:	697b      	ldr	r3, [r7, #20]
 800304e:	2200      	movs	r2, #0
 8003050:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003052:	7afb      	ldrb	r3, [r7, #11]
 8003054:	f003 030f 	and.w	r3, r3, #15
 8003058:	b2da      	uxtb	r2, r3
 800305a:	697b      	ldr	r3, [r7, #20]
 800305c:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 800305e:	68fb      	ldr	r3, [r7, #12]
 8003060:	691b      	ldr	r3, [r3, #16]
 8003062:	2b01      	cmp	r3, #1
 8003064:	d102      	bne.n	800306c <HAL_PCD_EP_Receive+0x5c>
  {
    ep->dma_addr = (uint32_t)pBuf;
 8003066:	687a      	ldr	r2, [r7, #4]
 8003068:	697b      	ldr	r3, [r7, #20]
 800306a:	611a      	str	r2, [r3, #16]
  }

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 800306c:	7afb      	ldrb	r3, [r7, #11]
 800306e:	f003 030f 	and.w	r3, r3, #15
 8003072:	2b00      	cmp	r3, #0
 8003074:	d109      	bne.n	800308a <HAL_PCD_EP_Receive+0x7a>
  {
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 8003076:	68fb      	ldr	r3, [r7, #12]
 8003078:	6818      	ldr	r0, [r3, #0]
 800307a:	68fb      	ldr	r3, [r7, #12]
 800307c:	691b      	ldr	r3, [r3, #16]
 800307e:	b2db      	uxtb	r3, r3
 8003080:	461a      	mov	r2, r3
 8003082:	6979      	ldr	r1, [r7, #20]
 8003084:	f002 fa12 	bl	80054ac <USB_EP0StartXfer>
 8003088:	e008      	b.n	800309c <HAL_PCD_EP_Receive+0x8c>
  }
  else
  {
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800308a:	68fb      	ldr	r3, [r7, #12]
 800308c:	6818      	ldr	r0, [r3, #0]
 800308e:	68fb      	ldr	r3, [r7, #12]
 8003090:	691b      	ldr	r3, [r3, #16]
 8003092:	b2db      	uxtb	r3, r3
 8003094:	461a      	mov	r2, r3
 8003096:	6979      	ldr	r1, [r7, #20]
 8003098:	f001 ffc4 	bl	8005024 <USB_EPStartXfer>
  }

  return HAL_OK;
 800309c:	2300      	movs	r3, #0
}
 800309e:	4618      	mov	r0, r3
 80030a0:	3718      	adds	r7, #24
 80030a2:	46bd      	mov	sp, r7
 80030a4:	bd80      	pop	{r7, pc}

080030a6 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 80030a6:	b480      	push	{r7}
 80030a8:	b083      	sub	sp, #12
 80030aa:	af00      	add	r7, sp, #0
 80030ac:	6078      	str	r0, [r7, #4]
 80030ae:	460b      	mov	r3, r1
 80030b0:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 80030b2:	78fb      	ldrb	r3, [r7, #3]
 80030b4:	f003 020f 	and.w	r2, r3, #15
 80030b8:	6879      	ldr	r1, [r7, #4]
 80030ba:	4613      	mov	r3, r2
 80030bc:	00db      	lsls	r3, r3, #3
 80030be:	1a9b      	subs	r3, r3, r2
 80030c0:	009b      	lsls	r3, r3, #2
 80030c2:	440b      	add	r3, r1
 80030c4:	f503 7305 	add.w	r3, r3, #532	; 0x214
 80030c8:	681b      	ldr	r3, [r3, #0]
}
 80030ca:	4618      	mov	r0, r3
 80030cc:	370c      	adds	r7, #12
 80030ce:	46bd      	mov	sp, r7
 80030d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030d4:	4770      	bx	lr

080030d6 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 80030d6:	b580      	push	{r7, lr}
 80030d8:	b086      	sub	sp, #24
 80030da:	af00      	add	r7, sp, #0
 80030dc:	60f8      	str	r0, [r7, #12]
 80030de:	607a      	str	r2, [r7, #4]
 80030e0:	603b      	str	r3, [r7, #0]
 80030e2:	460b      	mov	r3, r1
 80030e4:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 80030e6:	7afb      	ldrb	r3, [r7, #11]
 80030e8:	f003 020f 	and.w	r2, r3, #15
 80030ec:	4613      	mov	r3, r2
 80030ee:	00db      	lsls	r3, r3, #3
 80030f0:	1a9b      	subs	r3, r3, r2
 80030f2:	009b      	lsls	r3, r3, #2
 80030f4:	3338      	adds	r3, #56	; 0x38
 80030f6:	68fa      	ldr	r2, [r7, #12]
 80030f8:	4413      	add	r3, r2
 80030fa:	3304      	adds	r3, #4
 80030fc:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 80030fe:	697b      	ldr	r3, [r7, #20]
 8003100:	687a      	ldr	r2, [r7, #4]
 8003102:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 8003104:	697b      	ldr	r3, [r7, #20]
 8003106:	683a      	ldr	r2, [r7, #0]
 8003108:	615a      	str	r2, [r3, #20]
  ep->xfer_count = 0U;
 800310a:	697b      	ldr	r3, [r7, #20]
 800310c:	2200      	movs	r2, #0
 800310e:	619a      	str	r2, [r3, #24]
  ep->is_in = 1U;
 8003110:	697b      	ldr	r3, [r7, #20]
 8003112:	2201      	movs	r2, #1
 8003114:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 8003116:	7afb      	ldrb	r3, [r7, #11]
 8003118:	f003 030f 	and.w	r3, r3, #15
 800311c:	b2da      	uxtb	r2, r3
 800311e:	697b      	ldr	r3, [r7, #20]
 8003120:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 8003122:	68fb      	ldr	r3, [r7, #12]
 8003124:	691b      	ldr	r3, [r3, #16]
 8003126:	2b01      	cmp	r3, #1
 8003128:	d102      	bne.n	8003130 <HAL_PCD_EP_Transmit+0x5a>
  {
    ep->dma_addr = (uint32_t)pBuf;
 800312a:	687a      	ldr	r2, [r7, #4]
 800312c:	697b      	ldr	r3, [r7, #20]
 800312e:	611a      	str	r2, [r3, #16]
  }

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8003130:	7afb      	ldrb	r3, [r7, #11]
 8003132:	f003 030f 	and.w	r3, r3, #15
 8003136:	2b00      	cmp	r3, #0
 8003138:	d109      	bne.n	800314e <HAL_PCD_EP_Transmit+0x78>
  {
    (void)USB_EP0StartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800313a:	68fb      	ldr	r3, [r7, #12]
 800313c:	6818      	ldr	r0, [r3, #0]
 800313e:	68fb      	ldr	r3, [r7, #12]
 8003140:	691b      	ldr	r3, [r3, #16]
 8003142:	b2db      	uxtb	r3, r3
 8003144:	461a      	mov	r2, r3
 8003146:	6979      	ldr	r1, [r7, #20]
 8003148:	f002 f9b0 	bl	80054ac <USB_EP0StartXfer>
 800314c:	e008      	b.n	8003160 <HAL_PCD_EP_Transmit+0x8a>
  }
  else
  {
    (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800314e:	68fb      	ldr	r3, [r7, #12]
 8003150:	6818      	ldr	r0, [r3, #0]
 8003152:	68fb      	ldr	r3, [r7, #12]
 8003154:	691b      	ldr	r3, [r3, #16]
 8003156:	b2db      	uxtb	r3, r3
 8003158:	461a      	mov	r2, r3
 800315a:	6979      	ldr	r1, [r7, #20]
 800315c:	f001 ff62 	bl	8005024 <USB_EPStartXfer>
  }

  return HAL_OK;
 8003160:	2300      	movs	r3, #0
}
 8003162:	4618      	mov	r0, r3
 8003164:	3718      	adds	r7, #24
 8003166:	46bd      	mov	sp, r7
 8003168:	bd80      	pop	{r7, pc}

0800316a <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800316a:	b580      	push	{r7, lr}
 800316c:	b084      	sub	sp, #16
 800316e:	af00      	add	r7, sp, #0
 8003170:	6078      	str	r0, [r7, #4]
 8003172:	460b      	mov	r3, r1
 8003174:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 8003176:	78fb      	ldrb	r3, [r7, #3]
 8003178:	f003 020f 	and.w	r2, r3, #15
 800317c:	687b      	ldr	r3, [r7, #4]
 800317e:	685b      	ldr	r3, [r3, #4]
 8003180:	429a      	cmp	r2, r3
 8003182:	d901      	bls.n	8003188 <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
 8003184:	2301      	movs	r3, #1
 8003186:	e050      	b.n	800322a <HAL_PCD_EP_SetStall+0xc0>
  }

  if ((0x80U & ep_addr) == 0x80U)
 8003188:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800318c:	2b00      	cmp	r3, #0
 800318e:	da0f      	bge.n	80031b0 <HAL_PCD_EP_SetStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003190:	78fb      	ldrb	r3, [r7, #3]
 8003192:	f003 020f 	and.w	r2, r3, #15
 8003196:	4613      	mov	r3, r2
 8003198:	00db      	lsls	r3, r3, #3
 800319a:	1a9b      	subs	r3, r3, r2
 800319c:	009b      	lsls	r3, r3, #2
 800319e:	3338      	adds	r3, #56	; 0x38
 80031a0:	687a      	ldr	r2, [r7, #4]
 80031a2:	4413      	add	r3, r2
 80031a4:	3304      	adds	r3, #4
 80031a6:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 80031a8:	68fb      	ldr	r3, [r7, #12]
 80031aa:	2201      	movs	r2, #1
 80031ac:	705a      	strb	r2, [r3, #1]
 80031ae:	e00d      	b.n	80031cc <HAL_PCD_EP_SetStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 80031b0:	78fa      	ldrb	r2, [r7, #3]
 80031b2:	4613      	mov	r3, r2
 80031b4:	00db      	lsls	r3, r3, #3
 80031b6:	1a9b      	subs	r3, r3, r2
 80031b8:	009b      	lsls	r3, r3, #2
 80031ba:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
 80031be:	687a      	ldr	r2, [r7, #4]
 80031c0:	4413      	add	r3, r2
 80031c2:	3304      	adds	r3, #4
 80031c4:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 80031c6:	68fb      	ldr	r3, [r7, #12]
 80031c8:	2200      	movs	r2, #0
 80031ca:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
 80031cc:	68fb      	ldr	r3, [r7, #12]
 80031ce:	2201      	movs	r2, #1
 80031d0:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 80031d2:	78fb      	ldrb	r3, [r7, #3]
 80031d4:	f003 030f 	and.w	r3, r3, #15
 80031d8:	b2da      	uxtb	r2, r3
 80031da:	68fb      	ldr	r3, [r7, #12]
 80031dc:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 80031de:	687b      	ldr	r3, [r7, #4]
 80031e0:	f893 33bc 	ldrb.w	r3, [r3, #956]	; 0x3bc
 80031e4:	2b01      	cmp	r3, #1
 80031e6:	d101      	bne.n	80031ec <HAL_PCD_EP_SetStall+0x82>
 80031e8:	2302      	movs	r3, #2
 80031ea:	e01e      	b.n	800322a <HAL_PCD_EP_SetStall+0xc0>
 80031ec:	687b      	ldr	r3, [r7, #4]
 80031ee:	2201      	movs	r2, #1
 80031f0:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc

  (void)USB_EPSetStall(hpcd->Instance, ep);
 80031f4:	687b      	ldr	r3, [r7, #4]
 80031f6:	681b      	ldr	r3, [r3, #0]
 80031f8:	68f9      	ldr	r1, [r7, #12]
 80031fa:	4618      	mov	r0, r3
 80031fc:	f002 fb07 	bl	800580e <USB_EPSetStall>
  if ((ep_addr & EP_ADDR_MSK) == 0U)
 8003200:	78fb      	ldrb	r3, [r7, #3]
 8003202:	f003 030f 	and.w	r3, r3, #15
 8003206:	2b00      	cmp	r3, #0
 8003208:	d10a      	bne.n	8003220 <HAL_PCD_EP_SetStall+0xb6>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 800320a:	687b      	ldr	r3, [r7, #4]
 800320c:	6818      	ldr	r0, [r3, #0]
 800320e:	687b      	ldr	r3, [r7, #4]
 8003210:	691b      	ldr	r3, [r3, #16]
 8003212:	b2d9      	uxtb	r1, r3
 8003214:	687b      	ldr	r3, [r7, #4]
 8003216:	f503 7371 	add.w	r3, r3, #964	; 0x3c4
 800321a:	461a      	mov	r2, r3
 800321c:	f002 fce6 	bl	8005bec <USB_EP0_OutStart>
  }
  __HAL_UNLOCK(hpcd);
 8003220:	687b      	ldr	r3, [r7, #4]
 8003222:	2200      	movs	r2, #0
 8003224:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc

  return HAL_OK;
 8003228:	2300      	movs	r3, #0
}
 800322a:	4618      	mov	r0, r3
 800322c:	3710      	adds	r7, #16
 800322e:	46bd      	mov	sp, r7
 8003230:	bd80      	pop	{r7, pc}

08003232 <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 8003232:	b580      	push	{r7, lr}
 8003234:	b084      	sub	sp, #16
 8003236:	af00      	add	r7, sp, #0
 8003238:	6078      	str	r0, [r7, #4]
 800323a:	460b      	mov	r3, r1
 800323c:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 800323e:	78fb      	ldrb	r3, [r7, #3]
 8003240:	f003 020f 	and.w	r2, r3, #15
 8003244:	687b      	ldr	r3, [r7, #4]
 8003246:	685b      	ldr	r3, [r3, #4]
 8003248:	429a      	cmp	r2, r3
 800324a:	d901      	bls.n	8003250 <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
 800324c:	2301      	movs	r3, #1
 800324e:	e042      	b.n	80032d6 <HAL_PCD_EP_ClrStall+0xa4>
  }

  if ((0x80U & ep_addr) == 0x80U)
 8003250:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003254:	2b00      	cmp	r3, #0
 8003256:	da0f      	bge.n	8003278 <HAL_PCD_EP_ClrStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 8003258:	78fb      	ldrb	r3, [r7, #3]
 800325a:	f003 020f 	and.w	r2, r3, #15
 800325e:	4613      	mov	r3, r2
 8003260:	00db      	lsls	r3, r3, #3
 8003262:	1a9b      	subs	r3, r3, r2
 8003264:	009b      	lsls	r3, r3, #2
 8003266:	3338      	adds	r3, #56	; 0x38
 8003268:	687a      	ldr	r2, [r7, #4]
 800326a:	4413      	add	r3, r2
 800326c:	3304      	adds	r3, #4
 800326e:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 8003270:	68fb      	ldr	r3, [r7, #12]
 8003272:	2201      	movs	r2, #1
 8003274:	705a      	strb	r2, [r3, #1]
 8003276:	e00f      	b.n	8003298 <HAL_PCD_EP_ClrStall+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 8003278:	78fb      	ldrb	r3, [r7, #3]
 800327a:	f003 020f 	and.w	r2, r3, #15
 800327e:	4613      	mov	r3, r2
 8003280:	00db      	lsls	r3, r3, #3
 8003282:	1a9b      	subs	r3, r3, r2
 8003284:	009b      	lsls	r3, r3, #2
 8003286:	f503 73fc 	add.w	r3, r3, #504	; 0x1f8
 800328a:	687a      	ldr	r2, [r7, #4]
 800328c:	4413      	add	r3, r2
 800328e:	3304      	adds	r3, #4
 8003290:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 8003292:	68fb      	ldr	r3, [r7, #12]
 8003294:	2200      	movs	r2, #0
 8003296:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
 8003298:	68fb      	ldr	r3, [r7, #12]
 800329a:	2200      	movs	r2, #0
 800329c:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800329e:	78fb      	ldrb	r3, [r7, #3]
 80032a0:	f003 030f 	and.w	r3, r3, #15
 80032a4:	b2da      	uxtb	r2, r3
 80032a6:	68fb      	ldr	r3, [r7, #12]
 80032a8:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 80032aa:	687b      	ldr	r3, [r7, #4]
 80032ac:	f893 33bc 	ldrb.w	r3, [r3, #956]	; 0x3bc
 80032b0:	2b01      	cmp	r3, #1
 80032b2:	d101      	bne.n	80032b8 <HAL_PCD_EP_ClrStall+0x86>
 80032b4:	2302      	movs	r3, #2
 80032b6:	e00e      	b.n	80032d6 <HAL_PCD_EP_ClrStall+0xa4>
 80032b8:	687b      	ldr	r3, [r7, #4]
 80032ba:	2201      	movs	r2, #1
 80032bc:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc
  (void)USB_EPClearStall(hpcd->Instance, ep);
 80032c0:	687b      	ldr	r3, [r7, #4]
 80032c2:	681b      	ldr	r3, [r3, #0]
 80032c4:	68f9      	ldr	r1, [r7, #12]
 80032c6:	4618      	mov	r0, r3
 80032c8:	f002 fb0f 	bl	80058ea <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 80032cc:	687b      	ldr	r3, [r7, #4]
 80032ce:	2200      	movs	r2, #0
 80032d0:	f883 23bc 	strb.w	r2, [r3, #956]	; 0x3bc

  return HAL_OK;
 80032d4:	2300      	movs	r3, #0
}
 80032d6:	4618      	mov	r0, r3
 80032d8:	3710      	adds	r7, #16
 80032da:	46bd      	mov	sp, r7
 80032dc:	bd80      	pop	{r7, pc}

080032de <PCD_WriteEmptyTxFifo>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 80032de:	b580      	push	{r7, lr}
 80032e0:	b08a      	sub	sp, #40	; 0x28
 80032e2:	af02      	add	r7, sp, #8
 80032e4:	6078      	str	r0, [r7, #4]
 80032e6:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 80032e8:	687b      	ldr	r3, [r7, #4]
 80032ea:	681b      	ldr	r3, [r3, #0]
 80032ec:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80032ee:	697b      	ldr	r3, [r7, #20]
 80032f0:	613b      	str	r3, [r7, #16]
  USB_OTG_EPTypeDef *ep;
  uint32_t len;
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];
 80032f2:	683a      	ldr	r2, [r7, #0]
 80032f4:	4613      	mov	r3, r2
 80032f6:	00db      	lsls	r3, r3, #3
 80032f8:	1a9b      	subs	r3, r3, r2
 80032fa:	009b      	lsls	r3, r3, #2
 80032fc:	3338      	adds	r3, #56	; 0x38
 80032fe:	687a      	ldr	r2, [r7, #4]
 8003300:	4413      	add	r3, r2
 8003302:	3304      	adds	r3, #4
 8003304:	60fb      	str	r3, [r7, #12]

  if (ep->xfer_count > ep->xfer_len)
 8003306:	68fb      	ldr	r3, [r7, #12]
 8003308:	699a      	ldr	r2, [r3, #24]
 800330a:	68fb      	ldr	r3, [r7, #12]
 800330c:	695b      	ldr	r3, [r3, #20]
 800330e:	429a      	cmp	r2, r3
 8003310:	d901      	bls.n	8003316 <PCD_WriteEmptyTxFifo+0x38>
  {
    return HAL_ERROR;
 8003312:	2301      	movs	r3, #1
 8003314:	e06c      	b.n	80033f0 <PCD_WriteEmptyTxFifo+0x112>
  }

  len = ep->xfer_len - ep->xfer_count;
 8003316:	68fb      	ldr	r3, [r7, #12]
 8003318:	695a      	ldr	r2, [r3, #20]
 800331a:	68fb      	ldr	r3, [r7, #12]
 800331c:	699b      	ldr	r3, [r3, #24]
 800331e:	1ad3      	subs	r3, r2, r3
 8003320:	61fb      	str	r3, [r7, #28]

  if (len > ep->maxpacket)
 8003322:	68fb      	ldr	r3, [r7, #12]
 8003324:	689b      	ldr	r3, [r3, #8]
 8003326:	69fa      	ldr	r2, [r7, #28]
 8003328:	429a      	cmp	r2, r3
 800332a:	d902      	bls.n	8003332 <PCD_WriteEmptyTxFifo+0x54>
  {
    len = ep->maxpacket;
 800332c:	68fb      	ldr	r3, [r7, #12]
 800332e:	689b      	ldr	r3, [r3, #8]
 8003330:	61fb      	str	r3, [r7, #28]
  }

  len32b = (len + 3U) / 4U;
 8003332:	69fb      	ldr	r3, [r7, #28]
 8003334:	3303      	adds	r3, #3
 8003336:	089b      	lsrs	r3, r3, #2
 8003338:	61bb      	str	r3, [r7, #24]

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800333a:	e02b      	b.n	8003394 <PCD_WriteEmptyTxFifo+0xb6>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 800333c:	68fb      	ldr	r3, [r7, #12]
 800333e:	695a      	ldr	r2, [r3, #20]
 8003340:	68fb      	ldr	r3, [r7, #12]
 8003342:	699b      	ldr	r3, [r3, #24]
 8003344:	1ad3      	subs	r3, r2, r3
 8003346:	61fb      	str	r3, [r7, #28]

    if (len > ep->maxpacket)
 8003348:	68fb      	ldr	r3, [r7, #12]
 800334a:	689b      	ldr	r3, [r3, #8]
 800334c:	69fa      	ldr	r2, [r7, #28]
 800334e:	429a      	cmp	r2, r3
 8003350:	d902      	bls.n	8003358 <PCD_WriteEmptyTxFifo+0x7a>
    {
      len = ep->maxpacket;
 8003352:	68fb      	ldr	r3, [r7, #12]
 8003354:	689b      	ldr	r3, [r3, #8]
 8003356:	61fb      	str	r3, [r7, #28]
    }
    len32b = (len + 3U) / 4U;
 8003358:	69fb      	ldr	r3, [r7, #28]
 800335a:	3303      	adds	r3, #3
 800335c:	089b      	lsrs	r3, r3, #2
 800335e:	61bb      	str	r3, [r7, #24]

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 8003360:	68fb      	ldr	r3, [r7, #12]
 8003362:	68d9      	ldr	r1, [r3, #12]
 8003364:	683b      	ldr	r3, [r7, #0]
 8003366:	b2da      	uxtb	r2, r3
 8003368:	69fb      	ldr	r3, [r7, #28]
 800336a:	b298      	uxth	r0, r3
                          (uint8_t)hpcd->Init.dma_enable);
 800336c:	687b      	ldr	r3, [r7, #4]
 800336e:	691b      	ldr	r3, [r3, #16]
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 8003370:	b2db      	uxtb	r3, r3
 8003372:	9300      	str	r3, [sp, #0]
 8003374:	4603      	mov	r3, r0
 8003376:	6978      	ldr	r0, [r7, #20]
 8003378:	f002 f9eb 	bl	8005752 <USB_WritePacket>

    ep->xfer_buff  += len;
 800337c:	68fb      	ldr	r3, [r7, #12]
 800337e:	68da      	ldr	r2, [r3, #12]
 8003380:	69fb      	ldr	r3, [r7, #28]
 8003382:	441a      	add	r2, r3
 8003384:	68fb      	ldr	r3, [r7, #12]
 8003386:	60da      	str	r2, [r3, #12]
    ep->xfer_count += len;
 8003388:	68fb      	ldr	r3, [r7, #12]
 800338a:	699a      	ldr	r2, [r3, #24]
 800338c:	69fb      	ldr	r3, [r7, #28]
 800338e:	441a      	add	r2, r3
 8003390:	68fb      	ldr	r3, [r7, #12]
 8003392:	619a      	str	r2, [r3, #24]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 8003394:	683b      	ldr	r3, [r7, #0]
 8003396:	015a      	lsls	r2, r3, #5
 8003398:	693b      	ldr	r3, [r7, #16]
 800339a:	4413      	add	r3, r2
 800339c:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80033a0:	699b      	ldr	r3, [r3, #24]
 80033a2:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 80033a4:	69ba      	ldr	r2, [r7, #24]
 80033a6:	429a      	cmp	r2, r3
 80033a8:	d809      	bhi.n	80033be <PCD_WriteEmptyTxFifo+0xe0>
 80033aa:	68fb      	ldr	r3, [r7, #12]
 80033ac:	699a      	ldr	r2, [r3, #24]
 80033ae:	68fb      	ldr	r3, [r7, #12]
 80033b0:	695b      	ldr	r3, [r3, #20]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 80033b2:	429a      	cmp	r2, r3
 80033b4:	d203      	bcs.n	80033be <PCD_WriteEmptyTxFifo+0xe0>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 80033b6:	68fb      	ldr	r3, [r7, #12]
 80033b8:	695b      	ldr	r3, [r3, #20]
 80033ba:	2b00      	cmp	r3, #0
 80033bc:	d1be      	bne.n	800333c <PCD_WriteEmptyTxFifo+0x5e>
  }

  if (ep->xfer_len <= ep->xfer_count)
 80033be:	68fb      	ldr	r3, [r7, #12]
 80033c0:	695a      	ldr	r2, [r3, #20]
 80033c2:	68fb      	ldr	r3, [r7, #12]
 80033c4:	699b      	ldr	r3, [r3, #24]
 80033c6:	429a      	cmp	r2, r3
 80033c8:	d811      	bhi.n	80033ee <PCD_WriteEmptyTxFifo+0x110>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 80033ca:	683b      	ldr	r3, [r7, #0]
 80033cc:	f003 030f 	and.w	r3, r3, #15
 80033d0:	2201      	movs	r2, #1
 80033d2:	fa02 f303 	lsl.w	r3, r2, r3
 80033d6:	60bb      	str	r3, [r7, #8]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 80033d8:	693b      	ldr	r3, [r7, #16]
 80033da:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80033de:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80033e0:	68bb      	ldr	r3, [r7, #8]
 80033e2:	43db      	mvns	r3, r3
 80033e4:	6939      	ldr	r1, [r7, #16]
 80033e6:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 80033ea:	4013      	ands	r3, r2
 80033ec:	634b      	str	r3, [r1, #52]	; 0x34
  }

  return HAL_OK;
 80033ee:	2300      	movs	r3, #0
}
 80033f0:	4618      	mov	r0, r3
 80033f2:	3720      	adds	r7, #32
 80033f4:	46bd      	mov	sp, r7
 80033f6:	bd80      	pop	{r7, pc}

080033f8 <PCD_EP_OutXfrComplete_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 80033f8:	b580      	push	{r7, lr}
 80033fa:	b086      	sub	sp, #24
 80033fc:	af00      	add	r7, sp, #0
 80033fe:	6078      	str	r0, [r7, #4]
 8003400:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 8003402:	687b      	ldr	r3, [r7, #4]
 8003404:	681b      	ldr	r3, [r3, #0]
 8003406:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8003408:	697b      	ldr	r3, [r7, #20]
 800340a:	613b      	str	r3, [r7, #16]
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 800340c:	697b      	ldr	r3, [r7, #20]
 800340e:	333c      	adds	r3, #60	; 0x3c
 8003410:	3304      	adds	r3, #4
 8003412:	681b      	ldr	r3, [r3, #0]
 8003414:	60fb      	str	r3, [r7, #12]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 8003416:	683b      	ldr	r3, [r7, #0]
 8003418:	015a      	lsls	r2, r3, #5
 800341a:	693b      	ldr	r3, [r7, #16]
 800341c:	4413      	add	r3, r2
 800341e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8003422:	689b      	ldr	r3, [r3, #8]
 8003424:	60bb      	str	r3, [r7, #8]

  if (hpcd->Init.dma_enable == 1U)
 8003426:	687b      	ldr	r3, [r7, #4]
 8003428:	691b      	ldr	r3, [r3, #16]
 800342a:	2b01      	cmp	r3, #1
 800342c:	f040 80a0 	bne.w	8003570 <PCD_EP_OutXfrComplete_int+0x178>
  {
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 8003430:	68bb      	ldr	r3, [r7, #8]
 8003432:	f003 0308 	and.w	r3, r3, #8
 8003436:	2b00      	cmp	r3, #0
 8003438:	d015      	beq.n	8003466 <PCD_EP_OutXfrComplete_int+0x6e>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800343a:	68fb      	ldr	r3, [r7, #12]
 800343c:	4a72      	ldr	r2, [pc, #456]	; (8003608 <PCD_EP_OutXfrComplete_int+0x210>)
 800343e:	4293      	cmp	r3, r2
 8003440:	f240 80dd 	bls.w	80035fe <PCD_EP_OutXfrComplete_int+0x206>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 8003444:	68bb      	ldr	r3, [r7, #8]
 8003446:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800344a:	2b00      	cmp	r3, #0
 800344c:	f000 80d7 	beq.w	80035fe <PCD_EP_OutXfrComplete_int+0x206>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8003450:	683b      	ldr	r3, [r7, #0]
 8003452:	015a      	lsls	r2, r3, #5
 8003454:	693b      	ldr	r3, [r7, #16]
 8003456:	4413      	add	r3, r2
 8003458:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 800345c:	461a      	mov	r2, r3
 800345e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8003462:	6093      	str	r3, [r2, #8]
 8003464:	e0cb      	b.n	80035fe <PCD_EP_OutXfrComplete_int+0x206>
      }
    }
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 8003466:	68bb      	ldr	r3, [r7, #8]
 8003468:	f003 0320 	and.w	r3, r3, #32
 800346c:	2b00      	cmp	r3, #0
 800346e:	d009      	beq.n	8003484 <PCD_EP_OutXfrComplete_int+0x8c>
    {
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 8003470:	683b      	ldr	r3, [r7, #0]
 8003472:	015a      	lsls	r2, r3, #5
 8003474:	693b      	ldr	r3, [r7, #16]
 8003476:	4413      	add	r3, r2
 8003478:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 800347c:	461a      	mov	r2, r3
 800347e:	2320      	movs	r3, #32
 8003480:	6093      	str	r3, [r2, #8]
 8003482:	e0bc      	b.n	80035fe <PCD_EP_OutXfrComplete_int+0x206>
    }
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 8003484:	68bb      	ldr	r3, [r7, #8]
 8003486:	f003 0328 	and.w	r3, r3, #40	; 0x28
 800348a:	2b00      	cmp	r3, #0
 800348c:	f040 80b7 	bne.w	80035fe <PCD_EP_OutXfrComplete_int+0x206>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 8003490:	68fb      	ldr	r3, [r7, #12]
 8003492:	4a5d      	ldr	r2, [pc, #372]	; (8003608 <PCD_EP_OutXfrComplete_int+0x210>)
 8003494:	4293      	cmp	r3, r2
 8003496:	d90f      	bls.n	80034b8 <PCD_EP_OutXfrComplete_int+0xc0>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 8003498:	68bb      	ldr	r3, [r7, #8]
 800349a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800349e:	2b00      	cmp	r3, #0
 80034a0:	d00a      	beq.n	80034b8 <PCD_EP_OutXfrComplete_int+0xc0>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 80034a2:	683b      	ldr	r3, [r7, #0]
 80034a4:	015a      	lsls	r2, r3, #5
 80034a6:	693b      	ldr	r3, [r7, #16]
 80034a8:	4413      	add	r3, r2
 80034aa:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80034ae:	461a      	mov	r2, r3
 80034b0:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80034b4:	6093      	str	r3, [r2, #8]
 80034b6:	e0a2      	b.n	80035fe <PCD_EP_OutXfrComplete_int+0x206>
      }
      else
      {
        /* out data packet received over EP0 */
        hpcd->OUT_ep[epnum].xfer_count =
          hpcd->OUT_ep[epnum].maxpacket -
 80034b8:	6879      	ldr	r1, [r7, #4]
 80034ba:	683a      	ldr	r2, [r7, #0]
 80034bc:	4613      	mov	r3, r2
 80034be:	00db      	lsls	r3, r3, #3
 80034c0:	1a9b      	subs	r3, r3, r2
 80034c2:	009b      	lsls	r3, r3, #2
 80034c4:	440b      	add	r3, r1
 80034c6:	f503 7301 	add.w	r3, r3, #516	; 0x204
 80034ca:	681a      	ldr	r2, [r3, #0]
          (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 80034cc:	683b      	ldr	r3, [r7, #0]
 80034ce:	0159      	lsls	r1, r3, #5
 80034d0:	693b      	ldr	r3, [r7, #16]
 80034d2:	440b      	add	r3, r1
 80034d4:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80034d8:	691b      	ldr	r3, [r3, #16]
 80034da:	f3c3 0312 	ubfx	r3, r3, #0, #19
          hpcd->OUT_ep[epnum].maxpacket -
 80034de:	1ad1      	subs	r1, r2, r3
        hpcd->OUT_ep[epnum].xfer_count =
 80034e0:	6878      	ldr	r0, [r7, #4]
 80034e2:	683a      	ldr	r2, [r7, #0]
 80034e4:	4613      	mov	r3, r2
 80034e6:	00db      	lsls	r3, r3, #3
 80034e8:	1a9b      	subs	r3, r3, r2
 80034ea:	009b      	lsls	r3, r3, #2
 80034ec:	4403      	add	r3, r0
 80034ee:	f503 7305 	add.w	r3, r3, #532	; 0x214
 80034f2:	6019      	str	r1, [r3, #0]

        hpcd->OUT_ep[epnum].xfer_buff += hpcd->OUT_ep[epnum].maxpacket;
 80034f4:	6879      	ldr	r1, [r7, #4]
 80034f6:	683a      	ldr	r2, [r7, #0]
 80034f8:	4613      	mov	r3, r2
 80034fa:	00db      	lsls	r3, r3, #3
 80034fc:	1a9b      	subs	r3, r3, r2
 80034fe:	009b      	lsls	r3, r3, #2
 8003500:	440b      	add	r3, r1
 8003502:	f503 7302 	add.w	r3, r3, #520	; 0x208
 8003506:	6819      	ldr	r1, [r3, #0]
 8003508:	6878      	ldr	r0, [r7, #4]
 800350a:	683a      	ldr	r2, [r7, #0]
 800350c:	4613      	mov	r3, r2
 800350e:	00db      	lsls	r3, r3, #3
 8003510:	1a9b      	subs	r3, r3, r2
 8003512:	009b      	lsls	r3, r3, #2
 8003514:	4403      	add	r3, r0
 8003516:	f503 7301 	add.w	r3, r3, #516	; 0x204
 800351a:	681b      	ldr	r3, [r3, #0]
 800351c:	4419      	add	r1, r3
 800351e:	6878      	ldr	r0, [r7, #4]
 8003520:	683a      	ldr	r2, [r7, #0]
 8003522:	4613      	mov	r3, r2
 8003524:	00db      	lsls	r3, r3, #3
 8003526:	1a9b      	subs	r3, r3, r2
 8003528:	009b      	lsls	r3, r3, #2
 800352a:	4403      	add	r3, r0
 800352c:	f503 7302 	add.w	r3, r3, #520	; 0x208
 8003530:	6019      	str	r1, [r3, #0]

        if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 8003532:	683b      	ldr	r3, [r7, #0]
 8003534:	2b00      	cmp	r3, #0
 8003536:	d114      	bne.n	8003562 <PCD_EP_OutXfrComplete_int+0x16a>
 8003538:	6879      	ldr	r1, [r7, #4]
 800353a:	683a      	ldr	r2, [r7, #0]
 800353c:	4613      	mov	r3, r2
 800353e:	00db      	lsls	r3, r3, #3
 8003540:	1a9b      	subs	r3, r3, r2
 8003542:	009b      	lsls	r3, r3, #2
 8003544:	440b      	add	r3, r1
 8003546:	f503 7304 	add.w	r3, r3, #528	; 0x210
 800354a:	681b      	ldr	r3, [r3, #0]
 800354c:	2b00      	cmp	r3, #0
 800354e:	d108      	bne.n	8003562 <PCD_EP_OutXfrComplete_int+0x16a>
        {
          /* this is ZLP, so prepare EP0 for next setup */
          (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 8003550:	687b      	ldr	r3, [r7, #4]
 8003552:	6818      	ldr	r0, [r3, #0]
 8003554:	687b      	ldr	r3, [r7, #4]
 8003556:	f503 7371 	add.w	r3, r3, #964	; 0x3c4
 800355a:	461a      	mov	r2, r3
 800355c:	2101      	movs	r1, #1
 800355e:	f002 fb45 	bl	8005bec <USB_EP0_OutStart>
        }
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 8003562:	683b      	ldr	r3, [r7, #0]
 8003564:	b2db      	uxtb	r3, r3
 8003566:	4619      	mov	r1, r3
 8003568:	6878      	ldr	r0, [r7, #4]
 800356a:	f004 fa01 	bl	8007970 <HAL_PCD_DataOutStageCallback>
 800356e:	e046      	b.n	80035fe <PCD_EP_OutXfrComplete_int+0x206>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 8003570:	68fb      	ldr	r3, [r7, #12]
 8003572:	4a26      	ldr	r2, [pc, #152]	; (800360c <PCD_EP_OutXfrComplete_int+0x214>)
 8003574:	4293      	cmp	r3, r2
 8003576:	d124      	bne.n	80035c2 <PCD_EP_OutXfrComplete_int+0x1ca>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 8003578:	68bb      	ldr	r3, [r7, #8]
 800357a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800357e:	2b00      	cmp	r3, #0
 8003580:	d00a      	beq.n	8003598 <PCD_EP_OutXfrComplete_int+0x1a0>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8003582:	683b      	ldr	r3, [r7, #0]
 8003584:	015a      	lsls	r2, r3, #5
 8003586:	693b      	ldr	r3, [r7, #16]
 8003588:	4413      	add	r3, r2
 800358a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 800358e:	461a      	mov	r2, r3
 8003590:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8003594:	6093      	str	r3, [r2, #8]
 8003596:	e032      	b.n	80035fe <PCD_EP_OutXfrComplete_int+0x206>
      }
      else
      {
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 8003598:	68bb      	ldr	r3, [r7, #8]
 800359a:	f003 0320 	and.w	r3, r3, #32
 800359e:	2b00      	cmp	r3, #0
 80035a0:	d008      	beq.n	80035b4 <PCD_EP_OutXfrComplete_int+0x1bc>
        {
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 80035a2:	683b      	ldr	r3, [r7, #0]
 80035a4:	015a      	lsls	r2, r3, #5
 80035a6:	693b      	ldr	r3, [r7, #16]
 80035a8:	4413      	add	r3, r2
 80035aa:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80035ae:	461a      	mov	r2, r3
 80035b0:	2320      	movs	r3, #32
 80035b2:	6093      	str	r3, [r2, #8]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 80035b4:	683b      	ldr	r3, [r7, #0]
 80035b6:	b2db      	uxtb	r3, r3
 80035b8:	4619      	mov	r1, r3
 80035ba:	6878      	ldr	r0, [r7, #4]
 80035bc:	f004 f9d8 	bl	8007970 <HAL_PCD_DataOutStageCallback>
 80035c0:	e01d      	b.n	80035fe <PCD_EP_OutXfrComplete_int+0x206>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 80035c2:	683b      	ldr	r3, [r7, #0]
 80035c4:	2b00      	cmp	r3, #0
 80035c6:	d114      	bne.n	80035f2 <PCD_EP_OutXfrComplete_int+0x1fa>
 80035c8:	6879      	ldr	r1, [r7, #4]
 80035ca:	683a      	ldr	r2, [r7, #0]
 80035cc:	4613      	mov	r3, r2
 80035ce:	00db      	lsls	r3, r3, #3
 80035d0:	1a9b      	subs	r3, r3, r2
 80035d2:	009b      	lsls	r3, r3, #2
 80035d4:	440b      	add	r3, r1
 80035d6:	f503 7304 	add.w	r3, r3, #528	; 0x210
 80035da:	681b      	ldr	r3, [r3, #0]
 80035dc:	2b00      	cmp	r3, #0
 80035de:	d108      	bne.n	80035f2 <PCD_EP_OutXfrComplete_int+0x1fa>
      {
        /* this is ZLP, so prepare EP0 for next setup */
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 80035e0:	687b      	ldr	r3, [r7, #4]
 80035e2:	6818      	ldr	r0, [r3, #0]
 80035e4:	687b      	ldr	r3, [r7, #4]
 80035e6:	f503 7371 	add.w	r3, r3, #964	; 0x3c4
 80035ea:	461a      	mov	r2, r3
 80035ec:	2100      	movs	r1, #0
 80035ee:	f002 fafd 	bl	8005bec <USB_EP0_OutStart>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 80035f2:	683b      	ldr	r3, [r7, #0]
 80035f4:	b2db      	uxtb	r3, r3
 80035f6:	4619      	mov	r1, r3
 80035f8:	6878      	ldr	r0, [r7, #4]
 80035fa:	f004 f9b9 	bl	8007970 <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  return HAL_OK;
 80035fe:	2300      	movs	r3, #0
}
 8003600:	4618      	mov	r0, r3
 8003602:	3718      	adds	r7, #24
 8003604:	46bd      	mov	sp, r7
 8003606:	bd80      	pop	{r7, pc}
 8003608:	4f54300a 	.word	0x4f54300a
 800360c:	4f54310a 	.word	0x4f54310a

08003610 <PCD_EP_OutSetupPacket_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 8003610:	b580      	push	{r7, lr}
 8003612:	b086      	sub	sp, #24
 8003614:	af00      	add	r7, sp, #0
 8003616:	6078      	str	r0, [r7, #4]
 8003618:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800361a:	687b      	ldr	r3, [r7, #4]
 800361c:	681b      	ldr	r3, [r3, #0]
 800361e:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8003620:	697b      	ldr	r3, [r7, #20]
 8003622:	613b      	str	r3, [r7, #16]
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8003624:	697b      	ldr	r3, [r7, #20]
 8003626:	333c      	adds	r3, #60	; 0x3c
 8003628:	3304      	adds	r3, #4
 800362a:	681b      	ldr	r3, [r3, #0]
 800362c:	60fb      	str	r3, [r7, #12]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800362e:	683b      	ldr	r3, [r7, #0]
 8003630:	015a      	lsls	r2, r3, #5
 8003632:	693b      	ldr	r3, [r7, #16]
 8003634:	4413      	add	r3, r2
 8003636:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 800363a:	689b      	ldr	r3, [r3, #8]
 800363c:	60bb      	str	r3, [r7, #8]

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800363e:	68fb      	ldr	r3, [r7, #12]
 8003640:	4a15      	ldr	r2, [pc, #84]	; (8003698 <PCD_EP_OutSetupPacket_int+0x88>)
 8003642:	4293      	cmp	r3, r2
 8003644:	d90e      	bls.n	8003664 <PCD_EP_OutSetupPacket_int+0x54>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 8003646:	68bb      	ldr	r3, [r7, #8]
 8003648:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800364c:	2b00      	cmp	r3, #0
 800364e:	d009      	beq.n	8003664 <PCD_EP_OutSetupPacket_int+0x54>
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 8003650:	683b      	ldr	r3, [r7, #0]
 8003652:	015a      	lsls	r2, r3, #5
 8003654:	693b      	ldr	r3, [r7, #16]
 8003656:	4413      	add	r3, r2
 8003658:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 800365c:	461a      	mov	r2, r3
 800365e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8003662:	6093      	str	r3, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 8003664:	6878      	ldr	r0, [r7, #4]
 8003666:	f004 f971 	bl	800794c <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 800366a:	68fb      	ldr	r3, [r7, #12]
 800366c:	4a0a      	ldr	r2, [pc, #40]	; (8003698 <PCD_EP_OutSetupPacket_int+0x88>)
 800366e:	4293      	cmp	r3, r2
 8003670:	d90c      	bls.n	800368c <PCD_EP_OutSetupPacket_int+0x7c>
 8003672:	687b      	ldr	r3, [r7, #4]
 8003674:	691b      	ldr	r3, [r3, #16]
 8003676:	2b01      	cmp	r3, #1
 8003678:	d108      	bne.n	800368c <PCD_EP_OutSetupPacket_int+0x7c>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800367a:	687b      	ldr	r3, [r7, #4]
 800367c:	6818      	ldr	r0, [r3, #0]
 800367e:	687b      	ldr	r3, [r7, #4]
 8003680:	f503 7371 	add.w	r3, r3, #964	; 0x3c4
 8003684:	461a      	mov	r2, r3
 8003686:	2101      	movs	r1, #1
 8003688:	f002 fab0 	bl	8005bec <USB_EP0_OutStart>
  }

  return HAL_OK;
 800368c:	2300      	movs	r3, #0
}
 800368e:	4618      	mov	r0, r3
 8003690:	3718      	adds	r7, #24
 8003692:	46bd      	mov	sp, r7
 8003694:	bd80      	pop	{r7, pc}
 8003696:	bf00      	nop
 8003698:	4f54300a 	.word	0x4f54300a

0800369c <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 800369c:	b480      	push	{r7}
 800369e:	b085      	sub	sp, #20
 80036a0:	af00      	add	r7, sp, #0
 80036a2:	6078      	str	r0, [r7, #4]
 80036a4:	460b      	mov	r3, r1
 80036a6:	70fb      	strb	r3, [r7, #3]
 80036a8:	4613      	mov	r3, r2
 80036aa:	803b      	strh	r3, [r7, #0]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 80036ac:	687b      	ldr	r3, [r7, #4]
 80036ae:	681b      	ldr	r3, [r3, #0]
 80036b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80036b2:	60bb      	str	r3, [r7, #8]

  if (fifo == 0U)
 80036b4:	78fb      	ldrb	r3, [r7, #3]
 80036b6:	2b00      	cmp	r3, #0
 80036b8:	d107      	bne.n	80036ca <HAL_PCDEx_SetTxFiFo+0x2e>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 80036ba:	883b      	ldrh	r3, [r7, #0]
 80036bc:	0419      	lsls	r1, r3, #16
 80036be:	687b      	ldr	r3, [r7, #4]
 80036c0:	681b      	ldr	r3, [r3, #0]
 80036c2:	68ba      	ldr	r2, [r7, #8]
 80036c4:	430a      	orrs	r2, r1
 80036c6:	629a      	str	r2, [r3, #40]	; 0x28
 80036c8:	e028      	b.n	800371c <HAL_PCDEx_SetTxFiFo+0x80>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 80036ca:	687b      	ldr	r3, [r7, #4]
 80036cc:	681b      	ldr	r3, [r3, #0]
 80036ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80036d0:	0c1b      	lsrs	r3, r3, #16
 80036d2:	68ba      	ldr	r2, [r7, #8]
 80036d4:	4413      	add	r3, r2
 80036d6:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 80036d8:	2300      	movs	r3, #0
 80036da:	73fb      	strb	r3, [r7, #15]
 80036dc:	e00d      	b.n	80036fa <HAL_PCDEx_SetTxFiFo+0x5e>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 80036de:	687b      	ldr	r3, [r7, #4]
 80036e0:	681a      	ldr	r2, [r3, #0]
 80036e2:	7bfb      	ldrb	r3, [r7, #15]
 80036e4:	3340      	adds	r3, #64	; 0x40
 80036e6:	009b      	lsls	r3, r3, #2
 80036e8:	4413      	add	r3, r2
 80036ea:	685b      	ldr	r3, [r3, #4]
 80036ec:	0c1b      	lsrs	r3, r3, #16
 80036ee:	68ba      	ldr	r2, [r7, #8]
 80036f0:	4413      	add	r3, r2
 80036f2:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 80036f4:	7bfb      	ldrb	r3, [r7, #15]
 80036f6:	3301      	adds	r3, #1
 80036f8:	73fb      	strb	r3, [r7, #15]
 80036fa:	7bfa      	ldrb	r2, [r7, #15]
 80036fc:	78fb      	ldrb	r3, [r7, #3]
 80036fe:	3b01      	subs	r3, #1
 8003700:	429a      	cmp	r2, r3
 8003702:	d3ec      	bcc.n	80036de <HAL_PCDEx_SetTxFiFo+0x42>
    }

    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 8003704:	883b      	ldrh	r3, [r7, #0]
 8003706:	0418      	lsls	r0, r3, #16
 8003708:	687b      	ldr	r3, [r7, #4]
 800370a:	6819      	ldr	r1, [r3, #0]
 800370c:	78fb      	ldrb	r3, [r7, #3]
 800370e:	3b01      	subs	r3, #1
 8003710:	68ba      	ldr	r2, [r7, #8]
 8003712:	4302      	orrs	r2, r0
 8003714:	3340      	adds	r3, #64	; 0x40
 8003716:	009b      	lsls	r3, r3, #2
 8003718:	440b      	add	r3, r1
 800371a:	605a      	str	r2, [r3, #4]
  }

  return HAL_OK;
 800371c:	2300      	movs	r3, #0
}
 800371e:	4618      	mov	r0, r3
 8003720:	3714      	adds	r7, #20
 8003722:	46bd      	mov	sp, r7
 8003724:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003728:	4770      	bx	lr

0800372a <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
 800372a:	b480      	push	{r7}
 800372c:	b083      	sub	sp, #12
 800372e:	af00      	add	r7, sp, #0
 8003730:	6078      	str	r0, [r7, #4]
 8003732:	460b      	mov	r3, r1
 8003734:	807b      	strh	r3, [r7, #2]
  hpcd->Instance->GRXFSIZ = size;
 8003736:	687b      	ldr	r3, [r7, #4]
 8003738:	681b      	ldr	r3, [r3, #0]
 800373a:	887a      	ldrh	r2, [r7, #2]
 800373c:	625a      	str	r2, [r3, #36]	; 0x24

  return HAL_OK;
 800373e:	2300      	movs	r3, #0
}
 8003740:	4618      	mov	r0, r3
 8003742:	370c      	adds	r7, #12
 8003744:	46bd      	mov	sp, r7
 8003746:	f85d 7b04 	ldr.w	r7, [sp], #4
 800374a:	4770      	bx	lr

0800374c <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
 800374c:	b480      	push	{r7}
 800374e:	b083      	sub	sp, #12
 8003750:	af00      	add	r7, sp, #0
 8003752:	6078      	str	r0, [r7, #4]
 8003754:	460b      	mov	r3, r1
 8003756:	70fb      	strb	r3, [r7, #3]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 8003758:	bf00      	nop
 800375a:	370c      	adds	r7, #12
 800375c:	46bd      	mov	sp, r7
 800375e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003762:	4770      	bx	lr

08003764 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8003764:	b580      	push	{r7, lr}
 8003766:	b086      	sub	sp, #24
 8003768:	af00      	add	r7, sp, #0
 800376a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 800376c:	687b      	ldr	r3, [r7, #4]
 800376e:	2b00      	cmp	r3, #0
 8003770:	d101      	bne.n	8003776 <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 8003772:	2301      	movs	r3, #1
 8003774:	e25e      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003776:	687b      	ldr	r3, [r7, #4]
 8003778:	681b      	ldr	r3, [r3, #0]
 800377a:	f003 0301 	and.w	r3, r3, #1
 800377e:	2b00      	cmp	r3, #0
 8003780:	d075      	beq.n	800386e <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8003782:	4b88      	ldr	r3, [pc, #544]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 8003784:	689b      	ldr	r3, [r3, #8]
 8003786:	f003 030c 	and.w	r3, r3, #12
 800378a:	2b04      	cmp	r3, #4
 800378c:	d00c      	beq.n	80037a8 <HAL_RCC_OscConfig+0x44>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800378e:	4b85      	ldr	r3, [pc, #532]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 8003790:	689b      	ldr	r3, [r3, #8]
 8003792:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8003796:	2b08      	cmp	r3, #8
 8003798:	d112      	bne.n	80037c0 <HAL_RCC_OscConfig+0x5c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800379a:	4b82      	ldr	r3, [pc, #520]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 800379c:	685b      	ldr	r3, [r3, #4]
 800379e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80037a2:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80037a6:	d10b      	bne.n	80037c0 <HAL_RCC_OscConfig+0x5c>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80037a8:	4b7e      	ldr	r3, [pc, #504]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80037aa:	681b      	ldr	r3, [r3, #0]
 80037ac:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80037b0:	2b00      	cmp	r3, #0
 80037b2:	d05b      	beq.n	800386c <HAL_RCC_OscConfig+0x108>
 80037b4:	687b      	ldr	r3, [r7, #4]
 80037b6:	685b      	ldr	r3, [r3, #4]
 80037b8:	2b00      	cmp	r3, #0
 80037ba:	d157      	bne.n	800386c <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 80037bc:	2301      	movs	r3, #1
 80037be:	e239      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80037c0:	687b      	ldr	r3, [r7, #4]
 80037c2:	685b      	ldr	r3, [r3, #4]
 80037c4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80037c8:	d106      	bne.n	80037d8 <HAL_RCC_OscConfig+0x74>
 80037ca:	4b76      	ldr	r3, [pc, #472]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80037cc:	681b      	ldr	r3, [r3, #0]
 80037ce:	4a75      	ldr	r2, [pc, #468]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80037d0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80037d4:	6013      	str	r3, [r2, #0]
 80037d6:	e01d      	b.n	8003814 <HAL_RCC_OscConfig+0xb0>
 80037d8:	687b      	ldr	r3, [r7, #4]
 80037da:	685b      	ldr	r3, [r3, #4]
 80037dc:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80037e0:	d10c      	bne.n	80037fc <HAL_RCC_OscConfig+0x98>
 80037e2:	4b70      	ldr	r3, [pc, #448]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80037e4:	681b      	ldr	r3, [r3, #0]
 80037e6:	4a6f      	ldr	r2, [pc, #444]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80037e8:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80037ec:	6013      	str	r3, [r2, #0]
 80037ee:	4b6d      	ldr	r3, [pc, #436]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80037f0:	681b      	ldr	r3, [r3, #0]
 80037f2:	4a6c      	ldr	r2, [pc, #432]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80037f4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80037f8:	6013      	str	r3, [r2, #0]
 80037fa:	e00b      	b.n	8003814 <HAL_RCC_OscConfig+0xb0>
 80037fc:	4b69      	ldr	r3, [pc, #420]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80037fe:	681b      	ldr	r3, [r3, #0]
 8003800:	4a68      	ldr	r2, [pc, #416]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 8003802:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003806:	6013      	str	r3, [r2, #0]
 8003808:	4b66      	ldr	r3, [pc, #408]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 800380a:	681b      	ldr	r3, [r3, #0]
 800380c:	4a65      	ldr	r2, [pc, #404]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 800380e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003812:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8003814:	687b      	ldr	r3, [r7, #4]
 8003816:	685b      	ldr	r3, [r3, #4]
 8003818:	2b00      	cmp	r3, #0
 800381a:	d013      	beq.n	8003844 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800381c:	f7fd fdaa 	bl	8001374 <HAL_GetTick>
 8003820:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003822:	e008      	b.n	8003836 <HAL_RCC_OscConfig+0xd2>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003824:	f7fd fda6 	bl	8001374 <HAL_GetTick>
 8003828:	4602      	mov	r2, r0
 800382a:	693b      	ldr	r3, [r7, #16]
 800382c:	1ad3      	subs	r3, r2, r3
 800382e:	2b64      	cmp	r3, #100	; 0x64
 8003830:	d901      	bls.n	8003836 <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 8003832:	2303      	movs	r3, #3
 8003834:	e1fe      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003836:	4b5b      	ldr	r3, [pc, #364]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 8003838:	681b      	ldr	r3, [r3, #0]
 800383a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800383e:	2b00      	cmp	r3, #0
 8003840:	d0f0      	beq.n	8003824 <HAL_RCC_OscConfig+0xc0>
 8003842:	e014      	b.n	800386e <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003844:	f7fd fd96 	bl	8001374 <HAL_GetTick>
 8003848:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800384a:	e008      	b.n	800385e <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800384c:	f7fd fd92 	bl	8001374 <HAL_GetTick>
 8003850:	4602      	mov	r2, r0
 8003852:	693b      	ldr	r3, [r7, #16]
 8003854:	1ad3      	subs	r3, r2, r3
 8003856:	2b64      	cmp	r3, #100	; 0x64
 8003858:	d901      	bls.n	800385e <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 800385a:	2303      	movs	r3, #3
 800385c:	e1ea      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800385e:	4b51      	ldr	r3, [pc, #324]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 8003860:	681b      	ldr	r3, [r3, #0]
 8003862:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003866:	2b00      	cmp	r3, #0
 8003868:	d1f0      	bne.n	800384c <HAL_RCC_OscConfig+0xe8>
 800386a:	e000      	b.n	800386e <HAL_RCC_OscConfig+0x10a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800386c:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800386e:	687b      	ldr	r3, [r7, #4]
 8003870:	681b      	ldr	r3, [r3, #0]
 8003872:	f003 0302 	and.w	r3, r3, #2
 8003876:	2b00      	cmp	r3, #0
 8003878:	d063      	beq.n	8003942 <HAL_RCC_OscConfig+0x1de>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800387a:	4b4a      	ldr	r3, [pc, #296]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 800387c:	689b      	ldr	r3, [r3, #8]
 800387e:	f003 030c 	and.w	r3, r3, #12
 8003882:	2b00      	cmp	r3, #0
 8003884:	d00b      	beq.n	800389e <HAL_RCC_OscConfig+0x13a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8003886:	4b47      	ldr	r3, [pc, #284]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 8003888:	689b      	ldr	r3, [r3, #8]
 800388a:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800388e:	2b08      	cmp	r3, #8
 8003890:	d11c      	bne.n	80038cc <HAL_RCC_OscConfig+0x168>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8003892:	4b44      	ldr	r3, [pc, #272]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 8003894:	685b      	ldr	r3, [r3, #4]
 8003896:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800389a:	2b00      	cmp	r3, #0
 800389c:	d116      	bne.n	80038cc <HAL_RCC_OscConfig+0x168>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800389e:	4b41      	ldr	r3, [pc, #260]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80038a0:	681b      	ldr	r3, [r3, #0]
 80038a2:	f003 0302 	and.w	r3, r3, #2
 80038a6:	2b00      	cmp	r3, #0
 80038a8:	d005      	beq.n	80038b6 <HAL_RCC_OscConfig+0x152>
 80038aa:	687b      	ldr	r3, [r7, #4]
 80038ac:	68db      	ldr	r3, [r3, #12]
 80038ae:	2b01      	cmp	r3, #1
 80038b0:	d001      	beq.n	80038b6 <HAL_RCC_OscConfig+0x152>
      {
        return HAL_ERROR;
 80038b2:	2301      	movs	r3, #1
 80038b4:	e1be      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80038b6:	4b3b      	ldr	r3, [pc, #236]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80038b8:	681b      	ldr	r3, [r3, #0]
 80038ba:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 80038be:	687b      	ldr	r3, [r7, #4]
 80038c0:	691b      	ldr	r3, [r3, #16]
 80038c2:	00db      	lsls	r3, r3, #3
 80038c4:	4937      	ldr	r1, [pc, #220]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80038c6:	4313      	orrs	r3, r2
 80038c8:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80038ca:	e03a      	b.n	8003942 <HAL_RCC_OscConfig+0x1de>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 80038cc:	687b      	ldr	r3, [r7, #4]
 80038ce:	68db      	ldr	r3, [r3, #12]
 80038d0:	2b00      	cmp	r3, #0
 80038d2:	d020      	beq.n	8003916 <HAL_RCC_OscConfig+0x1b2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 80038d4:	4b34      	ldr	r3, [pc, #208]	; (80039a8 <HAL_RCC_OscConfig+0x244>)
 80038d6:	2201      	movs	r2, #1
 80038d8:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80038da:	f7fd fd4b 	bl	8001374 <HAL_GetTick>
 80038de:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80038e0:	e008      	b.n	80038f4 <HAL_RCC_OscConfig+0x190>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80038e2:	f7fd fd47 	bl	8001374 <HAL_GetTick>
 80038e6:	4602      	mov	r2, r0
 80038e8:	693b      	ldr	r3, [r7, #16]
 80038ea:	1ad3      	subs	r3, r2, r3
 80038ec:	2b02      	cmp	r3, #2
 80038ee:	d901      	bls.n	80038f4 <HAL_RCC_OscConfig+0x190>
          {
            return HAL_TIMEOUT;
 80038f0:	2303      	movs	r3, #3
 80038f2:	e19f      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80038f4:	4b2b      	ldr	r3, [pc, #172]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 80038f6:	681b      	ldr	r3, [r3, #0]
 80038f8:	f003 0302 	and.w	r3, r3, #2
 80038fc:	2b00      	cmp	r3, #0
 80038fe:	d0f0      	beq.n	80038e2 <HAL_RCC_OscConfig+0x17e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003900:	4b28      	ldr	r3, [pc, #160]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 8003902:	681b      	ldr	r3, [r3, #0]
 8003904:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8003908:	687b      	ldr	r3, [r7, #4]
 800390a:	691b      	ldr	r3, [r3, #16]
 800390c:	00db      	lsls	r3, r3, #3
 800390e:	4925      	ldr	r1, [pc, #148]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 8003910:	4313      	orrs	r3, r2
 8003912:	600b      	str	r3, [r1, #0]
 8003914:	e015      	b.n	8003942 <HAL_RCC_OscConfig+0x1de>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8003916:	4b24      	ldr	r3, [pc, #144]	; (80039a8 <HAL_RCC_OscConfig+0x244>)
 8003918:	2200      	movs	r2, #0
 800391a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800391c:	f7fd fd2a 	bl	8001374 <HAL_GetTick>
 8003920:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8003922:	e008      	b.n	8003936 <HAL_RCC_OscConfig+0x1d2>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8003924:	f7fd fd26 	bl	8001374 <HAL_GetTick>
 8003928:	4602      	mov	r2, r0
 800392a:	693b      	ldr	r3, [r7, #16]
 800392c:	1ad3      	subs	r3, r2, r3
 800392e:	2b02      	cmp	r3, #2
 8003930:	d901      	bls.n	8003936 <HAL_RCC_OscConfig+0x1d2>
          {
            return HAL_TIMEOUT;
 8003932:	2303      	movs	r3, #3
 8003934:	e17e      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8003936:	4b1b      	ldr	r3, [pc, #108]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 8003938:	681b      	ldr	r3, [r3, #0]
 800393a:	f003 0302 	and.w	r3, r3, #2
 800393e:	2b00      	cmp	r3, #0
 8003940:	d1f0      	bne.n	8003924 <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8003942:	687b      	ldr	r3, [r7, #4]
 8003944:	681b      	ldr	r3, [r3, #0]
 8003946:	f003 0308 	and.w	r3, r3, #8
 800394a:	2b00      	cmp	r3, #0
 800394c:	d036      	beq.n	80039bc <HAL_RCC_OscConfig+0x258>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800394e:	687b      	ldr	r3, [r7, #4]
 8003950:	695b      	ldr	r3, [r3, #20]
 8003952:	2b00      	cmp	r3, #0
 8003954:	d016      	beq.n	8003984 <HAL_RCC_OscConfig+0x220>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8003956:	4b15      	ldr	r3, [pc, #84]	; (80039ac <HAL_RCC_OscConfig+0x248>)
 8003958:	2201      	movs	r2, #1
 800395a:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800395c:	f7fd fd0a 	bl	8001374 <HAL_GetTick>
 8003960:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003962:	e008      	b.n	8003976 <HAL_RCC_OscConfig+0x212>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8003964:	f7fd fd06 	bl	8001374 <HAL_GetTick>
 8003968:	4602      	mov	r2, r0
 800396a:	693b      	ldr	r3, [r7, #16]
 800396c:	1ad3      	subs	r3, r2, r3
 800396e:	2b02      	cmp	r3, #2
 8003970:	d901      	bls.n	8003976 <HAL_RCC_OscConfig+0x212>
        {
          return HAL_TIMEOUT;
 8003972:	2303      	movs	r3, #3
 8003974:	e15e      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8003976:	4b0b      	ldr	r3, [pc, #44]	; (80039a4 <HAL_RCC_OscConfig+0x240>)
 8003978:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800397a:	f003 0302 	and.w	r3, r3, #2
 800397e:	2b00      	cmp	r3, #0
 8003980:	d0f0      	beq.n	8003964 <HAL_RCC_OscConfig+0x200>
 8003982:	e01b      	b.n	80039bc <HAL_RCC_OscConfig+0x258>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8003984:	4b09      	ldr	r3, [pc, #36]	; (80039ac <HAL_RCC_OscConfig+0x248>)
 8003986:	2200      	movs	r2, #0
 8003988:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800398a:	f7fd fcf3 	bl	8001374 <HAL_GetTick>
 800398e:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8003990:	e00e      	b.n	80039b0 <HAL_RCC_OscConfig+0x24c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8003992:	f7fd fcef 	bl	8001374 <HAL_GetTick>
 8003996:	4602      	mov	r2, r0
 8003998:	693b      	ldr	r3, [r7, #16]
 800399a:	1ad3      	subs	r3, r2, r3
 800399c:	2b02      	cmp	r3, #2
 800399e:	d907      	bls.n	80039b0 <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
 80039a0:	2303      	movs	r3, #3
 80039a2:	e147      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
 80039a4:	40023800 	.word	0x40023800
 80039a8:	42470000 	.word	0x42470000
 80039ac:	42470e80 	.word	0x42470e80
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80039b0:	4b88      	ldr	r3, [pc, #544]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 80039b2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80039b4:	f003 0302 	and.w	r3, r3, #2
 80039b8:	2b00      	cmp	r3, #0
 80039ba:	d1ea      	bne.n	8003992 <HAL_RCC_OscConfig+0x22e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80039bc:	687b      	ldr	r3, [r7, #4]
 80039be:	681b      	ldr	r3, [r3, #0]
 80039c0:	f003 0304 	and.w	r3, r3, #4
 80039c4:	2b00      	cmp	r3, #0
 80039c6:	f000 8097 	beq.w	8003af8 <HAL_RCC_OscConfig+0x394>
  {
    FlagStatus       pwrclkchanged = RESET;
 80039ca:	2300      	movs	r3, #0
 80039cc:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80039ce:	4b81      	ldr	r3, [pc, #516]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 80039d0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80039d2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80039d6:	2b00      	cmp	r3, #0
 80039d8:	d10f      	bne.n	80039fa <HAL_RCC_OscConfig+0x296>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 80039da:	2300      	movs	r3, #0
 80039dc:	60bb      	str	r3, [r7, #8]
 80039de:	4b7d      	ldr	r3, [pc, #500]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 80039e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80039e2:	4a7c      	ldr	r2, [pc, #496]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 80039e4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80039e8:	6413      	str	r3, [r2, #64]	; 0x40
 80039ea:	4b7a      	ldr	r3, [pc, #488]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 80039ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80039ee:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80039f2:	60bb      	str	r3, [r7, #8]
 80039f4:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 80039f6:	2301      	movs	r3, #1
 80039f8:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80039fa:	4b77      	ldr	r3, [pc, #476]	; (8003bd8 <HAL_RCC_OscConfig+0x474>)
 80039fc:	681b      	ldr	r3, [r3, #0]
 80039fe:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8003a02:	2b00      	cmp	r3, #0
 8003a04:	d118      	bne.n	8003a38 <HAL_RCC_OscConfig+0x2d4>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8003a06:	4b74      	ldr	r3, [pc, #464]	; (8003bd8 <HAL_RCC_OscConfig+0x474>)
 8003a08:	681b      	ldr	r3, [r3, #0]
 8003a0a:	4a73      	ldr	r2, [pc, #460]	; (8003bd8 <HAL_RCC_OscConfig+0x474>)
 8003a0c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003a10:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8003a12:	f7fd fcaf 	bl	8001374 <HAL_GetTick>
 8003a16:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003a18:	e008      	b.n	8003a2c <HAL_RCC_OscConfig+0x2c8>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8003a1a:	f7fd fcab 	bl	8001374 <HAL_GetTick>
 8003a1e:	4602      	mov	r2, r0
 8003a20:	693b      	ldr	r3, [r7, #16]
 8003a22:	1ad3      	subs	r3, r2, r3
 8003a24:	2b02      	cmp	r3, #2
 8003a26:	d901      	bls.n	8003a2c <HAL_RCC_OscConfig+0x2c8>
        {
          return HAL_TIMEOUT;
 8003a28:	2303      	movs	r3, #3
 8003a2a:	e103      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8003a2c:	4b6a      	ldr	r3, [pc, #424]	; (8003bd8 <HAL_RCC_OscConfig+0x474>)
 8003a2e:	681b      	ldr	r3, [r3, #0]
 8003a30:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8003a34:	2b00      	cmp	r3, #0
 8003a36:	d0f0      	beq.n	8003a1a <HAL_RCC_OscConfig+0x2b6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003a38:	687b      	ldr	r3, [r7, #4]
 8003a3a:	689b      	ldr	r3, [r3, #8]
 8003a3c:	2b01      	cmp	r3, #1
 8003a3e:	d106      	bne.n	8003a4e <HAL_RCC_OscConfig+0x2ea>
 8003a40:	4b64      	ldr	r3, [pc, #400]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003a42:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003a44:	4a63      	ldr	r2, [pc, #396]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003a46:	f043 0301 	orr.w	r3, r3, #1
 8003a4a:	6713      	str	r3, [r2, #112]	; 0x70
 8003a4c:	e01c      	b.n	8003a88 <HAL_RCC_OscConfig+0x324>
 8003a4e:	687b      	ldr	r3, [r7, #4]
 8003a50:	689b      	ldr	r3, [r3, #8]
 8003a52:	2b05      	cmp	r3, #5
 8003a54:	d10c      	bne.n	8003a70 <HAL_RCC_OscConfig+0x30c>
 8003a56:	4b5f      	ldr	r3, [pc, #380]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003a58:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003a5a:	4a5e      	ldr	r2, [pc, #376]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003a5c:	f043 0304 	orr.w	r3, r3, #4
 8003a60:	6713      	str	r3, [r2, #112]	; 0x70
 8003a62:	4b5c      	ldr	r3, [pc, #368]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003a64:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003a66:	4a5b      	ldr	r2, [pc, #364]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003a68:	f043 0301 	orr.w	r3, r3, #1
 8003a6c:	6713      	str	r3, [r2, #112]	; 0x70
 8003a6e:	e00b      	b.n	8003a88 <HAL_RCC_OscConfig+0x324>
 8003a70:	4b58      	ldr	r3, [pc, #352]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003a72:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003a74:	4a57      	ldr	r2, [pc, #348]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003a76:	f023 0301 	bic.w	r3, r3, #1
 8003a7a:	6713      	str	r3, [r2, #112]	; 0x70
 8003a7c:	4b55      	ldr	r3, [pc, #340]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003a7e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003a80:	4a54      	ldr	r2, [pc, #336]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003a82:	f023 0304 	bic.w	r3, r3, #4
 8003a86:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8003a88:	687b      	ldr	r3, [r7, #4]
 8003a8a:	689b      	ldr	r3, [r3, #8]
 8003a8c:	2b00      	cmp	r3, #0
 8003a8e:	d015      	beq.n	8003abc <HAL_RCC_OscConfig+0x358>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8003a90:	f7fd fc70 	bl	8001374 <HAL_GetTick>
 8003a94:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8003a96:	e00a      	b.n	8003aae <HAL_RCC_OscConfig+0x34a>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003a98:	f7fd fc6c 	bl	8001374 <HAL_GetTick>
 8003a9c:	4602      	mov	r2, r0
 8003a9e:	693b      	ldr	r3, [r7, #16]
 8003aa0:	1ad3      	subs	r3, r2, r3
 8003aa2:	f241 3288 	movw	r2, #5000	; 0x1388
 8003aa6:	4293      	cmp	r3, r2
 8003aa8:	d901      	bls.n	8003aae <HAL_RCC_OscConfig+0x34a>
        {
          return HAL_TIMEOUT;
 8003aaa:	2303      	movs	r3, #3
 8003aac:	e0c2      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8003aae:	4b49      	ldr	r3, [pc, #292]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003ab0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003ab2:	f003 0302 	and.w	r3, r3, #2
 8003ab6:	2b00      	cmp	r3, #0
 8003ab8:	d0ee      	beq.n	8003a98 <HAL_RCC_OscConfig+0x334>
 8003aba:	e014      	b.n	8003ae6 <HAL_RCC_OscConfig+0x382>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 8003abc:	f7fd fc5a 	bl	8001374 <HAL_GetTick>
 8003ac0:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8003ac2:	e00a      	b.n	8003ada <HAL_RCC_OscConfig+0x376>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003ac4:	f7fd fc56 	bl	8001374 <HAL_GetTick>
 8003ac8:	4602      	mov	r2, r0
 8003aca:	693b      	ldr	r3, [r7, #16]
 8003acc:	1ad3      	subs	r3, r2, r3
 8003ace:	f241 3288 	movw	r2, #5000	; 0x1388
 8003ad2:	4293      	cmp	r3, r2
 8003ad4:	d901      	bls.n	8003ada <HAL_RCC_OscConfig+0x376>
        {
          return HAL_TIMEOUT;
 8003ad6:	2303      	movs	r3, #3
 8003ad8:	e0ac      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8003ada:	4b3e      	ldr	r3, [pc, #248]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003adc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003ade:	f003 0302 	and.w	r3, r3, #2
 8003ae2:	2b00      	cmp	r3, #0
 8003ae4:	d1ee      	bne.n	8003ac4 <HAL_RCC_OscConfig+0x360>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8003ae6:	7dfb      	ldrb	r3, [r7, #23]
 8003ae8:	2b01      	cmp	r3, #1
 8003aea:	d105      	bne.n	8003af8 <HAL_RCC_OscConfig+0x394>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8003aec:	4b39      	ldr	r3, [pc, #228]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003aee:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003af0:	4a38      	ldr	r2, [pc, #224]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003af2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003af6:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8003af8:	687b      	ldr	r3, [r7, #4]
 8003afa:	699b      	ldr	r3, [r3, #24]
 8003afc:	2b00      	cmp	r3, #0
 8003afe:	f000 8098 	beq.w	8003c32 <HAL_RCC_OscConfig+0x4ce>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8003b02:	4b34      	ldr	r3, [pc, #208]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003b04:	689b      	ldr	r3, [r3, #8]
 8003b06:	f003 030c 	and.w	r3, r3, #12
 8003b0a:	2b08      	cmp	r3, #8
 8003b0c:	d05c      	beq.n	8003bc8 <HAL_RCC_OscConfig+0x464>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8003b0e:	687b      	ldr	r3, [r7, #4]
 8003b10:	699b      	ldr	r3, [r3, #24]
 8003b12:	2b02      	cmp	r3, #2
 8003b14:	d141      	bne.n	8003b9a <HAL_RCC_OscConfig+0x436>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8003b16:	4b31      	ldr	r3, [pc, #196]	; (8003bdc <HAL_RCC_OscConfig+0x478>)
 8003b18:	2200      	movs	r2, #0
 8003b1a:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003b1c:	f7fd fc2a 	bl	8001374 <HAL_GetTick>
 8003b20:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003b22:	e008      	b.n	8003b36 <HAL_RCC_OscConfig+0x3d2>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003b24:	f7fd fc26 	bl	8001374 <HAL_GetTick>
 8003b28:	4602      	mov	r2, r0
 8003b2a:	693b      	ldr	r3, [r7, #16]
 8003b2c:	1ad3      	subs	r3, r2, r3
 8003b2e:	2b02      	cmp	r3, #2
 8003b30:	d901      	bls.n	8003b36 <HAL_RCC_OscConfig+0x3d2>
          {
            return HAL_TIMEOUT;
 8003b32:	2303      	movs	r3, #3
 8003b34:	e07e      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003b36:	4b27      	ldr	r3, [pc, #156]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003b38:	681b      	ldr	r3, [r3, #0]
 8003b3a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8003b3e:	2b00      	cmp	r3, #0
 8003b40:	d1f0      	bne.n	8003b24 <HAL_RCC_OscConfig+0x3c0>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8003b42:	687b      	ldr	r3, [r7, #4]
 8003b44:	69da      	ldr	r2, [r3, #28]
 8003b46:	687b      	ldr	r3, [r7, #4]
 8003b48:	6a1b      	ldr	r3, [r3, #32]
 8003b4a:	431a      	orrs	r2, r3
 8003b4c:	687b      	ldr	r3, [r7, #4]
 8003b4e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003b50:	019b      	lsls	r3, r3, #6
 8003b52:	431a      	orrs	r2, r3
 8003b54:	687b      	ldr	r3, [r7, #4]
 8003b56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003b58:	085b      	lsrs	r3, r3, #1
 8003b5a:	3b01      	subs	r3, #1
 8003b5c:	041b      	lsls	r3, r3, #16
 8003b5e:	431a      	orrs	r2, r3
 8003b60:	687b      	ldr	r3, [r7, #4]
 8003b62:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003b64:	061b      	lsls	r3, r3, #24
 8003b66:	491b      	ldr	r1, [pc, #108]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003b68:	4313      	orrs	r3, r2
 8003b6a:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8003b6c:	4b1b      	ldr	r3, [pc, #108]	; (8003bdc <HAL_RCC_OscConfig+0x478>)
 8003b6e:	2201      	movs	r2, #1
 8003b70:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003b72:	f7fd fbff 	bl	8001374 <HAL_GetTick>
 8003b76:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003b78:	e008      	b.n	8003b8c <HAL_RCC_OscConfig+0x428>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003b7a:	f7fd fbfb 	bl	8001374 <HAL_GetTick>
 8003b7e:	4602      	mov	r2, r0
 8003b80:	693b      	ldr	r3, [r7, #16]
 8003b82:	1ad3      	subs	r3, r2, r3
 8003b84:	2b02      	cmp	r3, #2
 8003b86:	d901      	bls.n	8003b8c <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
 8003b88:	2303      	movs	r3, #3
 8003b8a:	e053      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003b8c:	4b11      	ldr	r3, [pc, #68]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003b8e:	681b      	ldr	r3, [r3, #0]
 8003b90:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8003b94:	2b00      	cmp	r3, #0
 8003b96:	d0f0      	beq.n	8003b7a <HAL_RCC_OscConfig+0x416>
 8003b98:	e04b      	b.n	8003c32 <HAL_RCC_OscConfig+0x4ce>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8003b9a:	4b10      	ldr	r3, [pc, #64]	; (8003bdc <HAL_RCC_OscConfig+0x478>)
 8003b9c:	2200      	movs	r2, #0
 8003b9e:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 8003ba0:	f7fd fbe8 	bl	8001374 <HAL_GetTick>
 8003ba4:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003ba6:	e008      	b.n	8003bba <HAL_RCC_OscConfig+0x456>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003ba8:	f7fd fbe4 	bl	8001374 <HAL_GetTick>
 8003bac:	4602      	mov	r2, r0
 8003bae:	693b      	ldr	r3, [r7, #16]
 8003bb0:	1ad3      	subs	r3, r2, r3
 8003bb2:	2b02      	cmp	r3, #2
 8003bb4:	d901      	bls.n	8003bba <HAL_RCC_OscConfig+0x456>
          {
            return HAL_TIMEOUT;
 8003bb6:	2303      	movs	r3, #3
 8003bb8:	e03c      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8003bba:	4b06      	ldr	r3, [pc, #24]	; (8003bd4 <HAL_RCC_OscConfig+0x470>)
 8003bbc:	681b      	ldr	r3, [r3, #0]
 8003bbe:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8003bc2:	2b00      	cmp	r3, #0
 8003bc4:	d1f0      	bne.n	8003ba8 <HAL_RCC_OscConfig+0x444>
 8003bc6:	e034      	b.n	8003c32 <HAL_RCC_OscConfig+0x4ce>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8003bc8:	687b      	ldr	r3, [r7, #4]
 8003bca:	699b      	ldr	r3, [r3, #24]
 8003bcc:	2b01      	cmp	r3, #1
 8003bce:	d107      	bne.n	8003be0 <HAL_RCC_OscConfig+0x47c>
      {
        return HAL_ERROR;
 8003bd0:	2301      	movs	r3, #1
 8003bd2:	e02f      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
 8003bd4:	40023800 	.word	0x40023800
 8003bd8:	40007000 	.word	0x40007000
 8003bdc:	42470060 	.word	0x42470060
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR;
 8003be0:	4b16      	ldr	r3, [pc, #88]	; (8003c3c <HAL_RCC_OscConfig+0x4d8>)
 8003be2:	685b      	ldr	r3, [r3, #4]
 8003be4:	60fb      	str	r3, [r7, #12]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8003be6:	68fb      	ldr	r3, [r7, #12]
 8003be8:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
 8003bec:	687b      	ldr	r3, [r7, #4]
 8003bee:	69db      	ldr	r3, [r3, #28]
 8003bf0:	429a      	cmp	r2, r3
 8003bf2:	d11c      	bne.n	8003c2e <HAL_RCC_OscConfig+0x4ca>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8003bf4:	68fb      	ldr	r3, [r7, #12]
 8003bf6:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8003bfa:	687b      	ldr	r3, [r7, #4]
 8003bfc:	6a1b      	ldr	r3, [r3, #32]
        if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8003bfe:	429a      	cmp	r2, r3
 8003c00:	d115      	bne.n	8003c2e <HAL_RCC_OscConfig+0x4ca>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 8003c02:	68fa      	ldr	r2, [r7, #12]
 8003c04:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8003c08:	4013      	ands	r3, r2
 8003c0a:	687a      	ldr	r2, [r7, #4]
 8003c0c:	6a52      	ldr	r2, [r2, #36]	; 0x24
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
 8003c0e:	4293      	cmp	r3, r2
 8003c10:	d10d      	bne.n	8003c2e <HAL_RCC_OscConfig+0x4ca>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8003c12:	68fb      	ldr	r3, [r7, #12]
 8003c14:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 8003c18:	687b      	ldr	r3, [r7, #4]
 8003c1a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != RCC_OscInitStruct->PLL.PLLN) ||
 8003c1c:	429a      	cmp	r2, r3
 8003c1e:	d106      	bne.n	8003c2e <HAL_RCC_OscConfig+0x4ca>
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != RCC_OscInitStruct->PLL.PLLQ))
 8003c20:	68fb      	ldr	r3, [r7, #12]
 8003c22:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 8003c26:	687b      	ldr	r3, [r7, #4]
 8003c28:	6adb      	ldr	r3, [r3, #44]	; 0x2c
           (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != RCC_OscInitStruct->PLL.PLLP) ||
 8003c2a:	429a      	cmp	r2, r3
 8003c2c:	d001      	beq.n	8003c32 <HAL_RCC_OscConfig+0x4ce>
        {
          return HAL_ERROR;
 8003c2e:	2301      	movs	r3, #1
 8003c30:	e000      	b.n	8003c34 <HAL_RCC_OscConfig+0x4d0>
        }
      }
    }
  }
  return HAL_OK;
 8003c32:	2300      	movs	r3, #0
}
 8003c34:	4618      	mov	r0, r3
 8003c36:	3718      	adds	r7, #24
 8003c38:	46bd      	mov	sp, r7
 8003c3a:	bd80      	pop	{r7, pc}
 8003c3c:	40023800 	.word	0x40023800

08003c40 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8003c40:	b580      	push	{r7, lr}
 8003c42:	b084      	sub	sp, #16
 8003c44:	af00      	add	r7, sp, #0
 8003c46:	6078      	str	r0, [r7, #4]
 8003c48:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 8003c4a:	687b      	ldr	r3, [r7, #4]
 8003c4c:	2b00      	cmp	r3, #0
 8003c4e:	d101      	bne.n	8003c54 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8003c50:	2301      	movs	r3, #1
 8003c52:	e0cc      	b.n	8003dee <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8003c54:	4b68      	ldr	r3, [pc, #416]	; (8003df8 <HAL_RCC_ClockConfig+0x1b8>)
 8003c56:	681b      	ldr	r3, [r3, #0]
 8003c58:	f003 030f 	and.w	r3, r3, #15
 8003c5c:	683a      	ldr	r2, [r7, #0]
 8003c5e:	429a      	cmp	r2, r3
 8003c60:	d90c      	bls.n	8003c7c <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003c62:	4b65      	ldr	r3, [pc, #404]	; (8003df8 <HAL_RCC_ClockConfig+0x1b8>)
 8003c64:	683a      	ldr	r2, [r7, #0]
 8003c66:	b2d2      	uxtb	r2, r2
 8003c68:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8003c6a:	4b63      	ldr	r3, [pc, #396]	; (8003df8 <HAL_RCC_ClockConfig+0x1b8>)
 8003c6c:	681b      	ldr	r3, [r3, #0]
 8003c6e:	f003 030f 	and.w	r3, r3, #15
 8003c72:	683a      	ldr	r2, [r7, #0]
 8003c74:	429a      	cmp	r2, r3
 8003c76:	d001      	beq.n	8003c7c <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 8003c78:	2301      	movs	r3, #1
 8003c7a:	e0b8      	b.n	8003dee <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003c7c:	687b      	ldr	r3, [r7, #4]
 8003c7e:	681b      	ldr	r3, [r3, #0]
 8003c80:	f003 0302 	and.w	r3, r3, #2
 8003c84:	2b00      	cmp	r3, #0
 8003c86:	d020      	beq.n	8003cca <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003c88:	687b      	ldr	r3, [r7, #4]
 8003c8a:	681b      	ldr	r3, [r3, #0]
 8003c8c:	f003 0304 	and.w	r3, r3, #4
 8003c90:	2b00      	cmp	r3, #0
 8003c92:	d005      	beq.n	8003ca0 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8003c94:	4b59      	ldr	r3, [pc, #356]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003c96:	689b      	ldr	r3, [r3, #8]
 8003c98:	4a58      	ldr	r2, [pc, #352]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003c9a:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 8003c9e:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003ca0:	687b      	ldr	r3, [r7, #4]
 8003ca2:	681b      	ldr	r3, [r3, #0]
 8003ca4:	f003 0308 	and.w	r3, r3, #8
 8003ca8:	2b00      	cmp	r3, #0
 8003caa:	d005      	beq.n	8003cb8 <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8003cac:	4b53      	ldr	r3, [pc, #332]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003cae:	689b      	ldr	r3, [r3, #8]
 8003cb0:	4a52      	ldr	r2, [pc, #328]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003cb2:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 8003cb6:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8003cb8:	4b50      	ldr	r3, [pc, #320]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003cba:	689b      	ldr	r3, [r3, #8]
 8003cbc:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8003cc0:	687b      	ldr	r3, [r7, #4]
 8003cc2:	689b      	ldr	r3, [r3, #8]
 8003cc4:	494d      	ldr	r1, [pc, #308]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003cc6:	4313      	orrs	r3, r2
 8003cc8:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8003cca:	687b      	ldr	r3, [r7, #4]
 8003ccc:	681b      	ldr	r3, [r3, #0]
 8003cce:	f003 0301 	and.w	r3, r3, #1
 8003cd2:	2b00      	cmp	r3, #0
 8003cd4:	d044      	beq.n	8003d60 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8003cd6:	687b      	ldr	r3, [r7, #4]
 8003cd8:	685b      	ldr	r3, [r3, #4]
 8003cda:	2b01      	cmp	r3, #1
 8003cdc:	d107      	bne.n	8003cee <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8003cde:	4b47      	ldr	r3, [pc, #284]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003ce0:	681b      	ldr	r3, [r3, #0]
 8003ce2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003ce6:	2b00      	cmp	r3, #0
 8003ce8:	d119      	bne.n	8003d1e <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8003cea:	2301      	movs	r3, #1
 8003cec:	e07f      	b.n	8003dee <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8003cee:	687b      	ldr	r3, [r7, #4]
 8003cf0:	685b      	ldr	r3, [r3, #4]
 8003cf2:	2b02      	cmp	r3, #2
 8003cf4:	d003      	beq.n	8003cfe <HAL_RCC_ClockConfig+0xbe>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 8003cf6:	687b      	ldr	r3, [r7, #4]
 8003cf8:	685b      	ldr	r3, [r3, #4]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 8003cfa:	2b03      	cmp	r3, #3
 8003cfc:	d107      	bne.n	8003d0e <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003cfe:	4b3f      	ldr	r3, [pc, #252]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003d00:	681b      	ldr	r3, [r3, #0]
 8003d02:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8003d06:	2b00      	cmp	r3, #0
 8003d08:	d109      	bne.n	8003d1e <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8003d0a:	2301      	movs	r3, #1
 8003d0c:	e06f      	b.n	8003dee <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8003d0e:	4b3b      	ldr	r3, [pc, #236]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003d10:	681b      	ldr	r3, [r3, #0]
 8003d12:	f003 0302 	and.w	r3, r3, #2
 8003d16:	2b00      	cmp	r3, #0
 8003d18:	d101      	bne.n	8003d1e <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 8003d1a:	2301      	movs	r3, #1
 8003d1c:	e067      	b.n	8003dee <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8003d1e:	4b37      	ldr	r3, [pc, #220]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003d20:	689b      	ldr	r3, [r3, #8]
 8003d22:	f023 0203 	bic.w	r2, r3, #3
 8003d26:	687b      	ldr	r3, [r7, #4]
 8003d28:	685b      	ldr	r3, [r3, #4]
 8003d2a:	4934      	ldr	r1, [pc, #208]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003d2c:	4313      	orrs	r3, r2
 8003d2e:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 8003d30:	f7fd fb20 	bl	8001374 <HAL_GetTick>
 8003d34:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8003d36:	e00a      	b.n	8003d4e <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003d38:	f7fd fb1c 	bl	8001374 <HAL_GetTick>
 8003d3c:	4602      	mov	r2, r0
 8003d3e:	68fb      	ldr	r3, [r7, #12]
 8003d40:	1ad3      	subs	r3, r2, r3
 8003d42:	f241 3288 	movw	r2, #5000	; 0x1388
 8003d46:	4293      	cmp	r3, r2
 8003d48:	d901      	bls.n	8003d4e <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 8003d4a:	2303      	movs	r3, #3
 8003d4c:	e04f      	b.n	8003dee <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8003d4e:	4b2b      	ldr	r3, [pc, #172]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003d50:	689b      	ldr	r3, [r3, #8]
 8003d52:	f003 020c 	and.w	r2, r3, #12
 8003d56:	687b      	ldr	r3, [r7, #4]
 8003d58:	685b      	ldr	r3, [r3, #4]
 8003d5a:	009b      	lsls	r3, r3, #2
 8003d5c:	429a      	cmp	r2, r3
 8003d5e:	d1eb      	bne.n	8003d38 <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8003d60:	4b25      	ldr	r3, [pc, #148]	; (8003df8 <HAL_RCC_ClockConfig+0x1b8>)
 8003d62:	681b      	ldr	r3, [r3, #0]
 8003d64:	f003 030f 	and.w	r3, r3, #15
 8003d68:	683a      	ldr	r2, [r7, #0]
 8003d6a:	429a      	cmp	r2, r3
 8003d6c:	d20c      	bcs.n	8003d88 <HAL_RCC_ClockConfig+0x148>
  {
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003d6e:	4b22      	ldr	r3, [pc, #136]	; (8003df8 <HAL_RCC_ClockConfig+0x1b8>)
 8003d70:	683a      	ldr	r2, [r7, #0]
 8003d72:	b2d2      	uxtb	r2, r2
 8003d74:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8003d76:	4b20      	ldr	r3, [pc, #128]	; (8003df8 <HAL_RCC_ClockConfig+0x1b8>)
 8003d78:	681b      	ldr	r3, [r3, #0]
 8003d7a:	f003 030f 	and.w	r3, r3, #15
 8003d7e:	683a      	ldr	r2, [r7, #0]
 8003d80:	429a      	cmp	r2, r3
 8003d82:	d001      	beq.n	8003d88 <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 8003d84:	2301      	movs	r3, #1
 8003d86:	e032      	b.n	8003dee <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003d88:	687b      	ldr	r3, [r7, #4]
 8003d8a:	681b      	ldr	r3, [r3, #0]
 8003d8c:	f003 0304 	and.w	r3, r3, #4
 8003d90:	2b00      	cmp	r3, #0
 8003d92:	d008      	beq.n	8003da6 <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8003d94:	4b19      	ldr	r3, [pc, #100]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003d96:	689b      	ldr	r3, [r3, #8]
 8003d98:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8003d9c:	687b      	ldr	r3, [r7, #4]
 8003d9e:	68db      	ldr	r3, [r3, #12]
 8003da0:	4916      	ldr	r1, [pc, #88]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003da2:	4313      	orrs	r3, r2
 8003da4:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003da6:	687b      	ldr	r3, [r7, #4]
 8003da8:	681b      	ldr	r3, [r3, #0]
 8003daa:	f003 0308 	and.w	r3, r3, #8
 8003dae:	2b00      	cmp	r3, #0
 8003db0:	d009      	beq.n	8003dc6 <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8003db2:	4b12      	ldr	r3, [pc, #72]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003db4:	689b      	ldr	r3, [r3, #8]
 8003db6:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 8003dba:	687b      	ldr	r3, [r7, #4]
 8003dbc:	691b      	ldr	r3, [r3, #16]
 8003dbe:	00db      	lsls	r3, r3, #3
 8003dc0:	490e      	ldr	r1, [pc, #56]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003dc2:	4313      	orrs	r3, r2
 8003dc4:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 8003dc6:	f000 f821 	bl	8003e0c <HAL_RCC_GetSysClockFreq>
 8003dca:	4602      	mov	r2, r0
 8003dcc:	4b0b      	ldr	r3, [pc, #44]	; (8003dfc <HAL_RCC_ClockConfig+0x1bc>)
 8003dce:	689b      	ldr	r3, [r3, #8]
 8003dd0:	091b      	lsrs	r3, r3, #4
 8003dd2:	f003 030f 	and.w	r3, r3, #15
 8003dd6:	490a      	ldr	r1, [pc, #40]	; (8003e00 <HAL_RCC_ClockConfig+0x1c0>)
 8003dd8:	5ccb      	ldrb	r3, [r1, r3]
 8003dda:	fa22 f303 	lsr.w	r3, r2, r3
 8003dde:	4a09      	ldr	r2, [pc, #36]	; (8003e04 <HAL_RCC_ClockConfig+0x1c4>)
 8003de0:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (uwTickPrio);
 8003de2:	4b09      	ldr	r3, [pc, #36]	; (8003e08 <HAL_RCC_ClockConfig+0x1c8>)
 8003de4:	681b      	ldr	r3, [r3, #0]
 8003de6:	4618      	mov	r0, r3
 8003de8:	f7fd fa80 	bl	80012ec <HAL_InitTick>

  return HAL_OK;
 8003dec:	2300      	movs	r3, #0
}
 8003dee:	4618      	mov	r0, r3
 8003df0:	3710      	adds	r7, #16
 8003df2:	46bd      	mov	sp, r7
 8003df4:	bd80      	pop	{r7, pc}
 8003df6:	bf00      	nop
 8003df8:	40023c00 	.word	0x40023c00
 8003dfc:	40023800 	.word	0x40023800
 8003e00:	0802e62c 	.word	0x0802e62c
 8003e04:	20000008 	.word	0x20000008
 8003e08:	2000000c 	.word	0x2000000c

08003e0c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8003e0c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8003e10:	b090      	sub	sp, #64	; 0x40
 8003e12:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
 8003e14:	2300      	movs	r3, #0
 8003e16:	637b      	str	r3, [r7, #52]	; 0x34
 8003e18:	2300      	movs	r3, #0
 8003e1a:	63fb      	str	r3, [r7, #60]	; 0x3c
 8003e1c:	2300      	movs	r3, #0
 8003e1e:	633b      	str	r3, [r7, #48]	; 0x30
  uint32_t sysclockfreq = 0U;
 8003e20:	2300      	movs	r3, #0
 8003e22:	63bb      	str	r3, [r7, #56]	; 0x38

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8003e24:	4b59      	ldr	r3, [pc, #356]	; (8003f8c <HAL_RCC_GetSysClockFreq+0x180>)
 8003e26:	689b      	ldr	r3, [r3, #8]
 8003e28:	f003 030c 	and.w	r3, r3, #12
 8003e2c:	2b08      	cmp	r3, #8
 8003e2e:	d00d      	beq.n	8003e4c <HAL_RCC_GetSysClockFreq+0x40>
 8003e30:	2b08      	cmp	r3, #8
 8003e32:	f200 80a1 	bhi.w	8003f78 <HAL_RCC_GetSysClockFreq+0x16c>
 8003e36:	2b00      	cmp	r3, #0
 8003e38:	d002      	beq.n	8003e40 <HAL_RCC_GetSysClockFreq+0x34>
 8003e3a:	2b04      	cmp	r3, #4
 8003e3c:	d003      	beq.n	8003e46 <HAL_RCC_GetSysClockFreq+0x3a>
 8003e3e:	e09b      	b.n	8003f78 <HAL_RCC_GetSysClockFreq+0x16c>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8003e40:	4b53      	ldr	r3, [pc, #332]	; (8003f90 <HAL_RCC_GetSysClockFreq+0x184>)
 8003e42:	63bb      	str	r3, [r7, #56]	; 0x38
       break;
 8003e44:	e09b      	b.n	8003f7e <HAL_RCC_GetSysClockFreq+0x172>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8003e46:	4b53      	ldr	r3, [pc, #332]	; (8003f94 <HAL_RCC_GetSysClockFreq+0x188>)
 8003e48:	63bb      	str	r3, [r7, #56]	; 0x38
      break;
 8003e4a:	e098      	b.n	8003f7e <HAL_RCC_GetSysClockFreq+0x172>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8003e4c:	4b4f      	ldr	r3, [pc, #316]	; (8003f8c <HAL_RCC_GetSysClockFreq+0x180>)
 8003e4e:	685b      	ldr	r3, [r3, #4]
 8003e50:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8003e54:	637b      	str	r3, [r7, #52]	; 0x34
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8003e56:	4b4d      	ldr	r3, [pc, #308]	; (8003f8c <HAL_RCC_GetSysClockFreq+0x180>)
 8003e58:	685b      	ldr	r3, [r3, #4]
 8003e5a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8003e5e:	2b00      	cmp	r3, #0
 8003e60:	d028      	beq.n	8003eb4 <HAL_RCC_GetSysClockFreq+0xa8>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003e62:	4b4a      	ldr	r3, [pc, #296]	; (8003f8c <HAL_RCC_GetSysClockFreq+0x180>)
 8003e64:	685b      	ldr	r3, [r3, #4]
 8003e66:	099b      	lsrs	r3, r3, #6
 8003e68:	2200      	movs	r2, #0
 8003e6a:	623b      	str	r3, [r7, #32]
 8003e6c:	627a      	str	r2, [r7, #36]	; 0x24
 8003e6e:	6a3b      	ldr	r3, [r7, #32]
 8003e70:	f3c3 0008 	ubfx	r0, r3, #0, #9
 8003e74:	2100      	movs	r1, #0
 8003e76:	4b47      	ldr	r3, [pc, #284]	; (8003f94 <HAL_RCC_GetSysClockFreq+0x188>)
 8003e78:	fb03 f201 	mul.w	r2, r3, r1
 8003e7c:	2300      	movs	r3, #0
 8003e7e:	fb00 f303 	mul.w	r3, r0, r3
 8003e82:	4413      	add	r3, r2
 8003e84:	4a43      	ldr	r2, [pc, #268]	; (8003f94 <HAL_RCC_GetSysClockFreq+0x188>)
 8003e86:	fba0 1202 	umull	r1, r2, r0, r2
 8003e8a:	62fa      	str	r2, [r7, #44]	; 0x2c
 8003e8c:	460a      	mov	r2, r1
 8003e8e:	62ba      	str	r2, [r7, #40]	; 0x28
 8003e90:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8003e92:	4413      	add	r3, r2
 8003e94:	62fb      	str	r3, [r7, #44]	; 0x2c
 8003e96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003e98:	2200      	movs	r2, #0
 8003e9a:	61bb      	str	r3, [r7, #24]
 8003e9c:	61fa      	str	r2, [r7, #28]
 8003e9e:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 8003ea2:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	; 0x28
 8003ea6:	f7fc f9b3 	bl	8000210 <__aeabi_uldivmod>
 8003eaa:	4602      	mov	r2, r0
 8003eac:	460b      	mov	r3, r1
 8003eae:	4613      	mov	r3, r2
 8003eb0:	63fb      	str	r3, [r7, #60]	; 0x3c
 8003eb2:	e053      	b.n	8003f5c <HAL_RCC_GetSysClockFreq+0x150>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8003eb4:	4b35      	ldr	r3, [pc, #212]	; (8003f8c <HAL_RCC_GetSysClockFreq+0x180>)
 8003eb6:	685b      	ldr	r3, [r3, #4]
 8003eb8:	099b      	lsrs	r3, r3, #6
 8003eba:	2200      	movs	r2, #0
 8003ebc:	613b      	str	r3, [r7, #16]
 8003ebe:	617a      	str	r2, [r7, #20]
 8003ec0:	693b      	ldr	r3, [r7, #16]
 8003ec2:	f3c3 0a08 	ubfx	sl, r3, #0, #9
 8003ec6:	f04f 0b00 	mov.w	fp, #0
 8003eca:	4652      	mov	r2, sl
 8003ecc:	465b      	mov	r3, fp
 8003ece:	f04f 0000 	mov.w	r0, #0
 8003ed2:	f04f 0100 	mov.w	r1, #0
 8003ed6:	0159      	lsls	r1, r3, #5
 8003ed8:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 8003edc:	0150      	lsls	r0, r2, #5
 8003ede:	4602      	mov	r2, r0
 8003ee0:	460b      	mov	r3, r1
 8003ee2:	ebb2 080a 	subs.w	r8, r2, sl
 8003ee6:	eb63 090b 	sbc.w	r9, r3, fp
 8003eea:	f04f 0200 	mov.w	r2, #0
 8003eee:	f04f 0300 	mov.w	r3, #0
 8003ef2:	ea4f 1389 	mov.w	r3, r9, lsl #6
 8003ef6:	ea43 6398 	orr.w	r3, r3, r8, lsr #26
 8003efa:	ea4f 1288 	mov.w	r2, r8, lsl #6
 8003efe:	ebb2 0408 	subs.w	r4, r2, r8
 8003f02:	eb63 0509 	sbc.w	r5, r3, r9
 8003f06:	f04f 0200 	mov.w	r2, #0
 8003f0a:	f04f 0300 	mov.w	r3, #0
 8003f0e:	00eb      	lsls	r3, r5, #3
 8003f10:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 8003f14:	00e2      	lsls	r2, r4, #3
 8003f16:	4614      	mov	r4, r2
 8003f18:	461d      	mov	r5, r3
 8003f1a:	eb14 030a 	adds.w	r3, r4, sl
 8003f1e:	603b      	str	r3, [r7, #0]
 8003f20:	eb45 030b 	adc.w	r3, r5, fp
 8003f24:	607b      	str	r3, [r7, #4]
 8003f26:	f04f 0200 	mov.w	r2, #0
 8003f2a:	f04f 0300 	mov.w	r3, #0
 8003f2e:	e9d7 4500 	ldrd	r4, r5, [r7]
 8003f32:	4629      	mov	r1, r5
 8003f34:	028b      	lsls	r3, r1, #10
 8003f36:	4621      	mov	r1, r4
 8003f38:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
 8003f3c:	4621      	mov	r1, r4
 8003f3e:	028a      	lsls	r2, r1, #10
 8003f40:	4610      	mov	r0, r2
 8003f42:	4619      	mov	r1, r3
 8003f44:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8003f46:	2200      	movs	r2, #0
 8003f48:	60bb      	str	r3, [r7, #8]
 8003f4a:	60fa      	str	r2, [r7, #12]
 8003f4c:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8003f50:	f7fc f95e 	bl	8000210 <__aeabi_uldivmod>
 8003f54:	4602      	mov	r2, r0
 8003f56:	460b      	mov	r3, r1
 8003f58:	4613      	mov	r3, r2
 8003f5a:	63fb      	str	r3, [r7, #60]	; 0x3c
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 8003f5c:	4b0b      	ldr	r3, [pc, #44]	; (8003f8c <HAL_RCC_GetSysClockFreq+0x180>)
 8003f5e:	685b      	ldr	r3, [r3, #4]
 8003f60:	0c1b      	lsrs	r3, r3, #16
 8003f62:	f003 0303 	and.w	r3, r3, #3
 8003f66:	3301      	adds	r3, #1
 8003f68:	005b      	lsls	r3, r3, #1
 8003f6a:	633b      	str	r3, [r7, #48]	; 0x30

      sysclockfreq = pllvco/pllp;
 8003f6c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8003f6e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8003f70:	fbb2 f3f3 	udiv	r3, r2, r3
 8003f74:	63bb      	str	r3, [r7, #56]	; 0x38
      break;
 8003f76:	e002      	b.n	8003f7e <HAL_RCC_GetSysClockFreq+0x172>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 8003f78:	4b05      	ldr	r3, [pc, #20]	; (8003f90 <HAL_RCC_GetSysClockFreq+0x184>)
 8003f7a:	63bb      	str	r3, [r7, #56]	; 0x38
      break;
 8003f7c:	bf00      	nop
    }
  }
  return sysclockfreq;
 8003f7e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
 8003f80:	4618      	mov	r0, r3
 8003f82:	3740      	adds	r7, #64	; 0x40
 8003f84:	46bd      	mov	sp, r7
 8003f86:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8003f8a:	bf00      	nop
 8003f8c:	40023800 	.word	0x40023800
 8003f90:	00f42400 	.word	0x00f42400
 8003f94:	017d7840 	.word	0x017d7840

08003f98 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8003f98:	b480      	push	{r7}
 8003f9a:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8003f9c:	4b03      	ldr	r3, [pc, #12]	; (8003fac <HAL_RCC_GetHCLKFreq+0x14>)
 8003f9e:	681b      	ldr	r3, [r3, #0]
}
 8003fa0:	4618      	mov	r0, r3
 8003fa2:	46bd      	mov	sp, r7
 8003fa4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003fa8:	4770      	bx	lr
 8003faa:	bf00      	nop
 8003fac:	20000008 	.word	0x20000008

08003fb0 <HAL_RCC_NMI_IRQHandler>:
  * @brief This function handles the RCC CSS interrupt request.
  * @note This API should be called under the NMI_Handler().
  * @retval None
  */
void HAL_RCC_NMI_IRQHandler(void)
{
 8003fb0:	b580      	push	{r7, lr}
 8003fb2:	af00      	add	r7, sp, #0
  /* Check RCC CSSF flag  */
  if(__HAL_RCC_GET_IT(RCC_IT_CSS))
 8003fb4:	4b06      	ldr	r3, [pc, #24]	; (8003fd0 <HAL_RCC_NMI_IRQHandler+0x20>)
 8003fb6:	68db      	ldr	r3, [r3, #12]
 8003fb8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003fbc:	2b80      	cmp	r3, #128	; 0x80
 8003fbe:	d104      	bne.n	8003fca <HAL_RCC_NMI_IRQHandler+0x1a>
  {
    /* RCC Clock Security System interrupt user callback */
    HAL_RCC_CSSCallback();
 8003fc0:	f000 f80a 	bl	8003fd8 <HAL_RCC_CSSCallback>

    /* Clear RCC CSS pending bit */
    __HAL_RCC_CLEAR_IT(RCC_IT_CSS);
 8003fc4:	4b03      	ldr	r3, [pc, #12]	; (8003fd4 <HAL_RCC_NMI_IRQHandler+0x24>)
 8003fc6:	2280      	movs	r2, #128	; 0x80
 8003fc8:	701a      	strb	r2, [r3, #0]
  }
}
 8003fca:	bf00      	nop
 8003fcc:	bd80      	pop	{r7, pc}
 8003fce:	bf00      	nop
 8003fd0:	40023800 	.word	0x40023800
 8003fd4:	4002380e 	.word	0x4002380e

08003fd8 <HAL_RCC_CSSCallback>:
/**
  * @brief  RCC Clock Security System interrupt callback
  * @retval None
  */
__weak void HAL_RCC_CSSCallback(void)
{
 8003fd8:	b480      	push	{r7}
 8003fda:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_RCC_CSSCallback could be implemented in the user file
   */
}
 8003fdc:	bf00      	nop
 8003fde:	46bd      	mov	sp, r7
 8003fe0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003fe4:	4770      	bx	lr
	...

08003fe8 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8003fe8:	b580      	push	{r7, lr}
 8003fea:	b086      	sub	sp, #24
 8003fec:	af00      	add	r7, sp, #0
 8003fee:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8003ff0:	2300      	movs	r3, #0
 8003ff2:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg1 = 0U;
 8003ff4:	2300      	movs	r3, #0
 8003ff6:	613b      	str	r3, [r7, #16]

  /*----------------------- SAI/I2S Configuration (PLLI2S) -------------------*/
  /*----------------------- Common configuration SAI/I2S ---------------------*/
  /* In Case of SAI or I2S Clock Configuration through PLLI2S, PLLI2SN division
     factor is common parameters for both peripherals */
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 8003ff8:	687b      	ldr	r3, [r7, #4]
 8003ffa:	681b      	ldr	r3, [r3, #0]
 8003ffc:	f003 0301 	and.w	r3, r3, #1
 8004000:	2b00      	cmp	r3, #0
 8004002:	d10b      	bne.n	800401c <HAL_RCCEx_PeriphCLKConfig+0x34>
     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == RCC_PERIPHCLK_SAI_PLLI2S) ||
 8004004:	687b      	ldr	r3, [r7, #4]
 8004006:	681b      	ldr	r3, [r3, #0]
 8004008:	f003 0302 	and.w	r3, r3, #2
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 800400c:	2b00      	cmp	r3, #0
 800400e:	d105      	bne.n	800401c <HAL_RCCEx_PeriphCLKConfig+0x34>
     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 8004010:	687b      	ldr	r3, [r7, #4]
 8004012:	681b      	ldr	r3, [r3, #0]
 8004014:	f003 0340 	and.w	r3, r3, #64	; 0x40
     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == RCC_PERIPHCLK_SAI_PLLI2S) ||
 8004018:	2b00      	cmp	r3, #0
 800401a:	d075      	beq.n	8004108 <HAL_RCCEx_PeriphCLKConfig+0x120>
  {
    /* check for Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));

    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 800401c:	4b91      	ldr	r3, [pc, #580]	; (8004264 <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 800401e:	2200      	movs	r2, #0
 8004020:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8004022:	f7fd f9a7 	bl	8001374 <HAL_GetTick>
 8004026:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8004028:	e008      	b.n	800403c <HAL_RCCEx_PeriphCLKConfig+0x54>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 800402a:	f7fd f9a3 	bl	8001374 <HAL_GetTick>
 800402e:	4602      	mov	r2, r0
 8004030:	697b      	ldr	r3, [r7, #20]
 8004032:	1ad3      	subs	r3, r2, r3
 8004034:	2b02      	cmp	r3, #2
 8004036:	d901      	bls.n	800403c <HAL_RCCEx_PeriphCLKConfig+0x54>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8004038:	2303      	movs	r3, #3
 800403a:	e189      	b.n	8004350 <HAL_RCCEx_PeriphCLKConfig+0x368>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800403c:	4b8a      	ldr	r3, [pc, #552]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800403e:	681b      	ldr	r3, [r3, #0]
 8004040:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8004044:	2b00      	cmp	r3, #0
 8004046:	d1f0      	bne.n	800402a <HAL_RCCEx_PeriphCLKConfig+0x42>
    }

    /*---------------------------- I2S configuration -------------------------*/
    /* In Case of I2S Clock Configuration through PLLI2S, PLLI2SR must be added
      only for I2S configuration */
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8004048:	687b      	ldr	r3, [r7, #4]
 800404a:	681b      	ldr	r3, [r3, #0]
 800404c:	f003 0301 	and.w	r3, r3, #1
 8004050:	2b00      	cmp	r3, #0
 8004052:	d009      	beq.n	8004068 <HAL_RCCEx_PeriphCLKConfig+0x80>
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 8004054:	687b      	ldr	r3, [r7, #4]
 8004056:	685b      	ldr	r3, [r3, #4]
 8004058:	019a      	lsls	r2, r3, #6
 800405a:	687b      	ldr	r3, [r7, #4]
 800405c:	689b      	ldr	r3, [r3, #8]
 800405e:	071b      	lsls	r3, r3, #28
 8004060:	4981      	ldr	r1, [pc, #516]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8004062:	4313      	orrs	r3, r2
 8004064:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*---------------------------- SAI configuration -------------------------*/
    /* In Case of SAI Clock Configuration through PLLI2S, PLLI2SQ and PLLI2S_DIVQ must
       be added only for SAI configuration */
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == (RCC_PERIPHCLK_SAI_PLLI2S))
 8004068:	687b      	ldr	r3, [r7, #4]
 800406a:	681b      	ldr	r3, [r3, #0]
 800406c:	f003 0302 	and.w	r3, r3, #2
 8004070:	2b00      	cmp	r3, #0
 8004072:	d01f      	beq.n	80040b4 <HAL_RCCEx_PeriphCLKConfig+0xcc>
      /* Check the PLLI2S division factors */
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));

      /* Read PLLI2SR value from PLLI2SCFGR register (this value is not need for SAI configuration) */
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 8004074:	4b7c      	ldr	r3, [pc, #496]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8004076:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800407a:	0f1b      	lsrs	r3, r3, #28
 800407c:	f003 0307 	and.w	r3, r3, #7
 8004080:	613b      	str	r3, [r7, #16]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
      __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ , tmpreg1);
 8004082:	687b      	ldr	r3, [r7, #4]
 8004084:	685b      	ldr	r3, [r3, #4]
 8004086:	019a      	lsls	r2, r3, #6
 8004088:	687b      	ldr	r3, [r7, #4]
 800408a:	68db      	ldr	r3, [r3, #12]
 800408c:	061b      	lsls	r3, r3, #24
 800408e:	431a      	orrs	r2, r3
 8004090:	693b      	ldr	r3, [r7, #16]
 8004092:	071b      	lsls	r3, r3, #28
 8004094:	4974      	ldr	r1, [pc, #464]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8004096:	4313      	orrs	r3, r2
 8004098:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 800409c:	4b72      	ldr	r3, [pc, #456]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800409e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80040a2:	f023 021f 	bic.w	r2, r3, #31
 80040a6:	687b      	ldr	r3, [r7, #4]
 80040a8:	69db      	ldr	r3, [r3, #28]
 80040aa:	3b01      	subs	r3, #1
 80040ac:	496e      	ldr	r1, [pc, #440]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 80040ae:	4313      	orrs	r3, r2
 80040b0:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLI2S is just selected  -----------------*/
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 80040b4:	687b      	ldr	r3, [r7, #4]
 80040b6:	681b      	ldr	r3, [r3, #0]
 80040b8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80040bc:	2b00      	cmp	r3, #0
 80040be:	d00d      	beq.n	80040dc <HAL_RCCEx_PeriphCLKConfig+0xf4>
      /* Check for Parameters */
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));

      /* Configure the PLLI2S multiplication and division factors */
      __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 80040c0:	687b      	ldr	r3, [r7, #4]
 80040c2:	685b      	ldr	r3, [r3, #4]
 80040c4:	019a      	lsls	r2, r3, #6
 80040c6:	687b      	ldr	r3, [r7, #4]
 80040c8:	68db      	ldr	r3, [r3, #12]
 80040ca:	061b      	lsls	r3, r3, #24
 80040cc:	431a      	orrs	r2, r3
 80040ce:	687b      	ldr	r3, [r7, #4]
 80040d0:	689b      	ldr	r3, [r3, #8]
 80040d2:	071b      	lsls	r3, r3, #28
 80040d4:	4964      	ldr	r1, [pc, #400]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 80040d6:	4313      	orrs	r3, r2
 80040d8:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 80040dc:	4b61      	ldr	r3, [pc, #388]	; (8004264 <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 80040de:	2201      	movs	r2, #1
 80040e0:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 80040e2:	f7fd f947 	bl	8001374 <HAL_GetTick>
 80040e6:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80040e8:	e008      	b.n	80040fc <HAL_RCCEx_PeriphCLKConfig+0x114>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 80040ea:	f7fd f943 	bl	8001374 <HAL_GetTick>
 80040ee:	4602      	mov	r2, r0
 80040f0:	697b      	ldr	r3, [r7, #20]
 80040f2:	1ad3      	subs	r3, r2, r3
 80040f4:	2b02      	cmp	r3, #2
 80040f6:	d901      	bls.n	80040fc <HAL_RCCEx_PeriphCLKConfig+0x114>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 80040f8:	2303      	movs	r3, #3
 80040fa:	e129      	b.n	8004350 <HAL_RCCEx_PeriphCLKConfig+0x368>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80040fc:	4b5a      	ldr	r3, [pc, #360]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 80040fe:	681b      	ldr	r3, [r3, #0]
 8004100:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8004104:	2b00      	cmp	r3, #0
 8004106:	d0f0      	beq.n	80040ea <HAL_RCCEx_PeriphCLKConfig+0x102>

  /*----------------------- SAI/LTDC Configuration (PLLSAI) ------------------*/
  /*----------------------- Common configuration SAI/LTDC --------------------*/
  /* In Case of SAI or LTDC Clock Configuration through PLLSAI, PLLSAIN division
     factor is common parameters for both peripherals */
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == RCC_PERIPHCLK_SAI_PLLSAI) ||
 8004108:	687b      	ldr	r3, [r7, #4]
 800410a:	681b      	ldr	r3, [r3, #0]
 800410c:	f003 0304 	and.w	r3, r3, #4
 8004110:	2b00      	cmp	r3, #0
 8004112:	d105      	bne.n	8004120 <HAL_RCCEx_PeriphCLKConfig+0x138>
     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC))
 8004114:	687b      	ldr	r3, [r7, #4]
 8004116:	681b      	ldr	r3, [r3, #0]
 8004118:	f003 0308 	and.w	r3, r3, #8
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == RCC_PERIPHCLK_SAI_PLLSAI) ||
 800411c:	2b00      	cmp	r3, #0
 800411e:	d079      	beq.n	8004214 <HAL_RCCEx_PeriphCLKConfig+0x22c>
  {
    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));

    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE();
 8004120:	4b52      	ldr	r3, [pc, #328]	; (800426c <HAL_RCCEx_PeriphCLKConfig+0x284>)
 8004122:	2200      	movs	r2, #0
 8004124:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 8004126:	f7fd f925 	bl	8001374 <HAL_GetTick>
 800412a:	6178      	str	r0, [r7, #20]
    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 800412c:	e008      	b.n	8004140 <HAL_RCCEx_PeriphCLKConfig+0x158>
    {
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 800412e:	f7fd f921 	bl	8001374 <HAL_GetTick>
 8004132:	4602      	mov	r2, r0
 8004134:	697b      	ldr	r3, [r7, #20]
 8004136:	1ad3      	subs	r3, r2, r3
 8004138:	2b02      	cmp	r3, #2
 800413a:	d901      	bls.n	8004140 <HAL_RCCEx_PeriphCLKConfig+0x158>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800413c:	2303      	movs	r3, #3
 800413e:	e107      	b.n	8004350 <HAL_RCCEx_PeriphCLKConfig+0x368>
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8004140:	4b49      	ldr	r3, [pc, #292]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8004142:	681b      	ldr	r3, [r3, #0]
 8004144:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8004148:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800414c:	d0ef      	beq.n	800412e <HAL_RCCEx_PeriphCLKConfig+0x146>
    }

    /*---------------------------- SAI configuration -------------------------*/
    /* In Case of SAI Clock Configuration through PLLSAI, PLLSAIQ and PLLSAI_DIVQ must
       be added only for SAI configuration */
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == (RCC_PERIPHCLK_SAI_PLLSAI))
 800414e:	687b      	ldr	r3, [r7, #4]
 8004150:	681b      	ldr	r3, [r3, #0]
 8004152:	f003 0304 	and.w	r3, r3, #4
 8004156:	2b00      	cmp	r3, #0
 8004158:	d020      	beq.n	800419c <HAL_RCCEx_PeriphCLKConfig+0x1b4>
    {
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));

      /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 800415a:	4b43      	ldr	r3, [pc, #268]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800415c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004160:	0f1b      	lsrs	r3, r3, #28
 8004162:	f003 0307 	and.w	r3, r3, #7
 8004166:	613b      	str	r3, [r7, #16]
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8004168:	687b      	ldr	r3, [r7, #4]
 800416a:	691b      	ldr	r3, [r3, #16]
 800416c:	019a      	lsls	r2, r3, #6
 800416e:	687b      	ldr	r3, [r7, #4]
 8004170:	695b      	ldr	r3, [r3, #20]
 8004172:	061b      	lsls	r3, r3, #24
 8004174:	431a      	orrs	r2, r3
 8004176:	693b      	ldr	r3, [r7, #16]
 8004178:	071b      	lsls	r3, r3, #28
 800417a:	493b      	ldr	r1, [pc, #236]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800417c:	4313      	orrs	r3, r2
 800417e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 8004182:	4b39      	ldr	r3, [pc, #228]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8004184:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8004188:	f423 52f8 	bic.w	r2, r3, #7936	; 0x1f00
 800418c:	687b      	ldr	r3, [r7, #4]
 800418e:	6a1b      	ldr	r3, [r3, #32]
 8004190:	3b01      	subs	r3, #1
 8004192:	021b      	lsls	r3, r3, #8
 8004194:	4934      	ldr	r1, [pc, #208]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8004196:	4313      	orrs	r3, r2
 8004198:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*---------------------------- LTDC configuration ------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 800419c:	687b      	ldr	r3, [r7, #4]
 800419e:	681b      	ldr	r3, [r3, #0]
 80041a0:	f003 0308 	and.w	r3, r3, #8
 80041a4:	2b00      	cmp	r3, #0
 80041a6:	d01e      	beq.n	80041e6 <HAL_RCCEx_PeriphCLKConfig+0x1fe>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));

      /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80041a8:	4b2f      	ldr	r3, [pc, #188]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 80041aa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80041ae:	0e1b      	lsrs	r3, r3, #24
 80041b0:	f003 030f 	and.w	r3, r3, #15
 80041b4:	613b      	str	r3, [r7, #16]
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, PeriphClkInit->PLLSAI.PLLSAIR);
 80041b6:	687b      	ldr	r3, [r7, #4]
 80041b8:	691b      	ldr	r3, [r3, #16]
 80041ba:	019a      	lsls	r2, r3, #6
 80041bc:	693b      	ldr	r3, [r7, #16]
 80041be:	061b      	lsls	r3, r3, #24
 80041c0:	431a      	orrs	r2, r3
 80041c2:	687b      	ldr	r3, [r7, #4]
 80041c4:	699b      	ldr	r3, [r3, #24]
 80041c6:	071b      	lsls	r3, r3, #28
 80041c8:	4927      	ldr	r1, [pc, #156]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 80041ca:	4313      	orrs	r3, r2
 80041cc:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 80041d0:	4b25      	ldr	r3, [pc, #148]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 80041d2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80041d6:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 80041da:	687b      	ldr	r3, [r7, #4]
 80041dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80041de:	4922      	ldr	r1, [pc, #136]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 80041e0:	4313      	orrs	r3, r2
 80041e2:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }
    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
 80041e6:	4b21      	ldr	r3, [pc, #132]	; (800426c <HAL_RCCEx_PeriphCLKConfig+0x284>)
 80041e8:	2201      	movs	r2, #1
 80041ea:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 80041ec:	f7fd f8c2 	bl	8001374 <HAL_GetTick>
 80041f0:	6178      	str	r0, [r7, #20]
    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80041f2:	e008      	b.n	8004206 <HAL_RCCEx_PeriphCLKConfig+0x21e>
    {
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 80041f4:	f7fd f8be 	bl	8001374 <HAL_GetTick>
 80041f8:	4602      	mov	r2, r0
 80041fa:	697b      	ldr	r3, [r7, #20]
 80041fc:	1ad3      	subs	r3, r2, r3
 80041fe:	2b02      	cmp	r3, #2
 8004200:	d901      	bls.n	8004206 <HAL_RCCEx_PeriphCLKConfig+0x21e>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8004202:	2303      	movs	r3, #3
 8004204:	e0a4      	b.n	8004350 <HAL_RCCEx_PeriphCLKConfig+0x368>
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8004206:	4b18      	ldr	r3, [pc, #96]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8004208:	681b      	ldr	r3, [r3, #0]
 800420a:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800420e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8004212:	d1ef      	bne.n	80041f4 <HAL_RCCEx_PeriphCLKConfig+0x20c>
    }
  }
  /*--------------------------------------------------------------------------*/

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8004214:	687b      	ldr	r3, [r7, #4]
 8004216:	681b      	ldr	r3, [r3, #0]
 8004218:	f003 0320 	and.w	r3, r3, #32
 800421c:	2b00      	cmp	r3, #0
 800421e:	f000 808b 	beq.w	8004338 <HAL_RCCEx_PeriphCLKConfig+0x350>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8004222:	2300      	movs	r3, #0
 8004224:	60fb      	str	r3, [r7, #12]
 8004226:	4b10      	ldr	r3, [pc, #64]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8004228:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800422a:	4a0f      	ldr	r2, [pc, #60]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 800422c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004230:	6413      	str	r3, [r2, #64]	; 0x40
 8004232:	4b0d      	ldr	r3, [pc, #52]	; (8004268 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8004234:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004236:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800423a:	60fb      	str	r3, [r7, #12]
 800423c:	68fb      	ldr	r3, [r7, #12]

    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 800423e:	4b0c      	ldr	r3, [pc, #48]	; (8004270 <HAL_RCCEx_PeriphCLKConfig+0x288>)
 8004240:	681b      	ldr	r3, [r3, #0]
 8004242:	4a0b      	ldr	r2, [pc, #44]	; (8004270 <HAL_RCCEx_PeriphCLKConfig+0x288>)
 8004244:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004248:	6013      	str	r3, [r2, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 800424a:	f7fd f893 	bl	8001374 <HAL_GetTick>
 800424e:	6178      	str	r0, [r7, #20]

    while((PWR->CR & PWR_CR_DBP) == RESET)
 8004250:	e010      	b.n	8004274 <HAL_RCCEx_PeriphCLKConfig+0x28c>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8004252:	f7fd f88f 	bl	8001374 <HAL_GetTick>
 8004256:	4602      	mov	r2, r0
 8004258:	697b      	ldr	r3, [r7, #20]
 800425a:	1ad3      	subs	r3, r2, r3
 800425c:	2b02      	cmp	r3, #2
 800425e:	d909      	bls.n	8004274 <HAL_RCCEx_PeriphCLKConfig+0x28c>
      {
        return HAL_TIMEOUT;
 8004260:	2303      	movs	r3, #3
 8004262:	e075      	b.n	8004350 <HAL_RCCEx_PeriphCLKConfig+0x368>
 8004264:	42470068 	.word	0x42470068
 8004268:	40023800 	.word	0x40023800
 800426c:	42470070 	.word	0x42470070
 8004270:	40007000 	.word	0x40007000
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8004274:	4b38      	ldr	r3, [pc, #224]	; (8004358 <HAL_RCCEx_PeriphCLKConfig+0x370>)
 8004276:	681b      	ldr	r3, [r3, #0]
 8004278:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800427c:	2b00      	cmp	r3, #0
 800427e:	d0e8      	beq.n	8004252 <HAL_RCCEx_PeriphCLKConfig+0x26a>
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8004280:	4b36      	ldr	r3, [pc, #216]	; (800435c <HAL_RCCEx_PeriphCLKConfig+0x374>)
 8004282:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004284:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004288:	613b      	str	r3, [r7, #16]
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800428a:	693b      	ldr	r3, [r7, #16]
 800428c:	2b00      	cmp	r3, #0
 800428e:	d02f      	beq.n	80042f0 <HAL_RCCEx_PeriphCLKConfig+0x308>
 8004290:	687b      	ldr	r3, [r7, #4]
 8004292:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004294:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004298:	693a      	ldr	r2, [r7, #16]
 800429a:	429a      	cmp	r2, r3
 800429c:	d028      	beq.n	80042f0 <HAL_RCCEx_PeriphCLKConfig+0x308>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800429e:	4b2f      	ldr	r3, [pc, #188]	; (800435c <HAL_RCCEx_PeriphCLKConfig+0x374>)
 80042a0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80042a2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80042a6:	613b      	str	r3, [r7, #16]
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 80042a8:	4b2d      	ldr	r3, [pc, #180]	; (8004360 <HAL_RCCEx_PeriphCLKConfig+0x378>)
 80042aa:	2201      	movs	r2, #1
 80042ac:	601a      	str	r2, [r3, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 80042ae:	4b2c      	ldr	r3, [pc, #176]	; (8004360 <HAL_RCCEx_PeriphCLKConfig+0x378>)
 80042b0:	2200      	movs	r2, #0
 80042b2:	601a      	str	r2, [r3, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg1;
 80042b4:	4a29      	ldr	r2, [pc, #164]	; (800435c <HAL_RCCEx_PeriphCLKConfig+0x374>)
 80042b6:	693b      	ldr	r3, [r7, #16]
 80042b8:	6713      	str	r3, [r2, #112]	; 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 80042ba:	4b28      	ldr	r3, [pc, #160]	; (800435c <HAL_RCCEx_PeriphCLKConfig+0x374>)
 80042bc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80042be:	f003 0301 	and.w	r3, r3, #1
 80042c2:	2b01      	cmp	r3, #1
 80042c4:	d114      	bne.n	80042f0 <HAL_RCCEx_PeriphCLKConfig+0x308>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 80042c6:	f7fd f855 	bl	8001374 <HAL_GetTick>
 80042ca:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80042cc:	e00a      	b.n	80042e4 <HAL_RCCEx_PeriphCLKConfig+0x2fc>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80042ce:	f7fd f851 	bl	8001374 <HAL_GetTick>
 80042d2:	4602      	mov	r2, r0
 80042d4:	697b      	ldr	r3, [r7, #20]
 80042d6:	1ad3      	subs	r3, r2, r3
 80042d8:	f241 3288 	movw	r2, #5000	; 0x1388
 80042dc:	4293      	cmp	r3, r2
 80042de:	d901      	bls.n	80042e4 <HAL_RCCEx_PeriphCLKConfig+0x2fc>
          {
            return HAL_TIMEOUT;
 80042e0:	2303      	movs	r3, #3
 80042e2:	e035      	b.n	8004350 <HAL_RCCEx_PeriphCLKConfig+0x368>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80042e4:	4b1d      	ldr	r3, [pc, #116]	; (800435c <HAL_RCCEx_PeriphCLKConfig+0x374>)
 80042e6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80042e8:	f003 0302 	and.w	r3, r3, #2
 80042ec:	2b00      	cmp	r3, #0
 80042ee:	d0ee      	beq.n	80042ce <HAL_RCCEx_PeriphCLKConfig+0x2e6>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80042f0:	687b      	ldr	r3, [r7, #4]
 80042f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80042f4:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80042f8:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80042fc:	d10d      	bne.n	800431a <HAL_RCCEx_PeriphCLKConfig+0x332>
 80042fe:	4b17      	ldr	r3, [pc, #92]	; (800435c <HAL_RCCEx_PeriphCLKConfig+0x374>)
 8004300:	689b      	ldr	r3, [r3, #8]
 8004302:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 8004306:	687b      	ldr	r3, [r7, #4]
 8004308:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800430a:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 800430e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8004312:	4912      	ldr	r1, [pc, #72]	; (800435c <HAL_RCCEx_PeriphCLKConfig+0x374>)
 8004314:	4313      	orrs	r3, r2
 8004316:	608b      	str	r3, [r1, #8]
 8004318:	e005      	b.n	8004326 <HAL_RCCEx_PeriphCLKConfig+0x33e>
 800431a:	4b10      	ldr	r3, [pc, #64]	; (800435c <HAL_RCCEx_PeriphCLKConfig+0x374>)
 800431c:	689b      	ldr	r3, [r3, #8]
 800431e:	4a0f      	ldr	r2, [pc, #60]	; (800435c <HAL_RCCEx_PeriphCLKConfig+0x374>)
 8004320:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 8004324:	6093      	str	r3, [r2, #8]
 8004326:	4b0d      	ldr	r3, [pc, #52]	; (800435c <HAL_RCCEx_PeriphCLKConfig+0x374>)
 8004328:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800432a:	687b      	ldr	r3, [r7, #4]
 800432c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800432e:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8004332:	490a      	ldr	r1, [pc, #40]	; (800435c <HAL_RCCEx_PeriphCLKConfig+0x374>)
 8004334:	4313      	orrs	r3, r2
 8004336:	670b      	str	r3, [r1, #112]	; 0x70
  }
  /*--------------------------------------------------------------------------*/

  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8004338:	687b      	ldr	r3, [r7, #4]
 800433a:	681b      	ldr	r3, [r3, #0]
 800433c:	f003 0310 	and.w	r3, r3, #16
 8004340:	2b00      	cmp	r3, #0
 8004342:	d004      	beq.n	800434e <HAL_RCCEx_PeriphCLKConfig+0x366>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8004344:	687b      	ldr	r3, [r7, #4]
 8004346:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
 800434a:	4b06      	ldr	r3, [pc, #24]	; (8004364 <HAL_RCCEx_PeriphCLKConfig+0x37c>)
 800434c:	601a      	str	r2, [r3, #0]
  }
  return HAL_OK;
 800434e:	2300      	movs	r3, #0
}
 8004350:	4618      	mov	r0, r3
 8004352:	3718      	adds	r7, #24
 8004354:	46bd      	mov	sp, r7
 8004356:	bd80      	pop	{r7, pc}
 8004358:	40007000 	.word	0x40007000
 800435c:	40023800 	.word	0x40023800
 8004360:	42470e40 	.word	0x42470e40
 8004364:	424711e0 	.word	0x424711e0

08004368 <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing Pointer to SDRAM control timing structure 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
 8004368:	b580      	push	{r7, lr}
 800436a:	b082      	sub	sp, #8
 800436c:	af00      	add	r7, sp, #0
 800436e:	6078      	str	r0, [r7, #4]
 8004370:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
 8004372:	687b      	ldr	r3, [r7, #4]
 8004374:	2b00      	cmp	r3, #0
 8004376:	d101      	bne.n	800437c <HAL_SDRAM_Init+0x14>
  {
    return HAL_ERROR;
 8004378:	2301      	movs	r3, #1
 800437a:	e025      	b.n	80043c8 <HAL_SDRAM_Init+0x60>
  }
  
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 800437c:	687b      	ldr	r3, [r7, #4]
 800437e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8004382:	b2db      	uxtb	r3, r3
 8004384:	2b00      	cmp	r3, #0
 8004386:	d106      	bne.n	8004396 <HAL_SDRAM_Init+0x2e>
  {  
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
 8004388:	687b      	ldr	r3, [r7, #4]
 800438a:	2200      	movs	r2, #0
 800438c:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    /* Init the low level hardware */
    hsdram->MspInitCallback(hsdram);
#else
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
 8004390:	6878      	ldr	r0, [r7, #4]
 8004392:	f7fc febd 	bl	8001110 <HAL_SDRAM_MspInit>
#endif
  }
  
  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8004396:	687b      	ldr	r3, [r7, #4]
 8004398:	2202      	movs	r2, #2
 800439a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Initialize SDRAM control Interface */
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800439e:	687b      	ldr	r3, [r7, #4]
 80043a0:	681a      	ldr	r2, [r3, #0]
 80043a2:	687b      	ldr	r3, [r7, #4]
 80043a4:	3304      	adds	r3, #4
 80043a6:	4619      	mov	r1, r3
 80043a8:	4610      	mov	r0, r2
 80043aa:	f000 f85c 	bl	8004466 <FMC_SDRAM_Init>
  
  /* Initialize SDRAM timing Interface */
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
 80043ae:	687b      	ldr	r3, [r7, #4]
 80043b0:	6818      	ldr	r0, [r3, #0]
 80043b2:	687b      	ldr	r3, [r7, #4]
 80043b4:	685b      	ldr	r3, [r3, #4]
 80043b6:	461a      	mov	r2, r3
 80043b8:	6839      	ldr	r1, [r7, #0]
 80043ba:	f000 f8c7 	bl	800454c <FMC_SDRAM_Timing_Init>
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 80043be:	687b      	ldr	r3, [r7, #4]
 80043c0:	2201      	movs	r2, #1
 80043c2:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;
 80043c6:	2300      	movs	r3, #0
}
 80043c8:	4618      	mov	r0, r3
 80043ca:	3708      	adds	r7, #8
 80043cc:	46bd      	mov	sp, r7
 80043ce:	bd80      	pop	{r7, pc}

080043d0 <HAL_SDRAM_SendCommand>:
  * @param  Command SDRAM command structure
  * @param  Timeout Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 80043d0:	b580      	push	{r7, lr}
 80043d2:	b084      	sub	sp, #16
 80043d4:	af00      	add	r7, sp, #0
 80043d6:	60f8      	str	r0, [r7, #12]
 80043d8:	60b9      	str	r1, [r7, #8]
 80043da:	607a      	str	r2, [r7, #4]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 80043dc:	68fb      	ldr	r3, [r7, #12]
 80043de:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80043e2:	b2db      	uxtb	r3, r3
 80043e4:	2b02      	cmp	r3, #2
 80043e6:	d101      	bne.n	80043ec <HAL_SDRAM_SendCommand+0x1c>
  {
    return HAL_BUSY;
 80043e8:	2302      	movs	r3, #2
 80043ea:	e018      	b.n	800441e <HAL_SDRAM_SendCommand+0x4e>
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 80043ec:	68fb      	ldr	r3, [r7, #12]
 80043ee:	2202      	movs	r2, #2
 80043f0:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 80043f4:	68fb      	ldr	r3, [r7, #12]
 80043f6:	681b      	ldr	r3, [r3, #0]
 80043f8:	687a      	ldr	r2, [r7, #4]
 80043fa:	68b9      	ldr	r1, [r7, #8]
 80043fc:	4618      	mov	r0, r3
 80043fe:	f000 f924 	bl	800464a <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 8004402:	68bb      	ldr	r3, [r7, #8]
 8004404:	681b      	ldr	r3, [r3, #0]
 8004406:	2b02      	cmp	r3, #2
 8004408:	d104      	bne.n	8004414 <HAL_SDRAM_SendCommand+0x44>
  {
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800440a:	68fb      	ldr	r3, [r7, #12]
 800440c:	2205      	movs	r2, #5
 800440e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
 8004412:	e003      	b.n	800441c <HAL_SDRAM_SendCommand+0x4c>
  }
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
 8004414:	68fb      	ldr	r3, [r7, #12]
 8004416:	2201      	movs	r2, #1
 8004418:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  }
  
  return HAL_OK;  
 800441c:	2300      	movs	r3, #0
}
 800441e:	4618      	mov	r0, r3
 8004420:	3710      	adds	r7, #16
 8004422:	46bd      	mov	sp, r7
 8004424:	bd80      	pop	{r7, pc}

08004426 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.  
  * @param  RefreshRate The SDRAM refresh rate value       
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 8004426:	b580      	push	{r7, lr}
 8004428:	b082      	sub	sp, #8
 800442a:	af00      	add	r7, sp, #0
 800442c:	6078      	str	r0, [r7, #4]
 800442e:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8004430:	687b      	ldr	r3, [r7, #4]
 8004432:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8004436:	b2db      	uxtb	r3, r3
 8004438:	2b02      	cmp	r3, #2
 800443a:	d101      	bne.n	8004440 <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
 800443c:	2302      	movs	r3, #2
 800443e:	e00e      	b.n	800445e <HAL_SDRAM_ProgramRefreshRate+0x38>
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8004440:	687b      	ldr	r3, [r7, #4]
 8004442:	2202      	movs	r2, #2
 8004444:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 8004448:	687b      	ldr	r3, [r7, #4]
 800444a:	681b      	ldr	r3, [r3, #0]
 800444c:	6839      	ldr	r1, [r7, #0]
 800444e:	4618      	mov	r0, r3
 8004450:	f000 f937 	bl	80046c2 <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 8004454:	687b      	ldr	r3, [r7, #4]
 8004456:	2201      	movs	r2, #1
 8004458:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;   
 800445c:	2300      	movs	r3, #0
}
 800445e:	4618      	mov	r0, r3
 8004460:	3708      	adds	r7, #8
 8004462:	46bd      	mov	sp, r7
 8004464:	bd80      	pop	{r7, pc}

08004466 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 8004466:	b480      	push	{r7}
 8004468:	b085      	sub	sp, #20
 800446a:	af00      	add	r7, sp, #0
 800446c:	6078      	str	r0, [r7, #4]
 800446e:	6039      	str	r1, [r7, #0]
  uint32_t tmpr1 = 0U;
 8004470:	2300      	movs	r3, #0
 8004472:	60fb      	str	r3, [r7, #12]
  uint32_t tmpr2 = 0U;
 8004474:	2300      	movs	r3, #0
 8004476:	60bb      	str	r3, [r7, #8]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 8004478:	683b      	ldr	r3, [r7, #0]
 800447a:	681b      	ldr	r3, [r3, #0]
 800447c:	2b01      	cmp	r3, #1
 800447e:	d029      	beq.n	80044d4 <FMC_SDRAM_Init+0x6e>
  {    
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 8004480:	687b      	ldr	r3, [r7, #4]
 8004482:	681b      	ldr	r3, [r3, #0]
 8004484:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8004486:	68fb      	ldr	r3, [r7, #12]
 8004488:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 800448c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8004490:	60fb      	str	r3, [r7, #12]
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
  
  
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8004492:	683b      	ldr	r3, [r7, #0]
 8004494:	685a      	ldr	r2, [r3, #4]
                                               Init->RowBitsNumber      |\
 8004496:	683b      	ldr	r3, [r7, #0]
 8004498:	689b      	ldr	r3, [r3, #8]
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800449a:	431a      	orrs	r2, r3
                                               Init->MemoryDataWidth    |\
 800449c:	683b      	ldr	r3, [r7, #0]
 800449e:	68db      	ldr	r3, [r3, #12]
                                               Init->RowBitsNumber      |\
 80044a0:	431a      	orrs	r2, r3
                                               Init->InternalBankNumber |\
 80044a2:	683b      	ldr	r3, [r7, #0]
 80044a4:	691b      	ldr	r3, [r3, #16]
                                               Init->MemoryDataWidth    |\
 80044a6:	431a      	orrs	r2, r3
                                               Init->CASLatency         |\
 80044a8:	683b      	ldr	r3, [r7, #0]
 80044aa:	695b      	ldr	r3, [r3, #20]
                                               Init->InternalBankNumber |\
 80044ac:	431a      	orrs	r2, r3
                                               Init->WriteProtection    |\
 80044ae:	683b      	ldr	r3, [r7, #0]
 80044b0:	699b      	ldr	r3, [r3, #24]
                                               Init->CASLatency         |\
 80044b2:	431a      	orrs	r2, r3
                                               Init->SDClockPeriod      |\
 80044b4:	683b      	ldr	r3, [r7, #0]
 80044b6:	69db      	ldr	r3, [r3, #28]
                                               Init->WriteProtection    |\
 80044b8:	431a      	orrs	r2, r3
                                               Init->ReadBurst          |\
 80044ba:	683b      	ldr	r3, [r7, #0]
 80044bc:	6a1b      	ldr	r3, [r3, #32]
                                               Init->SDClockPeriod      |\
 80044be:	431a      	orrs	r2, r3
                                               Init->ReadPipeDelay
 80044c0:	683b      	ldr	r3, [r7, #0]
 80044c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                                               Init->ReadBurst          |\
 80044c4:	4313      	orrs	r3, r2
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 80044c6:	68fa      	ldr	r2, [r7, #12]
 80044c8:	4313      	orrs	r3, r2
 80044ca:	60fb      	str	r3, [r7, #12]
                                               );
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 80044cc:	687b      	ldr	r3, [r7, #4]
 80044ce:	68fa      	ldr	r2, [r7, #12]
 80044d0:	601a      	str	r2, [r3, #0]
 80044d2:	e034      	b.n	800453e <FMC_SDRAM_Init+0xd8>
  }
  else /* FMC_Bank2_SDRAM */                      
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 80044d4:	687b      	ldr	r3, [r7, #4]
 80044d6:	681b      	ldr	r3, [r3, #0]
 80044d8:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
 80044da:	68fb      	ldr	r3, [r7, #12]
 80044dc:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 80044e0:	60fb      	str	r3, [r7, #12]
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 80044e2:	683b      	ldr	r3, [r7, #0]
 80044e4:	69da      	ldr	r2, [r3, #28]
                        Init->ReadBurst          |\
 80044e6:	683b      	ldr	r3, [r7, #0]
 80044e8:	6a1b      	ldr	r3, [r3, #32]
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 80044ea:	431a      	orrs	r2, r3
                        Init->ReadPipeDelay);  
 80044ec:	683b      	ldr	r3, [r7, #0]
 80044ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                        Init->ReadBurst          |\
 80044f0:	4313      	orrs	r3, r2
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 80044f2:	68fa      	ldr	r2, [r7, #12]
 80044f4:	4313      	orrs	r3, r2
 80044f6:	60fb      	str	r3, [r7, #12]
    
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
 80044f8:	687b      	ldr	r3, [r7, #4]
 80044fa:	685b      	ldr	r3, [r3, #4]
 80044fc:	60bb      	str	r3, [r7, #8]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 80044fe:	68bb      	ldr	r3, [r7, #8]
 8004500:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 8004504:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8004508:	60bb      	str	r3, [r7, #8]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800450a:	683b      	ldr	r3, [r7, #0]
 800450c:	685a      	ldr	r2, [r3, #4]
                       Init->RowBitsNumber      |\
 800450e:	683b      	ldr	r3, [r7, #0]
 8004510:	689b      	ldr	r3, [r3, #8]
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8004512:	431a      	orrs	r2, r3
                       Init->MemoryDataWidth    |\
 8004514:	683b      	ldr	r3, [r7, #0]
 8004516:	68db      	ldr	r3, [r3, #12]
                       Init->RowBitsNumber      |\
 8004518:	431a      	orrs	r2, r3
                       Init->InternalBankNumber |\
 800451a:	683b      	ldr	r3, [r7, #0]
 800451c:	691b      	ldr	r3, [r3, #16]
                       Init->MemoryDataWidth    |\
 800451e:	431a      	orrs	r2, r3
                       Init->CASLatency         |\
 8004520:	683b      	ldr	r3, [r7, #0]
 8004522:	695b      	ldr	r3, [r3, #20]
                       Init->InternalBankNumber |\
 8004524:	431a      	orrs	r2, r3
                       Init->WriteProtection);
 8004526:	683b      	ldr	r3, [r7, #0]
 8004528:	699b      	ldr	r3, [r3, #24]
                       Init->CASLatency         |\
 800452a:	4313      	orrs	r3, r2
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 800452c:	68ba      	ldr	r2, [r7, #8]
 800452e:	4313      	orrs	r3, r2
 8004530:	60bb      	str	r3, [r7, #8]

    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 8004532:	687b      	ldr	r3, [r7, #4]
 8004534:	68fa      	ldr	r2, [r7, #12]
 8004536:	601a      	str	r2, [r3, #0]
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 8004538:	687b      	ldr	r3, [r7, #4]
 800453a:	68ba      	ldr	r2, [r7, #8]
 800453c:	605a      	str	r2, [r3, #4]
  }  
  
  return HAL_OK;
 800453e:	2300      	movs	r3, #0
}
 8004540:	4618      	mov	r0, r3
 8004542:	3714      	adds	r7, #20
 8004544:	46bd      	mov	sp, r7
 8004546:	f85d 7b04 	ldr.w	r7, [sp], #4
 800454a:	4770      	bx	lr

0800454c <FMC_SDRAM_Timing_Init>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 800454c:	b480      	push	{r7}
 800454e:	b087      	sub	sp, #28
 8004550:	af00      	add	r7, sp, #0
 8004552:	60f8      	str	r0, [r7, #12]
 8004554:	60b9      	str	r1, [r7, #8]
 8004556:	607a      	str	r2, [r7, #4]
  uint32_t tmpr1 = 0U;
 8004558:	2300      	movs	r3, #0
 800455a:	617b      	str	r3, [r7, #20]
  uint32_t tmpr2 = 0U;
 800455c:	2300      	movs	r3, #0
 800455e:	613b      	str	r3, [r7, #16]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 8004560:	687b      	ldr	r3, [r7, #4]
 8004562:	2b01      	cmp	r3, #1
 8004564:	d02e      	beq.n	80045c4 <FMC_SDRAM_Timing_Init+0x78>
  { 
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 8004566:	68fb      	ldr	r3, [r7, #12]
 8004568:	689b      	ldr	r3, [r3, #8]
 800456a:	617b      	str	r3, [r7, #20]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 800456c:	697b      	ldr	r3, [r7, #20]
 800456e:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8004572:	617b      	str	r3, [r7, #20]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1U)           |\
 8004574:	68bb      	ldr	r3, [r7, #8]
 8004576:	681b      	ldr	r3, [r3, #0]
 8004578:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1U) << 4U) |\
 800457a:	68bb      	ldr	r3, [r7, #8]
 800457c:	685b      	ldr	r3, [r3, #4]
 800457e:	3b01      	subs	r3, #1
 8004580:	011b      	lsls	r3, r3, #4
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1U)           |\
 8004582:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1U) << 8U)      |\
 8004584:	68bb      	ldr	r3, [r7, #8]
 8004586:	689b      	ldr	r3, [r3, #8]
 8004588:	3b01      	subs	r3, #1
 800458a:	021b      	lsls	r3, r3, #8
                       (((Timing->ExitSelfRefreshDelay)-1U) << 4U) |\
 800458c:	431a      	orrs	r2, r3
                       (((Timing->RowCycleDelay)-1U) << 12U)       |\
 800458e:	68bb      	ldr	r3, [r7, #8]
 8004590:	68db      	ldr	r3, [r3, #12]
 8004592:	3b01      	subs	r3, #1
 8004594:	031b      	lsls	r3, r3, #12
                       (((Timing->SelfRefreshTime)-1U) << 8U)      |\
 8004596:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1U) <<16U)    |\
 8004598:	68bb      	ldr	r3, [r7, #8]
 800459a:	691b      	ldr	r3, [r3, #16]
 800459c:	3b01      	subs	r3, #1
 800459e:	041b      	lsls	r3, r3, #16
                       (((Timing->RowCycleDelay)-1U) << 12U)       |\
 80045a0:	431a      	orrs	r2, r3
                       (((Timing->RPDelay)-1U) << 20U)             |\
 80045a2:	68bb      	ldr	r3, [r7, #8]
 80045a4:	695b      	ldr	r3, [r3, #20]
 80045a6:	3b01      	subs	r3, #1
 80045a8:	051b      	lsls	r3, r3, #20
                       (((Timing->WriteRecoveryTime)-1U) <<16U)    |\
 80045aa:	431a      	orrs	r2, r3
                       (((Timing->RCDDelay)-1U) << 24U));
 80045ac:	68bb      	ldr	r3, [r7, #8]
 80045ae:	699b      	ldr	r3, [r3, #24]
 80045b0:	3b01      	subs	r3, #1
 80045b2:	061b      	lsls	r3, r3, #24
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1U)           |\
 80045b4:	4313      	orrs	r3, r2
 80045b6:	697a      	ldr	r2, [r7, #20]
 80045b8:	4313      	orrs	r3, r2
 80045ba:	617b      	str	r3, [r7, #20]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 80045bc:	68fb      	ldr	r3, [r7, #12]
 80045be:	697a      	ldr	r2, [r7, #20]
 80045c0:	609a      	str	r2, [r3, #8]
 80045c2:	e03b      	b.n	800463c <FMC_SDRAM_Timing_Init+0xf0>
  }
   else /* FMC_Bank2_SDRAM */
  {
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 80045c4:	68fb      	ldr	r3, [r7, #12]
 80045c6:	689b      	ldr	r3, [r3, #8]
 80045c8:	617b      	str	r3, [r7, #20]
    
    /* Clear TRC and TRP bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 80045ca:	697b      	ldr	r3, [r7, #20]
 80045cc:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 80045d0:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 80045d4:	617b      	str	r3, [r7, #20]
    
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1U) << 12U)       |\
 80045d6:	68bb      	ldr	r3, [r7, #8]
 80045d8:	68db      	ldr	r3, [r3, #12]
 80045da:	3b01      	subs	r3, #1
 80045dc:	031a      	lsls	r2, r3, #12
                        (((Timing->RPDelay)-1U) << 20U)); 
 80045de:	68bb      	ldr	r3, [r7, #8]
 80045e0:	695b      	ldr	r3, [r3, #20]
 80045e2:	3b01      	subs	r3, #1
 80045e4:	051b      	lsls	r3, r3, #20
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1U) << 12U)       |\
 80045e6:	4313      	orrs	r3, r2
 80045e8:	697a      	ldr	r2, [r7, #20]
 80045ea:	4313      	orrs	r3, r2
 80045ec:	617b      	str	r3, [r7, #20]
    
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
 80045ee:	68fb      	ldr	r3, [r7, #12]
 80045f0:	68db      	ldr	r3, [r3, #12]
 80045f2:	613b      	str	r3, [r7, #16]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 80045f4:	693b      	ldr	r3, [r7, #16]
 80045f6:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 80045fa:	613b      	str	r3, [r7, #16]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr2 |= (uint32_t)((((Timing->LoadToActiveDelay)-1U)           |\
 80045fc:	68bb      	ldr	r3, [r7, #8]
 80045fe:	681b      	ldr	r3, [r3, #0]
 8004600:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1U) << 4U)  |\
 8004602:	68bb      	ldr	r3, [r7, #8]
 8004604:	685b      	ldr	r3, [r3, #4]
 8004606:	3b01      	subs	r3, #1
 8004608:	011b      	lsls	r3, r3, #4
    tmpr2 |= (uint32_t)((((Timing->LoadToActiveDelay)-1U)           |\
 800460a:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1U) << 8U)       |\
 800460c:	68bb      	ldr	r3, [r7, #8]
 800460e:	689b      	ldr	r3, [r3, #8]
 8004610:	3b01      	subs	r3, #1
 8004612:	021b      	lsls	r3, r3, #8
                       (((Timing->ExitSelfRefreshDelay)-1U) << 4U)  |\
 8004614:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1U) <<16U)     |\
 8004616:	68bb      	ldr	r3, [r7, #8]
 8004618:	691b      	ldr	r3, [r3, #16]
 800461a:	3b01      	subs	r3, #1
 800461c:	041b      	lsls	r3, r3, #16
                       (((Timing->SelfRefreshTime)-1U) << 8U)       |\
 800461e:	431a      	orrs	r2, r3
                       (((Timing->RCDDelay)-1U) << 24U)));   
 8004620:	68bb      	ldr	r3, [r7, #8]
 8004622:	699b      	ldr	r3, [r3, #24]
 8004624:	3b01      	subs	r3, #1
 8004626:	061b      	lsls	r3, r3, #24
    tmpr2 |= (uint32_t)((((Timing->LoadToActiveDelay)-1U)           |\
 8004628:	4313      	orrs	r3, r2
 800462a:	693a      	ldr	r2, [r7, #16]
 800462c:	4313      	orrs	r3, r2
 800462e:	613b      	str	r3, [r7, #16]

    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 8004630:	68fb      	ldr	r3, [r7, #12]
 8004632:	697a      	ldr	r2, [r7, #20]
 8004634:	609a      	str	r2, [r3, #8]
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
 8004636:	68fb      	ldr	r3, [r7, #12]
 8004638:	693a      	ldr	r2, [r7, #16]
 800463a:	60da      	str	r2, [r3, #12]
  }
  return HAL_OK;
 800463c:	2300      	movs	r3, #0
}
 800463e:	4618      	mov	r0, r3
 8004640:	371c      	adds	r7, #28
 8004642:	46bd      	mov	sp, r7
 8004644:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004648:	4770      	bx	lr

0800464a <FMC_SDRAM_SendCommand>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Timeout Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 800464a:	b580      	push	{r7, lr}
 800464c:	b086      	sub	sp, #24
 800464e:	af00      	add	r7, sp, #0
 8004650:	60f8      	str	r0, [r7, #12]
 8004652:	60b9      	str	r1, [r7, #8]
 8004654:	607a      	str	r2, [r7, #4]
  __IO uint32_t tmpr = 0U;
 8004656:	2300      	movs	r3, #0
 8004658:	613b      	str	r3, [r7, #16]
  uint32_t tickstart = 0U;
 800465a:	2300      	movs	r3, #0
 800465c:	617b      	str	r3, [r7, #20]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 800465e:	68bb      	ldr	r3, [r7, #8]
 8004660:	681a      	ldr	r2, [r3, #0]
                    (Command->CommandTarget)                |\
 8004662:	68bb      	ldr	r3, [r7, #8]
 8004664:	685b      	ldr	r3, [r3, #4]
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8004666:	431a      	orrs	r2, r3
                    (((Command->AutoRefreshNumber)-1U) << 5U) |\
 8004668:	68bb      	ldr	r3, [r7, #8]
 800466a:	689b      	ldr	r3, [r3, #8]
 800466c:	3b01      	subs	r3, #1
 800466e:	015b      	lsls	r3, r3, #5
                    (Command->CommandTarget)                |\
 8004670:	431a      	orrs	r2, r3
                    ((Command->ModeRegisterDefinition) << 9U)
 8004672:	68bb      	ldr	r3, [r7, #8]
 8004674:	68db      	ldr	r3, [r3, #12]
 8004676:	025b      	lsls	r3, r3, #9
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8004678:	4313      	orrs	r3, r2
 800467a:	613b      	str	r3, [r7, #16]
                    );
    
  Device->SDCMR = tmpr;
 800467c:	693a      	ldr	r2, [r7, #16]
 800467e:	68fb      	ldr	r3, [r7, #12]
 8004680:	611a      	str	r2, [r3, #16]

  /* Get tick */ 
  tickstart = HAL_GetTick();
 8004682:	f7fc fe77 	bl	8001374 <HAL_GetTick>
 8004686:	6178      	str	r0, [r7, #20]

  /* Wait until command is send */
  while(HAL_IS_BIT_SET(Device->SDSR, FMC_SDSR_BUSY))
 8004688:	e010      	b.n	80046ac <FMC_SDRAM_SendCommand+0x62>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 800468a:	687b      	ldr	r3, [r7, #4]
 800468c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8004690:	d00c      	beq.n	80046ac <FMC_SDRAM_SendCommand+0x62>
    {
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 8004692:	687b      	ldr	r3, [r7, #4]
 8004694:	2b00      	cmp	r3, #0
 8004696:	d007      	beq.n	80046a8 <FMC_SDRAM_SendCommand+0x5e>
 8004698:	f7fc fe6c 	bl	8001374 <HAL_GetTick>
 800469c:	4602      	mov	r2, r0
 800469e:	697b      	ldr	r3, [r7, #20]
 80046a0:	1ad3      	subs	r3, r2, r3
 80046a2:	687a      	ldr	r2, [r7, #4]
 80046a4:	429a      	cmp	r2, r3
 80046a6:	d201      	bcs.n	80046ac <FMC_SDRAM_SendCommand+0x62>
      {
        return HAL_TIMEOUT;
 80046a8:	2303      	movs	r3, #3
 80046aa:	e006      	b.n	80046ba <FMC_SDRAM_SendCommand+0x70>
  while(HAL_IS_BIT_SET(Device->SDSR, FMC_SDSR_BUSY))
 80046ac:	68fb      	ldr	r3, [r7, #12]
 80046ae:	699b      	ldr	r3, [r3, #24]
 80046b0:	f003 0320 	and.w	r3, r3, #32
 80046b4:	2b20      	cmp	r3, #32
 80046b6:	d0e8      	beq.n	800468a <FMC_SDRAM_SendCommand+0x40>
      }
    }
  }

  return HAL_OK;
 80046b8:	2300      	movs	r3, #0
}
 80046ba:	4618      	mov	r0, r3
 80046bc:	3718      	adds	r7, #24
 80046be:	46bd      	mov	sp, r7
 80046c0:	bd80      	pop	{r7, pc}

080046c2 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance  
  * @param  RefreshRate The SDRAM refresh rate value.
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 80046c2:	b480      	push	{r7}
 80046c4:	b083      	sub	sp, #12
 80046c6:	af00      	add	r7, sp, #0
 80046c8:	6078      	str	r0, [r7, #4]
 80046ca:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1U);
 80046cc:	687b      	ldr	r3, [r7, #4]
 80046ce:	695a      	ldr	r2, [r3, #20]
 80046d0:	683b      	ldr	r3, [r7, #0]
 80046d2:	005b      	lsls	r3, r3, #1
 80046d4:	431a      	orrs	r2, r3
 80046d6:	687b      	ldr	r3, [r7, #4]
 80046d8:	615a      	str	r2, [r3, #20]
  
  return HAL_OK;   
 80046da:	2300      	movs	r3, #0
}
 80046dc:	4618      	mov	r0, r3
 80046de:	370c      	adds	r7, #12
 80046e0:	46bd      	mov	sp, r7
 80046e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80046e6:	4770      	bx	lr

080046e8 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80046e8:	b084      	sub	sp, #16
 80046ea:	b580      	push	{r7, lr}
 80046ec:	b084      	sub	sp, #16
 80046ee:	af00      	add	r7, sp, #0
 80046f0:	6078      	str	r0, [r7, #4]
 80046f2:	f107 001c 	add.w	r0, r7, #28
 80046f6:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80046fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80046fc:	2b01      	cmp	r3, #1
 80046fe:	d122      	bne.n	8004746 <USB_CoreInit+0x5e>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8004700:	687b      	ldr	r3, [r7, #4]
 8004702:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004704:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8004708:	687b      	ldr	r3, [r7, #4]
 800470a:	639a      	str	r2, [r3, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 800470c:	687b      	ldr	r3, [r7, #4]
 800470e:	68db      	ldr	r3, [r3, #12]
 8004710:	f423 0384 	bic.w	r3, r3, #4325376	; 0x420000
 8004714:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004718:	687a      	ldr	r2, [r7, #4]
 800471a:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 800471c:	687b      	ldr	r3, [r7, #4]
 800471e:	68db      	ldr	r3, [r3, #12]
 8004720:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8004724:	687b      	ldr	r3, [r7, #4]
 8004726:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 8004728:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800472a:	2b01      	cmp	r3, #1
 800472c:	d105      	bne.n	800473a <USB_CoreInit+0x52>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 800472e:	687b      	ldr	r3, [r7, #4]
 8004730:	68db      	ldr	r3, [r3, #12]
 8004732:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
 8004736:	687b      	ldr	r3, [r7, #4]
 8004738:	60da      	str	r2, [r3, #12]
    }
    /* Reset after a PHY select  */
    ret = USB_CoreReset(USBx);
 800473a:	6878      	ldr	r0, [r7, #4]
 800473c:	f001 fab4 	bl	8005ca8 <USB_CoreReset>
 8004740:	4603      	mov	r3, r0
 8004742:	73fb      	strb	r3, [r7, #15]
 8004744:	e01a      	b.n	800477c <USB_CoreInit+0x94>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8004746:	687b      	ldr	r3, [r7, #4]
 8004748:	68db      	ldr	r3, [r3, #12]
 800474a:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800474e:	687b      	ldr	r3, [r7, #4]
 8004750:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select and set Host mode */
    ret = USB_CoreReset(USBx);
 8004752:	6878      	ldr	r0, [r7, #4]
 8004754:	f001 faa8 	bl	8005ca8 <USB_CoreReset>
 8004758:	4603      	mov	r3, r0
 800475a:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
 800475c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800475e:	2b00      	cmp	r3, #0
 8004760:	d106      	bne.n	8004770 <USB_CoreInit+0x88>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 8004762:	687b      	ldr	r3, [r7, #4]
 8004764:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004766:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 800476a:	687b      	ldr	r3, [r7, #4]
 800476c:	639a      	str	r2, [r3, #56]	; 0x38
 800476e:	e005      	b.n	800477c <USB_CoreInit+0x94>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8004770:	687b      	ldr	r3, [r7, #4]
 8004772:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004774:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8004778:	687b      	ldr	r3, [r7, #4]
 800477a:	639a      	str	r2, [r3, #56]	; 0x38
    }
  }

  if (cfg.dma_enable == 1U)
 800477c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800477e:	2b01      	cmp	r3, #1
 8004780:	d10b      	bne.n	800479a <USB_CoreInit+0xb2>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8004782:	687b      	ldr	r3, [r7, #4]
 8004784:	689b      	ldr	r3, [r3, #8]
 8004786:	f043 0206 	orr.w	r2, r3, #6
 800478a:	687b      	ldr	r3, [r7, #4]
 800478c:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 800478e:	687b      	ldr	r3, [r7, #4]
 8004790:	689b      	ldr	r3, [r3, #8]
 8004792:	f043 0220 	orr.w	r2, r3, #32
 8004796:	687b      	ldr	r3, [r7, #4]
 8004798:	609a      	str	r2, [r3, #8]
  }

  return ret;
 800479a:	7bfb      	ldrb	r3, [r7, #15]
}
 800479c:	4618      	mov	r0, r3
 800479e:	3710      	adds	r7, #16
 80047a0:	46bd      	mov	sp, r7
 80047a2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 80047a6:	b004      	add	sp, #16
 80047a8:	4770      	bx	lr
	...

080047ac <USB_SetTurnaroundTime>:
  * @param  hclk: AHB clock frequency
  * @retval USB turnaround time In PHY Clocks number
  */
HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
                                        uint32_t hclk, uint8_t speed)
{
 80047ac:	b480      	push	{r7}
 80047ae:	b087      	sub	sp, #28
 80047b0:	af00      	add	r7, sp, #0
 80047b2:	60f8      	str	r0, [r7, #12]
 80047b4:	60b9      	str	r1, [r7, #8]
 80047b6:	4613      	mov	r3, r2
 80047b8:	71fb      	strb	r3, [r7, #7]

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
 80047ba:	79fb      	ldrb	r3, [r7, #7]
 80047bc:	2b02      	cmp	r3, #2
 80047be:	d165      	bne.n	800488c <USB_SetTurnaroundTime+0xe0>
  {
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 80047c0:	68bb      	ldr	r3, [r7, #8]
 80047c2:	4a41      	ldr	r2, [pc, #260]	; (80048c8 <USB_SetTurnaroundTime+0x11c>)
 80047c4:	4293      	cmp	r3, r2
 80047c6:	d906      	bls.n	80047d6 <USB_SetTurnaroundTime+0x2a>
 80047c8:	68bb      	ldr	r3, [r7, #8]
 80047ca:	4a40      	ldr	r2, [pc, #256]	; (80048cc <USB_SetTurnaroundTime+0x120>)
 80047cc:	4293      	cmp	r3, r2
 80047ce:	d202      	bcs.n	80047d6 <USB_SetTurnaroundTime+0x2a>
    {
      /* hclk Clock Range between 14.2-15 MHz */
      UsbTrd = 0xFU;
 80047d0:	230f      	movs	r3, #15
 80047d2:	617b      	str	r3, [r7, #20]
 80047d4:	e062      	b.n	800489c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 80047d6:	68bb      	ldr	r3, [r7, #8]
 80047d8:	4a3c      	ldr	r2, [pc, #240]	; (80048cc <USB_SetTurnaroundTime+0x120>)
 80047da:	4293      	cmp	r3, r2
 80047dc:	d306      	bcc.n	80047ec <USB_SetTurnaroundTime+0x40>
 80047de:	68bb      	ldr	r3, [r7, #8]
 80047e0:	4a3b      	ldr	r2, [pc, #236]	; (80048d0 <USB_SetTurnaroundTime+0x124>)
 80047e2:	4293      	cmp	r3, r2
 80047e4:	d202      	bcs.n	80047ec <USB_SetTurnaroundTime+0x40>
    {
      /* hclk Clock Range between 15-16 MHz */
      UsbTrd = 0xEU;
 80047e6:	230e      	movs	r3, #14
 80047e8:	617b      	str	r3, [r7, #20]
 80047ea:	e057      	b.n	800489c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 80047ec:	68bb      	ldr	r3, [r7, #8]
 80047ee:	4a38      	ldr	r2, [pc, #224]	; (80048d0 <USB_SetTurnaroundTime+0x124>)
 80047f0:	4293      	cmp	r3, r2
 80047f2:	d306      	bcc.n	8004802 <USB_SetTurnaroundTime+0x56>
 80047f4:	68bb      	ldr	r3, [r7, #8]
 80047f6:	4a37      	ldr	r2, [pc, #220]	; (80048d4 <USB_SetTurnaroundTime+0x128>)
 80047f8:	4293      	cmp	r3, r2
 80047fa:	d202      	bcs.n	8004802 <USB_SetTurnaroundTime+0x56>
    {
      /* hclk Clock Range between 16-17.2 MHz */
      UsbTrd = 0xDU;
 80047fc:	230d      	movs	r3, #13
 80047fe:	617b      	str	r3, [r7, #20]
 8004800:	e04c      	b.n	800489c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 8004802:	68bb      	ldr	r3, [r7, #8]
 8004804:	4a33      	ldr	r2, [pc, #204]	; (80048d4 <USB_SetTurnaroundTime+0x128>)
 8004806:	4293      	cmp	r3, r2
 8004808:	d306      	bcc.n	8004818 <USB_SetTurnaroundTime+0x6c>
 800480a:	68bb      	ldr	r3, [r7, #8]
 800480c:	4a32      	ldr	r2, [pc, #200]	; (80048d8 <USB_SetTurnaroundTime+0x12c>)
 800480e:	4293      	cmp	r3, r2
 8004810:	d802      	bhi.n	8004818 <USB_SetTurnaroundTime+0x6c>
    {
      /* hclk Clock Range between 17.2-18.5 MHz */
      UsbTrd = 0xCU;
 8004812:	230c      	movs	r3, #12
 8004814:	617b      	str	r3, [r7, #20]
 8004816:	e041      	b.n	800489c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 8004818:	68bb      	ldr	r3, [r7, #8]
 800481a:	4a2f      	ldr	r2, [pc, #188]	; (80048d8 <USB_SetTurnaroundTime+0x12c>)
 800481c:	4293      	cmp	r3, r2
 800481e:	d906      	bls.n	800482e <USB_SetTurnaroundTime+0x82>
 8004820:	68bb      	ldr	r3, [r7, #8]
 8004822:	4a2e      	ldr	r2, [pc, #184]	; (80048dc <USB_SetTurnaroundTime+0x130>)
 8004824:	4293      	cmp	r3, r2
 8004826:	d802      	bhi.n	800482e <USB_SetTurnaroundTime+0x82>
    {
      /* hclk Clock Range between 18.5-20 MHz */
      UsbTrd = 0xBU;
 8004828:	230b      	movs	r3, #11
 800482a:	617b      	str	r3, [r7, #20]
 800482c:	e036      	b.n	800489c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 800482e:	68bb      	ldr	r3, [r7, #8]
 8004830:	4a2a      	ldr	r2, [pc, #168]	; (80048dc <USB_SetTurnaroundTime+0x130>)
 8004832:	4293      	cmp	r3, r2
 8004834:	d906      	bls.n	8004844 <USB_SetTurnaroundTime+0x98>
 8004836:	68bb      	ldr	r3, [r7, #8]
 8004838:	4a29      	ldr	r2, [pc, #164]	; (80048e0 <USB_SetTurnaroundTime+0x134>)
 800483a:	4293      	cmp	r3, r2
 800483c:	d802      	bhi.n	8004844 <USB_SetTurnaroundTime+0x98>
    {
      /* hclk Clock Range between 20-21.8 MHz */
      UsbTrd = 0xAU;
 800483e:	230a      	movs	r3, #10
 8004840:	617b      	str	r3, [r7, #20]
 8004842:	e02b      	b.n	800489c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 8004844:	68bb      	ldr	r3, [r7, #8]
 8004846:	4a26      	ldr	r2, [pc, #152]	; (80048e0 <USB_SetTurnaroundTime+0x134>)
 8004848:	4293      	cmp	r3, r2
 800484a:	d906      	bls.n	800485a <USB_SetTurnaroundTime+0xae>
 800484c:	68bb      	ldr	r3, [r7, #8]
 800484e:	4a25      	ldr	r2, [pc, #148]	; (80048e4 <USB_SetTurnaroundTime+0x138>)
 8004850:	4293      	cmp	r3, r2
 8004852:	d202      	bcs.n	800485a <USB_SetTurnaroundTime+0xae>
    {
      /* hclk Clock Range between 21.8-24 MHz */
      UsbTrd = 0x9U;
 8004854:	2309      	movs	r3, #9
 8004856:	617b      	str	r3, [r7, #20]
 8004858:	e020      	b.n	800489c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 800485a:	68bb      	ldr	r3, [r7, #8]
 800485c:	4a21      	ldr	r2, [pc, #132]	; (80048e4 <USB_SetTurnaroundTime+0x138>)
 800485e:	4293      	cmp	r3, r2
 8004860:	d306      	bcc.n	8004870 <USB_SetTurnaroundTime+0xc4>
 8004862:	68bb      	ldr	r3, [r7, #8]
 8004864:	4a20      	ldr	r2, [pc, #128]	; (80048e8 <USB_SetTurnaroundTime+0x13c>)
 8004866:	4293      	cmp	r3, r2
 8004868:	d802      	bhi.n	8004870 <USB_SetTurnaroundTime+0xc4>
    {
      /* hclk Clock Range between 24-27.7 MHz */
      UsbTrd = 0x8U;
 800486a:	2308      	movs	r3, #8
 800486c:	617b      	str	r3, [r7, #20]
 800486e:	e015      	b.n	800489c <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8004870:	68bb      	ldr	r3, [r7, #8]
 8004872:	4a1d      	ldr	r2, [pc, #116]	; (80048e8 <USB_SetTurnaroundTime+0x13c>)
 8004874:	4293      	cmp	r3, r2
 8004876:	d906      	bls.n	8004886 <USB_SetTurnaroundTime+0xda>
 8004878:	68bb      	ldr	r3, [r7, #8]
 800487a:	4a1c      	ldr	r2, [pc, #112]	; (80048ec <USB_SetTurnaroundTime+0x140>)
 800487c:	4293      	cmp	r3, r2
 800487e:	d202      	bcs.n	8004886 <USB_SetTurnaroundTime+0xda>
    {
      /* hclk Clock Range between 27.7-32 MHz */
      UsbTrd = 0x7U;
 8004880:	2307      	movs	r3, #7
 8004882:	617b      	str	r3, [r7, #20]
 8004884:	e00a      	b.n	800489c <USB_SetTurnaroundTime+0xf0>
    }
    else /* if(hclk >= 32000000) */
    {
      /* hclk Clock Range between 32-200 MHz */
      UsbTrd = 0x6U;
 8004886:	2306      	movs	r3, #6
 8004888:	617b      	str	r3, [r7, #20]
 800488a:	e007      	b.n	800489c <USB_SetTurnaroundTime+0xf0>
    }
  }
  else if (speed == USBD_HS_SPEED)
 800488c:	79fb      	ldrb	r3, [r7, #7]
 800488e:	2b00      	cmp	r3, #0
 8004890:	d102      	bne.n	8004898 <USB_SetTurnaroundTime+0xec>
  {
    UsbTrd = USBD_HS_TRDT_VALUE;
 8004892:	2309      	movs	r3, #9
 8004894:	617b      	str	r3, [r7, #20]
 8004896:	e001      	b.n	800489c <USB_SetTurnaroundTime+0xf0>
  }
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
 8004898:	2309      	movs	r3, #9
 800489a:	617b      	str	r3, [r7, #20]
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 800489c:	68fb      	ldr	r3, [r7, #12]
 800489e:	68db      	ldr	r3, [r3, #12]
 80048a0:	f423 5270 	bic.w	r2, r3, #15360	; 0x3c00
 80048a4:	68fb      	ldr	r3, [r7, #12]
 80048a6:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 80048a8:	68fb      	ldr	r3, [r7, #12]
 80048aa:	68da      	ldr	r2, [r3, #12]
 80048ac:	697b      	ldr	r3, [r7, #20]
 80048ae:	029b      	lsls	r3, r3, #10
 80048b0:	f403 5370 	and.w	r3, r3, #15360	; 0x3c00
 80048b4:	431a      	orrs	r2, r3
 80048b6:	68fb      	ldr	r3, [r7, #12]
 80048b8:	60da      	str	r2, [r3, #12]

  return HAL_OK;
 80048ba:	2300      	movs	r3, #0
}
 80048bc:	4618      	mov	r0, r3
 80048be:	371c      	adds	r7, #28
 80048c0:	46bd      	mov	sp, r7
 80048c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80048c6:	4770      	bx	lr
 80048c8:	00d8acbf 	.word	0x00d8acbf
 80048cc:	00e4e1c0 	.word	0x00e4e1c0
 80048d0:	00f42400 	.word	0x00f42400
 80048d4:	01067380 	.word	0x01067380
 80048d8:	011a499f 	.word	0x011a499f
 80048dc:	01312cff 	.word	0x01312cff
 80048e0:	014ca43f 	.word	0x014ca43f
 80048e4:	016e3600 	.word	0x016e3600
 80048e8:	01a6ab1f 	.word	0x01a6ab1f
 80048ec:	01e84800 	.word	0x01e84800

080048f0 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 80048f0:	b480      	push	{r7}
 80048f2:	b083      	sub	sp, #12
 80048f4:	af00      	add	r7, sp, #0
 80048f6:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 80048f8:	687b      	ldr	r3, [r7, #4]
 80048fa:	689b      	ldr	r3, [r3, #8]
 80048fc:	f043 0201 	orr.w	r2, r3, #1
 8004900:	687b      	ldr	r3, [r7, #4]
 8004902:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8004904:	2300      	movs	r3, #0
}
 8004906:	4618      	mov	r0, r3
 8004908:	370c      	adds	r7, #12
 800490a:	46bd      	mov	sp, r7
 800490c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004910:	4770      	bx	lr

08004912 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8004912:	b480      	push	{r7}
 8004914:	b083      	sub	sp, #12
 8004916:	af00      	add	r7, sp, #0
 8004918:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 800491a:	687b      	ldr	r3, [r7, #4]
 800491c:	689b      	ldr	r3, [r3, #8]
 800491e:	f023 0201 	bic.w	r2, r3, #1
 8004922:	687b      	ldr	r3, [r7, #4]
 8004924:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8004926:	2300      	movs	r3, #0
}
 8004928:	4618      	mov	r0, r3
 800492a:	370c      	adds	r7, #12
 800492c:	46bd      	mov	sp, r7
 800492e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004932:	4770      	bx	lr

08004934 <USB_SetCurrentMode>:
  *            @arg USB_HOST_MODE: Host mode
  *            @arg USB_DRD_MODE: Dual Role Device mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 8004934:	b580      	push	{r7, lr}
 8004936:	b082      	sub	sp, #8
 8004938:	af00      	add	r7, sp, #0
 800493a:	6078      	str	r0, [r7, #4]
 800493c:	460b      	mov	r3, r1
 800493e:	70fb      	strb	r3, [r7, #3]
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8004940:	687b      	ldr	r3, [r7, #4]
 8004942:	68db      	ldr	r3, [r3, #12]
 8004944:	f023 42c0 	bic.w	r2, r3, #1610612736	; 0x60000000
 8004948:	687b      	ldr	r3, [r7, #4]
 800494a:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 800494c:	78fb      	ldrb	r3, [r7, #3]
 800494e:	2b01      	cmp	r3, #1
 8004950:	d106      	bne.n	8004960 <USB_SetCurrentMode+0x2c>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8004952:	687b      	ldr	r3, [r7, #4]
 8004954:	68db      	ldr	r3, [r3, #12]
 8004956:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
 800495a:	687b      	ldr	r3, [r7, #4]
 800495c:	60da      	str	r2, [r3, #12]
 800495e:	e00b      	b.n	8004978 <USB_SetCurrentMode+0x44>
  }
  else if (mode == USB_DEVICE_MODE)
 8004960:	78fb      	ldrb	r3, [r7, #3]
 8004962:	2b00      	cmp	r3, #0
 8004964:	d106      	bne.n	8004974 <USB_SetCurrentMode+0x40>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8004966:	687b      	ldr	r3, [r7, #4]
 8004968:	68db      	ldr	r3, [r3, #12]
 800496a:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
 800496e:	687b      	ldr	r3, [r7, #4]
 8004970:	60da      	str	r2, [r3, #12]
 8004972:	e001      	b.n	8004978 <USB_SetCurrentMode+0x44>
  }
  else
  {
    return HAL_ERROR;
 8004974:	2301      	movs	r3, #1
 8004976:	e003      	b.n	8004980 <USB_SetCurrentMode+0x4c>
  }
  HAL_Delay(50U);
 8004978:	2032      	movs	r0, #50	; 0x32
 800497a:	f7fc fd07 	bl	800138c <HAL_Delay>

  return HAL_OK;
 800497e:	2300      	movs	r3, #0
}
 8004980:	4618      	mov	r0, r3
 8004982:	3708      	adds	r7, #8
 8004984:	46bd      	mov	sp, r7
 8004986:	bd80      	pop	{r7, pc}

08004988 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8004988:	b084      	sub	sp, #16
 800498a:	b580      	push	{r7, lr}
 800498c:	b086      	sub	sp, #24
 800498e:	af00      	add	r7, sp, #0
 8004990:	6078      	str	r0, [r7, #4]
 8004992:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8004996:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
 800499a:	2300      	movs	r3, #0
 800499c:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800499e:	687b      	ldr	r3, [r7, #4]
 80049a0:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  for (i = 0U; i < 15U; i++)
 80049a2:	2300      	movs	r3, #0
 80049a4:	613b      	str	r3, [r7, #16]
 80049a6:	e009      	b.n	80049bc <USB_DevInit+0x34>
  {
    USBx->DIEPTXF[i] = 0U;
 80049a8:	687a      	ldr	r2, [r7, #4]
 80049aa:	693b      	ldr	r3, [r7, #16]
 80049ac:	3340      	adds	r3, #64	; 0x40
 80049ae:	009b      	lsls	r3, r3, #2
 80049b0:	4413      	add	r3, r2
 80049b2:	2200      	movs	r2, #0
 80049b4:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < 15U; i++)
 80049b6:	693b      	ldr	r3, [r7, #16]
 80049b8:	3301      	adds	r3, #1
 80049ba:	613b      	str	r3, [r7, #16]
 80049bc:	693b      	ldr	r3, [r7, #16]
 80049be:	2b0e      	cmp	r3, #14
 80049c0:	d9f2      	bls.n	80049a8 <USB_DevInit+0x20>
    /* Enable HW VBUS sensing */
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
  }
#else
  /* VBUS Sensing setup */
  if (cfg.vbus_sensing_enable == 0U)
 80049c2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80049c4:	2b00      	cmp	r3, #0
 80049c6:	d11c      	bne.n	8004a02 <USB_DevInit+0x7a>
  {
    /*
     * Disable HW VBUS sensing. VBUS is internally considered to be always
     * at VBUS-Valid level (5V).
     */
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 80049c8:	68fb      	ldr	r3, [r7, #12]
 80049ca:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80049ce:	685b      	ldr	r3, [r3, #4]
 80049d0:	68fa      	ldr	r2, [r7, #12]
 80049d2:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80049d6:	f043 0302 	orr.w	r3, r3, #2
 80049da:	6053      	str	r3, [r2, #4]
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 80049dc:	687b      	ldr	r3, [r7, #4]
 80049de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80049e0:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
 80049e4:	687b      	ldr	r3, [r7, #4]
 80049e6:	639a      	str	r2, [r3, #56]	; 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
 80049e8:	687b      	ldr	r3, [r7, #4]
 80049ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80049ec:	f423 2200 	bic.w	r2, r3, #524288	; 0x80000
 80049f0:	687b      	ldr	r3, [r7, #4]
 80049f2:	639a      	str	r2, [r3, #56]	; 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
 80049f4:	687b      	ldr	r3, [r7, #4]
 80049f6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80049f8:	f423 2280 	bic.w	r2, r3, #262144	; 0x40000
 80049fc:	687b      	ldr	r3, [r7, #4]
 80049fe:	639a      	str	r2, [r3, #56]	; 0x38
 8004a00:	e00b      	b.n	8004a1a <USB_DevInit+0x92>
  }
  else
  {
    /* Enable HW VBUS sensing */
    USBx->GCCFG &= ~USB_OTG_GCCFG_NOVBUSSENS;
 8004a02:	687b      	ldr	r3, [r7, #4]
 8004a04:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004a06:	f423 1200 	bic.w	r2, r3, #2097152	; 0x200000
 8004a0a:	687b      	ldr	r3, [r7, #4]
 8004a0c:	639a      	str	r2, [r3, #56]	; 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 8004a0e:	687b      	ldr	r3, [r7, #4]
 8004a10:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004a12:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
 8004a16:	687b      	ldr	r3, [r7, #4]
 8004a18:	639a      	str	r2, [r3, #56]	; 0x38
  }
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) || defined(STM32F423xx) */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8004a1a:	68fb      	ldr	r3, [r7, #12]
 8004a1c:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 8004a20:	461a      	mov	r2, r3
 8004a22:	2300      	movs	r3, #0
 8004a24:	6013      	str	r3, [r2, #0]

  /* Device mode configuration */
  USBx_DEVICE->DCFG |= DCFG_FRAME_INTERVAL_80;
 8004a26:	68fb      	ldr	r3, [r7, #12]
 8004a28:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004a2c:	4619      	mov	r1, r3
 8004a2e:	68fb      	ldr	r3, [r7, #12]
 8004a30:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004a34:	461a      	mov	r2, r3
 8004a36:	680b      	ldr	r3, [r1, #0]
 8004a38:	6013      	str	r3, [r2, #0]

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8004a3a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8004a3c:	2b01      	cmp	r3, #1
 8004a3e:	d10c      	bne.n	8004a5a <USB_DevInit+0xd2>
  {
    if (cfg.speed == USBD_HS_SPEED)
 8004a40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004a42:	2b00      	cmp	r3, #0
 8004a44:	d104      	bne.n	8004a50 <USB_DevInit+0xc8>
    {
      /* Set Core speed to High speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
 8004a46:	2100      	movs	r1, #0
 8004a48:	6878      	ldr	r0, [r7, #4]
 8004a4a:	f000 f949 	bl	8004ce0 <USB_SetDevSpeed>
 8004a4e:	e008      	b.n	8004a62 <USB_DevInit+0xda>
    }
    else
    {
      /* Set Core speed to Full speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 8004a50:	2101      	movs	r1, #1
 8004a52:	6878      	ldr	r0, [r7, #4]
 8004a54:	f000 f944 	bl	8004ce0 <USB_SetDevSpeed>
 8004a58:	e003      	b.n	8004a62 <USB_DevInit+0xda>
    }
  }
  else
  {
    /* Set Core speed to Full speed mode */
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 8004a5a:	2103      	movs	r1, #3
 8004a5c:	6878      	ldr	r0, [r7, #4]
 8004a5e:	f000 f93f 	bl	8004ce0 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 8004a62:	2110      	movs	r1, #16
 8004a64:	6878      	ldr	r0, [r7, #4]
 8004a66:	f000 f8f3 	bl	8004c50 <USB_FlushTxFifo>
 8004a6a:	4603      	mov	r3, r0
 8004a6c:	2b00      	cmp	r3, #0
 8004a6e:	d001      	beq.n	8004a74 <USB_DevInit+0xec>
  {
    ret = HAL_ERROR;
 8004a70:	2301      	movs	r3, #1
 8004a72:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 8004a74:	6878      	ldr	r0, [r7, #4]
 8004a76:	f000 f911 	bl	8004c9c <USB_FlushRxFifo>
 8004a7a:	4603      	mov	r3, r0
 8004a7c:	2b00      	cmp	r3, #0
 8004a7e:	d001      	beq.n	8004a84 <USB_DevInit+0xfc>
  {
    ret = HAL_ERROR;
 8004a80:	2301      	movs	r3, #1
 8004a82:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8004a84:	68fb      	ldr	r3, [r7, #12]
 8004a86:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004a8a:	461a      	mov	r2, r3
 8004a8c:	2300      	movs	r3, #0
 8004a8e:	6113      	str	r3, [r2, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 8004a90:	68fb      	ldr	r3, [r7, #12]
 8004a92:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004a96:	461a      	mov	r2, r3
 8004a98:	2300      	movs	r3, #0
 8004a9a:	6153      	str	r3, [r2, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 8004a9c:	68fb      	ldr	r3, [r7, #12]
 8004a9e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004aa2:	461a      	mov	r2, r3
 8004aa4:	2300      	movs	r3, #0
 8004aa6:	61d3      	str	r3, [r2, #28]

  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004aa8:	2300      	movs	r3, #0
 8004aaa:	613b      	str	r3, [r7, #16]
 8004aac:	e043      	b.n	8004b36 <USB_DevInit+0x1ae>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8004aae:	693b      	ldr	r3, [r7, #16]
 8004ab0:	015a      	lsls	r2, r3, #5
 8004ab2:	68fb      	ldr	r3, [r7, #12]
 8004ab4:	4413      	add	r3, r2
 8004ab6:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004aba:	681b      	ldr	r3, [r3, #0]
 8004abc:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8004ac0:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8004ac4:	d118      	bne.n	8004af8 <USB_DevInit+0x170>
    {
      if (i == 0U)
 8004ac6:	693b      	ldr	r3, [r7, #16]
 8004ac8:	2b00      	cmp	r3, #0
 8004aca:	d10a      	bne.n	8004ae2 <USB_DevInit+0x15a>
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8004acc:	693b      	ldr	r3, [r7, #16]
 8004ace:	015a      	lsls	r2, r3, #5
 8004ad0:	68fb      	ldr	r3, [r7, #12]
 8004ad2:	4413      	add	r3, r2
 8004ad4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004ad8:	461a      	mov	r2, r3
 8004ada:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8004ade:	6013      	str	r3, [r2, #0]
 8004ae0:	e013      	b.n	8004b0a <USB_DevInit+0x182>
      }
      else
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8004ae2:	693b      	ldr	r3, [r7, #16]
 8004ae4:	015a      	lsls	r2, r3, #5
 8004ae6:	68fb      	ldr	r3, [r7, #12]
 8004ae8:	4413      	add	r3, r2
 8004aea:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004aee:	461a      	mov	r2, r3
 8004af0:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8004af4:	6013      	str	r3, [r2, #0]
 8004af6:	e008      	b.n	8004b0a <USB_DevInit+0x182>
      }
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 8004af8:	693b      	ldr	r3, [r7, #16]
 8004afa:	015a      	lsls	r2, r3, #5
 8004afc:	68fb      	ldr	r3, [r7, #12]
 8004afe:	4413      	add	r3, r2
 8004b00:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004b04:	461a      	mov	r2, r3
 8004b06:	2300      	movs	r3, #0
 8004b08:	6013      	str	r3, [r2, #0]
    }

    USBx_INEP(i)->DIEPTSIZ = 0U;
 8004b0a:	693b      	ldr	r3, [r7, #16]
 8004b0c:	015a      	lsls	r2, r3, #5
 8004b0e:	68fb      	ldr	r3, [r7, #12]
 8004b10:	4413      	add	r3, r2
 8004b12:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004b16:	461a      	mov	r2, r3
 8004b18:	2300      	movs	r3, #0
 8004b1a:	6113      	str	r3, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 8004b1c:	693b      	ldr	r3, [r7, #16]
 8004b1e:	015a      	lsls	r2, r3, #5
 8004b20:	68fb      	ldr	r3, [r7, #12]
 8004b22:	4413      	add	r3, r2
 8004b24:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004b28:	461a      	mov	r2, r3
 8004b2a:	f64f 337f 	movw	r3, #64383	; 0xfb7f
 8004b2e:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004b30:	693b      	ldr	r3, [r7, #16]
 8004b32:	3301      	adds	r3, #1
 8004b34:	613b      	str	r3, [r7, #16]
 8004b36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004b38:	693a      	ldr	r2, [r7, #16]
 8004b3a:	429a      	cmp	r2, r3
 8004b3c:	d3b7      	bcc.n	8004aae <USB_DevInit+0x126>
  }

  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004b3e:	2300      	movs	r3, #0
 8004b40:	613b      	str	r3, [r7, #16]
 8004b42:	e043      	b.n	8004bcc <USB_DevInit+0x244>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8004b44:	693b      	ldr	r3, [r7, #16]
 8004b46:	015a      	lsls	r2, r3, #5
 8004b48:	68fb      	ldr	r3, [r7, #12]
 8004b4a:	4413      	add	r3, r2
 8004b4c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004b50:	681b      	ldr	r3, [r3, #0]
 8004b52:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8004b56:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8004b5a:	d118      	bne.n	8004b8e <USB_DevInit+0x206>
    {
      if (i == 0U)
 8004b5c:	693b      	ldr	r3, [r7, #16]
 8004b5e:	2b00      	cmp	r3, #0
 8004b60:	d10a      	bne.n	8004b78 <USB_DevInit+0x1f0>
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8004b62:	693b      	ldr	r3, [r7, #16]
 8004b64:	015a      	lsls	r2, r3, #5
 8004b66:	68fb      	ldr	r3, [r7, #12]
 8004b68:	4413      	add	r3, r2
 8004b6a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004b6e:	461a      	mov	r2, r3
 8004b70:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8004b74:	6013      	str	r3, [r2, #0]
 8004b76:	e013      	b.n	8004ba0 <USB_DevInit+0x218>
      }
      else
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8004b78:	693b      	ldr	r3, [r7, #16]
 8004b7a:	015a      	lsls	r2, r3, #5
 8004b7c:	68fb      	ldr	r3, [r7, #12]
 8004b7e:	4413      	add	r3, r2
 8004b80:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004b84:	461a      	mov	r2, r3
 8004b86:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8004b8a:	6013      	str	r3, [r2, #0]
 8004b8c:	e008      	b.n	8004ba0 <USB_DevInit+0x218>
      }
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8004b8e:	693b      	ldr	r3, [r7, #16]
 8004b90:	015a      	lsls	r2, r3, #5
 8004b92:	68fb      	ldr	r3, [r7, #12]
 8004b94:	4413      	add	r3, r2
 8004b96:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004b9a:	461a      	mov	r2, r3
 8004b9c:	2300      	movs	r3, #0
 8004b9e:	6013      	str	r3, [r2, #0]
    }

    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8004ba0:	693b      	ldr	r3, [r7, #16]
 8004ba2:	015a      	lsls	r2, r3, #5
 8004ba4:	68fb      	ldr	r3, [r7, #12]
 8004ba6:	4413      	add	r3, r2
 8004ba8:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004bac:	461a      	mov	r2, r3
 8004bae:	2300      	movs	r3, #0
 8004bb0:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8004bb2:	693b      	ldr	r3, [r7, #16]
 8004bb4:	015a      	lsls	r2, r3, #5
 8004bb6:	68fb      	ldr	r3, [r7, #12]
 8004bb8:	4413      	add	r3, r2
 8004bba:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004bbe:	461a      	mov	r2, r3
 8004bc0:	f64f 337f 	movw	r3, #64383	; 0xfb7f
 8004bc4:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8004bc6:	693b      	ldr	r3, [r7, #16]
 8004bc8:	3301      	adds	r3, #1
 8004bca:	613b      	str	r3, [r7, #16]
 8004bcc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004bce:	693a      	ldr	r2, [r7, #16]
 8004bd0:	429a      	cmp	r2, r3
 8004bd2:	d3b7      	bcc.n	8004b44 <USB_DevInit+0x1bc>
  }

  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8004bd4:	68fb      	ldr	r3, [r7, #12]
 8004bd6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004bda:	691b      	ldr	r3, [r3, #16]
 8004bdc:	68fa      	ldr	r2, [r7, #12]
 8004bde:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8004be2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004be6:	6113      	str	r3, [r2, #16]

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 8004be8:	687b      	ldr	r3, [r7, #4]
 8004bea:	2200      	movs	r2, #0
 8004bec:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 8004bee:	687b      	ldr	r3, [r7, #4]
 8004bf0:	f06f 4280 	mvn.w	r2, #1073741824	; 0x40000000
 8004bf4:	615a      	str	r2, [r3, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 8004bf6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004bf8:	2b00      	cmp	r3, #0
 8004bfa:	d105      	bne.n	8004c08 <USB_DevInit+0x280>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8004bfc:	687b      	ldr	r3, [r7, #4]
 8004bfe:	699b      	ldr	r3, [r3, #24]
 8004c00:	f043 0210 	orr.w	r2, r3, #16
 8004c04:	687b      	ldr	r3, [r7, #4]
 8004c06:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8004c08:	687b      	ldr	r3, [r7, #4]
 8004c0a:	699a      	ldr	r2, [r3, #24]
 8004c0c:	4b0f      	ldr	r3, [pc, #60]	; (8004c4c <USB_DevInit+0x2c4>)
 8004c0e:	4313      	orrs	r3, r2
 8004c10:	687a      	ldr	r2, [r7, #4]
 8004c12:	6193      	str	r3, [r2, #24]
                   USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
                   USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
                   USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;

  if (cfg.Sof_enable != 0U)
 8004c14:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8004c16:	2b00      	cmp	r3, #0
 8004c18:	d005      	beq.n	8004c26 <USB_DevInit+0x29e>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8004c1a:	687b      	ldr	r3, [r7, #4]
 8004c1c:	699b      	ldr	r3, [r3, #24]
 8004c1e:	f043 0208 	orr.w	r2, r3, #8
 8004c22:	687b      	ldr	r3, [r7, #4]
 8004c24:	619a      	str	r2, [r3, #24]
  }

  if (cfg.vbus_sensing_enable == 1U)
 8004c26:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8004c28:	2b01      	cmp	r3, #1
 8004c2a:	d107      	bne.n	8004c3c <USB_DevInit+0x2b4>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 8004c2c:	687b      	ldr	r3, [r7, #4]
 8004c2e:	699b      	ldr	r3, [r3, #24]
 8004c30:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8004c34:	f043 0304 	orr.w	r3, r3, #4
 8004c38:	687a      	ldr	r2, [r7, #4]
 8004c3a:	6193      	str	r3, [r2, #24]
  }

  return ret;
 8004c3c:	7dfb      	ldrb	r3, [r7, #23]
}
 8004c3e:	4618      	mov	r0, r3
 8004c40:	3718      	adds	r7, #24
 8004c42:	46bd      	mov	sp, r7
 8004c44:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8004c48:	b004      	add	sp, #16
 8004c4a:	4770      	bx	lr
 8004c4c:	803c3800 	.word	0x803c3800

08004c50 <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 8004c50:	b480      	push	{r7}
 8004c52:	b085      	sub	sp, #20
 8004c54:	af00      	add	r7, sp, #0
 8004c56:	6078      	str	r0, [r7, #4]
 8004c58:	6039      	str	r1, [r7, #0]
  uint32_t count = 0U;
 8004c5a:	2300      	movs	r3, #0
 8004c5c:	60fb      	str	r3, [r7, #12]

  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8004c5e:	683b      	ldr	r3, [r7, #0]
 8004c60:	019b      	lsls	r3, r3, #6
 8004c62:	f043 0220 	orr.w	r2, r3, #32
 8004c66:	687b      	ldr	r3, [r7, #4]
 8004c68:	611a      	str	r2, [r3, #16]

  do
  {
    if (++count > 200000U)
 8004c6a:	68fb      	ldr	r3, [r7, #12]
 8004c6c:	3301      	adds	r3, #1
 8004c6e:	60fb      	str	r3, [r7, #12]
 8004c70:	68fb      	ldr	r3, [r7, #12]
 8004c72:	4a09      	ldr	r2, [pc, #36]	; (8004c98 <USB_FlushTxFifo+0x48>)
 8004c74:	4293      	cmp	r3, r2
 8004c76:	d901      	bls.n	8004c7c <USB_FlushTxFifo+0x2c>
    {
      return HAL_TIMEOUT;
 8004c78:	2303      	movs	r3, #3
 8004c7a:	e006      	b.n	8004c8a <USB_FlushTxFifo+0x3a>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8004c7c:	687b      	ldr	r3, [r7, #4]
 8004c7e:	691b      	ldr	r3, [r3, #16]
 8004c80:	f003 0320 	and.w	r3, r3, #32
 8004c84:	2b20      	cmp	r3, #32
 8004c86:	d0f0      	beq.n	8004c6a <USB_FlushTxFifo+0x1a>

  return HAL_OK;
 8004c88:	2300      	movs	r3, #0
}
 8004c8a:	4618      	mov	r0, r3
 8004c8c:	3714      	adds	r7, #20
 8004c8e:	46bd      	mov	sp, r7
 8004c90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004c94:	4770      	bx	lr
 8004c96:	bf00      	nop
 8004c98:	00030d40 	.word	0x00030d40

08004c9c <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo : Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 8004c9c:	b480      	push	{r7}
 8004c9e:	b085      	sub	sp, #20
 8004ca0:	af00      	add	r7, sp, #0
 8004ca2:	6078      	str	r0, [r7, #4]
  uint32_t count = 0;
 8004ca4:	2300      	movs	r3, #0
 8004ca6:	60fb      	str	r3, [r7, #12]

  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8004ca8:	687b      	ldr	r3, [r7, #4]
 8004caa:	2210      	movs	r2, #16
 8004cac:	611a      	str	r2, [r3, #16]

  do
  {
    if (++count > 200000U)
 8004cae:	68fb      	ldr	r3, [r7, #12]
 8004cb0:	3301      	adds	r3, #1
 8004cb2:	60fb      	str	r3, [r7, #12]
 8004cb4:	68fb      	ldr	r3, [r7, #12]
 8004cb6:	4a09      	ldr	r2, [pc, #36]	; (8004cdc <USB_FlushRxFifo+0x40>)
 8004cb8:	4293      	cmp	r3, r2
 8004cba:	d901      	bls.n	8004cc0 <USB_FlushRxFifo+0x24>
    {
      return HAL_TIMEOUT;
 8004cbc:	2303      	movs	r3, #3
 8004cbe:	e006      	b.n	8004cce <USB_FlushRxFifo+0x32>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8004cc0:	687b      	ldr	r3, [r7, #4]
 8004cc2:	691b      	ldr	r3, [r3, #16]
 8004cc4:	f003 0310 	and.w	r3, r3, #16
 8004cc8:	2b10      	cmp	r3, #16
 8004cca:	d0f0      	beq.n	8004cae <USB_FlushRxFifo+0x12>

  return HAL_OK;
 8004ccc:	2300      	movs	r3, #0
}
 8004cce:	4618      	mov	r0, r3
 8004cd0:	3714      	adds	r7, #20
 8004cd2:	46bd      	mov	sp, r7
 8004cd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004cd8:	4770      	bx	lr
 8004cda:	bf00      	nop
 8004cdc:	00030d40 	.word	0x00030d40

08004ce0 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
{
 8004ce0:	b480      	push	{r7}
 8004ce2:	b085      	sub	sp, #20
 8004ce4:	af00      	add	r7, sp, #0
 8004ce6:	6078      	str	r0, [r7, #4]
 8004ce8:	460b      	mov	r3, r1
 8004cea:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004cec:	687b      	ldr	r3, [r7, #4]
 8004cee:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG |= speed;
 8004cf0:	68fb      	ldr	r3, [r7, #12]
 8004cf2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004cf6:	681a      	ldr	r2, [r3, #0]
 8004cf8:	78fb      	ldrb	r3, [r7, #3]
 8004cfa:	68f9      	ldr	r1, [r7, #12]
 8004cfc:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8004d00:	4313      	orrs	r3, r2
 8004d02:	600b      	str	r3, [r1, #0]
  return HAL_OK;
 8004d04:	2300      	movs	r3, #0
}
 8004d06:	4618      	mov	r0, r3
 8004d08:	3714      	adds	r7, #20
 8004d0a:	46bd      	mov	sp, r7
 8004d0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004d10:	4770      	bx	lr

08004d12 <USB_GetDevSpeed>:
  *          This parameter can be one of these values:
  *            @arg PCD_SPEED_HIGH: High speed mode
  *            @arg PCD_SPEED_FULL: Full speed mode
  */
uint8_t USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx)
{
 8004d12:	b480      	push	{r7}
 8004d14:	b087      	sub	sp, #28
 8004d16:	af00      	add	r7, sp, #0
 8004d18:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004d1a:	687b      	ldr	r3, [r7, #4]
 8004d1c:	613b      	str	r3, [r7, #16]
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 8004d1e:	693b      	ldr	r3, [r7, #16]
 8004d20:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004d24:	689b      	ldr	r3, [r3, #8]
 8004d26:	f003 0306 	and.w	r3, r3, #6
 8004d2a:	60fb      	str	r3, [r7, #12]

  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 8004d2c:	68fb      	ldr	r3, [r7, #12]
 8004d2e:	2b00      	cmp	r3, #0
 8004d30:	d102      	bne.n	8004d38 <USB_GetDevSpeed+0x26>
  {
    speed = USBD_HS_SPEED;
 8004d32:	2300      	movs	r3, #0
 8004d34:	75fb      	strb	r3, [r7, #23]
 8004d36:	e00a      	b.n	8004d4e <USB_GetDevSpeed+0x3c>
  }
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
 8004d38:	68fb      	ldr	r3, [r7, #12]
 8004d3a:	2b02      	cmp	r3, #2
 8004d3c:	d002      	beq.n	8004d44 <USB_GetDevSpeed+0x32>
 8004d3e:	68fb      	ldr	r3, [r7, #12]
 8004d40:	2b06      	cmp	r3, #6
 8004d42:	d102      	bne.n	8004d4a <USB_GetDevSpeed+0x38>
           (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USBD_FS_SPEED;
 8004d44:	2302      	movs	r3, #2
 8004d46:	75fb      	strb	r3, [r7, #23]
 8004d48:	e001      	b.n	8004d4e <USB_GetDevSpeed+0x3c>
  }
  else
  {
    speed = 0xFU;
 8004d4a:	230f      	movs	r3, #15
 8004d4c:	75fb      	strb	r3, [r7, #23]
  }

  return speed;
 8004d4e:	7dfb      	ldrb	r3, [r7, #23]
}
 8004d50:	4618      	mov	r0, r3
 8004d52:	371c      	adds	r7, #28
 8004d54:	46bd      	mov	sp, r7
 8004d56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004d5a:	4770      	bx	lr

08004d5c <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8004d5c:	b480      	push	{r7}
 8004d5e:	b085      	sub	sp, #20
 8004d60:	af00      	add	r7, sp, #0
 8004d62:	6078      	str	r0, [r7, #4]
 8004d64:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004d66:	687b      	ldr	r3, [r7, #4]
 8004d68:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8004d6a:	683b      	ldr	r3, [r7, #0]
 8004d6c:	781b      	ldrb	r3, [r3, #0]
 8004d6e:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 8004d70:	683b      	ldr	r3, [r7, #0]
 8004d72:	785b      	ldrb	r3, [r3, #1]
 8004d74:	2b01      	cmp	r3, #1
 8004d76:	d13a      	bne.n	8004dee <USB_ActivateEndpoint+0x92>
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8004d78:	68fb      	ldr	r3, [r7, #12]
 8004d7a:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004d7e:	69da      	ldr	r2, [r3, #28]
 8004d80:	683b      	ldr	r3, [r7, #0]
 8004d82:	781b      	ldrb	r3, [r3, #0]
 8004d84:	f003 030f 	and.w	r3, r3, #15
 8004d88:	2101      	movs	r1, #1
 8004d8a:	fa01 f303 	lsl.w	r3, r1, r3
 8004d8e:	b29b      	uxth	r3, r3
 8004d90:	68f9      	ldr	r1, [r7, #12]
 8004d92:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8004d96:	4313      	orrs	r3, r2
 8004d98:	61cb      	str	r3, [r1, #28]

    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8004d9a:	68bb      	ldr	r3, [r7, #8]
 8004d9c:	015a      	lsls	r2, r3, #5
 8004d9e:	68fb      	ldr	r3, [r7, #12]
 8004da0:	4413      	add	r3, r2
 8004da2:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004da6:	681b      	ldr	r3, [r3, #0]
 8004da8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8004dac:	2b00      	cmp	r3, #0
 8004dae:	d155      	bne.n	8004e5c <USB_ActivateEndpoint+0x100>
    {
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8004db0:	68bb      	ldr	r3, [r7, #8]
 8004db2:	015a      	lsls	r2, r3, #5
 8004db4:	68fb      	ldr	r3, [r7, #12]
 8004db6:	4413      	add	r3, r2
 8004db8:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004dbc:	681a      	ldr	r2, [r3, #0]
 8004dbe:	683b      	ldr	r3, [r7, #0]
 8004dc0:	689b      	ldr	r3, [r3, #8]
 8004dc2:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 8004dc6:	683b      	ldr	r3, [r7, #0]
 8004dc8:	78db      	ldrb	r3, [r3, #3]
 8004dca:	049b      	lsls	r3, r3, #18
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8004dcc:	4319      	orrs	r1, r3
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 8004dce:	68bb      	ldr	r3, [r7, #8]
 8004dd0:	059b      	lsls	r3, r3, #22
 8004dd2:	430b      	orrs	r3, r1
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8004dd4:	4313      	orrs	r3, r2
 8004dd6:	68ba      	ldr	r2, [r7, #8]
 8004dd8:	0151      	lsls	r1, r2, #5
 8004dda:	68fa      	ldr	r2, [r7, #12]
 8004ddc:	440a      	add	r2, r1
 8004dde:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8004de2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004de6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004dea:	6013      	str	r3, [r2, #0]
 8004dec:	e036      	b.n	8004e5c <USB_ActivateEndpoint+0x100>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 8004dee:	68fb      	ldr	r3, [r7, #12]
 8004df0:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004df4:	69da      	ldr	r2, [r3, #28]
 8004df6:	683b      	ldr	r3, [r7, #0]
 8004df8:	781b      	ldrb	r3, [r3, #0]
 8004dfa:	f003 030f 	and.w	r3, r3, #15
 8004dfe:	2101      	movs	r1, #1
 8004e00:	fa01 f303 	lsl.w	r3, r1, r3
 8004e04:	041b      	lsls	r3, r3, #16
 8004e06:	68f9      	ldr	r1, [r7, #12]
 8004e08:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8004e0c:	4313      	orrs	r3, r2
 8004e0e:	61cb      	str	r3, [r1, #28]

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 8004e10:	68bb      	ldr	r3, [r7, #8]
 8004e12:	015a      	lsls	r2, r3, #5
 8004e14:	68fb      	ldr	r3, [r7, #12]
 8004e16:	4413      	add	r3, r2
 8004e18:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004e1c:	681b      	ldr	r3, [r3, #0]
 8004e1e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8004e22:	2b00      	cmp	r3, #0
 8004e24:	d11a      	bne.n	8004e5c <USB_ActivateEndpoint+0x100>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8004e26:	68bb      	ldr	r3, [r7, #8]
 8004e28:	015a      	lsls	r2, r3, #5
 8004e2a:	68fb      	ldr	r3, [r7, #12]
 8004e2c:	4413      	add	r3, r2
 8004e2e:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004e32:	681a      	ldr	r2, [r3, #0]
 8004e34:	683b      	ldr	r3, [r7, #0]
 8004e36:	689b      	ldr	r3, [r3, #8]
 8004e38:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
 8004e3c:	683b      	ldr	r3, [r7, #0]
 8004e3e:	78db      	ldrb	r3, [r3, #3]
 8004e40:	049b      	lsls	r3, r3, #18
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 8004e42:	430b      	orrs	r3, r1
 8004e44:	4313      	orrs	r3, r2
 8004e46:	68ba      	ldr	r2, [r7, #8]
 8004e48:	0151      	lsls	r1, r2, #5
 8004e4a:	68fa      	ldr	r2, [r7, #12]
 8004e4c:	440a      	add	r2, r1
 8004e4e:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8004e52:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004e56:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8004e5a:	6013      	str	r3, [r2, #0]
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
 8004e5c:	2300      	movs	r3, #0
}
 8004e5e:	4618      	mov	r0, r3
 8004e60:	3714      	adds	r7, #20
 8004e62:	46bd      	mov	sp, r7
 8004e64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004e68:	4770      	bx	lr
	...

08004e6c <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 8004e6c:	b480      	push	{r7}
 8004e6e:	b085      	sub	sp, #20
 8004e70:	af00      	add	r7, sp, #0
 8004e72:	6078      	str	r0, [r7, #4]
 8004e74:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8004e76:	687b      	ldr	r3, [r7, #4]
 8004e78:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8004e7a:	683b      	ldr	r3, [r7, #0]
 8004e7c:	781b      	ldrb	r3, [r3, #0]
 8004e7e:	60bb      	str	r3, [r7, #8]

  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 8004e80:	683b      	ldr	r3, [r7, #0]
 8004e82:	785b      	ldrb	r3, [r3, #1]
 8004e84:	2b01      	cmp	r3, #1
 8004e86:	d161      	bne.n	8004f4c <USB_DeactivateEndpoint+0xe0>
  {
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8004e88:	68bb      	ldr	r3, [r7, #8]
 8004e8a:	015a      	lsls	r2, r3, #5
 8004e8c:	68fb      	ldr	r3, [r7, #12]
 8004e8e:	4413      	add	r3, r2
 8004e90:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004e94:	681b      	ldr	r3, [r3, #0]
 8004e96:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8004e9a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8004e9e:	d11f      	bne.n	8004ee0 <USB_DeactivateEndpoint+0x74>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 8004ea0:	68bb      	ldr	r3, [r7, #8]
 8004ea2:	015a      	lsls	r2, r3, #5
 8004ea4:	68fb      	ldr	r3, [r7, #12]
 8004ea6:	4413      	add	r3, r2
 8004ea8:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004eac:	681b      	ldr	r3, [r3, #0]
 8004eae:	68ba      	ldr	r2, [r7, #8]
 8004eb0:	0151      	lsls	r1, r2, #5
 8004eb2:	68fa      	ldr	r2, [r7, #12]
 8004eb4:	440a      	add	r2, r1
 8004eb6:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8004eba:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8004ebe:	6013      	str	r3, [r2, #0]
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 8004ec0:	68bb      	ldr	r3, [r7, #8]
 8004ec2:	015a      	lsls	r2, r3, #5
 8004ec4:	68fb      	ldr	r3, [r7, #12]
 8004ec6:	4413      	add	r3, r2
 8004ec8:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004ecc:	681b      	ldr	r3, [r3, #0]
 8004ece:	68ba      	ldr	r2, [r7, #8]
 8004ed0:	0151      	lsls	r1, r2, #5
 8004ed2:	68fa      	ldr	r2, [r7, #12]
 8004ed4:	440a      	add	r2, r1
 8004ed6:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8004eda:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8004ede:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8004ee0:	68fb      	ldr	r3, [r7, #12]
 8004ee2:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004ee6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8004ee8:	683b      	ldr	r3, [r7, #0]
 8004eea:	781b      	ldrb	r3, [r3, #0]
 8004eec:	f003 030f 	and.w	r3, r3, #15
 8004ef0:	2101      	movs	r1, #1
 8004ef2:	fa01 f303 	lsl.w	r3, r1, r3
 8004ef6:	b29b      	uxth	r3, r3
 8004ef8:	43db      	mvns	r3, r3
 8004efa:	68f9      	ldr	r1, [r7, #12]
 8004efc:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8004f00:	4013      	ands	r3, r2
 8004f02:	63cb      	str	r3, [r1, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8004f04:	68fb      	ldr	r3, [r7, #12]
 8004f06:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004f0a:	69da      	ldr	r2, [r3, #28]
 8004f0c:	683b      	ldr	r3, [r7, #0]
 8004f0e:	781b      	ldrb	r3, [r3, #0]
 8004f10:	f003 030f 	and.w	r3, r3, #15
 8004f14:	2101      	movs	r1, #1
 8004f16:	fa01 f303 	lsl.w	r3, r1, r3
 8004f1a:	b29b      	uxth	r3, r3
 8004f1c:	43db      	mvns	r3, r3
 8004f1e:	68f9      	ldr	r1, [r7, #12]
 8004f20:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8004f24:	4013      	ands	r3, r2
 8004f26:	61cb      	str	r3, [r1, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 8004f28:	68bb      	ldr	r3, [r7, #8]
 8004f2a:	015a      	lsls	r2, r3, #5
 8004f2c:	68fb      	ldr	r3, [r7, #12]
 8004f2e:	4413      	add	r3, r2
 8004f30:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004f34:	681a      	ldr	r2, [r3, #0]
 8004f36:	68bb      	ldr	r3, [r7, #8]
 8004f38:	0159      	lsls	r1, r3, #5
 8004f3a:	68fb      	ldr	r3, [r7, #12]
 8004f3c:	440b      	add	r3, r1
 8004f3e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8004f42:	4619      	mov	r1, r3
 8004f44:	4b35      	ldr	r3, [pc, #212]	; (800501c <USB_DeactivateEndpoint+0x1b0>)
 8004f46:	4013      	ands	r3, r2
 8004f48:	600b      	str	r3, [r1, #0]
 8004f4a:	e060      	b.n	800500e <USB_DeactivateEndpoint+0x1a2>
                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                   USB_OTG_DIEPCTL_EPTYP);
  }
  else
  {
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8004f4c:	68bb      	ldr	r3, [r7, #8]
 8004f4e:	015a      	lsls	r2, r3, #5
 8004f50:	68fb      	ldr	r3, [r7, #12]
 8004f52:	4413      	add	r3, r2
 8004f54:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004f58:	681b      	ldr	r3, [r3, #0]
 8004f5a:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8004f5e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8004f62:	d11f      	bne.n	8004fa4 <USB_DeactivateEndpoint+0x138>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 8004f64:	68bb      	ldr	r3, [r7, #8]
 8004f66:	015a      	lsls	r2, r3, #5
 8004f68:	68fb      	ldr	r3, [r7, #12]
 8004f6a:	4413      	add	r3, r2
 8004f6c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004f70:	681b      	ldr	r3, [r3, #0]
 8004f72:	68ba      	ldr	r2, [r7, #8]
 8004f74:	0151      	lsls	r1, r2, #5
 8004f76:	68fa      	ldr	r2, [r7, #12]
 8004f78:	440a      	add	r2, r1
 8004f7a:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8004f7e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 8004f82:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 8004f84:	68bb      	ldr	r3, [r7, #8]
 8004f86:	015a      	lsls	r2, r3, #5
 8004f88:	68fb      	ldr	r3, [r7, #12]
 8004f8a:	4413      	add	r3, r2
 8004f8c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004f90:	681b      	ldr	r3, [r3, #0]
 8004f92:	68ba      	ldr	r2, [r7, #8]
 8004f94:	0151      	lsls	r1, r2, #5
 8004f96:	68fa      	ldr	r2, [r7, #12]
 8004f98:	440a      	add	r2, r1
 8004f9a:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8004f9e:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8004fa2:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8004fa4:	68fb      	ldr	r3, [r7, #12]
 8004fa6:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004faa:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8004fac:	683b      	ldr	r3, [r7, #0]
 8004fae:	781b      	ldrb	r3, [r3, #0]
 8004fb0:	f003 030f 	and.w	r3, r3, #15
 8004fb4:	2101      	movs	r1, #1
 8004fb6:	fa01 f303 	lsl.w	r3, r1, r3
 8004fba:	041b      	lsls	r3, r3, #16
 8004fbc:	43db      	mvns	r3, r3
 8004fbe:	68f9      	ldr	r1, [r7, #12]
 8004fc0:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8004fc4:	4013      	ands	r3, r2
 8004fc6:	63cb      	str	r3, [r1, #60]	; 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8004fc8:	68fb      	ldr	r3, [r7, #12]
 8004fca:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004fce:	69da      	ldr	r2, [r3, #28]
 8004fd0:	683b      	ldr	r3, [r7, #0]
 8004fd2:	781b      	ldrb	r3, [r3, #0]
 8004fd4:	f003 030f 	and.w	r3, r3, #15
 8004fd8:	2101      	movs	r1, #1
 8004fda:	fa01 f303 	lsl.w	r3, r1, r3
 8004fde:	041b      	lsls	r3, r3, #16
 8004fe0:	43db      	mvns	r3, r3
 8004fe2:	68f9      	ldr	r1, [r7, #12]
 8004fe4:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8004fe8:	4013      	ands	r3, r2
 8004fea:	61cb      	str	r3, [r1, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 8004fec:	68bb      	ldr	r3, [r7, #8]
 8004fee:	015a      	lsls	r2, r3, #5
 8004ff0:	68fb      	ldr	r3, [r7, #12]
 8004ff2:	4413      	add	r3, r2
 8004ff4:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8004ff8:	681a      	ldr	r2, [r3, #0]
 8004ffa:	68bb      	ldr	r3, [r7, #8]
 8004ffc:	0159      	lsls	r1, r3, #5
 8004ffe:	68fb      	ldr	r3, [r7, #12]
 8005000:	440b      	add	r3, r1
 8005002:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005006:	4619      	mov	r1, r3
 8005008:	4b05      	ldr	r3, [pc, #20]	; (8005020 <USB_DeactivateEndpoint+0x1b4>)
 800500a:	4013      	ands	r3, r2
 800500c:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DOEPCTL_MPSIZ |
                                    USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_EPTYP);
  }

  return HAL_OK;
 800500e:	2300      	movs	r3, #0
}
 8005010:	4618      	mov	r0, r3
 8005012:	3714      	adds	r7, #20
 8005014:	46bd      	mov	sp, r7
 8005016:	f85d 7b04 	ldr.w	r7, [sp], #4
 800501a:	4770      	bx	lr
 800501c:	ec337800 	.word	0xec337800
 8005020:	eff37800 	.word	0xeff37800

08005024 <USB_EPStartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 8005024:	b580      	push	{r7, lr}
 8005026:	b08a      	sub	sp, #40	; 0x28
 8005028:	af02      	add	r7, sp, #8
 800502a:	60f8      	str	r0, [r7, #12]
 800502c:	60b9      	str	r1, [r7, #8]
 800502e:	4613      	mov	r3, r2
 8005030:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005032:	68fb      	ldr	r3, [r7, #12]
 8005034:	61fb      	str	r3, [r7, #28]
  uint32_t epnum = (uint32_t)ep->num;
 8005036:	68bb      	ldr	r3, [r7, #8]
 8005038:	781b      	ldrb	r3, [r3, #0]
 800503a:	61bb      	str	r3, [r7, #24]
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
 800503c:	68bb      	ldr	r3, [r7, #8]
 800503e:	785b      	ldrb	r3, [r3, #1]
 8005040:	2b01      	cmp	r3, #1
 8005042:	f040 815c 	bne.w	80052fe <USB_EPStartXfer+0x2da>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 8005046:	68bb      	ldr	r3, [r7, #8]
 8005048:	695b      	ldr	r3, [r3, #20]
 800504a:	2b00      	cmp	r3, #0
 800504c:	d132      	bne.n	80050b4 <USB_EPStartXfer+0x90>
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800504e:	69bb      	ldr	r3, [r7, #24]
 8005050:	015a      	lsls	r2, r3, #5
 8005052:	69fb      	ldr	r3, [r7, #28]
 8005054:	4413      	add	r3, r2
 8005056:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800505a:	691b      	ldr	r3, [r3, #16]
 800505c:	69ba      	ldr	r2, [r7, #24]
 800505e:	0151      	lsls	r1, r2, #5
 8005060:	69fa      	ldr	r2, [r7, #28]
 8005062:	440a      	add	r2, r1
 8005064:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005068:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 800506c:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8005070:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005072:	69bb      	ldr	r3, [r7, #24]
 8005074:	015a      	lsls	r2, r3, #5
 8005076:	69fb      	ldr	r3, [r7, #28]
 8005078:	4413      	add	r3, r2
 800507a:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800507e:	691b      	ldr	r3, [r3, #16]
 8005080:	69ba      	ldr	r2, [r7, #24]
 8005082:	0151      	lsls	r1, r2, #5
 8005084:	69fa      	ldr	r2, [r7, #28]
 8005086:	440a      	add	r2, r1
 8005088:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 800508c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8005090:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 8005092:	69bb      	ldr	r3, [r7, #24]
 8005094:	015a      	lsls	r2, r3, #5
 8005096:	69fb      	ldr	r3, [r7, #28]
 8005098:	4413      	add	r3, r2
 800509a:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800509e:	691b      	ldr	r3, [r3, #16]
 80050a0:	69ba      	ldr	r2, [r7, #24]
 80050a2:	0151      	lsls	r1, r2, #5
 80050a4:	69fa      	ldr	r2, [r7, #28]
 80050a6:	440a      	add	r2, r1
 80050a8:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80050ac:	0cdb      	lsrs	r3, r3, #19
 80050ae:	04db      	lsls	r3, r3, #19
 80050b0:	6113      	str	r3, [r2, #16]
 80050b2:	e074      	b.n	800519e <USB_EPStartXfer+0x17a>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 80050b4:	69bb      	ldr	r3, [r7, #24]
 80050b6:	015a      	lsls	r2, r3, #5
 80050b8:	69fb      	ldr	r3, [r7, #28]
 80050ba:	4413      	add	r3, r2
 80050bc:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80050c0:	691b      	ldr	r3, [r3, #16]
 80050c2:	69ba      	ldr	r2, [r7, #24]
 80050c4:	0151      	lsls	r1, r2, #5
 80050c6:	69fa      	ldr	r2, [r7, #28]
 80050c8:	440a      	add	r2, r1
 80050ca:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80050ce:	0cdb      	lsrs	r3, r3, #19
 80050d0:	04db      	lsls	r3, r3, #19
 80050d2:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80050d4:	69bb      	ldr	r3, [r7, #24]
 80050d6:	015a      	lsls	r2, r3, #5
 80050d8:	69fb      	ldr	r3, [r7, #28]
 80050da:	4413      	add	r3, r2
 80050dc:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80050e0:	691b      	ldr	r3, [r3, #16]
 80050e2:	69ba      	ldr	r2, [r7, #24]
 80050e4:	0151      	lsls	r1, r2, #5
 80050e6:	69fa      	ldr	r2, [r7, #28]
 80050e8:	440a      	add	r2, r1
 80050ea:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80050ee:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 80050f2:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 80050f6:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 80050f8:	69bb      	ldr	r3, [r7, #24]
 80050fa:	015a      	lsls	r2, r3, #5
 80050fc:	69fb      	ldr	r3, [r7, #28]
 80050fe:	4413      	add	r3, r2
 8005100:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005104:	691a      	ldr	r2, [r3, #16]
 8005106:	68bb      	ldr	r3, [r7, #8]
 8005108:	6959      	ldr	r1, [r3, #20]
 800510a:	68bb      	ldr	r3, [r7, #8]
 800510c:	689b      	ldr	r3, [r3, #8]
 800510e:	440b      	add	r3, r1
 8005110:	1e59      	subs	r1, r3, #1
 8005112:	68bb      	ldr	r3, [r7, #8]
 8005114:	689b      	ldr	r3, [r3, #8]
 8005116:	fbb1 f3f3 	udiv	r3, r1, r3
 800511a:	04d9      	lsls	r1, r3, #19
 800511c:	4b9d      	ldr	r3, [pc, #628]	; (8005394 <USB_EPStartXfer+0x370>)
 800511e:	400b      	ands	r3, r1
 8005120:	69b9      	ldr	r1, [r7, #24]
 8005122:	0148      	lsls	r0, r1, #5
 8005124:	69f9      	ldr	r1, [r7, #28]
 8005126:	4401      	add	r1, r0
 8005128:	f501 6110 	add.w	r1, r1, #2304	; 0x900
 800512c:	4313      	orrs	r3, r2
 800512e:	610b      	str	r3, [r1, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8005130:	69bb      	ldr	r3, [r7, #24]
 8005132:	015a      	lsls	r2, r3, #5
 8005134:	69fb      	ldr	r3, [r7, #28]
 8005136:	4413      	add	r3, r2
 8005138:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800513c:	691a      	ldr	r2, [r3, #16]
 800513e:	68bb      	ldr	r3, [r7, #8]
 8005140:	695b      	ldr	r3, [r3, #20]
 8005142:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8005146:	69b9      	ldr	r1, [r7, #24]
 8005148:	0148      	lsls	r0, r1, #5
 800514a:	69f9      	ldr	r1, [r7, #28]
 800514c:	4401      	add	r1, r0
 800514e:	f501 6110 	add.w	r1, r1, #2304	; 0x900
 8005152:	4313      	orrs	r3, r2
 8005154:	610b      	str	r3, [r1, #16]

      if (ep->type == EP_TYPE_ISOC)
 8005156:	68bb      	ldr	r3, [r7, #8]
 8005158:	78db      	ldrb	r3, [r3, #3]
 800515a:	2b01      	cmp	r3, #1
 800515c:	d11f      	bne.n	800519e <USB_EPStartXfer+0x17a>
      {
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 800515e:	69bb      	ldr	r3, [r7, #24]
 8005160:	015a      	lsls	r2, r3, #5
 8005162:	69fb      	ldr	r3, [r7, #28]
 8005164:	4413      	add	r3, r2
 8005166:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800516a:	691b      	ldr	r3, [r3, #16]
 800516c:	69ba      	ldr	r2, [r7, #24]
 800516e:	0151      	lsls	r1, r2, #5
 8005170:	69fa      	ldr	r2, [r7, #28]
 8005172:	440a      	add	r2, r1
 8005174:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005178:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 800517c:	6113      	str	r3, [r2, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 800517e:	69bb      	ldr	r3, [r7, #24]
 8005180:	015a      	lsls	r2, r3, #5
 8005182:	69fb      	ldr	r3, [r7, #28]
 8005184:	4413      	add	r3, r2
 8005186:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800518a:	691b      	ldr	r3, [r3, #16]
 800518c:	69ba      	ldr	r2, [r7, #24]
 800518e:	0151      	lsls	r1, r2, #5
 8005190:	69fa      	ldr	r2, [r7, #28]
 8005192:	440a      	add	r2, r1
 8005194:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005198:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800519c:	6113      	str	r3, [r2, #16]
      }
    }

    if (dma == 1U)
 800519e:	79fb      	ldrb	r3, [r7, #7]
 80051a0:	2b01      	cmp	r3, #1
 80051a2:	d14b      	bne.n	800523c <USB_EPStartXfer+0x218>
    {
      if ((uint32_t)ep->dma_addr != 0U)
 80051a4:	68bb      	ldr	r3, [r7, #8]
 80051a6:	691b      	ldr	r3, [r3, #16]
 80051a8:	2b00      	cmp	r3, #0
 80051aa:	d009      	beq.n	80051c0 <USB_EPStartXfer+0x19c>
      {
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 80051ac:	69bb      	ldr	r3, [r7, #24]
 80051ae:	015a      	lsls	r2, r3, #5
 80051b0:	69fb      	ldr	r3, [r7, #28]
 80051b2:	4413      	add	r3, r2
 80051b4:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80051b8:	461a      	mov	r2, r3
 80051ba:	68bb      	ldr	r3, [r7, #8]
 80051bc:	691b      	ldr	r3, [r3, #16]
 80051be:	6153      	str	r3, [r2, #20]
      }

      if (ep->type == EP_TYPE_ISOC)
 80051c0:	68bb      	ldr	r3, [r7, #8]
 80051c2:	78db      	ldrb	r3, [r3, #3]
 80051c4:	2b01      	cmp	r3, #1
 80051c6:	d128      	bne.n	800521a <USB_EPStartXfer+0x1f6>
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 80051c8:	69fb      	ldr	r3, [r7, #28]
 80051ca:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80051ce:	689b      	ldr	r3, [r3, #8]
 80051d0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80051d4:	2b00      	cmp	r3, #0
 80051d6:	d110      	bne.n	80051fa <USB_EPStartXfer+0x1d6>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 80051d8:	69bb      	ldr	r3, [r7, #24]
 80051da:	015a      	lsls	r2, r3, #5
 80051dc:	69fb      	ldr	r3, [r7, #28]
 80051de:	4413      	add	r3, r2
 80051e0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80051e4:	681b      	ldr	r3, [r3, #0]
 80051e6:	69ba      	ldr	r2, [r7, #24]
 80051e8:	0151      	lsls	r1, r2, #5
 80051ea:	69fa      	ldr	r2, [r7, #28]
 80051ec:	440a      	add	r2, r1
 80051ee:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80051f2:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80051f6:	6013      	str	r3, [r2, #0]
 80051f8:	e00f      	b.n	800521a <USB_EPStartXfer+0x1f6>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 80051fa:	69bb      	ldr	r3, [r7, #24]
 80051fc:	015a      	lsls	r2, r3, #5
 80051fe:	69fb      	ldr	r3, [r7, #28]
 8005200:	4413      	add	r3, r2
 8005202:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005206:	681b      	ldr	r3, [r3, #0]
 8005208:	69ba      	ldr	r2, [r7, #24]
 800520a:	0151      	lsls	r1, r2, #5
 800520c:	69fa      	ldr	r2, [r7, #28]
 800520e:	440a      	add	r2, r1
 8005210:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005214:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005218:	6013      	str	r3, [r2, #0]
        }
      }

      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800521a:	69bb      	ldr	r3, [r7, #24]
 800521c:	015a      	lsls	r2, r3, #5
 800521e:	69fb      	ldr	r3, [r7, #28]
 8005220:	4413      	add	r3, r2
 8005222:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005226:	681b      	ldr	r3, [r3, #0]
 8005228:	69ba      	ldr	r2, [r7, #24]
 800522a:	0151      	lsls	r1, r2, #5
 800522c:	69fa      	ldr	r2, [r7, #28]
 800522e:	440a      	add	r2, r1
 8005230:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005234:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8005238:	6013      	str	r3, [r2, #0]
 800523a:	e12f      	b.n	800549c <USB_EPStartXfer+0x478>
    }
    else
    {
      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800523c:	69bb      	ldr	r3, [r7, #24]
 800523e:	015a      	lsls	r2, r3, #5
 8005240:	69fb      	ldr	r3, [r7, #28]
 8005242:	4413      	add	r3, r2
 8005244:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005248:	681b      	ldr	r3, [r3, #0]
 800524a:	69ba      	ldr	r2, [r7, #24]
 800524c:	0151      	lsls	r1, r2, #5
 800524e:	69fa      	ldr	r2, [r7, #28]
 8005250:	440a      	add	r2, r1
 8005252:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005256:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800525a:	6013      	str	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 800525c:	68bb      	ldr	r3, [r7, #8]
 800525e:	78db      	ldrb	r3, [r3, #3]
 8005260:	2b01      	cmp	r3, #1
 8005262:	d015      	beq.n	8005290 <USB_EPStartXfer+0x26c>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 8005264:	68bb      	ldr	r3, [r7, #8]
 8005266:	695b      	ldr	r3, [r3, #20]
 8005268:	2b00      	cmp	r3, #0
 800526a:	f000 8117 	beq.w	800549c <USB_EPStartXfer+0x478>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 800526e:	69fb      	ldr	r3, [r7, #28]
 8005270:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005274:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005276:	68bb      	ldr	r3, [r7, #8]
 8005278:	781b      	ldrb	r3, [r3, #0]
 800527a:	f003 030f 	and.w	r3, r3, #15
 800527e:	2101      	movs	r1, #1
 8005280:	fa01 f303 	lsl.w	r3, r1, r3
 8005284:	69f9      	ldr	r1, [r7, #28]
 8005286:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 800528a:	4313      	orrs	r3, r2
 800528c:	634b      	str	r3, [r1, #52]	; 0x34
 800528e:	e105      	b.n	800549c <USB_EPStartXfer+0x478>
        }
      }
      else
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8005290:	69fb      	ldr	r3, [r7, #28]
 8005292:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005296:	689b      	ldr	r3, [r3, #8]
 8005298:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800529c:	2b00      	cmp	r3, #0
 800529e:	d110      	bne.n	80052c2 <USB_EPStartXfer+0x29e>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 80052a0:	69bb      	ldr	r3, [r7, #24]
 80052a2:	015a      	lsls	r2, r3, #5
 80052a4:	69fb      	ldr	r3, [r7, #28]
 80052a6:	4413      	add	r3, r2
 80052a8:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80052ac:	681b      	ldr	r3, [r3, #0]
 80052ae:	69ba      	ldr	r2, [r7, #24]
 80052b0:	0151      	lsls	r1, r2, #5
 80052b2:	69fa      	ldr	r2, [r7, #28]
 80052b4:	440a      	add	r2, r1
 80052b6:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80052ba:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80052be:	6013      	str	r3, [r2, #0]
 80052c0:	e00f      	b.n	80052e2 <USB_EPStartXfer+0x2be>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 80052c2:	69bb      	ldr	r3, [r7, #24]
 80052c4:	015a      	lsls	r2, r3, #5
 80052c6:	69fb      	ldr	r3, [r7, #28]
 80052c8:	4413      	add	r3, r2
 80052ca:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80052ce:	681b      	ldr	r3, [r3, #0]
 80052d0:	69ba      	ldr	r2, [r7, #24]
 80052d2:	0151      	lsls	r1, r2, #5
 80052d4:	69fa      	ldr	r2, [r7, #28]
 80052d6:	440a      	add	r2, r1
 80052d8:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80052dc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80052e0:	6013      	str	r3, [r2, #0]
        }

        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 80052e2:	68bb      	ldr	r3, [r7, #8]
 80052e4:	68d9      	ldr	r1, [r3, #12]
 80052e6:	68bb      	ldr	r3, [r7, #8]
 80052e8:	781a      	ldrb	r2, [r3, #0]
 80052ea:	68bb      	ldr	r3, [r7, #8]
 80052ec:	695b      	ldr	r3, [r3, #20]
 80052ee:	b298      	uxth	r0, r3
 80052f0:	79fb      	ldrb	r3, [r7, #7]
 80052f2:	9300      	str	r3, [sp, #0]
 80052f4:	4603      	mov	r3, r0
 80052f6:	68f8      	ldr	r0, [r7, #12]
 80052f8:	f000 fa2b 	bl	8005752 <USB_WritePacket>
 80052fc:	e0ce      	b.n	800549c <USB_EPStartXfer+0x478>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 80052fe:	69bb      	ldr	r3, [r7, #24]
 8005300:	015a      	lsls	r2, r3, #5
 8005302:	69fb      	ldr	r3, [r7, #28]
 8005304:	4413      	add	r3, r2
 8005306:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 800530a:	691b      	ldr	r3, [r3, #16]
 800530c:	69ba      	ldr	r2, [r7, #24]
 800530e:	0151      	lsls	r1, r2, #5
 8005310:	69fa      	ldr	r2, [r7, #28]
 8005312:	440a      	add	r2, r1
 8005314:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8005318:	0cdb      	lsrs	r3, r3, #19
 800531a:	04db      	lsls	r3, r3, #19
 800531c:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 800531e:	69bb      	ldr	r3, [r7, #24]
 8005320:	015a      	lsls	r2, r3, #5
 8005322:	69fb      	ldr	r3, [r7, #28]
 8005324:	4413      	add	r3, r2
 8005326:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 800532a:	691b      	ldr	r3, [r3, #16]
 800532c:	69ba      	ldr	r2, [r7, #24]
 800532e:	0151      	lsls	r1, r2, #5
 8005330:	69fa      	ldr	r2, [r7, #28]
 8005332:	440a      	add	r2, r1
 8005334:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8005338:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 800533c:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 8005340:	6113      	str	r3, [r2, #16]

    if (ep->xfer_len == 0U)
 8005342:	68bb      	ldr	r3, [r7, #8]
 8005344:	695b      	ldr	r3, [r3, #20]
 8005346:	2b00      	cmp	r3, #0
 8005348:	d126      	bne.n	8005398 <USB_EPStartXfer+0x374>
    {
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 800534a:	69bb      	ldr	r3, [r7, #24]
 800534c:	015a      	lsls	r2, r3, #5
 800534e:	69fb      	ldr	r3, [r7, #28]
 8005350:	4413      	add	r3, r2
 8005352:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005356:	691a      	ldr	r2, [r3, #16]
 8005358:	68bb      	ldr	r3, [r7, #8]
 800535a:	689b      	ldr	r3, [r3, #8]
 800535c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8005360:	69b9      	ldr	r1, [r7, #24]
 8005362:	0148      	lsls	r0, r1, #5
 8005364:	69f9      	ldr	r1, [r7, #28]
 8005366:	4401      	add	r1, r0
 8005368:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 800536c:	4313      	orrs	r3, r2
 800536e:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8005370:	69bb      	ldr	r3, [r7, #24]
 8005372:	015a      	lsls	r2, r3, #5
 8005374:	69fb      	ldr	r3, [r7, #28]
 8005376:	4413      	add	r3, r2
 8005378:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 800537c:	691b      	ldr	r3, [r3, #16]
 800537e:	69ba      	ldr	r2, [r7, #24]
 8005380:	0151      	lsls	r1, r2, #5
 8005382:	69fa      	ldr	r2, [r7, #28]
 8005384:	440a      	add	r2, r1
 8005386:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 800538a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800538e:	6113      	str	r3, [r2, #16]
 8005390:	e036      	b.n	8005400 <USB_EPStartXfer+0x3dc>
 8005392:	bf00      	nop
 8005394:	1ff80000 	.word	0x1ff80000
    }
    else
    {
      pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 8005398:	68bb      	ldr	r3, [r7, #8]
 800539a:	695a      	ldr	r2, [r3, #20]
 800539c:	68bb      	ldr	r3, [r7, #8]
 800539e:	689b      	ldr	r3, [r3, #8]
 80053a0:	4413      	add	r3, r2
 80053a2:	1e5a      	subs	r2, r3, #1
 80053a4:	68bb      	ldr	r3, [r7, #8]
 80053a6:	689b      	ldr	r3, [r3, #8]
 80053a8:	fbb2 f3f3 	udiv	r3, r2, r3
 80053ac:	82fb      	strh	r3, [r7, #22]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 80053ae:	69bb      	ldr	r3, [r7, #24]
 80053b0:	015a      	lsls	r2, r3, #5
 80053b2:	69fb      	ldr	r3, [r7, #28]
 80053b4:	4413      	add	r3, r2
 80053b6:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80053ba:	691a      	ldr	r2, [r3, #16]
 80053bc:	8afb      	ldrh	r3, [r7, #22]
 80053be:	04d9      	lsls	r1, r3, #19
 80053c0:	4b39      	ldr	r3, [pc, #228]	; (80054a8 <USB_EPStartXfer+0x484>)
 80053c2:	400b      	ands	r3, r1
 80053c4:	69b9      	ldr	r1, [r7, #24]
 80053c6:	0148      	lsls	r0, r1, #5
 80053c8:	69f9      	ldr	r1, [r7, #28]
 80053ca:	4401      	add	r1, r0
 80053cc:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 80053d0:	4313      	orrs	r3, r2
 80053d2:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket * pktcnt);
 80053d4:	69bb      	ldr	r3, [r7, #24]
 80053d6:	015a      	lsls	r2, r3, #5
 80053d8:	69fb      	ldr	r3, [r7, #28]
 80053da:	4413      	add	r3, r2
 80053dc:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80053e0:	691a      	ldr	r2, [r3, #16]
 80053e2:	68bb      	ldr	r3, [r7, #8]
 80053e4:	689b      	ldr	r3, [r3, #8]
 80053e6:	8af9      	ldrh	r1, [r7, #22]
 80053e8:	fb01 f303 	mul.w	r3, r1, r3
 80053ec:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80053f0:	69b9      	ldr	r1, [r7, #24]
 80053f2:	0148      	lsls	r0, r1, #5
 80053f4:	69f9      	ldr	r1, [r7, #28]
 80053f6:	4401      	add	r1, r0
 80053f8:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 80053fc:	4313      	orrs	r3, r2
 80053fe:	610b      	str	r3, [r1, #16]
    }

    if (dma == 1U)
 8005400:	79fb      	ldrb	r3, [r7, #7]
 8005402:	2b01      	cmp	r3, #1
 8005404:	d10d      	bne.n	8005422 <USB_EPStartXfer+0x3fe>
    {
      if ((uint32_t)ep->xfer_buff != 0U)
 8005406:	68bb      	ldr	r3, [r7, #8]
 8005408:	68db      	ldr	r3, [r3, #12]
 800540a:	2b00      	cmp	r3, #0
 800540c:	d009      	beq.n	8005422 <USB_EPStartXfer+0x3fe>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 800540e:	68bb      	ldr	r3, [r7, #8]
 8005410:	68d9      	ldr	r1, [r3, #12]
 8005412:	69bb      	ldr	r3, [r7, #24]
 8005414:	015a      	lsls	r2, r3, #5
 8005416:	69fb      	ldr	r3, [r7, #28]
 8005418:	4413      	add	r3, r2
 800541a:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 800541e:	460a      	mov	r2, r1
 8005420:	615a      	str	r2, [r3, #20]
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 8005422:	68bb      	ldr	r3, [r7, #8]
 8005424:	78db      	ldrb	r3, [r3, #3]
 8005426:	2b01      	cmp	r3, #1
 8005428:	d128      	bne.n	800547c <USB_EPStartXfer+0x458>
    {
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 800542a:	69fb      	ldr	r3, [r7, #28]
 800542c:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005430:	689b      	ldr	r3, [r3, #8]
 8005432:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8005436:	2b00      	cmp	r3, #0
 8005438:	d110      	bne.n	800545c <USB_EPStartXfer+0x438>
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 800543a:	69bb      	ldr	r3, [r7, #24]
 800543c:	015a      	lsls	r2, r3, #5
 800543e:	69fb      	ldr	r3, [r7, #28]
 8005440:	4413      	add	r3, r2
 8005442:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005446:	681b      	ldr	r3, [r3, #0]
 8005448:	69ba      	ldr	r2, [r7, #24]
 800544a:	0151      	lsls	r1, r2, #5
 800544c:	69fa      	ldr	r2, [r7, #28]
 800544e:	440a      	add	r2, r1
 8005450:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8005454:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8005458:	6013      	str	r3, [r2, #0]
 800545a:	e00f      	b.n	800547c <USB_EPStartXfer+0x458>
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 800545c:	69bb      	ldr	r3, [r7, #24]
 800545e:	015a      	lsls	r2, r3, #5
 8005460:	69fb      	ldr	r3, [r7, #28]
 8005462:	4413      	add	r3, r2
 8005464:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005468:	681b      	ldr	r3, [r3, #0]
 800546a:	69ba      	ldr	r2, [r7, #24]
 800546c:	0151      	lsls	r1, r2, #5
 800546e:	69fa      	ldr	r2, [r7, #28]
 8005470:	440a      	add	r2, r1
 8005472:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8005476:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800547a:	6013      	str	r3, [r2, #0]
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 800547c:	69bb      	ldr	r3, [r7, #24]
 800547e:	015a      	lsls	r2, r3, #5
 8005480:	69fb      	ldr	r3, [r7, #28]
 8005482:	4413      	add	r3, r2
 8005484:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005488:	681b      	ldr	r3, [r3, #0]
 800548a:	69ba      	ldr	r2, [r7, #24]
 800548c:	0151      	lsls	r1, r2, #5
 800548e:	69fa      	ldr	r2, [r7, #28]
 8005490:	440a      	add	r2, r1
 8005492:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8005496:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800549a:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 800549c:	2300      	movs	r3, #0
}
 800549e:	4618      	mov	r0, r3
 80054a0:	3720      	adds	r7, #32
 80054a2:	46bd      	mov	sp, r7
 80054a4:	bd80      	pop	{r7, pc}
 80054a6:	bf00      	nop
 80054a8:	1ff80000 	.word	0x1ff80000

080054ac <USB_EP0StartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 80054ac:	b480      	push	{r7}
 80054ae:	b087      	sub	sp, #28
 80054b0:	af00      	add	r7, sp, #0
 80054b2:	60f8      	str	r0, [r7, #12]
 80054b4:	60b9      	str	r1, [r7, #8]
 80054b6:	4613      	mov	r3, r2
 80054b8:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80054ba:	68fb      	ldr	r3, [r7, #12]
 80054bc:	617b      	str	r3, [r7, #20]
  uint32_t epnum = (uint32_t)ep->num;
 80054be:	68bb      	ldr	r3, [r7, #8]
 80054c0:	781b      	ldrb	r3, [r3, #0]
 80054c2:	613b      	str	r3, [r7, #16]

  /* IN endpoint */
  if (ep->is_in == 1U)
 80054c4:	68bb      	ldr	r3, [r7, #8]
 80054c6:	785b      	ldrb	r3, [r3, #1]
 80054c8:	2b01      	cmp	r3, #1
 80054ca:	f040 80cd 	bne.w	8005668 <USB_EP0StartXfer+0x1bc>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 80054ce:	68bb      	ldr	r3, [r7, #8]
 80054d0:	695b      	ldr	r3, [r3, #20]
 80054d2:	2b00      	cmp	r3, #0
 80054d4:	d132      	bne.n	800553c <USB_EP0StartXfer+0x90>
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 80054d6:	693b      	ldr	r3, [r7, #16]
 80054d8:	015a      	lsls	r2, r3, #5
 80054da:	697b      	ldr	r3, [r7, #20]
 80054dc:	4413      	add	r3, r2
 80054de:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80054e2:	691b      	ldr	r3, [r3, #16]
 80054e4:	693a      	ldr	r2, [r7, #16]
 80054e6:	0151      	lsls	r1, r2, #5
 80054e8:	697a      	ldr	r2, [r7, #20]
 80054ea:	440a      	add	r2, r1
 80054ec:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80054f0:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 80054f4:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 80054f8:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80054fa:	693b      	ldr	r3, [r7, #16]
 80054fc:	015a      	lsls	r2, r3, #5
 80054fe:	697b      	ldr	r3, [r7, #20]
 8005500:	4413      	add	r3, r2
 8005502:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005506:	691b      	ldr	r3, [r3, #16]
 8005508:	693a      	ldr	r2, [r7, #16]
 800550a:	0151      	lsls	r1, r2, #5
 800550c:	697a      	ldr	r2, [r7, #20]
 800550e:	440a      	add	r2, r1
 8005510:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005514:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8005518:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800551a:	693b      	ldr	r3, [r7, #16]
 800551c:	015a      	lsls	r2, r3, #5
 800551e:	697b      	ldr	r3, [r7, #20]
 8005520:	4413      	add	r3, r2
 8005522:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005526:	691b      	ldr	r3, [r3, #16]
 8005528:	693a      	ldr	r2, [r7, #16]
 800552a:	0151      	lsls	r1, r2, #5
 800552c:	697a      	ldr	r2, [r7, #20]
 800552e:	440a      	add	r2, r1
 8005530:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005534:	0cdb      	lsrs	r3, r3, #19
 8005536:	04db      	lsls	r3, r3, #19
 8005538:	6113      	str	r3, [r2, #16]
 800553a:	e04e      	b.n	80055da <USB_EP0StartXfer+0x12e>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 800553c:	693b      	ldr	r3, [r7, #16]
 800553e:	015a      	lsls	r2, r3, #5
 8005540:	697b      	ldr	r3, [r7, #20]
 8005542:	4413      	add	r3, r2
 8005544:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005548:	691b      	ldr	r3, [r3, #16]
 800554a:	693a      	ldr	r2, [r7, #16]
 800554c:	0151      	lsls	r1, r2, #5
 800554e:	697a      	ldr	r2, [r7, #20]
 8005550:	440a      	add	r2, r1
 8005552:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005556:	0cdb      	lsrs	r3, r3, #19
 8005558:	04db      	lsls	r3, r3, #19
 800555a:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 800555c:	693b      	ldr	r3, [r7, #16]
 800555e:	015a      	lsls	r2, r3, #5
 8005560:	697b      	ldr	r3, [r7, #20]
 8005562:	4413      	add	r3, r2
 8005564:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005568:	691b      	ldr	r3, [r3, #16]
 800556a:	693a      	ldr	r2, [r7, #16]
 800556c:	0151      	lsls	r1, r2, #5
 800556e:	697a      	ldr	r2, [r7, #20]
 8005570:	440a      	add	r2, r1
 8005572:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005576:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 800557a:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 800557e:	6113      	str	r3, [r2, #16]

      if (ep->xfer_len > ep->maxpacket)
 8005580:	68bb      	ldr	r3, [r7, #8]
 8005582:	695a      	ldr	r2, [r3, #20]
 8005584:	68bb      	ldr	r3, [r7, #8]
 8005586:	689b      	ldr	r3, [r3, #8]
 8005588:	429a      	cmp	r2, r3
 800558a:	d903      	bls.n	8005594 <USB_EP0StartXfer+0xe8>
      {
        ep->xfer_len = ep->maxpacket;
 800558c:	68bb      	ldr	r3, [r7, #8]
 800558e:	689a      	ldr	r2, [r3, #8]
 8005590:	68bb      	ldr	r3, [r7, #8]
 8005592:	615a      	str	r2, [r3, #20]
      }
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 8005594:	693b      	ldr	r3, [r7, #16]
 8005596:	015a      	lsls	r2, r3, #5
 8005598:	697b      	ldr	r3, [r7, #20]
 800559a:	4413      	add	r3, r2
 800559c:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80055a0:	691b      	ldr	r3, [r3, #16]
 80055a2:	693a      	ldr	r2, [r7, #16]
 80055a4:	0151      	lsls	r1, r2, #5
 80055a6:	697a      	ldr	r2, [r7, #20]
 80055a8:	440a      	add	r2, r1
 80055aa:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 80055ae:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80055b2:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 80055b4:	693b      	ldr	r3, [r7, #16]
 80055b6:	015a      	lsls	r2, r3, #5
 80055b8:	697b      	ldr	r3, [r7, #20]
 80055ba:	4413      	add	r3, r2
 80055bc:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80055c0:	691a      	ldr	r2, [r3, #16]
 80055c2:	68bb      	ldr	r3, [r7, #8]
 80055c4:	695b      	ldr	r3, [r3, #20]
 80055c6:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80055ca:	6939      	ldr	r1, [r7, #16]
 80055cc:	0148      	lsls	r0, r1, #5
 80055ce:	6979      	ldr	r1, [r7, #20]
 80055d0:	4401      	add	r1, r0
 80055d2:	f501 6110 	add.w	r1, r1, #2304	; 0x900
 80055d6:	4313      	orrs	r3, r2
 80055d8:	610b      	str	r3, [r1, #16]
    }

    if (dma == 1U)
 80055da:	79fb      	ldrb	r3, [r7, #7]
 80055dc:	2b01      	cmp	r3, #1
 80055de:	d11e      	bne.n	800561e <USB_EP0StartXfer+0x172>
    {
      if ((uint32_t)ep->dma_addr != 0U)
 80055e0:	68bb      	ldr	r3, [r7, #8]
 80055e2:	691b      	ldr	r3, [r3, #16]
 80055e4:	2b00      	cmp	r3, #0
 80055e6:	d009      	beq.n	80055fc <USB_EP0StartXfer+0x150>
      {
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 80055e8:	693b      	ldr	r3, [r7, #16]
 80055ea:	015a      	lsls	r2, r3, #5
 80055ec:	697b      	ldr	r3, [r7, #20]
 80055ee:	4413      	add	r3, r2
 80055f0:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 80055f4:	461a      	mov	r2, r3
 80055f6:	68bb      	ldr	r3, [r7, #8]
 80055f8:	691b      	ldr	r3, [r3, #16]
 80055fa:	6153      	str	r3, [r2, #20]
      }

      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 80055fc:	693b      	ldr	r3, [r7, #16]
 80055fe:	015a      	lsls	r2, r3, #5
 8005600:	697b      	ldr	r3, [r7, #20]
 8005602:	4413      	add	r3, r2
 8005604:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005608:	681b      	ldr	r3, [r3, #0]
 800560a:	693a      	ldr	r2, [r7, #16]
 800560c:	0151      	lsls	r1, r2, #5
 800560e:	697a      	ldr	r2, [r7, #20]
 8005610:	440a      	add	r2, r1
 8005612:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005616:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800561a:	6013      	str	r3, [r2, #0]
 800561c:	e092      	b.n	8005744 <USB_EP0StartXfer+0x298>
    }
    else
    {
      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 800561e:	693b      	ldr	r3, [r7, #16]
 8005620:	015a      	lsls	r2, r3, #5
 8005622:	697b      	ldr	r3, [r7, #20]
 8005624:	4413      	add	r3, r2
 8005626:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800562a:	681b      	ldr	r3, [r3, #0]
 800562c:	693a      	ldr	r2, [r7, #16]
 800562e:	0151      	lsls	r1, r2, #5
 8005630:	697a      	ldr	r2, [r7, #20]
 8005632:	440a      	add	r2, r1
 8005634:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005638:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800563c:	6013      	str	r3, [r2, #0]

      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0U)
 800563e:	68bb      	ldr	r3, [r7, #8]
 8005640:	695b      	ldr	r3, [r3, #20]
 8005642:	2b00      	cmp	r3, #0
 8005644:	d07e      	beq.n	8005744 <USB_EP0StartXfer+0x298>
      {
        USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8005646:	697b      	ldr	r3, [r7, #20]
 8005648:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 800564c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800564e:	68bb      	ldr	r3, [r7, #8]
 8005650:	781b      	ldrb	r3, [r3, #0]
 8005652:	f003 030f 	and.w	r3, r3, #15
 8005656:	2101      	movs	r1, #1
 8005658:	fa01 f303 	lsl.w	r3, r1, r3
 800565c:	6979      	ldr	r1, [r7, #20]
 800565e:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 8005662:	4313      	orrs	r3, r2
 8005664:	634b      	str	r3, [r1, #52]	; 0x34
 8005666:	e06d      	b.n	8005744 <USB_EP0StartXfer+0x298>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 8005668:	693b      	ldr	r3, [r7, #16]
 800566a:	015a      	lsls	r2, r3, #5
 800566c:	697b      	ldr	r3, [r7, #20]
 800566e:	4413      	add	r3, r2
 8005670:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005674:	691b      	ldr	r3, [r3, #16]
 8005676:	693a      	ldr	r2, [r7, #16]
 8005678:	0151      	lsls	r1, r2, #5
 800567a:	697a      	ldr	r2, [r7, #20]
 800567c:	440a      	add	r2, r1
 800567e:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8005682:	0cdb      	lsrs	r3, r3, #19
 8005684:	04db      	lsls	r3, r3, #19
 8005686:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8005688:	693b      	ldr	r3, [r7, #16]
 800568a:	015a      	lsls	r2, r3, #5
 800568c:	697b      	ldr	r3, [r7, #20]
 800568e:	4413      	add	r3, r2
 8005690:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005694:	691b      	ldr	r3, [r3, #16]
 8005696:	693a      	ldr	r2, [r7, #16]
 8005698:	0151      	lsls	r1, r2, #5
 800569a:	697a      	ldr	r2, [r7, #20]
 800569c:	440a      	add	r2, r1
 800569e:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 80056a2:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
 80056a6:	f423 13c0 	bic.w	r3, r3, #1572864	; 0x180000
 80056aa:	6113      	str	r3, [r2, #16]

    if (ep->xfer_len > 0U)
 80056ac:	68bb      	ldr	r3, [r7, #8]
 80056ae:	695b      	ldr	r3, [r3, #20]
 80056b0:	2b00      	cmp	r3, #0
 80056b2:	d003      	beq.n	80056bc <USB_EP0StartXfer+0x210>
    {
      ep->xfer_len = ep->maxpacket;
 80056b4:	68bb      	ldr	r3, [r7, #8]
 80056b6:	689a      	ldr	r2, [r3, #8]
 80056b8:	68bb      	ldr	r3, [r7, #8]
 80056ba:	615a      	str	r2, [r3, #20]
    }

    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 80056bc:	693b      	ldr	r3, [r7, #16]
 80056be:	015a      	lsls	r2, r3, #5
 80056c0:	697b      	ldr	r3, [r7, #20]
 80056c2:	4413      	add	r3, r2
 80056c4:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80056c8:	691b      	ldr	r3, [r3, #16]
 80056ca:	693a      	ldr	r2, [r7, #16]
 80056cc:	0151      	lsls	r1, r2, #5
 80056ce:	697a      	ldr	r2, [r7, #20]
 80056d0:	440a      	add	r2, r1
 80056d2:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 80056d6:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80056da:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & (ep->maxpacket));
 80056dc:	693b      	ldr	r3, [r7, #16]
 80056de:	015a      	lsls	r2, r3, #5
 80056e0:	697b      	ldr	r3, [r7, #20]
 80056e2:	4413      	add	r3, r2
 80056e4:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80056e8:	691a      	ldr	r2, [r3, #16]
 80056ea:	68bb      	ldr	r3, [r7, #8]
 80056ec:	689b      	ldr	r3, [r3, #8]
 80056ee:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80056f2:	6939      	ldr	r1, [r7, #16]
 80056f4:	0148      	lsls	r0, r1, #5
 80056f6:	6979      	ldr	r1, [r7, #20]
 80056f8:	4401      	add	r1, r0
 80056fa:	f501 6130 	add.w	r1, r1, #2816	; 0xb00
 80056fe:	4313      	orrs	r3, r2
 8005700:	610b      	str	r3, [r1, #16]

    if (dma == 1U)
 8005702:	79fb      	ldrb	r3, [r7, #7]
 8005704:	2b01      	cmp	r3, #1
 8005706:	d10d      	bne.n	8005724 <USB_EP0StartXfer+0x278>
    {
      if ((uint32_t)ep->xfer_buff != 0U)
 8005708:	68bb      	ldr	r3, [r7, #8]
 800570a:	68db      	ldr	r3, [r3, #12]
 800570c:	2b00      	cmp	r3, #0
 800570e:	d009      	beq.n	8005724 <USB_EP0StartXfer+0x278>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 8005710:	68bb      	ldr	r3, [r7, #8]
 8005712:	68d9      	ldr	r1, [r3, #12]
 8005714:	693b      	ldr	r3, [r7, #16]
 8005716:	015a      	lsls	r2, r3, #5
 8005718:	697b      	ldr	r3, [r7, #20]
 800571a:	4413      	add	r3, r2
 800571c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005720:	460a      	mov	r2, r1
 8005722:	615a      	str	r2, [r3, #20]
      }
    }

    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 8005724:	693b      	ldr	r3, [r7, #16]
 8005726:	015a      	lsls	r2, r3, #5
 8005728:	697b      	ldr	r3, [r7, #20]
 800572a:	4413      	add	r3, r2
 800572c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005730:	681b      	ldr	r3, [r3, #0]
 8005732:	693a      	ldr	r2, [r7, #16]
 8005734:	0151      	lsls	r1, r2, #5
 8005736:	697a      	ldr	r2, [r7, #20]
 8005738:	440a      	add	r2, r1
 800573a:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 800573e:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8005742:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8005744:	2300      	movs	r3, #0
}
 8005746:	4618      	mov	r0, r3
 8005748:	371c      	adds	r7, #28
 800574a:	46bd      	mov	sp, r7
 800574c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005750:	4770      	bx	lr

08005752 <USB_WritePacket>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 8005752:	b480      	push	{r7}
 8005754:	b089      	sub	sp, #36	; 0x24
 8005756:	af00      	add	r7, sp, #0
 8005758:	60f8      	str	r0, [r7, #12]
 800575a:	60b9      	str	r1, [r7, #8]
 800575c:	4611      	mov	r1, r2
 800575e:	461a      	mov	r2, r3
 8005760:	460b      	mov	r3, r1
 8005762:	71fb      	strb	r3, [r7, #7]
 8005764:	4613      	mov	r3, r2
 8005766:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005768:	68fb      	ldr	r3, [r7, #12]
 800576a:	617b      	str	r3, [r7, #20]
  uint32_t *pSrc = (uint32_t *)src;
 800576c:	68bb      	ldr	r3, [r7, #8]
 800576e:	61fb      	str	r3, [r7, #28]
  uint32_t count32b, i;

  if (dma == 0U)
 8005770:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8005774:	2b00      	cmp	r3, #0
 8005776:	d11a      	bne.n	80057ae <USB_WritePacket+0x5c>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 8005778:	88bb      	ldrh	r3, [r7, #4]
 800577a:	3303      	adds	r3, #3
 800577c:	089b      	lsrs	r3, r3, #2
 800577e:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
 8005780:	2300      	movs	r3, #0
 8005782:	61bb      	str	r3, [r7, #24]
 8005784:	e00f      	b.n	80057a6 <USB_WritePacket+0x54>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8005786:	79fb      	ldrb	r3, [r7, #7]
 8005788:	031a      	lsls	r2, r3, #12
 800578a:	697b      	ldr	r3, [r7, #20]
 800578c:	4413      	add	r3, r2
 800578e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8005792:	461a      	mov	r2, r3
 8005794:	69fb      	ldr	r3, [r7, #28]
 8005796:	681b      	ldr	r3, [r3, #0]
 8005798:	6013      	str	r3, [r2, #0]
      pSrc++;
 800579a:	69fb      	ldr	r3, [r7, #28]
 800579c:	3304      	adds	r3, #4
 800579e:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
 80057a0:	69bb      	ldr	r3, [r7, #24]
 80057a2:	3301      	adds	r3, #1
 80057a4:	61bb      	str	r3, [r7, #24]
 80057a6:	69ba      	ldr	r2, [r7, #24]
 80057a8:	693b      	ldr	r3, [r7, #16]
 80057aa:	429a      	cmp	r2, r3
 80057ac:	d3eb      	bcc.n	8005786 <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
 80057ae:	2300      	movs	r3, #0
}
 80057b0:	4618      	mov	r0, r3
 80057b2:	3724      	adds	r7, #36	; 0x24
 80057b4:	46bd      	mov	sp, r7
 80057b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80057ba:	4770      	bx	lr

080057bc <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 80057bc:	b480      	push	{r7}
 80057be:	b089      	sub	sp, #36	; 0x24
 80057c0:	af00      	add	r7, sp, #0
 80057c2:	60f8      	str	r0, [r7, #12]
 80057c4:	60b9      	str	r1, [r7, #8]
 80057c6:	4613      	mov	r3, r2
 80057c8:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80057ca:	68fb      	ldr	r3, [r7, #12]
 80057cc:	617b      	str	r3, [r7, #20]
  uint32_t *pDest = (uint32_t *)dest;
 80057ce:	68bb      	ldr	r3, [r7, #8]
 80057d0:	61fb      	str	r3, [r7, #28]
  uint32_t i;
  uint32_t count32b = ((uint32_t)len + 3U) / 4U;
 80057d2:	88fb      	ldrh	r3, [r7, #6]
 80057d4:	3303      	adds	r3, #3
 80057d6:	089b      	lsrs	r3, r3, #2
 80057d8:	613b      	str	r3, [r7, #16]

  for (i = 0U; i < count32b; i++)
 80057da:	2300      	movs	r3, #0
 80057dc:	61bb      	str	r3, [r7, #24]
 80057de:	e00b      	b.n	80057f8 <USB_ReadPacket+0x3c>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 80057e0:	697b      	ldr	r3, [r7, #20]
 80057e2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80057e6:	681a      	ldr	r2, [r3, #0]
 80057e8:	69fb      	ldr	r3, [r7, #28]
 80057ea:	601a      	str	r2, [r3, #0]
    pDest++;
 80057ec:	69fb      	ldr	r3, [r7, #28]
 80057ee:	3304      	adds	r3, #4
 80057f0:	61fb      	str	r3, [r7, #28]
  for (i = 0U; i < count32b; i++)
 80057f2:	69bb      	ldr	r3, [r7, #24]
 80057f4:	3301      	adds	r3, #1
 80057f6:	61bb      	str	r3, [r7, #24]
 80057f8:	69ba      	ldr	r2, [r7, #24]
 80057fa:	693b      	ldr	r3, [r7, #16]
 80057fc:	429a      	cmp	r2, r3
 80057fe:	d3ef      	bcc.n	80057e0 <USB_ReadPacket+0x24>
  }

  return ((void *)pDest);
 8005800:	69fb      	ldr	r3, [r7, #28]
}
 8005802:	4618      	mov	r0, r3
 8005804:	3724      	adds	r7, #36	; 0x24
 8005806:	46bd      	mov	sp, r7
 8005808:	f85d 7b04 	ldr.w	r7, [sp], #4
 800580c:	4770      	bx	lr

0800580e <USB_EPSetStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 800580e:	b480      	push	{r7}
 8005810:	b085      	sub	sp, #20
 8005812:	af00      	add	r7, sp, #0
 8005814:	6078      	str	r0, [r7, #4]
 8005816:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005818:	687b      	ldr	r3, [r7, #4]
 800581a:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 800581c:	683b      	ldr	r3, [r7, #0]
 800581e:	781b      	ldrb	r3, [r3, #0]
 8005820:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 8005822:	683b      	ldr	r3, [r7, #0]
 8005824:	785b      	ldrb	r3, [r3, #1]
 8005826:	2b01      	cmp	r3, #1
 8005828:	d12c      	bne.n	8005884 <USB_EPSetStall+0x76>
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 800582a:	68bb      	ldr	r3, [r7, #8]
 800582c:	015a      	lsls	r2, r3, #5
 800582e:	68fb      	ldr	r3, [r7, #12]
 8005830:	4413      	add	r3, r2
 8005832:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005836:	681b      	ldr	r3, [r3, #0]
 8005838:	2b00      	cmp	r3, #0
 800583a:	db12      	blt.n	8005862 <USB_EPSetStall+0x54>
 800583c:	68bb      	ldr	r3, [r7, #8]
 800583e:	2b00      	cmp	r3, #0
 8005840:	d00f      	beq.n	8005862 <USB_EPSetStall+0x54>
    {
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 8005842:	68bb      	ldr	r3, [r7, #8]
 8005844:	015a      	lsls	r2, r3, #5
 8005846:	68fb      	ldr	r3, [r7, #12]
 8005848:	4413      	add	r3, r2
 800584a:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800584e:	681b      	ldr	r3, [r3, #0]
 8005850:	68ba      	ldr	r2, [r7, #8]
 8005852:	0151      	lsls	r1, r2, #5
 8005854:	68fa      	ldr	r2, [r7, #12]
 8005856:	440a      	add	r2, r1
 8005858:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 800585c:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8005860:	6013      	str	r3, [r2, #0]
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8005862:	68bb      	ldr	r3, [r7, #8]
 8005864:	015a      	lsls	r2, r3, #5
 8005866:	68fb      	ldr	r3, [r7, #12]
 8005868:	4413      	add	r3, r2
 800586a:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 800586e:	681b      	ldr	r3, [r3, #0]
 8005870:	68ba      	ldr	r2, [r7, #8]
 8005872:	0151      	lsls	r1, r2, #5
 8005874:	68fa      	ldr	r2, [r7, #12]
 8005876:	440a      	add	r2, r1
 8005878:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 800587c:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8005880:	6013      	str	r3, [r2, #0]
 8005882:	e02b      	b.n	80058dc <USB_EPSetStall+0xce>
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 8005884:	68bb      	ldr	r3, [r7, #8]
 8005886:	015a      	lsls	r2, r3, #5
 8005888:	68fb      	ldr	r3, [r7, #12]
 800588a:	4413      	add	r3, r2
 800588c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005890:	681b      	ldr	r3, [r3, #0]
 8005892:	2b00      	cmp	r3, #0
 8005894:	db12      	blt.n	80058bc <USB_EPSetStall+0xae>
 8005896:	68bb      	ldr	r3, [r7, #8]
 8005898:	2b00      	cmp	r3, #0
 800589a:	d00f      	beq.n	80058bc <USB_EPSetStall+0xae>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 800589c:	68bb      	ldr	r3, [r7, #8]
 800589e:	015a      	lsls	r2, r3, #5
 80058a0:	68fb      	ldr	r3, [r7, #12]
 80058a2:	4413      	add	r3, r2
 80058a4:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80058a8:	681b      	ldr	r3, [r3, #0]
 80058aa:	68ba      	ldr	r2, [r7, #8]
 80058ac:	0151      	lsls	r1, r2, #5
 80058ae:	68fa      	ldr	r2, [r7, #12]
 80058b0:	440a      	add	r2, r1
 80058b2:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 80058b6:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 80058ba:	6013      	str	r3, [r2, #0]
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 80058bc:	68bb      	ldr	r3, [r7, #8]
 80058be:	015a      	lsls	r2, r3, #5
 80058c0:	68fb      	ldr	r3, [r7, #12]
 80058c2:	4413      	add	r3, r2
 80058c4:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 80058c8:	681b      	ldr	r3, [r3, #0]
 80058ca:	68ba      	ldr	r2, [r7, #8]
 80058cc:	0151      	lsls	r1, r2, #5
 80058ce:	68fa      	ldr	r2, [r7, #12]
 80058d0:	440a      	add	r2, r1
 80058d2:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 80058d6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80058da:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 80058dc:	2300      	movs	r3, #0
}
 80058de:	4618      	mov	r0, r3
 80058e0:	3714      	adds	r7, #20
 80058e2:	46bd      	mov	sp, r7
 80058e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80058e8:	4770      	bx	lr

080058ea <USB_EPClearStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 80058ea:	b480      	push	{r7}
 80058ec:	b085      	sub	sp, #20
 80058ee:	af00      	add	r7, sp, #0
 80058f0:	6078      	str	r0, [r7, #4]
 80058f2:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80058f4:	687b      	ldr	r3, [r7, #4]
 80058f6:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 80058f8:	683b      	ldr	r3, [r7, #0]
 80058fa:	781b      	ldrb	r3, [r3, #0]
 80058fc:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 80058fe:	683b      	ldr	r3, [r7, #0]
 8005900:	785b      	ldrb	r3, [r3, #1]
 8005902:	2b01      	cmp	r3, #1
 8005904:	d128      	bne.n	8005958 <USB_EPClearStall+0x6e>
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8005906:	68bb      	ldr	r3, [r7, #8]
 8005908:	015a      	lsls	r2, r3, #5
 800590a:	68fb      	ldr	r3, [r7, #12]
 800590c:	4413      	add	r3, r2
 800590e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005912:	681b      	ldr	r3, [r3, #0]
 8005914:	68ba      	ldr	r2, [r7, #8]
 8005916:	0151      	lsls	r1, r2, #5
 8005918:	68fa      	ldr	r2, [r7, #12]
 800591a:	440a      	add	r2, r1
 800591c:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005920:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8005924:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8005926:	683b      	ldr	r3, [r7, #0]
 8005928:	78db      	ldrb	r3, [r3, #3]
 800592a:	2b03      	cmp	r3, #3
 800592c:	d003      	beq.n	8005936 <USB_EPClearStall+0x4c>
 800592e:	683b      	ldr	r3, [r7, #0]
 8005930:	78db      	ldrb	r3, [r3, #3]
 8005932:	2b02      	cmp	r3, #2
 8005934:	d138      	bne.n	80059a8 <USB_EPClearStall+0xbe>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8005936:	68bb      	ldr	r3, [r7, #8]
 8005938:	015a      	lsls	r2, r3, #5
 800593a:	68fb      	ldr	r3, [r7, #12]
 800593c:	4413      	add	r3, r2
 800593e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005942:	681b      	ldr	r3, [r3, #0]
 8005944:	68ba      	ldr	r2, [r7, #8]
 8005946:	0151      	lsls	r1, r2, #5
 8005948:	68fa      	ldr	r2, [r7, #12]
 800594a:	440a      	add	r2, r1
 800594c:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005950:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005954:	6013      	str	r3, [r2, #0]
 8005956:	e027      	b.n	80059a8 <USB_EPClearStall+0xbe>
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8005958:	68bb      	ldr	r3, [r7, #8]
 800595a:	015a      	lsls	r2, r3, #5
 800595c:	68fb      	ldr	r3, [r7, #12]
 800595e:	4413      	add	r3, r2
 8005960:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005964:	681b      	ldr	r3, [r3, #0]
 8005966:	68ba      	ldr	r2, [r7, #8]
 8005968:	0151      	lsls	r1, r2, #5
 800596a:	68fa      	ldr	r2, [r7, #12]
 800596c:	440a      	add	r2, r1
 800596e:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8005972:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8005976:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8005978:	683b      	ldr	r3, [r7, #0]
 800597a:	78db      	ldrb	r3, [r3, #3]
 800597c:	2b03      	cmp	r3, #3
 800597e:	d003      	beq.n	8005988 <USB_EPClearStall+0x9e>
 8005980:	683b      	ldr	r3, [r7, #0]
 8005982:	78db      	ldrb	r3, [r3, #3]
 8005984:	2b02      	cmp	r3, #2
 8005986:	d10f      	bne.n	80059a8 <USB_EPClearStall+0xbe>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8005988:	68bb      	ldr	r3, [r7, #8]
 800598a:	015a      	lsls	r2, r3, #5
 800598c:	68fb      	ldr	r3, [r7, #12]
 800598e:	4413      	add	r3, r2
 8005990:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005994:	681b      	ldr	r3, [r3, #0]
 8005996:	68ba      	ldr	r2, [r7, #8]
 8005998:	0151      	lsls	r1, r2, #5
 800599a:	68fa      	ldr	r2, [r7, #12]
 800599c:	440a      	add	r2, r1
 800599e:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 80059a2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80059a6:	6013      	str	r3, [r2, #0]
    }
  }
  return HAL_OK;
 80059a8:	2300      	movs	r3, #0
}
 80059aa:	4618      	mov	r0, r3
 80059ac:	3714      	adds	r7, #20
 80059ae:	46bd      	mov	sp, r7
 80059b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80059b4:	4770      	bx	lr

080059b6 <USB_SetDevAddress>:
  * @param  address  new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_SetDevAddress(USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
 80059b6:	b480      	push	{r7}
 80059b8:	b085      	sub	sp, #20
 80059ba:	af00      	add	r7, sp, #0
 80059bc:	6078      	str	r0, [r7, #4]
 80059be:	460b      	mov	r3, r1
 80059c0:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80059c2:	687b      	ldr	r3, [r7, #4]
 80059c4:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 80059c6:	68fb      	ldr	r3, [r7, #12]
 80059c8:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80059cc:	681b      	ldr	r3, [r3, #0]
 80059ce:	68fa      	ldr	r2, [r7, #12]
 80059d0:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80059d4:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80059d8:	6013      	str	r3, [r2, #0]
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 80059da:	68fb      	ldr	r3, [r7, #12]
 80059dc:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 80059e0:	681a      	ldr	r2, [r3, #0]
 80059e2:	78fb      	ldrb	r3, [r7, #3]
 80059e4:	011b      	lsls	r3, r3, #4
 80059e6:	f403 63fe 	and.w	r3, r3, #2032	; 0x7f0
 80059ea:	68f9      	ldr	r1, [r7, #12]
 80059ec:	f501 6100 	add.w	r1, r1, #2048	; 0x800
 80059f0:	4313      	orrs	r3, r2
 80059f2:	600b      	str	r3, [r1, #0]

  return HAL_OK;
 80059f4:	2300      	movs	r3, #0
}
 80059f6:	4618      	mov	r0, r3
 80059f8:	3714      	adds	r7, #20
 80059fa:	46bd      	mov	sp, r7
 80059fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a00:	4770      	bx	lr

08005a02 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling the pull-up/pull-down
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevConnect(USB_OTG_GlobalTypeDef *USBx)
{
 8005a02:	b580      	push	{r7, lr}
 8005a04:	b084      	sub	sp, #16
 8005a06:	af00      	add	r7, sp, #0
 8005a08:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005a0a:	687b      	ldr	r3, [r7, #4]
 8005a0c:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 8005a0e:	68fb      	ldr	r3, [r7, #12]
 8005a10:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005a14:	685b      	ldr	r3, [r3, #4]
 8005a16:	68fa      	ldr	r2, [r7, #12]
 8005a18:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8005a1c:	f023 0302 	bic.w	r3, r3, #2
 8005a20:	6053      	str	r3, [r2, #4]
  HAL_Delay(3U);
 8005a22:	2003      	movs	r0, #3
 8005a24:	f7fb fcb2 	bl	800138c <HAL_Delay>

  return HAL_OK;
 8005a28:	2300      	movs	r3, #0
}
 8005a2a:	4618      	mov	r0, r3
 8005a2c:	3710      	adds	r7, #16
 8005a2e:	46bd      	mov	sp, r7
 8005a30:	bd80      	pop	{r7, pc}

08005a32 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling the pull-up/pull-down
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect(USB_OTG_GlobalTypeDef *USBx)
{
 8005a32:	b580      	push	{r7, lr}
 8005a34:	b084      	sub	sp, #16
 8005a36:	af00      	add	r7, sp, #0
 8005a38:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005a3a:	687b      	ldr	r3, [r7, #4]
 8005a3c:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8005a3e:	68fb      	ldr	r3, [r7, #12]
 8005a40:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005a44:	685b      	ldr	r3, [r3, #4]
 8005a46:	68fa      	ldr	r2, [r7, #12]
 8005a48:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8005a4c:	f043 0302 	orr.w	r3, r3, #2
 8005a50:	6053      	str	r3, [r2, #4]
  HAL_Delay(3U);
 8005a52:	2003      	movs	r0, #3
 8005a54:	f7fb fc9a 	bl	800138c <HAL_Delay>

  return HAL_OK;
 8005a58:	2300      	movs	r3, #0
}
 8005a5a:	4618      	mov	r0, r3
 8005a5c:	3710      	adds	r7, #16
 8005a5e:	46bd      	mov	sp, r7
 8005a60:	bd80      	pop	{r7, pc}

08005a62 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval HAL status
  */
uint32_t  USB_ReadInterrupts(USB_OTG_GlobalTypeDef *USBx)
{
 8005a62:	b480      	push	{r7}
 8005a64:	b085      	sub	sp, #20
 8005a66:	af00      	add	r7, sp, #0
 8005a68:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 8005a6a:	687b      	ldr	r3, [r7, #4]
 8005a6c:	695b      	ldr	r3, [r3, #20]
 8005a6e:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 8005a70:	687b      	ldr	r3, [r7, #4]
 8005a72:	699b      	ldr	r3, [r3, #24]
 8005a74:	68fa      	ldr	r2, [r7, #12]
 8005a76:	4013      	ands	r3, r2
 8005a78:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 8005a7a:	68fb      	ldr	r3, [r7, #12]
}
 8005a7c:	4618      	mov	r0, r3
 8005a7e:	3714      	adds	r7, #20
 8005a80:	46bd      	mov	sp, r7
 8005a82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a86:	4770      	bx	lr

08005a88 <USB_ReadDevAllOutEpInterrupt>:
  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
  * @param  USBx  Selected device
  * @retval HAL status
  */
uint32_t USB_ReadDevAllOutEpInterrupt(USB_OTG_GlobalTypeDef *USBx)
{
 8005a88:	b480      	push	{r7}
 8005a8a:	b085      	sub	sp, #20
 8005a8c:	af00      	add	r7, sp, #0
 8005a8e:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005a90:	687b      	ldr	r3, [r7, #4]
 8005a92:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 8005a94:	68fb      	ldr	r3, [r7, #12]
 8005a96:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005a9a:	699b      	ldr	r3, [r3, #24]
 8005a9c:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8005a9e:	68fb      	ldr	r3, [r7, #12]
 8005aa0:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005aa4:	69db      	ldr	r3, [r3, #28]
 8005aa6:	68ba      	ldr	r2, [r7, #8]
 8005aa8:	4013      	ands	r3, r2
 8005aaa:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xffff0000U) >> 16);
 8005aac:	68bb      	ldr	r3, [r7, #8]
 8005aae:	0c1b      	lsrs	r3, r3, #16
}
 8005ab0:	4618      	mov	r0, r3
 8005ab2:	3714      	adds	r7, #20
 8005ab4:	46bd      	mov	sp, r7
 8005ab6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005aba:	4770      	bx	lr

08005abc <USB_ReadDevAllInEpInterrupt>:
  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
  * @param  USBx  Selected device
  * @retval HAL status
  */
uint32_t USB_ReadDevAllInEpInterrupt(USB_OTG_GlobalTypeDef *USBx)
{
 8005abc:	b480      	push	{r7}
 8005abe:	b085      	sub	sp, #20
 8005ac0:	af00      	add	r7, sp, #0
 8005ac2:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005ac4:	687b      	ldr	r3, [r7, #4]
 8005ac6:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 8005ac8:	68fb      	ldr	r3, [r7, #12]
 8005aca:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005ace:	699b      	ldr	r3, [r3, #24]
 8005ad0:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8005ad2:	68fb      	ldr	r3, [r7, #12]
 8005ad4:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005ad8:	69db      	ldr	r3, [r3, #28]
 8005ada:	68ba      	ldr	r2, [r7, #8]
 8005adc:	4013      	ands	r3, r2
 8005ade:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xFFFFU));
 8005ae0:	68bb      	ldr	r3, [r7, #8]
 8005ae2:	b29b      	uxth	r3, r3
}
 8005ae4:	4618      	mov	r0, r3
 8005ae6:	3714      	adds	r7, #20
 8005ae8:	46bd      	mov	sp, r7
 8005aea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005aee:	4770      	bx	lr

08005af0 <USB_ReadDevOutEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 8005af0:	b480      	push	{r7}
 8005af2:	b085      	sub	sp, #20
 8005af4:	af00      	add	r7, sp, #0
 8005af6:	6078      	str	r0, [r7, #4]
 8005af8:	460b      	mov	r3, r1
 8005afa:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005afc:	687b      	ldr	r3, [r7, #4]
 8005afe:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8005b00:	78fb      	ldrb	r3, [r7, #3]
 8005b02:	015a      	lsls	r2, r3, #5
 8005b04:	68fb      	ldr	r3, [r7, #12]
 8005b06:	4413      	add	r3, r2
 8005b08:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005b0c:	689b      	ldr	r3, [r3, #8]
 8005b0e:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8005b10:	68fb      	ldr	r3, [r7, #12]
 8005b12:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005b16:	695b      	ldr	r3, [r3, #20]
 8005b18:	68ba      	ldr	r2, [r7, #8]
 8005b1a:	4013      	ands	r3, r2
 8005b1c:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 8005b1e:	68bb      	ldr	r3, [r7, #8]
}
 8005b20:	4618      	mov	r0, r3
 8005b22:	3714      	adds	r7, #20
 8005b24:	46bd      	mov	sp, r7
 8005b26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b2a:	4770      	bx	lr

08005b2c <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt(USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 8005b2c:	b480      	push	{r7}
 8005b2e:	b087      	sub	sp, #28
 8005b30:	af00      	add	r7, sp, #0
 8005b32:	6078      	str	r0, [r7, #4]
 8005b34:	460b      	mov	r3, r1
 8005b36:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005b38:	687b      	ldr	r3, [r7, #4]
 8005b3a:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg, msk, emp;

  msk = USBx_DEVICE->DIEPMSK;
 8005b3c:	697b      	ldr	r3, [r7, #20]
 8005b3e:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005b42:	691b      	ldr	r3, [r3, #16]
 8005b44:	613b      	str	r3, [r7, #16]
  emp = USBx_DEVICE->DIEPEMPMSK;
 8005b46:	697b      	ldr	r3, [r7, #20]
 8005b48:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005b4c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005b4e:	60fb      	str	r3, [r7, #12]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8005b50:	78fb      	ldrb	r3, [r7, #3]
 8005b52:	f003 030f 	and.w	r3, r3, #15
 8005b56:	68fa      	ldr	r2, [r7, #12]
 8005b58:	fa22 f303 	lsr.w	r3, r2, r3
 8005b5c:	01db      	lsls	r3, r3, #7
 8005b5e:	b2db      	uxtb	r3, r3
 8005b60:	693a      	ldr	r2, [r7, #16]
 8005b62:	4313      	orrs	r3, r2
 8005b64:	613b      	str	r3, [r7, #16]
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8005b66:	78fb      	ldrb	r3, [r7, #3]
 8005b68:	015a      	lsls	r2, r3, #5
 8005b6a:	697b      	ldr	r3, [r7, #20]
 8005b6c:	4413      	add	r3, r2
 8005b6e:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005b72:	689b      	ldr	r3, [r3, #8]
 8005b74:	693a      	ldr	r2, [r7, #16]
 8005b76:	4013      	ands	r3, r2
 8005b78:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 8005b7a:	68bb      	ldr	r3, [r7, #8]
}
 8005b7c:	4618      	mov	r0, r3
 8005b7e:	371c      	adds	r7, #28
 8005b80:	46bd      	mov	sp, r7
 8005b82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b86:	4770      	bx	lr

08005b88 <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
 8005b88:	b480      	push	{r7}
 8005b8a:	b083      	sub	sp, #12
 8005b8c:	af00      	add	r7, sp, #0
 8005b8e:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 8005b90:	687b      	ldr	r3, [r7, #4]
 8005b92:	695b      	ldr	r3, [r3, #20]
 8005b94:	f003 0301 	and.w	r3, r3, #1
}
 8005b98:	4618      	mov	r0, r3
 8005b9a:	370c      	adds	r7, #12
 8005b9c:	46bd      	mov	sp, r7
 8005b9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ba2:	4770      	bx	lr

08005ba4 <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_ActivateSetup(USB_OTG_GlobalTypeDef *USBx)
{
 8005ba4:	b480      	push	{r7}
 8005ba6:	b085      	sub	sp, #20
 8005ba8:	af00      	add	r7, sp, #0
 8005baa:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005bac:	687b      	ldr	r3, [r7, #4]
 8005bae:	60fb      	str	r3, [r7, #12]

  /* Set the MPS of the IN EP0 to 64 bytes */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8005bb0:	68fb      	ldr	r3, [r7, #12]
 8005bb2:	f503 6310 	add.w	r3, r3, #2304	; 0x900
 8005bb6:	681b      	ldr	r3, [r3, #0]
 8005bb8:	68fa      	ldr	r2, [r7, #12]
 8005bba:	f502 6210 	add.w	r2, r2, #2304	; 0x900
 8005bbe:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8005bc2:	f023 0307 	bic.w	r3, r3, #7
 8005bc6:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8005bc8:	68fb      	ldr	r3, [r7, #12]
 8005bca:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8005bce:	685b      	ldr	r3, [r3, #4]
 8005bd0:	68fa      	ldr	r2, [r7, #12]
 8005bd2:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8005bd6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005bda:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 8005bdc:	2300      	movs	r3, #0
}
 8005bde:	4618      	mov	r0, r3
 8005be0:	3714      	adds	r7, #20
 8005be2:	46bd      	mov	sp, r7
 8005be4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005be8:	4770      	bx	lr
	...

08005bec <USB_EP0_OutStart>:
  *           1 : DMA feature used
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup)
{
 8005bec:	b480      	push	{r7}
 8005bee:	b087      	sub	sp, #28
 8005bf0:	af00      	add	r7, sp, #0
 8005bf2:	60f8      	str	r0, [r7, #12]
 8005bf4:	460b      	mov	r3, r1
 8005bf6:	607a      	str	r2, [r7, #4]
 8005bf8:	72fb      	strb	r3, [r7, #11]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8005bfa:	68fb      	ldr	r3, [r7, #12]
 8005bfc:	617b      	str	r3, [r7, #20]
  uint32_t gSNPSiD = *(__IO uint32_t *)(&USBx->CID + 0x1U);
 8005bfe:	68fb      	ldr	r3, [r7, #12]
 8005c00:	333c      	adds	r3, #60	; 0x3c
 8005c02:	3304      	adds	r3, #4
 8005c04:	681b      	ldr	r3, [r3, #0]
 8005c06:	613b      	str	r3, [r7, #16]

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8005c08:	693b      	ldr	r3, [r7, #16]
 8005c0a:	4a26      	ldr	r2, [pc, #152]	; (8005ca4 <USB_EP0_OutStart+0xb8>)
 8005c0c:	4293      	cmp	r3, r2
 8005c0e:	d90a      	bls.n	8005c26 <USB_EP0_OutStart+0x3a>
  {
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8005c10:	697b      	ldr	r3, [r7, #20]
 8005c12:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005c16:	681b      	ldr	r3, [r3, #0]
 8005c18:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8005c1c:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8005c20:	d101      	bne.n	8005c26 <USB_EP0_OutStart+0x3a>
    {
      return HAL_OK;
 8005c22:	2300      	movs	r3, #0
 8005c24:	e037      	b.n	8005c96 <USB_EP0_OutStart+0xaa>
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8005c26:	697b      	ldr	r3, [r7, #20]
 8005c28:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005c2c:	461a      	mov	r2, r3
 8005c2e:	2300      	movs	r3, #0
 8005c30:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8005c32:	697b      	ldr	r3, [r7, #20]
 8005c34:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005c38:	691b      	ldr	r3, [r3, #16]
 8005c3a:	697a      	ldr	r2, [r7, #20]
 8005c3c:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8005c40:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8005c44:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8005c46:	697b      	ldr	r3, [r7, #20]
 8005c48:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005c4c:	691b      	ldr	r3, [r3, #16]
 8005c4e:	697a      	ldr	r2, [r7, #20]
 8005c50:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8005c54:	f043 0318 	orr.w	r3, r3, #24
 8005c58:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 8005c5a:	697b      	ldr	r3, [r7, #20]
 8005c5c:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005c60:	691b      	ldr	r3, [r3, #16]
 8005c62:	697a      	ldr	r2, [r7, #20]
 8005c64:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8005c68:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 8005c6c:	6113      	str	r3, [r2, #16]

  if (dma == 1U)
 8005c6e:	7afb      	ldrb	r3, [r7, #11]
 8005c70:	2b01      	cmp	r3, #1
 8005c72:	d10f      	bne.n	8005c94 <USB_EP0_OutStart+0xa8>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 8005c74:	697b      	ldr	r3, [r7, #20]
 8005c76:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005c7a:	461a      	mov	r2, r3
 8005c7c:	687b      	ldr	r3, [r7, #4]
 8005c7e:	6153      	str	r3, [r2, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 8005c80:	697b      	ldr	r3, [r7, #20]
 8005c82:	f503 6330 	add.w	r3, r3, #2816	; 0xb00
 8005c86:	681b      	ldr	r3, [r3, #0]
 8005c88:	697a      	ldr	r2, [r7, #20]
 8005c8a:	f502 6230 	add.w	r2, r2, #2816	; 0xb00
 8005c8e:	f043 2380 	orr.w	r3, r3, #2147516416	; 0x80008000
 8005c92:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8005c94:	2300      	movs	r3, #0
}
 8005c96:	4618      	mov	r0, r3
 8005c98:	371c      	adds	r7, #28
 8005c9a:	46bd      	mov	sp, r7
 8005c9c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ca0:	4770      	bx	lr
 8005ca2:	bf00      	nop
 8005ca4:	4f54300a 	.word	0x4f54300a

08005ca8 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8005ca8:	b480      	push	{r7}
 8005caa:	b085      	sub	sp, #20
 8005cac:	af00      	add	r7, sp, #0
 8005cae:	6078      	str	r0, [r7, #4]
  uint32_t count = 0U;
 8005cb0:	2300      	movs	r3, #0
 8005cb2:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 8005cb4:	68fb      	ldr	r3, [r7, #12]
 8005cb6:	3301      	adds	r3, #1
 8005cb8:	60fb      	str	r3, [r7, #12]
 8005cba:	68fb      	ldr	r3, [r7, #12]
 8005cbc:	4a13      	ldr	r2, [pc, #76]	; (8005d0c <USB_CoreReset+0x64>)
 8005cbe:	4293      	cmp	r3, r2
 8005cc0:	d901      	bls.n	8005cc6 <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 8005cc2:	2303      	movs	r3, #3
 8005cc4:	e01b      	b.n	8005cfe <USB_CoreReset+0x56>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8005cc6:	687b      	ldr	r3, [r7, #4]
 8005cc8:	691b      	ldr	r3, [r3, #16]
 8005cca:	2b00      	cmp	r3, #0
 8005ccc:	daf2      	bge.n	8005cb4 <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 8005cce:	2300      	movs	r3, #0
 8005cd0:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8005cd2:	687b      	ldr	r3, [r7, #4]
 8005cd4:	691b      	ldr	r3, [r3, #16]
 8005cd6:	f043 0201 	orr.w	r2, r3, #1
 8005cda:	687b      	ldr	r3, [r7, #4]
 8005cdc:	611a      	str	r2, [r3, #16]

  do
  {
    if (++count > 200000U)
 8005cde:	68fb      	ldr	r3, [r7, #12]
 8005ce0:	3301      	adds	r3, #1
 8005ce2:	60fb      	str	r3, [r7, #12]
 8005ce4:	68fb      	ldr	r3, [r7, #12]
 8005ce6:	4a09      	ldr	r2, [pc, #36]	; (8005d0c <USB_CoreReset+0x64>)
 8005ce8:	4293      	cmp	r3, r2
 8005cea:	d901      	bls.n	8005cf0 <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 8005cec:	2303      	movs	r3, #3
 8005cee:	e006      	b.n	8005cfe <USB_CoreReset+0x56>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8005cf0:	687b      	ldr	r3, [r7, #4]
 8005cf2:	691b      	ldr	r3, [r3, #16]
 8005cf4:	f003 0301 	and.w	r3, r3, #1
 8005cf8:	2b01      	cmp	r3, #1
 8005cfa:	d0f0      	beq.n	8005cde <USB_CoreReset+0x36>

  return HAL_OK;
 8005cfc:	2300      	movs	r3, #0
}
 8005cfe:	4618      	mov	r0, r3
 8005d00:	3714      	adds	r7, #20
 8005d02:	46bd      	mov	sp, r7
 8005d04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d08:	4770      	bx	lr
 8005d0a:	bf00      	nop
 8005d0c:	00030d40 	.word	0x00030d40

08005d10 <USBD_CDC_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8005d10:	b580      	push	{r7, lr}
 8005d12:	b084      	sub	sp, #16
 8005d14:	af00      	add	r7, sp, #0
 8005d16:	6078      	str	r0, [r7, #4]
 8005d18:	460b      	mov	r3, r1
 8005d1a:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);
  USBD_CDC_HandleTypeDef *hcdc;

  hcdc = USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 8005d1c:	f44f 7007 	mov.w	r0, #540	; 0x21c
 8005d20:	f028 f9d6 	bl	802e0d0 <malloc>
 8005d24:	4603      	mov	r3, r0
 8005d26:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 8005d28:	68fb      	ldr	r3, [r7, #12]
 8005d2a:	2b00      	cmp	r3, #0
 8005d2c:	d105      	bne.n	8005d3a <USBD_CDC_Init+0x2a>
  {
    pdev->pClassData = NULL;
 8005d2e:	687b      	ldr	r3, [r7, #4]
 8005d30:	2200      	movs	r2, #0
 8005d32:	f8c3 22bc 	str.w	r2, [r3, #700]	; 0x2bc
    return (uint8_t)USBD_EMEM;
 8005d36:	2302      	movs	r3, #2
 8005d38:	e066      	b.n	8005e08 <USBD_CDC_Init+0xf8>
  }

  pdev->pClassData = (void *)hcdc;
 8005d3a:	687b      	ldr	r3, [r7, #4]
 8005d3c:	68fa      	ldr	r2, [r7, #12]
 8005d3e:	f8c3 22bc 	str.w	r2, [r3, #700]	; 0x2bc

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8005d42:	687b      	ldr	r3, [r7, #4]
 8005d44:	7c1b      	ldrb	r3, [r3, #16]
 8005d46:	2b00      	cmp	r3, #0
 8005d48:	d119      	bne.n	8005d7e <USBD_CDC_Init+0x6e>
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 8005d4a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005d4e:	2202      	movs	r2, #2
 8005d50:	2181      	movs	r1, #129	; 0x81
 8005d52:	6878      	ldr	r0, [r7, #4]
 8005d54:	f001 ff53 	bl	8007bfe <USBD_LL_OpenEP>
                         CDC_DATA_HS_IN_PACKET_SIZE);

     pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 8005d58:	687b      	ldr	r3, [r7, #4]
 8005d5a:	2201      	movs	r2, #1
 8005d5c:	871a      	strh	r2, [r3, #56]	; 0x38

     /* Open EP OUT */
     (void)USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 8005d5e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005d62:	2202      	movs	r2, #2
 8005d64:	2101      	movs	r1, #1
 8005d66:	6878      	ldr	r0, [r7, #4]
 8005d68:	f001 ff49 	bl	8007bfe <USBD_LL_OpenEP>
                          CDC_DATA_HS_OUT_PACKET_SIZE);

      pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
 8005d6c:	687b      	ldr	r3, [r7, #4]
 8005d6e:	2201      	movs	r2, #1
 8005d70:	f8a3 2178 	strh.w	r2, [r3, #376]	; 0x178

      /* Set bInterval for CDC CMD Endpoint */
      pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = CDC_HS_BINTERVAL;
 8005d74:	687b      	ldr	r3, [r7, #4]
 8005d76:	2210      	movs	r2, #16
 8005d78:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
 8005d7c:	e016      	b.n	8005dac <USBD_CDC_Init+0x9c>
  }
  else
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDC_IN_EP, USBD_EP_TYPE_BULK,
 8005d7e:	2340      	movs	r3, #64	; 0x40
 8005d80:	2202      	movs	r2, #2
 8005d82:	2181      	movs	r1, #129	; 0x81
 8005d84:	6878      	ldr	r0, [r7, #4]
 8005d86:	f001 ff3a 	bl	8007bfe <USBD_LL_OpenEP>
                         CDC_DATA_FS_IN_PACKET_SIZE);

     pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 1U;
 8005d8a:	687b      	ldr	r3, [r7, #4]
 8005d8c:	2201      	movs	r2, #1
 8005d8e:	871a      	strh	r2, [r3, #56]	; 0x38

     /* Open EP OUT */
     (void)USBD_LL_OpenEP(pdev, CDC_OUT_EP, USBD_EP_TYPE_BULK,
 8005d90:	2340      	movs	r3, #64	; 0x40
 8005d92:	2202      	movs	r2, #2
 8005d94:	2101      	movs	r1, #1
 8005d96:	6878      	ldr	r0, [r7, #4]
 8005d98:	f001 ff31 	bl	8007bfe <USBD_LL_OpenEP>
                          CDC_DATA_FS_OUT_PACKET_SIZE);

      pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 1U;
 8005d9c:	687b      	ldr	r3, [r7, #4]
 8005d9e:	2201      	movs	r2, #1
 8005da0:	f8a3 2178 	strh.w	r2, [r3, #376]	; 0x178

      /* Set bInterval for CMD Endpoint */
      pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = CDC_FS_BINTERVAL;
 8005da4:	687b      	ldr	r3, [r7, #4]
 8005da6:	2210      	movs	r2, #16
 8005da8:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
  }

  /* Open Command IN EP */
  (void)USBD_LL_OpenEP(pdev, CDC_CMD_EP, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8005dac:	2308      	movs	r3, #8
 8005dae:	2203      	movs	r2, #3
 8005db0:	2182      	movs	r1, #130	; 0x82
 8005db2:	6878      	ldr	r0, [r7, #4]
 8005db4:	f001 ff23 	bl	8007bfe <USBD_LL_OpenEP>
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 1U;
 8005db8:	687b      	ldr	r3, [r7, #4]
 8005dba:	2201      	movs	r2, #1
 8005dbc:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c

  /* Init  physical Interface components */
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Init();
 8005dc0:	687b      	ldr	r3, [r7, #4]
 8005dc2:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 8005dc6:	681b      	ldr	r3, [r3, #0]
 8005dc8:	4798      	blx	r3

  /* Init Xfer states */
  hcdc->TxState = 0U;
 8005dca:	68fb      	ldr	r3, [r7, #12]
 8005dcc:	2200      	movs	r2, #0
 8005dce:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
  hcdc->RxState = 0U;
 8005dd2:	68fb      	ldr	r3, [r7, #12]
 8005dd4:	2200      	movs	r2, #0
 8005dd6:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8005dda:	687b      	ldr	r3, [r7, #4]
 8005ddc:	7c1b      	ldrb	r3, [r3, #16]
 8005dde:	2b00      	cmp	r3, #0
 8005de0:	d109      	bne.n	8005df6 <USBD_CDC_Init+0xe6>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 8005de2:	68fb      	ldr	r3, [r7, #12]
 8005de4:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8005de8:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005dec:	2101      	movs	r1, #1
 8005dee:	6878      	ldr	r0, [r7, #4]
 8005df0:	f001 fff4 	bl	8007ddc <USBD_LL_PrepareReceive>
 8005df4:	e007      	b.n	8005e06 <USBD_CDC_Init+0xf6>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 8005df6:	68fb      	ldr	r3, [r7, #12]
 8005df8:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8005dfc:	2340      	movs	r3, #64	; 0x40
 8005dfe:	2101      	movs	r1, #1
 8005e00:	6878      	ldr	r0, [r7, #4]
 8005e02:	f001 ffeb 	bl	8007ddc <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 8005e06:	2300      	movs	r3, #0
}
 8005e08:	4618      	mov	r0, r3
 8005e0a:	3710      	adds	r7, #16
 8005e0c:	46bd      	mov	sp, r7
 8005e0e:	bd80      	pop	{r7, pc}

08005e10 <USBD_CDC_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8005e10:	b580      	push	{r7, lr}
 8005e12:	b084      	sub	sp, #16
 8005e14:	af00      	add	r7, sp, #0
 8005e16:	6078      	str	r0, [r7, #4]
 8005e18:	460b      	mov	r3, r1
 8005e1a:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);
  uint8_t ret = 0U;
 8005e1c:	2300      	movs	r3, #0
 8005e1e:	73fb      	strb	r3, [r7, #15]

  /* Close EP IN */
  (void)USBD_LL_CloseEP(pdev, CDC_IN_EP);
 8005e20:	2181      	movs	r1, #129	; 0x81
 8005e22:	6878      	ldr	r0, [r7, #4]
 8005e24:	f001 ff11 	bl	8007c4a <USBD_LL_CloseEP>
  pdev->ep_in[CDC_IN_EP & 0xFU].is_used = 0U;
 8005e28:	687b      	ldr	r3, [r7, #4]
 8005e2a:	2200      	movs	r2, #0
 8005e2c:	871a      	strh	r2, [r3, #56]	; 0x38

  /* Close EP OUT */
  (void)USBD_LL_CloseEP(pdev, CDC_OUT_EP);
 8005e2e:	2101      	movs	r1, #1
 8005e30:	6878      	ldr	r0, [r7, #4]
 8005e32:	f001 ff0a 	bl	8007c4a <USBD_LL_CloseEP>
  pdev->ep_out[CDC_OUT_EP & 0xFU].is_used = 0U;
 8005e36:	687b      	ldr	r3, [r7, #4]
 8005e38:	2200      	movs	r2, #0
 8005e3a:	f8a3 2178 	strh.w	r2, [r3, #376]	; 0x178

  /* Close Command IN EP */
  (void)USBD_LL_CloseEP(pdev, CDC_CMD_EP);
 8005e3e:	2182      	movs	r1, #130	; 0x82
 8005e40:	6878      	ldr	r0, [r7, #4]
 8005e42:	f001 ff02 	bl	8007c4a <USBD_LL_CloseEP>
  pdev->ep_in[CDC_CMD_EP & 0xFU].is_used = 0U;
 8005e46:	687b      	ldr	r3, [r7, #4]
 8005e48:	2200      	movs	r2, #0
 8005e4a:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
  pdev->ep_in[CDC_CMD_EP & 0xFU].bInterval = 0U;
 8005e4e:	687b      	ldr	r3, [r7, #4]
 8005e50:	2200      	movs	r2, #0
 8005e52:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e

  /* DeInit  physical Interface components */
  if (pdev->pClassData != NULL)
 8005e56:	687b      	ldr	r3, [r7, #4]
 8005e58:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8005e5c:	2b00      	cmp	r3, #0
 8005e5e:	d00e      	beq.n	8005e7e <USBD_CDC_DeInit+0x6e>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->DeInit();
 8005e60:	687b      	ldr	r3, [r7, #4]
 8005e62:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 8005e66:	685b      	ldr	r3, [r3, #4]
 8005e68:	4798      	blx	r3
    (void)USBD_free(pdev->pClassData);
 8005e6a:	687b      	ldr	r3, [r7, #4]
 8005e6c:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8005e70:	4618      	mov	r0, r3
 8005e72:	f028 f935 	bl	802e0e0 <free>
    pdev->pClassData = NULL;
 8005e76:	687b      	ldr	r3, [r7, #4]
 8005e78:	2200      	movs	r2, #0
 8005e7a:	f8c3 22bc 	str.w	r2, [r3, #700]	; 0x2bc
  }

  return ret;
 8005e7e:	7bfb      	ldrb	r3, [r7, #15]
}
 8005e80:	4618      	mov	r0, r3
 8005e82:	3710      	adds	r7, #16
 8005e84:	46bd      	mov	sp, r7
 8005e86:	bd80      	pop	{r7, pc}

08005e88 <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t USBD_CDC_Setup(USBD_HandleTypeDef *pdev,
                              USBD_SetupReqTypedef *req)
{
 8005e88:	b580      	push	{r7, lr}
 8005e8a:	b086      	sub	sp, #24
 8005e8c:	af00      	add	r7, sp, #0
 8005e8e:	6078      	str	r0, [r7, #4]
 8005e90:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 8005e92:	687b      	ldr	r3, [r7, #4]
 8005e94:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8005e98:	613b      	str	r3, [r7, #16]
  uint8_t ifalt = 0U;
 8005e9a:	2300      	movs	r3, #0
 8005e9c:	73fb      	strb	r3, [r7, #15]
  uint16_t status_info = 0U;
 8005e9e:	2300      	movs	r3, #0
 8005ea0:	81bb      	strh	r3, [r7, #12]
  USBD_StatusTypeDef ret = USBD_OK;
 8005ea2:	2300      	movs	r3, #0
 8005ea4:	75fb      	strb	r3, [r7, #23]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8005ea6:	683b      	ldr	r3, [r7, #0]
 8005ea8:	781b      	ldrb	r3, [r3, #0]
 8005eaa:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8005eae:	2b00      	cmp	r3, #0
 8005eb0:	d03a      	beq.n	8005f28 <USBD_CDC_Setup+0xa0>
 8005eb2:	2b20      	cmp	r3, #32
 8005eb4:	f040 8097 	bne.w	8005fe6 <USBD_CDC_Setup+0x15e>
  {
  case USB_REQ_TYPE_CLASS:
    if (req->wLength != 0U)
 8005eb8:	683b      	ldr	r3, [r7, #0]
 8005eba:	88db      	ldrh	r3, [r3, #6]
 8005ebc:	2b00      	cmp	r3, #0
 8005ebe:	d029      	beq.n	8005f14 <USBD_CDC_Setup+0x8c>
    {
      if ((req->bmRequest & 0x80U) != 0U)
 8005ec0:	683b      	ldr	r3, [r7, #0]
 8005ec2:	781b      	ldrb	r3, [r3, #0]
 8005ec4:	b25b      	sxtb	r3, r3
 8005ec6:	2b00      	cmp	r3, #0
 8005ec8:	da11      	bge.n	8005eee <USBD_CDC_Setup+0x66>
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8005eca:	687b      	ldr	r3, [r7, #4]
 8005ecc:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 8005ed0:	689b      	ldr	r3, [r3, #8]
 8005ed2:	683a      	ldr	r2, [r7, #0]
 8005ed4:	7850      	ldrb	r0, [r2, #1]
                                                          (uint8_t *)hcdc->data,
 8005ed6:	6939      	ldr	r1, [r7, #16]
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8005ed8:	683a      	ldr	r2, [r7, #0]
 8005eda:	88d2      	ldrh	r2, [r2, #6]
 8005edc:	4798      	blx	r3
                                                          req->wLength);

          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, req->wLength);
 8005ede:	6939      	ldr	r1, [r7, #16]
 8005ee0:	683b      	ldr	r3, [r7, #0]
 8005ee2:	88db      	ldrh	r3, [r3, #6]
 8005ee4:	461a      	mov	r2, r3
 8005ee6:	6878      	ldr	r0, [r7, #4]
 8005ee8:	f001 fa7c 	bl	80073e4 <USBD_CtlSendData>
    else
    {
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
                                                        (uint8_t *)req, 0U);
    }
    break;
 8005eec:	e082      	b.n	8005ff4 <USBD_CDC_Setup+0x16c>
        hcdc->CmdOpCode = req->bRequest;
 8005eee:	683b      	ldr	r3, [r7, #0]
 8005ef0:	785a      	ldrb	r2, [r3, #1]
 8005ef2:	693b      	ldr	r3, [r7, #16]
 8005ef4:	f883 2200 	strb.w	r2, [r3, #512]	; 0x200
        hcdc->CmdLength = (uint8_t)req->wLength;
 8005ef8:	683b      	ldr	r3, [r7, #0]
 8005efa:	88db      	ldrh	r3, [r3, #6]
 8005efc:	b2da      	uxtb	r2, r3
 8005efe:	693b      	ldr	r3, [r7, #16]
 8005f00:	f883 2201 	strb.w	r2, [r3, #513]	; 0x201
        (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, req->wLength);
 8005f04:	6939      	ldr	r1, [r7, #16]
 8005f06:	683b      	ldr	r3, [r7, #0]
 8005f08:	88db      	ldrh	r3, [r3, #6]
 8005f0a:	461a      	mov	r2, r3
 8005f0c:	6878      	ldr	r0, [r7, #4]
 8005f0e:	f001 fa95 	bl	800743c <USBD_CtlPrepareRx>
    break;
 8005f12:	e06f      	b.n	8005ff4 <USBD_CDC_Setup+0x16c>
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(req->bRequest,
 8005f14:	687b      	ldr	r3, [r7, #4]
 8005f16:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 8005f1a:	689b      	ldr	r3, [r3, #8]
 8005f1c:	683a      	ldr	r2, [r7, #0]
 8005f1e:	7850      	ldrb	r0, [r2, #1]
 8005f20:	2200      	movs	r2, #0
 8005f22:	6839      	ldr	r1, [r7, #0]
 8005f24:	4798      	blx	r3
    break;
 8005f26:	e065      	b.n	8005ff4 <USBD_CDC_Setup+0x16c>

  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 8005f28:	683b      	ldr	r3, [r7, #0]
 8005f2a:	785b      	ldrb	r3, [r3, #1]
 8005f2c:	2b0b      	cmp	r3, #11
 8005f2e:	d84f      	bhi.n	8005fd0 <USBD_CDC_Setup+0x148>
 8005f30:	a201      	add	r2, pc, #4	; (adr r2, 8005f38 <USBD_CDC_Setup+0xb0>)
 8005f32:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005f36:	bf00      	nop
 8005f38:	08005f69 	.word	0x08005f69
 8005f3c:	08005fdf 	.word	0x08005fdf
 8005f40:	08005fd1 	.word	0x08005fd1
 8005f44:	08005fd1 	.word	0x08005fd1
 8005f48:	08005fd1 	.word	0x08005fd1
 8005f4c:	08005fd1 	.word	0x08005fd1
 8005f50:	08005fd1 	.word	0x08005fd1
 8005f54:	08005fd1 	.word	0x08005fd1
 8005f58:	08005fd1 	.word	0x08005fd1
 8005f5c:	08005fd1 	.word	0x08005fd1
 8005f60:	08005f91 	.word	0x08005f91
 8005f64:	08005fb9 	.word	0x08005fb9
    {
    case USB_REQ_GET_STATUS:
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8005f68:	687b      	ldr	r3, [r7, #4]
 8005f6a:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8005f6e:	2b03      	cmp	r3, #3
 8005f70:	d107      	bne.n	8005f82 <USBD_CDC_Setup+0xfa>
      {
        (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 8005f72:	f107 030c 	add.w	r3, r7, #12
 8005f76:	2202      	movs	r2, #2
 8005f78:	4619      	mov	r1, r3
 8005f7a:	6878      	ldr	r0, [r7, #4]
 8005f7c:	f001 fa32 	bl	80073e4 <USBD_CtlSendData>
      else
      {
        USBD_CtlError(pdev, req);
        ret = USBD_FAIL;
      }
      break;
 8005f80:	e030      	b.n	8005fe4 <USBD_CDC_Setup+0x15c>
        USBD_CtlError(pdev, req);
 8005f82:	6839      	ldr	r1, [r7, #0]
 8005f84:	6878      	ldr	r0, [r7, #4]
 8005f86:	f001 f9bc 	bl	8007302 <USBD_CtlError>
        ret = USBD_FAIL;
 8005f8a:	2303      	movs	r3, #3
 8005f8c:	75fb      	strb	r3, [r7, #23]
      break;
 8005f8e:	e029      	b.n	8005fe4 <USBD_CDC_Setup+0x15c>

    case USB_REQ_GET_INTERFACE:
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8005f90:	687b      	ldr	r3, [r7, #4]
 8005f92:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8005f96:	2b03      	cmp	r3, #3
 8005f98:	d107      	bne.n	8005faa <USBD_CDC_Setup+0x122>
      {
        (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 8005f9a:	f107 030f 	add.w	r3, r7, #15
 8005f9e:	2201      	movs	r2, #1
 8005fa0:	4619      	mov	r1, r3
 8005fa2:	6878      	ldr	r0, [r7, #4]
 8005fa4:	f001 fa1e 	bl	80073e4 <USBD_CtlSendData>
      else
      {
        USBD_CtlError(pdev, req);
        ret = USBD_FAIL;
      }
      break;
 8005fa8:	e01c      	b.n	8005fe4 <USBD_CDC_Setup+0x15c>
        USBD_CtlError(pdev, req);
 8005faa:	6839      	ldr	r1, [r7, #0]
 8005fac:	6878      	ldr	r0, [r7, #4]
 8005fae:	f001 f9a8 	bl	8007302 <USBD_CtlError>
        ret = USBD_FAIL;
 8005fb2:	2303      	movs	r3, #3
 8005fb4:	75fb      	strb	r3, [r7, #23]
      break;
 8005fb6:	e015      	b.n	8005fe4 <USBD_CDC_Setup+0x15c>

    case USB_REQ_SET_INTERFACE:
      if (pdev->dev_state != USBD_STATE_CONFIGURED)
 8005fb8:	687b      	ldr	r3, [r7, #4]
 8005fba:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8005fbe:	2b03      	cmp	r3, #3
 8005fc0:	d00f      	beq.n	8005fe2 <USBD_CDC_Setup+0x15a>
      {
        USBD_CtlError(pdev, req);
 8005fc2:	6839      	ldr	r1, [r7, #0]
 8005fc4:	6878      	ldr	r0, [r7, #4]
 8005fc6:	f001 f99c 	bl	8007302 <USBD_CtlError>
        ret = USBD_FAIL;
 8005fca:	2303      	movs	r3, #3
 8005fcc:	75fb      	strb	r3, [r7, #23]
      }
      break;
 8005fce:	e008      	b.n	8005fe2 <USBD_CDC_Setup+0x15a>

    case USB_REQ_CLEAR_FEATURE:
      break;

    default:
      USBD_CtlError(pdev, req);
 8005fd0:	6839      	ldr	r1, [r7, #0]
 8005fd2:	6878      	ldr	r0, [r7, #4]
 8005fd4:	f001 f995 	bl	8007302 <USBD_CtlError>
      ret = USBD_FAIL;
 8005fd8:	2303      	movs	r3, #3
 8005fda:	75fb      	strb	r3, [r7, #23]
      break;
 8005fdc:	e002      	b.n	8005fe4 <USBD_CDC_Setup+0x15c>
      break;
 8005fde:	bf00      	nop
 8005fe0:	e008      	b.n	8005ff4 <USBD_CDC_Setup+0x16c>
      break;
 8005fe2:	bf00      	nop
    }
    break;
 8005fe4:	e006      	b.n	8005ff4 <USBD_CDC_Setup+0x16c>

  default:
    USBD_CtlError(pdev, req);
 8005fe6:	6839      	ldr	r1, [r7, #0]
 8005fe8:	6878      	ldr	r0, [r7, #4]
 8005fea:	f001 f98a 	bl	8007302 <USBD_CtlError>
    ret = USBD_FAIL;
 8005fee:	2303      	movs	r3, #3
 8005ff0:	75fb      	strb	r3, [r7, #23]
    break;
 8005ff2:	bf00      	nop
  }

  return (uint8_t)ret;
 8005ff4:	7dfb      	ldrb	r3, [r7, #23]
}
 8005ff6:	4618      	mov	r0, r3
 8005ff8:	3718      	adds	r7, #24
 8005ffa:	46bd      	mov	sp, r7
 8005ffc:	bd80      	pop	{r7, pc}
 8005ffe:	bf00      	nop

08006000 <USBD_CDC_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8006000:	b580      	push	{r7, lr}
 8006002:	b084      	sub	sp, #16
 8006004:	af00      	add	r7, sp, #0
 8006006:	6078      	str	r0, [r7, #4]
 8006008:	460b      	mov	r3, r1
 800600a:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc;
  PCD_HandleTypeDef *hpcd = pdev->pData;
 800600c:	687b      	ldr	r3, [r7, #4]
 800600e:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8006012:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassData == NULL)
 8006014:	687b      	ldr	r3, [r7, #4]
 8006016:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 800601a:	2b00      	cmp	r3, #0
 800601c:	d101      	bne.n	8006022 <USBD_CDC_DataIn+0x22>
  {
    return (uint8_t)USBD_FAIL;
 800601e:	2303      	movs	r3, #3
 8006020:	e049      	b.n	80060b6 <USBD_CDC_DataIn+0xb6>
  }

  hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 8006022:	687b      	ldr	r3, [r7, #4]
 8006024:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8006028:	60bb      	str	r3, [r7, #8]

  if ((pdev->ep_in[epnum].total_length > 0U) &&
 800602a:	78fa      	ldrb	r2, [r7, #3]
 800602c:	6879      	ldr	r1, [r7, #4]
 800602e:	4613      	mov	r3, r2
 8006030:	009b      	lsls	r3, r3, #2
 8006032:	4413      	add	r3, r2
 8006034:	009b      	lsls	r3, r3, #2
 8006036:	440b      	add	r3, r1
 8006038:	3318      	adds	r3, #24
 800603a:	681b      	ldr	r3, [r3, #0]
 800603c:	2b00      	cmp	r3, #0
 800603e:	d029      	beq.n	8006094 <USBD_CDC_DataIn+0x94>
      ((pdev->ep_in[epnum].total_length % hpcd->IN_ep[epnum].maxpacket) == 0U))
 8006040:	78fa      	ldrb	r2, [r7, #3]
 8006042:	6879      	ldr	r1, [r7, #4]
 8006044:	4613      	mov	r3, r2
 8006046:	009b      	lsls	r3, r3, #2
 8006048:	4413      	add	r3, r2
 800604a:	009b      	lsls	r3, r3, #2
 800604c:	440b      	add	r3, r1
 800604e:	3318      	adds	r3, #24
 8006050:	681a      	ldr	r2, [r3, #0]
 8006052:	78f9      	ldrb	r1, [r7, #3]
 8006054:	68f8      	ldr	r0, [r7, #12]
 8006056:	460b      	mov	r3, r1
 8006058:	00db      	lsls	r3, r3, #3
 800605a:	1a5b      	subs	r3, r3, r1
 800605c:	009b      	lsls	r3, r3, #2
 800605e:	4403      	add	r3, r0
 8006060:	3344      	adds	r3, #68	; 0x44
 8006062:	681b      	ldr	r3, [r3, #0]
 8006064:	fbb2 f1f3 	udiv	r1, r2, r3
 8006068:	fb01 f303 	mul.w	r3, r1, r3
 800606c:	1ad3      	subs	r3, r2, r3
  if ((pdev->ep_in[epnum].total_length > 0U) &&
 800606e:	2b00      	cmp	r3, #0
 8006070:	d110      	bne.n	8006094 <USBD_CDC_DataIn+0x94>
  {
    /* Update the packet total length */
    pdev->ep_in[epnum].total_length = 0U;
 8006072:	78fa      	ldrb	r2, [r7, #3]
 8006074:	6879      	ldr	r1, [r7, #4]
 8006076:	4613      	mov	r3, r2
 8006078:	009b      	lsls	r3, r3, #2
 800607a:	4413      	add	r3, r2
 800607c:	009b      	lsls	r3, r3, #2
 800607e:	440b      	add	r3, r1
 8006080:	3318      	adds	r3, #24
 8006082:	2200      	movs	r2, #0
 8006084:	601a      	str	r2, [r3, #0]

    /* Send ZLP */
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 8006086:	78f9      	ldrb	r1, [r7, #3]
 8006088:	2300      	movs	r3, #0
 800608a:	2200      	movs	r2, #0
 800608c:	6878      	ldr	r0, [r7, #4]
 800608e:	f001 fe84 	bl	8007d9a <USBD_LL_Transmit>
 8006092:	e00f      	b.n	80060b4 <USBD_CDC_DataIn+0xb4>
  }
  else
  {
    hcdc->TxState = 0U;
 8006094:	68bb      	ldr	r3, [r7, #8]
 8006096:	2200      	movs	r2, #0
 8006098:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 800609c:	687b      	ldr	r3, [r7, #4]
 800609e:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 80060a2:	691b      	ldr	r3, [r3, #16]
 80060a4:	68ba      	ldr	r2, [r7, #8]
 80060a6:	f8d2 0208 	ldr.w	r0, [r2, #520]	; 0x208
 80060aa:	68ba      	ldr	r2, [r7, #8]
 80060ac:	f502 7104 	add.w	r1, r2, #528	; 0x210
 80060b0:	78fa      	ldrb	r2, [r7, #3]
 80060b2:	4798      	blx	r3
  }

  return (uint8_t)USBD_OK;
 80060b4:	2300      	movs	r3, #0
}
 80060b6:	4618      	mov	r0, r3
 80060b8:	3710      	adds	r7, #16
 80060ba:	46bd      	mov	sp, r7
 80060bc:	bd80      	pop	{r7, pc}

080060be <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 80060be:	b580      	push	{r7, lr}
 80060c0:	b084      	sub	sp, #16
 80060c2:	af00      	add	r7, sp, #0
 80060c4:	6078      	str	r0, [r7, #4]
 80060c6:	460b      	mov	r3, r1
 80060c8:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 80060ca:	687b      	ldr	r3, [r7, #4]
 80060cc:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 80060d0:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassData == NULL)
 80060d2:	687b      	ldr	r3, [r7, #4]
 80060d4:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 80060d8:	2b00      	cmp	r3, #0
 80060da:	d101      	bne.n	80060e0 <USBD_CDC_DataOut+0x22>
  {
    return (uint8_t)USBD_FAIL;
 80060dc:	2303      	movs	r3, #3
 80060de:	e015      	b.n	800610c <USBD_CDC_DataOut+0x4e>
  }

  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 80060e0:	78fb      	ldrb	r3, [r7, #3]
 80060e2:	4619      	mov	r1, r3
 80060e4:	6878      	ldr	r0, [r7, #4]
 80060e6:	f001 fe9a 	bl	8007e1e <USBD_LL_GetRxDataSize>
 80060ea:	4602      	mov	r2, r0
 80060ec:	68fb      	ldr	r3, [r7, #12]
 80060ee:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c

  /* USB data will be immediately processed, this allow next USB traffic being
  NAKed till the end of the application Xfer */

  ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 80060f2:	687b      	ldr	r3, [r7, #4]
 80060f4:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 80060f8:	68db      	ldr	r3, [r3, #12]
 80060fa:	68fa      	ldr	r2, [r7, #12]
 80060fc:	f8d2 0204 	ldr.w	r0, [r2, #516]	; 0x204
 8006100:	68fa      	ldr	r2, [r7, #12]
 8006102:	f502 7203 	add.w	r2, r2, #524	; 0x20c
 8006106:	4611      	mov	r1, r2
 8006108:	4798      	blx	r3

  return (uint8_t)USBD_OK;
 800610a:	2300      	movs	r3, #0
}
 800610c:	4618      	mov	r0, r3
 800610e:	3710      	adds	r7, #16
 8006110:	46bd      	mov	sp, r7
 8006112:	bd80      	pop	{r7, pc}

08006114 <USBD_CDC_EP0_RxReady>:
  *         Handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 8006114:	b580      	push	{r7, lr}
 8006116:	b084      	sub	sp, #16
 8006118:	af00      	add	r7, sp, #0
 800611a:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800611c:	687b      	ldr	r3, [r7, #4]
 800611e:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8006122:	60fb      	str	r3, [r7, #12]

  if ((pdev->pUserData != NULL) && (hcdc->CmdOpCode != 0xFFU))
 8006124:	687b      	ldr	r3, [r7, #4]
 8006126:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 800612a:	2b00      	cmp	r3, #0
 800612c:	d015      	beq.n	800615a <USBD_CDC_EP0_RxReady+0x46>
 800612e:	68fb      	ldr	r3, [r7, #12]
 8006130:	f893 3200 	ldrb.w	r3, [r3, #512]	; 0x200
 8006134:	2bff      	cmp	r3, #255	; 0xff
 8006136:	d010      	beq.n	800615a <USBD_CDC_EP0_RxReady+0x46>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 8006138:	687b      	ldr	r3, [r7, #4]
 800613a:	f8d3 32c0 	ldr.w	r3, [r3, #704]	; 0x2c0
 800613e:	689b      	ldr	r3, [r3, #8]
 8006140:	68fa      	ldr	r2, [r7, #12]
 8006142:	f892 0200 	ldrb.w	r0, [r2, #512]	; 0x200
                                                      (uint8_t *)hcdc->data,
 8006146:	68f9      	ldr	r1, [r7, #12]
                                                      (uint16_t)hcdc->CmdLength);
 8006148:	68fa      	ldr	r2, [r7, #12]
 800614a:	f892 2201 	ldrb.w	r2, [r2, #513]	; 0x201
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData)->Control(hcdc->CmdOpCode,
 800614e:	b292      	uxth	r2, r2
 8006150:	4798      	blx	r3
    hcdc->CmdOpCode = 0xFFU;
 8006152:	68fb      	ldr	r3, [r7, #12]
 8006154:	22ff      	movs	r2, #255	; 0xff
 8006156:	f883 2200 	strb.w	r2, [r3, #512]	; 0x200

  }

  return (uint8_t)USBD_OK;
 800615a:	2300      	movs	r3, #0
}
 800615c:	4618      	mov	r0, r3
 800615e:	3710      	adds	r7, #16
 8006160:	46bd      	mov	sp, r7
 8006162:	bd80      	pop	{r7, pc}

08006164 <USBD_CDC_GetFSCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
 8006164:	b480      	push	{r7}
 8006166:	b083      	sub	sp, #12
 8006168:	af00      	add	r7, sp, #0
 800616a:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_CfgFSDesc);
 800616c:	687b      	ldr	r3, [r7, #4]
 800616e:	2243      	movs	r2, #67	; 0x43
 8006170:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_CfgFSDesc;
 8006172:	4b03      	ldr	r3, [pc, #12]	; (8006180 <USBD_CDC_GetFSCfgDesc+0x1c>)
}
 8006174:	4618      	mov	r0, r3
 8006176:	370c      	adds	r7, #12
 8006178:	46bd      	mov	sp, r7
 800617a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800617e:	4770      	bx	lr
 8006180:	2000009c 	.word	0x2000009c

08006184 <USBD_CDC_GetHSCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
 8006184:	b480      	push	{r7}
 8006186:	b083      	sub	sp, #12
 8006188:	af00      	add	r7, sp, #0
 800618a:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_CfgHSDesc);
 800618c:	687b      	ldr	r3, [r7, #4]
 800618e:	2243      	movs	r2, #67	; 0x43
 8006190:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_CfgHSDesc;
 8006192:	4b03      	ldr	r3, [pc, #12]	; (80061a0 <USBD_CDC_GetHSCfgDesc+0x1c>)
}
 8006194:	4618      	mov	r0, r3
 8006196:	370c      	adds	r7, #12
 8006198:	46bd      	mov	sp, r7
 800619a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800619e:	4770      	bx	lr
 80061a0:	20000058 	.word	0x20000058

080061a4 <USBD_CDC_GetOtherSpeedCfgDesc>:
  * @param  speed : current device speed
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
 80061a4:	b480      	push	{r7}
 80061a6:	b083      	sub	sp, #12
 80061a8:	af00      	add	r7, sp, #0
 80061aa:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_OtherSpeedCfgDesc);
 80061ac:	687b      	ldr	r3, [r7, #4]
 80061ae:	2243      	movs	r2, #67	; 0x43
 80061b0:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_OtherSpeedCfgDesc;
 80061b2:	4b03      	ldr	r3, [pc, #12]	; (80061c0 <USBD_CDC_GetOtherSpeedCfgDesc+0x1c>)
}
 80061b4:	4618      	mov	r0, r3
 80061b6:	370c      	adds	r7, #12
 80061b8:	46bd      	mov	sp, r7
 80061ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80061be:	4770      	bx	lr
 80061c0:	200000e0 	.word	0x200000e0

080061c4 <USBD_CDC_GetDeviceQualifierDescriptor>:
*         return Device Qualifier descriptor
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 80061c4:	b480      	push	{r7}
 80061c6:	b083      	sub	sp, #12
 80061c8:	af00      	add	r7, sp, #0
 80061ca:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 80061cc:	687b      	ldr	r3, [r7, #4]
 80061ce:	220a      	movs	r2, #10
 80061d0:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_DeviceQualifierDesc;
 80061d2:	4b03      	ldr	r3, [pc, #12]	; (80061e0 <USBD_CDC_GetDeviceQualifierDescriptor+0x1c>)
}
 80061d4:	4618      	mov	r0, r3
 80061d6:	370c      	adds	r7, #12
 80061d8:	46bd      	mov	sp, r7
 80061da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80061de:	4770      	bx	lr
 80061e0:	20000014 	.word	0x20000014

080061e4 <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
 80061e4:	b480      	push	{r7}
 80061e6:	b083      	sub	sp, #12
 80061e8:	af00      	add	r7, sp, #0
 80061ea:	6078      	str	r0, [r7, #4]
 80061ec:	6039      	str	r1, [r7, #0]
  if (fops == NULL)
 80061ee:	683b      	ldr	r3, [r7, #0]
 80061f0:	2b00      	cmp	r3, #0
 80061f2:	d101      	bne.n	80061f8 <USBD_CDC_RegisterInterface+0x14>
  {
    return (uint8_t)USBD_FAIL;
 80061f4:	2303      	movs	r3, #3
 80061f6:	e004      	b.n	8006202 <USBD_CDC_RegisterInterface+0x1e>
  }

  pdev->pUserData = fops;
 80061f8:	687b      	ldr	r3, [r7, #4]
 80061fa:	683a      	ldr	r2, [r7, #0]
 80061fc:	f8c3 22c0 	str.w	r2, [r3, #704]	; 0x2c0

  return (uint8_t)USBD_OK;
 8006200:	2300      	movs	r3, #0
}
 8006202:	4618      	mov	r0, r3
 8006204:	370c      	adds	r7, #12
 8006206:	46bd      	mov	sp, r7
 8006208:	f85d 7b04 	ldr.w	r7, [sp], #4
 800620c:	4770      	bx	lr

0800620e <USBD_CDC_SetTxBuffer>:
  * @param  pbuff: Tx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
 800620e:	b480      	push	{r7}
 8006210:	b087      	sub	sp, #28
 8006212:	af00      	add	r7, sp, #0
 8006214:	60f8      	str	r0, [r7, #12]
 8006216:	60b9      	str	r1, [r7, #8]
 8006218:	607a      	str	r2, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800621a:	68fb      	ldr	r3, [r7, #12]
 800621c:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8006220:	617b      	str	r3, [r7, #20]

  hcdc->TxBuffer = pbuff;
 8006222:	697b      	ldr	r3, [r7, #20]
 8006224:	68ba      	ldr	r2, [r7, #8]
 8006226:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
  hcdc->TxLength = length;
 800622a:	697b      	ldr	r3, [r7, #20]
 800622c:	687a      	ldr	r2, [r7, #4]
 800622e:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210

  return (uint8_t)USBD_OK;
 8006232:	2300      	movs	r3, #0
}
 8006234:	4618      	mov	r0, r3
 8006236:	371c      	adds	r7, #28
 8006238:	46bd      	mov	sp, r7
 800623a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800623e:	4770      	bx	lr

08006240 <USBD_CDC_SetRxBuffer>:
  * @param  pdev: device instance
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
 8006240:	b480      	push	{r7}
 8006242:	b085      	sub	sp, #20
 8006244:	af00      	add	r7, sp, #0
 8006246:	6078      	str	r0, [r7, #4]
 8006248:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 800624a:	687b      	ldr	r3, [r7, #4]
 800624c:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8006250:	60fb      	str	r3, [r7, #12]

  hcdc->RxBuffer = pbuff;
 8006252:	68fb      	ldr	r3, [r7, #12]
 8006254:	683a      	ldr	r2, [r7, #0]
 8006256:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204

  return (uint8_t)USBD_OK;
 800625a:	2300      	movs	r3, #0
}
 800625c:	4618      	mov	r0, r3
 800625e:	3714      	adds	r7, #20
 8006260:	46bd      	mov	sp, r7
 8006262:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006266:	4770      	bx	lr

08006268 <USBD_CDC_ReceivePacket>:
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
 8006268:	b580      	push	{r7, lr}
 800626a:	b084      	sub	sp, #16
 800626c:	af00      	add	r7, sp, #0
 800626e:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassData;
 8006270:	687b      	ldr	r3, [r7, #4]
 8006272:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 8006276:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassData == NULL)
 8006278:	687b      	ldr	r3, [r7, #4]
 800627a:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 800627e:	2b00      	cmp	r3, #0
 8006280:	d101      	bne.n	8006286 <USBD_CDC_ReceivePacket+0x1e>
  {
    return (uint8_t)USBD_FAIL;
 8006282:	2303      	movs	r3, #3
 8006284:	e016      	b.n	80062b4 <USBD_CDC_ReceivePacket+0x4c>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8006286:	687b      	ldr	r3, [r7, #4]
 8006288:	7c1b      	ldrb	r3, [r3, #16]
 800628a:	2b00      	cmp	r3, #0
 800628c:	d109      	bne.n	80062a2 <USBD_CDC_ReceivePacket+0x3a>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 800628e:	68fb      	ldr	r3, [r7, #12]
 8006290:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8006294:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006298:	2101      	movs	r1, #1
 800629a:	6878      	ldr	r0, [r7, #4]
 800629c:	f001 fd9e 	bl	8007ddc <USBD_LL_PrepareReceive>
 80062a0:	e007      	b.n	80062b2 <USBD_CDC_ReceivePacket+0x4a>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDC_OUT_EP, hcdc->RxBuffer,
 80062a2:	68fb      	ldr	r3, [r7, #12]
 80062a4:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 80062a8:	2340      	movs	r3, #64	; 0x40
 80062aa:	2101      	movs	r1, #1
 80062ac:	6878      	ldr	r0, [r7, #4]
 80062ae:	f001 fd95 	bl	8007ddc <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 80062b2:	2300      	movs	r3, #0
}
 80062b4:	4618      	mov	r0, r3
 80062b6:	3710      	adds	r7, #16
 80062b8:	46bd      	mov	sp, r7
 80062ba:	bd80      	pop	{r7, pc}

080062bc <USBD_Init>:
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 80062bc:	b580      	push	{r7, lr}
 80062be:	b086      	sub	sp, #24
 80062c0:	af00      	add	r7, sp, #0
 80062c2:	60f8      	str	r0, [r7, #12]
 80062c4:	60b9      	str	r1, [r7, #8]
 80062c6:	4613      	mov	r3, r2
 80062c8:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 80062ca:	68fb      	ldr	r3, [r7, #12]
 80062cc:	2b00      	cmp	r3, #0
 80062ce:	d101      	bne.n	80062d4 <USBD_Init+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif
    return USBD_FAIL;
 80062d0:	2303      	movs	r3, #3
 80062d2:	e025      	b.n	8006320 <USBD_Init+0x64>
  }

  /* Unlink previous class */
  if (pdev->pClass != NULL)
 80062d4:	68fb      	ldr	r3, [r7, #12]
 80062d6:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80062da:	2b00      	cmp	r3, #0
 80062dc:	d003      	beq.n	80062e6 <USBD_Init+0x2a>
  {
    pdev->pClass = NULL;
 80062de:	68fb      	ldr	r3, [r7, #12]
 80062e0:	2200      	movs	r2, #0
 80062e2:	f8c3 22b8 	str.w	r2, [r3, #696]	; 0x2b8
  }

  if (pdev->pConfDesc != NULL)
 80062e6:	68fb      	ldr	r3, [r7, #12]
 80062e8:	f8d3 32cc 	ldr.w	r3, [r3, #716]	; 0x2cc
 80062ec:	2b00      	cmp	r3, #0
 80062ee:	d003      	beq.n	80062f8 <USBD_Init+0x3c>
  {
    pdev->pConfDesc = NULL;
 80062f0:	68fb      	ldr	r3, [r7, #12]
 80062f2:	2200      	movs	r2, #0
 80062f4:	f8c3 22cc 	str.w	r2, [r3, #716]	; 0x2cc
  }

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 80062f8:	68bb      	ldr	r3, [r7, #8]
 80062fa:	2b00      	cmp	r3, #0
 80062fc:	d003      	beq.n	8006306 <USBD_Init+0x4a>
  {
    pdev->pDesc = pdesc;
 80062fe:	68fb      	ldr	r3, [r7, #12]
 8006300:	68ba      	ldr	r2, [r7, #8]
 8006302:	f8c3 22b4 	str.w	r2, [r3, #692]	; 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8006306:	68fb      	ldr	r3, [r7, #12]
 8006308:	2201      	movs	r2, #1
 800630a:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  pdev->id = id;
 800630e:	68fb      	ldr	r3, [r7, #12]
 8006310:	79fa      	ldrb	r2, [r7, #7]
 8006312:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 8006314:	68f8      	ldr	r0, [r7, #12]
 8006316:	f001 fc0b 	bl	8007b30 <USBD_LL_Init>
 800631a:	4603      	mov	r3, r0
 800631c:	75fb      	strb	r3, [r7, #23]

  return ret;
 800631e:	7dfb      	ldrb	r3, [r7, #23]
}
 8006320:	4618      	mov	r0, r3
 8006322:	3718      	adds	r7, #24
 8006324:	46bd      	mov	sp, r7
 8006326:	bd80      	pop	{r7, pc}

08006328 <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 8006328:	b580      	push	{r7, lr}
 800632a:	b084      	sub	sp, #16
 800632c:	af00      	add	r7, sp, #0
 800632e:	6078      	str	r0, [r7, #4]
 8006330:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8006332:	2300      	movs	r3, #0
 8006334:	81fb      	strh	r3, [r7, #14]

  if (pclass == NULL)
 8006336:	683b      	ldr	r3, [r7, #0]
 8006338:	2b00      	cmp	r3, #0
 800633a:	d101      	bne.n	8006340 <USBD_RegisterClass+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif
    return USBD_FAIL;
 800633c:	2303      	movs	r3, #3
 800633e:	e010      	b.n	8006362 <USBD_RegisterClass+0x3a>
  }

  /* link the class to the USB Device handle */
  pdev->pClass = pclass;
 8006340:	687b      	ldr	r3, [r7, #4]
 8006342:	683a      	ldr	r2, [r7, #0]
 8006344:	f8c3 22b8 	str.w	r2, [r3, #696]	; 0x2b8

  /* Get Device Configuration Descriptor */
#ifdef USE_USB_FS
  pdev->pConfDesc = (void *)pdev->pClass->GetFSConfigDescriptor(&len);
#else /* USE_USB_HS */
  pdev->pConfDesc = (void *)pdev->pClass->GetHSConfigDescriptor(&len);
 8006348:	687b      	ldr	r3, [r7, #4]
 800634a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 800634e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006350:	f107 020e 	add.w	r2, r7, #14
 8006354:	4610      	mov	r0, r2
 8006356:	4798      	blx	r3
 8006358:	4602      	mov	r2, r0
 800635a:	687b      	ldr	r3, [r7, #4]
 800635c:	f8c3 22cc 	str.w	r2, [r3, #716]	; 0x2cc
#endif /* USE_USB_FS */


  return USBD_OK;
 8006360:	2300      	movs	r3, #0
}
 8006362:	4618      	mov	r0, r3
 8006364:	3710      	adds	r7, #16
 8006366:	46bd      	mov	sp, r7
 8006368:	bd80      	pop	{r7, pc}

0800636a <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
 800636a:	b580      	push	{r7, lr}
 800636c:	b082      	sub	sp, #8
 800636e:	af00      	add	r7, sp, #0
 8006370:	6078      	str	r0, [r7, #4]
  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 8006372:	6878      	ldr	r0, [r7, #4]
 8006374:	f001 fc28 	bl	8007bc8 <USBD_LL_Start>
 8006378:	4603      	mov	r3, r0
}
 800637a:	4618      	mov	r0, r3
 800637c:	3708      	adds	r7, #8
 800637e:	46bd      	mov	sp, r7
 8006380:	bd80      	pop	{r7, pc}

08006382 <USBD_RunTestMode>:
*         Launch test mode process
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef  *pdev)
{
 8006382:	b480      	push	{r7}
 8006384:	b083      	sub	sp, #12
 8006386:	af00      	add	r7, sp, #0
 8006388:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 800638a:	2300      	movs	r3, #0
}
 800638c:	4618      	mov	r0, r3
 800638e:	370c      	adds	r7, #12
 8006390:	46bd      	mov	sp, r7
 8006392:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006396:	4770      	bx	lr

08006398 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8006398:	b580      	push	{r7, lr}
 800639a:	b084      	sub	sp, #16
 800639c:	af00      	add	r7, sp, #0
 800639e:	6078      	str	r0, [r7, #4]
 80063a0:	460b      	mov	r3, r1
 80063a2:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_FAIL;
 80063a4:	2303      	movs	r3, #3
 80063a6:	73fb      	strb	r3, [r7, #15]

  if (pdev->pClass != NULL)
 80063a8:	687b      	ldr	r3, [r7, #4]
 80063aa:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80063ae:	2b00      	cmp	r3, #0
 80063b0:	d009      	beq.n	80063c6 <USBD_SetClassConfig+0x2e>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass->Init(pdev, cfgidx);
 80063b2:	687b      	ldr	r3, [r7, #4]
 80063b4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80063b8:	681b      	ldr	r3, [r3, #0]
 80063ba:	78fa      	ldrb	r2, [r7, #3]
 80063bc:	4611      	mov	r1, r2
 80063be:	6878      	ldr	r0, [r7, #4]
 80063c0:	4798      	blx	r3
 80063c2:	4603      	mov	r3, r0
 80063c4:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
 80063c6:	7bfb      	ldrb	r3, [r7, #15]
}
 80063c8:	4618      	mov	r0, r3
 80063ca:	3710      	adds	r7, #16
 80063cc:	46bd      	mov	sp, r7
 80063ce:	bd80      	pop	{r7, pc}

080063d0 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80063d0:	b580      	push	{r7, lr}
 80063d2:	b082      	sub	sp, #8
 80063d4:	af00      	add	r7, sp, #0
 80063d6:	6078      	str	r0, [r7, #4]
 80063d8:	460b      	mov	r3, r1
 80063da:	70fb      	strb	r3, [r7, #3]
  /* Clear configuration and De-initialize the Class process */
  if (pdev->pClass != NULL)
 80063dc:	687b      	ldr	r3, [r7, #4]
 80063de:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80063e2:	2b00      	cmp	r3, #0
 80063e4:	d007      	beq.n	80063f6 <USBD_ClrClassConfig+0x26>
  {
    pdev->pClass->DeInit(pdev, cfgidx);
 80063e6:	687b      	ldr	r3, [r7, #4]
 80063e8:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80063ec:	685b      	ldr	r3, [r3, #4]
 80063ee:	78fa      	ldrb	r2, [r7, #3]
 80063f0:	4611      	mov	r1, r2
 80063f2:	6878      	ldr	r0, [r7, #4]
 80063f4:	4798      	blx	r3
  }

  return USBD_OK;
 80063f6:	2300      	movs	r3, #0
}
 80063f8:	4618      	mov	r0, r3
 80063fa:	3708      	adds	r7, #8
 80063fc:	46bd      	mov	sp, r7
 80063fe:	bd80      	pop	{r7, pc}

08006400 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8006400:	b580      	push	{r7, lr}
 8006402:	b084      	sub	sp, #16
 8006404:	af00      	add	r7, sp, #0
 8006406:	6078      	str	r0, [r7, #4]
 8006408:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 800640a:	687b      	ldr	r3, [r7, #4]
 800640c:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 8006410:	6839      	ldr	r1, [r7, #0]
 8006412:	4618      	mov	r0, r3
 8006414:	f000 ff3b 	bl	800728e <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 8006418:	687b      	ldr	r3, [r7, #4]
 800641a:	2201      	movs	r2, #1
 800641c:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 8006420:	687b      	ldr	r3, [r7, #4]
 8006422:	f8b3 32b0 	ldrh.w	r3, [r3, #688]	; 0x2b0
 8006426:	461a      	mov	r2, r3
 8006428:	687b      	ldr	r3, [r7, #4]
 800642a:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 800642e:	687b      	ldr	r3, [r7, #4]
 8006430:	f893 32aa 	ldrb.w	r3, [r3, #682]	; 0x2aa
 8006434:	f003 031f 	and.w	r3, r3, #31
 8006438:	2b02      	cmp	r3, #2
 800643a:	d01a      	beq.n	8006472 <USBD_LL_SetupStage+0x72>
 800643c:	2b02      	cmp	r3, #2
 800643e:	d822      	bhi.n	8006486 <USBD_LL_SetupStage+0x86>
 8006440:	2b00      	cmp	r3, #0
 8006442:	d002      	beq.n	800644a <USBD_LL_SetupStage+0x4a>
 8006444:	2b01      	cmp	r3, #1
 8006446:	d00a      	beq.n	800645e <USBD_LL_SetupStage+0x5e>
 8006448:	e01d      	b.n	8006486 <USBD_LL_SetupStage+0x86>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 800644a:	687b      	ldr	r3, [r7, #4]
 800644c:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 8006450:	4619      	mov	r1, r3
 8006452:	6878      	ldr	r0, [r7, #4]
 8006454:	f000 fa18 	bl	8006888 <USBD_StdDevReq>
 8006458:	4603      	mov	r3, r0
 800645a:	73fb      	strb	r3, [r7, #15]
      break;
 800645c:	e020      	b.n	80064a0 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_INTERFACE:
      ret = USBD_StdItfReq(pdev, &pdev->request);
 800645e:	687b      	ldr	r3, [r7, #4]
 8006460:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 8006464:	4619      	mov	r1, r3
 8006466:	6878      	ldr	r0, [r7, #4]
 8006468:	f000 fa7c 	bl	8006964 <USBD_StdItfReq>
 800646c:	4603      	mov	r3, r0
 800646e:	73fb      	strb	r3, [r7, #15]
      break;
 8006470:	e016      	b.n	80064a0 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
 8006472:	687b      	ldr	r3, [r7, #4]
 8006474:	f203 23aa 	addw	r3, r3, #682	; 0x2aa
 8006478:	4619      	mov	r1, r3
 800647a:	6878      	ldr	r0, [r7, #4]
 800647c:	f000 faba 	bl	80069f4 <USBD_StdEPReq>
 8006480:	4603      	mov	r3, r0
 8006482:	73fb      	strb	r3, [r7, #15]
      break;
 8006484:	e00c      	b.n	80064a0 <USBD_LL_SetupStage+0xa0>

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 8006486:	687b      	ldr	r3, [r7, #4]
 8006488:	f893 32aa 	ldrb.w	r3, [r3, #682]	; 0x2aa
 800648c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8006490:	b2db      	uxtb	r3, r3
 8006492:	4619      	mov	r1, r3
 8006494:	6878      	ldr	r0, [r7, #4]
 8006496:	f001 fbf7 	bl	8007c88 <USBD_LL_StallEP>
 800649a:	4603      	mov	r3, r0
 800649c:	73fb      	strb	r3, [r7, #15]
      break;
 800649e:	bf00      	nop
  }

  return ret;
 80064a0:	7bfb      	ldrb	r3, [r7, #15]
}
 80064a2:	4618      	mov	r0, r3
 80064a4:	3710      	adds	r7, #16
 80064a6:	46bd      	mov	sp, r7
 80064a8:	bd80      	pop	{r7, pc}

080064aa <USBD_LL_DataOutStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 80064aa:	b580      	push	{r7, lr}
 80064ac:	b086      	sub	sp, #24
 80064ae:	af00      	add	r7, sp, #0
 80064b0:	60f8      	str	r0, [r7, #12]
 80064b2:	460b      	mov	r3, r1
 80064b4:	607a      	str	r2, [r7, #4]
 80064b6:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;

  if (epnum == 0U)
 80064b8:	7afb      	ldrb	r3, [r7, #11]
 80064ba:	2b00      	cmp	r3, #0
 80064bc:	d137      	bne.n	800652e <USBD_LL_DataOutStage+0x84>
  {
    pep = &pdev->ep_out[0];
 80064be:	68fb      	ldr	r3, [r7, #12]
 80064c0:	f503 73aa 	add.w	r3, r3, #340	; 0x154
 80064c4:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 80064c6:	68fb      	ldr	r3, [r7, #12]
 80064c8:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 80064cc:	2b03      	cmp	r3, #3
 80064ce:	d14a      	bne.n	8006566 <USBD_LL_DataOutStage+0xbc>
    {
      if (pep->rem_length > pep->maxpacket)
 80064d0:	693b      	ldr	r3, [r7, #16]
 80064d2:	689a      	ldr	r2, [r3, #8]
 80064d4:	693b      	ldr	r3, [r7, #16]
 80064d6:	68db      	ldr	r3, [r3, #12]
 80064d8:	429a      	cmp	r2, r3
 80064da:	d913      	bls.n	8006504 <USBD_LL_DataOutStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 80064dc:	693b      	ldr	r3, [r7, #16]
 80064de:	689a      	ldr	r2, [r3, #8]
 80064e0:	693b      	ldr	r3, [r7, #16]
 80064e2:	68db      	ldr	r3, [r3, #12]
 80064e4:	1ad2      	subs	r2, r2, r3
 80064e6:	693b      	ldr	r3, [r7, #16]
 80064e8:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 80064ea:	693b      	ldr	r3, [r7, #16]
 80064ec:	68da      	ldr	r2, [r3, #12]
 80064ee:	693b      	ldr	r3, [r7, #16]
 80064f0:	689b      	ldr	r3, [r3, #8]
 80064f2:	4293      	cmp	r3, r2
 80064f4:	bf28      	it	cs
 80064f6:	4613      	movcs	r3, r2
 80064f8:	461a      	mov	r2, r3
 80064fa:	6879      	ldr	r1, [r7, #4]
 80064fc:	68f8      	ldr	r0, [r7, #12]
 80064fe:	f000 ffba 	bl	8007476 <USBD_CtlContinueRx>
 8006502:	e030      	b.n	8006566 <USBD_LL_DataOutStage+0xbc>
      }
      else
      {
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 8006504:	68fb      	ldr	r3, [r7, #12]
 8006506:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 800650a:	691b      	ldr	r3, [r3, #16]
 800650c:	2b00      	cmp	r3, #0
 800650e:	d00a      	beq.n	8006526 <USBD_LL_DataOutStage+0x7c>
            (pdev->dev_state == USBD_STATE_CONFIGURED))
 8006510:	68fb      	ldr	r3, [r7, #12]
 8006512:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
        if ((pdev->pClass->EP0_RxReady != NULL) &&
 8006516:	2b03      	cmp	r3, #3
 8006518:	d105      	bne.n	8006526 <USBD_LL_DataOutStage+0x7c>
        {
          pdev->pClass->EP0_RxReady(pdev);
 800651a:	68fb      	ldr	r3, [r7, #12]
 800651c:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006520:	691b      	ldr	r3, [r3, #16]
 8006522:	68f8      	ldr	r0, [r7, #12]
 8006524:	4798      	blx	r3
        }
        (void)USBD_CtlSendStatus(pdev);
 8006526:	68f8      	ldr	r0, [r7, #12]
 8006528:	f000 ffb6 	bl	8007498 <USBD_CtlSendStatus>
 800652c:	e01b      	b.n	8006566 <USBD_LL_DataOutStage+0xbc>
        (void)USBD_LL_StallEP(pdev, 0U);
      }
#endif
    }
  }
  else if ((pdev->pClass->DataOut != NULL) &&
 800652e:	68fb      	ldr	r3, [r7, #12]
 8006530:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006534:	699b      	ldr	r3, [r3, #24]
 8006536:	2b00      	cmp	r3, #0
 8006538:	d013      	beq.n	8006562 <USBD_LL_DataOutStage+0xb8>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
 800653a:	68fb      	ldr	r3, [r7, #12]
 800653c:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
  else if ((pdev->pClass->DataOut != NULL) &&
 8006540:	2b03      	cmp	r3, #3
 8006542:	d10e      	bne.n	8006562 <USBD_LL_DataOutStage+0xb8>
  {
    ret = (USBD_StatusTypeDef)pdev->pClass->DataOut(pdev, epnum);
 8006544:	68fb      	ldr	r3, [r7, #12]
 8006546:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 800654a:	699b      	ldr	r3, [r3, #24]
 800654c:	7afa      	ldrb	r2, [r7, #11]
 800654e:	4611      	mov	r1, r2
 8006550:	68f8      	ldr	r0, [r7, #12]
 8006552:	4798      	blx	r3
 8006554:	4603      	mov	r3, r0
 8006556:	75fb      	strb	r3, [r7, #23]

    if (ret != USBD_OK)
 8006558:	7dfb      	ldrb	r3, [r7, #23]
 800655a:	2b00      	cmp	r3, #0
 800655c:	d003      	beq.n	8006566 <USBD_LL_DataOutStage+0xbc>
    {
      return ret;
 800655e:	7dfb      	ldrb	r3, [r7, #23]
 8006560:	e002      	b.n	8006568 <USBD_LL_DataOutStage+0xbe>
    }
  }
  else
  {
    /* should never be in this condition */
    return USBD_FAIL;
 8006562:	2303      	movs	r3, #3
 8006564:	e000      	b.n	8006568 <USBD_LL_DataOutStage+0xbe>
  }

  return USBD_OK;
 8006566:	2300      	movs	r3, #0
}
 8006568:	4618      	mov	r0, r3
 800656a:	3718      	adds	r7, #24
 800656c:	46bd      	mov	sp, r7
 800656e:	bd80      	pop	{r7, pc}

08006570 <USBD_LL_DataInStage>:
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 8006570:	b580      	push	{r7, lr}
 8006572:	b086      	sub	sp, #24
 8006574:	af00      	add	r7, sp, #0
 8006576:	60f8      	str	r0, [r7, #12]
 8006578:	460b      	mov	r3, r1
 800657a:	607a      	str	r2, [r7, #4]
 800657c:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;

  if (epnum == 0U)
 800657e:	7afb      	ldrb	r3, [r7, #11]
 8006580:	2b00      	cmp	r3, #0
 8006582:	d16a      	bne.n	800665a <USBD_LL_DataInStage+0xea>
  {
    pep = &pdev->ep_in[0];
 8006584:	68fb      	ldr	r3, [r7, #12]
 8006586:	3314      	adds	r3, #20
 8006588:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 800658a:	68fb      	ldr	r3, [r7, #12]
 800658c:	f8d3 3294 	ldr.w	r3, [r3, #660]	; 0x294
 8006590:	2b02      	cmp	r3, #2
 8006592:	d155      	bne.n	8006640 <USBD_LL_DataInStage+0xd0>
    {
      if (pep->rem_length > pep->maxpacket)
 8006594:	693b      	ldr	r3, [r7, #16]
 8006596:	689a      	ldr	r2, [r3, #8]
 8006598:	693b      	ldr	r3, [r7, #16]
 800659a:	68db      	ldr	r3, [r3, #12]
 800659c:	429a      	cmp	r2, r3
 800659e:	d914      	bls.n	80065ca <USBD_LL_DataInStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 80065a0:	693b      	ldr	r3, [r7, #16]
 80065a2:	689a      	ldr	r2, [r3, #8]
 80065a4:	693b      	ldr	r3, [r7, #16]
 80065a6:	68db      	ldr	r3, [r3, #12]
 80065a8:	1ad2      	subs	r2, r2, r3
 80065aa:	693b      	ldr	r3, [r7, #16]
 80065ac:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 80065ae:	693b      	ldr	r3, [r7, #16]
 80065b0:	689b      	ldr	r3, [r3, #8]
 80065b2:	461a      	mov	r2, r3
 80065b4:	6879      	ldr	r1, [r7, #4]
 80065b6:	68f8      	ldr	r0, [r7, #12]
 80065b8:	f000 ff2f 	bl	800741a <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
       (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80065bc:	2300      	movs	r3, #0
 80065be:	2200      	movs	r2, #0
 80065c0:	2100      	movs	r1, #0
 80065c2:	68f8      	ldr	r0, [r7, #12]
 80065c4:	f001 fc0a 	bl	8007ddc <USBD_LL_PrepareReceive>
 80065c8:	e03a      	b.n	8006640 <USBD_LL_DataInStage+0xd0>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->maxpacket == pep->rem_length) &&
 80065ca:	693b      	ldr	r3, [r7, #16]
 80065cc:	68da      	ldr	r2, [r3, #12]
 80065ce:	693b      	ldr	r3, [r7, #16]
 80065d0:	689b      	ldr	r3, [r3, #8]
 80065d2:	429a      	cmp	r2, r3
 80065d4:	d11c      	bne.n	8006610 <USBD_LL_DataInStage+0xa0>
            (pep->total_length >= pep->maxpacket) &&
 80065d6:	693b      	ldr	r3, [r7, #16]
 80065d8:	685a      	ldr	r2, [r3, #4]
 80065da:	693b      	ldr	r3, [r7, #16]
 80065dc:	68db      	ldr	r3, [r3, #12]
        if ((pep->maxpacket == pep->rem_length) &&
 80065de:	429a      	cmp	r2, r3
 80065e0:	d316      	bcc.n	8006610 <USBD_LL_DataInStage+0xa0>
            (pep->total_length < pdev->ep0_data_len))
 80065e2:	693b      	ldr	r3, [r7, #16]
 80065e4:	685a      	ldr	r2, [r3, #4]
 80065e6:	68fb      	ldr	r3, [r7, #12]
 80065e8:	f8d3 3298 	ldr.w	r3, [r3, #664]	; 0x298
            (pep->total_length >= pep->maxpacket) &&
 80065ec:	429a      	cmp	r2, r3
 80065ee:	d20f      	bcs.n	8006610 <USBD_LL_DataInStage+0xa0>
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 80065f0:	2200      	movs	r2, #0
 80065f2:	2100      	movs	r1, #0
 80065f4:	68f8      	ldr	r0, [r7, #12]
 80065f6:	f000 ff10 	bl	800741a <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 80065fa:	68fb      	ldr	r3, [r7, #12]
 80065fc:	2200      	movs	r2, #0
 80065fe:	f8c3 2298 	str.w	r2, [r3, #664]	; 0x298

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 8006602:	2300      	movs	r3, #0
 8006604:	2200      	movs	r2, #0
 8006606:	2100      	movs	r1, #0
 8006608:	68f8      	ldr	r0, [r7, #12]
 800660a:	f001 fbe7 	bl	8007ddc <USBD_LL_PrepareReceive>
 800660e:	e017      	b.n	8006640 <USBD_LL_DataInStage+0xd0>
        }
        else
        {
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 8006610:	68fb      	ldr	r3, [r7, #12]
 8006612:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006616:	68db      	ldr	r3, [r3, #12]
 8006618:	2b00      	cmp	r3, #0
 800661a:	d00a      	beq.n	8006632 <USBD_LL_DataInStage+0xc2>
              (pdev->dev_state == USBD_STATE_CONFIGURED))
 800661c:	68fb      	ldr	r3, [r7, #12]
 800661e:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
          if ((pdev->pClass->EP0_TxSent != NULL) &&
 8006622:	2b03      	cmp	r3, #3
 8006624:	d105      	bne.n	8006632 <USBD_LL_DataInStage+0xc2>
          {
            pdev->pClass->EP0_TxSent(pdev);
 8006626:	68fb      	ldr	r3, [r7, #12]
 8006628:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 800662c:	68db      	ldr	r3, [r3, #12]
 800662e:	68f8      	ldr	r0, [r7, #12]
 8006630:	4798      	blx	r3
          }
          (void)USBD_LL_StallEP(pdev, 0x80U);
 8006632:	2180      	movs	r1, #128	; 0x80
 8006634:	68f8      	ldr	r0, [r7, #12]
 8006636:	f001 fb27 	bl	8007c88 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 800663a:	68f8      	ldr	r0, [r7, #12]
 800663c:	f000 ff3f 	bl	80074be <USBD_CtlReceiveStatus>
        (void)USBD_LL_StallEP(pdev, 0x80U);
      }
#endif
    }

    if (pdev->dev_test_mode == 1U)
 8006640:	68fb      	ldr	r3, [r7, #12]
 8006642:	f893 32a0 	ldrb.w	r3, [r3, #672]	; 0x2a0
 8006646:	2b01      	cmp	r3, #1
 8006648:	d123      	bne.n	8006692 <USBD_LL_DataInStage+0x122>
    {
      (void)USBD_RunTestMode(pdev);
 800664a:	68f8      	ldr	r0, [r7, #12]
 800664c:	f7ff fe99 	bl	8006382 <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
 8006650:	68fb      	ldr	r3, [r7, #12]
 8006652:	2200      	movs	r2, #0
 8006654:	f883 22a0 	strb.w	r2, [r3, #672]	; 0x2a0
 8006658:	e01b      	b.n	8006692 <USBD_LL_DataInStage+0x122>
    }
  }
  else if ((pdev->pClass->DataIn != NULL) &&
 800665a:	68fb      	ldr	r3, [r7, #12]
 800665c:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006660:	695b      	ldr	r3, [r3, #20]
 8006662:	2b00      	cmp	r3, #0
 8006664:	d013      	beq.n	800668e <USBD_LL_DataInStage+0x11e>
           (pdev->dev_state == USBD_STATE_CONFIGURED))
 8006666:	68fb      	ldr	r3, [r7, #12]
 8006668:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
  else if ((pdev->pClass->DataIn != NULL) &&
 800666c:	2b03      	cmp	r3, #3
 800666e:	d10e      	bne.n	800668e <USBD_LL_DataInStage+0x11e>
  {
    ret = (USBD_StatusTypeDef)pdev->pClass->DataIn(pdev, epnum);
 8006670:	68fb      	ldr	r3, [r7, #12]
 8006672:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006676:	695b      	ldr	r3, [r3, #20]
 8006678:	7afa      	ldrb	r2, [r7, #11]
 800667a:	4611      	mov	r1, r2
 800667c:	68f8      	ldr	r0, [r7, #12]
 800667e:	4798      	blx	r3
 8006680:	4603      	mov	r3, r0
 8006682:	75fb      	strb	r3, [r7, #23]

    if (ret != USBD_OK)
 8006684:	7dfb      	ldrb	r3, [r7, #23]
 8006686:	2b00      	cmp	r3, #0
 8006688:	d003      	beq.n	8006692 <USBD_LL_DataInStage+0x122>
    {
      return ret;
 800668a:	7dfb      	ldrb	r3, [r7, #23]
 800668c:	e002      	b.n	8006694 <USBD_LL_DataInStage+0x124>
    }
  }
  else
  {
    /* should never be in this condition */
    return USBD_FAIL;
 800668e:	2303      	movs	r3, #3
 8006690:	e000      	b.n	8006694 <USBD_LL_DataInStage+0x124>
  }

  return USBD_OK;
 8006692:	2300      	movs	r3, #0
}
 8006694:	4618      	mov	r0, r3
 8006696:	3718      	adds	r7, #24
 8006698:	46bd      	mov	sp, r7
 800669a:	bd80      	pop	{r7, pc}

0800669c <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 800669c:	b580      	push	{r7, lr}
 800669e:	b082      	sub	sp, #8
 80066a0:	af00      	add	r7, sp, #0
 80066a2:	6078      	str	r0, [r7, #4]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 80066a4:	687b      	ldr	r3, [r7, #4]
 80066a6:	2201      	movs	r2, #1
 80066a8:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 80066ac:	687b      	ldr	r3, [r7, #4]
 80066ae:	2200      	movs	r2, #0
 80066b0:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  pdev->dev_config = 0U;
 80066b4:	687b      	ldr	r3, [r7, #4]
 80066b6:	2200      	movs	r2, #0
 80066b8:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
 80066ba:	687b      	ldr	r3, [r7, #4]
 80066bc:	2200      	movs	r2, #0
 80066be:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4

  if (pdev->pClassData != NULL)
 80066c2:	687b      	ldr	r3, [r7, #4]
 80066c4:	f8d3 32bc 	ldr.w	r3, [r3, #700]	; 0x2bc
 80066c8:	2b00      	cmp	r3, #0
 80066ca:	d009      	beq.n	80066e0 <USBD_LL_Reset+0x44>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 80066cc:	687b      	ldr	r3, [r7, #4]
 80066ce:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80066d2:	685b      	ldr	r3, [r3, #4]
 80066d4:	687a      	ldr	r2, [r7, #4]
 80066d6:	6852      	ldr	r2, [r2, #4]
 80066d8:	b2d2      	uxtb	r2, r2
 80066da:	4611      	mov	r1, r2
 80066dc:	6878      	ldr	r0, [r7, #4]
 80066de:	4798      	blx	r3
  }

    /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80066e0:	2340      	movs	r3, #64	; 0x40
 80066e2:	2200      	movs	r2, #0
 80066e4:	2100      	movs	r1, #0
 80066e6:	6878      	ldr	r0, [r7, #4]
 80066e8:	f001 fa89 	bl	8007bfe <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 80066ec:	687b      	ldr	r3, [r7, #4]
 80066ee:	2201      	movs	r2, #1
 80066f0:	f8a3 2164 	strh.w	r2, [r3, #356]	; 0x164

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 80066f4:	687b      	ldr	r3, [r7, #4]
 80066f6:	2240      	movs	r2, #64	; 0x40
 80066f8:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 80066fc:	2340      	movs	r3, #64	; 0x40
 80066fe:	2200      	movs	r2, #0
 8006700:	2180      	movs	r1, #128	; 0x80
 8006702:	6878      	ldr	r0, [r7, #4]
 8006704:	f001 fa7b 	bl	8007bfe <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 8006708:	687b      	ldr	r3, [r7, #4]
 800670a:	2201      	movs	r2, #1
 800670c:	849a      	strh	r2, [r3, #36]	; 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 800670e:	687b      	ldr	r3, [r7, #4]
 8006710:	2240      	movs	r2, #64	; 0x40
 8006712:	621a      	str	r2, [r3, #32]

  return USBD_OK;
 8006714:	2300      	movs	r3, #0
}
 8006716:	4618      	mov	r0, r3
 8006718:	3708      	adds	r7, #8
 800671a:	46bd      	mov	sp, r7
 800671c:	bd80      	pop	{r7, pc}

0800671e <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 800671e:	b480      	push	{r7}
 8006720:	b083      	sub	sp, #12
 8006722:	af00      	add	r7, sp, #0
 8006724:	6078      	str	r0, [r7, #4]
 8006726:	460b      	mov	r3, r1
 8006728:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 800672a:	687b      	ldr	r3, [r7, #4]
 800672c:	78fa      	ldrb	r2, [r7, #3]
 800672e:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
 8006730:	2300      	movs	r3, #0
}
 8006732:	4618      	mov	r0, r3
 8006734:	370c      	adds	r7, #12
 8006736:	46bd      	mov	sp, r7
 8006738:	f85d 7b04 	ldr.w	r7, [sp], #4
 800673c:	4770      	bx	lr

0800673e <USBD_LL_Suspend>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 800673e:	b480      	push	{r7}
 8006740:	b083      	sub	sp, #12
 8006742:	af00      	add	r7, sp, #0
 8006744:	6078      	str	r0, [r7, #4]
  pdev->dev_old_state = pdev->dev_state;
 8006746:	687b      	ldr	r3, [r7, #4]
 8006748:	f893 229c 	ldrb.w	r2, [r3, #668]	; 0x29c
 800674c:	687b      	ldr	r3, [r7, #4]
 800674e:	f883 229d 	strb.w	r2, [r3, #669]	; 0x29d
  pdev->dev_state = USBD_STATE_SUSPENDED;
 8006752:	687b      	ldr	r3, [r7, #4]
 8006754:	2204      	movs	r2, #4
 8006756:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c

  return USBD_OK;
 800675a:	2300      	movs	r3, #0
}
 800675c:	4618      	mov	r0, r3
 800675e:	370c      	adds	r7, #12
 8006760:	46bd      	mov	sp, r7
 8006762:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006766:	4770      	bx	lr

08006768 <USBD_LL_Resume>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
 8006768:	b480      	push	{r7}
 800676a:	b083      	sub	sp, #12
 800676c:	af00      	add	r7, sp, #0
 800676e:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 8006770:	687b      	ldr	r3, [r7, #4]
 8006772:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8006776:	2b04      	cmp	r3, #4
 8006778:	d105      	bne.n	8006786 <USBD_LL_Resume+0x1e>
  {
    pdev->dev_state = pdev->dev_old_state;
 800677a:	687b      	ldr	r3, [r7, #4]
 800677c:	f893 229d 	ldrb.w	r2, [r3, #669]	; 0x29d
 8006780:	687b      	ldr	r3, [r7, #4]
 8006782:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
  }

  return USBD_OK;
 8006786:	2300      	movs	r3, #0
}
 8006788:	4618      	mov	r0, r3
 800678a:	370c      	adds	r7, #12
 800678c:	46bd      	mov	sp, r7
 800678e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006792:	4770      	bx	lr

08006794 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 8006794:	b580      	push	{r7, lr}
 8006796:	b082      	sub	sp, #8
 8006798:	af00      	add	r7, sp, #0
 800679a:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 800679c:	687b      	ldr	r3, [r7, #4]
 800679e:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 80067a2:	2b03      	cmp	r3, #3
 80067a4:	d10b      	bne.n	80067be <USBD_LL_SOF+0x2a>
  {
    if (pdev->pClass->SOF != NULL)
 80067a6:	687b      	ldr	r3, [r7, #4]
 80067a8:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80067ac:	69db      	ldr	r3, [r3, #28]
 80067ae:	2b00      	cmp	r3, #0
 80067b0:	d005      	beq.n	80067be <USBD_LL_SOF+0x2a>
    {
      pdev->pClass->SOF(pdev);
 80067b2:	687b      	ldr	r3, [r7, #4]
 80067b4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80067b8:	69db      	ldr	r3, [r3, #28]
 80067ba:	6878      	ldr	r0, [r7, #4]
 80067bc:	4798      	blx	r3
    }
  }

  return USBD_OK;
 80067be:	2300      	movs	r3, #0
}
 80067c0:	4618      	mov	r0, r3
 80067c2:	3708      	adds	r7, #8
 80067c4:	46bd      	mov	sp, r7
 80067c6:	bd80      	pop	{r7, pc}

080067c8 <USBD_LL_IsoINIncomplete>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
 80067c8:	b480      	push	{r7}
 80067ca:	b083      	sub	sp, #12
 80067cc:	af00      	add	r7, sp, #0
 80067ce:	6078      	str	r0, [r7, #4]
 80067d0:	460b      	mov	r3, r1
 80067d2:	70fb      	strb	r3, [r7, #3]
  /* Prevent unused arguments compilation warning */
  UNUSED(pdev);
  UNUSED(epnum);

  return USBD_OK;
 80067d4:	2300      	movs	r3, #0
}
 80067d6:	4618      	mov	r0, r3
 80067d8:	370c      	adds	r7, #12
 80067da:	46bd      	mov	sp, r7
 80067dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067e0:	4770      	bx	lr

080067e2 <USBD_LL_IsoOUTIncomplete>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
 80067e2:	b480      	push	{r7}
 80067e4:	b083      	sub	sp, #12
 80067e6:	af00      	add	r7, sp, #0
 80067e8:	6078      	str	r0, [r7, #4]
 80067ea:	460b      	mov	r3, r1
 80067ec:	70fb      	strb	r3, [r7, #3]
  /* Prevent unused arguments compilation warning */
  UNUSED(pdev);
  UNUSED(epnum);

  return USBD_OK;
 80067ee:	2300      	movs	r3, #0
}
 80067f0:	4618      	mov	r0, r3
 80067f2:	370c      	adds	r7, #12
 80067f4:	46bd      	mov	sp, r7
 80067f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80067fa:	4770      	bx	lr

080067fc <USBD_LL_DevConnected>:
*         Handle device connection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
{
 80067fc:	b480      	push	{r7}
 80067fe:	b083      	sub	sp, #12
 8006800:	af00      	add	r7, sp, #0
 8006802:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 8006804:	2300      	movs	r3, #0
}
 8006806:	4618      	mov	r0, r3
 8006808:	370c      	adds	r7, #12
 800680a:	46bd      	mov	sp, r7
 800680c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006810:	4770      	bx	lr

08006812 <USBD_LL_DevDisconnected>:
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
 8006812:	b580      	push	{r7, lr}
 8006814:	b082      	sub	sp, #8
 8006816:	af00      	add	r7, sp, #0
 8006818:	6078      	str	r0, [r7, #4]
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800681a:	687b      	ldr	r3, [r7, #4]
 800681c:	2201      	movs	r2, #1
 800681e:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c

  if (pdev->pClass != NULL)
 8006822:	687b      	ldr	r3, [r7, #4]
 8006824:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006828:	2b00      	cmp	r3, #0
 800682a:	d009      	beq.n	8006840 <USBD_LL_DevDisconnected+0x2e>
  {
    pdev->pClass->DeInit(pdev, (uint8_t)pdev->dev_config);
 800682c:	687b      	ldr	r3, [r7, #4]
 800682e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006832:	685b      	ldr	r3, [r3, #4]
 8006834:	687a      	ldr	r2, [r7, #4]
 8006836:	6852      	ldr	r2, [r2, #4]
 8006838:	b2d2      	uxtb	r2, r2
 800683a:	4611      	mov	r1, r2
 800683c:	6878      	ldr	r0, [r7, #4]
 800683e:	4798      	blx	r3
  }

  return USBD_OK;
 8006840:	2300      	movs	r3, #0
}
 8006842:	4618      	mov	r0, r3
 8006844:	3708      	adds	r7, #8
 8006846:	46bd      	mov	sp, r7
 8006848:	bd80      	pop	{r7, pc}

0800684a <SWAPBYTE>:

/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
 800684a:	b480      	push	{r7}
 800684c:	b087      	sub	sp, #28
 800684e:	af00      	add	r7, sp, #0
 8006850:	6078      	str	r0, [r7, #4]
  uint16_t _SwapVal, _Byte1, _Byte2;
  uint8_t *_pbuff = addr;
 8006852:	687b      	ldr	r3, [r7, #4]
 8006854:	617b      	str	r3, [r7, #20]

  _Byte1 = *(uint8_t *)_pbuff;
 8006856:	697b      	ldr	r3, [r7, #20]
 8006858:	781b      	ldrb	r3, [r3, #0]
 800685a:	827b      	strh	r3, [r7, #18]
  _pbuff++;
 800685c:	697b      	ldr	r3, [r7, #20]
 800685e:	3301      	adds	r3, #1
 8006860:	617b      	str	r3, [r7, #20]
  _Byte2 = *(uint8_t *)_pbuff;
 8006862:	697b      	ldr	r3, [r7, #20]
 8006864:	781b      	ldrb	r3, [r3, #0]
 8006866:	823b      	strh	r3, [r7, #16]

  _SwapVal = (_Byte2 << 8) | _Byte1;
 8006868:	8a3b      	ldrh	r3, [r7, #16]
 800686a:	021b      	lsls	r3, r3, #8
 800686c:	b21a      	sxth	r2, r3
 800686e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8006872:	4313      	orrs	r3, r2
 8006874:	b21b      	sxth	r3, r3
 8006876:	81fb      	strh	r3, [r7, #14]

  return _SwapVal;
 8006878:	89fb      	ldrh	r3, [r7, #14]
}
 800687a:	4618      	mov	r0, r3
 800687c:	371c      	adds	r7, #28
 800687e:	46bd      	mov	sp, r7
 8006880:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006884:	4770      	bx	lr
	...

08006888 <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8006888:	b580      	push	{r7, lr}
 800688a:	b084      	sub	sp, #16
 800688c:	af00      	add	r7, sp, #0
 800688e:	6078      	str	r0, [r7, #4]
 8006890:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8006892:	2300      	movs	r3, #0
 8006894:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006896:	683b      	ldr	r3, [r7, #0]
 8006898:	781b      	ldrb	r3, [r3, #0]
 800689a:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800689e:	2b40      	cmp	r3, #64	; 0x40
 80068a0:	d005      	beq.n	80068ae <USBD_StdDevReq+0x26>
 80068a2:	2b40      	cmp	r3, #64	; 0x40
 80068a4:	d853      	bhi.n	800694e <USBD_StdDevReq+0xc6>
 80068a6:	2b00      	cmp	r3, #0
 80068a8:	d00b      	beq.n	80068c2 <USBD_StdDevReq+0x3a>
 80068aa:	2b20      	cmp	r3, #32
 80068ac:	d14f      	bne.n	800694e <USBD_StdDevReq+0xc6>
  {
  case USB_REQ_TYPE_CLASS:
  case USB_REQ_TYPE_VENDOR:
    ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 80068ae:	687b      	ldr	r3, [r7, #4]
 80068b0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80068b4:	689b      	ldr	r3, [r3, #8]
 80068b6:	6839      	ldr	r1, [r7, #0]
 80068b8:	6878      	ldr	r0, [r7, #4]
 80068ba:	4798      	blx	r3
 80068bc:	4603      	mov	r3, r0
 80068be:	73fb      	strb	r3, [r7, #15]
    break;
 80068c0:	e04a      	b.n	8006958 <USBD_StdDevReq+0xd0>

  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 80068c2:	683b      	ldr	r3, [r7, #0]
 80068c4:	785b      	ldrb	r3, [r3, #1]
 80068c6:	2b09      	cmp	r3, #9
 80068c8:	d83b      	bhi.n	8006942 <USBD_StdDevReq+0xba>
 80068ca:	a201      	add	r2, pc, #4	; (adr r2, 80068d0 <USBD_StdDevReq+0x48>)
 80068cc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80068d0:	08006925 	.word	0x08006925
 80068d4:	08006939 	.word	0x08006939
 80068d8:	08006943 	.word	0x08006943
 80068dc:	0800692f 	.word	0x0800692f
 80068e0:	08006943 	.word	0x08006943
 80068e4:	08006903 	.word	0x08006903
 80068e8:	080068f9 	.word	0x080068f9
 80068ec:	08006943 	.word	0x08006943
 80068f0:	0800691b 	.word	0x0800691b
 80068f4:	0800690d 	.word	0x0800690d
    {
    case USB_REQ_GET_DESCRIPTOR:
      USBD_GetDescriptor(pdev, req);
 80068f8:	6839      	ldr	r1, [r7, #0]
 80068fa:	6878      	ldr	r0, [r7, #4]
 80068fc:	f000 f9d8 	bl	8006cb0 <USBD_GetDescriptor>
      break;
 8006900:	e024      	b.n	800694c <USBD_StdDevReq+0xc4>

    case USB_REQ_SET_ADDRESS:
      USBD_SetAddress(pdev, req);
 8006902:	6839      	ldr	r1, [r7, #0]
 8006904:	6878      	ldr	r0, [r7, #4]
 8006906:	f000 fb3d 	bl	8006f84 <USBD_SetAddress>
      break;
 800690a:	e01f      	b.n	800694c <USBD_StdDevReq+0xc4>

    case USB_REQ_SET_CONFIGURATION:
      ret = USBD_SetConfig(pdev, req);
 800690c:	6839      	ldr	r1, [r7, #0]
 800690e:	6878      	ldr	r0, [r7, #4]
 8006910:	f000 fb7c 	bl	800700c <USBD_SetConfig>
 8006914:	4603      	mov	r3, r0
 8006916:	73fb      	strb	r3, [r7, #15]
      break;
 8006918:	e018      	b.n	800694c <USBD_StdDevReq+0xc4>

    case USB_REQ_GET_CONFIGURATION:
      USBD_GetConfig(pdev, req);
 800691a:	6839      	ldr	r1, [r7, #0]
 800691c:	6878      	ldr	r0, [r7, #4]
 800691e:	f000 fc19 	bl	8007154 <USBD_GetConfig>
      break;
 8006922:	e013      	b.n	800694c <USBD_StdDevReq+0xc4>

    case USB_REQ_GET_STATUS:
      USBD_GetStatus(pdev, req);
 8006924:	6839      	ldr	r1, [r7, #0]
 8006926:	6878      	ldr	r0, [r7, #4]
 8006928:	f000 fc49 	bl	80071be <USBD_GetStatus>
      break;
 800692c:	e00e      	b.n	800694c <USBD_StdDevReq+0xc4>

    case USB_REQ_SET_FEATURE:
      USBD_SetFeature(pdev, req);
 800692e:	6839      	ldr	r1, [r7, #0]
 8006930:	6878      	ldr	r0, [r7, #4]
 8006932:	f000 fc77 	bl	8007224 <USBD_SetFeature>
      break;
 8006936:	e009      	b.n	800694c <USBD_StdDevReq+0xc4>

    case USB_REQ_CLEAR_FEATURE:
      USBD_ClrFeature(pdev, req);
 8006938:	6839      	ldr	r1, [r7, #0]
 800693a:	6878      	ldr	r0, [r7, #4]
 800693c:	f000 fc86 	bl	800724c <USBD_ClrFeature>
      break;
 8006940:	e004      	b.n	800694c <USBD_StdDevReq+0xc4>

    default:
      USBD_CtlError(pdev, req);
 8006942:	6839      	ldr	r1, [r7, #0]
 8006944:	6878      	ldr	r0, [r7, #4]
 8006946:	f000 fcdc 	bl	8007302 <USBD_CtlError>
      break;
 800694a:	bf00      	nop
    }
    break;
 800694c:	e004      	b.n	8006958 <USBD_StdDevReq+0xd0>

  default:
    USBD_CtlError(pdev, req);
 800694e:	6839      	ldr	r1, [r7, #0]
 8006950:	6878      	ldr	r0, [r7, #4]
 8006952:	f000 fcd6 	bl	8007302 <USBD_CtlError>
    break;
 8006956:	bf00      	nop
  }

  return ret;
 8006958:	7bfb      	ldrb	r3, [r7, #15]
}
 800695a:	4618      	mov	r0, r3
 800695c:	3710      	adds	r7, #16
 800695e:	46bd      	mov	sp, r7
 8006960:	bd80      	pop	{r7, pc}
 8006962:	bf00      	nop

08006964 <USBD_StdItfReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef USBD_StdItfReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8006964:	b580      	push	{r7, lr}
 8006966:	b084      	sub	sp, #16
 8006968:	af00      	add	r7, sp, #0
 800696a:	6078      	str	r0, [r7, #4]
 800696c:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 800696e:	2300      	movs	r3, #0
 8006970:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006972:	683b      	ldr	r3, [r7, #0]
 8006974:	781b      	ldrb	r3, [r3, #0]
 8006976:	f003 0360 	and.w	r3, r3, #96	; 0x60
 800697a:	2b40      	cmp	r3, #64	; 0x40
 800697c:	d005      	beq.n	800698a <USBD_StdItfReq+0x26>
 800697e:	2b40      	cmp	r3, #64	; 0x40
 8006980:	d82e      	bhi.n	80069e0 <USBD_StdItfReq+0x7c>
 8006982:	2b00      	cmp	r3, #0
 8006984:	d001      	beq.n	800698a <USBD_StdItfReq+0x26>
 8006986:	2b20      	cmp	r3, #32
 8006988:	d12a      	bne.n	80069e0 <USBD_StdItfReq+0x7c>
  {
  case USB_REQ_TYPE_CLASS:
  case USB_REQ_TYPE_VENDOR:
  case USB_REQ_TYPE_STANDARD:
    switch (pdev->dev_state)
 800698a:	687b      	ldr	r3, [r7, #4]
 800698c:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8006990:	3b01      	subs	r3, #1
 8006992:	2b02      	cmp	r3, #2
 8006994:	d81d      	bhi.n	80069d2 <USBD_StdItfReq+0x6e>
    {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:

      if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 8006996:	683b      	ldr	r3, [r7, #0]
 8006998:	889b      	ldrh	r3, [r3, #4]
 800699a:	b2db      	uxtb	r3, r3
 800699c:	2b01      	cmp	r3, #1
 800699e:	d813      	bhi.n	80069c8 <USBD_StdItfReq+0x64>
      {
        ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 80069a0:	687b      	ldr	r3, [r7, #4]
 80069a2:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 80069a6:	689b      	ldr	r3, [r3, #8]
 80069a8:	6839      	ldr	r1, [r7, #0]
 80069aa:	6878      	ldr	r0, [r7, #4]
 80069ac:	4798      	blx	r3
 80069ae:	4603      	mov	r3, r0
 80069b0:	73fb      	strb	r3, [r7, #15]

        if ((req->wLength == 0U) && (ret == USBD_OK))
 80069b2:	683b      	ldr	r3, [r7, #0]
 80069b4:	88db      	ldrh	r3, [r3, #6]
 80069b6:	2b00      	cmp	r3, #0
 80069b8:	d110      	bne.n	80069dc <USBD_StdItfReq+0x78>
 80069ba:	7bfb      	ldrb	r3, [r7, #15]
 80069bc:	2b00      	cmp	r3, #0
 80069be:	d10d      	bne.n	80069dc <USBD_StdItfReq+0x78>
        {
          (void)USBD_CtlSendStatus(pdev);
 80069c0:	6878      	ldr	r0, [r7, #4]
 80069c2:	f000 fd69 	bl	8007498 <USBD_CtlSendStatus>
      }
      else
      {
        USBD_CtlError(pdev, req);
      }
      break;
 80069c6:	e009      	b.n	80069dc <USBD_StdItfReq+0x78>
        USBD_CtlError(pdev, req);
 80069c8:	6839      	ldr	r1, [r7, #0]
 80069ca:	6878      	ldr	r0, [r7, #4]
 80069cc:	f000 fc99 	bl	8007302 <USBD_CtlError>
      break;
 80069d0:	e004      	b.n	80069dc <USBD_StdItfReq+0x78>

    default:
      USBD_CtlError(pdev, req);
 80069d2:	6839      	ldr	r1, [r7, #0]
 80069d4:	6878      	ldr	r0, [r7, #4]
 80069d6:	f000 fc94 	bl	8007302 <USBD_CtlError>
      break;
 80069da:	e000      	b.n	80069de <USBD_StdItfReq+0x7a>
      break;
 80069dc:	bf00      	nop
    }
    break;
 80069de:	e004      	b.n	80069ea <USBD_StdItfReq+0x86>

  default:
    USBD_CtlError(pdev, req);
 80069e0:	6839      	ldr	r1, [r7, #0]
 80069e2:	6878      	ldr	r0, [r7, #4]
 80069e4:	f000 fc8d 	bl	8007302 <USBD_CtlError>
    break;
 80069e8:	bf00      	nop
  }

  return ret;
 80069ea:	7bfb      	ldrb	r3, [r7, #15]
}
 80069ec:	4618      	mov	r0, r3
 80069ee:	3710      	adds	r7, #16
 80069f0:	46bd      	mov	sp, r7
 80069f2:	bd80      	pop	{r7, pc}

080069f4 <USBD_StdEPReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef USBD_StdEPReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80069f4:	b580      	push	{r7, lr}
 80069f6:	b084      	sub	sp, #16
 80069f8:	af00      	add	r7, sp, #0
 80069fa:	6078      	str	r0, [r7, #4]
 80069fc:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t ep_addr;
  USBD_StatusTypeDef ret = USBD_OK;
 80069fe:	2300      	movs	r3, #0
 8006a00:	73fb      	strb	r3, [r7, #15]
  ep_addr = LOBYTE(req->wIndex);
 8006a02:	683b      	ldr	r3, [r7, #0]
 8006a04:	889b      	ldrh	r3, [r3, #4]
 8006a06:	73bb      	strb	r3, [r7, #14]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8006a08:	683b      	ldr	r3, [r7, #0]
 8006a0a:	781b      	ldrb	r3, [r3, #0]
 8006a0c:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8006a10:	2b40      	cmp	r3, #64	; 0x40
 8006a12:	d007      	beq.n	8006a24 <USBD_StdEPReq+0x30>
 8006a14:	2b40      	cmp	r3, #64	; 0x40
 8006a16:	f200 8140 	bhi.w	8006c9a <USBD_StdEPReq+0x2a6>
 8006a1a:	2b00      	cmp	r3, #0
 8006a1c:	d00c      	beq.n	8006a38 <USBD_StdEPReq+0x44>
 8006a1e:	2b20      	cmp	r3, #32
 8006a20:	f040 813b 	bne.w	8006c9a <USBD_StdEPReq+0x2a6>
  {
  case USB_REQ_TYPE_CLASS:
  case USB_REQ_TYPE_VENDOR:
    ret = (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 8006a24:	687b      	ldr	r3, [r7, #4]
 8006a26:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006a2a:	689b      	ldr	r3, [r3, #8]
 8006a2c:	6839      	ldr	r1, [r7, #0]
 8006a2e:	6878      	ldr	r0, [r7, #4]
 8006a30:	4798      	blx	r3
 8006a32:	4603      	mov	r3, r0
 8006a34:	73fb      	strb	r3, [r7, #15]
    break;
 8006a36:	e135      	b.n	8006ca4 <USBD_StdEPReq+0x2b0>

  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
 8006a38:	683b      	ldr	r3, [r7, #0]
 8006a3a:	785b      	ldrb	r3, [r3, #1]
 8006a3c:	2b03      	cmp	r3, #3
 8006a3e:	d007      	beq.n	8006a50 <USBD_StdEPReq+0x5c>
 8006a40:	2b03      	cmp	r3, #3
 8006a42:	f300 8124 	bgt.w	8006c8e <USBD_StdEPReq+0x29a>
 8006a46:	2b00      	cmp	r3, #0
 8006a48:	d07b      	beq.n	8006b42 <USBD_StdEPReq+0x14e>
 8006a4a:	2b01      	cmp	r3, #1
 8006a4c:	d03b      	beq.n	8006ac6 <USBD_StdEPReq+0xd2>
 8006a4e:	e11e      	b.n	8006c8e <USBD_StdEPReq+0x29a>
    {
    case USB_REQ_SET_FEATURE:
      switch (pdev->dev_state)
 8006a50:	687b      	ldr	r3, [r7, #4]
 8006a52:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8006a56:	2b02      	cmp	r3, #2
 8006a58:	d002      	beq.n	8006a60 <USBD_StdEPReq+0x6c>
 8006a5a:	2b03      	cmp	r3, #3
 8006a5c:	d016      	beq.n	8006a8c <USBD_StdEPReq+0x98>
 8006a5e:	e02c      	b.n	8006aba <USBD_StdEPReq+0xc6>
      {
      case USBD_STATE_ADDRESSED:
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8006a60:	7bbb      	ldrb	r3, [r7, #14]
 8006a62:	2b00      	cmp	r3, #0
 8006a64:	d00d      	beq.n	8006a82 <USBD_StdEPReq+0x8e>
 8006a66:	7bbb      	ldrb	r3, [r7, #14]
 8006a68:	2b80      	cmp	r3, #128	; 0x80
 8006a6a:	d00a      	beq.n	8006a82 <USBD_StdEPReq+0x8e>
        {
          (void)USBD_LL_StallEP(pdev, ep_addr);
 8006a6c:	7bbb      	ldrb	r3, [r7, #14]
 8006a6e:	4619      	mov	r1, r3
 8006a70:	6878      	ldr	r0, [r7, #4]
 8006a72:	f001 f909 	bl	8007c88 <USBD_LL_StallEP>
          (void)USBD_LL_StallEP(pdev, 0x80U);
 8006a76:	2180      	movs	r1, #128	; 0x80
 8006a78:	6878      	ldr	r0, [r7, #4]
 8006a7a:	f001 f905 	bl	8007c88 <USBD_LL_StallEP>
 8006a7e:	bf00      	nop
        }
        else
        {
          USBD_CtlError(pdev, req);
        }
        break;
 8006a80:	e020      	b.n	8006ac4 <USBD_StdEPReq+0xd0>
          USBD_CtlError(pdev, req);
 8006a82:	6839      	ldr	r1, [r7, #0]
 8006a84:	6878      	ldr	r0, [r7, #4]
 8006a86:	f000 fc3c 	bl	8007302 <USBD_CtlError>
        break;
 8006a8a:	e01b      	b.n	8006ac4 <USBD_StdEPReq+0xd0>

      case USBD_STATE_CONFIGURED:
        if (req->wValue == USB_FEATURE_EP_HALT)
 8006a8c:	683b      	ldr	r3, [r7, #0]
 8006a8e:	885b      	ldrh	r3, [r3, #2]
 8006a90:	2b00      	cmp	r3, #0
 8006a92:	d10e      	bne.n	8006ab2 <USBD_StdEPReq+0xbe>
        {
          if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 8006a94:	7bbb      	ldrb	r3, [r7, #14]
 8006a96:	2b00      	cmp	r3, #0
 8006a98:	d00b      	beq.n	8006ab2 <USBD_StdEPReq+0xbe>
 8006a9a:	7bbb      	ldrb	r3, [r7, #14]
 8006a9c:	2b80      	cmp	r3, #128	; 0x80
 8006a9e:	d008      	beq.n	8006ab2 <USBD_StdEPReq+0xbe>
 8006aa0:	683b      	ldr	r3, [r7, #0]
 8006aa2:	88db      	ldrh	r3, [r3, #6]
 8006aa4:	2b00      	cmp	r3, #0
 8006aa6:	d104      	bne.n	8006ab2 <USBD_StdEPReq+0xbe>
          {
            (void)USBD_LL_StallEP(pdev, ep_addr);
 8006aa8:	7bbb      	ldrb	r3, [r7, #14]
 8006aaa:	4619      	mov	r1, r3
 8006aac:	6878      	ldr	r0, [r7, #4]
 8006aae:	f001 f8eb 	bl	8007c88 <USBD_LL_StallEP>
          }
        }
        (void)USBD_CtlSendStatus(pdev);
 8006ab2:	6878      	ldr	r0, [r7, #4]
 8006ab4:	f000 fcf0 	bl	8007498 <USBD_CtlSendStatus>

        break;
 8006ab8:	e004      	b.n	8006ac4 <USBD_StdEPReq+0xd0>

      default:
        USBD_CtlError(pdev, req);
 8006aba:	6839      	ldr	r1, [r7, #0]
 8006abc:	6878      	ldr	r0, [r7, #4]
 8006abe:	f000 fc20 	bl	8007302 <USBD_CtlError>
        break;
 8006ac2:	bf00      	nop
      }
      break;
 8006ac4:	e0e8      	b.n	8006c98 <USBD_StdEPReq+0x2a4>

    case USB_REQ_CLEAR_FEATURE:

      switch (pdev->dev_state)
 8006ac6:	687b      	ldr	r3, [r7, #4]
 8006ac8:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8006acc:	2b02      	cmp	r3, #2
 8006ace:	d002      	beq.n	8006ad6 <USBD_StdEPReq+0xe2>
 8006ad0:	2b03      	cmp	r3, #3
 8006ad2:	d016      	beq.n	8006b02 <USBD_StdEPReq+0x10e>
 8006ad4:	e02e      	b.n	8006b34 <USBD_StdEPReq+0x140>
      {
      case USBD_STATE_ADDRESSED:
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8006ad6:	7bbb      	ldrb	r3, [r7, #14]
 8006ad8:	2b00      	cmp	r3, #0
 8006ada:	d00d      	beq.n	8006af8 <USBD_StdEPReq+0x104>
 8006adc:	7bbb      	ldrb	r3, [r7, #14]
 8006ade:	2b80      	cmp	r3, #128	; 0x80
 8006ae0:	d00a      	beq.n	8006af8 <USBD_StdEPReq+0x104>
        {
          (void)USBD_LL_StallEP(pdev, ep_addr);
 8006ae2:	7bbb      	ldrb	r3, [r7, #14]
 8006ae4:	4619      	mov	r1, r3
 8006ae6:	6878      	ldr	r0, [r7, #4]
 8006ae8:	f001 f8ce 	bl	8007c88 <USBD_LL_StallEP>
          (void)USBD_LL_StallEP(pdev, 0x80U);
 8006aec:	2180      	movs	r1, #128	; 0x80
 8006aee:	6878      	ldr	r0, [r7, #4]
 8006af0:	f001 f8ca 	bl	8007c88 <USBD_LL_StallEP>
 8006af4:	bf00      	nop
        }
        else
        {
          USBD_CtlError(pdev, req);
        }
        break;
 8006af6:	e023      	b.n	8006b40 <USBD_StdEPReq+0x14c>
          USBD_CtlError(pdev, req);
 8006af8:	6839      	ldr	r1, [r7, #0]
 8006afa:	6878      	ldr	r0, [r7, #4]
 8006afc:	f000 fc01 	bl	8007302 <USBD_CtlError>
        break;
 8006b00:	e01e      	b.n	8006b40 <USBD_StdEPReq+0x14c>

      case USBD_STATE_CONFIGURED:
        if (req->wValue == USB_FEATURE_EP_HALT)
 8006b02:	683b      	ldr	r3, [r7, #0]
 8006b04:	885b      	ldrh	r3, [r3, #2]
 8006b06:	2b00      	cmp	r3, #0
 8006b08:	d119      	bne.n	8006b3e <USBD_StdEPReq+0x14a>
        {
          if ((ep_addr & 0x7FU) != 0x00U)
 8006b0a:	7bbb      	ldrb	r3, [r7, #14]
 8006b0c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8006b10:	2b00      	cmp	r3, #0
 8006b12:	d004      	beq.n	8006b1e <USBD_StdEPReq+0x12a>
          {
            (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 8006b14:	7bbb      	ldrb	r3, [r7, #14]
 8006b16:	4619      	mov	r1, r3
 8006b18:	6878      	ldr	r0, [r7, #4]
 8006b1a:	f001 f8d4 	bl	8007cc6 <USBD_LL_ClearStallEP>
          }
          (void)USBD_CtlSendStatus(pdev);
 8006b1e:	6878      	ldr	r0, [r7, #4]
 8006b20:	f000 fcba 	bl	8007498 <USBD_CtlSendStatus>
          (USBD_StatusTypeDef)pdev->pClass->Setup(pdev, req);
 8006b24:	687b      	ldr	r3, [r7, #4]
 8006b26:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006b2a:	689b      	ldr	r3, [r3, #8]
 8006b2c:	6839      	ldr	r1, [r7, #0]
 8006b2e:	6878      	ldr	r0, [r7, #4]
 8006b30:	4798      	blx	r3
        }
        break;
 8006b32:	e004      	b.n	8006b3e <USBD_StdEPReq+0x14a>

      default:
        USBD_CtlError(pdev, req);
 8006b34:	6839      	ldr	r1, [r7, #0]
 8006b36:	6878      	ldr	r0, [r7, #4]
 8006b38:	f000 fbe3 	bl	8007302 <USBD_CtlError>
        break;
 8006b3c:	e000      	b.n	8006b40 <USBD_StdEPReq+0x14c>
        break;
 8006b3e:	bf00      	nop
      }
      break;
 8006b40:	e0aa      	b.n	8006c98 <USBD_StdEPReq+0x2a4>

    case USB_REQ_GET_STATUS:
      switch (pdev->dev_state)
 8006b42:	687b      	ldr	r3, [r7, #4]
 8006b44:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8006b48:	2b02      	cmp	r3, #2
 8006b4a:	d002      	beq.n	8006b52 <USBD_StdEPReq+0x15e>
 8006b4c:	2b03      	cmp	r3, #3
 8006b4e:	d032      	beq.n	8006bb6 <USBD_StdEPReq+0x1c2>
 8006b50:	e097      	b.n	8006c82 <USBD_StdEPReq+0x28e>
      {
      case USBD_STATE_ADDRESSED:
        if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 8006b52:	7bbb      	ldrb	r3, [r7, #14]
 8006b54:	2b00      	cmp	r3, #0
 8006b56:	d007      	beq.n	8006b68 <USBD_StdEPReq+0x174>
 8006b58:	7bbb      	ldrb	r3, [r7, #14]
 8006b5a:	2b80      	cmp	r3, #128	; 0x80
 8006b5c:	d004      	beq.n	8006b68 <USBD_StdEPReq+0x174>
        {
          USBD_CtlError(pdev, req);
 8006b5e:	6839      	ldr	r1, [r7, #0]
 8006b60:	6878      	ldr	r0, [r7, #4]
 8006b62:	f000 fbce 	bl	8007302 <USBD_CtlError>
          break;
 8006b66:	e091      	b.n	8006c8c <USBD_StdEPReq+0x298>
        }
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8006b68:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8006b6c:	2b00      	cmp	r3, #0
 8006b6e:	da0b      	bge.n	8006b88 <USBD_StdEPReq+0x194>
 8006b70:	7bbb      	ldrb	r3, [r7, #14]
 8006b72:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8006b76:	4613      	mov	r3, r2
 8006b78:	009b      	lsls	r3, r3, #2
 8006b7a:	4413      	add	r3, r2
 8006b7c:	009b      	lsls	r3, r3, #2
 8006b7e:	3310      	adds	r3, #16
 8006b80:	687a      	ldr	r2, [r7, #4]
 8006b82:	4413      	add	r3, r2
 8006b84:	3304      	adds	r3, #4
 8006b86:	e00b      	b.n	8006ba0 <USBD_StdEPReq+0x1ac>
              &pdev->ep_out[ep_addr & 0x7FU];
 8006b88:	7bbb      	ldrb	r3, [r7, #14]
 8006b8a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8006b8e:	4613      	mov	r3, r2
 8006b90:	009b      	lsls	r3, r3, #2
 8006b92:	4413      	add	r3, r2
 8006b94:	009b      	lsls	r3, r3, #2
 8006b96:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 8006b9a:	687a      	ldr	r2, [r7, #4]
 8006b9c:	4413      	add	r3, r2
 8006b9e:	3304      	adds	r3, #4
 8006ba0:	60bb      	str	r3, [r7, #8]

        pep->status = 0x0000U;
 8006ba2:	68bb      	ldr	r3, [r7, #8]
 8006ba4:	2200      	movs	r2, #0
 8006ba6:	601a      	str	r2, [r3, #0]

        (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8006ba8:	68bb      	ldr	r3, [r7, #8]
 8006baa:	2202      	movs	r2, #2
 8006bac:	4619      	mov	r1, r3
 8006bae:	6878      	ldr	r0, [r7, #4]
 8006bb0:	f000 fc18 	bl	80073e4 <USBD_CtlSendData>
        break;
 8006bb4:	e06a      	b.n	8006c8c <USBD_StdEPReq+0x298>

      case USBD_STATE_CONFIGURED:
        if ((ep_addr & 0x80U) == 0x80U)
 8006bb6:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8006bba:	2b00      	cmp	r3, #0
 8006bbc:	da11      	bge.n	8006be2 <USBD_StdEPReq+0x1ee>
        {
          if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 8006bbe:	7bbb      	ldrb	r3, [r7, #14]
 8006bc0:	f003 020f 	and.w	r2, r3, #15
 8006bc4:	6879      	ldr	r1, [r7, #4]
 8006bc6:	4613      	mov	r3, r2
 8006bc8:	009b      	lsls	r3, r3, #2
 8006bca:	4413      	add	r3, r2
 8006bcc:	009b      	lsls	r3, r3, #2
 8006bce:	440b      	add	r3, r1
 8006bd0:	3324      	adds	r3, #36	; 0x24
 8006bd2:	881b      	ldrh	r3, [r3, #0]
 8006bd4:	2b00      	cmp	r3, #0
 8006bd6:	d117      	bne.n	8006c08 <USBD_StdEPReq+0x214>
          {
            USBD_CtlError(pdev, req);
 8006bd8:	6839      	ldr	r1, [r7, #0]
 8006bda:	6878      	ldr	r0, [r7, #4]
 8006bdc:	f000 fb91 	bl	8007302 <USBD_CtlError>
            break;
 8006be0:	e054      	b.n	8006c8c <USBD_StdEPReq+0x298>
          }
        }
        else
        {
          if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 8006be2:	7bbb      	ldrb	r3, [r7, #14]
 8006be4:	f003 020f 	and.w	r2, r3, #15
 8006be8:	6879      	ldr	r1, [r7, #4]
 8006bea:	4613      	mov	r3, r2
 8006bec:	009b      	lsls	r3, r3, #2
 8006bee:	4413      	add	r3, r2
 8006bf0:	009b      	lsls	r3, r3, #2
 8006bf2:	440b      	add	r3, r1
 8006bf4:	f503 73b2 	add.w	r3, r3, #356	; 0x164
 8006bf8:	881b      	ldrh	r3, [r3, #0]
 8006bfa:	2b00      	cmp	r3, #0
 8006bfc:	d104      	bne.n	8006c08 <USBD_StdEPReq+0x214>
          {
            USBD_CtlError(pdev, req);
 8006bfe:	6839      	ldr	r1, [r7, #0]
 8006c00:	6878      	ldr	r0, [r7, #4]
 8006c02:	f000 fb7e 	bl	8007302 <USBD_CtlError>
            break;
 8006c06:	e041      	b.n	8006c8c <USBD_StdEPReq+0x298>
          }
        }

        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8006c08:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8006c0c:	2b00      	cmp	r3, #0
 8006c0e:	da0b      	bge.n	8006c28 <USBD_StdEPReq+0x234>
 8006c10:	7bbb      	ldrb	r3, [r7, #14]
 8006c12:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8006c16:	4613      	mov	r3, r2
 8006c18:	009b      	lsls	r3, r3, #2
 8006c1a:	4413      	add	r3, r2
 8006c1c:	009b      	lsls	r3, r3, #2
 8006c1e:	3310      	adds	r3, #16
 8006c20:	687a      	ldr	r2, [r7, #4]
 8006c22:	4413      	add	r3, r2
 8006c24:	3304      	adds	r3, #4
 8006c26:	e00b      	b.n	8006c40 <USBD_StdEPReq+0x24c>
              &pdev->ep_out[ep_addr & 0x7FU];
 8006c28:	7bbb      	ldrb	r3, [r7, #14]
 8006c2a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
        pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 8006c2e:	4613      	mov	r3, r2
 8006c30:	009b      	lsls	r3, r3, #2
 8006c32:	4413      	add	r3, r2
 8006c34:	009b      	lsls	r3, r3, #2
 8006c36:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 8006c3a:	687a      	ldr	r2, [r7, #4]
 8006c3c:	4413      	add	r3, r2
 8006c3e:	3304      	adds	r3, #4
 8006c40:	60bb      	str	r3, [r7, #8]

          if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 8006c42:	7bbb      	ldrb	r3, [r7, #14]
 8006c44:	2b00      	cmp	r3, #0
 8006c46:	d002      	beq.n	8006c4e <USBD_StdEPReq+0x25a>
 8006c48:	7bbb      	ldrb	r3, [r7, #14]
 8006c4a:	2b80      	cmp	r3, #128	; 0x80
 8006c4c:	d103      	bne.n	8006c56 <USBD_StdEPReq+0x262>
          {
            pep->status = 0x0000U;
 8006c4e:	68bb      	ldr	r3, [r7, #8]
 8006c50:	2200      	movs	r2, #0
 8006c52:	601a      	str	r2, [r3, #0]
 8006c54:	e00e      	b.n	8006c74 <USBD_StdEPReq+0x280>
          }
          else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 8006c56:	7bbb      	ldrb	r3, [r7, #14]
 8006c58:	4619      	mov	r1, r3
 8006c5a:	6878      	ldr	r0, [r7, #4]
 8006c5c:	f001 f852 	bl	8007d04 <USBD_LL_IsStallEP>
 8006c60:	4603      	mov	r3, r0
 8006c62:	2b00      	cmp	r3, #0
 8006c64:	d003      	beq.n	8006c6e <USBD_StdEPReq+0x27a>
          {
            pep->status = 0x0001U;
 8006c66:	68bb      	ldr	r3, [r7, #8]
 8006c68:	2201      	movs	r2, #1
 8006c6a:	601a      	str	r2, [r3, #0]
 8006c6c:	e002      	b.n	8006c74 <USBD_StdEPReq+0x280>
          }
          else
          {
            pep->status = 0x0000U;
 8006c6e:	68bb      	ldr	r3, [r7, #8]
 8006c70:	2200      	movs	r2, #0
 8006c72:	601a      	str	r2, [r3, #0]
          }

          (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 8006c74:	68bb      	ldr	r3, [r7, #8]
 8006c76:	2202      	movs	r2, #2
 8006c78:	4619      	mov	r1, r3
 8006c7a:	6878      	ldr	r0, [r7, #4]
 8006c7c:	f000 fbb2 	bl	80073e4 <USBD_CtlSendData>
          break;
 8006c80:	e004      	b.n	8006c8c <USBD_StdEPReq+0x298>

      default:
        USBD_CtlError(pdev, req);
 8006c82:	6839      	ldr	r1, [r7, #0]
 8006c84:	6878      	ldr	r0, [r7, #4]
 8006c86:	f000 fb3c 	bl	8007302 <USBD_CtlError>
        break;
 8006c8a:	bf00      	nop
      }
      break;
 8006c8c:	e004      	b.n	8006c98 <USBD_StdEPReq+0x2a4>

    default:
      USBD_CtlError(pdev, req);
 8006c8e:	6839      	ldr	r1, [r7, #0]
 8006c90:	6878      	ldr	r0, [r7, #4]
 8006c92:	f000 fb36 	bl	8007302 <USBD_CtlError>
      break;
 8006c96:	bf00      	nop
    }
    break;
 8006c98:	e004      	b.n	8006ca4 <USBD_StdEPReq+0x2b0>

  default:
    USBD_CtlError(pdev, req);
 8006c9a:	6839      	ldr	r1, [r7, #0]
 8006c9c:	6878      	ldr	r0, [r7, #4]
 8006c9e:	f000 fb30 	bl	8007302 <USBD_CtlError>
    break;
 8006ca2:	bf00      	nop
  }

  return ret;
 8006ca4:	7bfb      	ldrb	r3, [r7, #15]
}
 8006ca6:	4618      	mov	r0, r3
 8006ca8:	3710      	adds	r7, #16
 8006caa:	46bd      	mov	sp, r7
 8006cac:	bd80      	pop	{r7, pc}
	...

08006cb0 <USBD_GetDescriptor>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8006cb0:	b580      	push	{r7, lr}
 8006cb2:	b084      	sub	sp, #16
 8006cb4:	af00      	add	r7, sp, #0
 8006cb6:	6078      	str	r0, [r7, #4]
 8006cb8:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8006cba:	2300      	movs	r3, #0
 8006cbc:	813b      	strh	r3, [r7, #8]
  uint8_t *pbuf = NULL;
 8006cbe:	2300      	movs	r3, #0
 8006cc0:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
 8006cc2:	2300      	movs	r3, #0
 8006cc4:	72fb      	strb	r3, [r7, #11]

  switch (req->wValue >> 8)
 8006cc6:	683b      	ldr	r3, [r7, #0]
 8006cc8:	885b      	ldrh	r3, [r3, #2]
 8006cca:	0a1b      	lsrs	r3, r3, #8
 8006ccc:	b29b      	uxth	r3, r3
 8006cce:	3b01      	subs	r3, #1
 8006cd0:	2b06      	cmp	r3, #6
 8006cd2:	f200 8128 	bhi.w	8006f26 <USBD_GetDescriptor+0x276>
 8006cd6:	a201      	add	r2, pc, #4	; (adr r2, 8006cdc <USBD_GetDescriptor+0x2c>)
 8006cd8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006cdc:	08006cf9 	.word	0x08006cf9
 8006ce0:	08006d11 	.word	0x08006d11
 8006ce4:	08006d51 	.word	0x08006d51
 8006ce8:	08006f27 	.word	0x08006f27
 8006cec:	08006f27 	.word	0x08006f27
 8006cf0:	08006ec7 	.word	0x08006ec7
 8006cf4:	08006ef3 	.word	0x08006ef3
      err++;
    }
    break;
#endif
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 8006cf8:	687b      	ldr	r3, [r7, #4]
 8006cfa:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006cfe:	681b      	ldr	r3, [r3, #0]
 8006d00:	687a      	ldr	r2, [r7, #4]
 8006d02:	7c12      	ldrb	r2, [r2, #16]
 8006d04:	f107 0108 	add.w	r1, r7, #8
 8006d08:	4610      	mov	r0, r2
 8006d0a:	4798      	blx	r3
 8006d0c:	60f8      	str	r0, [r7, #12]
    break;
 8006d0e:	e112      	b.n	8006f36 <USBD_GetDescriptor+0x286>

  case USB_DESC_TYPE_CONFIGURATION:
    if (pdev->dev_speed == USBD_SPEED_HIGH)
 8006d10:	687b      	ldr	r3, [r7, #4]
 8006d12:	7c1b      	ldrb	r3, [r3, #16]
 8006d14:	2b00      	cmp	r3, #0
 8006d16:	d10d      	bne.n	8006d34 <USBD_GetDescriptor+0x84>
    {
      pbuf = pdev->pClass->GetHSConfigDescriptor(&len);
 8006d18:	687b      	ldr	r3, [r7, #4]
 8006d1a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006d1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006d20:	f107 0208 	add.w	r2, r7, #8
 8006d24:	4610      	mov	r0, r2
 8006d26:	4798      	blx	r3
 8006d28:	60f8      	str	r0, [r7, #12]
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8006d2a:	68fb      	ldr	r3, [r7, #12]
 8006d2c:	3301      	adds	r3, #1
 8006d2e:	2202      	movs	r2, #2
 8006d30:	701a      	strb	r2, [r3, #0]
    else
    {
      pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    break;
 8006d32:	e100      	b.n	8006f36 <USBD_GetDescriptor+0x286>
      pbuf = pdev->pClass->GetFSConfigDescriptor(&len);
 8006d34:	687b      	ldr	r3, [r7, #4]
 8006d36:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006d3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006d3c:	f107 0208 	add.w	r2, r7, #8
 8006d40:	4610      	mov	r0, r2
 8006d42:	4798      	blx	r3
 8006d44:	60f8      	str	r0, [r7, #12]
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8006d46:	68fb      	ldr	r3, [r7, #12]
 8006d48:	3301      	adds	r3, #1
 8006d4a:	2202      	movs	r2, #2
 8006d4c:	701a      	strb	r2, [r3, #0]
    break;
 8006d4e:	e0f2      	b.n	8006f36 <USBD_GetDescriptor+0x286>

  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
 8006d50:	683b      	ldr	r3, [r7, #0]
 8006d52:	885b      	ldrh	r3, [r3, #2]
 8006d54:	b2db      	uxtb	r3, r3
 8006d56:	2b05      	cmp	r3, #5
 8006d58:	f200 80ac 	bhi.w	8006eb4 <USBD_GetDescriptor+0x204>
 8006d5c:	a201      	add	r2, pc, #4	; (adr r2, 8006d64 <USBD_GetDescriptor+0xb4>)
 8006d5e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006d62:	bf00      	nop
 8006d64:	08006d7d 	.word	0x08006d7d
 8006d68:	08006db1 	.word	0x08006db1
 8006d6c:	08006de5 	.word	0x08006de5
 8006d70:	08006e19 	.word	0x08006e19
 8006d74:	08006e4d 	.word	0x08006e4d
 8006d78:	08006e81 	.word	0x08006e81
    {
    case USBD_IDX_LANGID_STR:
      if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 8006d7c:	687b      	ldr	r3, [r7, #4]
 8006d7e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006d82:	685b      	ldr	r3, [r3, #4]
 8006d84:	2b00      	cmp	r3, #0
 8006d86:	d00b      	beq.n	8006da0 <USBD_GetDescriptor+0xf0>
      {
        pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 8006d88:	687b      	ldr	r3, [r7, #4]
 8006d8a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006d8e:	685b      	ldr	r3, [r3, #4]
 8006d90:	687a      	ldr	r2, [r7, #4]
 8006d92:	7c12      	ldrb	r2, [r2, #16]
 8006d94:	f107 0108 	add.w	r1, r7, #8
 8006d98:	4610      	mov	r0, r2
 8006d9a:	4798      	blx	r3
 8006d9c:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8006d9e:	e091      	b.n	8006ec4 <USBD_GetDescriptor+0x214>
        USBD_CtlError(pdev, req);
 8006da0:	6839      	ldr	r1, [r7, #0]
 8006da2:	6878      	ldr	r0, [r7, #4]
 8006da4:	f000 faad 	bl	8007302 <USBD_CtlError>
        err++;
 8006da8:	7afb      	ldrb	r3, [r7, #11]
 8006daa:	3301      	adds	r3, #1
 8006dac:	72fb      	strb	r3, [r7, #11]
      break;
 8006dae:	e089      	b.n	8006ec4 <USBD_GetDescriptor+0x214>

    case USBD_IDX_MFC_STR:
      if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 8006db0:	687b      	ldr	r3, [r7, #4]
 8006db2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006db6:	689b      	ldr	r3, [r3, #8]
 8006db8:	2b00      	cmp	r3, #0
 8006dba:	d00b      	beq.n	8006dd4 <USBD_GetDescriptor+0x124>
      {
        pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8006dbc:	687b      	ldr	r3, [r7, #4]
 8006dbe:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006dc2:	689b      	ldr	r3, [r3, #8]
 8006dc4:	687a      	ldr	r2, [r7, #4]
 8006dc6:	7c12      	ldrb	r2, [r2, #16]
 8006dc8:	f107 0108 	add.w	r1, r7, #8
 8006dcc:	4610      	mov	r0, r2
 8006dce:	4798      	blx	r3
 8006dd0:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8006dd2:	e077      	b.n	8006ec4 <USBD_GetDescriptor+0x214>
        USBD_CtlError(pdev, req);
 8006dd4:	6839      	ldr	r1, [r7, #0]
 8006dd6:	6878      	ldr	r0, [r7, #4]
 8006dd8:	f000 fa93 	bl	8007302 <USBD_CtlError>
        err++;
 8006ddc:	7afb      	ldrb	r3, [r7, #11]
 8006dde:	3301      	adds	r3, #1
 8006de0:	72fb      	strb	r3, [r7, #11]
      break;
 8006de2:	e06f      	b.n	8006ec4 <USBD_GetDescriptor+0x214>

    case USBD_IDX_PRODUCT_STR:
      if (pdev->pDesc->GetProductStrDescriptor != NULL)
 8006de4:	687b      	ldr	r3, [r7, #4]
 8006de6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006dea:	68db      	ldr	r3, [r3, #12]
 8006dec:	2b00      	cmp	r3, #0
 8006dee:	d00b      	beq.n	8006e08 <USBD_GetDescriptor+0x158>
      {
        pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8006df0:	687b      	ldr	r3, [r7, #4]
 8006df2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006df6:	68db      	ldr	r3, [r3, #12]
 8006df8:	687a      	ldr	r2, [r7, #4]
 8006dfa:	7c12      	ldrb	r2, [r2, #16]
 8006dfc:	f107 0108 	add.w	r1, r7, #8
 8006e00:	4610      	mov	r0, r2
 8006e02:	4798      	blx	r3
 8006e04:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8006e06:	e05d      	b.n	8006ec4 <USBD_GetDescriptor+0x214>
        USBD_CtlError(pdev, req);
 8006e08:	6839      	ldr	r1, [r7, #0]
 8006e0a:	6878      	ldr	r0, [r7, #4]
 8006e0c:	f000 fa79 	bl	8007302 <USBD_CtlError>
        err++;
 8006e10:	7afb      	ldrb	r3, [r7, #11]
 8006e12:	3301      	adds	r3, #1
 8006e14:	72fb      	strb	r3, [r7, #11]
      break;
 8006e16:	e055      	b.n	8006ec4 <USBD_GetDescriptor+0x214>

    case USBD_IDX_SERIAL_STR:
      if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 8006e18:	687b      	ldr	r3, [r7, #4]
 8006e1a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006e1e:	691b      	ldr	r3, [r3, #16]
 8006e20:	2b00      	cmp	r3, #0
 8006e22:	d00b      	beq.n	8006e3c <USBD_GetDescriptor+0x18c>
      {
        pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8006e24:	687b      	ldr	r3, [r7, #4]
 8006e26:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006e2a:	691b      	ldr	r3, [r3, #16]
 8006e2c:	687a      	ldr	r2, [r7, #4]
 8006e2e:	7c12      	ldrb	r2, [r2, #16]
 8006e30:	f107 0108 	add.w	r1, r7, #8
 8006e34:	4610      	mov	r0, r2
 8006e36:	4798      	blx	r3
 8006e38:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8006e3a:	e043      	b.n	8006ec4 <USBD_GetDescriptor+0x214>
        USBD_CtlError(pdev, req);
 8006e3c:	6839      	ldr	r1, [r7, #0]
 8006e3e:	6878      	ldr	r0, [r7, #4]
 8006e40:	f000 fa5f 	bl	8007302 <USBD_CtlError>
        err++;
 8006e44:	7afb      	ldrb	r3, [r7, #11]
 8006e46:	3301      	adds	r3, #1
 8006e48:	72fb      	strb	r3, [r7, #11]
      break;
 8006e4a:	e03b      	b.n	8006ec4 <USBD_GetDescriptor+0x214>

    case USBD_IDX_CONFIG_STR:
      if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 8006e4c:	687b      	ldr	r3, [r7, #4]
 8006e4e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006e52:	695b      	ldr	r3, [r3, #20]
 8006e54:	2b00      	cmp	r3, #0
 8006e56:	d00b      	beq.n	8006e70 <USBD_GetDescriptor+0x1c0>
      {
        pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8006e58:	687b      	ldr	r3, [r7, #4]
 8006e5a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006e5e:	695b      	ldr	r3, [r3, #20]
 8006e60:	687a      	ldr	r2, [r7, #4]
 8006e62:	7c12      	ldrb	r2, [r2, #16]
 8006e64:	f107 0108 	add.w	r1, r7, #8
 8006e68:	4610      	mov	r0, r2
 8006e6a:	4798      	blx	r3
 8006e6c:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8006e6e:	e029      	b.n	8006ec4 <USBD_GetDescriptor+0x214>
        USBD_CtlError(pdev, req);
 8006e70:	6839      	ldr	r1, [r7, #0]
 8006e72:	6878      	ldr	r0, [r7, #4]
 8006e74:	f000 fa45 	bl	8007302 <USBD_CtlError>
        err++;
 8006e78:	7afb      	ldrb	r3, [r7, #11]
 8006e7a:	3301      	adds	r3, #1
 8006e7c:	72fb      	strb	r3, [r7, #11]
      break;
 8006e7e:	e021      	b.n	8006ec4 <USBD_GetDescriptor+0x214>

    case USBD_IDX_INTERFACE_STR:
      if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 8006e80:	687b      	ldr	r3, [r7, #4]
 8006e82:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006e86:	699b      	ldr	r3, [r3, #24]
 8006e88:	2b00      	cmp	r3, #0
 8006e8a:	d00b      	beq.n	8006ea4 <USBD_GetDescriptor+0x1f4>
      {
        pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8006e8c:	687b      	ldr	r3, [r7, #4]
 8006e8e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
 8006e92:	699b      	ldr	r3, [r3, #24]
 8006e94:	687a      	ldr	r2, [r7, #4]
 8006e96:	7c12      	ldrb	r2, [r2, #16]
 8006e98:	f107 0108 	add.w	r1, r7, #8
 8006e9c:	4610      	mov	r0, r2
 8006e9e:	4798      	blx	r3
 8006ea0:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 8006ea2:	e00f      	b.n	8006ec4 <USBD_GetDescriptor+0x214>
        USBD_CtlError(pdev, req);
 8006ea4:	6839      	ldr	r1, [r7, #0]
 8006ea6:	6878      	ldr	r0, [r7, #4]
 8006ea8:	f000 fa2b 	bl	8007302 <USBD_CtlError>
        err++;
 8006eac:	7afb      	ldrb	r3, [r7, #11]
 8006eae:	3301      	adds	r3, #1
 8006eb0:	72fb      	strb	r3, [r7, #11]
      break;
 8006eb2:	e007      	b.n	8006ec4 <USBD_GetDescriptor+0x214>
      {
        USBD_CtlError(pdev, req);
        err++;
      }
#else
      USBD_CtlError(pdev, req);
 8006eb4:	6839      	ldr	r1, [r7, #0]
 8006eb6:	6878      	ldr	r0, [r7, #4]
 8006eb8:	f000 fa23 	bl	8007302 <USBD_CtlError>
      err++;
 8006ebc:	7afb      	ldrb	r3, [r7, #11]
 8006ebe:	3301      	adds	r3, #1
 8006ec0:	72fb      	strb	r3, [r7, #11]
#endif
      break;
 8006ec2:	bf00      	nop
    }
    break;
 8006ec4:	e037      	b.n	8006f36 <USBD_GetDescriptor+0x286>

  case USB_DESC_TYPE_DEVICE_QUALIFIER:
    if (pdev->dev_speed == USBD_SPEED_HIGH)
 8006ec6:	687b      	ldr	r3, [r7, #4]
 8006ec8:	7c1b      	ldrb	r3, [r3, #16]
 8006eca:	2b00      	cmp	r3, #0
 8006ecc:	d109      	bne.n	8006ee2 <USBD_GetDescriptor+0x232>
    {
      pbuf = pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8006ece:	687b      	ldr	r3, [r7, #4]
 8006ed0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006ed4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8006ed6:	f107 0208 	add.w	r2, r7, #8
 8006eda:	4610      	mov	r0, r2
 8006edc:	4798      	blx	r3
 8006ede:	60f8      	str	r0, [r7, #12]
    else
    {
      USBD_CtlError(pdev, req);
      err++;
    }
    break;
 8006ee0:	e029      	b.n	8006f36 <USBD_GetDescriptor+0x286>
      USBD_CtlError(pdev, req);
 8006ee2:	6839      	ldr	r1, [r7, #0]
 8006ee4:	6878      	ldr	r0, [r7, #4]
 8006ee6:	f000 fa0c 	bl	8007302 <USBD_CtlError>
      err++;
 8006eea:	7afb      	ldrb	r3, [r7, #11]
 8006eec:	3301      	adds	r3, #1
 8006eee:	72fb      	strb	r3, [r7, #11]
    break;
 8006ef0:	e021      	b.n	8006f36 <USBD_GetDescriptor+0x286>

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if (pdev->dev_speed == USBD_SPEED_HIGH)
 8006ef2:	687b      	ldr	r3, [r7, #4]
 8006ef4:	7c1b      	ldrb	r3, [r3, #16]
 8006ef6:	2b00      	cmp	r3, #0
 8006ef8:	d10d      	bne.n	8006f16 <USBD_GetDescriptor+0x266>
    {
      pbuf = pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8006efa:	687b      	ldr	r3, [r7, #4]
 8006efc:	f8d3 32b8 	ldr.w	r3, [r3, #696]	; 0x2b8
 8006f00:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006f02:	f107 0208 	add.w	r2, r7, #8
 8006f06:	4610      	mov	r0, r2
 8006f08:	4798      	blx	r3
 8006f0a:	60f8      	str	r0, [r7, #12]
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8006f0c:	68fb      	ldr	r3, [r7, #12]
 8006f0e:	3301      	adds	r3, #1
 8006f10:	2207      	movs	r2, #7
 8006f12:	701a      	strb	r2, [r3, #0]
    else
    {
      USBD_CtlError(pdev, req);
      err++;
    }
    break;
 8006f14:	e00f      	b.n	8006f36 <USBD_GetDescriptor+0x286>
      USBD_CtlError(pdev, req);
 8006f16:	6839      	ldr	r1, [r7, #0]
 8006f18:	6878      	ldr	r0, [r7, #4]
 8006f1a:	f000 f9f2 	bl	8007302 <USBD_CtlError>
      err++;
 8006f1e:	7afb      	ldrb	r3, [r7, #11]
 8006f20:	3301      	adds	r3, #1
 8006f22:	72fb      	strb	r3, [r7, #11]
    break;
 8006f24:	e007      	b.n	8006f36 <USBD_GetDescriptor+0x286>

  default:
    USBD_CtlError(pdev, req);
 8006f26:	6839      	ldr	r1, [r7, #0]
 8006f28:	6878      	ldr	r0, [r7, #4]
 8006f2a:	f000 f9ea 	bl	8007302 <USBD_CtlError>
    err++;
 8006f2e:	7afb      	ldrb	r3, [r7, #11]
 8006f30:	3301      	adds	r3, #1
 8006f32:	72fb      	strb	r3, [r7, #11]
    break;
 8006f34:	bf00      	nop
  }

  if (err != 0U)
 8006f36:	7afb      	ldrb	r3, [r7, #11]
 8006f38:	2b00      	cmp	r3, #0
 8006f3a:	d11e      	bne.n	8006f7a <USBD_GetDescriptor+0x2ca>
  {
    return;
  }
  else
  {
    if (req->wLength != 0U)
 8006f3c:	683b      	ldr	r3, [r7, #0]
 8006f3e:	88db      	ldrh	r3, [r3, #6]
 8006f40:	2b00      	cmp	r3, #0
 8006f42:	d016      	beq.n	8006f72 <USBD_GetDescriptor+0x2c2>
    {
      if (len != 0U)
 8006f44:	893b      	ldrh	r3, [r7, #8]
 8006f46:	2b00      	cmp	r3, #0
 8006f48:	d00e      	beq.n	8006f68 <USBD_GetDescriptor+0x2b8>
      {
        len = MIN(len, req->wLength);
 8006f4a:	683b      	ldr	r3, [r7, #0]
 8006f4c:	88da      	ldrh	r2, [r3, #6]
 8006f4e:	893b      	ldrh	r3, [r7, #8]
 8006f50:	4293      	cmp	r3, r2
 8006f52:	bf28      	it	cs
 8006f54:	4613      	movcs	r3, r2
 8006f56:	b29b      	uxth	r3, r3
 8006f58:	813b      	strh	r3, [r7, #8]
        (void)USBD_CtlSendData(pdev, pbuf, len);
 8006f5a:	893b      	ldrh	r3, [r7, #8]
 8006f5c:	461a      	mov	r2, r3
 8006f5e:	68f9      	ldr	r1, [r7, #12]
 8006f60:	6878      	ldr	r0, [r7, #4]
 8006f62:	f000 fa3f 	bl	80073e4 <USBD_CtlSendData>
 8006f66:	e009      	b.n	8006f7c <USBD_GetDescriptor+0x2cc>
      }
      else
      {
        USBD_CtlError(pdev, req);
 8006f68:	6839      	ldr	r1, [r7, #0]
 8006f6a:	6878      	ldr	r0, [r7, #4]
 8006f6c:	f000 f9c9 	bl	8007302 <USBD_CtlError>
 8006f70:	e004      	b.n	8006f7c <USBD_GetDescriptor+0x2cc>
      }
    }
    else
    {
      (void)USBD_CtlSendStatus(pdev);
 8006f72:	6878      	ldr	r0, [r7, #4]
 8006f74:	f000 fa90 	bl	8007498 <USBD_CtlSendStatus>
 8006f78:	e000      	b.n	8006f7c <USBD_GetDescriptor+0x2cc>
    return;
 8006f7a:	bf00      	nop
    }
  }
}
 8006f7c:	3710      	adds	r7, #16
 8006f7e:	46bd      	mov	sp, r7
 8006f80:	bd80      	pop	{r7, pc}
 8006f82:	bf00      	nop

08006f84 <USBD_SetAddress>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_SetAddress(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8006f84:	b580      	push	{r7, lr}
 8006f86:	b084      	sub	sp, #16
 8006f88:	af00      	add	r7, sp, #0
 8006f8a:	6078      	str	r0, [r7, #4]
 8006f8c:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 8006f8e:	683b      	ldr	r3, [r7, #0]
 8006f90:	889b      	ldrh	r3, [r3, #4]
 8006f92:	2b00      	cmp	r3, #0
 8006f94:	d130      	bne.n	8006ff8 <USBD_SetAddress+0x74>
 8006f96:	683b      	ldr	r3, [r7, #0]
 8006f98:	88db      	ldrh	r3, [r3, #6]
 8006f9a:	2b00      	cmp	r3, #0
 8006f9c:	d12c      	bne.n	8006ff8 <USBD_SetAddress+0x74>
 8006f9e:	683b      	ldr	r3, [r7, #0]
 8006fa0:	885b      	ldrh	r3, [r3, #2]
 8006fa2:	2b7f      	cmp	r3, #127	; 0x7f
 8006fa4:	d828      	bhi.n	8006ff8 <USBD_SetAddress+0x74>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 8006fa6:	683b      	ldr	r3, [r7, #0]
 8006fa8:	885b      	ldrh	r3, [r3, #2]
 8006faa:	b2db      	uxtb	r3, r3
 8006fac:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8006fb0:	73fb      	strb	r3, [r7, #15]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006fb2:	687b      	ldr	r3, [r7, #4]
 8006fb4:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8006fb8:	2b03      	cmp	r3, #3
 8006fba:	d104      	bne.n	8006fc6 <USBD_SetAddress+0x42>
    {
      USBD_CtlError(pdev, req);
 8006fbc:	6839      	ldr	r1, [r7, #0]
 8006fbe:	6878      	ldr	r0, [r7, #4]
 8006fc0:	f000 f99f 	bl	8007302 <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006fc4:	e01d      	b.n	8007002 <USBD_SetAddress+0x7e>
    }
    else
    {
      pdev->dev_address = dev_addr;
 8006fc6:	687b      	ldr	r3, [r7, #4]
 8006fc8:	7bfa      	ldrb	r2, [r7, #15]
 8006fca:	f883 229e 	strb.w	r2, [r3, #670]	; 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 8006fce:	7bfb      	ldrb	r3, [r7, #15]
 8006fd0:	4619      	mov	r1, r3
 8006fd2:	6878      	ldr	r0, [r7, #4]
 8006fd4:	f000 fec2 	bl	8007d5c <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 8006fd8:	6878      	ldr	r0, [r7, #4]
 8006fda:	f000 fa5d 	bl	8007498 <USBD_CtlSendStatus>

      if (dev_addr != 0U)
 8006fde:	7bfb      	ldrb	r3, [r7, #15]
 8006fe0:	2b00      	cmp	r3, #0
 8006fe2:	d004      	beq.n	8006fee <USBD_SetAddress+0x6a>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8006fe4:	687b      	ldr	r3, [r7, #4]
 8006fe6:	2202      	movs	r2, #2
 8006fe8:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006fec:	e009      	b.n	8007002 <USBD_SetAddress+0x7e>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
 8006fee:	687b      	ldr	r3, [r7, #4]
 8006ff0:	2201      	movs	r2, #1
 8006ff2:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8006ff6:	e004      	b.n	8007002 <USBD_SetAddress+0x7e>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
 8006ff8:	6839      	ldr	r1, [r7, #0]
 8006ffa:	6878      	ldr	r0, [r7, #4]
 8006ffc:	f000 f981 	bl	8007302 <USBD_CtlError>
  }
}
 8007000:	bf00      	nop
 8007002:	bf00      	nop
 8007004:	3710      	adds	r7, #16
 8007006:	46bd      	mov	sp, r7
 8007008:	bd80      	pop	{r7, pc}
	...

0800700c <USBD_SetConfig>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static USBD_StatusTypeDef USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 800700c:	b580      	push	{r7, lr}
 800700e:	b084      	sub	sp, #16
 8007010:	af00      	add	r7, sp, #0
 8007012:	6078      	str	r0, [r7, #4]
 8007014:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 8007016:	2300      	movs	r3, #0
 8007018:	73fb      	strb	r3, [r7, #15]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
 800701a:	683b      	ldr	r3, [r7, #0]
 800701c:	885b      	ldrh	r3, [r3, #2]
 800701e:	b2da      	uxtb	r2, r3
 8007020:	4b4b      	ldr	r3, [pc, #300]	; (8007150 <USBD_SetConfig+0x144>)
 8007022:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 8007024:	4b4a      	ldr	r3, [pc, #296]	; (8007150 <USBD_SetConfig+0x144>)
 8007026:	781b      	ldrb	r3, [r3, #0]
 8007028:	2b01      	cmp	r3, #1
 800702a:	d905      	bls.n	8007038 <USBD_SetConfig+0x2c>
  {
    USBD_CtlError(pdev, req);
 800702c:	6839      	ldr	r1, [r7, #0]
 800702e:	6878      	ldr	r0, [r7, #4]
 8007030:	f000 f967 	bl	8007302 <USBD_CtlError>
    return USBD_FAIL;
 8007034:	2303      	movs	r3, #3
 8007036:	e087      	b.n	8007148 <USBD_SetConfig+0x13c>
  }

  switch (pdev->dev_state)
 8007038:	687b      	ldr	r3, [r7, #4]
 800703a:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 800703e:	2b02      	cmp	r3, #2
 8007040:	d002      	beq.n	8007048 <USBD_SetConfig+0x3c>
 8007042:	2b03      	cmp	r3, #3
 8007044:	d025      	beq.n	8007092 <USBD_SetConfig+0x86>
 8007046:	e071      	b.n	800712c <USBD_SetConfig+0x120>
  {
  case USBD_STATE_ADDRESSED:
    if (cfgidx != 0U)
 8007048:	4b41      	ldr	r3, [pc, #260]	; (8007150 <USBD_SetConfig+0x144>)
 800704a:	781b      	ldrb	r3, [r3, #0]
 800704c:	2b00      	cmp	r3, #0
 800704e:	d01c      	beq.n	800708a <USBD_SetConfig+0x7e>
    {
      pdev->dev_config = cfgidx;
 8007050:	4b3f      	ldr	r3, [pc, #252]	; (8007150 <USBD_SetConfig+0x144>)
 8007052:	781b      	ldrb	r3, [r3, #0]
 8007054:	461a      	mov	r2, r3
 8007056:	687b      	ldr	r3, [r7, #4]
 8007058:	605a      	str	r2, [r3, #4]

      ret = USBD_SetClassConfig(pdev, cfgidx);
 800705a:	4b3d      	ldr	r3, [pc, #244]	; (8007150 <USBD_SetConfig+0x144>)
 800705c:	781b      	ldrb	r3, [r3, #0]
 800705e:	4619      	mov	r1, r3
 8007060:	6878      	ldr	r0, [r7, #4]
 8007062:	f7ff f999 	bl	8006398 <USBD_SetClassConfig>
 8007066:	4603      	mov	r3, r0
 8007068:	73fb      	strb	r3, [r7, #15]

      if (ret != USBD_OK)
 800706a:	7bfb      	ldrb	r3, [r7, #15]
 800706c:	2b00      	cmp	r3, #0
 800706e:	d004      	beq.n	800707a <USBD_SetConfig+0x6e>
      {
        USBD_CtlError(pdev, req);
 8007070:	6839      	ldr	r1, [r7, #0]
 8007072:	6878      	ldr	r0, [r7, #4]
 8007074:	f000 f945 	bl	8007302 <USBD_CtlError>
    }
    else
    {
      (void)USBD_CtlSendStatus(pdev);
    }
    break;
 8007078:	e065      	b.n	8007146 <USBD_SetConfig+0x13a>
        (void)USBD_CtlSendStatus(pdev);
 800707a:	6878      	ldr	r0, [r7, #4]
 800707c:	f000 fa0c 	bl	8007498 <USBD_CtlSendStatus>
        pdev->dev_state = USBD_STATE_CONFIGURED;
 8007080:	687b      	ldr	r3, [r7, #4]
 8007082:	2203      	movs	r2, #3
 8007084:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
    break;
 8007088:	e05d      	b.n	8007146 <USBD_SetConfig+0x13a>
      (void)USBD_CtlSendStatus(pdev);
 800708a:	6878      	ldr	r0, [r7, #4]
 800708c:	f000 fa04 	bl	8007498 <USBD_CtlSendStatus>
    break;
 8007090:	e059      	b.n	8007146 <USBD_SetConfig+0x13a>

  case USBD_STATE_CONFIGURED:
    if (cfgidx == 0U)
 8007092:	4b2f      	ldr	r3, [pc, #188]	; (8007150 <USBD_SetConfig+0x144>)
 8007094:	781b      	ldrb	r3, [r3, #0]
 8007096:	2b00      	cmp	r3, #0
 8007098:	d112      	bne.n	80070c0 <USBD_SetConfig+0xb4>
    {
      pdev->dev_state = USBD_STATE_ADDRESSED;
 800709a:	687b      	ldr	r3, [r7, #4]
 800709c:	2202      	movs	r2, #2
 800709e:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
      pdev->dev_config = cfgidx;
 80070a2:	4b2b      	ldr	r3, [pc, #172]	; (8007150 <USBD_SetConfig+0x144>)
 80070a4:	781b      	ldrb	r3, [r3, #0]
 80070a6:	461a      	mov	r2, r3
 80070a8:	687b      	ldr	r3, [r7, #4]
 80070aa:	605a      	str	r2, [r3, #4]
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 80070ac:	4b28      	ldr	r3, [pc, #160]	; (8007150 <USBD_SetConfig+0x144>)
 80070ae:	781b      	ldrb	r3, [r3, #0]
 80070b0:	4619      	mov	r1, r3
 80070b2:	6878      	ldr	r0, [r7, #4]
 80070b4:	f7ff f98c 	bl	80063d0 <USBD_ClrClassConfig>
      (void)USBD_CtlSendStatus(pdev);
 80070b8:	6878      	ldr	r0, [r7, #4]
 80070ba:	f000 f9ed 	bl	8007498 <USBD_CtlSendStatus>
    }
    else
    {
      (void)USBD_CtlSendStatus(pdev);
    }
    break;
 80070be:	e042      	b.n	8007146 <USBD_SetConfig+0x13a>
    else if (cfgidx != pdev->dev_config)
 80070c0:	4b23      	ldr	r3, [pc, #140]	; (8007150 <USBD_SetConfig+0x144>)
 80070c2:	781b      	ldrb	r3, [r3, #0]
 80070c4:	461a      	mov	r2, r3
 80070c6:	687b      	ldr	r3, [r7, #4]
 80070c8:	685b      	ldr	r3, [r3, #4]
 80070ca:	429a      	cmp	r2, r3
 80070cc:	d02a      	beq.n	8007124 <USBD_SetConfig+0x118>
      (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 80070ce:	687b      	ldr	r3, [r7, #4]
 80070d0:	685b      	ldr	r3, [r3, #4]
 80070d2:	b2db      	uxtb	r3, r3
 80070d4:	4619      	mov	r1, r3
 80070d6:	6878      	ldr	r0, [r7, #4]
 80070d8:	f7ff f97a 	bl	80063d0 <USBD_ClrClassConfig>
      pdev->dev_config = cfgidx;
 80070dc:	4b1c      	ldr	r3, [pc, #112]	; (8007150 <USBD_SetConfig+0x144>)
 80070de:	781b      	ldrb	r3, [r3, #0]
 80070e0:	461a      	mov	r2, r3
 80070e2:	687b      	ldr	r3, [r7, #4]
 80070e4:	605a      	str	r2, [r3, #4]
      ret = USBD_SetClassConfig(pdev, cfgidx);
 80070e6:	4b1a      	ldr	r3, [pc, #104]	; (8007150 <USBD_SetConfig+0x144>)
 80070e8:	781b      	ldrb	r3, [r3, #0]
 80070ea:	4619      	mov	r1, r3
 80070ec:	6878      	ldr	r0, [r7, #4]
 80070ee:	f7ff f953 	bl	8006398 <USBD_SetClassConfig>
 80070f2:	4603      	mov	r3, r0
 80070f4:	73fb      	strb	r3, [r7, #15]
      if (ret != USBD_OK)
 80070f6:	7bfb      	ldrb	r3, [r7, #15]
 80070f8:	2b00      	cmp	r3, #0
 80070fa:	d00f      	beq.n	800711c <USBD_SetConfig+0x110>
        USBD_CtlError(pdev, req);
 80070fc:	6839      	ldr	r1, [r7, #0]
 80070fe:	6878      	ldr	r0, [r7, #4]
 8007100:	f000 f8ff 	bl	8007302 <USBD_CtlError>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 8007104:	687b      	ldr	r3, [r7, #4]
 8007106:	685b      	ldr	r3, [r3, #4]
 8007108:	b2db      	uxtb	r3, r3
 800710a:	4619      	mov	r1, r3
 800710c:	6878      	ldr	r0, [r7, #4]
 800710e:	f7ff f95f 	bl	80063d0 <USBD_ClrClassConfig>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 8007112:	687b      	ldr	r3, [r7, #4]
 8007114:	2202      	movs	r2, #2
 8007116:	f883 229c 	strb.w	r2, [r3, #668]	; 0x29c
    break;
 800711a:	e014      	b.n	8007146 <USBD_SetConfig+0x13a>
        (void)USBD_CtlSendStatus(pdev);
 800711c:	6878      	ldr	r0, [r7, #4]
 800711e:	f000 f9bb 	bl	8007498 <USBD_CtlSendStatus>
    break;
 8007122:	e010      	b.n	8007146 <USBD_SetConfig+0x13a>
      (void)USBD_CtlSendStatus(pdev);
 8007124:	6878      	ldr	r0, [r7, #4]
 8007126:	f000 f9b7 	bl	8007498 <USBD_CtlSendStatus>
    break;
 800712a:	e00c      	b.n	8007146 <USBD_SetConfig+0x13a>

  default:
    USBD_CtlError(pdev, req);
 800712c:	6839      	ldr	r1, [r7, #0]
 800712e:	6878      	ldr	r0, [r7, #4]
 8007130:	f000 f8e7 	bl	8007302 <USBD_CtlError>
    (void)USBD_ClrClassConfig(pdev, cfgidx);
 8007134:	4b06      	ldr	r3, [pc, #24]	; (8007150 <USBD_SetConfig+0x144>)
 8007136:	781b      	ldrb	r3, [r3, #0]
 8007138:	4619      	mov	r1, r3
 800713a:	6878      	ldr	r0, [r7, #4]
 800713c:	f7ff f948 	bl	80063d0 <USBD_ClrClassConfig>
    ret = USBD_FAIL;
 8007140:	2303      	movs	r3, #3
 8007142:	73fb      	strb	r3, [r7, #15]
    break;
 8007144:	bf00      	nop
  }

  return ret;
 8007146:	7bfb      	ldrb	r3, [r7, #15]
}
 8007148:	4618      	mov	r0, r3
 800714a:	3710      	adds	r7, #16
 800714c:	46bd      	mov	sp, r7
 800714e:	bd80      	pop	{r7, pc}
 8007150:	20008108 	.word	0x20008108

08007154 <USBD_GetConfig>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007154:	b580      	push	{r7, lr}
 8007156:	b082      	sub	sp, #8
 8007158:	af00      	add	r7, sp, #0
 800715a:	6078      	str	r0, [r7, #4]
 800715c:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
 800715e:	683b      	ldr	r3, [r7, #0]
 8007160:	88db      	ldrh	r3, [r3, #6]
 8007162:	2b01      	cmp	r3, #1
 8007164:	d004      	beq.n	8007170 <USBD_GetConfig+0x1c>
  {
    USBD_CtlError(pdev, req);
 8007166:	6839      	ldr	r1, [r7, #0]
 8007168:	6878      	ldr	r0, [r7, #4]
 800716a:	f000 f8ca 	bl	8007302 <USBD_CtlError>
    default:
      USBD_CtlError(pdev, req);
      break;
    }
  }
}
 800716e:	e022      	b.n	80071b6 <USBD_GetConfig+0x62>
    switch (pdev->dev_state)
 8007170:	687b      	ldr	r3, [r7, #4]
 8007172:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 8007176:	2b02      	cmp	r3, #2
 8007178:	dc02      	bgt.n	8007180 <USBD_GetConfig+0x2c>
 800717a:	2b00      	cmp	r3, #0
 800717c:	dc03      	bgt.n	8007186 <USBD_GetConfig+0x32>
 800717e:	e015      	b.n	80071ac <USBD_GetConfig+0x58>
 8007180:	2b03      	cmp	r3, #3
 8007182:	d00b      	beq.n	800719c <USBD_GetConfig+0x48>
 8007184:	e012      	b.n	80071ac <USBD_GetConfig+0x58>
      pdev->dev_default_config = 0U;
 8007186:	687b      	ldr	r3, [r7, #4]
 8007188:	2200      	movs	r2, #0
 800718a:	609a      	str	r2, [r3, #8]
      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 800718c:	687b      	ldr	r3, [r7, #4]
 800718e:	3308      	adds	r3, #8
 8007190:	2201      	movs	r2, #1
 8007192:	4619      	mov	r1, r3
 8007194:	6878      	ldr	r0, [r7, #4]
 8007196:	f000 f925 	bl	80073e4 <USBD_CtlSendData>
      break;
 800719a:	e00c      	b.n	80071b6 <USBD_GetConfig+0x62>
      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 800719c:	687b      	ldr	r3, [r7, #4]
 800719e:	3304      	adds	r3, #4
 80071a0:	2201      	movs	r2, #1
 80071a2:	4619      	mov	r1, r3
 80071a4:	6878      	ldr	r0, [r7, #4]
 80071a6:	f000 f91d 	bl	80073e4 <USBD_CtlSendData>
      break;
 80071aa:	e004      	b.n	80071b6 <USBD_GetConfig+0x62>
      USBD_CtlError(pdev, req);
 80071ac:	6839      	ldr	r1, [r7, #0]
 80071ae:	6878      	ldr	r0, [r7, #4]
 80071b0:	f000 f8a7 	bl	8007302 <USBD_CtlError>
      break;
 80071b4:	bf00      	nop
}
 80071b6:	bf00      	nop
 80071b8:	3708      	adds	r7, #8
 80071ba:	46bd      	mov	sp, r7
 80071bc:	bd80      	pop	{r7, pc}

080071be <USBD_GetStatus>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 80071be:	b580      	push	{r7, lr}
 80071c0:	b082      	sub	sp, #8
 80071c2:	af00      	add	r7, sp, #0
 80071c4:	6078      	str	r0, [r7, #4]
 80071c6:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 80071c8:	687b      	ldr	r3, [r7, #4]
 80071ca:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 80071ce:	3b01      	subs	r3, #1
 80071d0:	2b02      	cmp	r3, #2
 80071d2:	d81e      	bhi.n	8007212 <USBD_GetStatus+0x54>
  {
  case USBD_STATE_DEFAULT:
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wLength != 0x2U)
 80071d4:	683b      	ldr	r3, [r7, #0]
 80071d6:	88db      	ldrh	r3, [r3, #6]
 80071d8:	2b02      	cmp	r3, #2
 80071da:	d004      	beq.n	80071e6 <USBD_GetStatus+0x28>
    {
      USBD_CtlError(pdev, req);
 80071dc:	6839      	ldr	r1, [r7, #0]
 80071de:	6878      	ldr	r0, [r7, #4]
 80071e0:	f000 f88f 	bl	8007302 <USBD_CtlError>
      break;
 80071e4:	e01a      	b.n	800721c <USBD_GetStatus+0x5e>
    }

#if (USBD_SELF_POWERED == 1U)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 80071e6:	687b      	ldr	r3, [r7, #4]
 80071e8:	2201      	movs	r2, #1
 80071ea:	60da      	str	r2, [r3, #12]
#else
    pdev->dev_config_status = 0U;
#endif

    if (pdev->dev_remote_wakeup != 0U)
 80071ec:	687b      	ldr	r3, [r7, #4]
 80071ee:	f8d3 32a4 	ldr.w	r3, [r3, #676]	; 0x2a4
 80071f2:	2b00      	cmp	r3, #0
 80071f4:	d005      	beq.n	8007202 <USBD_GetStatus+0x44>
    {
      pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 80071f6:	687b      	ldr	r3, [r7, #4]
 80071f8:	68db      	ldr	r3, [r3, #12]
 80071fa:	f043 0202 	orr.w	r2, r3, #2
 80071fe:	687b      	ldr	r3, [r7, #4]
 8007200:	60da      	str	r2, [r3, #12]
    }

    (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 8007202:	687b      	ldr	r3, [r7, #4]
 8007204:	330c      	adds	r3, #12
 8007206:	2202      	movs	r2, #2
 8007208:	4619      	mov	r1, r3
 800720a:	6878      	ldr	r0, [r7, #4]
 800720c:	f000 f8ea 	bl	80073e4 <USBD_CtlSendData>
    break;
 8007210:	e004      	b.n	800721c <USBD_GetStatus+0x5e>

  default:
    USBD_CtlError(pdev, req);
 8007212:	6839      	ldr	r1, [r7, #0]
 8007214:	6878      	ldr	r0, [r7, #4]
 8007216:	f000 f874 	bl	8007302 <USBD_CtlError>
    break;
 800721a:	bf00      	nop
  }
}
 800721c:	bf00      	nop
 800721e:	3708      	adds	r7, #8
 8007220:	46bd      	mov	sp, r7
 8007222:	bd80      	pop	{r7, pc}

08007224 <USBD_SetFeature>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_SetFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007224:	b580      	push	{r7, lr}
 8007226:	b082      	sub	sp, #8
 8007228:	af00      	add	r7, sp, #0
 800722a:	6078      	str	r0, [r7, #4]
 800722c:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800722e:	683b      	ldr	r3, [r7, #0]
 8007230:	885b      	ldrh	r3, [r3, #2]
 8007232:	2b01      	cmp	r3, #1
 8007234:	d106      	bne.n	8007244 <USBD_SetFeature+0x20>
  {
    pdev->dev_remote_wakeup = 1U;
 8007236:	687b      	ldr	r3, [r7, #4]
 8007238:	2201      	movs	r2, #1
 800723a:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
    (void)USBD_CtlSendStatus(pdev);
 800723e:	6878      	ldr	r0, [r7, #4]
 8007240:	f000 f92a 	bl	8007498 <USBD_CtlSendStatus>
  }
}
 8007244:	bf00      	nop
 8007246:	3708      	adds	r7, #8
 8007248:	46bd      	mov	sp, r7
 800724a:	bd80      	pop	{r7, pc}

0800724c <USBD_ClrFeature>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 800724c:	b580      	push	{r7, lr}
 800724e:	b082      	sub	sp, #8
 8007250:	af00      	add	r7, sp, #0
 8007252:	6078      	str	r0, [r7, #4]
 8007254:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 8007256:	687b      	ldr	r3, [r7, #4]
 8007258:	f893 329c 	ldrb.w	r3, [r3, #668]	; 0x29c
 800725c:	3b01      	subs	r3, #1
 800725e:	2b02      	cmp	r3, #2
 8007260:	d80b      	bhi.n	800727a <USBD_ClrFeature+0x2e>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8007262:	683b      	ldr	r3, [r7, #0]
 8007264:	885b      	ldrh	r3, [r3, #2]
 8007266:	2b01      	cmp	r3, #1
 8007268:	d10c      	bne.n	8007284 <USBD_ClrFeature+0x38>
      {
        pdev->dev_remote_wakeup = 0U;
 800726a:	687b      	ldr	r3, [r7, #4]
 800726c:	2200      	movs	r2, #0
 800726e:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 8007272:	6878      	ldr	r0, [r7, #4]
 8007274:	f000 f910 	bl	8007498 <USBD_CtlSendStatus>
      }
      break;
 8007278:	e004      	b.n	8007284 <USBD_ClrFeature+0x38>

    default:
      USBD_CtlError(pdev, req);
 800727a:	6839      	ldr	r1, [r7, #0]
 800727c:	6878      	ldr	r0, [r7, #4]
 800727e:	f000 f840 	bl	8007302 <USBD_CtlError>
      break;
 8007282:	e000      	b.n	8007286 <USBD_ClrFeature+0x3a>
      break;
 8007284:	bf00      	nop
  }
}
 8007286:	bf00      	nop
 8007288:	3708      	adds	r7, #8
 800728a:	46bd      	mov	sp, r7
 800728c:	bd80      	pop	{r7, pc}

0800728e <USBD_ParseSetupRequest>:
* @param  req: usb request
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 800728e:	b580      	push	{r7, lr}
 8007290:	b084      	sub	sp, #16
 8007292:	af00      	add	r7, sp, #0
 8007294:	6078      	str	r0, [r7, #4]
 8007296:	6039      	str	r1, [r7, #0]
  uint8_t *pbuff = pdata;
 8007298:	683b      	ldr	r3, [r7, #0]
 800729a:	60fb      	str	r3, [r7, #12]

  req->bmRequest = *(uint8_t *)(pbuff);
 800729c:	68fb      	ldr	r3, [r7, #12]
 800729e:	781a      	ldrb	r2, [r3, #0]
 80072a0:	687b      	ldr	r3, [r7, #4]
 80072a2:	701a      	strb	r2, [r3, #0]

  pbuff++;
 80072a4:	68fb      	ldr	r3, [r7, #12]
 80072a6:	3301      	adds	r3, #1
 80072a8:	60fb      	str	r3, [r7, #12]
  req->bRequest = *(uint8_t *)(pbuff);
 80072aa:	68fb      	ldr	r3, [r7, #12]
 80072ac:	781a      	ldrb	r2, [r3, #0]
 80072ae:	687b      	ldr	r3, [r7, #4]
 80072b0:	705a      	strb	r2, [r3, #1]

  pbuff++;
 80072b2:	68fb      	ldr	r3, [r7, #12]
 80072b4:	3301      	adds	r3, #1
 80072b6:	60fb      	str	r3, [r7, #12]
  req->wValue = SWAPBYTE(pbuff);
 80072b8:	68f8      	ldr	r0, [r7, #12]
 80072ba:	f7ff fac6 	bl	800684a <SWAPBYTE>
 80072be:	4603      	mov	r3, r0
 80072c0:	461a      	mov	r2, r3
 80072c2:	687b      	ldr	r3, [r7, #4]
 80072c4:	805a      	strh	r2, [r3, #2]

  pbuff++;
 80072c6:	68fb      	ldr	r3, [r7, #12]
 80072c8:	3301      	adds	r3, #1
 80072ca:	60fb      	str	r3, [r7, #12]
  pbuff++;
 80072cc:	68fb      	ldr	r3, [r7, #12]
 80072ce:	3301      	adds	r3, #1
 80072d0:	60fb      	str	r3, [r7, #12]
  req->wIndex = SWAPBYTE(pbuff);
 80072d2:	68f8      	ldr	r0, [r7, #12]
 80072d4:	f7ff fab9 	bl	800684a <SWAPBYTE>
 80072d8:	4603      	mov	r3, r0
 80072da:	461a      	mov	r2, r3
 80072dc:	687b      	ldr	r3, [r7, #4]
 80072de:	809a      	strh	r2, [r3, #4]

  pbuff++;
 80072e0:	68fb      	ldr	r3, [r7, #12]
 80072e2:	3301      	adds	r3, #1
 80072e4:	60fb      	str	r3, [r7, #12]
  pbuff++;
 80072e6:	68fb      	ldr	r3, [r7, #12]
 80072e8:	3301      	adds	r3, #1
 80072ea:	60fb      	str	r3, [r7, #12]
  req->wLength = SWAPBYTE(pbuff);
 80072ec:	68f8      	ldr	r0, [r7, #12]
 80072ee:	f7ff faac 	bl	800684a <SWAPBYTE>
 80072f2:	4603      	mov	r3, r0
 80072f4:	461a      	mov	r2, r3
 80072f6:	687b      	ldr	r3, [r7, #4]
 80072f8:	80da      	strh	r2, [r3, #6]
}
 80072fa:	bf00      	nop
 80072fc:	3710      	adds	r7, #16
 80072fe:	46bd      	mov	sp, r7
 8007300:	bd80      	pop	{r7, pc}

08007302 <USBD_CtlError>:
* @param  req: usb request
* @retval None
*/

void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 8007302:	b580      	push	{r7, lr}
 8007304:	b082      	sub	sp, #8
 8007306:	af00      	add	r7, sp, #0
 8007308:	6078      	str	r0, [r7, #4]
 800730a:	6039      	str	r1, [r7, #0]
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 800730c:	2180      	movs	r1, #128	; 0x80
 800730e:	6878      	ldr	r0, [r7, #4]
 8007310:	f000 fcba 	bl	8007c88 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 8007314:	2100      	movs	r1, #0
 8007316:	6878      	ldr	r0, [r7, #4]
 8007318:	f000 fcb6 	bl	8007c88 <USBD_LL_StallEP>
}
 800731c:	bf00      	nop
 800731e:	3708      	adds	r7, #8
 8007320:	46bd      	mov	sp, r7
 8007322:	bd80      	pop	{r7, pc}

08007324 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8007324:	b580      	push	{r7, lr}
 8007326:	b086      	sub	sp, #24
 8007328:	af00      	add	r7, sp, #0
 800732a:	60f8      	str	r0, [r7, #12]
 800732c:	60b9      	str	r1, [r7, #8]
 800732e:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 8007330:	2300      	movs	r3, #0
 8007332:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
 8007334:	68fb      	ldr	r3, [r7, #12]
 8007336:	2b00      	cmp	r3, #0
 8007338:	d036      	beq.n	80073a8 <USBD_GetString+0x84>
  {
    return;
  }

  pdesc = desc;
 800733a:	68fb      	ldr	r3, [r7, #12]
 800733c:	613b      	str	r3, [r7, #16]
  *len = ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U;
 800733e:	6938      	ldr	r0, [r7, #16]
 8007340:	f000 f836 	bl	80073b0 <USBD_GetLen>
 8007344:	4603      	mov	r3, r0
 8007346:	3301      	adds	r3, #1
 8007348:	b29b      	uxth	r3, r3
 800734a:	005b      	lsls	r3, r3, #1
 800734c:	b29a      	uxth	r2, r3
 800734e:	687b      	ldr	r3, [r7, #4]
 8007350:	801a      	strh	r2, [r3, #0]

  unicode[idx] = *(uint8_t *)len;
 8007352:	7dfb      	ldrb	r3, [r7, #23]
 8007354:	68ba      	ldr	r2, [r7, #8]
 8007356:	4413      	add	r3, r2
 8007358:	687a      	ldr	r2, [r7, #4]
 800735a:	7812      	ldrb	r2, [r2, #0]
 800735c:	701a      	strb	r2, [r3, #0]
  idx++;
 800735e:	7dfb      	ldrb	r3, [r7, #23]
 8007360:	3301      	adds	r3, #1
 8007362:	75fb      	strb	r3, [r7, #23]
  unicode[idx] = USB_DESC_TYPE_STRING;
 8007364:	7dfb      	ldrb	r3, [r7, #23]
 8007366:	68ba      	ldr	r2, [r7, #8]
 8007368:	4413      	add	r3, r2
 800736a:	2203      	movs	r2, #3
 800736c:	701a      	strb	r2, [r3, #0]
  idx++;
 800736e:	7dfb      	ldrb	r3, [r7, #23]
 8007370:	3301      	adds	r3, #1
 8007372:	75fb      	strb	r3, [r7, #23]

  while (*pdesc != (uint8_t)'\0')
 8007374:	e013      	b.n	800739e <USBD_GetString+0x7a>
  {
    unicode[idx] = *pdesc;
 8007376:	7dfb      	ldrb	r3, [r7, #23]
 8007378:	68ba      	ldr	r2, [r7, #8]
 800737a:	4413      	add	r3, r2
 800737c:	693a      	ldr	r2, [r7, #16]
 800737e:	7812      	ldrb	r2, [r2, #0]
 8007380:	701a      	strb	r2, [r3, #0]
    pdesc++;
 8007382:	693b      	ldr	r3, [r7, #16]
 8007384:	3301      	adds	r3, #1
 8007386:	613b      	str	r3, [r7, #16]
    idx++;
 8007388:	7dfb      	ldrb	r3, [r7, #23]
 800738a:	3301      	adds	r3, #1
 800738c:	75fb      	strb	r3, [r7, #23]

    unicode[idx] = 0U;
 800738e:	7dfb      	ldrb	r3, [r7, #23]
 8007390:	68ba      	ldr	r2, [r7, #8]
 8007392:	4413      	add	r3, r2
 8007394:	2200      	movs	r2, #0
 8007396:	701a      	strb	r2, [r3, #0]
    idx++;
 8007398:	7dfb      	ldrb	r3, [r7, #23]
 800739a:	3301      	adds	r3, #1
 800739c:	75fb      	strb	r3, [r7, #23]
  while (*pdesc != (uint8_t)'\0')
 800739e:	693b      	ldr	r3, [r7, #16]
 80073a0:	781b      	ldrb	r3, [r3, #0]
 80073a2:	2b00      	cmp	r3, #0
 80073a4:	d1e7      	bne.n	8007376 <USBD_GetString+0x52>
 80073a6:	e000      	b.n	80073aa <USBD_GetString+0x86>
    return;
 80073a8:	bf00      	nop
  }
}
 80073aa:	3718      	adds	r7, #24
 80073ac:	46bd      	mov	sp, r7
 80073ae:	bd80      	pop	{r7, pc}

080073b0 <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 80073b0:	b480      	push	{r7}
 80073b2:	b085      	sub	sp, #20
 80073b4:	af00      	add	r7, sp, #0
 80073b6:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 80073b8:	2300      	movs	r3, #0
 80073ba:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
 80073bc:	687b      	ldr	r3, [r7, #4]
 80073be:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
 80073c0:	e005      	b.n	80073ce <USBD_GetLen+0x1e>
  {
    len++;
 80073c2:	7bfb      	ldrb	r3, [r7, #15]
 80073c4:	3301      	adds	r3, #1
 80073c6:	73fb      	strb	r3, [r7, #15]
    pbuff++;
 80073c8:	68bb      	ldr	r3, [r7, #8]
 80073ca:	3301      	adds	r3, #1
 80073cc:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
 80073ce:	68bb      	ldr	r3, [r7, #8]
 80073d0:	781b      	ldrb	r3, [r3, #0]
 80073d2:	2b00      	cmp	r3, #0
 80073d4:	d1f5      	bne.n	80073c2 <USBD_GetLen+0x12>
  }

  return len;
 80073d6:	7bfb      	ldrb	r3, [r7, #15]
}
 80073d8:	4618      	mov	r0, r3
 80073da:	3714      	adds	r7, #20
 80073dc:	46bd      	mov	sp, r7
 80073de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80073e2:	4770      	bx	lr

080073e4 <USBD_CtlSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 80073e4:	b580      	push	{r7, lr}
 80073e6:	b084      	sub	sp, #16
 80073e8:	af00      	add	r7, sp, #0
 80073ea:	60f8      	str	r0, [r7, #12]
 80073ec:	60b9      	str	r1, [r7, #8]
 80073ee:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 80073f0:	68fb      	ldr	r3, [r7, #12]
 80073f2:	2202      	movs	r2, #2
 80073f4:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  pdev->ep_in[0].total_length = len;
 80073f8:	68fb      	ldr	r3, [r7, #12]
 80073fa:	687a      	ldr	r2, [r7, #4]
 80073fc:	619a      	str	r2, [r3, #24]
  pdev->ep_in[0].rem_length = len;
 80073fe:	68fb      	ldr	r3, [r7, #12]
 8007400:	687a      	ldr	r2, [r7, #4]
 8007402:	61da      	str	r2, [r3, #28]

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8007404:	687b      	ldr	r3, [r7, #4]
 8007406:	68ba      	ldr	r2, [r7, #8]
 8007408:	2100      	movs	r1, #0
 800740a:	68f8      	ldr	r0, [r7, #12]
 800740c:	f000 fcc5 	bl	8007d9a <USBD_LL_Transmit>

  return USBD_OK;
 8007410:	2300      	movs	r3, #0
}
 8007412:	4618      	mov	r0, r3
 8007414:	3710      	adds	r7, #16
 8007416:	46bd      	mov	sp, r7
 8007418:	bd80      	pop	{r7, pc}

0800741a <USBD_CtlContinueSendData>:
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 800741a:	b580      	push	{r7, lr}
 800741c:	b084      	sub	sp, #16
 800741e:	af00      	add	r7, sp, #0
 8007420:	60f8      	str	r0, [r7, #12]
 8007422:	60b9      	str	r1, [r7, #8]
 8007424:	607a      	str	r2, [r7, #4]
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 8007426:	687b      	ldr	r3, [r7, #4]
 8007428:	68ba      	ldr	r2, [r7, #8]
 800742a:	2100      	movs	r1, #0
 800742c:	68f8      	ldr	r0, [r7, #12]
 800742e:	f000 fcb4 	bl	8007d9a <USBD_LL_Transmit>

  return USBD_OK;
 8007432:	2300      	movs	r3, #0
}
 8007434:	4618      	mov	r0, r3
 8007436:	3710      	adds	r7, #16
 8007438:	46bd      	mov	sp, r7
 800743a:	bd80      	pop	{r7, pc}

0800743c <USBD_CtlPrepareRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 800743c:	b580      	push	{r7, lr}
 800743e:	b084      	sub	sp, #16
 8007440:	af00      	add	r7, sp, #0
 8007442:	60f8      	str	r0, [r7, #12]
 8007444:	60b9      	str	r1, [r7, #8]
 8007446:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 8007448:	68fb      	ldr	r3, [r7, #12]
 800744a:	2203      	movs	r2, #3
 800744c:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294
  pdev->ep_out[0].total_length = len;
 8007450:	68fb      	ldr	r3, [r7, #12]
 8007452:	687a      	ldr	r2, [r7, #4]
 8007454:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
  pdev->ep_out[0].rem_length = len;
 8007458:	68fb      	ldr	r3, [r7, #12]
 800745a:	687a      	ldr	r2, [r7, #4]
 800745c:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8007460:	687b      	ldr	r3, [r7, #4]
 8007462:	68ba      	ldr	r2, [r7, #8]
 8007464:	2100      	movs	r1, #0
 8007466:	68f8      	ldr	r0, [r7, #12]
 8007468:	f000 fcb8 	bl	8007ddc <USBD_LL_PrepareReceive>

  return USBD_OK;
 800746c:	2300      	movs	r3, #0
}
 800746e:	4618      	mov	r0, r3
 8007470:	3710      	adds	r7, #16
 8007472:	46bd      	mov	sp, r7
 8007474:	bd80      	pop	{r7, pc}

08007476 <USBD_CtlContinueRx>:
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 8007476:	b580      	push	{r7, lr}
 8007478:	b084      	sub	sp, #16
 800747a:	af00      	add	r7, sp, #0
 800747c:	60f8      	str	r0, [r7, #12]
 800747e:	60b9      	str	r1, [r7, #8]
 8007480:	607a      	str	r2, [r7, #4]
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 8007482:	687b      	ldr	r3, [r7, #4]
 8007484:	68ba      	ldr	r2, [r7, #8]
 8007486:	2100      	movs	r1, #0
 8007488:	68f8      	ldr	r0, [r7, #12]
 800748a:	f000 fca7 	bl	8007ddc <USBD_LL_PrepareReceive>

  return USBD_OK;
 800748e:	2300      	movs	r3, #0
}
 8007490:	4618      	mov	r0, r3
 8007492:	3710      	adds	r7, #16
 8007494:	46bd      	mov	sp, r7
 8007496:	bd80      	pop	{r7, pc}

08007498 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 8007498:	b580      	push	{r7, lr}
 800749a:	b082      	sub	sp, #8
 800749c:	af00      	add	r7, sp, #0
 800749e:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 80074a0:	687b      	ldr	r3, [r7, #4]
 80074a2:	2204      	movs	r2, #4
 80074a4:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 80074a8:	2300      	movs	r3, #0
 80074aa:	2200      	movs	r2, #0
 80074ac:	2100      	movs	r1, #0
 80074ae:	6878      	ldr	r0, [r7, #4]
 80074b0:	f000 fc73 	bl	8007d9a <USBD_LL_Transmit>

  return USBD_OK;
 80074b4:	2300      	movs	r3, #0
}
 80074b6:	4618      	mov	r0, r3
 80074b8:	3708      	adds	r7, #8
 80074ba:	46bd      	mov	sp, r7
 80074bc:	bd80      	pop	{r7, pc}

080074be <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 80074be:	b580      	push	{r7, lr}
 80074c0:	b082      	sub	sp, #8
 80074c2:	af00      	add	r7, sp, #0
 80074c4:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 80074c6:	687b      	ldr	r3, [r7, #4]
 80074c8:	2205      	movs	r2, #5
 80074ca:	f8c3 2294 	str.w	r2, [r3, #660]	; 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 80074ce:	2300      	movs	r3, #0
 80074d0:	2200      	movs	r2, #0
 80074d2:	2100      	movs	r1, #0
 80074d4:	6878      	ldr	r0, [r7, #4]
 80074d6:	f000 fc81 	bl	8007ddc <USBD_LL_PrepareReceive>

  return USBD_OK;
 80074da:	2300      	movs	r3, #0
}
 80074dc:	4618      	mov	r0, r3
 80074de:	3708      	adds	r7, #8
 80074e0:	46bd      	mov	sp, r7
 80074e2:	bd80      	pop	{r7, pc}

080074e4 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 80074e4:	b580      	push	{r7, lr}
 80074e6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 80074e8:	2200      	movs	r2, #0
 80074ea:	4912      	ldr	r1, [pc, #72]	; (8007534 <MX_USB_DEVICE_Init+0x50>)
 80074ec:	4812      	ldr	r0, [pc, #72]	; (8007538 <MX_USB_DEVICE_Init+0x54>)
 80074ee:	f7fe fee5 	bl	80062bc <USBD_Init>
 80074f2:	4603      	mov	r3, r0
 80074f4:	2b00      	cmp	r3, #0
 80074f6:	d001      	beq.n	80074fc <MX_USB_DEVICE_Init+0x18>
  {
    Error_Handler();
 80074f8:	f7f9 fc5a 	bl	8000db0 <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 80074fc:	490f      	ldr	r1, [pc, #60]	; (800753c <MX_USB_DEVICE_Init+0x58>)
 80074fe:	480e      	ldr	r0, [pc, #56]	; (8007538 <MX_USB_DEVICE_Init+0x54>)
 8007500:	f7fe ff12 	bl	8006328 <USBD_RegisterClass>
 8007504:	4603      	mov	r3, r0
 8007506:	2b00      	cmp	r3, #0
 8007508:	d001      	beq.n	800750e <MX_USB_DEVICE_Init+0x2a>
  {
    Error_Handler();
 800750a:	f7f9 fc51 	bl	8000db0 <Error_Handler>
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 800750e:	490c      	ldr	r1, [pc, #48]	; (8007540 <MX_USB_DEVICE_Init+0x5c>)
 8007510:	4809      	ldr	r0, [pc, #36]	; (8007538 <MX_USB_DEVICE_Init+0x54>)
 8007512:	f7fe fe67 	bl	80061e4 <USBD_CDC_RegisterInterface>
 8007516:	4603      	mov	r3, r0
 8007518:	2b00      	cmp	r3, #0
 800751a:	d001      	beq.n	8007520 <MX_USB_DEVICE_Init+0x3c>
  {
    Error_Handler();
 800751c:	f7f9 fc48 	bl	8000db0 <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 8007520:	4805      	ldr	r0, [pc, #20]	; (8007538 <MX_USB_DEVICE_Init+0x54>)
 8007522:	f7fe ff22 	bl	800636a <USBD_Start>
 8007526:	4603      	mov	r3, r0
 8007528:	2b00      	cmp	r3, #0
 800752a:	d001      	beq.n	8007530 <MX_USB_DEVICE_Init+0x4c>
  {
    Error_Handler();
 800752c:	f7f9 fc40 	bl	8000db0 <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 8007530:	bf00      	nop
 8007532:	bd80      	pop	{r7, pc}
 8007534:	20000138 	.word	0x20000138
 8007538:	2000810c 	.word	0x2000810c
 800753c:	20000020 	.word	0x20000020
 8007540:	20000124 	.word	0x20000124

08007544 <CDC_Init_FS>:
/**
  * @brief  Initializes the CDC media low layer over the FS USB IP
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{
 8007544:	b580      	push	{r7, lr}
 8007546:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 3 */
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 8007548:	2200      	movs	r2, #0
 800754a:	4905      	ldr	r1, [pc, #20]	; (8007560 <CDC_Init_FS+0x1c>)
 800754c:	4805      	ldr	r0, [pc, #20]	; (8007564 <CDC_Init_FS+0x20>)
 800754e:	f7fe fe5e 	bl	800620e <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 8007552:	4905      	ldr	r1, [pc, #20]	; (8007568 <CDC_Init_FS+0x24>)
 8007554:	4803      	ldr	r0, [pc, #12]	; (8007564 <CDC_Init_FS+0x20>)
 8007556:	f7fe fe73 	bl	8006240 <USBD_CDC_SetRxBuffer>
  return (USBD_OK);
 800755a:	2300      	movs	r3, #0
  /* USER CODE END 3 */
}
 800755c:	4618      	mov	r0, r3
 800755e:	bd80      	pop	{r7, pc}
 8007560:	20008bdc 	.word	0x20008bdc
 8007564:	2000810c 	.word	0x2000810c
 8007568:	200083dc 	.word	0x200083dc

0800756c <CDC_DeInit_FS>:
/**
  * @brief  DeInitializes the CDC media low layer
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_DeInit_FS(void)
{
 800756c:	b480      	push	{r7}
 800756e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
 8007570:	2300      	movs	r3, #0
  /* USER CODE END 4 */
}
 8007572:	4618      	mov	r0, r3
 8007574:	46bd      	mov	sp, r7
 8007576:	f85d 7b04 	ldr.w	r7, [sp], #4
 800757a:	4770      	bx	lr

0800757c <CDC_Control_FS>:
  * @param  pbuf: Buffer containing command data (request parameters)
  * @param  length: Number of data to be sent (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
 800757c:	b480      	push	{r7}
 800757e:	b083      	sub	sp, #12
 8007580:	af00      	add	r7, sp, #0
 8007582:	4603      	mov	r3, r0
 8007584:	6039      	str	r1, [r7, #0]
 8007586:	71fb      	strb	r3, [r7, #7]
 8007588:	4613      	mov	r3, r2
 800758a:	80bb      	strh	r3, [r7, #4]
  /* USER CODE BEGIN 5 */
  switch(cmd)
 800758c:	79fb      	ldrb	r3, [r7, #7]
 800758e:	2b23      	cmp	r3, #35	; 0x23
 8007590:	d84a      	bhi.n	8007628 <CDC_Control_FS+0xac>
 8007592:	a201      	add	r2, pc, #4	; (adr r2, 8007598 <CDC_Control_FS+0x1c>)
 8007594:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007598:	08007629 	.word	0x08007629
 800759c:	08007629 	.word	0x08007629
 80075a0:	08007629 	.word	0x08007629
 80075a4:	08007629 	.word	0x08007629
 80075a8:	08007629 	.word	0x08007629
 80075ac:	08007629 	.word	0x08007629
 80075b0:	08007629 	.word	0x08007629
 80075b4:	08007629 	.word	0x08007629
 80075b8:	08007629 	.word	0x08007629
 80075bc:	08007629 	.word	0x08007629
 80075c0:	08007629 	.word	0x08007629
 80075c4:	08007629 	.word	0x08007629
 80075c8:	08007629 	.word	0x08007629
 80075cc:	08007629 	.word	0x08007629
 80075d0:	08007629 	.word	0x08007629
 80075d4:	08007629 	.word	0x08007629
 80075d8:	08007629 	.word	0x08007629
 80075dc:	08007629 	.word	0x08007629
 80075e0:	08007629 	.word	0x08007629
 80075e4:	08007629 	.word	0x08007629
 80075e8:	08007629 	.word	0x08007629
 80075ec:	08007629 	.word	0x08007629
 80075f0:	08007629 	.word	0x08007629
 80075f4:	08007629 	.word	0x08007629
 80075f8:	08007629 	.word	0x08007629
 80075fc:	08007629 	.word	0x08007629
 8007600:	08007629 	.word	0x08007629
 8007604:	08007629 	.word	0x08007629
 8007608:	08007629 	.word	0x08007629
 800760c:	08007629 	.word	0x08007629
 8007610:	08007629 	.word	0x08007629
 8007614:	08007629 	.word	0x08007629
 8007618:	08007629 	.word	0x08007629
 800761c:	08007629 	.word	0x08007629
 8007620:	08007629 	.word	0x08007629
 8007624:	08007629 	.word	0x08007629
    case CDC_SEND_BREAK:

    break;

  default:
    break;
 8007628:	bf00      	nop
  }

  return (USBD_OK);
 800762a:	2300      	movs	r3, #0
  /* USER CODE END 5 */
}
 800762c:	4618      	mov	r0, r3
 800762e:	370c      	adds	r7, #12
 8007630:	46bd      	mov	sp, r7
 8007632:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007636:	4770      	bx	lr

08007638 <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
 8007638:	b580      	push	{r7, lr}
 800763a:	b082      	sub	sp, #8
 800763c:	af00      	add	r7, sp, #0
 800763e:	6078      	str	r0, [r7, #4]
 8007640:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 8007642:	6879      	ldr	r1, [r7, #4]
 8007644:	4805      	ldr	r0, [pc, #20]	; (800765c <CDC_Receive_FS+0x24>)
 8007646:	f7fe fdfb 	bl	8006240 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 800764a:	4804      	ldr	r0, [pc, #16]	; (800765c <CDC_Receive_FS+0x24>)
 800764c:	f7fe fe0c 	bl	8006268 <USBD_CDC_ReceivePacket>
  return (USBD_OK);
 8007650:	2300      	movs	r3, #0
  /* USER CODE END 6 */
}
 8007652:	4618      	mov	r0, r3
 8007654:	3708      	adds	r7, #8
 8007656:	46bd      	mov	sp, r7
 8007658:	bd80      	pop	{r7, pc}
 800765a:	bf00      	nop
 800765c:	2000810c 	.word	0x2000810c

08007660 <CDC_TransmitCplt_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_TransmitCplt_FS(uint8_t *Buf, uint32_t *Len, uint8_t epnum)
{
 8007660:	b480      	push	{r7}
 8007662:	b087      	sub	sp, #28
 8007664:	af00      	add	r7, sp, #0
 8007666:	60f8      	str	r0, [r7, #12]
 8007668:	60b9      	str	r1, [r7, #8]
 800766a:	4613      	mov	r3, r2
 800766c:	71fb      	strb	r3, [r7, #7]
  uint8_t result = USBD_OK;
 800766e:	2300      	movs	r3, #0
 8007670:	75fb      	strb	r3, [r7, #23]
  /* USER CODE BEGIN 13 */
  UNUSED(Buf);
  UNUSED(Len);
  UNUSED(epnum);
  /* USER CODE END 13 */
  return result;
 8007672:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 8007676:	4618      	mov	r0, r3
 8007678:	371c      	adds	r7, #28
 800767a:	46bd      	mov	sp, r7
 800767c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007680:	4770      	bx	lr
	...

08007684 <USBD_FS_DeviceDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8007684:	b480      	push	{r7}
 8007686:	b083      	sub	sp, #12
 8007688:	af00      	add	r7, sp, #0
 800768a:	4603      	mov	r3, r0
 800768c:	6039      	str	r1, [r7, #0]
 800768e:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 8007690:	683b      	ldr	r3, [r7, #0]
 8007692:	2212      	movs	r2, #18
 8007694:	801a      	strh	r2, [r3, #0]
  return USBD_FS_DeviceDesc;
 8007696:	4b03      	ldr	r3, [pc, #12]	; (80076a4 <USBD_FS_DeviceDescriptor+0x20>)
}
 8007698:	4618      	mov	r0, r3
 800769a:	370c      	adds	r7, #12
 800769c:	46bd      	mov	sp, r7
 800769e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80076a2:	4770      	bx	lr
 80076a4:	20000154 	.word	0x20000154

080076a8 <USBD_FS_LangIDStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80076a8:	b480      	push	{r7}
 80076aa:	b083      	sub	sp, #12
 80076ac:	af00      	add	r7, sp, #0
 80076ae:	4603      	mov	r3, r0
 80076b0:	6039      	str	r1, [r7, #0]
 80076b2:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 80076b4:	683b      	ldr	r3, [r7, #0]
 80076b6:	2204      	movs	r2, #4
 80076b8:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 80076ba:	4b03      	ldr	r3, [pc, #12]	; (80076c8 <USBD_FS_LangIDStrDescriptor+0x20>)
}
 80076bc:	4618      	mov	r0, r3
 80076be:	370c      	adds	r7, #12
 80076c0:	46bd      	mov	sp, r7
 80076c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80076c6:	4770      	bx	lr
 80076c8:	20000168 	.word	0x20000168

080076cc <USBD_FS_ProductStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80076cc:	b580      	push	{r7, lr}
 80076ce:	b082      	sub	sp, #8
 80076d0:	af00      	add	r7, sp, #0
 80076d2:	4603      	mov	r3, r0
 80076d4:	6039      	str	r1, [r7, #0]
 80076d6:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 80076d8:	79fb      	ldrb	r3, [r7, #7]
 80076da:	2b00      	cmp	r3, #0
 80076dc:	d105      	bne.n	80076ea <USBD_FS_ProductStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 80076de:	683a      	ldr	r2, [r7, #0]
 80076e0:	4907      	ldr	r1, [pc, #28]	; (8007700 <USBD_FS_ProductStrDescriptor+0x34>)
 80076e2:	4808      	ldr	r0, [pc, #32]	; (8007704 <USBD_FS_ProductStrDescriptor+0x38>)
 80076e4:	f7ff fe1e 	bl	8007324 <USBD_GetString>
 80076e8:	e004      	b.n	80076f4 <USBD_FS_ProductStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 80076ea:	683a      	ldr	r2, [r7, #0]
 80076ec:	4904      	ldr	r1, [pc, #16]	; (8007700 <USBD_FS_ProductStrDescriptor+0x34>)
 80076ee:	4805      	ldr	r0, [pc, #20]	; (8007704 <USBD_FS_ProductStrDescriptor+0x38>)
 80076f0:	f7ff fe18 	bl	8007324 <USBD_GetString>
  }
  return USBD_StrDesc;
 80076f4:	4b02      	ldr	r3, [pc, #8]	; (8007700 <USBD_FS_ProductStrDescriptor+0x34>)
}
 80076f6:	4618      	mov	r0, r3
 80076f8:	3708      	adds	r7, #8
 80076fa:	46bd      	mov	sp, r7
 80076fc:	bd80      	pop	{r7, pc}
 80076fe:	bf00      	nop
 8007700:	200093dc 	.word	0x200093dc
 8007704:	0802e3c0 	.word	0x0802e3c0

08007708 <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8007708:	b580      	push	{r7, lr}
 800770a:	b082      	sub	sp, #8
 800770c:	af00      	add	r7, sp, #0
 800770e:	4603      	mov	r3, r0
 8007710:	6039      	str	r1, [r7, #0]
 8007712:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 8007714:	683a      	ldr	r2, [r7, #0]
 8007716:	4904      	ldr	r1, [pc, #16]	; (8007728 <USBD_FS_ManufacturerStrDescriptor+0x20>)
 8007718:	4804      	ldr	r0, [pc, #16]	; (800772c <USBD_FS_ManufacturerStrDescriptor+0x24>)
 800771a:	f7ff fe03 	bl	8007324 <USBD_GetString>
  return USBD_StrDesc;
 800771e:	4b02      	ldr	r3, [pc, #8]	; (8007728 <USBD_FS_ManufacturerStrDescriptor+0x20>)
}
 8007720:	4618      	mov	r0, r3
 8007722:	3708      	adds	r7, #8
 8007724:	46bd      	mov	sp, r7
 8007726:	bd80      	pop	{r7, pc}
 8007728:	200093dc 	.word	0x200093dc
 800772c:	0802e3d8 	.word	0x0802e3d8

08007730 <USBD_FS_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8007730:	b580      	push	{r7, lr}
 8007732:	b082      	sub	sp, #8
 8007734:	af00      	add	r7, sp, #0
 8007736:	4603      	mov	r3, r0
 8007738:	6039      	str	r1, [r7, #0]
 800773a:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = USB_SIZ_STRING_SERIAL;
 800773c:	683b      	ldr	r3, [r7, #0]
 800773e:	221a      	movs	r2, #26
 8007740:	801a      	strh	r2, [r3, #0]

  /* Update the serial number string descriptor with the data from the unique
   * ID */
  Get_SerialNum();
 8007742:	f000 f843 	bl	80077cc <Get_SerialNum>
  /* USER CODE BEGIN USBD_FS_SerialStrDescriptor */

  /* USER CODE END USBD_FS_SerialStrDescriptor */
  return (uint8_t *) USBD_StringSerial;
 8007746:	4b02      	ldr	r3, [pc, #8]	; (8007750 <USBD_FS_SerialStrDescriptor+0x20>)
}
 8007748:	4618      	mov	r0, r3
 800774a:	3708      	adds	r7, #8
 800774c:	46bd      	mov	sp, r7
 800774e:	bd80      	pop	{r7, pc}
 8007750:	2000016c 	.word	0x2000016c

08007754 <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8007754:	b580      	push	{r7, lr}
 8007756:	b082      	sub	sp, #8
 8007758:	af00      	add	r7, sp, #0
 800775a:	4603      	mov	r3, r0
 800775c:	6039      	str	r1, [r7, #0]
 800775e:	71fb      	strb	r3, [r7, #7]
  if(speed == USBD_SPEED_HIGH)
 8007760:	79fb      	ldrb	r3, [r7, #7]
 8007762:	2b00      	cmp	r3, #0
 8007764:	d105      	bne.n	8007772 <USBD_FS_ConfigStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8007766:	683a      	ldr	r2, [r7, #0]
 8007768:	4907      	ldr	r1, [pc, #28]	; (8007788 <USBD_FS_ConfigStrDescriptor+0x34>)
 800776a:	4808      	ldr	r0, [pc, #32]	; (800778c <USBD_FS_ConfigStrDescriptor+0x38>)
 800776c:	f7ff fdda 	bl	8007324 <USBD_GetString>
 8007770:	e004      	b.n	800777c <USBD_FS_ConfigStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8007772:	683a      	ldr	r2, [r7, #0]
 8007774:	4904      	ldr	r1, [pc, #16]	; (8007788 <USBD_FS_ConfigStrDescriptor+0x34>)
 8007776:	4805      	ldr	r0, [pc, #20]	; (800778c <USBD_FS_ConfigStrDescriptor+0x38>)
 8007778:	f7ff fdd4 	bl	8007324 <USBD_GetString>
  }
  return USBD_StrDesc;
 800777c:	4b02      	ldr	r3, [pc, #8]	; (8007788 <USBD_FS_ConfigStrDescriptor+0x34>)
}
 800777e:	4618      	mov	r0, r3
 8007780:	3708      	adds	r7, #8
 8007782:	46bd      	mov	sp, r7
 8007784:	bd80      	pop	{r7, pc}
 8007786:	bf00      	nop
 8007788:	200093dc 	.word	0x200093dc
 800778c:	0802e3ec 	.word	0x0802e3ec

08007790 <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8007790:	b580      	push	{r7, lr}
 8007792:	b082      	sub	sp, #8
 8007794:	af00      	add	r7, sp, #0
 8007796:	4603      	mov	r3, r0
 8007798:	6039      	str	r1, [r7, #0]
 800779a:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 800779c:	79fb      	ldrb	r3, [r7, #7]
 800779e:	2b00      	cmp	r3, #0
 80077a0:	d105      	bne.n	80077ae <USBD_FS_InterfaceStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80077a2:	683a      	ldr	r2, [r7, #0]
 80077a4:	4907      	ldr	r1, [pc, #28]	; (80077c4 <USBD_FS_InterfaceStrDescriptor+0x34>)
 80077a6:	4808      	ldr	r0, [pc, #32]	; (80077c8 <USBD_FS_InterfaceStrDescriptor+0x38>)
 80077a8:	f7ff fdbc 	bl	8007324 <USBD_GetString>
 80077ac:	e004      	b.n	80077b8 <USBD_FS_InterfaceStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 80077ae:	683a      	ldr	r2, [r7, #0]
 80077b0:	4904      	ldr	r1, [pc, #16]	; (80077c4 <USBD_FS_InterfaceStrDescriptor+0x34>)
 80077b2:	4805      	ldr	r0, [pc, #20]	; (80077c8 <USBD_FS_InterfaceStrDescriptor+0x38>)
 80077b4:	f7ff fdb6 	bl	8007324 <USBD_GetString>
  }
  return USBD_StrDesc;
 80077b8:	4b02      	ldr	r3, [pc, #8]	; (80077c4 <USBD_FS_InterfaceStrDescriptor+0x34>)
}
 80077ba:	4618      	mov	r0, r3
 80077bc:	3708      	adds	r7, #8
 80077be:	46bd      	mov	sp, r7
 80077c0:	bd80      	pop	{r7, pc}
 80077c2:	bf00      	nop
 80077c4:	200093dc 	.word	0x200093dc
 80077c8:	0802e3f8 	.word	0x0802e3f8

080077cc <Get_SerialNum>:
  * @brief  Create the serial number string descriptor
  * @param  None
  * @retval None
  */
static void Get_SerialNum(void)
{
 80077cc:	b580      	push	{r7, lr}
 80077ce:	b084      	sub	sp, #16
 80077d0:	af00      	add	r7, sp, #0
  uint32_t deviceserial0, deviceserial1, deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 80077d2:	4b0f      	ldr	r3, [pc, #60]	; (8007810 <Get_SerialNum+0x44>)
 80077d4:	681b      	ldr	r3, [r3, #0]
 80077d6:	60fb      	str	r3, [r7, #12]
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 80077d8:	4b0e      	ldr	r3, [pc, #56]	; (8007814 <Get_SerialNum+0x48>)
 80077da:	681b      	ldr	r3, [r3, #0]
 80077dc:	60bb      	str	r3, [r7, #8]
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 80077de:	4b0e      	ldr	r3, [pc, #56]	; (8007818 <Get_SerialNum+0x4c>)
 80077e0:	681b      	ldr	r3, [r3, #0]
 80077e2:	607b      	str	r3, [r7, #4]

  deviceserial0 += deviceserial2;
 80077e4:	68fa      	ldr	r2, [r7, #12]
 80077e6:	687b      	ldr	r3, [r7, #4]
 80077e8:	4413      	add	r3, r2
 80077ea:	60fb      	str	r3, [r7, #12]

  if (deviceserial0 != 0)
 80077ec:	68fb      	ldr	r3, [r7, #12]
 80077ee:	2b00      	cmp	r3, #0
 80077f0:	d009      	beq.n	8007806 <Get_SerialNum+0x3a>
  {
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 80077f2:	2208      	movs	r2, #8
 80077f4:	4909      	ldr	r1, [pc, #36]	; (800781c <Get_SerialNum+0x50>)
 80077f6:	68f8      	ldr	r0, [r7, #12]
 80077f8:	f000 f814 	bl	8007824 <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 80077fc:	2204      	movs	r2, #4
 80077fe:	4908      	ldr	r1, [pc, #32]	; (8007820 <Get_SerialNum+0x54>)
 8007800:	68b8      	ldr	r0, [r7, #8]
 8007802:	f000 f80f 	bl	8007824 <IntToUnicode>
  }
}
 8007806:	bf00      	nop
 8007808:	3710      	adds	r7, #16
 800780a:	46bd      	mov	sp, r7
 800780c:	bd80      	pop	{r7, pc}
 800780e:	bf00      	nop
 8007810:	1fff7a10 	.word	0x1fff7a10
 8007814:	1fff7a14 	.word	0x1fff7a14
 8007818:	1fff7a18 	.word	0x1fff7a18
 800781c:	2000016e 	.word	0x2000016e
 8007820:	2000017e 	.word	0x2000017e

08007824 <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
 8007824:	b480      	push	{r7}
 8007826:	b087      	sub	sp, #28
 8007828:	af00      	add	r7, sp, #0
 800782a:	60f8      	str	r0, [r7, #12]
 800782c:	60b9      	str	r1, [r7, #8]
 800782e:	4613      	mov	r3, r2
 8007830:	71fb      	strb	r3, [r7, #7]
  uint8_t idx = 0;
 8007832:	2300      	movs	r3, #0
 8007834:	75fb      	strb	r3, [r7, #23]

  for (idx = 0; idx < len; idx++)
 8007836:	2300      	movs	r3, #0
 8007838:	75fb      	strb	r3, [r7, #23]
 800783a:	e027      	b.n	800788c <IntToUnicode+0x68>
  {
    if (((value >> 28)) < 0xA)
 800783c:	68fb      	ldr	r3, [r7, #12]
 800783e:	0f1b      	lsrs	r3, r3, #28
 8007840:	2b09      	cmp	r3, #9
 8007842:	d80b      	bhi.n	800785c <IntToUnicode+0x38>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
 8007844:	68fb      	ldr	r3, [r7, #12]
 8007846:	0f1b      	lsrs	r3, r3, #28
 8007848:	b2da      	uxtb	r2, r3
 800784a:	7dfb      	ldrb	r3, [r7, #23]
 800784c:	005b      	lsls	r3, r3, #1
 800784e:	4619      	mov	r1, r3
 8007850:	68bb      	ldr	r3, [r7, #8]
 8007852:	440b      	add	r3, r1
 8007854:	3230      	adds	r2, #48	; 0x30
 8007856:	b2d2      	uxtb	r2, r2
 8007858:	701a      	strb	r2, [r3, #0]
 800785a:	e00a      	b.n	8007872 <IntToUnicode+0x4e>
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 800785c:	68fb      	ldr	r3, [r7, #12]
 800785e:	0f1b      	lsrs	r3, r3, #28
 8007860:	b2da      	uxtb	r2, r3
 8007862:	7dfb      	ldrb	r3, [r7, #23]
 8007864:	005b      	lsls	r3, r3, #1
 8007866:	4619      	mov	r1, r3
 8007868:	68bb      	ldr	r3, [r7, #8]
 800786a:	440b      	add	r3, r1
 800786c:	3237      	adds	r2, #55	; 0x37
 800786e:	b2d2      	uxtb	r2, r2
 8007870:	701a      	strb	r2, [r3, #0]
    }

    value = value << 4;
 8007872:	68fb      	ldr	r3, [r7, #12]
 8007874:	011b      	lsls	r3, r3, #4
 8007876:	60fb      	str	r3, [r7, #12]

    pbuf[2 * idx + 1] = 0;
 8007878:	7dfb      	ldrb	r3, [r7, #23]
 800787a:	005b      	lsls	r3, r3, #1
 800787c:	3301      	adds	r3, #1
 800787e:	68ba      	ldr	r2, [r7, #8]
 8007880:	4413      	add	r3, r2
 8007882:	2200      	movs	r2, #0
 8007884:	701a      	strb	r2, [r3, #0]
  for (idx = 0; idx < len; idx++)
 8007886:	7dfb      	ldrb	r3, [r7, #23]
 8007888:	3301      	adds	r3, #1
 800788a:	75fb      	strb	r3, [r7, #23]
 800788c:	7dfa      	ldrb	r2, [r7, #23]
 800788e:	79fb      	ldrb	r3, [r7, #7]
 8007890:	429a      	cmp	r2, r3
 8007892:	d3d3      	bcc.n	800783c <IntToUnicode+0x18>
  }
}
 8007894:	bf00      	nop
 8007896:	bf00      	nop
 8007898:	371c      	adds	r7, #28
 800789a:	46bd      	mov	sp, r7
 800789c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80078a0:	4770      	bx	lr
	...

080078a4 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 80078a4:	b580      	push	{r7, lr}
 80078a6:	b08a      	sub	sp, #40	; 0x28
 80078a8:	af00      	add	r7, sp, #0
 80078aa:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80078ac:	f107 0314 	add.w	r3, r7, #20
 80078b0:	2200      	movs	r2, #0
 80078b2:	601a      	str	r2, [r3, #0]
 80078b4:	605a      	str	r2, [r3, #4]
 80078b6:	609a      	str	r2, [r3, #8]
 80078b8:	60da      	str	r2, [r3, #12]
 80078ba:	611a      	str	r2, [r3, #16]
  if(pcdHandle->Instance==USB_OTG_FS)
 80078bc:	687b      	ldr	r3, [r7, #4]
 80078be:	681b      	ldr	r3, [r3, #0]
 80078c0:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80078c4:	d13a      	bne.n	800793c <HAL_PCD_MspInit+0x98>
  {
  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */

  /* USER CODE END USB_OTG_FS_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 80078c6:	2300      	movs	r3, #0
 80078c8:	613b      	str	r3, [r7, #16]
 80078ca:	4b1e      	ldr	r3, [pc, #120]	; (8007944 <HAL_PCD_MspInit+0xa0>)
 80078cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80078ce:	4a1d      	ldr	r2, [pc, #116]	; (8007944 <HAL_PCD_MspInit+0xa0>)
 80078d0:	f043 0301 	orr.w	r3, r3, #1
 80078d4:	6313      	str	r3, [r2, #48]	; 0x30
 80078d6:	4b1b      	ldr	r3, [pc, #108]	; (8007944 <HAL_PCD_MspInit+0xa0>)
 80078d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80078da:	f003 0301 	and.w	r3, r3, #1
 80078de:	613b      	str	r3, [r7, #16]
 80078e0:	693b      	ldr	r3, [r7, #16]
    /**USB_OTG_FS GPIO Configuration
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 80078e2:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 80078e6:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80078e8:	2302      	movs	r3, #2
 80078ea:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80078ec:	2300      	movs	r3, #0
 80078ee:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80078f0:	2303      	movs	r3, #3
 80078f2:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 80078f4:	230a      	movs	r3, #10
 80078f6:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80078f8:	f107 0314 	add.w	r3, r7, #20
 80078fc:	4619      	mov	r1, r3
 80078fe:	4812      	ldr	r0, [pc, #72]	; (8007948 <HAL_PCD_MspInit+0xa4>)
 8007900:	f7fa f880 	bl	8001a04 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8007904:	4b0f      	ldr	r3, [pc, #60]	; (8007944 <HAL_PCD_MspInit+0xa0>)
 8007906:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8007908:	4a0e      	ldr	r2, [pc, #56]	; (8007944 <HAL_PCD_MspInit+0xa0>)
 800790a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800790e:	6353      	str	r3, [r2, #52]	; 0x34
 8007910:	2300      	movs	r3, #0
 8007912:	60fb      	str	r3, [r7, #12]
 8007914:	4b0b      	ldr	r3, [pc, #44]	; (8007944 <HAL_PCD_MspInit+0xa0>)
 8007916:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007918:	4a0a      	ldr	r2, [pc, #40]	; (8007944 <HAL_PCD_MspInit+0xa0>)
 800791a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800791e:	6453      	str	r3, [r2, #68]	; 0x44
 8007920:	4b08      	ldr	r3, [pc, #32]	; (8007944 <HAL_PCD_MspInit+0xa0>)
 8007922:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8007924:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8007928:	60fb      	str	r3, [r7, #12]
 800792a:	68fb      	ldr	r3, [r7, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 800792c:	2200      	movs	r2, #0
 800792e:	2100      	movs	r1, #0
 8007930:	2043      	movs	r0, #67	; 0x43
 8007932:	f7f9 fe2a 	bl	800158a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8007936:	2043      	movs	r0, #67	; 0x43
 8007938:	f7f9 fe43 	bl	80015c2 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 800793c:	bf00      	nop
 800793e:	3728      	adds	r7, #40	; 0x28
 8007940:	46bd      	mov	sp, r7
 8007942:	bd80      	pop	{r7, pc}
 8007944:	40023800 	.word	0x40023800
 8007948:	40020000 	.word	0x40020000

0800794c <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 800794c:	b580      	push	{r7, lr}
 800794e:	b082      	sub	sp, #8
 8007950:	af00      	add	r7, sp, #0
 8007952:	6078      	str	r0, [r7, #4]
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 8007954:	687b      	ldr	r3, [r7, #4]
 8007956:	f8d3 2404 	ldr.w	r2, [r3, #1028]	; 0x404
 800795a:	687b      	ldr	r3, [r7, #4]
 800795c:	f503 7371 	add.w	r3, r3, #964	; 0x3c4
 8007960:	4619      	mov	r1, r3
 8007962:	4610      	mov	r0, r2
 8007964:	f7fe fd4c 	bl	8006400 <USBD_LL_SetupStage>
}
 8007968:	bf00      	nop
 800796a:	3708      	adds	r7, #8
 800796c:	46bd      	mov	sp, r7
 800796e:	bd80      	pop	{r7, pc}

08007970 <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8007970:	b580      	push	{r7, lr}
 8007972:	b082      	sub	sp, #8
 8007974:	af00      	add	r7, sp, #0
 8007976:	6078      	str	r0, [r7, #4]
 8007978:	460b      	mov	r3, r1
 800797a:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 800797c:	687b      	ldr	r3, [r7, #4]
 800797e:	f8d3 0404 	ldr.w	r0, [r3, #1028]	; 0x404
 8007982:	78fa      	ldrb	r2, [r7, #3]
 8007984:	6879      	ldr	r1, [r7, #4]
 8007986:	4613      	mov	r3, r2
 8007988:	00db      	lsls	r3, r3, #3
 800798a:	1a9b      	subs	r3, r3, r2
 800798c:	009b      	lsls	r3, r3, #2
 800798e:	440b      	add	r3, r1
 8007990:	f503 7302 	add.w	r3, r3, #520	; 0x208
 8007994:	681a      	ldr	r2, [r3, #0]
 8007996:	78fb      	ldrb	r3, [r7, #3]
 8007998:	4619      	mov	r1, r3
 800799a:	f7fe fd86 	bl	80064aa <USBD_LL_DataOutStage>
}
 800799e:	bf00      	nop
 80079a0:	3708      	adds	r7, #8
 80079a2:	46bd      	mov	sp, r7
 80079a4:	bd80      	pop	{r7, pc}

080079a6 <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 80079a6:	b580      	push	{r7, lr}
 80079a8:	b082      	sub	sp, #8
 80079aa:	af00      	add	r7, sp, #0
 80079ac:	6078      	str	r0, [r7, #4]
 80079ae:	460b      	mov	r3, r1
 80079b0:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 80079b2:	687b      	ldr	r3, [r7, #4]
 80079b4:	f8d3 0404 	ldr.w	r0, [r3, #1028]	; 0x404
 80079b8:	78fa      	ldrb	r2, [r7, #3]
 80079ba:	6879      	ldr	r1, [r7, #4]
 80079bc:	4613      	mov	r3, r2
 80079be:	00db      	lsls	r3, r3, #3
 80079c0:	1a9b      	subs	r3, r3, r2
 80079c2:	009b      	lsls	r3, r3, #2
 80079c4:	440b      	add	r3, r1
 80079c6:	3348      	adds	r3, #72	; 0x48
 80079c8:	681a      	ldr	r2, [r3, #0]
 80079ca:	78fb      	ldrb	r3, [r7, #3]
 80079cc:	4619      	mov	r1, r3
 80079ce:	f7fe fdcf 	bl	8006570 <USBD_LL_DataInStage>
}
 80079d2:	bf00      	nop
 80079d4:	3708      	adds	r7, #8
 80079d6:	46bd      	mov	sp, r7
 80079d8:	bd80      	pop	{r7, pc}

080079da <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 80079da:	b580      	push	{r7, lr}
 80079dc:	b082      	sub	sp, #8
 80079de:	af00      	add	r7, sp, #0
 80079e0:	6078      	str	r0, [r7, #4]
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 80079e2:	687b      	ldr	r3, [r7, #4]
 80079e4:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 80079e8:	4618      	mov	r0, r3
 80079ea:	f7fe fed3 	bl	8006794 <USBD_LL_SOF>
}
 80079ee:	bf00      	nop
 80079f0:	3708      	adds	r7, #8
 80079f2:	46bd      	mov	sp, r7
 80079f4:	bd80      	pop	{r7, pc}

080079f6 <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 80079f6:	b580      	push	{r7, lr}
 80079f8:	b084      	sub	sp, #16
 80079fa:	af00      	add	r7, sp, #0
 80079fc:	6078      	str	r0, [r7, #4]
  USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 80079fe:	2301      	movs	r3, #1
 8007a00:	73fb      	strb	r3, [r7, #15]

  if ( hpcd->Init.speed == PCD_SPEED_HIGH)
 8007a02:	687b      	ldr	r3, [r7, #4]
 8007a04:	68db      	ldr	r3, [r3, #12]
 8007a06:	2b00      	cmp	r3, #0
 8007a08:	d102      	bne.n	8007a10 <HAL_PCD_ResetCallback+0x1a>
  {
    speed = USBD_SPEED_HIGH;
 8007a0a:	2300      	movs	r3, #0
 8007a0c:	73fb      	strb	r3, [r7, #15]
 8007a0e:	e008      	b.n	8007a22 <HAL_PCD_ResetCallback+0x2c>
  }
  else if ( hpcd->Init.speed == PCD_SPEED_FULL)
 8007a10:	687b      	ldr	r3, [r7, #4]
 8007a12:	68db      	ldr	r3, [r3, #12]
 8007a14:	2b02      	cmp	r3, #2
 8007a16:	d102      	bne.n	8007a1e <HAL_PCD_ResetCallback+0x28>
  {
    speed = USBD_SPEED_FULL;
 8007a18:	2301      	movs	r3, #1
 8007a1a:	73fb      	strb	r3, [r7, #15]
 8007a1c:	e001      	b.n	8007a22 <HAL_PCD_ResetCallback+0x2c>
  }
  else
  {
    Error_Handler();
 8007a1e:	f7f9 f9c7 	bl	8000db0 <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 8007a22:	687b      	ldr	r3, [r7, #4]
 8007a24:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 8007a28:	7bfa      	ldrb	r2, [r7, #15]
 8007a2a:	4611      	mov	r1, r2
 8007a2c:	4618      	mov	r0, r3
 8007a2e:	f7fe fe76 	bl	800671e <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 8007a32:	687b      	ldr	r3, [r7, #4]
 8007a34:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 8007a38:	4618      	mov	r0, r3
 8007a3a:	f7fe fe2f 	bl	800669c <USBD_LL_Reset>
}
 8007a3e:	bf00      	nop
 8007a40:	3710      	adds	r7, #16
 8007a42:	46bd      	mov	sp, r7
 8007a44:	bd80      	pop	{r7, pc}
	...

08007a48 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8007a48:	b580      	push	{r7, lr}
 8007a4a:	b082      	sub	sp, #8
 8007a4c:	af00      	add	r7, sp, #0
 8007a4e:	6078      	str	r0, [r7, #4]
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 8007a50:	687b      	ldr	r3, [r7, #4]
 8007a52:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 8007a56:	4618      	mov	r0, r3
 8007a58:	f7fe fe71 	bl	800673e <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 8007a5c:	687b      	ldr	r3, [r7, #4]
 8007a5e:	681b      	ldr	r3, [r3, #0]
 8007a60:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 8007a64:	681b      	ldr	r3, [r3, #0]
 8007a66:	687a      	ldr	r2, [r7, #4]
 8007a68:	6812      	ldr	r2, [r2, #0]
 8007a6a:	f502 6260 	add.w	r2, r2, #3584	; 0xe00
 8007a6e:	f043 0301 	orr.w	r3, r3, #1
 8007a72:	6013      	str	r3, [r2, #0]
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8007a74:	687b      	ldr	r3, [r7, #4]
 8007a76:	6a1b      	ldr	r3, [r3, #32]
 8007a78:	2b00      	cmp	r3, #0
 8007a7a:	d005      	beq.n	8007a88 <HAL_PCD_SuspendCallback+0x40>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8007a7c:	4b04      	ldr	r3, [pc, #16]	; (8007a90 <HAL_PCD_SuspendCallback+0x48>)
 8007a7e:	691b      	ldr	r3, [r3, #16]
 8007a80:	4a03      	ldr	r2, [pc, #12]	; (8007a90 <HAL_PCD_SuspendCallback+0x48>)
 8007a82:	f043 0306 	orr.w	r3, r3, #6
 8007a86:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 8007a88:	bf00      	nop
 8007a8a:	3708      	adds	r7, #8
 8007a8c:	46bd      	mov	sp, r7
 8007a8e:	bd80      	pop	{r7, pc}
 8007a90:	e000ed00 	.word	0xe000ed00

08007a94 <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8007a94:	b580      	push	{r7, lr}
 8007a96:	b082      	sub	sp, #8
 8007a98:	af00      	add	r7, sp, #0
 8007a9a:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8007a9c:	687b      	ldr	r3, [r7, #4]
 8007a9e:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 8007aa2:	4618      	mov	r0, r3
 8007aa4:	f7fe fe60 	bl	8006768 <USBD_LL_Resume>
}
 8007aa8:	bf00      	nop
 8007aaa:	3708      	adds	r7, #8
 8007aac:	46bd      	mov	sp, r7
 8007aae:	bd80      	pop	{r7, pc}

08007ab0 <HAL_PCD_ISOOUTIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8007ab0:	b580      	push	{r7, lr}
 8007ab2:	b082      	sub	sp, #8
 8007ab4:	af00      	add	r7, sp, #0
 8007ab6:	6078      	str	r0, [r7, #4]
 8007ab8:	460b      	mov	r3, r1
 8007aba:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8007abc:	687b      	ldr	r3, [r7, #4]
 8007abe:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 8007ac2:	78fa      	ldrb	r2, [r7, #3]
 8007ac4:	4611      	mov	r1, r2
 8007ac6:	4618      	mov	r0, r3
 8007ac8:	f7fe fe8b 	bl	80067e2 <USBD_LL_IsoOUTIncomplete>
}
 8007acc:	bf00      	nop
 8007ace:	3708      	adds	r7, #8
 8007ad0:	46bd      	mov	sp, r7
 8007ad2:	bd80      	pop	{r7, pc}

08007ad4 <HAL_PCD_ISOINIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8007ad4:	b580      	push	{r7, lr}
 8007ad6:	b082      	sub	sp, #8
 8007ad8:	af00      	add	r7, sp, #0
 8007ada:	6078      	str	r0, [r7, #4]
 8007adc:	460b      	mov	r3, r1
 8007ade:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 8007ae0:	687b      	ldr	r3, [r7, #4]
 8007ae2:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 8007ae6:	78fa      	ldrb	r2, [r7, #3]
 8007ae8:	4611      	mov	r1, r2
 8007aea:	4618      	mov	r0, r3
 8007aec:	f7fe fe6c 	bl	80067c8 <USBD_LL_IsoINIncomplete>
}
 8007af0:	bf00      	nop
 8007af2:	3708      	adds	r7, #8
 8007af4:	46bd      	mov	sp, r7
 8007af6:	bd80      	pop	{r7, pc}

08007af8 <HAL_PCD_ConnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8007af8:	b580      	push	{r7, lr}
 8007afa:	b082      	sub	sp, #8
 8007afc:	af00      	add	r7, sp, #0
 8007afe:	6078      	str	r0, [r7, #4]
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 8007b00:	687b      	ldr	r3, [r7, #4]
 8007b02:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 8007b06:	4618      	mov	r0, r3
 8007b08:	f7fe fe78 	bl	80067fc <USBD_LL_DevConnected>
}
 8007b0c:	bf00      	nop
 8007b0e:	3708      	adds	r7, #8
 8007b10:	46bd      	mov	sp, r7
 8007b12:	bd80      	pop	{r7, pc}

08007b14 <HAL_PCD_DisconnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 8007b14:	b580      	push	{r7, lr}
 8007b16:	b082      	sub	sp, #8
 8007b18:	af00      	add	r7, sp, #0
 8007b1a:	6078      	str	r0, [r7, #4]
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 8007b1c:	687b      	ldr	r3, [r7, #4]
 8007b1e:	f8d3 3404 	ldr.w	r3, [r3, #1028]	; 0x404
 8007b22:	4618      	mov	r0, r3
 8007b24:	f7fe fe75 	bl	8006812 <USBD_LL_DevDisconnected>
}
 8007b28:	bf00      	nop
 8007b2a:	3708      	adds	r7, #8
 8007b2c:	46bd      	mov	sp, r7
 8007b2e:	bd80      	pop	{r7, pc}

08007b30 <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 8007b30:	b580      	push	{r7, lr}
 8007b32:	b082      	sub	sp, #8
 8007b34:	af00      	add	r7, sp, #0
 8007b36:	6078      	str	r0, [r7, #4]
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 8007b38:	687b      	ldr	r3, [r7, #4]
 8007b3a:	781b      	ldrb	r3, [r3, #0]
 8007b3c:	2b00      	cmp	r3, #0
 8007b3e:	d13c      	bne.n	8007bba <USBD_LL_Init+0x8a>
  /* Link the driver to the stack. */
  hpcd_USB_OTG_FS.pData = pdev;
 8007b40:	4a20      	ldr	r2, [pc, #128]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b42:	687b      	ldr	r3, [r7, #4]
 8007b44:	f8c2 3404 	str.w	r3, [r2, #1028]	; 0x404
  pdev->pData = &hpcd_USB_OTG_FS;
 8007b48:	687b      	ldr	r3, [r7, #4]
 8007b4a:	4a1e      	ldr	r2, [pc, #120]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b4c:	f8c3 22c4 	str.w	r2, [r3, #708]	; 0x2c4

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8007b50:	4b1c      	ldr	r3, [pc, #112]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b52:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8007b56:	601a      	str	r2, [r3, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 8007b58:	4b1a      	ldr	r3, [pc, #104]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b5a:	2204      	movs	r2, #4
 8007b5c:	605a      	str	r2, [r3, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 8007b5e:	4b19      	ldr	r3, [pc, #100]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b60:	2202      	movs	r2, #2
 8007b62:	60da      	str	r2, [r3, #12]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 8007b64:	4b17      	ldr	r3, [pc, #92]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b66:	2200      	movs	r2, #0
 8007b68:	611a      	str	r2, [r3, #16]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8007b6a:	4b16      	ldr	r3, [pc, #88]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b6c:	2202      	movs	r2, #2
 8007b6e:	619a      	str	r2, [r3, #24]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 8007b70:	4b14      	ldr	r3, [pc, #80]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b72:	2200      	movs	r2, #0
 8007b74:	61da      	str	r2, [r3, #28]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 8007b76:	4b13      	ldr	r3, [pc, #76]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b78:	2200      	movs	r2, #0
 8007b7a:	621a      	str	r2, [r3, #32]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 8007b7c:	4b11      	ldr	r3, [pc, #68]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b7e:	2200      	movs	r2, #0
 8007b80:	625a      	str	r2, [r3, #36]	; 0x24
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = DISABLE;
 8007b82:	4b10      	ldr	r3, [pc, #64]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b84:	2200      	movs	r2, #0
 8007b86:	62da      	str	r2, [r3, #44]	; 0x2c
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 8007b88:	4b0e      	ldr	r3, [pc, #56]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b8a:	2200      	movs	r2, #0
 8007b8c:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 8007b8e:	480d      	ldr	r0, [pc, #52]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007b90:	f7fa fc65 	bl	800245e <HAL_PCD_Init>
 8007b94:	4603      	mov	r3, r0
 8007b96:	2b00      	cmp	r3, #0
 8007b98:	d001      	beq.n	8007b9e <USBD_LL_Init+0x6e>
  {
    Error_Handler( );
 8007b9a:	f7f9 f909 	bl	8000db0 <Error_Handler>
  HAL_PCD_RegisterDataOutStageCallback(&hpcd_USB_OTG_FS, PCD_DataOutStageCallback);
  HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_OTG_FS, PCD_DataInStageCallback);
  HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOOUTIncompleteCallback);
  HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOINIncompleteCallback);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 8007b9e:	2180      	movs	r1, #128	; 0x80
 8007ba0:	4808      	ldr	r0, [pc, #32]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007ba2:	f7fb fdc2 	bl	800372a <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 8007ba6:	2240      	movs	r2, #64	; 0x40
 8007ba8:	2100      	movs	r1, #0
 8007baa:	4806      	ldr	r0, [pc, #24]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007bac:	f7fb fd76 	bl	800369c <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 8007bb0:	2280      	movs	r2, #128	; 0x80
 8007bb2:	2101      	movs	r1, #1
 8007bb4:	4803      	ldr	r0, [pc, #12]	; (8007bc4 <USBD_LL_Init+0x94>)
 8007bb6:	f7fb fd71 	bl	800369c <HAL_PCDEx_SetTxFiFo>
  }
  return USBD_OK;
 8007bba:	2300      	movs	r3, #0
}
 8007bbc:	4618      	mov	r0, r3
 8007bbe:	3708      	adds	r7, #8
 8007bc0:	46bd      	mov	sp, r7
 8007bc2:	bd80      	pop	{r7, pc}
 8007bc4:	200095dc 	.word	0x200095dc

08007bc8 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8007bc8:	b580      	push	{r7, lr}
 8007bca:	b084      	sub	sp, #16
 8007bcc:	af00      	add	r7, sp, #0
 8007bce:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8007bd0:	2300      	movs	r3, #0
 8007bd2:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8007bd4:	2300      	movs	r3, #0
 8007bd6:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_Start(pdev->pData);
 8007bd8:	687b      	ldr	r3, [r7, #4]
 8007bda:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8007bde:	4618      	mov	r0, r3
 8007be0:	f7fa fd5a 	bl	8002698 <HAL_PCD_Start>
 8007be4:	4603      	mov	r3, r0
 8007be6:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8007be8:	7bfb      	ldrb	r3, [r7, #15]
 8007bea:	4618      	mov	r0, r3
 8007bec:	f000 f92a 	bl	8007e44 <USBD_Get_USB_Status>
 8007bf0:	4603      	mov	r3, r0
 8007bf2:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8007bf4:	7bbb      	ldrb	r3, [r7, #14]
}
 8007bf6:	4618      	mov	r0, r3
 8007bf8:	3710      	adds	r7, #16
 8007bfa:	46bd      	mov	sp, r7
 8007bfc:	bd80      	pop	{r7, pc}

08007bfe <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 8007bfe:	b580      	push	{r7, lr}
 8007c00:	b084      	sub	sp, #16
 8007c02:	af00      	add	r7, sp, #0
 8007c04:	6078      	str	r0, [r7, #4]
 8007c06:	4608      	mov	r0, r1
 8007c08:	4611      	mov	r1, r2
 8007c0a:	461a      	mov	r2, r3
 8007c0c:	4603      	mov	r3, r0
 8007c0e:	70fb      	strb	r3, [r7, #3]
 8007c10:	460b      	mov	r3, r1
 8007c12:	70bb      	strb	r3, [r7, #2]
 8007c14:	4613      	mov	r3, r2
 8007c16:	803b      	strh	r3, [r7, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8007c18:	2300      	movs	r3, #0
 8007c1a:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8007c1c:	2300      	movs	r3, #0
 8007c1e:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 8007c20:	687b      	ldr	r3, [r7, #4]
 8007c22:	f8d3 02c4 	ldr.w	r0, [r3, #708]	; 0x2c4
 8007c26:	78bb      	ldrb	r3, [r7, #2]
 8007c28:	883a      	ldrh	r2, [r7, #0]
 8007c2a:	78f9      	ldrb	r1, [r7, #3]
 8007c2c:	f7fb f93e 	bl	8002eac <HAL_PCD_EP_Open>
 8007c30:	4603      	mov	r3, r0
 8007c32:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8007c34:	7bfb      	ldrb	r3, [r7, #15]
 8007c36:	4618      	mov	r0, r3
 8007c38:	f000 f904 	bl	8007e44 <USBD_Get_USB_Status>
 8007c3c:	4603      	mov	r3, r0
 8007c3e:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8007c40:	7bbb      	ldrb	r3, [r7, #14]
}
 8007c42:	4618      	mov	r0, r3
 8007c44:	3710      	adds	r7, #16
 8007c46:	46bd      	mov	sp, r7
 8007c48:	bd80      	pop	{r7, pc}

08007c4a <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8007c4a:	b580      	push	{r7, lr}
 8007c4c:	b084      	sub	sp, #16
 8007c4e:	af00      	add	r7, sp, #0
 8007c50:	6078      	str	r0, [r7, #4]
 8007c52:	460b      	mov	r3, r1
 8007c54:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8007c56:	2300      	movs	r3, #0
 8007c58:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8007c5a:	2300      	movs	r3, #0
 8007c5c:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 8007c5e:	687b      	ldr	r3, [r7, #4]
 8007c60:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8007c64:	78fa      	ldrb	r2, [r7, #3]
 8007c66:	4611      	mov	r1, r2
 8007c68:	4618      	mov	r0, r3
 8007c6a:	f7fb f987 	bl	8002f7c <HAL_PCD_EP_Close>
 8007c6e:	4603      	mov	r3, r0
 8007c70:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8007c72:	7bfb      	ldrb	r3, [r7, #15]
 8007c74:	4618      	mov	r0, r3
 8007c76:	f000 f8e5 	bl	8007e44 <USBD_Get_USB_Status>
 8007c7a:	4603      	mov	r3, r0
 8007c7c:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8007c7e:	7bbb      	ldrb	r3, [r7, #14]
}
 8007c80:	4618      	mov	r0, r3
 8007c82:	3710      	adds	r7, #16
 8007c84:	46bd      	mov	sp, r7
 8007c86:	bd80      	pop	{r7, pc}

08007c88 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8007c88:	b580      	push	{r7, lr}
 8007c8a:	b084      	sub	sp, #16
 8007c8c:	af00      	add	r7, sp, #0
 8007c8e:	6078      	str	r0, [r7, #4]
 8007c90:	460b      	mov	r3, r1
 8007c92:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8007c94:	2300      	movs	r3, #0
 8007c96:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8007c98:	2300      	movs	r3, #0
 8007c9a:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 8007c9c:	687b      	ldr	r3, [r7, #4]
 8007c9e:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8007ca2:	78fa      	ldrb	r2, [r7, #3]
 8007ca4:	4611      	mov	r1, r2
 8007ca6:	4618      	mov	r0, r3
 8007ca8:	f7fb fa5f 	bl	800316a <HAL_PCD_EP_SetStall>
 8007cac:	4603      	mov	r3, r0
 8007cae:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8007cb0:	7bfb      	ldrb	r3, [r7, #15]
 8007cb2:	4618      	mov	r0, r3
 8007cb4:	f000 f8c6 	bl	8007e44 <USBD_Get_USB_Status>
 8007cb8:	4603      	mov	r3, r0
 8007cba:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8007cbc:	7bbb      	ldrb	r3, [r7, #14]
}
 8007cbe:	4618      	mov	r0, r3
 8007cc0:	3710      	adds	r7, #16
 8007cc2:	46bd      	mov	sp, r7
 8007cc4:	bd80      	pop	{r7, pc}

08007cc6 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8007cc6:	b580      	push	{r7, lr}
 8007cc8:	b084      	sub	sp, #16
 8007cca:	af00      	add	r7, sp, #0
 8007ccc:	6078      	str	r0, [r7, #4]
 8007cce:	460b      	mov	r3, r1
 8007cd0:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8007cd2:	2300      	movs	r3, #0
 8007cd4:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8007cd6:	2300      	movs	r3, #0
 8007cd8:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 8007cda:	687b      	ldr	r3, [r7, #4]
 8007cdc:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8007ce0:	78fa      	ldrb	r2, [r7, #3]
 8007ce2:	4611      	mov	r1, r2
 8007ce4:	4618      	mov	r0, r3
 8007ce6:	f7fb faa4 	bl	8003232 <HAL_PCD_EP_ClrStall>
 8007cea:	4603      	mov	r3, r0
 8007cec:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8007cee:	7bfb      	ldrb	r3, [r7, #15]
 8007cf0:	4618      	mov	r0, r3
 8007cf2:	f000 f8a7 	bl	8007e44 <USBD_Get_USB_Status>
 8007cf6:	4603      	mov	r3, r0
 8007cf8:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8007cfa:	7bbb      	ldrb	r3, [r7, #14]
}
 8007cfc:	4618      	mov	r0, r3
 8007cfe:	3710      	adds	r7, #16
 8007d00:	46bd      	mov	sp, r7
 8007d02:	bd80      	pop	{r7, pc}

08007d04 <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8007d04:	b480      	push	{r7}
 8007d06:	b085      	sub	sp, #20
 8007d08:	af00      	add	r7, sp, #0
 8007d0a:	6078      	str	r0, [r7, #4]
 8007d0c:	460b      	mov	r3, r1
 8007d0e:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8007d10:	687b      	ldr	r3, [r7, #4]
 8007d12:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8007d16:	60fb      	str	r3, [r7, #12]

  if((ep_addr & 0x80) == 0x80)
 8007d18:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8007d1c:	2b00      	cmp	r3, #0
 8007d1e:	da0b      	bge.n	8007d38 <USBD_LL_IsStallEP+0x34>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 8007d20:	78fb      	ldrb	r3, [r7, #3]
 8007d22:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8007d26:	68f9      	ldr	r1, [r7, #12]
 8007d28:	4613      	mov	r3, r2
 8007d2a:	00db      	lsls	r3, r3, #3
 8007d2c:	1a9b      	subs	r3, r3, r2
 8007d2e:	009b      	lsls	r3, r3, #2
 8007d30:	440b      	add	r3, r1
 8007d32:	333e      	adds	r3, #62	; 0x3e
 8007d34:	781b      	ldrb	r3, [r3, #0]
 8007d36:	e00b      	b.n	8007d50 <USBD_LL_IsStallEP+0x4c>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 8007d38:	78fb      	ldrb	r3, [r7, #3]
 8007d3a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8007d3e:	68f9      	ldr	r1, [r7, #12]
 8007d40:	4613      	mov	r3, r2
 8007d42:	00db      	lsls	r3, r3, #3
 8007d44:	1a9b      	subs	r3, r3, r2
 8007d46:	009b      	lsls	r3, r3, #2
 8007d48:	440b      	add	r3, r1
 8007d4a:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
 8007d4e:	781b      	ldrb	r3, [r3, #0]
  }
}
 8007d50:	4618      	mov	r0, r3
 8007d52:	3714      	adds	r7, #20
 8007d54:	46bd      	mov	sp, r7
 8007d56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d5a:	4770      	bx	lr

08007d5c <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8007d5c:	b580      	push	{r7, lr}
 8007d5e:	b084      	sub	sp, #16
 8007d60:	af00      	add	r7, sp, #0
 8007d62:	6078      	str	r0, [r7, #4]
 8007d64:	460b      	mov	r3, r1
 8007d66:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8007d68:	2300      	movs	r3, #0
 8007d6a:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8007d6c:	2300      	movs	r3, #0
 8007d6e:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 8007d70:	687b      	ldr	r3, [r7, #4]
 8007d72:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8007d76:	78fa      	ldrb	r2, [r7, #3]
 8007d78:	4611      	mov	r1, r2
 8007d7a:	4618      	mov	r0, r3
 8007d7c:	f7fb f871 	bl	8002e62 <HAL_PCD_SetAddress>
 8007d80:	4603      	mov	r3, r0
 8007d82:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8007d84:	7bfb      	ldrb	r3, [r7, #15]
 8007d86:	4618      	mov	r0, r3
 8007d88:	f000 f85c 	bl	8007e44 <USBD_Get_USB_Status>
 8007d8c:	4603      	mov	r3, r0
 8007d8e:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 8007d90:	7bbb      	ldrb	r3, [r7, #14]
}
 8007d92:	4618      	mov	r0, r3
 8007d94:	3710      	adds	r7, #16
 8007d96:	46bd      	mov	sp, r7
 8007d98:	bd80      	pop	{r7, pc}

08007d9a <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 8007d9a:	b580      	push	{r7, lr}
 8007d9c:	b086      	sub	sp, #24
 8007d9e:	af00      	add	r7, sp, #0
 8007da0:	60f8      	str	r0, [r7, #12]
 8007da2:	607a      	str	r2, [r7, #4]
 8007da4:	603b      	str	r3, [r7, #0]
 8007da6:	460b      	mov	r3, r1
 8007da8:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8007daa:	2300      	movs	r3, #0
 8007dac:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8007dae:	2300      	movs	r3, #0
 8007db0:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8007db2:	68fb      	ldr	r3, [r7, #12]
 8007db4:	f8d3 02c4 	ldr.w	r0, [r3, #708]	; 0x2c4
 8007db8:	7af9      	ldrb	r1, [r7, #11]
 8007dba:	683b      	ldr	r3, [r7, #0]
 8007dbc:	687a      	ldr	r2, [r7, #4]
 8007dbe:	f7fb f98a 	bl	80030d6 <HAL_PCD_EP_Transmit>
 8007dc2:	4603      	mov	r3, r0
 8007dc4:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8007dc6:	7dfb      	ldrb	r3, [r7, #23]
 8007dc8:	4618      	mov	r0, r3
 8007dca:	f000 f83b 	bl	8007e44 <USBD_Get_USB_Status>
 8007dce:	4603      	mov	r3, r0
 8007dd0:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 8007dd2:	7dbb      	ldrb	r3, [r7, #22]
}
 8007dd4:	4618      	mov	r0, r3
 8007dd6:	3718      	adds	r7, #24
 8007dd8:	46bd      	mov	sp, r7
 8007dda:	bd80      	pop	{r7, pc}

08007ddc <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 8007ddc:	b580      	push	{r7, lr}
 8007dde:	b086      	sub	sp, #24
 8007de0:	af00      	add	r7, sp, #0
 8007de2:	60f8      	str	r0, [r7, #12]
 8007de4:	607a      	str	r2, [r7, #4]
 8007de6:	603b      	str	r3, [r7, #0]
 8007de8:	460b      	mov	r3, r1
 8007dea:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 8007dec:	2300      	movs	r3, #0
 8007dee:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8007df0:	2300      	movs	r3, #0
 8007df2:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8007df4:	68fb      	ldr	r3, [r7, #12]
 8007df6:	f8d3 02c4 	ldr.w	r0, [r3, #708]	; 0x2c4
 8007dfa:	7af9      	ldrb	r1, [r7, #11]
 8007dfc:	683b      	ldr	r3, [r7, #0]
 8007dfe:	687a      	ldr	r2, [r7, #4]
 8007e00:	f7fb f906 	bl	8003010 <HAL_PCD_EP_Receive>
 8007e04:	4603      	mov	r3, r0
 8007e06:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 8007e08:	7dfb      	ldrb	r3, [r7, #23]
 8007e0a:	4618      	mov	r0, r3
 8007e0c:	f000 f81a 	bl	8007e44 <USBD_Get_USB_Status>
 8007e10:	4603      	mov	r3, r0
 8007e12:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 8007e14:	7dbb      	ldrb	r3, [r7, #22]
}
 8007e16:	4618      	mov	r0, r3
 8007e18:	3718      	adds	r7, #24
 8007e1a:	46bd      	mov	sp, r7
 8007e1c:	bd80      	pop	{r7, pc}

08007e1e <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Recived Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 8007e1e:	b580      	push	{r7, lr}
 8007e20:	b082      	sub	sp, #8
 8007e22:	af00      	add	r7, sp, #0
 8007e24:	6078      	str	r0, [r7, #4]
 8007e26:	460b      	mov	r3, r1
 8007e28:	70fb      	strb	r3, [r7, #3]
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 8007e2a:	687b      	ldr	r3, [r7, #4]
 8007e2c:	f8d3 32c4 	ldr.w	r3, [r3, #708]	; 0x2c4
 8007e30:	78fa      	ldrb	r2, [r7, #3]
 8007e32:	4611      	mov	r1, r2
 8007e34:	4618      	mov	r0, r3
 8007e36:	f7fb f936 	bl	80030a6 <HAL_PCD_EP_GetRxCount>
 8007e3a:	4603      	mov	r3, r0
}
 8007e3c:	4618      	mov	r0, r3
 8007e3e:	3708      	adds	r7, #8
 8007e40:	46bd      	mov	sp, r7
 8007e42:	bd80      	pop	{r7, pc}

08007e44 <USBD_Get_USB_Status>:
  * @brief  Retuns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 8007e44:	b480      	push	{r7}
 8007e46:	b085      	sub	sp, #20
 8007e48:	af00      	add	r7, sp, #0
 8007e4a:	4603      	mov	r3, r0
 8007e4c:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef usb_status = USBD_OK;
 8007e4e:	2300      	movs	r3, #0
 8007e50:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 8007e52:	79fb      	ldrb	r3, [r7, #7]
 8007e54:	2b03      	cmp	r3, #3
 8007e56:	d817      	bhi.n	8007e88 <USBD_Get_USB_Status+0x44>
 8007e58:	a201      	add	r2, pc, #4	; (adr r2, 8007e60 <USBD_Get_USB_Status+0x1c>)
 8007e5a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007e5e:	bf00      	nop
 8007e60:	08007e71 	.word	0x08007e71
 8007e64:	08007e77 	.word	0x08007e77
 8007e68:	08007e7d 	.word	0x08007e7d
 8007e6c:	08007e83 	.word	0x08007e83
  {
    case HAL_OK :
      usb_status = USBD_OK;
 8007e70:	2300      	movs	r3, #0
 8007e72:	73fb      	strb	r3, [r7, #15]
    break;
 8007e74:	e00b      	b.n	8007e8e <USBD_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 8007e76:	2303      	movs	r3, #3
 8007e78:	73fb      	strb	r3, [r7, #15]
    break;
 8007e7a:	e008      	b.n	8007e8e <USBD_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBD_BUSY;
 8007e7c:	2301      	movs	r3, #1
 8007e7e:	73fb      	strb	r3, [r7, #15]
    break;
 8007e80:	e005      	b.n	8007e8e <USBD_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBD_FAIL;
 8007e82:	2303      	movs	r3, #3
 8007e84:	73fb      	strb	r3, [r7, #15]
    break;
 8007e86:	e002      	b.n	8007e8e <USBD_Get_USB_Status+0x4a>
    default :
      usb_status = USBD_FAIL;
 8007e88:	2303      	movs	r3, #3
 8007e8a:	73fb      	strb	r3, [r7, #15]
    break;
 8007e8c:	bf00      	nop
  }
  return usb_status;
 8007e8e:	7bfb      	ldrb	r3, [r7, #15]
}
 8007e90:	4618      	mov	r0, r3
 8007e92:	3714      	adds	r7, #20
 8007e94:	46bd      	mov	sp, r7
 8007e96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e9a:	4770      	bx	lr

08007e9c <lv_disp_get_scr_act>:
 * @param disp pointer to display which active screen should be get. (NULL to use the default
 * screen)
 * @return pointer to the active screen object (loaded by 'lv_scr_load()')
 */
lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)
{
 8007e9c:	b580      	push	{r7, lr}
 8007e9e:	b082      	sub	sp, #8
 8007ea0:	af00      	add	r7, sp, #0
 8007ea2:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 8007ea4:	687b      	ldr	r3, [r7, #4]
 8007ea6:	2b00      	cmp	r3, #0
 8007ea8:	d102      	bne.n	8007eb0 <lv_disp_get_scr_act+0x14>
 8007eaa:	f016 fde3 	bl	801ea74 <lv_disp_get_default>
 8007eae:	6078      	str	r0, [r7, #4]
    if(!disp) {
 8007eb0:	687b      	ldr	r3, [r7, #4]
 8007eb2:	2b00      	cmp	r3, #0
 8007eb4:	d101      	bne.n	8007eba <lv_disp_get_scr_act+0x1e>
        LV_LOG_WARN("no display registered to get its active screen");
        return NULL;
 8007eb6:	2300      	movs	r3, #0
 8007eb8:	e001      	b.n	8007ebe <lv_disp_get_scr_act+0x22>
    }

    return disp->act_scr;
 8007eba:	687b      	ldr	r3, [r7, #4]
 8007ebc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
}
 8007ebe:	4618      	mov	r0, r3
 8007ec0:	3708      	adds	r7, #8
 8007ec2:	46bd      	mov	sp, r7
 8007ec4:	bd80      	pop	{r7, pc}

08007ec6 <lv_disp_get_scr_prev>:
 * @param disp pointer to display which previous screen should be get. (NULL to use the default
 * screen)
 * @return pointer to the previous screen object or NULL if not used now
 */
lv_obj_t * lv_disp_get_scr_prev(lv_disp_t * disp)
{
 8007ec6:	b580      	push	{r7, lr}
 8007ec8:	b082      	sub	sp, #8
 8007eca:	af00      	add	r7, sp, #0
 8007ecc:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 8007ece:	687b      	ldr	r3, [r7, #4]
 8007ed0:	2b00      	cmp	r3, #0
 8007ed2:	d102      	bne.n	8007eda <lv_disp_get_scr_prev+0x14>
 8007ed4:	f016 fdce 	bl	801ea74 <lv_disp_get_default>
 8007ed8:	6078      	str	r0, [r7, #4]
    if(!disp) {
 8007eda:	687b      	ldr	r3, [r7, #4]
 8007edc:	2b00      	cmp	r3, #0
 8007ede:	d101      	bne.n	8007ee4 <lv_disp_get_scr_prev+0x1e>
        LV_LOG_WARN("no display registered to get its previous screen");
        return NULL;
 8007ee0:	2300      	movs	r3, #0
 8007ee2:	e001      	b.n	8007ee8 <lv_disp_get_scr_prev+0x22>
    }

    return disp->prev_scr;
 8007ee4:	687b      	ldr	r3, [r7, #4]
 8007ee6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
}
 8007ee8:	4618      	mov	r0, r3
 8007eea:	3708      	adds	r7, #8
 8007eec:	46bd      	mov	sp, r7
 8007eee:	bd80      	pop	{r7, pc}

08007ef0 <lv_disp_get_layer_top>:
 * Return with the top layer. (Same on every screen and it is above the normal screen layer)
 * @param disp pointer to display which top layer should be get. (NULL to use the default screen)
 * @return pointer to the top layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)
{
 8007ef0:	b580      	push	{r7, lr}
 8007ef2:	b082      	sub	sp, #8
 8007ef4:	af00      	add	r7, sp, #0
 8007ef6:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 8007ef8:	687b      	ldr	r3, [r7, #4]
 8007efa:	2b00      	cmp	r3, #0
 8007efc:	d102      	bne.n	8007f04 <lv_disp_get_layer_top+0x14>
 8007efe:	f016 fdb9 	bl	801ea74 <lv_disp_get_default>
 8007f02:	6078      	str	r0, [r7, #4]
    if(!disp) {
 8007f04:	687b      	ldr	r3, [r7, #4]
 8007f06:	2b00      	cmp	r3, #0
 8007f08:	d101      	bne.n	8007f0e <lv_disp_get_layer_top+0x1e>
        LV_LOG_WARN("lv_layer_top: no display registered to get its top layer");
        return NULL;
 8007f0a:	2300      	movs	r3, #0
 8007f0c:	e001      	b.n	8007f12 <lv_disp_get_layer_top+0x22>
    }

    return disp->top_layer;
 8007f0e:	687b      	ldr	r3, [r7, #4]
 8007f10:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
 8007f12:	4618      	mov	r0, r3
 8007f14:	3708      	adds	r7, #8
 8007f16:	46bd      	mov	sp, r7
 8007f18:	bd80      	pop	{r7, pc}

08007f1a <lv_disp_get_layer_sys>:
 * layer)
 * @param disp pointer to display which sys. layer  should be get. (NULL to use the default screen)
 * @return pointer to the sys layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)
{
 8007f1a:	b580      	push	{r7, lr}
 8007f1c:	b082      	sub	sp, #8
 8007f1e:	af00      	add	r7, sp, #0
 8007f20:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 8007f22:	687b      	ldr	r3, [r7, #4]
 8007f24:	2b00      	cmp	r3, #0
 8007f26:	d102      	bne.n	8007f2e <lv_disp_get_layer_sys+0x14>
 8007f28:	f016 fda4 	bl	801ea74 <lv_disp_get_default>
 8007f2c:	6078      	str	r0, [r7, #4]
    if(!disp) {
 8007f2e:	687b      	ldr	r3, [r7, #4]
 8007f30:	2b00      	cmp	r3, #0
 8007f32:	d101      	bne.n	8007f38 <lv_disp_get_layer_sys+0x1e>
        LV_LOG_WARN("lv_layer_sys: no display registered to get its sys. layer");
        return NULL;
 8007f34:	2300      	movs	r3, #0
 8007f36:	e001      	b.n	8007f3c <lv_disp_get_layer_sys+0x22>
    }

    return disp->sys_layer;
 8007f38:	687b      	ldr	r3, [r7, #4]
 8007f3a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
 8007f3c:	4618      	mov	r0, r3
 8007f3e:	3708      	adds	r7, #8
 8007f40:	46bd      	mov	sp, r7
 8007f42:	bd80      	pop	{r7, pc}

08007f44 <_lv_group_init>:

/**
 * Init. the group module
 */
void _lv_group_init(void)
{
 8007f44:	b580      	push	{r7, lr}
 8007f46:	af00      	add	r7, sp, #0
    _lv_ll_init(&LV_GC_ROOT(_lv_group_ll), sizeof(lv_group_t));
 8007f48:	2118      	movs	r1, #24
 8007f4a:	4802      	ldr	r0, [pc, #8]	; (8007f54 <_lv_group_init+0x10>)
 8007f4c:	f018 fb10 	bl	8020570 <_lv_ll_init>
}
 8007f50:	bf00      	nop
 8007f52:	bd80      	pop	{r7, pc}
 8007f54:	2000a1b0 	.word	0x2000a1b0

08007f58 <lv_group_add_obj>:
 * Add an object to a group
 * @param group pointer to a group
 * @param obj pointer to an object to add
 */
void lv_group_add_obj(lv_group_t * group, lv_obj_t * obj)
{
 8007f58:	b5b0      	push	{r4, r5, r7, lr}
 8007f5a:	b084      	sub	sp, #16
 8007f5c:	af00      	add	r7, sp, #0
 8007f5e:	6078      	str	r0, [r7, #4]
 8007f60:	6039      	str	r1, [r7, #0]
    if(group == NULL) return;
 8007f62:	687b      	ldr	r3, [r7, #4]
 8007f64:	2b00      	cmp	r3, #0
 8007f66:	d04f      	beq.n	8008008 <lv_group_add_obj+0xb0>
    /*Do not add the object twice*/
    lv_obj_t ** obj_i;
    _LV_LL_READ(group->obj_ll, obj_i) {
 8007f68:	687b      	ldr	r3, [r7, #4]
 8007f6a:	4618      	mov	r0, r3
 8007f6c:	f018 fc76 	bl	802085c <_lv_ll_get_head>
 8007f70:	60f8      	str	r0, [r7, #12]
 8007f72:	e00a      	b.n	8007f8a <lv_group_add_obj+0x32>
        if((*obj_i) == obj) {
 8007f74:	68fb      	ldr	r3, [r7, #12]
 8007f76:	681b      	ldr	r3, [r3, #0]
 8007f78:	683a      	ldr	r2, [r7, #0]
 8007f7a:	429a      	cmp	r2, r3
 8007f7c:	d046      	beq.n	800800c <lv_group_add_obj+0xb4>
    _LV_LL_READ(group->obj_ll, obj_i) {
 8007f7e:	687b      	ldr	r3, [r7, #4]
 8007f80:	68f9      	ldr	r1, [r7, #12]
 8007f82:	4618      	mov	r0, r3
 8007f84:	f018 fc90 	bl	80208a8 <_lv_ll_get_next>
 8007f88:	60f8      	str	r0, [r7, #12]
 8007f8a:	68fb      	ldr	r3, [r7, #12]
 8007f8c:	2b00      	cmp	r3, #0
 8007f8e:	d1f1      	bne.n	8007f74 <lv_group_add_obj+0x1c>
            return;
        }
    }

    /*If the object is already in a group and focused then defocus it*/
    if(obj->group_p) {
 8007f90:	683b      	ldr	r3, [r7, #0]
 8007f92:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007f94:	2b00      	cmp	r3, #0
 8007f96:	d00a      	beq.n	8007fae <lv_group_add_obj+0x56>
        if(lv_obj_is_focused(obj)) {
 8007f98:	6838      	ldr	r0, [r7, #0]
 8007f9a:	f003 fd99 	bl	800bad0 <lv_obj_is_focused>
 8007f9e:	4603      	mov	r3, r0
 8007fa0:	2b00      	cmp	r3, #0
 8007fa2:	d004      	beq.n	8007fae <lv_group_add_obj+0x56>
            lv_group_refocus(obj->group_p);
 8007fa4:	683b      	ldr	r3, [r7, #0]
 8007fa6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007fa8:	4618      	mov	r0, r3
 8007faa:	f000 f8fd 	bl	80081a8 <lv_group_refocus>

            LV_LOG_INFO("lv_group_add_obj: assign object to an other group");
        }
    }

    obj->group_p     = group;
 8007fae:	683b      	ldr	r3, [r7, #0]
 8007fb0:	687a      	ldr	r2, [r7, #4]
 8007fb2:	639a      	str	r2, [r3, #56]	; 0x38
    lv_obj_t ** next = _lv_ll_ins_tail(&group->obj_ll);
 8007fb4:	687b      	ldr	r3, [r7, #4]
 8007fb6:	4618      	mov	r0, r3
 8007fb8:	f018 fb6e 	bl	8020698 <_lv_ll_ins_tail>
 8007fbc:	60b8      	str	r0, [r7, #8]
    LV_ASSERT_MEM(next);
 8007fbe:	68b8      	ldr	r0, [r7, #8]
 8007fc0:	f018 f896 	bl	80200f0 <lv_debug_check_null>
 8007fc4:	4603      	mov	r3, r0
 8007fc6:	f083 0301 	eor.w	r3, r3, #1
 8007fca:	b2db      	uxtb	r3, r3
 8007fcc:	2b00      	cmp	r3, #0
 8007fce:	d009      	beq.n	8007fe4 <lv_group_add_obj+0x8c>
 8007fd0:	68bb      	ldr	r3, [r7, #8]
 8007fd2:	2200      	movs	r2, #0
 8007fd4:	461c      	mov	r4, r3
 8007fd6:	4615      	mov	r5, r2
 8007fd8:	4622      	mov	r2, r4
 8007fda:	462b      	mov	r3, r5
 8007fdc:	480e      	ldr	r0, [pc, #56]	; (8008018 <lv_group_add_obj+0xc0>)
 8007fde:	f018 f897 	bl	8020110 <lv_debug_log_error>
 8007fe2:	e7fe      	b.n	8007fe2 <lv_group_add_obj+0x8a>
    if(next == NULL) return;
 8007fe4:	68bb      	ldr	r3, [r7, #8]
 8007fe6:	2b00      	cmp	r3, #0
 8007fe8:	d012      	beq.n	8008010 <lv_group_add_obj+0xb8>
    *next = obj;
 8007fea:	68bb      	ldr	r3, [r7, #8]
 8007fec:	683a      	ldr	r2, [r7, #0]
 8007fee:	601a      	str	r2, [r3, #0]

    /* If the head and the tail is equal then there is only one object in the linked list.
     * In this case automatically activate it*/
    if(_lv_ll_get_head(&group->obj_ll) == next) {
 8007ff0:	687b      	ldr	r3, [r7, #4]
 8007ff2:	4618      	mov	r0, r3
 8007ff4:	f018 fc32 	bl	802085c <_lv_ll_get_head>
 8007ff8:	4602      	mov	r2, r0
 8007ffa:	68bb      	ldr	r3, [r7, #8]
 8007ffc:	4293      	cmp	r3, r2
 8007ffe:	d108      	bne.n	8008012 <lv_group_add_obj+0xba>
        lv_group_refocus(group);
 8008000:	6878      	ldr	r0, [r7, #4]
 8008002:	f000 f8d1 	bl	80081a8 <lv_group_refocus>
 8008006:	e004      	b.n	8008012 <lv_group_add_obj+0xba>
    if(group == NULL) return;
 8008008:	bf00      	nop
 800800a:	e002      	b.n	8008012 <lv_group_add_obj+0xba>
            return;
 800800c:	bf00      	nop
 800800e:	e000      	b.n	8008012 <lv_group_add_obj+0xba>
    if(next == NULL) return;
 8008010:	bf00      	nop
    }
}
 8008012:	3710      	adds	r7, #16
 8008014:	46bd      	mov	sp, r7
 8008016:	bdb0      	pop	{r4, r5, r7, pc}
 8008018:	0802e408 	.word	0x0802e408

0800801c <lv_group_remove_obj>:
/**
 * Remove an object from its group
 * @param obj pointer to an object to remove
 */
void lv_group_remove_obj(lv_obj_t * obj)
{
 800801c:	b580      	push	{r7, lr}
 800801e:	b084      	sub	sp, #16
 8008020:	af00      	add	r7, sp, #0
 8008022:	6078      	str	r0, [r7, #4]
    lv_group_t * g = obj->group_p;
 8008024:	687b      	ldr	r3, [r7, #4]
 8008026:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8008028:	60bb      	str	r3, [r7, #8]
    if(g == NULL) return;
 800802a:	68bb      	ldr	r3, [r7, #8]
 800802c:	2b00      	cmp	r3, #0
 800802e:	d05f      	beq.n	80080f0 <lv_group_remove_obj+0xd4>
    if(g->obj_focus == NULL) return; /*Just to be sure (Not possible if there is at least one object in the group)*/
 8008030:	68bb      	ldr	r3, [r7, #8]
 8008032:	68db      	ldr	r3, [r3, #12]
 8008034:	2b00      	cmp	r3, #0
 8008036:	d05d      	beq.n	80080f4 <lv_group_remove_obj+0xd8>

    /*Focus on the next object*/
    if(*g->obj_focus == obj) {
 8008038:	68bb      	ldr	r3, [r7, #8]
 800803a:	68db      	ldr	r3, [r3, #12]
 800803c:	681b      	ldr	r3, [r3, #0]
 800803e:	687a      	ldr	r2, [r7, #4]
 8008040:	429a      	cmp	r2, r3
 8008042:	d12b      	bne.n	800809c <lv_group_remove_obj+0x80>
        if(g->frozen) g->frozen = 0;
 8008044:	68bb      	ldr	r3, [r7, #8]
 8008046:	7d1b      	ldrb	r3, [r3, #20]
 8008048:	f003 0301 	and.w	r3, r3, #1
 800804c:	b2db      	uxtb	r3, r3
 800804e:	2b00      	cmp	r3, #0
 8008050:	d004      	beq.n	800805c <lv_group_remove_obj+0x40>
 8008052:	68ba      	ldr	r2, [r7, #8]
 8008054:	7d13      	ldrb	r3, [r2, #20]
 8008056:	f36f 0300 	bfc	r3, #0, #1
 800805a:	7513      	strb	r3, [r2, #20]

        /*If this is the only object in the group then focus to nothing.*/
        if(_lv_ll_get_head(&g->obj_ll) == g->obj_focus && _lv_ll_get_tail(&g->obj_ll) == g->obj_focus) {
 800805c:	68bb      	ldr	r3, [r7, #8]
 800805e:	4618      	mov	r0, r3
 8008060:	f018 fbfc 	bl	802085c <_lv_ll_get_head>
 8008064:	4602      	mov	r2, r0
 8008066:	68bb      	ldr	r3, [r7, #8]
 8008068:	68db      	ldr	r3, [r3, #12]
 800806a:	429a      	cmp	r2, r3
 800806c:	d113      	bne.n	8008096 <lv_group_remove_obj+0x7a>
 800806e:	68bb      	ldr	r3, [r7, #8]
 8008070:	4618      	mov	r0, r3
 8008072:	f018 fc06 	bl	8020882 <_lv_ll_get_tail>
 8008076:	4602      	mov	r2, r0
 8008078:	68bb      	ldr	r3, [r7, #8]
 800807a:	68db      	ldr	r3, [r3, #12]
 800807c:	429a      	cmp	r2, r3
 800807e:	d10a      	bne.n	8008096 <lv_group_remove_obj+0x7a>
            (*g->obj_focus)->signal_cb(*g->obj_focus, LV_SIGNAL_DEFOCUS, NULL);
 8008080:	68bb      	ldr	r3, [r7, #8]
 8008082:	68db      	ldr	r3, [r3, #12]
 8008084:	681b      	ldr	r3, [r3, #0]
 8008086:	69db      	ldr	r3, [r3, #28]
 8008088:	68ba      	ldr	r2, [r7, #8]
 800808a:	68d2      	ldr	r2, [r2, #12]
 800808c:	6810      	ldr	r0, [r2, #0]
 800808e:	2200      	movs	r2, #0
 8008090:	2117      	movs	r1, #23
 8008092:	4798      	blx	r3
 8008094:	e002      	b.n	800809c <lv_group_remove_obj+0x80>
        }
        /*If there more objects in the group then focus to the next/prev object*/
        else {
            lv_group_refocus(g);
 8008096:	68b8      	ldr	r0, [r7, #8]
 8008098:	f000 f886 	bl	80081a8 <lv_group_refocus>
    }

    /* If the focuses object is still the same then it was the only object in the group but it will
     * be deleted. Set the `obj_focus` to NULL to get back to the initial state of the group with
     * zero objects*/
    if(*g->obj_focus == obj) {
 800809c:	68bb      	ldr	r3, [r7, #8]
 800809e:	68db      	ldr	r3, [r3, #12]
 80080a0:	681b      	ldr	r3, [r3, #0]
 80080a2:	687a      	ldr	r2, [r7, #4]
 80080a4:	429a      	cmp	r2, r3
 80080a6:	d102      	bne.n	80080ae <lv_group_remove_obj+0x92>
        g->obj_focus = NULL;
 80080a8:	68bb      	ldr	r3, [r7, #8]
 80080aa:	2200      	movs	r2, #0
 80080ac:	60da      	str	r2, [r3, #12]
    }

    /*Search the object and remove it from its group */
    lv_obj_t ** i;
    _LV_LL_READ(g->obj_ll, i) {
 80080ae:	68bb      	ldr	r3, [r7, #8]
 80080b0:	4618      	mov	r0, r3
 80080b2:	f018 fbd3 	bl	802085c <_lv_ll_get_head>
 80080b6:	60f8      	str	r0, [r7, #12]
 80080b8:	e016      	b.n	80080e8 <lv_group_remove_obj+0xcc>
        if(*i == obj) {
 80080ba:	68fb      	ldr	r3, [r7, #12]
 80080bc:	681b      	ldr	r3, [r3, #0]
 80080be:	687a      	ldr	r2, [r7, #4]
 80080c0:	429a      	cmp	r2, r3
 80080c2:	d10b      	bne.n	80080dc <lv_group_remove_obj+0xc0>
            _lv_ll_remove(&g->obj_ll, i);
 80080c4:	68bb      	ldr	r3, [r7, #8]
 80080c6:	68f9      	ldr	r1, [r7, #12]
 80080c8:	4618      	mov	r0, r3
 80080ca:	f018 fb19 	bl	8020700 <_lv_ll_remove>
            lv_mem_free(i);
 80080ce:	68f8      	ldr	r0, [r7, #12]
 80080d0:	f018 fdca 	bl	8020c68 <lv_mem_free>
            obj->group_p = NULL;
 80080d4:	687b      	ldr	r3, [r7, #4]
 80080d6:	2200      	movs	r2, #0
 80080d8:	639a      	str	r2, [r3, #56]	; 0x38
            break;
 80080da:	e00c      	b.n	80080f6 <lv_group_remove_obj+0xda>
    _LV_LL_READ(g->obj_ll, i) {
 80080dc:	68bb      	ldr	r3, [r7, #8]
 80080de:	68f9      	ldr	r1, [r7, #12]
 80080e0:	4618      	mov	r0, r3
 80080e2:	f018 fbe1 	bl	80208a8 <_lv_ll_get_next>
 80080e6:	60f8      	str	r0, [r7, #12]
 80080e8:	68fb      	ldr	r3, [r7, #12]
 80080ea:	2b00      	cmp	r3, #0
 80080ec:	d1e5      	bne.n	80080ba <lv_group_remove_obj+0x9e>
 80080ee:	e002      	b.n	80080f6 <lv_group_remove_obj+0xda>
    if(g == NULL) return;
 80080f0:	bf00      	nop
 80080f2:	e000      	b.n	80080f6 <lv_group_remove_obj+0xda>
    if(g->obj_focus == NULL) return; /*Just to be sure (Not possible if there is at least one object in the group)*/
 80080f4:	bf00      	nop
        }
    }
}
 80080f6:	3710      	adds	r7, #16
 80080f8:	46bd      	mov	sp, r7
 80080fa:	bd80      	pop	{r7, pc}

080080fc <lv_group_focus_next>:
/**
 * Focus the next object in a group (defocus the current)
 * @param group pointer to a group
 */
void lv_group_focus_next(lv_group_t * group)
{
 80080fc:	b580      	push	{r7, lr}
 80080fe:	b082      	sub	sp, #8
 8008100:	af00      	add	r7, sp, #0
 8008102:	6078      	str	r0, [r7, #4]
    focus_next_core(group, _lv_ll_get_head, _lv_ll_get_next);
 8008104:	4a04      	ldr	r2, [pc, #16]	; (8008118 <lv_group_focus_next+0x1c>)
 8008106:	4905      	ldr	r1, [pc, #20]	; (800811c <lv_group_focus_next+0x20>)
 8008108:	6878      	ldr	r0, [r7, #4]
 800810a:	f000 f87e 	bl	800820a <focus_next_core>
}
 800810e:	bf00      	nop
 8008110:	3708      	adds	r7, #8
 8008112:	46bd      	mov	sp, r7
 8008114:	bd80      	pop	{r7, pc}
 8008116:	bf00      	nop
 8008118:	080208a9 	.word	0x080208a9
 800811c:	0802085d 	.word	0x0802085d

08008120 <lv_group_focus_prev>:
/**
 * Focus the previous object in a group (defocus the current)
 * @param group pointer to a group
 */
void lv_group_focus_prev(lv_group_t * group)
{
 8008120:	b580      	push	{r7, lr}
 8008122:	b082      	sub	sp, #8
 8008124:	af00      	add	r7, sp, #0
 8008126:	6078      	str	r0, [r7, #4]
    focus_next_core(group, _lv_ll_get_tail, _lv_ll_get_prev);
 8008128:	4a04      	ldr	r2, [pc, #16]	; (800813c <lv_group_focus_prev+0x1c>)
 800812a:	4905      	ldr	r1, [pc, #20]	; (8008140 <lv_group_focus_prev+0x20>)
 800812c:	6878      	ldr	r0, [r7, #4]
 800812e:	f000 f86c 	bl	800820a <focus_next_core>
}
 8008132:	bf00      	nop
 8008134:	3708      	adds	r7, #8
 8008136:	46bd      	mov	sp, r7
 8008138:	bd80      	pop	{r7, pc}
 800813a:	bf00      	nop
 800813c:	080208dd 	.word	0x080208dd
 8008140:	08020883 	.word	0x08020883

08008144 <lv_group_get_focused>:
 * Get the focused object or NULL if there isn't one
 * @param group pointer to a group
 * @return pointer to the focused object
 */
lv_obj_t * lv_group_get_focused(const lv_group_t * group)
{
 8008144:	b480      	push	{r7}
 8008146:	b083      	sub	sp, #12
 8008148:	af00      	add	r7, sp, #0
 800814a:	6078      	str	r0, [r7, #4]
    if(!group) return NULL;
 800814c:	687b      	ldr	r3, [r7, #4]
 800814e:	2b00      	cmp	r3, #0
 8008150:	d101      	bne.n	8008156 <lv_group_get_focused+0x12>
 8008152:	2300      	movs	r3, #0
 8008154:	e008      	b.n	8008168 <lv_group_get_focused+0x24>
    if(group->obj_focus == NULL) return NULL;
 8008156:	687b      	ldr	r3, [r7, #4]
 8008158:	68db      	ldr	r3, [r3, #12]
 800815a:	2b00      	cmp	r3, #0
 800815c:	d101      	bne.n	8008162 <lv_group_get_focused+0x1e>
 800815e:	2300      	movs	r3, #0
 8008160:	e002      	b.n	8008168 <lv_group_get_focused+0x24>

    return *group->obj_focus;
 8008162:	687b      	ldr	r3, [r7, #4]
 8008164:	68db      	ldr	r3, [r3, #12]
 8008166:	681b      	ldr	r3, [r3, #0]
}
 8008168:	4618      	mov	r0, r3
 800816a:	370c      	adds	r7, #12
 800816c:	46bd      	mov	sp, r7
 800816e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008172:	4770      	bx	lr

08008174 <lv_group_get_editing>:
 * Get the current mode (edit or navigate).
 * @param group pointer to group
 * @return true: edit mode; false: navigate mode
 */
bool lv_group_get_editing(const lv_group_t * group)
{
 8008174:	b480      	push	{r7}
 8008176:	b083      	sub	sp, #12
 8008178:	af00      	add	r7, sp, #0
 800817a:	6078      	str	r0, [r7, #4]
    if(!group) return false;
 800817c:	687b      	ldr	r3, [r7, #4]
 800817e:	2b00      	cmp	r3, #0
 8008180:	d101      	bne.n	8008186 <lv_group_get_editing+0x12>
 8008182:	2300      	movs	r3, #0
 8008184:	e00a      	b.n	800819c <lv_group_get_editing+0x28>
    return group->editing ? true : false;
 8008186:	687b      	ldr	r3, [r7, #4]
 8008188:	7d1b      	ldrb	r3, [r3, #20]
 800818a:	085b      	lsrs	r3, r3, #1
 800818c:	b2db      	uxtb	r3, r3
 800818e:	f003 0301 	and.w	r3, r3, #1
 8008192:	2b00      	cmp	r3, #0
 8008194:	bf14      	ite	ne
 8008196:	2301      	movne	r3, #1
 8008198:	2300      	moveq	r3, #0
 800819a:	b2db      	uxtb	r3, r3
}
 800819c:	4618      	mov	r0, r3
 800819e:	370c      	adds	r7, #12
 80081a0:	46bd      	mov	sp, r7
 80081a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081a6:	4770      	bx	lr

080081a8 <lv_group_refocus>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void lv_group_refocus(lv_group_t * g)
{
 80081a8:	b580      	push	{r7, lr}
 80081aa:	b084      	sub	sp, #16
 80081ac:	af00      	add	r7, sp, #0
 80081ae:	6078      	str	r0, [r7, #4]
    /*Refocus must temporarily allow wrapping to work correctly*/
    uint8_t temp_wrap = g->wrap;
 80081b0:	687b      	ldr	r3, [r7, #4]
 80081b2:	7d1b      	ldrb	r3, [r3, #20]
 80081b4:	f3c3 1300 	ubfx	r3, r3, #4, #1
 80081b8:	b2db      	uxtb	r3, r3
 80081ba:	73fb      	strb	r3, [r7, #15]
    g->wrap           = 1;
 80081bc:	687a      	ldr	r2, [r7, #4]
 80081be:	7d13      	ldrb	r3, [r2, #20]
 80081c0:	f043 0310 	orr.w	r3, r3, #16
 80081c4:	7513      	strb	r3, [r2, #20]

    if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_NEXT)
 80081c6:	687b      	ldr	r3, [r7, #4]
 80081c8:	7d1b      	ldrb	r3, [r3, #20]
 80081ca:	f003 0308 	and.w	r3, r3, #8
 80081ce:	b2db      	uxtb	r3, r3
 80081d0:	2b00      	cmp	r3, #0
 80081d2:	d103      	bne.n	80081dc <lv_group_refocus+0x34>
        lv_group_focus_next(g);
 80081d4:	6878      	ldr	r0, [r7, #4]
 80081d6:	f7ff ff91 	bl	80080fc <lv_group_focus_next>
 80081da:	e009      	b.n	80081f0 <lv_group_refocus+0x48>
    else if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_PREV)
 80081dc:	687b      	ldr	r3, [r7, #4]
 80081de:	7d1b      	ldrb	r3, [r3, #20]
 80081e0:	f003 0308 	and.w	r3, r3, #8
 80081e4:	b2db      	uxtb	r3, r3
 80081e6:	2b00      	cmp	r3, #0
 80081e8:	d002      	beq.n	80081f0 <lv_group_refocus+0x48>
        lv_group_focus_prev(g);
 80081ea:	6878      	ldr	r0, [r7, #4]
 80081ec:	f7ff ff98 	bl	8008120 <lv_group_focus_prev>
    /*Restore wrap property*/
    g->wrap = temp_wrap;
 80081f0:	7bfb      	ldrb	r3, [r7, #15]
 80081f2:	f003 0301 	and.w	r3, r3, #1
 80081f6:	b2d9      	uxtb	r1, r3
 80081f8:	687a      	ldr	r2, [r7, #4]
 80081fa:	7d13      	ldrb	r3, [r2, #20]
 80081fc:	f361 1304 	bfi	r3, r1, #4, #1
 8008200:	7513      	strb	r3, [r2, #20]
}
 8008202:	bf00      	nop
 8008204:	3710      	adds	r7, #16
 8008206:	46bd      	mov	sp, r7
 8008208:	bd80      	pop	{r7, pc}

0800820a <focus_next_core>:

static void focus_next_core(lv_group_t * group, void * (*begin)(const lv_ll_t *),
                            void * (*move)(const lv_ll_t *, const void *))
{
 800820a:	b580      	push	{r7, lr}
 800820c:	b088      	sub	sp, #32
 800820e:	af00      	add	r7, sp, #0
 8008210:	60f8      	str	r0, [r7, #12]
 8008212:	60b9      	str	r1, [r7, #8]
 8008214:	607a      	str	r2, [r7, #4]
    if(group->frozen) return;
 8008216:	68fb      	ldr	r3, [r7, #12]
 8008218:	7d1b      	ldrb	r3, [r3, #20]
 800821a:	f003 0301 	and.w	r3, r3, #1
 800821e:	b2db      	uxtb	r3, r3
 8008220:	2b00      	cmp	r3, #0
 8008222:	f040 80a5 	bne.w	8008370 <focus_next_core+0x166>

    lv_obj_t ** obj_next     = group->obj_focus;
 8008226:	68fb      	ldr	r3, [r7, #12]
 8008228:	68db      	ldr	r3, [r3, #12]
 800822a:	61fb      	str	r3, [r7, #28]
    lv_obj_t ** obj_sentinel = NULL;
 800822c:	2300      	movs	r3, #0
 800822e:	61bb      	str	r3, [r7, #24]
    bool can_move            = true;
 8008230:	2301      	movs	r3, #1
 8008232:	75fb      	strb	r3, [r7, #23]
    bool can_begin           = true;
 8008234:	2301      	movs	r3, #1
 8008236:	75bb      	strb	r3, [r7, #22]

    for(;;) {
        if(obj_next == NULL) {
 8008238:	69fb      	ldr	r3, [r7, #28]
 800823a:	2b00      	cmp	r3, #0
 800823c:	d11a      	bne.n	8008274 <focus_next_core+0x6a>
            if(group->wrap || obj_sentinel == NULL) {
 800823e:	68fb      	ldr	r3, [r7, #12]
 8008240:	7d1b      	ldrb	r3, [r3, #20]
 8008242:	f003 0310 	and.w	r3, r3, #16
 8008246:	b2db      	uxtb	r3, r3
 8008248:	2b00      	cmp	r3, #0
 800824a:	d103      	bne.n	8008254 <focus_next_core+0x4a>
 800824c:	69bb      	ldr	r3, [r7, #24]
 800824e:	2b00      	cmp	r3, #0
 8008250:	f040 8090 	bne.w	8008374 <focus_next_core+0x16a>
                if(!can_begin) return;
 8008254:	7dbb      	ldrb	r3, [r7, #22]
 8008256:	f083 0301 	eor.w	r3, r3, #1
 800825a:	b2db      	uxtb	r3, r3
 800825c:	2b00      	cmp	r3, #0
 800825e:	f040 808b 	bne.w	8008378 <focus_next_core+0x16e>
                obj_next  = begin(&group->obj_ll);
 8008262:	68fa      	ldr	r2, [r7, #12]
 8008264:	68bb      	ldr	r3, [r7, #8]
 8008266:	4610      	mov	r0, r2
 8008268:	4798      	blx	r3
 800826a:	61f8      	str	r0, [r7, #28]
                can_move  = false;
 800826c:	2300      	movs	r3, #0
 800826e:	75fb      	strb	r3, [r7, #23]
                can_begin = false;
 8008270:	2300      	movs	r3, #0
 8008272:	75bb      	strb	r3, [r7, #22]
                /*Currently focused object is the last/first in the group, keep it that way*/
                return;
            }
        }

        if(obj_sentinel == NULL) {
 8008274:	69bb      	ldr	r3, [r7, #24]
 8008276:	2b00      	cmp	r3, #0
 8008278:	d104      	bne.n	8008284 <focus_next_core+0x7a>
            obj_sentinel = obj_next;
 800827a:	69fb      	ldr	r3, [r7, #28]
 800827c:	61bb      	str	r3, [r7, #24]
            if(obj_sentinel == NULL) return; /*Group is empty*/
 800827e:	69bb      	ldr	r3, [r7, #24]
 8008280:	2b00      	cmp	r3, #0
 8008282:	d07b      	beq.n	800837c <focus_next_core+0x172>
        }

        if(can_move) {
 8008284:	7dfb      	ldrb	r3, [r7, #23]
 8008286:	2b00      	cmp	r3, #0
 8008288:	d009      	beq.n	800829e <focus_next_core+0x94>
            obj_next = move(&group->obj_ll, obj_next);
 800828a:	68fa      	ldr	r2, [r7, #12]
 800828c:	687b      	ldr	r3, [r7, #4]
 800828e:	69f9      	ldr	r1, [r7, #28]
 8008290:	4610      	mov	r0, r2
 8008292:	4798      	blx	r3
 8008294:	61f8      	str	r0, [r7, #28]

            /*Give up if we walked the entire list and haven't found another visible object*/
            if(obj_next == obj_sentinel) return;
 8008296:	69fa      	ldr	r2, [r7, #28]
 8008298:	69bb      	ldr	r3, [r7, #24]
 800829a:	429a      	cmp	r2, r3
 800829c:	d070      	beq.n	8008380 <focus_next_core+0x176>
        }

        can_move = true;
 800829e:	2301      	movs	r3, #1
 80082a0:	75fb      	strb	r3, [r7, #23]

        if(obj_next == NULL) continue;
 80082a2:	69fb      	ldr	r3, [r7, #28]
 80082a4:	2b00      	cmp	r3, #0
 80082a6:	d00b      	beq.n	80082c0 <focus_next_core+0xb6>

        /*Hidden objects don't receive focus*/
        if(!lv_obj_get_hidden(*obj_next)) break;
 80082a8:	69fb      	ldr	r3, [r7, #28]
 80082aa:	681b      	ldr	r3, [r3, #0]
 80082ac:	4618      	mov	r0, r3
 80082ae:	f003 fad7 	bl	800b860 <lv_obj_get_hidden>
 80082b2:	4603      	mov	r3, r0
 80082b4:	f083 0301 	eor.w	r3, r3, #1
 80082b8:	b2db      	uxtb	r3, r3
 80082ba:	2b00      	cmp	r3, #0
 80082bc:	d102      	bne.n	80082c4 <focus_next_core+0xba>
 80082be:	e7bb      	b.n	8008238 <focus_next_core+0x2e>
        if(obj_next == NULL) continue;
 80082c0:	bf00      	nop
        if(obj_next == NULL) {
 80082c2:	e7b9      	b.n	8008238 <focus_next_core+0x2e>
        if(!lv_obj_get_hidden(*obj_next)) break;
 80082c4:	bf00      	nop
    }

    if(obj_next == group->obj_focus) return; /*There's only one visible object and it's already focused*/
 80082c6:	68fb      	ldr	r3, [r7, #12]
 80082c8:	68db      	ldr	r3, [r3, #12]
 80082ca:	69fa      	ldr	r2, [r7, #28]
 80082cc:	429a      	cmp	r2, r3
 80082ce:	d059      	beq.n	8008384 <focus_next_core+0x17a>

    if(group->obj_focus) {
 80082d0:	68fb      	ldr	r3, [r7, #12]
 80082d2:	68db      	ldr	r3, [r3, #12]
 80082d4:	2b00      	cmp	r3, #0
 80082d6:	d01c      	beq.n	8008312 <focus_next_core+0x108>
        (*group->obj_focus)->signal_cb(*group->obj_focus, LV_SIGNAL_DEFOCUS, NULL);
 80082d8:	68fb      	ldr	r3, [r7, #12]
 80082da:	68db      	ldr	r3, [r3, #12]
 80082dc:	681b      	ldr	r3, [r3, #0]
 80082de:	69db      	ldr	r3, [r3, #28]
 80082e0:	68fa      	ldr	r2, [r7, #12]
 80082e2:	68d2      	ldr	r2, [r2, #12]
 80082e4:	6810      	ldr	r0, [r2, #0]
 80082e6:	2200      	movs	r2, #0
 80082e8:	2117      	movs	r1, #23
 80082ea:	4798      	blx	r3
        lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_DEFOCUSED, NULL);
 80082ec:	68fb      	ldr	r3, [r7, #12]
 80082ee:	68db      	ldr	r3, [r3, #12]
 80082f0:	681b      	ldr	r3, [r3, #0]
 80082f2:	2200      	movs	r2, #0
 80082f4:	210e      	movs	r1, #14
 80082f6:	4618      	mov	r0, r3
 80082f8:	f002 fb26 	bl	800a948 <lv_event_send>
 80082fc:	4603      	mov	r3, r0
 80082fe:	757b      	strb	r3, [r7, #21]
        if(res != LV_RES_OK) return;
 8008300:	7d7b      	ldrb	r3, [r7, #21]
 8008302:	2b01      	cmp	r3, #1
 8008304:	d140      	bne.n	8008388 <focus_next_core+0x17e>
        lv_obj_invalidate(*group->obj_focus);
 8008306:	68fb      	ldr	r3, [r7, #12]
 8008308:	68db      	ldr	r3, [r3, #12]
 800830a:	681b      	ldr	r3, [r3, #0]
 800830c:	4618      	mov	r0, r3
 800830e:	f001 fb77 	bl	8009a00 <lv_obj_invalidate>
    }

    group->obj_focus = obj_next;
 8008312:	68fb      	ldr	r3, [r7, #12]
 8008314:	69fa      	ldr	r2, [r7, #28]
 8008316:	60da      	str	r2, [r3, #12]

    (*group->obj_focus)->signal_cb(*group->obj_focus, LV_SIGNAL_FOCUS, NULL);
 8008318:	68fb      	ldr	r3, [r7, #12]
 800831a:	68db      	ldr	r3, [r3, #12]
 800831c:	681b      	ldr	r3, [r3, #0]
 800831e:	69db      	ldr	r3, [r3, #28]
 8008320:	68fa      	ldr	r2, [r7, #12]
 8008322:	68d2      	ldr	r2, [r2, #12]
 8008324:	6810      	ldr	r0, [r2, #0]
 8008326:	2200      	movs	r2, #0
 8008328:	2116      	movs	r1, #22
 800832a:	4798      	blx	r3
    lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_FOCUSED, NULL);
 800832c:	68fb      	ldr	r3, [r7, #12]
 800832e:	68db      	ldr	r3, [r3, #12]
 8008330:	681b      	ldr	r3, [r3, #0]
 8008332:	2200      	movs	r2, #0
 8008334:	210d      	movs	r1, #13
 8008336:	4618      	mov	r0, r3
 8008338:	f002 fb06 	bl	800a948 <lv_event_send>
 800833c:	4603      	mov	r3, r0
 800833e:	753b      	strb	r3, [r7, #20]
    if(res != LV_RES_OK) return;
 8008340:	7d3b      	ldrb	r3, [r7, #20]
 8008342:	2b01      	cmp	r3, #1
 8008344:	d122      	bne.n	800838c <focus_next_core+0x182>

    /*If the object or its parent has `top == true` bring it to the foreground*/
    obj_to_foreground(*group->obj_focus);
 8008346:	68fb      	ldr	r3, [r7, #12]
 8008348:	68db      	ldr	r3, [r3, #12]
 800834a:	681b      	ldr	r3, [r3, #0]
 800834c:	4618      	mov	r0, r3
 800834e:	f000 f821 	bl	8008394 <obj_to_foreground>

    lv_obj_invalidate(*group->obj_focus);
 8008352:	68fb      	ldr	r3, [r7, #12]
 8008354:	68db      	ldr	r3, [r3, #12]
 8008356:	681b      	ldr	r3, [r3, #0]
 8008358:	4618      	mov	r0, r3
 800835a:	f001 fb51 	bl	8009a00 <lv_obj_invalidate>

    if(group->focus_cb) group->focus_cb(group);
 800835e:	68fb      	ldr	r3, [r7, #12]
 8008360:	691b      	ldr	r3, [r3, #16]
 8008362:	2b00      	cmp	r3, #0
 8008364:	d013      	beq.n	800838e <focus_next_core+0x184>
 8008366:	68fb      	ldr	r3, [r7, #12]
 8008368:	691b      	ldr	r3, [r3, #16]
 800836a:	68f8      	ldr	r0, [r7, #12]
 800836c:	4798      	blx	r3
 800836e:	e00e      	b.n	800838e <focus_next_core+0x184>
    if(group->frozen) return;
 8008370:	bf00      	nop
 8008372:	e00c      	b.n	800838e <focus_next_core+0x184>
                return;
 8008374:	bf00      	nop
 8008376:	e00a      	b.n	800838e <focus_next_core+0x184>
                if(!can_begin) return;
 8008378:	bf00      	nop
 800837a:	e008      	b.n	800838e <focus_next_core+0x184>
            if(obj_sentinel == NULL) return; /*Group is empty*/
 800837c:	bf00      	nop
 800837e:	e006      	b.n	800838e <focus_next_core+0x184>
            if(obj_next == obj_sentinel) return;
 8008380:	bf00      	nop
 8008382:	e004      	b.n	800838e <focus_next_core+0x184>
    if(obj_next == group->obj_focus) return; /*There's only one visible object and it's already focused*/
 8008384:	bf00      	nop
 8008386:	e002      	b.n	800838e <focus_next_core+0x184>
        if(res != LV_RES_OK) return;
 8008388:	bf00      	nop
 800838a:	e000      	b.n	800838e <focus_next_core+0x184>
    if(res != LV_RES_OK) return;
 800838c:	bf00      	nop
}
 800838e:	3720      	adds	r7, #32
 8008390:	46bd      	mov	sp, r7
 8008392:	bd80      	pop	{r7, pc}

08008394 <obj_to_foreground>:

static void obj_to_foreground(lv_obj_t * obj)
{
 8008394:	b580      	push	{r7, lr}
 8008396:	b084      	sub	sp, #16
 8008398:	af00      	add	r7, sp, #0
 800839a:	6078      	str	r0, [r7, #4]
    /*Search for 'top' attribute*/
    lv_obj_t * i        = obj;
 800839c:	687b      	ldr	r3, [r7, #4]
 800839e:	60fb      	str	r3, [r7, #12]
    lv_obj_t * last_top = NULL;
 80083a0:	2300      	movs	r3, #0
 80083a2:	60bb      	str	r3, [r7, #8]
    while(i != NULL) {
 80083a4:	e00d      	b.n	80083c2 <obj_to_foreground+0x2e>
        if(i->top != 0) last_top = i;
 80083a6:	68fb      	ldr	r3, [r7, #12]
 80083a8:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80083ac:	f003 0320 	and.w	r3, r3, #32
 80083b0:	b2db      	uxtb	r3, r3
 80083b2:	2b00      	cmp	r3, #0
 80083b4:	d001      	beq.n	80083ba <obj_to_foreground+0x26>
 80083b6:	68fb      	ldr	r3, [r7, #12]
 80083b8:	60bb      	str	r3, [r7, #8]
        i = lv_obj_get_parent(i);
 80083ba:	68f8      	ldr	r0, [r7, #12]
 80083bc:	f002 fcac 	bl	800ad18 <lv_obj_get_parent>
 80083c0:	60f8      	str	r0, [r7, #12]
    while(i != NULL) {
 80083c2:	68fb      	ldr	r3, [r7, #12]
 80083c4:	2b00      	cmp	r3, #0
 80083c6:	d1ee      	bne.n	80083a6 <obj_to_foreground+0x12>
    }

    if(last_top != NULL) {
 80083c8:	68bb      	ldr	r3, [r7, #8]
 80083ca:	2b00      	cmp	r3, #0
 80083cc:	d002      	beq.n	80083d4 <obj_to_foreground+0x40>
        /*Move the last_top object to the foreground*/
        lv_obj_move_foreground(last_top);
 80083ce:	68b8      	ldr	r0, [r7, #8]
 80083d0:	f001 fbfe 	bl	8009bd0 <lv_obj_move_foreground>
    }
}
 80083d4:	bf00      	nop
 80083d6:	3710      	adds	r7, #16
 80083d8:	46bd      	mov	sp, r7
 80083da:	bd80      	pop	{r7, pc}

080083dc <_lv_indev_init>:

/**
 * Initialize the display input device subsystem
 */
void _lv_indev_init(void)
{
 80083dc:	b580      	push	{r7, lr}
 80083de:	af00      	add	r7, sp, #0
    lv_indev_reset(NULL, NULL); /*Reset all input devices*/
 80083e0:	2100      	movs	r1, #0
 80083e2:	2000      	movs	r0, #0
 80083e4:	f000 f80e 	bl	8008404 <lv_indev_reset>
}
 80083e8:	bf00      	nop
 80083ea:	bd80      	pop	{r7, pc}

080083ec <lv_indev_get_act>:
 * Get the currently processed input device. Can be used in action functions too.
 * @return pointer to the currently processed input device or NULL if no input device processing
 * right now
 */
lv_indev_t * lv_indev_get_act(void)
{
 80083ec:	b480      	push	{r7}
 80083ee:	af00      	add	r7, sp, #0
    return indev_act;
 80083f0:	4b03      	ldr	r3, [pc, #12]	; (8008400 <lv_indev_get_act+0x14>)
 80083f2:	681b      	ldr	r3, [r3, #0]
}
 80083f4:	4618      	mov	r0, r3
 80083f6:	46bd      	mov	sp, r7
 80083f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80083fc:	4770      	bx	lr
 80083fe:	bf00      	nop
 8008400:	200099e4 	.word	0x200099e4

08008404 <lv_indev_reset>:
 * Reset one or all input devices
 * @param indev pointer to an input device to reset or NULL to reset all of them
 * @param obj pointer to an object which triggers the reset.
 */
void lv_indev_reset(lv_indev_t * indev, lv_obj_t * obj)
{
 8008404:	b580      	push	{r7, lr}
 8008406:	b084      	sub	sp, #16
 8008408:	af00      	add	r7, sp, #0
 800840a:	6078      	str	r0, [r7, #4]
 800840c:	6039      	str	r1, [r7, #0]
    if(indev) {
 800840e:	687b      	ldr	r3, [r7, #4]
 8008410:	2b00      	cmp	r3, #0
 8008412:	d01a      	beq.n	800844a <lv_indev_reset+0x46>
        indev->proc.reset_query = 1;
 8008414:	687a      	ldr	r2, [r7, #4]
 8008416:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800841a:	f043 0302 	orr.w	r3, r3, #2
 800841e:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
        if(indev_act == indev) indev_obj_act = NULL;
 8008422:	4b1f      	ldr	r3, [pc, #124]	; (80084a0 <lv_indev_reset+0x9c>)
 8008424:	681b      	ldr	r3, [r3, #0]
 8008426:	687a      	ldr	r2, [r7, #4]
 8008428:	429a      	cmp	r2, r3
 800842a:	d102      	bne.n	8008432 <lv_indev_reset+0x2e>
 800842c:	4b1d      	ldr	r3, [pc, #116]	; (80084a4 <lv_indev_reset+0xa0>)
 800842e:	2200      	movs	r2, #0
 8008430:	601a      	str	r2, [r3, #0]
        if(obj == NULL || indev->proc.types.pointer.last_pressed == obj) {
 8008432:	683b      	ldr	r3, [r7, #0]
 8008434:	2b00      	cmp	r3, #0
 8008436:	d004      	beq.n	8008442 <lv_indev_reset+0x3e>
 8008438:	687b      	ldr	r3, [r7, #4]
 800843a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800843c:	683a      	ldr	r2, [r7, #0]
 800843e:	429a      	cmp	r2, r3
 8008440:	d129      	bne.n	8008496 <lv_indev_reset+0x92>
            indev->proc.types.pointer.last_pressed = NULL;
 8008442:	687b      	ldr	r3, [r7, #4]
 8008444:	2200      	movs	r2, #0
 8008446:	63da      	str	r2, [r3, #60]	; 0x3c
                i->proc.types.pointer.last_pressed = NULL;
            }
            i = lv_indev_get_next(i);
        }
    }
}
 8008448:	e025      	b.n	8008496 <lv_indev_reset+0x92>
        lv_indev_t * i = lv_indev_get_next(NULL);
 800844a:	2000      	movs	r0, #0
 800844c:	f016 fc22 	bl	801ec94 <lv_indev_get_next>
 8008450:	60f8      	str	r0, [r7, #12]
        while(i) {
 8008452:	e01d      	b.n	8008490 <lv_indev_reset+0x8c>
            i->proc.reset_query = 1;
 8008454:	68fa      	ldr	r2, [r7, #12]
 8008456:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800845a:	f043 0302 	orr.w	r3, r3, #2
 800845e:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
            if(indev_act == i) indev_obj_act = NULL;
 8008462:	4b0f      	ldr	r3, [pc, #60]	; (80084a0 <lv_indev_reset+0x9c>)
 8008464:	681b      	ldr	r3, [r3, #0]
 8008466:	68fa      	ldr	r2, [r7, #12]
 8008468:	429a      	cmp	r2, r3
 800846a:	d102      	bne.n	8008472 <lv_indev_reset+0x6e>
 800846c:	4b0d      	ldr	r3, [pc, #52]	; (80084a4 <lv_indev_reset+0xa0>)
 800846e:	2200      	movs	r2, #0
 8008470:	601a      	str	r2, [r3, #0]
            if(obj == NULL || i->proc.types.pointer.last_pressed == obj) {
 8008472:	683b      	ldr	r3, [r7, #0]
 8008474:	2b00      	cmp	r3, #0
 8008476:	d004      	beq.n	8008482 <lv_indev_reset+0x7e>
 8008478:	68fb      	ldr	r3, [r7, #12]
 800847a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800847c:	683a      	ldr	r2, [r7, #0]
 800847e:	429a      	cmp	r2, r3
 8008480:	d102      	bne.n	8008488 <lv_indev_reset+0x84>
                i->proc.types.pointer.last_pressed = NULL;
 8008482:	68fb      	ldr	r3, [r7, #12]
 8008484:	2200      	movs	r2, #0
 8008486:	63da      	str	r2, [r3, #60]	; 0x3c
            i = lv_indev_get_next(i);
 8008488:	68f8      	ldr	r0, [r7, #12]
 800848a:	f016 fc03 	bl	801ec94 <lv_indev_get_next>
 800848e:	60f8      	str	r0, [r7, #12]
        while(i) {
 8008490:	68fb      	ldr	r3, [r7, #12]
 8008492:	2b00      	cmp	r3, #0
 8008494:	d1de      	bne.n	8008454 <lv_indev_reset+0x50>
}
 8008496:	bf00      	nop
 8008498:	3710      	adds	r7, #16
 800849a:	46bd      	mov	sp, r7
 800849c:	bd80      	pop	{r7, pc}
 800849e:	bf00      	nop
 80084a0:	200099e4 	.word	0x200099e4
 80084a4:	200099e8 	.word	0x200099e8

080084a8 <lv_indev_get_obj_act>:
/**
 * Gets a pointer to the currently active object in the currently processed input device.
 * @return pointer to currently active object or NULL if no active object
 */
lv_obj_t * lv_indev_get_obj_act(void)
{
 80084a8:	b480      	push	{r7}
 80084aa:	af00      	add	r7, sp, #0
    return indev_obj_act;
 80084ac:	4b03      	ldr	r3, [pc, #12]	; (80084bc <lv_indev_get_obj_act+0x14>)
 80084ae:	681b      	ldr	r3, [r3, #0]
}
 80084b0:	4618      	mov	r0, r3
 80084b2:	46bd      	mov	sp, r7
 80084b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80084b8:	4770      	bx	lr
 80084ba:	bf00      	nop
 80084bc:	200099e8 	.word	0x200099e8

080084c0 <_lv_memcpy_small>:
 * @param dst pointer to the destination buffer
 * @param src pointer to the source buffer
 * @param len number of byte to copy
 */
LV_ATTRIBUTE_FAST_MEM static inline void * _lv_memcpy_small(void * dst, const void * src, size_t len)
{
 80084c0:	b480      	push	{r7}
 80084c2:	b087      	sub	sp, #28
 80084c4:	af00      	add	r7, sp, #0
 80084c6:	60f8      	str	r0, [r7, #12]
 80084c8:	60b9      	str	r1, [r7, #8]
 80084ca:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 80084cc:	68fb      	ldr	r3, [r7, #12]
 80084ce:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 80084d0:	68bb      	ldr	r3, [r7, #8]
 80084d2:	613b      	str	r3, [r7, #16]

    while(len) {
 80084d4:	e00c      	b.n	80084f0 <_lv_memcpy_small+0x30>
        *d8 = *s8;
 80084d6:	693b      	ldr	r3, [r7, #16]
 80084d8:	781a      	ldrb	r2, [r3, #0]
 80084da:	697b      	ldr	r3, [r7, #20]
 80084dc:	701a      	strb	r2, [r3, #0]
        d8++;
 80084de:	697b      	ldr	r3, [r7, #20]
 80084e0:	3301      	adds	r3, #1
 80084e2:	617b      	str	r3, [r7, #20]
        s8++;
 80084e4:	693b      	ldr	r3, [r7, #16]
 80084e6:	3301      	adds	r3, #1
 80084e8:	613b      	str	r3, [r7, #16]
        len--;
 80084ea:	687b      	ldr	r3, [r7, #4]
 80084ec:	3b01      	subs	r3, #1
 80084ee:	607b      	str	r3, [r7, #4]
    while(len) {
 80084f0:	687b      	ldr	r3, [r7, #4]
 80084f2:	2b00      	cmp	r3, #0
 80084f4:	d1ef      	bne.n	80084d6 <_lv_memcpy_small+0x16>
    }

    return dst;
 80084f6:	68fb      	ldr	r3, [r7, #12]
}
 80084f8:	4618      	mov	r0, r3
 80084fa:	371c      	adds	r7, #28
 80084fc:	46bd      	mov	sp, r7
 80084fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008502:	4770      	bx	lr

08008504 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 8008504:	b580      	push	{r7, lr}
 8008506:	b082      	sub	sp, #8
 8008508:	af00      	add	r7, sp, #0
 800850a:	6078      	str	r0, [r7, #4]
 800850c:	6039      	str	r1, [r7, #0]
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
 800850e:	2208      	movs	r2, #8
 8008510:	6839      	ldr	r1, [r7, #0]
 8008512:	6878      	ldr	r0, [r7, #4]
 8008514:	f7ff ffd4 	bl	80084c0 <_lv_memcpy_small>
}
 8008518:	bf00      	nop
 800851a:	3708      	adds	r7, #8
 800851c:	46bd      	mov	sp, r7
 800851e:	bd80      	pop	{r7, pc}

08008520 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 8008520:	b480      	push	{r7}
 8008522:	b083      	sub	sp, #12
 8008524:	af00      	add	r7, sp, #0
 8008526:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 8008528:	687b      	ldr	r3, [r7, #4]
 800852a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800852e:	b29a      	uxth	r2, r3
 8008530:	687b      	ldr	r3, [r7, #4]
 8008532:	f9b3 3000 	ldrsh.w	r3, [r3]
 8008536:	b29b      	uxth	r3, r3
 8008538:	1ad3      	subs	r3, r2, r3
 800853a:	b29b      	uxth	r3, r3
 800853c:	3301      	adds	r3, #1
 800853e:	b29b      	uxth	r3, r3
 8008540:	b21b      	sxth	r3, r3
}
 8008542:	4618      	mov	r0, r3
 8008544:	370c      	adds	r7, #12
 8008546:	46bd      	mov	sp, r7
 8008548:	f85d 7b04 	ldr.w	r7, [sp], #4
 800854c:	4770      	bx	lr

0800854e <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 800854e:	b480      	push	{r7}
 8008550:	b083      	sub	sp, #12
 8008552:	af00      	add	r7, sp, #0
 8008554:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 8008556:	687b      	ldr	r3, [r7, #4]
 8008558:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800855c:	b29a      	uxth	r2, r3
 800855e:	687b      	ldr	r3, [r7, #4]
 8008560:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8008564:	b29b      	uxth	r3, r3
 8008566:	1ad3      	subs	r3, r2, r3
 8008568:	b29b      	uxth	r3, r3
 800856a:	3301      	adds	r3, #1
 800856c:	b29b      	uxth	r3, r3
 800856e:	b21b      	sxth	r3, r3
}
 8008570:	4618      	mov	r0, r3
 8008572:	370c      	adds	r7, #12
 8008574:	46bd      	mov	sp, r7
 8008576:	f85d 7b04 	ldr.w	r7, [sp], #4
 800857a:	4770      	bx	lr

0800857c <lv_color_mix>:
 * @param c2 the second color to mix (usually the background)
 * @param mix The ratio of the colors. 0: full `c2`, 255: full `c1`, 127: half `c1` and half`c2`
 * @return the mixed color
 */
LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
 800857c:	b480      	push	{r7}
 800857e:	b085      	sub	sp, #20
 8008580:	af00      	add	r7, sp, #0
 8008582:	80b8      	strh	r0, [r7, #4]
 8008584:	8039      	strh	r1, [r7, #0]
 8008586:	4613      	mov	r3, r2
 8008588:	70fb      	strb	r3, [r7, #3]
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
 800858a:	797b      	ldrb	r3, [r7, #5]
 800858c:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8008590:	b2db      	uxtb	r3, r3
 8008592:	461a      	mov	r2, r3
 8008594:	78fb      	ldrb	r3, [r7, #3]
 8008596:	fb03 f202 	mul.w	r2, r3, r2
 800859a:	787b      	ldrb	r3, [r7, #1]
 800859c:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80085a0:	b2db      	uxtb	r3, r3
 80085a2:	4619      	mov	r1, r3
 80085a4:	78fb      	ldrb	r3, [r7, #3]
 80085a6:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80085aa:	fb01 f303 	mul.w	r3, r1, r3
 80085ae:	4413      	add	r3, r2
 80085b0:	3380      	adds	r3, #128	; 0x80
 80085b2:	461a      	mov	r2, r3
 80085b4:	4613      	mov	r3, r2
 80085b6:	021b      	lsls	r3, r3, #8
 80085b8:	4413      	add	r3, r2
 80085ba:	01db      	lsls	r3, r3, #7
 80085bc:	4413      	add	r3, r2
 80085be:	0ddb      	lsrs	r3, r3, #23
 80085c0:	f003 031f 	and.w	r3, r3, #31
 80085c4:	b2da      	uxtb	r2, r3
 80085c6:	7b7b      	ldrb	r3, [r7, #13]
 80085c8:	f362 03c7 	bfi	r3, r2, #3, #5
 80085cc:	737b      	strb	r3, [r7, #13]
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
 80085ce:	88bb      	ldrh	r3, [r7, #4]
 80085d0:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80085d4:	b2db      	uxtb	r3, r3
 80085d6:	461a      	mov	r2, r3
 80085d8:	78fb      	ldrb	r3, [r7, #3]
 80085da:	fb03 f202 	mul.w	r2, r3, r2
 80085de:	883b      	ldrh	r3, [r7, #0]
 80085e0:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80085e4:	b2db      	uxtb	r3, r3
 80085e6:	4619      	mov	r1, r3
 80085e8:	78fb      	ldrb	r3, [r7, #3]
 80085ea:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80085ee:	fb01 f303 	mul.w	r3, r1, r3
 80085f2:	4413      	add	r3, r2
 80085f4:	3380      	adds	r3, #128	; 0x80
 80085f6:	461a      	mov	r2, r3
 80085f8:	4613      	mov	r3, r2
 80085fa:	021b      	lsls	r3, r3, #8
 80085fc:	4413      	add	r3, r2
 80085fe:	01db      	lsls	r3, r3, #7
 8008600:	4413      	add	r3, r2
 8008602:	0ddb      	lsrs	r3, r3, #23
 8008604:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8008608:	b2da      	uxtb	r2, r3
 800860a:	89bb      	ldrh	r3, [r7, #12]
 800860c:	f362 134a 	bfi	r3, r2, #5, #6
 8008610:	81bb      	strh	r3, [r7, #12]
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
 8008612:	793b      	ldrb	r3, [r7, #4]
 8008614:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8008618:	b2db      	uxtb	r3, r3
 800861a:	461a      	mov	r2, r3
 800861c:	78fb      	ldrb	r3, [r7, #3]
 800861e:	fb03 f202 	mul.w	r2, r3, r2
 8008622:	783b      	ldrb	r3, [r7, #0]
 8008624:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8008628:	b2db      	uxtb	r3, r3
 800862a:	4619      	mov	r1, r3
 800862c:	78fb      	ldrb	r3, [r7, #3]
 800862e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8008632:	fb01 f303 	mul.w	r3, r1, r3
 8008636:	4413      	add	r3, r2
 8008638:	3380      	adds	r3, #128	; 0x80
 800863a:	461a      	mov	r2, r3
 800863c:	4613      	mov	r3, r2
 800863e:	021b      	lsls	r3, r3, #8
 8008640:	4413      	add	r3, r2
 8008642:	01db      	lsls	r3, r3, #7
 8008644:	4413      	add	r3, r2
 8008646:	0ddb      	lsrs	r3, r3, #23
 8008648:	f003 031f 	and.w	r3, r3, #31
 800864c:	b2da      	uxtb	r2, r3
 800864e:	7b3b      	ldrb	r3, [r7, #12]
 8008650:	f362 0304 	bfi	r3, r2, #0, #5
 8008654:	733b      	strb	r3, [r7, #12]
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
 8008656:	89bb      	ldrh	r3, [r7, #12]
}
 8008658:	4618      	mov	r0, r3
 800865a:	3714      	adds	r7, #20
 800865c:	46bd      	mov	sp, r7
 800865e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008662:	4770      	bx	lr

08008664 <lv_color_make>:
#elif LV_COLOR_DEPTH == 32
#define LV_COLOR_MAKE(r8, g8, b8) (_LV_COLOR_MAKE_TYPE_HELPER{{b8, g8, r8, 0xff}}) /*Fix 0xff alpha*/
#endif

static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
 8008664:	b490      	push	{r4, r7}
 8008666:	b082      	sub	sp, #8
 8008668:	af00      	add	r7, sp, #0
 800866a:	4604      	mov	r4, r0
 800866c:	4608      	mov	r0, r1
 800866e:	4611      	mov	r1, r2
 8008670:	4622      	mov	r2, r4
 8008672:	71fa      	strb	r2, [r7, #7]
 8008674:	4602      	mov	r2, r0
 8008676:	71ba      	strb	r2, [r7, #6]
 8008678:	460a      	mov	r2, r1
 800867a:	717a      	strb	r2, [r7, #5]
    return LV_COLOR_MAKE(r, g, b);
 800867c:	797a      	ldrb	r2, [r7, #5]
 800867e:	08d2      	lsrs	r2, r2, #3
 8008680:	b2d2      	uxtb	r2, r2
 8008682:	f002 021f 	and.w	r2, r2, #31
 8008686:	b2d0      	uxtb	r0, r2
 8008688:	79ba      	ldrb	r2, [r7, #6]
 800868a:	0892      	lsrs	r2, r2, #2
 800868c:	b2d2      	uxtb	r2, r2
 800868e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8008692:	b2d1      	uxtb	r1, r2
 8008694:	79fa      	ldrb	r2, [r7, #7]
 8008696:	08d2      	lsrs	r2, r2, #3
 8008698:	b2d2      	uxtb	r2, r2
 800869a:	f002 021f 	and.w	r2, r2, #31
 800869e:	b2d2      	uxtb	r2, r2
 80086a0:	f360 0304 	bfi	r3, r0, #0, #5
 80086a4:	f361 134a 	bfi	r3, r1, #5, #6
 80086a8:	f362 23cf 	bfi	r3, r2, #11, #5
}
 80086ac:	4618      	mov	r0, r3
 80086ae:	3708      	adds	r7, #8
 80086b0:	46bd      	mov	sp, r7
 80086b2:	bc90      	pop	{r4, r7}
 80086b4:	4770      	bx	lr

080086b6 <lv_color_hex>:

static inline lv_color_t lv_color_hex(uint32_t c)
{
 80086b6:	b580      	push	{r7, lr}
 80086b8:	b082      	sub	sp, #8
 80086ba:	af00      	add	r7, sp, #0
 80086bc:	6078      	str	r0, [r7, #4]
    return lv_color_make((uint8_t)((c >> 16) & 0xFF), (uint8_t)((c >> 8) & 0xFF), (uint8_t)(c & 0xFF));
 80086be:	687b      	ldr	r3, [r7, #4]
 80086c0:	0c1b      	lsrs	r3, r3, #16
 80086c2:	b2d8      	uxtb	r0, r3
 80086c4:	687b      	ldr	r3, [r7, #4]
 80086c6:	0a1b      	lsrs	r3, r3, #8
 80086c8:	b2db      	uxtb	r3, r3
 80086ca:	687a      	ldr	r2, [r7, #4]
 80086cc:	b2d2      	uxtb	r2, r2
 80086ce:	4619      	mov	r1, r3
 80086d0:	f7ff ffc8 	bl	8008664 <lv_color_make>
 80086d4:	4603      	mov	r3, r0
}
 80086d6:	4618      	mov	r0, r3
 80086d8:	3708      	adds	r7, #8
 80086da:	46bd      	mov	sp, r7
 80086dc:	bd80      	pop	{r7, pc}

080086de <lv_anim_set_var>:
 * Set a variable to animate
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param var pointer to a variable to animate
 */
static inline void lv_anim_set_var(lv_anim_t * a, void * var)
{
 80086de:	b480      	push	{r7}
 80086e0:	b083      	sub	sp, #12
 80086e2:	af00      	add	r7, sp, #0
 80086e4:	6078      	str	r0, [r7, #4]
 80086e6:	6039      	str	r1, [r7, #0]
    a->var     = var;
 80086e8:	687b      	ldr	r3, [r7, #4]
 80086ea:	683a      	ldr	r2, [r7, #0]
 80086ec:	601a      	str	r2, [r3, #0]
}
 80086ee:	bf00      	nop
 80086f0:	370c      	adds	r7, #12
 80086f2:	46bd      	mov	sp, r7
 80086f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80086f8:	4770      	bx	lr

080086fa <lv_anim_set_exec_cb>:
 * @param exec_cb a function to execute during animation
 *                LittelvGL's built-in functions can be used.
 *                E.g. lv_obj_set_x
 */
static inline void lv_anim_set_exec_cb(lv_anim_t * a, lv_anim_exec_xcb_t exec_cb)
{
 80086fa:	b480      	push	{r7}
 80086fc:	b083      	sub	sp, #12
 80086fe:	af00      	add	r7, sp, #0
 8008700:	6078      	str	r0, [r7, #4]
 8008702:	6039      	str	r1, [r7, #0]
    a->exec_cb = exec_cb;
 8008704:	687b      	ldr	r3, [r7, #4]
 8008706:	683a      	ldr	r2, [r7, #0]
 8008708:	605a      	str	r2, [r3, #4]
}
 800870a:	bf00      	nop
 800870c:	370c      	adds	r7, #12
 800870e:	46bd      	mov	sp, r7
 8008710:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008714:	4770      	bx	lr

08008716 <lv_anim_set_time>:
 * Set the duration of an animation
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param duration duration of the animation in milliseconds
 */
static inline void lv_anim_set_time(lv_anim_t * a, uint32_t duration)
{
 8008716:	b480      	push	{r7}
 8008718:	b083      	sub	sp, #12
 800871a:	af00      	add	r7, sp, #0
 800871c:	6078      	str	r0, [r7, #4]
 800871e:	6039      	str	r1, [r7, #0]
    a->time     = duration;
 8008720:	683a      	ldr	r2, [r7, #0]
 8008722:	687b      	ldr	r3, [r7, #4]
 8008724:	625a      	str	r2, [r3, #36]	; 0x24
}
 8008726:	bf00      	nop
 8008728:	370c      	adds	r7, #12
 800872a:	46bd      	mov	sp, r7
 800872c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008730:	4770      	bx	lr

08008732 <lv_anim_set_delay>:
 * Set a delay before starting the animation
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param delay delay before the animation in milliseconds
 */
static inline void lv_anim_set_delay(lv_anim_t * a, uint32_t delay)
{
 8008732:	b480      	push	{r7}
 8008734:	b083      	sub	sp, #12
 8008736:	af00      	add	r7, sp, #0
 8008738:	6078      	str	r0, [r7, #4]
 800873a:	6039      	str	r1, [r7, #0]
    a->act_time = -(int32_t)(delay);
 800873c:	683b      	ldr	r3, [r7, #0]
 800873e:	425a      	negs	r2, r3
 8008740:	687b      	ldr	r3, [r7, #4]
 8008742:	629a      	str	r2, [r3, #40]	; 0x28
}
 8008744:	bf00      	nop
 8008746:	370c      	adds	r7, #12
 8008748:	46bd      	mov	sp, r7
 800874a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800874e:	4770      	bx	lr

08008750 <lv_anim_set_values>:
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param start the start value
 * @param end the end value
 */
static inline void lv_anim_set_values(lv_anim_t * a, lv_anim_value_t start, lv_anim_value_t end)
{
 8008750:	b480      	push	{r7}
 8008752:	b083      	sub	sp, #12
 8008754:	af00      	add	r7, sp, #0
 8008756:	6078      	str	r0, [r7, #4]
 8008758:	460b      	mov	r3, r1
 800875a:	807b      	strh	r3, [r7, #2]
 800875c:	4613      	mov	r3, r2
 800875e:	803b      	strh	r3, [r7, #0]
    a->start = start;
 8008760:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 8008764:	687b      	ldr	r3, [r7, #4]
 8008766:	619a      	str	r2, [r3, #24]
    a->current = start;
 8008768:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 800876c:	687b      	ldr	r3, [r7, #4]
 800876e:	61da      	str	r2, [r3, #28]
    a->end   = end;
 8008770:	f9b7 2000 	ldrsh.w	r2, [r7]
 8008774:	687b      	ldr	r3, [r7, #4]
 8008776:	621a      	str	r2, [r3, #32]
}
 8008778:	bf00      	nop
 800877a:	370c      	adds	r7, #12
 800877c:	46bd      	mov	sp, r7
 800877e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008782:	4770      	bx	lr

08008784 <lv_anim_set_path>:
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param path_cb a function the get the current value of the animation.
 *                The built in functions starts with `lv_anim_path_...`
 */
static inline void lv_anim_set_path(lv_anim_t * a, const lv_anim_path_t * path)
{
 8008784:	b580      	push	{r7, lr}
 8008786:	b082      	sub	sp, #8
 8008788:	af00      	add	r7, sp, #0
 800878a:	6078      	str	r0, [r7, #4]
 800878c:	6039      	str	r1, [r7, #0]
    _lv_memcpy_small(&a->path, path, sizeof(lv_anim_path_t));
 800878e:	687b      	ldr	r3, [r7, #4]
 8008790:	3310      	adds	r3, #16
 8008792:	2208      	movs	r2, #8
 8008794:	6839      	ldr	r1, [r7, #0]
 8008796:	4618      	mov	r0, r3
 8008798:	f7ff fe92 	bl	80084c0 <_lv_memcpy_small>
}
 800879c:	bf00      	nop
 800879e:	3708      	adds	r7, #8
 80087a0:	46bd      	mov	sp, r7
 80087a2:	bd80      	pop	{r7, pc}

080087a4 <lv_anim_set_start_cb>:
 * Set a function call when the animation really starts (considering `delay`)
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param start_cb a function call when the animation starts
 */
static inline void lv_anim_set_start_cb(lv_anim_t * a, lv_anim_ready_cb_t start_cb)
{
 80087a4:	b480      	push	{r7}
 80087a6:	b083      	sub	sp, #12
 80087a8:	af00      	add	r7, sp, #0
 80087aa:	6078      	str	r0, [r7, #4]
 80087ac:	6039      	str	r1, [r7, #0]
    a->start_cb = start_cb;
 80087ae:	687b      	ldr	r3, [r7, #4]
 80087b0:	683a      	ldr	r2, [r7, #0]
 80087b2:	609a      	str	r2, [r3, #8]
}
 80087b4:	bf00      	nop
 80087b6:	370c      	adds	r7, #12
 80087b8:	46bd      	mov	sp, r7
 80087ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 80087be:	4770      	bx	lr

080087c0 <lv_anim_set_ready_cb>:
 * Set a function call when the animation is ready
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param ready_cb a function call when the animation is ready
 */
static inline void lv_anim_set_ready_cb(lv_anim_t * a, lv_anim_ready_cb_t ready_cb)
{
 80087c0:	b480      	push	{r7}
 80087c2:	b083      	sub	sp, #12
 80087c4:	af00      	add	r7, sp, #0
 80087c6:	6078      	str	r0, [r7, #4]
 80087c8:	6039      	str	r1, [r7, #0]
    a->ready_cb = ready_cb;
 80087ca:	687b      	ldr	r3, [r7, #4]
 80087cc:	683a      	ldr	r2, [r7, #0]
 80087ce:	60da      	str	r2, [r3, #12]
}
 80087d0:	bf00      	nop
 80087d2:	370c      	adds	r7, #12
 80087d4:	46bd      	mov	sp, r7
 80087d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80087da:	4770      	bx	lr

080087dc <lv_style_list_get_style>:
 * @param list pointer to a style list.
 */
void _lv_style_list_reset(lv_style_list_t * style_list);

static inline lv_style_t * lv_style_list_get_style(lv_style_list_t * list, uint8_t id)
{
 80087dc:	b480      	push	{r7}
 80087de:	b083      	sub	sp, #12
 80087e0:	af00      	add	r7, sp, #0
 80087e2:	6078      	str	r0, [r7, #4]
 80087e4:	460b      	mov	r3, r1
 80087e6:	70fb      	strb	r3, [r7, #3]
    if(list->has_trans && list->skip_trans) id++;
 80087e8:	687b      	ldr	r3, [r7, #4]
 80087ea:	791b      	ldrb	r3, [r3, #4]
 80087ec:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80087f0:	b2db      	uxtb	r3, r3
 80087f2:	2b00      	cmp	r3, #0
 80087f4:	d009      	beq.n	800880a <lv_style_list_get_style+0x2e>
 80087f6:	687b      	ldr	r3, [r7, #4]
 80087f8:	795b      	ldrb	r3, [r3, #5]
 80087fa:	f003 0301 	and.w	r3, r3, #1
 80087fe:	b2db      	uxtb	r3, r3
 8008800:	2b00      	cmp	r3, #0
 8008802:	d002      	beq.n	800880a <lv_style_list_get_style+0x2e>
 8008804:	78fb      	ldrb	r3, [r7, #3]
 8008806:	3301      	adds	r3, #1
 8008808:	70fb      	strb	r3, [r7, #3]
    if(list->style_cnt == 0 || id >= list->style_cnt) return NULL;
 800880a:	687b      	ldr	r3, [r7, #4]
 800880c:	791b      	ldrb	r3, [r3, #4]
 800880e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8008812:	b2db      	uxtb	r3, r3
 8008814:	2b00      	cmp	r3, #0
 8008816:	d008      	beq.n	800882a <lv_style_list_get_style+0x4e>
 8008818:	687b      	ldr	r3, [r7, #4]
 800881a:	791b      	ldrb	r3, [r3, #4]
 800881c:	f3c3 0305 	ubfx	r3, r3, #0, #6
 8008820:	b2db      	uxtb	r3, r3
 8008822:	461a      	mov	r2, r3
 8008824:	78fb      	ldrb	r3, [r7, #3]
 8008826:	4293      	cmp	r3, r2
 8008828:	d301      	bcc.n	800882e <lv_style_list_get_style+0x52>
 800882a:	2300      	movs	r3, #0
 800882c:	e005      	b.n	800883a <lv_style_list_get_style+0x5e>
    return list->style_list[id];
 800882e:	687b      	ldr	r3, [r7, #4]
 8008830:	681a      	ldr	r2, [r3, #0]
 8008832:	78fb      	ldrb	r3, [r7, #3]
 8008834:	009b      	lsls	r3, r3, #2
 8008836:	4413      	add	r3, r2
 8008838:	681b      	ldr	r3, [r3, #0]
}
 800883a:	4618      	mov	r0, r3
 800883c:	370c      	adds	r7, #12
 800883e:	46bd      	mov	sp, r7
 8008840:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008844:	4770      	bx	lr

08008846 <lv_obj_get_style_radius>:
#define _LV_OBJ_STYLE_SET_GET_DECLARE(prop_name, func_name, value_type, style_type, scalar)                             \
    _OBJ_GET_STYLE_##scalar(prop_name, func_name, value_type, style_type)                                               \
    _OBJ_SET_STYLE_LOCAL_##scalar(prop_name, func_name, value_type, style_type)                                         \
    _OBJ_SET_STYLE_##scalar(prop_name, func_name, value_type, style_type)

_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
 8008846:	b580      	push	{r7, lr}
 8008848:	b082      	sub	sp, #8
 800884a:	af00      	add	r7, sp, #0
 800884c:	6078      	str	r0, [r7, #4]
 800884e:	460b      	mov	r3, r1
 8008850:	70fb      	strb	r3, [r7, #3]
 8008852:	78fb      	ldrb	r3, [r7, #3]
 8008854:	2201      	movs	r2, #1
 8008856:	4619      	mov	r1, r3
 8008858:	6878      	ldr	r0, [r7, #4]
 800885a:	f002 fc09 	bl	800b070 <_lv_obj_get_style_int>
 800885e:	4603      	mov	r3, r0
 8008860:	4618      	mov	r0, r3
 8008862:	3708      	adds	r7, #8
 8008864:	46bd      	mov	sp, r7
 8008866:	bd80      	pop	{r7, pc}

08008868 <lv_obj_get_style_clip_corner>:
_LV_OBJ_STYLE_SET_GET_DECLARE(CLIP_CORNER, clip_corner, bool, _int, scalar)
 8008868:	b580      	push	{r7, lr}
 800886a:	b082      	sub	sp, #8
 800886c:	af00      	add	r7, sp, #0
 800886e:	6078      	str	r0, [r7, #4]
 8008870:	460b      	mov	r3, r1
 8008872:	70fb      	strb	r3, [r7, #3]
 8008874:	78fb      	ldrb	r3, [r7, #3]
 8008876:	2202      	movs	r2, #2
 8008878:	4619      	mov	r1, r3
 800887a:	6878      	ldr	r0, [r7, #4]
 800887c:	f002 fbf8 	bl	800b070 <_lv_obj_get_style_int>
 8008880:	4603      	mov	r3, r0
 8008882:	2b00      	cmp	r3, #0
 8008884:	bf14      	ite	ne
 8008886:	2301      	movne	r3, #1
 8008888:	2300      	moveq	r3, #0
 800888a:	b2db      	uxtb	r3, r3
 800888c:	4618      	mov	r0, r3
 800888e:	3708      	adds	r7, #8
 8008890:	46bd      	mov	sp, r7
 8008892:	bd80      	pop	{r7, pc}

08008894 <lv_obj_get_style_transform_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SIZE, size, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
 8008894:	b580      	push	{r7, lr}
 8008896:	b082      	sub	sp, #8
 8008898:	af00      	add	r7, sp, #0
 800889a:	6078      	str	r0, [r7, #4]
 800889c:	460b      	mov	r3, r1
 800889e:	70fb      	strb	r3, [r7, #3]
 80088a0:	78fb      	ldrb	r3, [r7, #3]
 80088a2:	2204      	movs	r2, #4
 80088a4:	4619      	mov	r1, r3
 80088a6:	6878      	ldr	r0, [r7, #4]
 80088a8:	f002 fbe2 	bl	800b070 <_lv_obj_get_style_int>
 80088ac:	4603      	mov	r3, r0
 80088ae:	4618      	mov	r0, r3
 80088b0:	3708      	adds	r7, #8
 80088b2:	46bd      	mov	sp, r7
 80088b4:	bd80      	pop	{r7, pc}

080088b6 <lv_obj_get_style_transform_height>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
 80088b6:	b580      	push	{r7, lr}
 80088b8:	b082      	sub	sp, #8
 80088ba:	af00      	add	r7, sp, #0
 80088bc:	6078      	str	r0, [r7, #4]
 80088be:	460b      	mov	r3, r1
 80088c0:	70fb      	strb	r3, [r7, #3]
 80088c2:	78fb      	ldrb	r3, [r7, #3]
 80088c4:	2205      	movs	r2, #5
 80088c6:	4619      	mov	r1, r3
 80088c8:	6878      	ldr	r0, [r7, #4]
 80088ca:	f002 fbd1 	bl	800b070 <_lv_obj_get_style_int>
 80088ce:	4603      	mov	r3, r0
 80088d0:	4618      	mov	r0, r3
 80088d2:	3708      	adds	r7, #8
 80088d4:	46bd      	mov	sp, r7
 80088d6:	bd80      	pop	{r7, pc}

080088d8 <lv_obj_get_style_transform_angle>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
 80088d8:	b580      	push	{r7, lr}
 80088da:	b082      	sub	sp, #8
 80088dc:	af00      	add	r7, sp, #0
 80088de:	6078      	str	r0, [r7, #4]
 80088e0:	460b      	mov	r3, r1
 80088e2:	70fb      	strb	r3, [r7, #3]
 80088e4:	78fb      	ldrb	r3, [r7, #3]
 80088e6:	2206      	movs	r2, #6
 80088e8:	4619      	mov	r1, r3
 80088ea:	6878      	ldr	r0, [r7, #4]
 80088ec:	f002 fbc0 	bl	800b070 <_lv_obj_get_style_int>
 80088f0:	4603      	mov	r3, r0
 80088f2:	4618      	mov	r0, r3
 80088f4:	3708      	adds	r7, #8
 80088f6:	46bd      	mov	sp, r7
 80088f8:	bd80      	pop	{r7, pc}

080088fa <lv_obj_get_style_transform_zoom>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
 80088fa:	b580      	push	{r7, lr}
 80088fc:	b082      	sub	sp, #8
 80088fe:	af00      	add	r7, sp, #0
 8008900:	6078      	str	r0, [r7, #4]
 8008902:	460b      	mov	r3, r1
 8008904:	70fb      	strb	r3, [r7, #3]
 8008906:	78fb      	ldrb	r3, [r7, #3]
 8008908:	2207      	movs	r2, #7
 800890a:	4619      	mov	r1, r3
 800890c:	6878      	ldr	r0, [r7, #4]
 800890e:	f002 fbaf 	bl	800b070 <_lv_obj_get_style_int>
 8008912:	4603      	mov	r3, r0
 8008914:	4618      	mov	r0, r3
 8008916:	3708      	adds	r7, #8
 8008918:	46bd      	mov	sp, r7
 800891a:	bd80      	pop	{r7, pc}

0800891c <lv_obj_get_style_opa_scale>:
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
 800891c:	b580      	push	{r7, lr}
 800891e:	b082      	sub	sp, #8
 8008920:	af00      	add	r7, sp, #0
 8008922:	6078      	str	r0, [r7, #4]
 8008924:	460b      	mov	r3, r1
 8008926:	70fb      	strb	r3, [r7, #3]
 8008928:	78fb      	ldrb	r3, [r7, #3]
 800892a:	f248 020c 	movw	r2, #32780	; 0x800c
 800892e:	4619      	mov	r1, r3
 8008930:	6878      	ldr	r0, [r7, #4]
 8008932:	f002 fe11 	bl	800b558 <_lv_obj_get_style_opa>
 8008936:	4603      	mov	r3, r0
 8008938:	4618      	mov	r0, r3
 800893a:	3708      	adds	r7, #8
 800893c:	46bd      	mov	sp, r7
 800893e:	bd80      	pop	{r7, pc}

08008940 <lv_obj_get_style_pad_top>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
 8008940:	b580      	push	{r7, lr}
 8008942:	b082      	sub	sp, #8
 8008944:	af00      	add	r7, sp, #0
 8008946:	6078      	str	r0, [r7, #4]
 8008948:	460b      	mov	r3, r1
 800894a:	70fb      	strb	r3, [r7, #3]
 800894c:	78fb      	ldrb	r3, [r7, #3]
 800894e:	2210      	movs	r2, #16
 8008950:	4619      	mov	r1, r3
 8008952:	6878      	ldr	r0, [r7, #4]
 8008954:	f002 fb8c 	bl	800b070 <_lv_obj_get_style_int>
 8008958:	4603      	mov	r3, r0
 800895a:	4618      	mov	r0, r3
 800895c:	3708      	adds	r7, #8
 800895e:	46bd      	mov	sp, r7
 8008960:	bd80      	pop	{r7, pc}

08008962 <lv_obj_get_style_pad_bottom>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
 8008962:	b580      	push	{r7, lr}
 8008964:	b082      	sub	sp, #8
 8008966:	af00      	add	r7, sp, #0
 8008968:	6078      	str	r0, [r7, #4]
 800896a:	460b      	mov	r3, r1
 800896c:	70fb      	strb	r3, [r7, #3]
 800896e:	78fb      	ldrb	r3, [r7, #3]
 8008970:	2211      	movs	r2, #17
 8008972:	4619      	mov	r1, r3
 8008974:	6878      	ldr	r0, [r7, #4]
 8008976:	f002 fb7b 	bl	800b070 <_lv_obj_get_style_int>
 800897a:	4603      	mov	r3, r0
 800897c:	4618      	mov	r0, r3
 800897e:	3708      	adds	r7, #8
 8008980:	46bd      	mov	sp, r7
 8008982:	bd80      	pop	{r7, pc}

08008984 <lv_obj_get_style_pad_left>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
 8008984:	b580      	push	{r7, lr}
 8008986:	b082      	sub	sp, #8
 8008988:	af00      	add	r7, sp, #0
 800898a:	6078      	str	r0, [r7, #4]
 800898c:	460b      	mov	r3, r1
 800898e:	70fb      	strb	r3, [r7, #3]
 8008990:	78fb      	ldrb	r3, [r7, #3]
 8008992:	2212      	movs	r2, #18
 8008994:	4619      	mov	r1, r3
 8008996:	6878      	ldr	r0, [r7, #4]
 8008998:	f002 fb6a 	bl	800b070 <_lv_obj_get_style_int>
 800899c:	4603      	mov	r3, r0
 800899e:	4618      	mov	r0, r3
 80089a0:	3708      	adds	r7, #8
 80089a2:	46bd      	mov	sp, r7
 80089a4:	bd80      	pop	{r7, pc}

080089a6 <lv_obj_get_style_pad_right>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
 80089a6:	b580      	push	{r7, lr}
 80089a8:	b082      	sub	sp, #8
 80089aa:	af00      	add	r7, sp, #0
 80089ac:	6078      	str	r0, [r7, #4]
 80089ae:	460b      	mov	r3, r1
 80089b0:	70fb      	strb	r3, [r7, #3]
 80089b2:	78fb      	ldrb	r3, [r7, #3]
 80089b4:	2213      	movs	r2, #19
 80089b6:	4619      	mov	r1, r3
 80089b8:	6878      	ldr	r0, [r7, #4]
 80089ba:	f002 fb59 	bl	800b070 <_lv_obj_get_style_int>
 80089be:	4603      	mov	r3, r0
 80089c0:	4618      	mov	r0, r3
 80089c2:	3708      	adds	r7, #8
 80089c4:	46bd      	mov	sp, r7
 80089c6:	bd80      	pop	{r7, pc}

080089c8 <lv_obj_get_style_bg_blend_mode>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_BLEND_MODE, bg_blend_mode, lv_blend_mode_t, _int, scalar)
 80089c8:	b580      	push	{r7, lr}
 80089ca:	b082      	sub	sp, #8
 80089cc:	af00      	add	r7, sp, #0
 80089ce:	6078      	str	r0, [r7, #4]
 80089d0:	460b      	mov	r3, r1
 80089d2:	70fb      	strb	r3, [r7, #3]
 80089d4:	78fb      	ldrb	r3, [r7, #3]
 80089d6:	2220      	movs	r2, #32
 80089d8:	4619      	mov	r1, r3
 80089da:	6878      	ldr	r0, [r7, #4]
 80089dc:	f002 fb48 	bl	800b070 <_lv_obj_get_style_int>
 80089e0:	4603      	mov	r3, r0
 80089e2:	b2db      	uxtb	r3, r3
 80089e4:	4618      	mov	r0, r3
 80089e6:	3708      	adds	r7, #8
 80089e8:	46bd      	mov	sp, r7
 80089ea:	bd80      	pop	{r7, pc}

080089ec <lv_obj_get_style_bg_main_stop>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_MAIN_STOP, bg_main_stop, lv_style_int_t, _int, scalar)
 80089ec:	b580      	push	{r7, lr}
 80089ee:	b082      	sub	sp, #8
 80089f0:	af00      	add	r7, sp, #0
 80089f2:	6078      	str	r0, [r7, #4]
 80089f4:	460b      	mov	r3, r1
 80089f6:	70fb      	strb	r3, [r7, #3]
 80089f8:	78fb      	ldrb	r3, [r7, #3]
 80089fa:	2221      	movs	r2, #33	; 0x21
 80089fc:	4619      	mov	r1, r3
 80089fe:	6878      	ldr	r0, [r7, #4]
 8008a00:	f002 fb36 	bl	800b070 <_lv_obj_get_style_int>
 8008a04:	4603      	mov	r3, r0
 8008a06:	4618      	mov	r0, r3
 8008a08:	3708      	adds	r7, #8
 8008a0a:	46bd      	mov	sp, r7
 8008a0c:	bd80      	pop	{r7, pc}

08008a0e <lv_obj_get_style_bg_grad_stop>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_STOP, bg_grad_stop, lv_style_int_t, _int, scalar)
 8008a0e:	b580      	push	{r7, lr}
 8008a10:	b082      	sub	sp, #8
 8008a12:	af00      	add	r7, sp, #0
 8008a14:	6078      	str	r0, [r7, #4]
 8008a16:	460b      	mov	r3, r1
 8008a18:	70fb      	strb	r3, [r7, #3]
 8008a1a:	78fb      	ldrb	r3, [r7, #3]
 8008a1c:	2222      	movs	r2, #34	; 0x22
 8008a1e:	4619      	mov	r1, r3
 8008a20:	6878      	ldr	r0, [r7, #4]
 8008a22:	f002 fb25 	bl	800b070 <_lv_obj_get_style_int>
 8008a26:	4603      	mov	r3, r0
 8008a28:	4618      	mov	r0, r3
 8008a2a:	3708      	adds	r7, #8
 8008a2c:	46bd      	mov	sp, r7
 8008a2e:	bd80      	pop	{r7, pc}

08008a30 <lv_obj_get_style_bg_grad_dir>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_DIR, bg_grad_dir, lv_grad_dir_t, _int, scalar)
 8008a30:	b580      	push	{r7, lr}
 8008a32:	b082      	sub	sp, #8
 8008a34:	af00      	add	r7, sp, #0
 8008a36:	6078      	str	r0, [r7, #4]
 8008a38:	460b      	mov	r3, r1
 8008a3a:	70fb      	strb	r3, [r7, #3]
 8008a3c:	78fb      	ldrb	r3, [r7, #3]
 8008a3e:	2223      	movs	r2, #35	; 0x23
 8008a40:	4619      	mov	r1, r3
 8008a42:	6878      	ldr	r0, [r7, #4]
 8008a44:	f002 fb14 	bl	800b070 <_lv_obj_get_style_int>
 8008a48:	4603      	mov	r3, r0
 8008a4a:	b2db      	uxtb	r3, r3
 8008a4c:	4618      	mov	r0, r3
 8008a4e:	3708      	adds	r7, #8
 8008a50:	46bd      	mov	sp, r7
 8008a52:	bd80      	pop	{r7, pc}

08008a54 <lv_obj_get_style_bg_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
 8008a54:	b580      	push	{r7, lr}
 8008a56:	b082      	sub	sp, #8
 8008a58:	af00      	add	r7, sp, #0
 8008a5a:	6078      	str	r0, [r7, #4]
 8008a5c:	460b      	mov	r3, r1
 8008a5e:	70fb      	strb	r3, [r7, #3]
 8008a60:	78fb      	ldrb	r3, [r7, #3]
 8008a62:	2229      	movs	r2, #41	; 0x29
 8008a64:	4619      	mov	r1, r3
 8008a66:	6878      	ldr	r0, [r7, #4]
 8008a68:	f002 fd16 	bl	800b498 <_lv_obj_get_style_color>
 8008a6c:	4603      	mov	r3, r0
 8008a6e:	4618      	mov	r0, r3
 8008a70:	3708      	adds	r7, #8
 8008a72:	46bd      	mov	sp, r7
 8008a74:	bd80      	pop	{r7, pc}

08008a76 <lv_obj_get_style_bg_grad_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_COLOR, bg_grad_color, lv_color_t, _color, nonscalar)
 8008a76:	b580      	push	{r7, lr}
 8008a78:	b082      	sub	sp, #8
 8008a7a:	af00      	add	r7, sp, #0
 8008a7c:	6078      	str	r0, [r7, #4]
 8008a7e:	460b      	mov	r3, r1
 8008a80:	70fb      	strb	r3, [r7, #3]
 8008a82:	78fb      	ldrb	r3, [r7, #3]
 8008a84:	222a      	movs	r2, #42	; 0x2a
 8008a86:	4619      	mov	r1, r3
 8008a88:	6878      	ldr	r0, [r7, #4]
 8008a8a:	f002 fd05 	bl	800b498 <_lv_obj_get_style_color>
 8008a8e:	4603      	mov	r3, r0
 8008a90:	4618      	mov	r0, r3
 8008a92:	3708      	adds	r7, #8
 8008a94:	46bd      	mov	sp, r7
 8008a96:	bd80      	pop	{r7, pc}

08008a98 <lv_obj_get_style_bg_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
 8008a98:	b580      	push	{r7, lr}
 8008a9a:	b082      	sub	sp, #8
 8008a9c:	af00      	add	r7, sp, #0
 8008a9e:	6078      	str	r0, [r7, #4]
 8008aa0:	460b      	mov	r3, r1
 8008aa2:	70fb      	strb	r3, [r7, #3]
 8008aa4:	78fb      	ldrb	r3, [r7, #3]
 8008aa6:	222c      	movs	r2, #44	; 0x2c
 8008aa8:	4619      	mov	r1, r3
 8008aaa:	6878      	ldr	r0, [r7, #4]
 8008aac:	f002 fd54 	bl	800b558 <_lv_obj_get_style_opa>
 8008ab0:	4603      	mov	r3, r0
 8008ab2:	4618      	mov	r0, r3
 8008ab4:	3708      	adds	r7, #8
 8008ab6:	46bd      	mov	sp, r7
 8008ab8:	bd80      	pop	{r7, pc}

08008aba <lv_obj_get_style_border_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
 8008aba:	b580      	push	{r7, lr}
 8008abc:	b082      	sub	sp, #8
 8008abe:	af00      	add	r7, sp, #0
 8008ac0:	6078      	str	r0, [r7, #4]
 8008ac2:	460b      	mov	r3, r1
 8008ac4:	70fb      	strb	r3, [r7, #3]
 8008ac6:	78fb      	ldrb	r3, [r7, #3]
 8008ac8:	2230      	movs	r2, #48	; 0x30
 8008aca:	4619      	mov	r1, r3
 8008acc:	6878      	ldr	r0, [r7, #4]
 8008ace:	f002 facf 	bl	800b070 <_lv_obj_get_style_int>
 8008ad2:	4603      	mov	r3, r0
 8008ad4:	4618      	mov	r0, r3
 8008ad6:	3708      	adds	r7, #8
 8008ad8:	46bd      	mov	sp, r7
 8008ada:	bd80      	pop	{r7, pc}

08008adc <lv_obj_get_style_border_side>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_SIDE, border_side, lv_border_side_t, _int, scalar)
 8008adc:	b580      	push	{r7, lr}
 8008ade:	b082      	sub	sp, #8
 8008ae0:	af00      	add	r7, sp, #0
 8008ae2:	6078      	str	r0, [r7, #4]
 8008ae4:	460b      	mov	r3, r1
 8008ae6:	70fb      	strb	r3, [r7, #3]
 8008ae8:	78fb      	ldrb	r3, [r7, #3]
 8008aea:	2231      	movs	r2, #49	; 0x31
 8008aec:	4619      	mov	r1, r3
 8008aee:	6878      	ldr	r0, [r7, #4]
 8008af0:	f002 fabe 	bl	800b070 <_lv_obj_get_style_int>
 8008af4:	4603      	mov	r3, r0
 8008af6:	b2db      	uxtb	r3, r3
 8008af8:	4618      	mov	r0, r3
 8008afa:	3708      	adds	r7, #8
 8008afc:	46bd      	mov	sp, r7
 8008afe:	bd80      	pop	{r7, pc}

08008b00 <lv_obj_get_style_border_blend_mode>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_BLEND_MODE, border_blend_mode, lv_blend_mode_t, _int, scalar)
 8008b00:	b580      	push	{r7, lr}
 8008b02:	b082      	sub	sp, #8
 8008b04:	af00      	add	r7, sp, #0
 8008b06:	6078      	str	r0, [r7, #4]
 8008b08:	460b      	mov	r3, r1
 8008b0a:	70fb      	strb	r3, [r7, #3]
 8008b0c:	78fb      	ldrb	r3, [r7, #3]
 8008b0e:	2232      	movs	r2, #50	; 0x32
 8008b10:	4619      	mov	r1, r3
 8008b12:	6878      	ldr	r0, [r7, #4]
 8008b14:	f002 faac 	bl	800b070 <_lv_obj_get_style_int>
 8008b18:	4603      	mov	r3, r0
 8008b1a:	b2db      	uxtb	r3, r3
 8008b1c:	4618      	mov	r0, r3
 8008b1e:	3708      	adds	r7, #8
 8008b20:	46bd      	mov	sp, r7
 8008b22:	bd80      	pop	{r7, pc}

08008b24 <lv_obj_get_style_border_post>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
 8008b24:	b580      	push	{r7, lr}
 8008b26:	b082      	sub	sp, #8
 8008b28:	af00      	add	r7, sp, #0
 8008b2a:	6078      	str	r0, [r7, #4]
 8008b2c:	460b      	mov	r3, r1
 8008b2e:	70fb      	strb	r3, [r7, #3]
 8008b30:	78fb      	ldrb	r3, [r7, #3]
 8008b32:	2233      	movs	r2, #51	; 0x33
 8008b34:	4619      	mov	r1, r3
 8008b36:	6878      	ldr	r0, [r7, #4]
 8008b38:	f002 fa9a 	bl	800b070 <_lv_obj_get_style_int>
 8008b3c:	4603      	mov	r3, r0
 8008b3e:	2b00      	cmp	r3, #0
 8008b40:	bf14      	ite	ne
 8008b42:	2301      	movne	r3, #1
 8008b44:	2300      	moveq	r3, #0
 8008b46:	b2db      	uxtb	r3, r3
 8008b48:	4618      	mov	r0, r3
 8008b4a:	3708      	adds	r7, #8
 8008b4c:	46bd      	mov	sp, r7
 8008b4e:	bd80      	pop	{r7, pc}

08008b50 <lv_obj_get_style_border_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
 8008b50:	b580      	push	{r7, lr}
 8008b52:	b082      	sub	sp, #8
 8008b54:	af00      	add	r7, sp, #0
 8008b56:	6078      	str	r0, [r7, #4]
 8008b58:	460b      	mov	r3, r1
 8008b5a:	70fb      	strb	r3, [r7, #3]
 8008b5c:	78fb      	ldrb	r3, [r7, #3]
 8008b5e:	2239      	movs	r2, #57	; 0x39
 8008b60:	4619      	mov	r1, r3
 8008b62:	6878      	ldr	r0, [r7, #4]
 8008b64:	f002 fc98 	bl	800b498 <_lv_obj_get_style_color>
 8008b68:	4603      	mov	r3, r0
 8008b6a:	4618      	mov	r0, r3
 8008b6c:	3708      	adds	r7, #8
 8008b6e:	46bd      	mov	sp, r7
 8008b70:	bd80      	pop	{r7, pc}

08008b72 <lv_obj_get_style_border_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_OPA, border_opa, lv_opa_t, _opa, scalar)
 8008b72:	b580      	push	{r7, lr}
 8008b74:	b082      	sub	sp, #8
 8008b76:	af00      	add	r7, sp, #0
 8008b78:	6078      	str	r0, [r7, #4]
 8008b7a:	460b      	mov	r3, r1
 8008b7c:	70fb      	strb	r3, [r7, #3]
 8008b7e:	78fb      	ldrb	r3, [r7, #3]
 8008b80:	223c      	movs	r2, #60	; 0x3c
 8008b82:	4619      	mov	r1, r3
 8008b84:	6878      	ldr	r0, [r7, #4]
 8008b86:	f002 fce7 	bl	800b558 <_lv_obj_get_style_opa>
 8008b8a:	4603      	mov	r3, r0
 8008b8c:	4618      	mov	r0, r3
 8008b8e:	3708      	adds	r7, #8
 8008b90:	46bd      	mov	sp, r7
 8008b92:	bd80      	pop	{r7, pc}

08008b94 <lv_obj_get_style_outline_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_WIDTH, outline_width, lv_style_int_t, _int, scalar)
 8008b94:	b580      	push	{r7, lr}
 8008b96:	b082      	sub	sp, #8
 8008b98:	af00      	add	r7, sp, #0
 8008b9a:	6078      	str	r0, [r7, #4]
 8008b9c:	460b      	mov	r3, r1
 8008b9e:	70fb      	strb	r3, [r7, #3]
 8008ba0:	78fb      	ldrb	r3, [r7, #3]
 8008ba2:	2240      	movs	r2, #64	; 0x40
 8008ba4:	4619      	mov	r1, r3
 8008ba6:	6878      	ldr	r0, [r7, #4]
 8008ba8:	f002 fa62 	bl	800b070 <_lv_obj_get_style_int>
 8008bac:	4603      	mov	r3, r0
 8008bae:	4618      	mov	r0, r3
 8008bb0:	3708      	adds	r7, #8
 8008bb2:	46bd      	mov	sp, r7
 8008bb4:	bd80      	pop	{r7, pc}

08008bb6 <lv_obj_get_style_outline_pad>:
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_PAD, outline_pad, lv_style_int_t, _int, scalar)
 8008bb6:	b580      	push	{r7, lr}
 8008bb8:	b082      	sub	sp, #8
 8008bba:	af00      	add	r7, sp, #0
 8008bbc:	6078      	str	r0, [r7, #4]
 8008bbe:	460b      	mov	r3, r1
 8008bc0:	70fb      	strb	r3, [r7, #3]
 8008bc2:	78fb      	ldrb	r3, [r7, #3]
 8008bc4:	2241      	movs	r2, #65	; 0x41
 8008bc6:	4619      	mov	r1, r3
 8008bc8:	6878      	ldr	r0, [r7, #4]
 8008bca:	f002 fa51 	bl	800b070 <_lv_obj_get_style_int>
 8008bce:	4603      	mov	r3, r0
 8008bd0:	4618      	mov	r0, r3
 8008bd2:	3708      	adds	r7, #8
 8008bd4:	46bd      	mov	sp, r7
 8008bd6:	bd80      	pop	{r7, pc}

08008bd8 <lv_obj_get_style_outline_blend_mode>:
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_BLEND_MODE, outline_blend_mode, lv_blend_mode_t, _int, scalar)
 8008bd8:	b580      	push	{r7, lr}
 8008bda:	b082      	sub	sp, #8
 8008bdc:	af00      	add	r7, sp, #0
 8008bde:	6078      	str	r0, [r7, #4]
 8008be0:	460b      	mov	r3, r1
 8008be2:	70fb      	strb	r3, [r7, #3]
 8008be4:	78fb      	ldrb	r3, [r7, #3]
 8008be6:	2242      	movs	r2, #66	; 0x42
 8008be8:	4619      	mov	r1, r3
 8008bea:	6878      	ldr	r0, [r7, #4]
 8008bec:	f002 fa40 	bl	800b070 <_lv_obj_get_style_int>
 8008bf0:	4603      	mov	r3, r0
 8008bf2:	b2db      	uxtb	r3, r3
 8008bf4:	4618      	mov	r0, r3
 8008bf6:	3708      	adds	r7, #8
 8008bf8:	46bd      	mov	sp, r7
 8008bfa:	bd80      	pop	{r7, pc}

08008bfc <lv_obj_get_style_outline_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_COLOR, outline_color, lv_color_t, _color, nonscalar)
 8008bfc:	b580      	push	{r7, lr}
 8008bfe:	b082      	sub	sp, #8
 8008c00:	af00      	add	r7, sp, #0
 8008c02:	6078      	str	r0, [r7, #4]
 8008c04:	460b      	mov	r3, r1
 8008c06:	70fb      	strb	r3, [r7, #3]
 8008c08:	78fb      	ldrb	r3, [r7, #3]
 8008c0a:	2249      	movs	r2, #73	; 0x49
 8008c0c:	4619      	mov	r1, r3
 8008c0e:	6878      	ldr	r0, [r7, #4]
 8008c10:	f002 fc42 	bl	800b498 <_lv_obj_get_style_color>
 8008c14:	4603      	mov	r3, r0
 8008c16:	4618      	mov	r0, r3
 8008c18:	3708      	adds	r7, #8
 8008c1a:	46bd      	mov	sp, r7
 8008c1c:	bd80      	pop	{r7, pc}

08008c1e <lv_obj_get_style_outline_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_OPA, outline_opa, lv_opa_t, _opa, scalar)
 8008c1e:	b580      	push	{r7, lr}
 8008c20:	b082      	sub	sp, #8
 8008c22:	af00      	add	r7, sp, #0
 8008c24:	6078      	str	r0, [r7, #4]
 8008c26:	460b      	mov	r3, r1
 8008c28:	70fb      	strb	r3, [r7, #3]
 8008c2a:	78fb      	ldrb	r3, [r7, #3]
 8008c2c:	224c      	movs	r2, #76	; 0x4c
 8008c2e:	4619      	mov	r1, r3
 8008c30:	6878      	ldr	r0, [r7, #4]
 8008c32:	f002 fc91 	bl	800b558 <_lv_obj_get_style_opa>
 8008c36:	4603      	mov	r3, r0
 8008c38:	4618      	mov	r0, r3
 8008c3a:	3708      	adds	r7, #8
 8008c3c:	46bd      	mov	sp, r7
 8008c3e:	bd80      	pop	{r7, pc}

08008c40 <lv_obj_get_style_shadow_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_WIDTH, shadow_width, lv_style_int_t, _int, scalar)
 8008c40:	b580      	push	{r7, lr}
 8008c42:	b082      	sub	sp, #8
 8008c44:	af00      	add	r7, sp, #0
 8008c46:	6078      	str	r0, [r7, #4]
 8008c48:	460b      	mov	r3, r1
 8008c4a:	70fb      	strb	r3, [r7, #3]
 8008c4c:	78fb      	ldrb	r3, [r7, #3]
 8008c4e:	2250      	movs	r2, #80	; 0x50
 8008c50:	4619      	mov	r1, r3
 8008c52:	6878      	ldr	r0, [r7, #4]
 8008c54:	f002 fa0c 	bl	800b070 <_lv_obj_get_style_int>
 8008c58:	4603      	mov	r3, r0
 8008c5a:	4618      	mov	r0, r3
 8008c5c:	3708      	adds	r7, #8
 8008c5e:	46bd      	mov	sp, r7
 8008c60:	bd80      	pop	{r7, pc}

08008c62 <lv_obj_get_style_shadow_ofs_x>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_X, shadow_ofs_x, lv_style_int_t, _int, scalar)
 8008c62:	b580      	push	{r7, lr}
 8008c64:	b082      	sub	sp, #8
 8008c66:	af00      	add	r7, sp, #0
 8008c68:	6078      	str	r0, [r7, #4]
 8008c6a:	460b      	mov	r3, r1
 8008c6c:	70fb      	strb	r3, [r7, #3]
 8008c6e:	78fb      	ldrb	r3, [r7, #3]
 8008c70:	2251      	movs	r2, #81	; 0x51
 8008c72:	4619      	mov	r1, r3
 8008c74:	6878      	ldr	r0, [r7, #4]
 8008c76:	f002 f9fb 	bl	800b070 <_lv_obj_get_style_int>
 8008c7a:	4603      	mov	r3, r0
 8008c7c:	4618      	mov	r0, r3
 8008c7e:	3708      	adds	r7, #8
 8008c80:	46bd      	mov	sp, r7
 8008c82:	bd80      	pop	{r7, pc}

08008c84 <lv_obj_get_style_shadow_ofs_y>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_Y, shadow_ofs_y, lv_style_int_t, _int, scalar)
 8008c84:	b580      	push	{r7, lr}
 8008c86:	b082      	sub	sp, #8
 8008c88:	af00      	add	r7, sp, #0
 8008c8a:	6078      	str	r0, [r7, #4]
 8008c8c:	460b      	mov	r3, r1
 8008c8e:	70fb      	strb	r3, [r7, #3]
 8008c90:	78fb      	ldrb	r3, [r7, #3]
 8008c92:	2252      	movs	r2, #82	; 0x52
 8008c94:	4619      	mov	r1, r3
 8008c96:	6878      	ldr	r0, [r7, #4]
 8008c98:	f002 f9ea 	bl	800b070 <_lv_obj_get_style_int>
 8008c9c:	4603      	mov	r3, r0
 8008c9e:	4618      	mov	r0, r3
 8008ca0:	3708      	adds	r7, #8
 8008ca2:	46bd      	mov	sp, r7
 8008ca4:	bd80      	pop	{r7, pc}

08008ca6 <lv_obj_get_style_shadow_spread>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_SPREAD, shadow_spread, lv_style_int_t, _int, scalar)
 8008ca6:	b580      	push	{r7, lr}
 8008ca8:	b082      	sub	sp, #8
 8008caa:	af00      	add	r7, sp, #0
 8008cac:	6078      	str	r0, [r7, #4]
 8008cae:	460b      	mov	r3, r1
 8008cb0:	70fb      	strb	r3, [r7, #3]
 8008cb2:	78fb      	ldrb	r3, [r7, #3]
 8008cb4:	2253      	movs	r2, #83	; 0x53
 8008cb6:	4619      	mov	r1, r3
 8008cb8:	6878      	ldr	r0, [r7, #4]
 8008cba:	f002 f9d9 	bl	800b070 <_lv_obj_get_style_int>
 8008cbe:	4603      	mov	r3, r0
 8008cc0:	4618      	mov	r0, r3
 8008cc2:	3708      	adds	r7, #8
 8008cc4:	46bd      	mov	sp, r7
 8008cc6:	bd80      	pop	{r7, pc}

08008cc8 <lv_obj_get_style_shadow_blend_mode>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_BLEND_MODE, shadow_blend_mode, lv_blend_mode_t, _int, scalar)
 8008cc8:	b580      	push	{r7, lr}
 8008cca:	b082      	sub	sp, #8
 8008ccc:	af00      	add	r7, sp, #0
 8008cce:	6078      	str	r0, [r7, #4]
 8008cd0:	460b      	mov	r3, r1
 8008cd2:	70fb      	strb	r3, [r7, #3]
 8008cd4:	78fb      	ldrb	r3, [r7, #3]
 8008cd6:	2254      	movs	r2, #84	; 0x54
 8008cd8:	4619      	mov	r1, r3
 8008cda:	6878      	ldr	r0, [r7, #4]
 8008cdc:	f002 f9c8 	bl	800b070 <_lv_obj_get_style_int>
 8008ce0:	4603      	mov	r3, r0
 8008ce2:	b2db      	uxtb	r3, r3
 8008ce4:	4618      	mov	r0, r3
 8008ce6:	3708      	adds	r7, #8
 8008ce8:	46bd      	mov	sp, r7
 8008cea:	bd80      	pop	{r7, pc}

08008cec <lv_obj_get_style_shadow_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_COLOR, shadow_color, lv_color_t, _color, nonscalar)
 8008cec:	b580      	push	{r7, lr}
 8008cee:	b082      	sub	sp, #8
 8008cf0:	af00      	add	r7, sp, #0
 8008cf2:	6078      	str	r0, [r7, #4]
 8008cf4:	460b      	mov	r3, r1
 8008cf6:	70fb      	strb	r3, [r7, #3]
 8008cf8:	78fb      	ldrb	r3, [r7, #3]
 8008cfa:	2259      	movs	r2, #89	; 0x59
 8008cfc:	4619      	mov	r1, r3
 8008cfe:	6878      	ldr	r0, [r7, #4]
 8008d00:	f002 fbca 	bl	800b498 <_lv_obj_get_style_color>
 8008d04:	4603      	mov	r3, r0
 8008d06:	4618      	mov	r0, r3
 8008d08:	3708      	adds	r7, #8
 8008d0a:	46bd      	mov	sp, r7
 8008d0c:	bd80      	pop	{r7, pc}

08008d0e <lv_obj_get_style_shadow_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OPA, shadow_opa, lv_opa_t, _opa, scalar)
 8008d0e:	b580      	push	{r7, lr}
 8008d10:	b082      	sub	sp, #8
 8008d12:	af00      	add	r7, sp, #0
 8008d14:	6078      	str	r0, [r7, #4]
 8008d16:	460b      	mov	r3, r1
 8008d18:	70fb      	strb	r3, [r7, #3]
 8008d1a:	78fb      	ldrb	r3, [r7, #3]
 8008d1c:	225c      	movs	r2, #92	; 0x5c
 8008d1e:	4619      	mov	r1, r3
 8008d20:	6878      	ldr	r0, [r7, #4]
 8008d22:	f002 fc19 	bl	800b558 <_lv_obj_get_style_opa>
 8008d26:	4603      	mov	r3, r0
 8008d28:	4618      	mov	r0, r3
 8008d2a:	3708      	adds	r7, #8
 8008d2c:	46bd      	mov	sp, r7
 8008d2e:	bd80      	pop	{r7, pc}

08008d30 <lv_obj_get_style_pattern_repeat>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_REPEAT, pattern_repeat, bool, _int, scalar)
 8008d30:	b580      	push	{r7, lr}
 8008d32:	b082      	sub	sp, #8
 8008d34:	af00      	add	r7, sp, #0
 8008d36:	6078      	str	r0, [r7, #4]
 8008d38:	460b      	mov	r3, r1
 8008d3a:	70fb      	strb	r3, [r7, #3]
 8008d3c:	78fb      	ldrb	r3, [r7, #3]
 8008d3e:	2261      	movs	r2, #97	; 0x61
 8008d40:	4619      	mov	r1, r3
 8008d42:	6878      	ldr	r0, [r7, #4]
 8008d44:	f002 f994 	bl	800b070 <_lv_obj_get_style_int>
 8008d48:	4603      	mov	r3, r0
 8008d4a:	2b00      	cmp	r3, #0
 8008d4c:	bf14      	ite	ne
 8008d4e:	2301      	movne	r3, #1
 8008d50:	2300      	moveq	r3, #0
 8008d52:	b2db      	uxtb	r3, r3
 8008d54:	4618      	mov	r0, r3
 8008d56:	3708      	adds	r7, #8
 8008d58:	46bd      	mov	sp, r7
 8008d5a:	bd80      	pop	{r7, pc}

08008d5c <lv_obj_get_style_pattern_blend_mode>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_BLEND_MODE, pattern_blend_mode, lv_blend_mode_t, _int, scalar)
 8008d5c:	b580      	push	{r7, lr}
 8008d5e:	b082      	sub	sp, #8
 8008d60:	af00      	add	r7, sp, #0
 8008d62:	6078      	str	r0, [r7, #4]
 8008d64:	460b      	mov	r3, r1
 8008d66:	70fb      	strb	r3, [r7, #3]
 8008d68:	78fb      	ldrb	r3, [r7, #3]
 8008d6a:	2260      	movs	r2, #96	; 0x60
 8008d6c:	4619      	mov	r1, r3
 8008d6e:	6878      	ldr	r0, [r7, #4]
 8008d70:	f002 f97e 	bl	800b070 <_lv_obj_get_style_int>
 8008d74:	4603      	mov	r3, r0
 8008d76:	b2db      	uxtb	r3, r3
 8008d78:	4618      	mov	r0, r3
 8008d7a:	3708      	adds	r7, #8
 8008d7c:	46bd      	mov	sp, r7
 8008d7e:	bd80      	pop	{r7, pc}

08008d80 <lv_obj_get_style_pattern_recolor>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_RECOLOR, pattern_recolor, lv_color_t, _color, nonscalar)
 8008d80:	b580      	push	{r7, lr}
 8008d82:	b082      	sub	sp, #8
 8008d84:	af00      	add	r7, sp, #0
 8008d86:	6078      	str	r0, [r7, #4]
 8008d88:	460b      	mov	r3, r1
 8008d8a:	70fb      	strb	r3, [r7, #3]
 8008d8c:	78fb      	ldrb	r3, [r7, #3]
 8008d8e:	2269      	movs	r2, #105	; 0x69
 8008d90:	4619      	mov	r1, r3
 8008d92:	6878      	ldr	r0, [r7, #4]
 8008d94:	f002 fb80 	bl	800b498 <_lv_obj_get_style_color>
 8008d98:	4603      	mov	r3, r0
 8008d9a:	4618      	mov	r0, r3
 8008d9c:	3708      	adds	r7, #8
 8008d9e:	46bd      	mov	sp, r7
 8008da0:	bd80      	pop	{r7, pc}

08008da2 <lv_obj_get_style_pattern_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_OPA, pattern_opa, lv_opa_t, _opa, scalar)
 8008da2:	b580      	push	{r7, lr}
 8008da4:	b082      	sub	sp, #8
 8008da6:	af00      	add	r7, sp, #0
 8008da8:	6078      	str	r0, [r7, #4]
 8008daa:	460b      	mov	r3, r1
 8008dac:	70fb      	strb	r3, [r7, #3]
 8008dae:	78fb      	ldrb	r3, [r7, #3]
 8008db0:	226c      	movs	r2, #108	; 0x6c
 8008db2:	4619      	mov	r1, r3
 8008db4:	6878      	ldr	r0, [r7, #4]
 8008db6:	f002 fbcf 	bl	800b558 <_lv_obj_get_style_opa>
 8008dba:	4603      	mov	r3, r0
 8008dbc:	4618      	mov	r0, r3
 8008dbe:	3708      	adds	r7, #8
 8008dc0:	46bd      	mov	sp, r7
 8008dc2:	bd80      	pop	{r7, pc}

08008dc4 <lv_obj_get_style_pattern_recolor_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_RECOLOR_OPA, pattern_recolor_opa, lv_opa_t, _opa, scalar)
 8008dc4:	b580      	push	{r7, lr}
 8008dc6:	b082      	sub	sp, #8
 8008dc8:	af00      	add	r7, sp, #0
 8008dca:	6078      	str	r0, [r7, #4]
 8008dcc:	460b      	mov	r3, r1
 8008dce:	70fb      	strb	r3, [r7, #3]
 8008dd0:	78fb      	ldrb	r3, [r7, #3]
 8008dd2:	226d      	movs	r2, #109	; 0x6d
 8008dd4:	4619      	mov	r1, r3
 8008dd6:	6878      	ldr	r0, [r7, #4]
 8008dd8:	f002 fbbe 	bl	800b558 <_lv_obj_get_style_opa>
 8008ddc:	4603      	mov	r3, r0
 8008dde:	4618      	mov	r0, r3
 8008de0:	3708      	adds	r7, #8
 8008de2:	46bd      	mov	sp, r7
 8008de4:	bd80      	pop	{r7, pc}

08008de6 <lv_obj_get_style_pattern_image>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_IMAGE, pattern_image, const void *, _ptr, scalar)
 8008de6:	b580      	push	{r7, lr}
 8008de8:	b082      	sub	sp, #8
 8008dea:	af00      	add	r7, sp, #0
 8008dec:	6078      	str	r0, [r7, #4]
 8008dee:	460b      	mov	r3, r1
 8008df0:	70fb      	strb	r3, [r7, #3]
 8008df2:	78fb      	ldrb	r3, [r7, #3]
 8008df4:	226e      	movs	r2, #110	; 0x6e
 8008df6:	4619      	mov	r1, r3
 8008df8:	6878      	ldr	r0, [r7, #4]
 8008dfa:	f002 fc71 	bl	800b6e0 <_lv_obj_get_style_ptr>
 8008dfe:	4603      	mov	r3, r0
 8008e00:	4618      	mov	r0, r3
 8008e02:	3708      	adds	r7, #8
 8008e04:	46bd      	mov	sp, r7
 8008e06:	bd80      	pop	{r7, pc}

08008e08 <lv_obj_get_style_value_letter_space>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_LETTER_SPACE, value_letter_space, lv_style_int_t, _int, scalar)
 8008e08:	b580      	push	{r7, lr}
 8008e0a:	b082      	sub	sp, #8
 8008e0c:	af00      	add	r7, sp, #0
 8008e0e:	6078      	str	r0, [r7, #4]
 8008e10:	460b      	mov	r3, r1
 8008e12:	70fb      	strb	r3, [r7, #3]
 8008e14:	78fb      	ldrb	r3, [r7, #3]
 8008e16:	2270      	movs	r2, #112	; 0x70
 8008e18:	4619      	mov	r1, r3
 8008e1a:	6878      	ldr	r0, [r7, #4]
 8008e1c:	f002 f928 	bl	800b070 <_lv_obj_get_style_int>
 8008e20:	4603      	mov	r3, r0
 8008e22:	4618      	mov	r0, r3
 8008e24:	3708      	adds	r7, #8
 8008e26:	46bd      	mov	sp, r7
 8008e28:	bd80      	pop	{r7, pc}

08008e2a <lv_obj_get_style_value_line_space>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_LINE_SPACE, value_line_space, lv_style_int_t, _int, scalar)
 8008e2a:	b580      	push	{r7, lr}
 8008e2c:	b082      	sub	sp, #8
 8008e2e:	af00      	add	r7, sp, #0
 8008e30:	6078      	str	r0, [r7, #4]
 8008e32:	460b      	mov	r3, r1
 8008e34:	70fb      	strb	r3, [r7, #3]
 8008e36:	78fb      	ldrb	r3, [r7, #3]
 8008e38:	2271      	movs	r2, #113	; 0x71
 8008e3a:	4619      	mov	r1, r3
 8008e3c:	6878      	ldr	r0, [r7, #4]
 8008e3e:	f002 f917 	bl	800b070 <_lv_obj_get_style_int>
 8008e42:	4603      	mov	r3, r0
 8008e44:	4618      	mov	r0, r3
 8008e46:	3708      	adds	r7, #8
 8008e48:	46bd      	mov	sp, r7
 8008e4a:	bd80      	pop	{r7, pc}

08008e4c <lv_obj_get_style_value_blend_mode>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_BLEND_MODE, value_blend_mode, lv_blend_mode_t, _int, scalar)
 8008e4c:	b580      	push	{r7, lr}
 8008e4e:	b082      	sub	sp, #8
 8008e50:	af00      	add	r7, sp, #0
 8008e52:	6078      	str	r0, [r7, #4]
 8008e54:	460b      	mov	r3, r1
 8008e56:	70fb      	strb	r3, [r7, #3]
 8008e58:	78fb      	ldrb	r3, [r7, #3]
 8008e5a:	2272      	movs	r2, #114	; 0x72
 8008e5c:	4619      	mov	r1, r3
 8008e5e:	6878      	ldr	r0, [r7, #4]
 8008e60:	f002 f906 	bl	800b070 <_lv_obj_get_style_int>
 8008e64:	4603      	mov	r3, r0
 8008e66:	b2db      	uxtb	r3, r3
 8008e68:	4618      	mov	r0, r3
 8008e6a:	3708      	adds	r7, #8
 8008e6c:	46bd      	mov	sp, r7
 8008e6e:	bd80      	pop	{r7, pc}

08008e70 <lv_obj_get_style_value_ofs_x>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_X, value_ofs_x, lv_style_int_t, _int, scalar)
 8008e70:	b580      	push	{r7, lr}
 8008e72:	b082      	sub	sp, #8
 8008e74:	af00      	add	r7, sp, #0
 8008e76:	6078      	str	r0, [r7, #4]
 8008e78:	460b      	mov	r3, r1
 8008e7a:	70fb      	strb	r3, [r7, #3]
 8008e7c:	78fb      	ldrb	r3, [r7, #3]
 8008e7e:	2273      	movs	r2, #115	; 0x73
 8008e80:	4619      	mov	r1, r3
 8008e82:	6878      	ldr	r0, [r7, #4]
 8008e84:	f002 f8f4 	bl	800b070 <_lv_obj_get_style_int>
 8008e88:	4603      	mov	r3, r0
 8008e8a:	4618      	mov	r0, r3
 8008e8c:	3708      	adds	r7, #8
 8008e8e:	46bd      	mov	sp, r7
 8008e90:	bd80      	pop	{r7, pc}

08008e92 <lv_obj_get_style_value_ofs_y>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_Y, value_ofs_y, lv_style_int_t, _int, scalar)
 8008e92:	b580      	push	{r7, lr}
 8008e94:	b082      	sub	sp, #8
 8008e96:	af00      	add	r7, sp, #0
 8008e98:	6078      	str	r0, [r7, #4]
 8008e9a:	460b      	mov	r3, r1
 8008e9c:	70fb      	strb	r3, [r7, #3]
 8008e9e:	78fb      	ldrb	r3, [r7, #3]
 8008ea0:	2274      	movs	r2, #116	; 0x74
 8008ea2:	4619      	mov	r1, r3
 8008ea4:	6878      	ldr	r0, [r7, #4]
 8008ea6:	f002 f8e3 	bl	800b070 <_lv_obj_get_style_int>
 8008eaa:	4603      	mov	r3, r0
 8008eac:	4618      	mov	r0, r3
 8008eae:	3708      	adds	r7, #8
 8008eb0:	46bd      	mov	sp, r7
 8008eb2:	bd80      	pop	{r7, pc}

08008eb4 <lv_obj_get_style_value_align>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_ALIGN, value_align, lv_align_t, _int, scalar)
 8008eb4:	b580      	push	{r7, lr}
 8008eb6:	b082      	sub	sp, #8
 8008eb8:	af00      	add	r7, sp, #0
 8008eba:	6078      	str	r0, [r7, #4]
 8008ebc:	460b      	mov	r3, r1
 8008ebe:	70fb      	strb	r3, [r7, #3]
 8008ec0:	78fb      	ldrb	r3, [r7, #3]
 8008ec2:	2275      	movs	r2, #117	; 0x75
 8008ec4:	4619      	mov	r1, r3
 8008ec6:	6878      	ldr	r0, [r7, #4]
 8008ec8:	f002 f8d2 	bl	800b070 <_lv_obj_get_style_int>
 8008ecc:	4603      	mov	r3, r0
 8008ece:	b2db      	uxtb	r3, r3
 8008ed0:	4618      	mov	r0, r3
 8008ed2:	3708      	adds	r7, #8
 8008ed4:	46bd      	mov	sp, r7
 8008ed6:	bd80      	pop	{r7, pc}

08008ed8 <lv_obj_get_style_value_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_COLOR, value_color, lv_color_t, _color, nonscalar)
 8008ed8:	b580      	push	{r7, lr}
 8008eda:	b082      	sub	sp, #8
 8008edc:	af00      	add	r7, sp, #0
 8008ede:	6078      	str	r0, [r7, #4]
 8008ee0:	460b      	mov	r3, r1
 8008ee2:	70fb      	strb	r3, [r7, #3]
 8008ee4:	78fb      	ldrb	r3, [r7, #3]
 8008ee6:	2279      	movs	r2, #121	; 0x79
 8008ee8:	4619      	mov	r1, r3
 8008eea:	6878      	ldr	r0, [r7, #4]
 8008eec:	f002 fad4 	bl	800b498 <_lv_obj_get_style_color>
 8008ef0:	4603      	mov	r3, r0
 8008ef2:	4618      	mov	r0, r3
 8008ef4:	3708      	adds	r7, #8
 8008ef6:	46bd      	mov	sp, r7
 8008ef8:	bd80      	pop	{r7, pc}

08008efa <lv_obj_get_style_value_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OPA, value_opa, lv_opa_t, _opa, scalar)
 8008efa:	b580      	push	{r7, lr}
 8008efc:	b082      	sub	sp, #8
 8008efe:	af00      	add	r7, sp, #0
 8008f00:	6078      	str	r0, [r7, #4]
 8008f02:	460b      	mov	r3, r1
 8008f04:	70fb      	strb	r3, [r7, #3]
 8008f06:	78fb      	ldrb	r3, [r7, #3]
 8008f08:	227c      	movs	r2, #124	; 0x7c
 8008f0a:	4619      	mov	r1, r3
 8008f0c:	6878      	ldr	r0, [r7, #4]
 8008f0e:	f002 fb23 	bl	800b558 <_lv_obj_get_style_opa>
 8008f12:	4603      	mov	r3, r0
 8008f14:	4618      	mov	r0, r3
 8008f16:	3708      	adds	r7, #8
 8008f18:	46bd      	mov	sp, r7
 8008f1a:	bd80      	pop	{r7, pc}

08008f1c <lv_obj_get_style_value_font>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_FONT, value_font, const lv_font_t *, _ptr, scalar)
 8008f1c:	b580      	push	{r7, lr}
 8008f1e:	b082      	sub	sp, #8
 8008f20:	af00      	add	r7, sp, #0
 8008f22:	6078      	str	r0, [r7, #4]
 8008f24:	460b      	mov	r3, r1
 8008f26:	70fb      	strb	r3, [r7, #3]
 8008f28:	78fb      	ldrb	r3, [r7, #3]
 8008f2a:	227e      	movs	r2, #126	; 0x7e
 8008f2c:	4619      	mov	r1, r3
 8008f2e:	6878      	ldr	r0, [r7, #4]
 8008f30:	f002 fbd6 	bl	800b6e0 <_lv_obj_get_style_ptr>
 8008f34:	4603      	mov	r3, r0
 8008f36:	4618      	mov	r0, r3
 8008f38:	3708      	adds	r7, #8
 8008f3a:	46bd      	mov	sp, r7
 8008f3c:	bd80      	pop	{r7, pc}

08008f3e <lv_obj_get_style_value_str>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_STR, value_str, const char *, _ptr, scalar)
 8008f3e:	b580      	push	{r7, lr}
 8008f40:	b082      	sub	sp, #8
 8008f42:	af00      	add	r7, sp, #0
 8008f44:	6078      	str	r0, [r7, #4]
 8008f46:	460b      	mov	r3, r1
 8008f48:	70fb      	strb	r3, [r7, #3]
 8008f4a:	78fb      	ldrb	r3, [r7, #3]
 8008f4c:	227f      	movs	r2, #127	; 0x7f
 8008f4e:	4619      	mov	r1, r3
 8008f50:	6878      	ldr	r0, [r7, #4]
 8008f52:	f002 fbc5 	bl	800b6e0 <_lv_obj_get_style_ptr>
 8008f56:	4603      	mov	r3, r0
 8008f58:	4618      	mov	r0, r3
 8008f5a:	3708      	adds	r7, #8
 8008f5c:	46bd      	mov	sp, r7
 8008f5e:	bd80      	pop	{r7, pc}

08008f60 <lv_obj_get_style_text_letter_space>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
 8008f60:	b580      	push	{r7, lr}
 8008f62:	b082      	sub	sp, #8
 8008f64:	af00      	add	r7, sp, #0
 8008f66:	6078      	str	r0, [r7, #4]
 8008f68:	460b      	mov	r3, r1
 8008f6a:	70fb      	strb	r3, [r7, #3]
 8008f6c:	78fb      	ldrb	r3, [r7, #3]
 8008f6e:	f248 0280 	movw	r2, #32896	; 0x8080
 8008f72:	4619      	mov	r1, r3
 8008f74:	6878      	ldr	r0, [r7, #4]
 8008f76:	f002 f87b 	bl	800b070 <_lv_obj_get_style_int>
 8008f7a:	4603      	mov	r3, r0
 8008f7c:	4618      	mov	r0, r3
 8008f7e:	3708      	adds	r7, #8
 8008f80:	46bd      	mov	sp, r7
 8008f82:	bd80      	pop	{r7, pc}

08008f84 <lv_obj_get_style_text_line_space>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
 8008f84:	b580      	push	{r7, lr}
 8008f86:	b082      	sub	sp, #8
 8008f88:	af00      	add	r7, sp, #0
 8008f8a:	6078      	str	r0, [r7, #4]
 8008f8c:	460b      	mov	r3, r1
 8008f8e:	70fb      	strb	r3, [r7, #3]
 8008f90:	78fb      	ldrb	r3, [r7, #3]
 8008f92:	f248 0281 	movw	r2, #32897	; 0x8081
 8008f96:	4619      	mov	r1, r3
 8008f98:	6878      	ldr	r0, [r7, #4]
 8008f9a:	f002 f869 	bl	800b070 <_lv_obj_get_style_int>
 8008f9e:	4603      	mov	r3, r0
 8008fa0:	4618      	mov	r0, r3
 8008fa2:	3708      	adds	r7, #8
 8008fa4:	46bd      	mov	sp, r7
 8008fa6:	bd80      	pop	{r7, pc}

08008fa8 <lv_obj_get_style_text_decor>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
 8008fa8:	b580      	push	{r7, lr}
 8008faa:	b082      	sub	sp, #8
 8008fac:	af00      	add	r7, sp, #0
 8008fae:	6078      	str	r0, [r7, #4]
 8008fb0:	460b      	mov	r3, r1
 8008fb2:	70fb      	strb	r3, [r7, #3]
 8008fb4:	78fb      	ldrb	r3, [r7, #3]
 8008fb6:	f248 0282 	movw	r2, #32898	; 0x8082
 8008fba:	4619      	mov	r1, r3
 8008fbc:	6878      	ldr	r0, [r7, #4]
 8008fbe:	f002 f857 	bl	800b070 <_lv_obj_get_style_int>
 8008fc2:	4603      	mov	r3, r0
 8008fc4:	b2db      	uxtb	r3, r3
 8008fc6:	4618      	mov	r0, r3
 8008fc8:	3708      	adds	r7, #8
 8008fca:	46bd      	mov	sp, r7
 8008fcc:	bd80      	pop	{r7, pc}

08008fce <lv_obj_get_style_text_blend_mode>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_BLEND_MODE, text_blend_mode, lv_blend_mode_t, _int, scalar)
 8008fce:	b580      	push	{r7, lr}
 8008fd0:	b082      	sub	sp, #8
 8008fd2:	af00      	add	r7, sp, #0
 8008fd4:	6078      	str	r0, [r7, #4]
 8008fd6:	460b      	mov	r3, r1
 8008fd8:	70fb      	strb	r3, [r7, #3]
 8008fda:	78fb      	ldrb	r3, [r7, #3]
 8008fdc:	f248 0283 	movw	r2, #32899	; 0x8083
 8008fe0:	4619      	mov	r1, r3
 8008fe2:	6878      	ldr	r0, [r7, #4]
 8008fe4:	f002 f844 	bl	800b070 <_lv_obj_get_style_int>
 8008fe8:	4603      	mov	r3, r0
 8008fea:	b2db      	uxtb	r3, r3
 8008fec:	4618      	mov	r0, r3
 8008fee:	3708      	adds	r7, #8
 8008ff0:	46bd      	mov	sp, r7
 8008ff2:	bd80      	pop	{r7, pc}

08008ff4 <lv_obj_get_style_text_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
 8008ff4:	b580      	push	{r7, lr}
 8008ff6:	b082      	sub	sp, #8
 8008ff8:	af00      	add	r7, sp, #0
 8008ffa:	6078      	str	r0, [r7, #4]
 8008ffc:	460b      	mov	r3, r1
 8008ffe:	70fb      	strb	r3, [r7, #3]
 8009000:	78fb      	ldrb	r3, [r7, #3]
 8009002:	f248 0289 	movw	r2, #32905	; 0x8089
 8009006:	4619      	mov	r1, r3
 8009008:	6878      	ldr	r0, [r7, #4]
 800900a:	f002 fa45 	bl	800b498 <_lv_obj_get_style_color>
 800900e:	4603      	mov	r3, r0
 8009010:	4618      	mov	r0, r3
 8009012:	3708      	adds	r7, #8
 8009014:	46bd      	mov	sp, r7
 8009016:	bd80      	pop	{r7, pc}

08009018 <lv_obj_get_style_text_sel_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_SEL_COLOR, text_sel_color, lv_color_t, _color, nonscalar)
 8009018:	b580      	push	{r7, lr}
 800901a:	b082      	sub	sp, #8
 800901c:	af00      	add	r7, sp, #0
 800901e:	6078      	str	r0, [r7, #4]
 8009020:	460b      	mov	r3, r1
 8009022:	70fb      	strb	r3, [r7, #3]
 8009024:	78fb      	ldrb	r3, [r7, #3]
 8009026:	f248 028a 	movw	r2, #32906	; 0x808a
 800902a:	4619      	mov	r1, r3
 800902c:	6878      	ldr	r0, [r7, #4]
 800902e:	f002 fa33 	bl	800b498 <_lv_obj_get_style_color>
 8009032:	4603      	mov	r3, r0
 8009034:	4618      	mov	r0, r3
 8009036:	3708      	adds	r7, #8
 8009038:	46bd      	mov	sp, r7
 800903a:	bd80      	pop	{r7, pc}

0800903c <lv_obj_get_style_text_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_OPA, text_opa, lv_opa_t, _opa, scalar)
 800903c:	b580      	push	{r7, lr}
 800903e:	b082      	sub	sp, #8
 8009040:	af00      	add	r7, sp, #0
 8009042:	6078      	str	r0, [r7, #4]
 8009044:	460b      	mov	r3, r1
 8009046:	70fb      	strb	r3, [r7, #3]
 8009048:	78fb      	ldrb	r3, [r7, #3]
 800904a:	f248 028c 	movw	r2, #32908	; 0x808c
 800904e:	4619      	mov	r1, r3
 8009050:	6878      	ldr	r0, [r7, #4]
 8009052:	f002 fa81 	bl	800b558 <_lv_obj_get_style_opa>
 8009056:	4603      	mov	r3, r0
 8009058:	4618      	mov	r0, r3
 800905a:	3708      	adds	r7, #8
 800905c:	46bd      	mov	sp, r7
 800905e:	bd80      	pop	{r7, pc}

08009060 <lv_obj_get_style_text_font>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
 8009060:	b580      	push	{r7, lr}
 8009062:	b082      	sub	sp, #8
 8009064:	af00      	add	r7, sp, #0
 8009066:	6078      	str	r0, [r7, #4]
 8009068:	460b      	mov	r3, r1
 800906a:	70fb      	strb	r3, [r7, #3]
 800906c:	78fb      	ldrb	r3, [r7, #3]
 800906e:	f248 028e 	movw	r2, #32910	; 0x808e
 8009072:	4619      	mov	r1, r3
 8009074:	6878      	ldr	r0, [r7, #4]
 8009076:	f002 fb33 	bl	800b6e0 <_lv_obj_get_style_ptr>
 800907a:	4603      	mov	r3, r0
 800907c:	4618      	mov	r0, r3
 800907e:	3708      	adds	r7, #8
 8009080:	46bd      	mov	sp, r7
 8009082:	bd80      	pop	{r7, pc}

08009084 <lv_obj_get_style_line_blend_mode>:
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_WIDTH, line_width, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_BLEND_MODE, line_blend_mode, lv_blend_mode_t, _int, scalar)
 8009084:	b580      	push	{r7, lr}
 8009086:	b082      	sub	sp, #8
 8009088:	af00      	add	r7, sp, #0
 800908a:	6078      	str	r0, [r7, #4]
 800908c:	460b      	mov	r3, r1
 800908e:	70fb      	strb	r3, [r7, #3]
 8009090:	78fb      	ldrb	r3, [r7, #3]
 8009092:	2291      	movs	r2, #145	; 0x91
 8009094:	4619      	mov	r1, r3
 8009096:	6878      	ldr	r0, [r7, #4]
 8009098:	f001 ffea 	bl	800b070 <_lv_obj_get_style_int>
 800909c:	4603      	mov	r3, r0
 800909e:	b2db      	uxtb	r3, r3
 80090a0:	4618      	mov	r0, r3
 80090a2:	3708      	adds	r7, #8
 80090a4:	46bd      	mov	sp, r7
 80090a6:	bd80      	pop	{r7, pc}

080090a8 <lv_obj_get_style_image_blend_mode>:
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_DASH_WIDTH, line_dash_width, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_DASH_GAP, line_dash_gap, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_ROUNDED, line_rounded, bool, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_COLOR, line_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_OPA, line_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_BLEND_MODE, image_blend_mode, lv_blend_mode_t, _int, scalar)
 80090a8:	b580      	push	{r7, lr}
 80090aa:	b082      	sub	sp, #8
 80090ac:	af00      	add	r7, sp, #0
 80090ae:	6078      	str	r0, [r7, #4]
 80090b0:	460b      	mov	r3, r1
 80090b2:	70fb      	strb	r3, [r7, #3]
 80090b4:	78fb      	ldrb	r3, [r7, #3]
 80090b6:	f248 02a0 	movw	r2, #32928	; 0x80a0
 80090ba:	4619      	mov	r1, r3
 80090bc:	6878      	ldr	r0, [r7, #4]
 80090be:	f001 ffd7 	bl	800b070 <_lv_obj_get_style_int>
 80090c2:	4603      	mov	r3, r0
 80090c4:	b2db      	uxtb	r3, r3
 80090c6:	4618      	mov	r0, r3
 80090c8:	3708      	adds	r7, #8
 80090ca:	46bd      	mov	sp, r7
 80090cc:	bd80      	pop	{r7, pc}

080090ce <lv_obj_get_style_image_recolor>:
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
 80090ce:	b580      	push	{r7, lr}
 80090d0:	b082      	sub	sp, #8
 80090d2:	af00      	add	r7, sp, #0
 80090d4:	6078      	str	r0, [r7, #4]
 80090d6:	460b      	mov	r3, r1
 80090d8:	70fb      	strb	r3, [r7, #3]
 80090da:	78fb      	ldrb	r3, [r7, #3]
 80090dc:	f248 02a9 	movw	r2, #32937	; 0x80a9
 80090e0:	4619      	mov	r1, r3
 80090e2:	6878      	ldr	r0, [r7, #4]
 80090e4:	f002 f9d8 	bl	800b498 <_lv_obj_get_style_color>
 80090e8:	4603      	mov	r3, r0
 80090ea:	4618      	mov	r0, r3
 80090ec:	3708      	adds	r7, #8
 80090ee:	46bd      	mov	sp, r7
 80090f0:	bd80      	pop	{r7, pc}

080090f2 <lv_obj_get_style_image_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_OPA, image_opa, lv_opa_t, _opa, scalar)
 80090f2:	b580      	push	{r7, lr}
 80090f4:	b082      	sub	sp, #8
 80090f6:	af00      	add	r7, sp, #0
 80090f8:	6078      	str	r0, [r7, #4]
 80090fa:	460b      	mov	r3, r1
 80090fc:	70fb      	strb	r3, [r7, #3]
 80090fe:	78fb      	ldrb	r3, [r7, #3]
 8009100:	f248 02ac 	movw	r2, #32940	; 0x80ac
 8009104:	4619      	mov	r1, r3
 8009106:	6878      	ldr	r0, [r7, #4]
 8009108:	f002 fa26 	bl	800b558 <_lv_obj_get_style_opa>
 800910c:	4603      	mov	r3, r0
 800910e:	4618      	mov	r0, r3
 8009110:	3708      	adds	r7, #8
 8009112:	46bd      	mov	sp, r7
 8009114:	bd80      	pop	{r7, pc}

08009116 <lv_obj_get_style_image_recolor_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR_OPA, image_recolor_opa, lv_opa_t, _opa, scalar)
 8009116:	b580      	push	{r7, lr}
 8009118:	b082      	sub	sp, #8
 800911a:	af00      	add	r7, sp, #0
 800911c:	6078      	str	r0, [r7, #4]
 800911e:	460b      	mov	r3, r1
 8009120:	70fb      	strb	r3, [r7, #3]
 8009122:	78fb      	ldrb	r3, [r7, #3]
 8009124:	f248 02ad 	movw	r2, #32941	; 0x80ad
 8009128:	4619      	mov	r1, r3
 800912a:	6878      	ldr	r0, [r7, #4]
 800912c:	f002 fa14 	bl	800b558 <_lv_obj_get_style_opa>
 8009130:	4603      	mov	r3, r0
 8009132:	4618      	mov	r0, r3
 8009134:	3708      	adds	r7, #8
 8009136:	46bd      	mov	sp, r7
 8009138:	bd80      	pop	{r7, pc}

0800913a <lv_obj_get_style_transition_time>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_TIME, transition_time, lv_style_int_t, _int, scalar)
 800913a:	b580      	push	{r7, lr}
 800913c:	b082      	sub	sp, #8
 800913e:	af00      	add	r7, sp, #0
 8009140:	6078      	str	r0, [r7, #4]
 8009142:	460b      	mov	r3, r1
 8009144:	70fb      	strb	r3, [r7, #3]
 8009146:	78fb      	ldrb	r3, [r7, #3]
 8009148:	22b0      	movs	r2, #176	; 0xb0
 800914a:	4619      	mov	r1, r3
 800914c:	6878      	ldr	r0, [r7, #4]
 800914e:	f001 ff8f 	bl	800b070 <_lv_obj_get_style_int>
 8009152:	4603      	mov	r3, r0
 8009154:	4618      	mov	r0, r3
 8009156:	3708      	adds	r7, #8
 8009158:	46bd      	mov	sp, r7
 800915a:	bd80      	pop	{r7, pc}

0800915c <lv_obj_get_style_transition_delay>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_DELAY, transition_delay, lv_style_int_t, _int, scalar)
 800915c:	b580      	push	{r7, lr}
 800915e:	b082      	sub	sp, #8
 8009160:	af00      	add	r7, sp, #0
 8009162:	6078      	str	r0, [r7, #4]
 8009164:	460b      	mov	r3, r1
 8009166:	70fb      	strb	r3, [r7, #3]
 8009168:	78fb      	ldrb	r3, [r7, #3]
 800916a:	22b1      	movs	r2, #177	; 0xb1
 800916c:	4619      	mov	r1, r3
 800916e:	6878      	ldr	r0, [r7, #4]
 8009170:	f001 ff7e 	bl	800b070 <_lv_obj_get_style_int>
 8009174:	4603      	mov	r3, r0
 8009176:	4618      	mov	r0, r3
 8009178:	3708      	adds	r7, #8
 800917a:	46bd      	mov	sp, r7
 800917c:	bd80      	pop	{r7, pc}

0800917e <lv_obj_get_style_transition_prop_1>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_1, transition_prop_1, lv_style_int_t, _int, scalar)
 800917e:	b580      	push	{r7, lr}
 8009180:	b082      	sub	sp, #8
 8009182:	af00      	add	r7, sp, #0
 8009184:	6078      	str	r0, [r7, #4]
 8009186:	460b      	mov	r3, r1
 8009188:	70fb      	strb	r3, [r7, #3]
 800918a:	78fb      	ldrb	r3, [r7, #3]
 800918c:	22b2      	movs	r2, #178	; 0xb2
 800918e:	4619      	mov	r1, r3
 8009190:	6878      	ldr	r0, [r7, #4]
 8009192:	f001 ff6d 	bl	800b070 <_lv_obj_get_style_int>
 8009196:	4603      	mov	r3, r0
 8009198:	4618      	mov	r0, r3
 800919a:	3708      	adds	r7, #8
 800919c:	46bd      	mov	sp, r7
 800919e:	bd80      	pop	{r7, pc}

080091a0 <lv_obj_get_style_transition_prop_2>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_2, transition_prop_2, lv_style_int_t, _int, scalar)
 80091a0:	b580      	push	{r7, lr}
 80091a2:	b082      	sub	sp, #8
 80091a4:	af00      	add	r7, sp, #0
 80091a6:	6078      	str	r0, [r7, #4]
 80091a8:	460b      	mov	r3, r1
 80091aa:	70fb      	strb	r3, [r7, #3]
 80091ac:	78fb      	ldrb	r3, [r7, #3]
 80091ae:	22b3      	movs	r2, #179	; 0xb3
 80091b0:	4619      	mov	r1, r3
 80091b2:	6878      	ldr	r0, [r7, #4]
 80091b4:	f001 ff5c 	bl	800b070 <_lv_obj_get_style_int>
 80091b8:	4603      	mov	r3, r0
 80091ba:	4618      	mov	r0, r3
 80091bc:	3708      	adds	r7, #8
 80091be:	46bd      	mov	sp, r7
 80091c0:	bd80      	pop	{r7, pc}

080091c2 <lv_obj_get_style_transition_prop_3>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_3, transition_prop_3, lv_style_int_t, _int, scalar)
 80091c2:	b580      	push	{r7, lr}
 80091c4:	b082      	sub	sp, #8
 80091c6:	af00      	add	r7, sp, #0
 80091c8:	6078      	str	r0, [r7, #4]
 80091ca:	460b      	mov	r3, r1
 80091cc:	70fb      	strb	r3, [r7, #3]
 80091ce:	78fb      	ldrb	r3, [r7, #3]
 80091d0:	22b4      	movs	r2, #180	; 0xb4
 80091d2:	4619      	mov	r1, r3
 80091d4:	6878      	ldr	r0, [r7, #4]
 80091d6:	f001 ff4b 	bl	800b070 <_lv_obj_get_style_int>
 80091da:	4603      	mov	r3, r0
 80091dc:	4618      	mov	r0, r3
 80091de:	3708      	adds	r7, #8
 80091e0:	46bd      	mov	sp, r7
 80091e2:	bd80      	pop	{r7, pc}

080091e4 <lv_obj_get_style_transition_prop_4>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_4, transition_prop_4, lv_style_int_t, _int, scalar)
 80091e4:	b580      	push	{r7, lr}
 80091e6:	b082      	sub	sp, #8
 80091e8:	af00      	add	r7, sp, #0
 80091ea:	6078      	str	r0, [r7, #4]
 80091ec:	460b      	mov	r3, r1
 80091ee:	70fb      	strb	r3, [r7, #3]
 80091f0:	78fb      	ldrb	r3, [r7, #3]
 80091f2:	22b5      	movs	r2, #181	; 0xb5
 80091f4:	4619      	mov	r1, r3
 80091f6:	6878      	ldr	r0, [r7, #4]
 80091f8:	f001 ff3a 	bl	800b070 <_lv_obj_get_style_int>
 80091fc:	4603      	mov	r3, r0
 80091fe:	4618      	mov	r0, r3
 8009200:	3708      	adds	r7, #8
 8009202:	46bd      	mov	sp, r7
 8009204:	bd80      	pop	{r7, pc}

08009206 <lv_obj_get_style_transition_prop_5>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_5, transition_prop_5, lv_style_int_t, _int, scalar)
 8009206:	b580      	push	{r7, lr}
 8009208:	b082      	sub	sp, #8
 800920a:	af00      	add	r7, sp, #0
 800920c:	6078      	str	r0, [r7, #4]
 800920e:	460b      	mov	r3, r1
 8009210:	70fb      	strb	r3, [r7, #3]
 8009212:	78fb      	ldrb	r3, [r7, #3]
 8009214:	22b6      	movs	r2, #182	; 0xb6
 8009216:	4619      	mov	r1, r3
 8009218:	6878      	ldr	r0, [r7, #4]
 800921a:	f001 ff29 	bl	800b070 <_lv_obj_get_style_int>
 800921e:	4603      	mov	r3, r0
 8009220:	4618      	mov	r0, r3
 8009222:	3708      	adds	r7, #8
 8009224:	46bd      	mov	sp, r7
 8009226:	bd80      	pop	{r7, pc}

08009228 <lv_obj_get_style_transition_prop_6>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_6, transition_prop_6, lv_style_int_t, _int, scalar)
 8009228:	b580      	push	{r7, lr}
 800922a:	b082      	sub	sp, #8
 800922c:	af00      	add	r7, sp, #0
 800922e:	6078      	str	r0, [r7, #4]
 8009230:	460b      	mov	r3, r1
 8009232:	70fb      	strb	r3, [r7, #3]
 8009234:	78fb      	ldrb	r3, [r7, #3]
 8009236:	22b7      	movs	r2, #183	; 0xb7
 8009238:	4619      	mov	r1, r3
 800923a:	6878      	ldr	r0, [r7, #4]
 800923c:	f001 ff18 	bl	800b070 <_lv_obj_get_style_int>
 8009240:	4603      	mov	r3, r0
 8009242:	4618      	mov	r0, r3
 8009244:	3708      	adds	r7, #8
 8009246:	46bd      	mov	sp, r7
 8009248:	bd80      	pop	{r7, pc}

0800924a <lv_obj_get_style_transition_path>:
#if LV_USE_ANIMATION
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PATH, transition_path, lv_anim_path_t *, _ptr, scalar)
 800924a:	b580      	push	{r7, lr}
 800924c:	b082      	sub	sp, #8
 800924e:	af00      	add	r7, sp, #0
 8009250:	6078      	str	r0, [r7, #4]
 8009252:	460b      	mov	r3, r1
 8009254:	70fb      	strb	r3, [r7, #3]
 8009256:	78fb      	ldrb	r3, [r7, #3]
 8009258:	22be      	movs	r2, #190	; 0xbe
 800925a:	4619      	mov	r1, r3
 800925c:	6878      	ldr	r0, [r7, #4]
 800925e:	f002 fa3f 	bl	800b6e0 <_lv_obj_get_style_ptr>
 8009262:	4603      	mov	r3, r0
 8009264:	4618      	mov	r0, r3
 8009266:	3708      	adds	r7, #8
 8009268:	46bd      	mov	sp, r7
 800926a:	bd80      	pop	{r7, pc}

0800926c <lv_init>:

/**
 * Init. the 'lv' library.
 */
void lv_init(void)
{
 800926c:	b590      	push	{r4, r7, lr}
 800926e:	b089      	sub	sp, #36	; 0x24
 8009270:	af04      	add	r7, sp, #16
    /* Do nothing if already initialized */
    if(lv_initialized) {
 8009272:	4b27      	ldr	r3, [pc, #156]	; (8009310 <lv_init+0xa4>)
 8009274:	781b      	ldrb	r3, [r3, #0]
 8009276:	2b00      	cmp	r3, #0
 8009278:	d146      	bne.n	8009308 <lv_init+0x9c>
    }

    LV_LOG_TRACE("lv_init started");

    /*Initialize the lv_misc modules*/
    _lv_mem_init();
 800927a:	f017 fc87 	bl	8020b8c <_lv_mem_init>
    _lv_task_core_init();
 800927e:	f018 fbbb 	bl	80219f8 <_lv_task_core_init>

#if LV_USE_FILESYSTEM
    _lv_fs_init();
 8009282:	f016 ffdd 	bl	8020240 <_lv_fs_init>
#endif

#if LV_USE_ANIMATION
    _lv_anim_core_init();
 8009286:	f015 fd8d 	bl	801eda4 <_lv_anim_core_init>
#endif

#if LV_USE_GROUP
    _lv_group_init();
 800928a:	f7fe fe5b 	bl	8007f44 <_lv_group_init>
#if LV_USE_GPU_STM32_DMA2D
    /*Initialize DMA2D GPU*/
    lv_gpu_stm32_dma2d_init();
#endif

    _lv_ll_init(&LV_GC_ROOT(_lv_obj_style_trans_ll), sizeof(lv_style_trans_t));
 800928e:	2110      	movs	r1, #16
 8009290:	4820      	ldr	r0, [pc, #128]	; (8009314 <lv_init+0xa8>)
 8009292:	f017 f96d 	bl	8020570 <_lv_ll_init>

    _lv_ll_init(&LV_GC_ROOT(_lv_disp_ll), sizeof(lv_disp_t));
 8009296:	f44f 71be 	mov.w	r1, #380	; 0x17c
 800929a:	481f      	ldr	r0, [pc, #124]	; (8009318 <lv_init+0xac>)
 800929c:	f017 f968 	bl	8020570 <_lv_ll_init>
    _lv_ll_init(&LV_GC_ROOT(_lv_indev_ll), sizeof(lv_indev_t));
 80092a0:	2160      	movs	r1, #96	; 0x60
 80092a2:	481e      	ldr	r0, [pc, #120]	; (800931c <lv_init+0xb0>)
 80092a4:	f017 f964 	bl	8020570 <_lv_ll_init>

    lv_theme_t * th = LV_THEME_DEFAULT_INIT(LV_THEME_DEFAULT_COLOR_PRIMARY, LV_THEME_DEFAULT_COLOR_SECONDARY,
 80092a8:	481d      	ldr	r0, [pc, #116]	; (8009320 <lv_init+0xb4>)
 80092aa:	f7ff fa04 	bl	80086b6 <lv_color_hex>
 80092ae:	4604      	mov	r4, r0
 80092b0:	481c      	ldr	r0, [pc, #112]	; (8009324 <lv_init+0xb8>)
 80092b2:	f7ff fa00 	bl	80086b6 <lv_color_hex>
 80092b6:	4601      	mov	r1, r0
 80092b8:	4b1b      	ldr	r3, [pc, #108]	; (8009328 <lv_init+0xbc>)
 80092ba:	9302      	str	r3, [sp, #8]
 80092bc:	4b1a      	ldr	r3, [pc, #104]	; (8009328 <lv_init+0xbc>)
 80092be:	9301      	str	r3, [sp, #4]
 80092c0:	4b19      	ldr	r3, [pc, #100]	; (8009328 <lv_init+0xbc>)
 80092c2:	9300      	str	r3, [sp, #0]
 80092c4:	4b18      	ldr	r3, [pc, #96]	; (8009328 <lv_init+0xbc>)
 80092c6:	2202      	movs	r2, #2
 80092c8:	4620      	mov	r0, r4
 80092ca:	f01f fd2f 	bl	8028d2c <lv_theme_material_init>
 80092ce:	60f8      	str	r0, [r7, #12]
                                            LV_THEME_DEFAULT_FLAG,
                                            LV_THEME_DEFAULT_FONT_SMALL, LV_THEME_DEFAULT_FONT_NORMAL, LV_THEME_DEFAULT_FONT_SUBTITLE, LV_THEME_DEFAULT_FONT_TITLE);
    lv_theme_set_act(th);
 80092d0:	68f8      	ldr	r0, [r7, #12]
 80092d2:	f019 fc25 	bl	8022b20 <lv_theme_set_act>

    /*Initialize the screen refresh system*/
    _lv_refr_init();
 80092d6:	f004 ffc4 	bl	800e262 <_lv_refr_init>

    /*Init the input device handling*/
    _lv_indev_init();
 80092da:	f7ff f87f 	bl	80083dc <_lv_indev_init>

    _lv_img_decoder_init();
 80092de:	f013 fb63 	bl	801c9a8 <_lv_img_decoder_init>
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);
 80092e2:	2001      	movs	r0, #1
 80092e4:	f013 fa52 	bl	801c78c <lv_img_cache_set_size>

    /*Test if the IDE has UTF-8 encoding*/
    char * txt = "Á";
 80092e8:	4b10      	ldr	r3, [pc, #64]	; (800932c <lv_init+0xc0>)
 80092ea:	60bb      	str	r3, [r7, #8]

    uint8_t * txt_u8 = (uint8_t *) txt;
 80092ec:	68bb      	ldr	r3, [r7, #8]
 80092ee:	607b      	str	r3, [r7, #4]
    if(txt_u8[0] != 0xc3 || txt_u8[1] != 0x81 || txt_u8[2] != 0x00) {
 80092f0:	687b      	ldr	r3, [r7, #4]
 80092f2:	781b      	ldrb	r3, [r3, #0]
 80092f4:	2bc3      	cmp	r3, #195	; 0xc3
 80092f6:	d103      	bne.n	8009300 <lv_init+0x94>
 80092f8:	687b      	ldr	r3, [r7, #4]
 80092fa:	3301      	adds	r3, #1
 80092fc:	781b      	ldrb	r3, [r3, #0]
 80092fe:	2b81      	cmp	r3, #129	; 0x81
        LV_LOG_WARN("The strings has no UTF-8 encoding. Some characters won't be displayed.")
    }

    lv_initialized = true;
 8009300:	4b03      	ldr	r3, [pc, #12]	; (8009310 <lv_init+0xa4>)
 8009302:	2201      	movs	r2, #1
 8009304:	701a      	strb	r2, [r3, #0]
 8009306:	e000      	b.n	800930a <lv_init+0x9e>
        return;
 8009308:	bf00      	nop
    LV_LOG_INFO("lv_init ready");
}
 800930a:	3714      	adds	r7, #20
 800930c:	46bd      	mov	sp, r7
 800930e:	bd90      	pop	{r4, r7, pc}
 8009310:	200099ec 	.word	0x200099ec
 8009314:	2000a1c8 	.word	0x2000a1c8
 8009318:	2000a180 	.word	0x2000a180
 800931c:	2000a18c 	.word	0x2000a18c
 8009320:	0001a2b1 	.word	0x0001a2b1
 8009324:	0044d1b6 	.word	0x0044d1b6
 8009328:	200001a8 	.word	0x200001a8
 800932c:	0802e418 	.word	0x0802e418

08009330 <lv_obj_create>:
 *                  If NULL then a screen will be created
 * @param copy pointer to a base object, if not NULL then the new object will be copied from it
 * @return pointer to the new object
 */
lv_obj_t * lv_obj_create(lv_obj_t * parent, const lv_obj_t * copy)
{
 8009330:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8009334:	b084      	sub	sp, #16
 8009336:	af00      	add	r7, sp, #0
 8009338:	6078      	str	r0, [r7, #4]
 800933a:	6039      	str	r1, [r7, #0]
    lv_obj_t * new_obj = NULL;
 800933c:	2300      	movs	r3, #0
 800933e:	60fb      	str	r3, [r7, #12]

    /*Create a screen*/
    if(parent == NULL) {
 8009340:	687b      	ldr	r3, [r7, #4]
 8009342:	2b00      	cmp	r3, #0
 8009344:	d154      	bne.n	80093f0 <lv_obj_create+0xc0>
        LV_LOG_TRACE("Screen create started");
        lv_disp_t * disp = lv_disp_get_default();
 8009346:	f015 fb95 	bl	801ea74 <lv_disp_get_default>
 800934a:	60b8      	str	r0, [r7, #8]
        if(!disp) {
 800934c:	68bb      	ldr	r3, [r7, #8]
 800934e:	2b00      	cmp	r3, #0
 8009350:	d101      	bne.n	8009356 <lv_obj_create+0x26>
            LV_LOG_WARN("lv_obj_create: not display created to so far. No place to assign the new screen");
            return NULL;
 8009352:	2300      	movs	r3, #0
 8009354:	e2c6      	b.n	80098e4 <lv_obj_create+0x5b4>
        }

        new_obj = _lv_ll_ins_head(&disp->scr_ll);
 8009356:	68bb      	ldr	r3, [r7, #8]
 8009358:	3330      	adds	r3, #48	; 0x30
 800935a:	4618      	mov	r0, r3
 800935c:	f017 f921 	bl	80205a2 <_lv_ll_ins_head>
 8009360:	60f8      	str	r0, [r7, #12]
        LV_ASSERT_MEM(new_obj);
 8009362:	68f8      	ldr	r0, [r7, #12]
 8009364:	f016 fec4 	bl	80200f0 <lv_debug_check_null>
 8009368:	4603      	mov	r3, r0
 800936a:	f083 0301 	eor.w	r3, r3, #1
 800936e:	b2db      	uxtb	r3, r3
 8009370:	2b00      	cmp	r3, #0
 8009372:	d009      	beq.n	8009388 <lv_obj_create+0x58>
 8009374:	68fb      	ldr	r3, [r7, #12]
 8009376:	2200      	movs	r2, #0
 8009378:	469a      	mov	sl, r3
 800937a:	4693      	mov	fp, r2
 800937c:	4652      	mov	r2, sl
 800937e:	465b      	mov	r3, fp
 8009380:	487f      	ldr	r0, [pc, #508]	; (8009580 <lv_obj_create+0x250>)
 8009382:	f016 fec5 	bl	8020110 <lv_debug_log_error>
 8009386:	e7fe      	b.n	8009386 <lv_obj_create+0x56>
        if(new_obj == NULL) return NULL;
 8009388:	68fb      	ldr	r3, [r7, #12]
 800938a:	2b00      	cmp	r3, #0
 800938c:	d101      	bne.n	8009392 <lv_obj_create+0x62>
 800938e:	2300      	movs	r3, #0
 8009390:	e2a8      	b.n	80098e4 <lv_obj_create+0x5b4>

        _lv_memset_00(new_obj, sizeof(lv_obj_t));
 8009392:	214c      	movs	r1, #76	; 0x4c
 8009394:	68f8      	ldr	r0, [r7, #12]
 8009396:	f018 f987 	bl	80216a8 <_lv_memset_00>

#if LV_USE_BIDI
        new_obj->base_dir     = LV_BIDI_BASE_DIR_DEF;
#else
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
 800939a:	68fa      	ldr	r2, [r7, #12]
 800939c:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 80093a0:	f36f 1346 	bfc	r3, #5, #2
 80093a4:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35
#endif

        /*Set the callbacks*/
        new_obj->signal_cb = lv_obj_signal;
 80093a8:	68fb      	ldr	r3, [r7, #12]
 80093aa:	4a76      	ldr	r2, [pc, #472]	; (8009584 <lv_obj_create+0x254>)
 80093ac:	61da      	str	r2, [r3, #28]
        new_obj->design_cb = lv_obj_design;
 80093ae:	68fb      	ldr	r3, [r7, #12]
 80093b0:	4a75      	ldr	r2, [pc, #468]	; (8009588 <lv_obj_create+0x258>)
 80093b2:	621a      	str	r2, [r3, #32]
        new_obj->event_cb = NULL;
 80093b4:	68fb      	ldr	r3, [r7, #12]
 80093b6:	2200      	movs	r2, #0
 80093b8:	619a      	str	r2, [r3, #24]

        /*Set coordinates to full screen size*/
        new_obj->coords.x1    = 0;
 80093ba:	68fb      	ldr	r3, [r7, #12]
 80093bc:	2200      	movs	r2, #0
 80093be:	821a      	strh	r2, [r3, #16]
        new_obj->coords.y1    = 0;
 80093c0:	68fb      	ldr	r3, [r7, #12]
 80093c2:	2200      	movs	r2, #0
 80093c4:	825a      	strh	r2, [r3, #18]
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
 80093c6:	2000      	movs	r0, #0
 80093c8:	f015 fb60 	bl	801ea8c <lv_disp_get_hor_res>
 80093cc:	4603      	mov	r3, r0
 80093ce:	b29b      	uxth	r3, r3
 80093d0:	3b01      	subs	r3, #1
 80093d2:	b29b      	uxth	r3, r3
 80093d4:	b21a      	sxth	r2, r3
 80093d6:	68fb      	ldr	r3, [r7, #12]
 80093d8:	829a      	strh	r2, [r3, #20]
        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;
 80093da:	2000      	movs	r0, #0
 80093dc:	f015 fb78 	bl	801ead0 <lv_disp_get_ver_res>
 80093e0:	4603      	mov	r3, r0
 80093e2:	b29b      	uxth	r3, r3
 80093e4:	3b01      	subs	r3, #1
 80093e6:	b29b      	uxth	r3, r3
 80093e8:	b21a      	sxth	r2, r3
 80093ea:	68fb      	ldr	r3, [r7, #12]
 80093ec:	82da      	strh	r2, [r3, #22]
 80093ee:	e0d7      	b.n	80095a0 <lv_obj_create+0x270>
    }
    /*Create a normal object*/
    else {
        LV_LOG_TRACE("Object create started");
        LV_ASSERT_OBJ(parent, LV_OBJX_NAME);
 80093f0:	6878      	ldr	r0, [r7, #4]
 80093f2:	f016 fe7d 	bl	80200f0 <lv_debug_check_null>
 80093f6:	4603      	mov	r3, r0
 80093f8:	f083 0301 	eor.w	r3, r3, #1
 80093fc:	b2db      	uxtb	r3, r3
 80093fe:	2b00      	cmp	r3, #0
 8009400:	d009      	beq.n	8009416 <lv_obj_create+0xe6>
 8009402:	687b      	ldr	r3, [r7, #4]
 8009404:	2200      	movs	r2, #0
 8009406:	4698      	mov	r8, r3
 8009408:	4691      	mov	r9, r2
 800940a:	4642      	mov	r2, r8
 800940c:	464b      	mov	r3, r9
 800940e:	485f      	ldr	r0, [pc, #380]	; (800958c <lv_obj_create+0x25c>)
 8009410:	f016 fe7e 	bl	8020110 <lv_debug_log_error>
 8009414:	e7fe      	b.n	8009414 <lv_obj_create+0xe4>

        new_obj = _lv_ll_ins_head(&parent->child_ll);
 8009416:	687b      	ldr	r3, [r7, #4]
 8009418:	3304      	adds	r3, #4
 800941a:	4618      	mov	r0, r3
 800941c:	f017 f8c1 	bl	80205a2 <_lv_ll_ins_head>
 8009420:	60f8      	str	r0, [r7, #12]
        LV_ASSERT_MEM(new_obj);
 8009422:	68f8      	ldr	r0, [r7, #12]
 8009424:	f016 fe64 	bl	80200f0 <lv_debug_check_null>
 8009428:	4603      	mov	r3, r0
 800942a:	f083 0301 	eor.w	r3, r3, #1
 800942e:	b2db      	uxtb	r3, r3
 8009430:	2b00      	cmp	r3, #0
 8009432:	d009      	beq.n	8009448 <lv_obj_create+0x118>
 8009434:	68fb      	ldr	r3, [r7, #12]
 8009436:	2200      	movs	r2, #0
 8009438:	461c      	mov	r4, r3
 800943a:	4615      	mov	r5, r2
 800943c:	4622      	mov	r2, r4
 800943e:	462b      	mov	r3, r5
 8009440:	484f      	ldr	r0, [pc, #316]	; (8009580 <lv_obj_create+0x250>)
 8009442:	f016 fe65 	bl	8020110 <lv_debug_log_error>
 8009446:	e7fe      	b.n	8009446 <lv_obj_create+0x116>
        if(new_obj == NULL) return NULL;
 8009448:	68fb      	ldr	r3, [r7, #12]
 800944a:	2b00      	cmp	r3, #0
 800944c:	d101      	bne.n	8009452 <lv_obj_create+0x122>
 800944e:	2300      	movs	r3, #0
 8009450:	e248      	b.n	80098e4 <lv_obj_create+0x5b4>

        _lv_memset_00(new_obj, sizeof(lv_obj_t));
 8009452:	214c      	movs	r1, #76	; 0x4c
 8009454:	68f8      	ldr	r0, [r7, #12]
 8009456:	f018 f927 	bl	80216a8 <_lv_memset_00>

        new_obj->parent = parent;
 800945a:	68fb      	ldr	r3, [r7, #12]
 800945c:	687a      	ldr	r2, [r7, #4]
 800945e:	601a      	str	r2, [r3, #0]

#if LV_USE_BIDI
        new_obj->base_dir     = LV_BIDI_DIR_INHERIT;
#else
        new_obj->base_dir     = LV_BIDI_DIR_LTR;
 8009460:	68fa      	ldr	r2, [r7, #12]
 8009462:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 8009466:	f36f 1346 	bfc	r3, #5, #2
 800946a:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35
#endif

        /*Set the callbacks (signal:cb is required in `lv_obj_get_base_dir` if `LV_USE_ASSERT_OBJ` is enabled)*/
        new_obj->signal_cb = lv_obj_signal;
 800946e:	68fb      	ldr	r3, [r7, #12]
 8009470:	4a44      	ldr	r2, [pc, #272]	; (8009584 <lv_obj_create+0x254>)
 8009472:	61da      	str	r2, [r3, #28]
        new_obj->design_cb = lv_obj_design;
 8009474:	68fb      	ldr	r3, [r7, #12]
 8009476:	4a44      	ldr	r2, [pc, #272]	; (8009588 <lv_obj_create+0x258>)
 8009478:	621a      	str	r2, [r3, #32]
        new_obj->event_cb = NULL;
 800947a:	68fb      	ldr	r3, [r7, #12]
 800947c:	2200      	movs	r2, #0
 800947e:	619a      	str	r2, [r3, #24]

        new_obj->coords.y1    = parent->coords.y1;
 8009480:	687b      	ldr	r3, [r7, #4]
 8009482:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 8009486:	68fb      	ldr	r3, [r7, #12]
 8009488:	825a      	strh	r2, [r3, #18]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
 800948a:	687b      	ldr	r3, [r7, #4]
 800948c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8009490:	b29c      	uxth	r4, r3
 8009492:	2000      	movs	r0, #0
 8009494:	f015 fb3e 	bl	801eb14 <lv_disp_get_dpi>
 8009498:	4603      	mov	r3, r0
 800949a:	461a      	mov	r2, r3
 800949c:	2332      	movs	r3, #50	; 0x32
 800949e:	fb02 f303 	mul.w	r3, r2, r3
 80094a2:	2bef      	cmp	r3, #239	; 0xef
 80094a4:	dd10      	ble.n	80094c8 <lv_obj_create+0x198>
 80094a6:	2000      	movs	r0, #0
 80094a8:	f015 fb34 	bl	801eb14 <lv_disp_get_dpi>
 80094ac:	4603      	mov	r3, r0
 80094ae:	461a      	mov	r2, r3
 80094b0:	2332      	movs	r3, #50	; 0x32
 80094b2:	fb02 f303 	mul.w	r3, r2, r3
 80094b6:	3350      	adds	r3, #80	; 0x50
 80094b8:	4a35      	ldr	r2, [pc, #212]	; (8009590 <lv_obj_create+0x260>)
 80094ba:	fb82 1203 	smull	r1, r2, r2, r3
 80094be:	1192      	asrs	r2, r2, #6
 80094c0:	17db      	asrs	r3, r3, #31
 80094c2:	1ad3      	subs	r3, r2, r3
 80094c4:	b29b      	uxth	r3, r3
 80094c6:	e000      	b.n	80094ca <lv_obj_create+0x19a>
 80094c8:	2301      	movs	r3, #1
 80094ca:	4423      	add	r3, r4
 80094cc:	b29b      	uxth	r3, r3
 80094ce:	b21a      	sxth	r2, r3
 80094d0:	68fb      	ldr	r3, [r7, #12]
 80094d2:	82da      	strh	r2, [r3, #22]
        if(lv_obj_get_base_dir(new_obj) == LV_BIDI_DIR_RTL) {
 80094d4:	68f8      	ldr	r0, [r7, #12]
 80094d6:	f002 fa01 	bl	800b8dc <lv_obj_get_base_dir>
 80094da:	4603      	mov	r3, r0
 80094dc:	2b01      	cmp	r3, #1
 80094de:	d12a      	bne.n	8009536 <lv_obj_create+0x206>
            new_obj->coords.x2    = parent->coords.x2;
 80094e0:	687b      	ldr	r3, [r7, #4]
 80094e2:	f9b3 2014 	ldrsh.w	r2, [r3, #20]
 80094e6:	68fb      	ldr	r3, [r7, #12]
 80094e8:	829a      	strh	r2, [r3, #20]
            new_obj->coords.x1    = parent->coords.x2 - LV_OBJ_DEF_WIDTH;
 80094ea:	687b      	ldr	r3, [r7, #4]
 80094ec:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 80094f0:	b29c      	uxth	r4, r3
 80094f2:	2000      	movs	r0, #0
 80094f4:	f015 fb0e 	bl	801eb14 <lv_disp_get_dpi>
 80094f8:	4603      	mov	r3, r0
 80094fa:	461a      	mov	r2, r3
 80094fc:	2364      	movs	r3, #100	; 0x64
 80094fe:	fb02 f303 	mul.w	r3, r2, r3
 8009502:	2bef      	cmp	r3, #239	; 0xef
 8009504:	dd10      	ble.n	8009528 <lv_obj_create+0x1f8>
 8009506:	2000      	movs	r0, #0
 8009508:	f015 fb04 	bl	801eb14 <lv_disp_get_dpi>
 800950c:	4603      	mov	r3, r0
 800950e:	461a      	mov	r2, r3
 8009510:	2364      	movs	r3, #100	; 0x64
 8009512:	fb02 f303 	mul.w	r3, r2, r3
 8009516:	3350      	adds	r3, #80	; 0x50
 8009518:	4a1d      	ldr	r2, [pc, #116]	; (8009590 <lv_obj_create+0x260>)
 800951a:	fb82 1203 	smull	r1, r2, r2, r3
 800951e:	1192      	asrs	r2, r2, #6
 8009520:	17db      	asrs	r3, r3, #31
 8009522:	1ad3      	subs	r3, r2, r3
 8009524:	b29b      	uxth	r3, r3
 8009526:	e000      	b.n	800952a <lv_obj_create+0x1fa>
 8009528:	2301      	movs	r3, #1
 800952a:	1ae3      	subs	r3, r4, r3
 800952c:	b29b      	uxth	r3, r3
 800952e:	b21a      	sxth	r2, r3
 8009530:	68fb      	ldr	r3, [r7, #12]
 8009532:	821a      	strh	r2, [r3, #16]
 8009534:	e034      	b.n	80095a0 <lv_obj_create+0x270>
        }
        else {
            new_obj->coords.x1    = parent->coords.x1;
 8009536:	687b      	ldr	r3, [r7, #4]
 8009538:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 800953c:	68fb      	ldr	r3, [r7, #12]
 800953e:	821a      	strh	r2, [r3, #16]
            new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
 8009540:	687b      	ldr	r3, [r7, #4]
 8009542:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8009546:	b29c      	uxth	r4, r3
 8009548:	2000      	movs	r0, #0
 800954a:	f015 fae3 	bl	801eb14 <lv_disp_get_dpi>
 800954e:	4603      	mov	r3, r0
 8009550:	461a      	mov	r2, r3
 8009552:	2364      	movs	r3, #100	; 0x64
 8009554:	fb02 f303 	mul.w	r3, r2, r3
 8009558:	2bef      	cmp	r3, #239	; 0xef
 800955a:	dd1b      	ble.n	8009594 <lv_obj_create+0x264>
 800955c:	2000      	movs	r0, #0
 800955e:	f015 fad9 	bl	801eb14 <lv_disp_get_dpi>
 8009562:	4603      	mov	r3, r0
 8009564:	461a      	mov	r2, r3
 8009566:	2364      	movs	r3, #100	; 0x64
 8009568:	fb02 f303 	mul.w	r3, r2, r3
 800956c:	3350      	adds	r3, #80	; 0x50
 800956e:	4a08      	ldr	r2, [pc, #32]	; (8009590 <lv_obj_create+0x260>)
 8009570:	fb82 1203 	smull	r1, r2, r2, r3
 8009574:	1192      	asrs	r2, r2, #6
 8009576:	17db      	asrs	r3, r3, #31
 8009578:	1ad3      	subs	r3, r2, r3
 800957a:	b29b      	uxth	r3, r3
 800957c:	e00b      	b.n	8009596 <lv_obj_create+0x266>
 800957e:	bf00      	nop
 8009580:	0802e41c 	.word	0x0802e41c
 8009584:	0800ca49 	.word	0x0800ca49
 8009588:	0800c6d5 	.word	0x0800c6d5
 800958c:	0802e42c 	.word	0x0802e42c
 8009590:	66666667 	.word	0x66666667
 8009594:	2301      	movs	r3, #1
 8009596:	4423      	add	r3, r4
 8009598:	b29b      	uxth	r3, r3
 800959a:	b21a      	sxth	r2, r3
 800959c:	68fb      	ldr	r3, [r7, #12]
 800959e:	829a      	strh	r2, [r3, #20]
        }
    }


    _lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
 80095a0:	68fb      	ldr	r3, [r7, #12]
 80095a2:	3304      	adds	r3, #4
 80095a4:	214c      	movs	r1, #76	; 0x4c
 80095a6:	4618      	mov	r0, r3
 80095a8:	f016 ffe2 	bl	8020570 <_lv_ll_init>


    new_obj->ext_draw_pad = 0;
 80095ac:	68fb      	ldr	r3, [r7, #12]
 80095ae:	2200      	movs	r2, #0
 80095b0:	865a      	strh	r2, [r3, #50]	; 0x32

#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL
    _lv_memset_00(&new_obj->ext_click_pad, sizeof(new_obj->ext_click_pad));
#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY
    new_obj->ext_click_pad_hor = 0;
 80095b2:	68fb      	ldr	r3, [r7, #12]
 80095b4:	2200      	movs	r2, #0
 80095b6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    new_obj->ext_click_pad_ver = 0;
 80095ba:	68fb      	ldr	r3, [r7, #12]
 80095bc:	2200      	movs	r2, #0
 80095be:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
#endif

    /*Init realign*/
#if LV_USE_OBJ_REALIGN
    new_obj->realign.align        = LV_ALIGN_CENTER;
 80095c2:	68fb      	ldr	r3, [r7, #12]
 80095c4:	2200      	movs	r2, #0
 80095c6:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    new_obj->realign.xofs         = 0;
 80095ca:	68fb      	ldr	r3, [r7, #12]
 80095cc:	2200      	movs	r2, #0
 80095ce:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    new_obj->realign.yofs         = 0;
 80095d2:	68fb      	ldr	r3, [r7, #12]
 80095d4:	2200      	movs	r2, #0
 80095d6:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
    new_obj->realign.base         = NULL;
 80095da:	68fb      	ldr	r3, [r7, #12]
 80095dc:	2200      	movs	r2, #0
 80095de:	641a      	str	r2, [r3, #64]	; 0x40
    new_obj->realign.auto_realign = 0;
 80095e0:	68fa      	ldr	r2, [r7, #12]
 80095e2:	f892 3049 	ldrb.w	r3, [r2, #73]	; 0x49
 80095e6:	f36f 0300 	bfc	r3, #0, #1
 80095ea:	f882 3049 	strb.w	r3, [r2, #73]	; 0x49
    _lv_memset_00(&new_obj->user_data, sizeof(lv_obj_user_data_t));
#endif


#if LV_USE_GROUP
    new_obj->group_p = NULL;
 80095ee:	68fb      	ldr	r3, [r7, #12]
 80095f0:	2200      	movs	r2, #0
 80095f2:	639a      	str	r2, [r3, #56]	; 0x38

#endif

    /*Set attributes*/
    new_obj->adv_hittest  = 0;
 80095f4:	68fa      	ldr	r2, [r7, #12]
 80095f6:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 80095fa:	f36f 13c7 	bfc	r3, #7, #1
 80095fe:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
    new_obj->click        = 1;
 8009602:	68fa      	ldr	r2, [r7, #12]
 8009604:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 8009608:	f043 0301 	orr.w	r3, r3, #1
 800960c:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
    new_obj->drag         = 0;
 8009610:	68fa      	ldr	r2, [r7, #12]
 8009612:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 8009616:	f36f 0341 	bfc	r3, #1, #1
 800961a:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
    new_obj->drag_throw   = 0;
 800961e:	68fa      	ldr	r2, [r7, #12]
 8009620:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 8009624:	f36f 0382 	bfc	r3, #2, #1
 8009628:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
    new_obj->drag_parent  = 0;
 800962c:	68fa      	ldr	r2, [r7, #12]
 800962e:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 8009632:	f36f 03c3 	bfc	r3, #3, #1
 8009636:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
    new_obj->drag_dir     = LV_DRAG_DIR_BOTH;
 800963a:	68fa      	ldr	r2, [r7, #12]
 800963c:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 8009640:	2103      	movs	r1, #3
 8009642:	f361 0384 	bfi	r3, r1, #2, #3
 8009646:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35
    new_obj->hidden       = 0;
 800964a:	68fa      	ldr	r2, [r7, #12]
 800964c:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 8009650:	f36f 1304 	bfc	r3, #4, #1
 8009654:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
    new_obj->top          = 0;
 8009658:	68fa      	ldr	r2, [r7, #12]
 800965a:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 800965e:	f36f 1345 	bfc	r3, #5, #1
 8009662:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
    new_obj->protect      = LV_PROTECT_NONE;
 8009666:	68fb      	ldr	r3, [r7, #12]
 8009668:	2200      	movs	r2, #0
 800966a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    new_obj->parent_event = 0;
 800966e:	68fa      	ldr	r2, [r7, #12]
 8009670:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 8009674:	f36f 1386 	bfc	r3, #6, #1
 8009678:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
    new_obj->gesture_parent = parent ? 1 : 0;
 800967c:	687b      	ldr	r3, [r7, #4]
 800967e:	2b00      	cmp	r3, #0
 8009680:	bf14      	ite	ne
 8009682:	2301      	movne	r3, #1
 8009684:	2300      	moveq	r3, #0
 8009686:	b2d9      	uxtb	r1, r3
 8009688:	68fa      	ldr	r2, [r7, #12]
 800968a:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 800968e:	f361 0300 	bfi	r3, r1, #0, #1
 8009692:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35
    new_obj->focus_parent  = 0;
 8009696:	68fa      	ldr	r2, [r7, #12]
 8009698:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 800969c:	f36f 0341 	bfc	r3, #1, #1
 80096a0:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35
    new_obj->state = LV_STATE_DEFAULT;
 80096a4:	68fb      	ldr	r3, [r7, #12]
 80096a6:	2200      	movs	r2, #0
 80096a8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    new_obj->ext_attr = NULL;
 80096ac:	68fb      	ldr	r3, [r7, #12]
 80096ae:	2200      	movs	r2, #0
 80096b0:	625a      	str	r2, [r3, #36]	; 0x24

    lv_style_list_init(&new_obj->style_list);
 80096b2:	68fb      	ldr	r3, [r7, #12]
 80096b4:	3328      	adds	r3, #40	; 0x28
 80096b6:	4618      	mov	r0, r3
 80096b8:	f005 fdd7 	bl	800f26a <lv_style_list_init>
    if(copy == NULL) {
 80096bc:	683b      	ldr	r3, [r7, #0]
 80096be:	2b00      	cmp	r3, #0
 80096c0:	d10c      	bne.n	80096dc <lv_obj_create+0x3ac>
        if(parent != NULL) lv_theme_apply(new_obj, LV_THEME_OBJ);
 80096c2:	687b      	ldr	r3, [r7, #4]
 80096c4:	2b00      	cmp	r3, #0
 80096c6:	d004      	beq.n	80096d2 <lv_obj_create+0x3a2>
 80096c8:	2102      	movs	r1, #2
 80096ca:	68f8      	ldr	r0, [r7, #12]
 80096cc:	f019 fa38 	bl	8022b40 <lv_theme_apply>
 80096d0:	e00d      	b.n	80096ee <lv_obj_create+0x3be>
        else  lv_theme_apply(new_obj, LV_THEME_SCR);
 80096d2:	2101      	movs	r1, #1
 80096d4:	68f8      	ldr	r0, [r7, #12]
 80096d6:	f019 fa33 	bl	8022b40 <lv_theme_apply>
 80096da:	e008      	b.n	80096ee <lv_obj_create+0x3be>
    }
    else {
        lv_style_list_copy(&new_obj->style_list, &copy->style_list);
 80096dc:	68fb      	ldr	r3, [r7, #12]
 80096de:	f103 0228 	add.w	r2, r3, #40	; 0x28
 80096e2:	683b      	ldr	r3, [r7, #0]
 80096e4:	3328      	adds	r3, #40	; 0x28
 80096e6:	4619      	mov	r1, r3
 80096e8:	4610      	mov	r0, r2
 80096ea:	f005 fdca 	bl	800f282 <lv_style_list_copy>
    }
    /*Copy the attributes if required*/
    if(copy != NULL) {
 80096ee:	683b      	ldr	r3, [r7, #0]
 80096f0:	2b00      	cmp	r3, #0
 80096f2:	f000 80ea 	beq.w	80098ca <lv_obj_create+0x59a>
        lv_area_copy(&new_obj->coords, &copy->coords);
 80096f6:	68fb      	ldr	r3, [r7, #12]
 80096f8:	f103 0210 	add.w	r2, r3, #16
 80096fc:	683b      	ldr	r3, [r7, #0]
 80096fe:	3310      	adds	r3, #16
 8009700:	4619      	mov	r1, r3
 8009702:	4610      	mov	r0, r2
 8009704:	f7fe fefe 	bl	8008504 <lv_area_copy>
        new_obj->ext_draw_pad = copy->ext_draw_pad;
 8009708:	683b      	ldr	r3, [r7, #0]
 800970a:	f9b3 2032 	ldrsh.w	r2, [r3, #50]	; 0x32
 800970e:	68fb      	ldr	r3, [r7, #12]
 8009710:	865a      	strh	r2, [r3, #50]	; 0x32

#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_FULL
        lv_area_copy(&new_obj->ext_click_pad, &copy->ext_click_pad);
#elif LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY
        new_obj->ext_click_pad_hor = copy->ext_click_pad_hor;
 8009712:	683b      	ldr	r3, [r7, #0]
 8009714:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
 8009718:	68fb      	ldr	r3, [r7, #12]
 800971a:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        new_obj->ext_click_pad_ver = copy->ext_click_pad_ver;
 800971e:	683b      	ldr	r3, [r7, #0]
 8009720:	f893 2031 	ldrb.w	r2, [r3, #49]	; 0x31
 8009724:	68fb      	ldr	r3, [r7, #12]
 8009726:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
        _lv_memcpy(&new_obj->user_data, &copy->user_data, sizeof(lv_obj_user_data_t));
#endif

        /*Copy realign*/
#if LV_USE_OBJ_REALIGN
        new_obj->realign.align        = copy->realign.align;
 800972a:	683b      	ldr	r3, [r7, #0]
 800972c:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
 8009730:	68fb      	ldr	r3, [r7, #12]
 8009732:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
        new_obj->realign.xofs         = copy->realign.xofs;
 8009736:	683b      	ldr	r3, [r7, #0]
 8009738:	f9b3 2044 	ldrsh.w	r2, [r3, #68]	; 0x44
 800973c:	68fb      	ldr	r3, [r7, #12]
 800973e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
        new_obj->realign.yofs         = copy->realign.yofs;
 8009742:	683b      	ldr	r3, [r7, #0]
 8009744:	f9b3 2046 	ldrsh.w	r2, [r3, #70]	; 0x46
 8009748:	68fb      	ldr	r3, [r7, #12]
 800974a:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
        new_obj->realign.base         = copy->realign.base;
 800974e:	683b      	ldr	r3, [r7, #0]
 8009750:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8009752:	68fb      	ldr	r3, [r7, #12]
 8009754:	641a      	str	r2, [r3, #64]	; 0x40
        new_obj->realign.auto_realign = copy->realign.auto_realign;
 8009756:	683b      	ldr	r3, [r7, #0]
 8009758:	f893 3049 	ldrb.w	r3, [r3, #73]	; 0x49
 800975c:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8009760:	b2d9      	uxtb	r1, r3
 8009762:	68fa      	ldr	r2, [r7, #12]
 8009764:	f892 3049 	ldrb.w	r3, [r2, #73]	; 0x49
 8009768:	f361 0300 	bfi	r3, r1, #0, #1
 800976c:	f882 3049 	strb.w	r3, [r2, #73]	; 0x49
#endif

        /*Only copy the `event_cb`. `signal_cb` and `design_cb` will be copied in the derived
         * object type (e.g. `lv_btn`)*/
        new_obj->event_cb = copy->event_cb;
 8009770:	683b      	ldr	r3, [r7, #0]
 8009772:	699a      	ldr	r2, [r3, #24]
 8009774:	68fb      	ldr	r3, [r7, #12]
 8009776:	619a      	str	r2, [r3, #24]

        /*Copy attributes*/
        new_obj->adv_hittest  = copy->adv_hittest;
 8009778:	683b      	ldr	r3, [r7, #0]
 800977a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800977e:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8009782:	b2d9      	uxtb	r1, r3
 8009784:	68fa      	ldr	r2, [r7, #12]
 8009786:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 800978a:	f361 13c7 	bfi	r3, r1, #7, #1
 800978e:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
        new_obj->click        = copy->click;
 8009792:	683b      	ldr	r3, [r7, #0]
 8009794:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8009798:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800979c:	b2d9      	uxtb	r1, r3
 800979e:	68fa      	ldr	r2, [r7, #12]
 80097a0:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 80097a4:	f361 0300 	bfi	r3, r1, #0, #1
 80097a8:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
        new_obj->drag         = copy->drag;
 80097ac:	683b      	ldr	r3, [r7, #0]
 80097ae:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80097b2:	f3c3 0340 	ubfx	r3, r3, #1, #1
 80097b6:	b2d9      	uxtb	r1, r3
 80097b8:	68fa      	ldr	r2, [r7, #12]
 80097ba:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 80097be:	f361 0341 	bfi	r3, r1, #1, #1
 80097c2:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
        new_obj->drag_dir     = copy->drag_dir;
 80097c6:	683b      	ldr	r3, [r7, #0]
 80097c8:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 80097cc:	f3c3 0382 	ubfx	r3, r3, #2, #3
 80097d0:	b2d9      	uxtb	r1, r3
 80097d2:	68fa      	ldr	r2, [r7, #12]
 80097d4:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 80097d8:	f361 0384 	bfi	r3, r1, #2, #3
 80097dc:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35
        new_obj->drag_throw   = copy->drag_throw;
 80097e0:	683b      	ldr	r3, [r7, #0]
 80097e2:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 80097e6:	f3c3 0380 	ubfx	r3, r3, #2, #1
 80097ea:	b2d9      	uxtb	r1, r3
 80097ec:	68fa      	ldr	r2, [r7, #12]
 80097ee:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 80097f2:	f361 0382 	bfi	r3, r1, #2, #1
 80097f6:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
        new_obj->drag_parent  = copy->drag_parent;
 80097fa:	683b      	ldr	r3, [r7, #0]
 80097fc:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8009800:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8009804:	b2d9      	uxtb	r1, r3
 8009806:	68fa      	ldr	r2, [r7, #12]
 8009808:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 800980c:	f361 03c3 	bfi	r3, r1, #3, #1
 8009810:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
        new_obj->hidden       = copy->hidden;
 8009814:	683b      	ldr	r3, [r7, #0]
 8009816:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800981a:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800981e:	b2d9      	uxtb	r1, r3
 8009820:	68fa      	ldr	r2, [r7, #12]
 8009822:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 8009826:	f361 1304 	bfi	r3, r1, #4, #1
 800982a:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
        new_obj->top          = copy->top;
 800982e:	683b      	ldr	r3, [r7, #0]
 8009830:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8009834:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8009838:	b2d9      	uxtb	r1, r3
 800983a:	68fa      	ldr	r2, [r7, #12]
 800983c:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 8009840:	f361 1345 	bfi	r3, r1, #5, #1
 8009844:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
        new_obj->parent_event = copy->parent_event;
 8009848:	683b      	ldr	r3, [r7, #0]
 800984a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800984e:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8009852:	b2d9      	uxtb	r1, r3
 8009854:	68fa      	ldr	r2, [r7, #12]
 8009856:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 800985a:	f361 1386 	bfi	r3, r1, #6, #1
 800985e:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34

        new_obj->protect      = copy->protect;
 8009862:	683b      	ldr	r3, [r7, #0]
 8009864:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 8009868:	68fb      	ldr	r3, [r7, #12]
 800986a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        new_obj->gesture_parent = copy->gesture_parent;
 800986e:	683b      	ldr	r3, [r7, #0]
 8009870:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8009874:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8009878:	b2d9      	uxtb	r1, r3
 800987a:	68fa      	ldr	r2, [r7, #12]
 800987c:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 8009880:	f361 0300 	bfi	r3, r1, #0, #1
 8009884:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35

#if LV_USE_GROUP
        /*Add to the same group*/
        if(copy->group_p != NULL) {
 8009888:	683b      	ldr	r3, [r7, #0]
 800988a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800988c:	2b00      	cmp	r3, #0
 800988e:	d005      	beq.n	800989c <lv_obj_create+0x56c>
            lv_group_add_obj(copy->group_p, new_obj);
 8009890:	683b      	ldr	r3, [r7, #0]
 8009892:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8009894:	68f9      	ldr	r1, [r7, #12]
 8009896:	4618      	mov	r0, r3
 8009898:	f7fe fb5e 	bl	8007f58 <lv_group_add_obj>
        }
#endif

        /*Set the same coordinates for non screen objects*/
        if(lv_obj_get_parent(copy) != NULL && parent != NULL) {
 800989c:	6838      	ldr	r0, [r7, #0]
 800989e:	f001 fa3b 	bl	800ad18 <lv_obj_get_parent>
 80098a2:	4603      	mov	r3, r0
 80098a4:	2b00      	cmp	r3, #0
 80098a6:	d010      	beq.n	80098ca <lv_obj_create+0x59a>
 80098a8:	687b      	ldr	r3, [r7, #4]
 80098aa:	2b00      	cmp	r3, #0
 80098ac:	d00d      	beq.n	80098ca <lv_obj_create+0x59a>
            lv_obj_set_pos(new_obj, lv_obj_get_x(copy), lv_obj_get_y(copy));
 80098ae:	6838      	ldr	r0, [r7, #0]
 80098b0:	f001 faa8 	bl	800ae04 <lv_obj_get_x>
 80098b4:	4603      	mov	r3, r0
 80098b6:	461c      	mov	r4, r3
 80098b8:	6838      	ldr	r0, [r7, #0]
 80098ba:	f001 fad9 	bl	800ae70 <lv_obj_get_y>
 80098be:	4603      	mov	r3, r0
 80098c0:	461a      	mov	r2, r3
 80098c2:	4621      	mov	r1, r4
 80098c4:	68f8      	ldr	r0, [r7, #12]
 80098c6:	f000 f9c3 	bl	8009c50 <lv_obj_set_pos>
        }
    }

    /*Send a signal to the parent to notify it about the new child*/
    if(parent != NULL) {
 80098ca:	687b      	ldr	r3, [r7, #4]
 80098cc:	2b00      	cmp	r3, #0
 80098ce:	d008      	beq.n	80098e2 <lv_obj_create+0x5b2>
        parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, new_obj);
 80098d0:	687b      	ldr	r3, [r7, #4]
 80098d2:	69db      	ldr	r3, [r3, #28]
 80098d4:	68fa      	ldr	r2, [r7, #12]
 80098d6:	2101      	movs	r1, #1
 80098d8:	6878      	ldr	r0, [r7, #4]
 80098da:	4798      	blx	r3

        /*Invalidate the area if not screen created*/
        lv_obj_invalidate(new_obj);
 80098dc:	68f8      	ldr	r0, [r7, #12]
 80098de:	f000 f88f 	bl	8009a00 <lv_obj_invalidate>
    }

    LV_LOG_INFO("Object create ready");

    return new_obj;
 80098e2:	68fb      	ldr	r3, [r7, #12]
}
 80098e4:	4618      	mov	r0, r3
 80098e6:	3710      	adds	r7, #16
 80098e8:	46bd      	mov	sp, r7
 80098ea:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 80098ee:	bf00      	nop

080098f0 <lv_obj_del>:
 * Delete 'obj' and all of its children
 * @param obj pointer to an object to delete
 * @return LV_RES_INV because the object is deleted
 */
lv_res_t lv_obj_del(lv_obj_t * obj)
{
 80098f0:	b5b0      	push	{r4, r5, r7, lr}
 80098f2:	b086      	sub	sp, #24
 80098f4:	af00      	add	r7, sp, #0
 80098f6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 80098f8:	6878      	ldr	r0, [r7, #4]
 80098fa:	f016 fbf9 	bl	80200f0 <lv_debug_check_null>
 80098fe:	4603      	mov	r3, r0
 8009900:	f083 0301 	eor.w	r3, r3, #1
 8009904:	b2db      	uxtb	r3, r3
 8009906:	2b00      	cmp	r3, #0
 8009908:	d009      	beq.n	800991e <lv_obj_del+0x2e>
 800990a:	687b      	ldr	r3, [r7, #4]
 800990c:	2200      	movs	r2, #0
 800990e:	461c      	mov	r4, r3
 8009910:	4615      	mov	r5, r2
 8009912:	4622      	mov	r2, r4
 8009914:	462b      	mov	r3, r5
 8009916:	481c      	ldr	r0, [pc, #112]	; (8009988 <lv_obj_del+0x98>)
 8009918:	f016 fbfa 	bl	8020110 <lv_debug_log_error>
 800991c:	e7fe      	b.n	800991c <lv_obj_del+0x2c>
    lv_obj_invalidate(obj);
 800991e:	6878      	ldr	r0, [r7, #4]
 8009920:	f000 f86e 	bl	8009a00 <lv_obj_invalidate>

    lv_disp_t * disp = NULL;
 8009924:	2300      	movs	r3, #0
 8009926:	617b      	str	r3, [r7, #20]
    bool act_scr_del = false;
 8009928:	2300      	movs	r3, #0
 800992a:	74fb      	strb	r3, [r7, #19]
    lv_obj_t * par = lv_obj_get_parent(obj);
 800992c:	6878      	ldr	r0, [r7, #4]
 800992e:	f001 f9f3 	bl	800ad18 <lv_obj_get_parent>
 8009932:	60f8      	str	r0, [r7, #12]
    if(par == NULL) {
 8009934:	68fb      	ldr	r3, [r7, #12]
 8009936:	2b00      	cmp	r3, #0
 8009938:	d10f      	bne.n	800995a <lv_obj_del+0x6a>
        disp = lv_obj_get_disp(obj);
 800993a:	6878      	ldr	r0, [r7, #4]
 800993c:	f001 f99c 	bl	800ac78 <lv_obj_get_disp>
 8009940:	6178      	str	r0, [r7, #20]
        if(!disp) return LV_RES_INV;   /*Shouldn't happen*/
 8009942:	697b      	ldr	r3, [r7, #20]
 8009944:	2b00      	cmp	r3, #0
 8009946:	d101      	bne.n	800994c <lv_obj_del+0x5c>
 8009948:	2300      	movs	r3, #0
 800994a:	e019      	b.n	8009980 <lv_obj_del+0x90>
        if(disp->act_scr == obj) act_scr_del = true;
 800994c:	697b      	ldr	r3, [r7, #20]
 800994e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8009950:	687a      	ldr	r2, [r7, #4]
 8009952:	429a      	cmp	r2, r3
 8009954:	d101      	bne.n	800995a <lv_obj_del+0x6a>
 8009956:	2301      	movs	r3, #1
 8009958:	74fb      	strb	r3, [r7, #19]
    }


    obj_del_core(obj);
 800995a:	6878      	ldr	r0, [r7, #4]
 800995c:	f002 fe25 	bl	800c5aa <obj_del_core>

    /*Send a signal to the parent to notify it about the child delete*/
    if(par) {
 8009960:	68fb      	ldr	r3, [r7, #12]
 8009962:	2b00      	cmp	r3, #0
 8009964:	d005      	beq.n	8009972 <lv_obj_del+0x82>
        par->signal_cb(par, LV_SIGNAL_CHILD_CHG, NULL);
 8009966:	68fb      	ldr	r3, [r7, #12]
 8009968:	69db      	ldr	r3, [r3, #28]
 800996a:	2200      	movs	r2, #0
 800996c:	2101      	movs	r1, #1
 800996e:	68f8      	ldr	r0, [r7, #12]
 8009970:	4798      	blx	r3
    }

    /*Handle if the active screen was deleted*/
    if(act_scr_del)  {
 8009972:	7cfb      	ldrb	r3, [r7, #19]
 8009974:	2b00      	cmp	r3, #0
 8009976:	d002      	beq.n	800997e <lv_obj_del+0x8e>
        disp->act_scr = NULL;
 8009978:	697b      	ldr	r3, [r7, #20]
 800997a:	2200      	movs	r2, #0
 800997c:	63da      	str	r2, [r3, #60]	; 0x3c
    }

    return LV_RES_INV;
 800997e:	2300      	movs	r3, #0
}
 8009980:	4618      	mov	r0, r3
 8009982:	3718      	adds	r7, #24
 8009984:	46bd      	mov	sp, r7
 8009986:	bdb0      	pop	{r4, r5, r7, pc}
 8009988:	0802e42c 	.word	0x0802e42c

0800998c <lv_obj_invalidate_area>:
 * This area will be redrawn by 'lv_refr_task'
 * @param obj pointer to an object
 * @param area the area to redraw
 */
void lv_obj_invalidate_area(const lv_obj_t * obj, const lv_area_t * area)
{
 800998c:	b5b0      	push	{r4, r5, r7, lr}
 800998e:	b086      	sub	sp, #24
 8009990:	af00      	add	r7, sp, #0
 8009992:	6078      	str	r0, [r7, #4]
 8009994:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8009996:	6878      	ldr	r0, [r7, #4]
 8009998:	f016 fbaa 	bl	80200f0 <lv_debug_check_null>
 800999c:	4603      	mov	r3, r0
 800999e:	f083 0301 	eor.w	r3, r3, #1
 80099a2:	b2db      	uxtb	r3, r3
 80099a4:	2b00      	cmp	r3, #0
 80099a6:	d009      	beq.n	80099bc <lv_obj_invalidate_area+0x30>
 80099a8:	687b      	ldr	r3, [r7, #4]
 80099aa:	2200      	movs	r2, #0
 80099ac:	461c      	mov	r4, r3
 80099ae:	4615      	mov	r5, r2
 80099b0:	4622      	mov	r2, r4
 80099b2:	462b      	mov	r3, r5
 80099b4:	4811      	ldr	r0, [pc, #68]	; (80099fc <lv_obj_invalidate_area+0x70>)
 80099b6:	f016 fbab 	bl	8020110 <lv_debug_log_error>
 80099ba:	e7fe      	b.n	80099ba <lv_obj_invalidate_area+0x2e>

    lv_area_t area_tmp;
    lv_area_copy(&area_tmp, area);
 80099bc:	f107 030c 	add.w	r3, r7, #12
 80099c0:	6839      	ldr	r1, [r7, #0]
 80099c2:	4618      	mov	r0, r3
 80099c4:	f7fe fd9e 	bl	8008504 <lv_area_copy>
    bool visible = lv_obj_area_is_visible(obj, &area_tmp);
 80099c8:	f107 030c 	add.w	r3, r7, #12
 80099cc:	4619      	mov	r1, r3
 80099ce:	6878      	ldr	r0, [r7, #4]
 80099d0:	f000 f866 	bl	8009aa0 <lv_obj_area_is_visible>
 80099d4:	4603      	mov	r3, r0
 80099d6:	75fb      	strb	r3, [r7, #23]

    if(visible) _lv_inv_area(lv_obj_get_disp(obj), &area_tmp);
 80099d8:	7dfb      	ldrb	r3, [r7, #23]
 80099da:	2b00      	cmp	r3, #0
 80099dc:	d009      	beq.n	80099f2 <lv_obj_invalidate_area+0x66>
 80099de:	6878      	ldr	r0, [r7, #4]
 80099e0:	f001 f94a 	bl	800ac78 <lv_obj_get_disp>
 80099e4:	4602      	mov	r2, r0
 80099e6:	f107 030c 	add.w	r3, r7, #12
 80099ea:	4619      	mov	r1, r3
 80099ec:	4610      	mov	r0, r2
 80099ee:	f004 fc3f 	bl	800e270 <_lv_inv_area>
}
 80099f2:	bf00      	nop
 80099f4:	3718      	adds	r7, #24
 80099f6:	46bd      	mov	sp, r7
 80099f8:	bdb0      	pop	{r4, r5, r7, pc}
 80099fa:	bf00      	nop
 80099fc:	0802e42c 	.word	0x0802e42c

08009a00 <lv_obj_invalidate>:
/**
 * Mark the object as invalid therefore its current position will be redrawn by 'lv_refr_task'
 * @param obj pointer to an object
 */
void lv_obj_invalidate(const lv_obj_t * obj)
{
 8009a00:	b5b0      	push	{r4, r5, r7, lr}
 8009a02:	b086      	sub	sp, #24
 8009a04:	af00      	add	r7, sp, #0
 8009a06:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8009a08:	6878      	ldr	r0, [r7, #4]
 8009a0a:	f016 fb71 	bl	80200f0 <lv_debug_check_null>
 8009a0e:	4603      	mov	r3, r0
 8009a10:	f083 0301 	eor.w	r3, r3, #1
 8009a14:	b2db      	uxtb	r3, r3
 8009a16:	2b00      	cmp	r3, #0
 8009a18:	d009      	beq.n	8009a2e <lv_obj_invalidate+0x2e>
 8009a1a:	687b      	ldr	r3, [r7, #4]
 8009a1c:	2200      	movs	r2, #0
 8009a1e:	461c      	mov	r4, r3
 8009a20:	4615      	mov	r5, r2
 8009a22:	4622      	mov	r2, r4
 8009a24:	462b      	mov	r3, r5
 8009a26:	481d      	ldr	r0, [pc, #116]	; (8009a9c <lv_obj_invalidate+0x9c>)
 8009a28:	f016 fb72 	bl	8020110 <lv_debug_log_error>
 8009a2c:	e7fe      	b.n	8009a2c <lv_obj_invalidate+0x2c>

    /*Truncate the area to the object*/
    lv_area_t obj_coords;
    lv_coord_t ext_size = obj->ext_draw_pad;
 8009a2e:	687b      	ldr	r3, [r7, #4]
 8009a30:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8009a32:	82fb      	strh	r3, [r7, #22]
    lv_area_copy(&obj_coords, &obj->coords);
 8009a34:	687b      	ldr	r3, [r7, #4]
 8009a36:	f103 0210 	add.w	r2, r3, #16
 8009a3a:	f107 030c 	add.w	r3, r7, #12
 8009a3e:	4611      	mov	r1, r2
 8009a40:	4618      	mov	r0, r3
 8009a42:	f7fe fd5f 	bl	8008504 <lv_area_copy>
    obj_coords.x1 -= ext_size;
 8009a46:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8009a4a:	b29a      	uxth	r2, r3
 8009a4c:	8afb      	ldrh	r3, [r7, #22]
 8009a4e:	1ad3      	subs	r3, r2, r3
 8009a50:	b29b      	uxth	r3, r3
 8009a52:	b21b      	sxth	r3, r3
 8009a54:	81bb      	strh	r3, [r7, #12]
    obj_coords.y1 -= ext_size;
 8009a56:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8009a5a:	b29a      	uxth	r2, r3
 8009a5c:	8afb      	ldrh	r3, [r7, #22]
 8009a5e:	1ad3      	subs	r3, r2, r3
 8009a60:	b29b      	uxth	r3, r3
 8009a62:	b21b      	sxth	r3, r3
 8009a64:	81fb      	strh	r3, [r7, #14]
    obj_coords.x2 += ext_size;
 8009a66:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8009a6a:	b29a      	uxth	r2, r3
 8009a6c:	8afb      	ldrh	r3, [r7, #22]
 8009a6e:	4413      	add	r3, r2
 8009a70:	b29b      	uxth	r3, r3
 8009a72:	b21b      	sxth	r3, r3
 8009a74:	823b      	strh	r3, [r7, #16]
    obj_coords.y2 += ext_size;
 8009a76:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8009a7a:	b29a      	uxth	r2, r3
 8009a7c:	8afb      	ldrh	r3, [r7, #22]
 8009a7e:	4413      	add	r3, r2
 8009a80:	b29b      	uxth	r3, r3
 8009a82:	b21b      	sxth	r3, r3
 8009a84:	827b      	strh	r3, [r7, #18]

    lv_obj_invalidate_area(obj, &obj_coords);
 8009a86:	f107 030c 	add.w	r3, r7, #12
 8009a8a:	4619      	mov	r1, r3
 8009a8c:	6878      	ldr	r0, [r7, #4]
 8009a8e:	f7ff ff7d 	bl	800998c <lv_obj_invalidate_area>

}
 8009a92:	bf00      	nop
 8009a94:	3718      	adds	r7, #24
 8009a96:	46bd      	mov	sp, r7
 8009a98:	bdb0      	pop	{r4, r5, r7, pc}
 8009a9a:	bf00      	nop
 8009a9c:	0802e42c 	.word	0x0802e42c

08009aa0 <lv_obj_area_is_visible>:
 * @param obj pointer to an object
 * @param area the are to check. The visible part of the area will be written back here.
 * @return true: visible; false: not visible (hidden, out of parent, on other screen, etc)
 */
bool lv_obj_area_is_visible(const lv_obj_t * obj, lv_area_t * area)
{
 8009aa0:	b580      	push	{r7, lr}
 8009aa2:	b088      	sub	sp, #32
 8009aa4:	af00      	add	r7, sp, #0
 8009aa6:	6078      	str	r0, [r7, #4]
 8009aa8:	6039      	str	r1, [r7, #0]
    if(lv_obj_get_hidden(obj)) return false;
 8009aaa:	6878      	ldr	r0, [r7, #4]
 8009aac:	f001 fed8 	bl	800b860 <lv_obj_get_hidden>
 8009ab0:	4603      	mov	r3, r0
 8009ab2:	2b00      	cmp	r3, #0
 8009ab4:	d001      	beq.n	8009aba <lv_obj_area_is_visible+0x1a>
 8009ab6:	2300      	movs	r3, #0
 8009ab8:	e086      	b.n	8009bc8 <lv_obj_area_is_visible+0x128>

    /*Invalidate the object only if it belongs to the curent or previous'*/
    lv_obj_t * obj_scr = lv_obj_get_screen(obj);
 8009aba:	6878      	ldr	r0, [r7, #4]
 8009abc:	f001 f8b2 	bl	800ac24 <lv_obj_get_screen>
 8009ac0:	61b8      	str	r0, [r7, #24]
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
 8009ac2:	69b8      	ldr	r0, [r7, #24]
 8009ac4:	f001 f8d8 	bl	800ac78 <lv_obj_get_disp>
 8009ac8:	6178      	str	r0, [r7, #20]
    if(obj_scr == lv_disp_get_scr_act(disp) ||
 8009aca:	6978      	ldr	r0, [r7, #20]
 8009acc:	f7fe f9e6 	bl	8007e9c <lv_disp_get_scr_act>
 8009ad0:	4602      	mov	r2, r0
 8009ad2:	69bb      	ldr	r3, [r7, #24]
 8009ad4:	4293      	cmp	r3, r2
 8009ad6:	d014      	beq.n	8009b02 <lv_obj_area_is_visible+0x62>
       obj_scr == lv_disp_get_scr_prev(disp) ||
 8009ad8:	6978      	ldr	r0, [r7, #20]
 8009ada:	f7fe f9f4 	bl	8007ec6 <lv_disp_get_scr_prev>
 8009ade:	4602      	mov	r2, r0
    if(obj_scr == lv_disp_get_scr_act(disp) ||
 8009ae0:	69bb      	ldr	r3, [r7, #24]
 8009ae2:	4293      	cmp	r3, r2
 8009ae4:	d00d      	beq.n	8009b02 <lv_obj_area_is_visible+0x62>
       obj_scr == lv_disp_get_layer_top(disp) ||
 8009ae6:	6978      	ldr	r0, [r7, #20]
 8009ae8:	f7fe fa02 	bl	8007ef0 <lv_disp_get_layer_top>
 8009aec:	4602      	mov	r2, r0
       obj_scr == lv_disp_get_scr_prev(disp) ||
 8009aee:	69bb      	ldr	r3, [r7, #24]
 8009af0:	4293      	cmp	r3, r2
 8009af2:	d006      	beq.n	8009b02 <lv_obj_area_is_visible+0x62>
       obj_scr == lv_disp_get_layer_sys(disp)) {
 8009af4:	6978      	ldr	r0, [r7, #20]
 8009af6:	f7fe fa10 	bl	8007f1a <lv_disp_get_layer_sys>
 8009afa:	4602      	mov	r2, r0
       obj_scr == lv_disp_get_layer_top(disp) ||
 8009afc:	69bb      	ldr	r3, [r7, #24]
 8009afe:	4293      	cmp	r3, r2
 8009b00:	d161      	bne.n	8009bc6 <lv_obj_area_is_visible+0x126>

        /*Truncate the area to the object*/
        lv_area_t obj_coords;
        lv_coord_t ext_size = obj->ext_draw_pad;
 8009b02:	687b      	ldr	r3, [r7, #4]
 8009b04:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 8009b06:	827b      	strh	r3, [r7, #18]
        lv_area_copy(&obj_coords, &obj->coords);
 8009b08:	687b      	ldr	r3, [r7, #4]
 8009b0a:	f103 0210 	add.w	r2, r3, #16
 8009b0e:	f107 0308 	add.w	r3, r7, #8
 8009b12:	4611      	mov	r1, r2
 8009b14:	4618      	mov	r0, r3
 8009b16:	f7fe fcf5 	bl	8008504 <lv_area_copy>
        obj_coords.x1 -= ext_size;
 8009b1a:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8009b1e:	b29a      	uxth	r2, r3
 8009b20:	8a7b      	ldrh	r3, [r7, #18]
 8009b22:	1ad3      	subs	r3, r2, r3
 8009b24:	b29b      	uxth	r3, r3
 8009b26:	b21b      	sxth	r3, r3
 8009b28:	813b      	strh	r3, [r7, #8]
        obj_coords.y1 -= ext_size;
 8009b2a:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8009b2e:	b29a      	uxth	r2, r3
 8009b30:	8a7b      	ldrh	r3, [r7, #18]
 8009b32:	1ad3      	subs	r3, r2, r3
 8009b34:	b29b      	uxth	r3, r3
 8009b36:	b21b      	sxth	r3, r3
 8009b38:	817b      	strh	r3, [r7, #10]
        obj_coords.x2 += ext_size;
 8009b3a:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8009b3e:	b29a      	uxth	r2, r3
 8009b40:	8a7b      	ldrh	r3, [r7, #18]
 8009b42:	4413      	add	r3, r2
 8009b44:	b29b      	uxth	r3, r3
 8009b46:	b21b      	sxth	r3, r3
 8009b48:	81bb      	strh	r3, [r7, #12]
        obj_coords.y2 += ext_size;
 8009b4a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8009b4e:	b29a      	uxth	r2, r3
 8009b50:	8a7b      	ldrh	r3, [r7, #18]
 8009b52:	4413      	add	r3, r2
 8009b54:	b29b      	uxth	r3, r3
 8009b56:	b21b      	sxth	r3, r3
 8009b58:	81fb      	strh	r3, [r7, #14]

        bool is_common;

        is_common = _lv_area_intersect(area, area, &obj_coords);
 8009b5a:	f107 0308 	add.w	r3, r7, #8
 8009b5e:	461a      	mov	r2, r3
 8009b60:	6839      	ldr	r1, [r7, #0]
 8009b62:	6838      	ldr	r0, [r7, #0]
 8009b64:	f015 fc82 	bl	801f46c <_lv_area_intersect>
 8009b68:	4603      	mov	r3, r0
 8009b6a:	747b      	strb	r3, [r7, #17]
        if(is_common == false) return false;  /*The area is not on the object*/
 8009b6c:	7c7b      	ldrb	r3, [r7, #17]
 8009b6e:	f083 0301 	eor.w	r3, r3, #1
 8009b72:	b2db      	uxtb	r3, r3
 8009b74:	2b00      	cmp	r3, #0
 8009b76:	d001      	beq.n	8009b7c <lv_obj_area_is_visible+0xdc>
 8009b78:	2300      	movs	r3, #0
 8009b7a:	e025      	b.n	8009bc8 <lv_obj_area_is_visible+0x128>

        /*Truncate recursively to the parents*/
        lv_obj_t * par = lv_obj_get_parent(obj);
 8009b7c:	6878      	ldr	r0, [r7, #4]
 8009b7e:	f001 f8cb 	bl	800ad18 <lv_obj_get_parent>
 8009b82:	61f8      	str	r0, [r7, #28]
        while(par != NULL) {
 8009b84:	e01c      	b.n	8009bc0 <lv_obj_area_is_visible+0x120>
            is_common = _lv_area_intersect(area, area, &par->coords);
 8009b86:	69fb      	ldr	r3, [r7, #28]
 8009b88:	3310      	adds	r3, #16
 8009b8a:	461a      	mov	r2, r3
 8009b8c:	6839      	ldr	r1, [r7, #0]
 8009b8e:	6838      	ldr	r0, [r7, #0]
 8009b90:	f015 fc6c 	bl	801f46c <_lv_area_intersect>
 8009b94:	4603      	mov	r3, r0
 8009b96:	747b      	strb	r3, [r7, #17]
            if(is_common == false) return false;       /*If no common parts with parent break;*/
 8009b98:	7c7b      	ldrb	r3, [r7, #17]
 8009b9a:	f083 0301 	eor.w	r3, r3, #1
 8009b9e:	b2db      	uxtb	r3, r3
 8009ba0:	2b00      	cmp	r3, #0
 8009ba2:	d001      	beq.n	8009ba8 <lv_obj_area_is_visible+0x108>
 8009ba4:	2300      	movs	r3, #0
 8009ba6:	e00f      	b.n	8009bc8 <lv_obj_area_is_visible+0x128>
            if(lv_obj_get_hidden(par)) return false; /*If the parent is hidden then the child is hidden and won't be drawn*/
 8009ba8:	69f8      	ldr	r0, [r7, #28]
 8009baa:	f001 fe59 	bl	800b860 <lv_obj_get_hidden>
 8009bae:	4603      	mov	r3, r0
 8009bb0:	2b00      	cmp	r3, #0
 8009bb2:	d001      	beq.n	8009bb8 <lv_obj_area_is_visible+0x118>
 8009bb4:	2300      	movs	r3, #0
 8009bb6:	e007      	b.n	8009bc8 <lv_obj_area_is_visible+0x128>

            par = lv_obj_get_parent(par);
 8009bb8:	69f8      	ldr	r0, [r7, #28]
 8009bba:	f001 f8ad 	bl	800ad18 <lv_obj_get_parent>
 8009bbe:	61f8      	str	r0, [r7, #28]
        while(par != NULL) {
 8009bc0:	69fb      	ldr	r3, [r7, #28]
 8009bc2:	2b00      	cmp	r3, #0
 8009bc4:	d1df      	bne.n	8009b86 <lv_obj_area_is_visible+0xe6>
        }
    }

    return true;
 8009bc6:	2301      	movs	r3, #1
}
 8009bc8:	4618      	mov	r0, r3
 8009bca:	3720      	adds	r7, #32
 8009bcc:	46bd      	mov	sp, r7
 8009bce:	bd80      	pop	{r7, pc}

08009bd0 <lv_obj_move_foreground>:
/**
 * Move and object to the foreground
 * @param obj pointer to an object
 */
void lv_obj_move_foreground(lv_obj_t * obj)
{
 8009bd0:	b5b0      	push	{r4, r5, r7, lr}
 8009bd2:	b084      	sub	sp, #16
 8009bd4:	af00      	add	r7, sp, #0
 8009bd6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8009bd8:	6878      	ldr	r0, [r7, #4]
 8009bda:	f016 fa89 	bl	80200f0 <lv_debug_check_null>
 8009bde:	4603      	mov	r3, r0
 8009be0:	f083 0301 	eor.w	r3, r3, #1
 8009be4:	b2db      	uxtb	r3, r3
 8009be6:	2b00      	cmp	r3, #0
 8009be8:	d009      	beq.n	8009bfe <lv_obj_move_foreground+0x2e>
 8009bea:	687b      	ldr	r3, [r7, #4]
 8009bec:	2200      	movs	r2, #0
 8009bee:	461c      	mov	r4, r3
 8009bf0:	4615      	mov	r5, r2
 8009bf2:	4622      	mov	r2, r4
 8009bf4:	462b      	mov	r3, r5
 8009bf6:	4815      	ldr	r0, [pc, #84]	; (8009c4c <lv_obj_move_foreground+0x7c>)
 8009bf8:	f016 fa8a 	bl	8020110 <lv_debug_log_error>
 8009bfc:	e7fe      	b.n	8009bfc <lv_obj_move_foreground+0x2c>

    lv_obj_t * parent = lv_obj_get_parent(obj);
 8009bfe:	6878      	ldr	r0, [r7, #4]
 8009c00:	f001 f88a 	bl	800ad18 <lv_obj_get_parent>
 8009c04:	60f8      	str	r0, [r7, #12]

    /*Do nothing of already in the foreground*/
    if(_lv_ll_get_head(&parent->child_ll) == obj) return;
 8009c06:	68fb      	ldr	r3, [r7, #12]
 8009c08:	3304      	adds	r3, #4
 8009c0a:	4618      	mov	r0, r3
 8009c0c:	f016 fe26 	bl	802085c <_lv_ll_get_head>
 8009c10:	4602      	mov	r2, r0
 8009c12:	687b      	ldr	r3, [r7, #4]
 8009c14:	4293      	cmp	r3, r2
 8009c16:	d014      	beq.n	8009c42 <lv_obj_move_foreground+0x72>

    lv_obj_invalidate(parent);
 8009c18:	68f8      	ldr	r0, [r7, #12]
 8009c1a:	f7ff fef1 	bl	8009a00 <lv_obj_invalidate>

    _lv_ll_chg_list(&parent->child_ll, &parent->child_ll, obj, true);
 8009c1e:	68fb      	ldr	r3, [r7, #12]
 8009c20:	1d18      	adds	r0, r3, #4
 8009c22:	68fb      	ldr	r3, [r7, #12]
 8009c24:	1d19      	adds	r1, r3, #4
 8009c26:	2301      	movs	r3, #1
 8009c28:	687a      	ldr	r2, [r7, #4]
 8009c2a:	f016 fdc2 	bl	80207b2 <_lv_ll_chg_list>

    /*Notify the new parent about the child*/
    parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, obj);
 8009c2e:	68fb      	ldr	r3, [r7, #12]
 8009c30:	69db      	ldr	r3, [r3, #28]
 8009c32:	687a      	ldr	r2, [r7, #4]
 8009c34:	2101      	movs	r1, #1
 8009c36:	68f8      	ldr	r0, [r7, #12]
 8009c38:	4798      	blx	r3

    lv_obj_invalidate(parent);
 8009c3a:	68f8      	ldr	r0, [r7, #12]
 8009c3c:	f7ff fee0 	bl	8009a00 <lv_obj_invalidate>
 8009c40:	e000      	b.n	8009c44 <lv_obj_move_foreground+0x74>
    if(_lv_ll_get_head(&parent->child_ll) == obj) return;
 8009c42:	bf00      	nop
}
 8009c44:	3710      	adds	r7, #16
 8009c46:	46bd      	mov	sp, r7
 8009c48:	bdb0      	pop	{r4, r5, r7, pc}
 8009c4a:	bf00      	nop
 8009c4c:	0802e42c 	.word	0x0802e42c

08009c50 <lv_obj_set_pos>:
 * @param obj pointer to an object
 * @param x new distance from the left side of the parent
 * @param y new distance from the top of the parent
 */
void lv_obj_set_pos(lv_obj_t * obj, lv_coord_t x, lv_coord_t y)
{
 8009c50:	b5b0      	push	{r4, r5, r7, lr}
 8009c52:	b086      	sub	sp, #24
 8009c54:	af00      	add	r7, sp, #0
 8009c56:	6078      	str	r0, [r7, #4]
 8009c58:	460b      	mov	r3, r1
 8009c5a:	807b      	strh	r3, [r7, #2]
 8009c5c:	4613      	mov	r3, r2
 8009c5e:	803b      	strh	r3, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8009c60:	6878      	ldr	r0, [r7, #4]
 8009c62:	f016 fa45 	bl	80200f0 <lv_debug_check_null>
 8009c66:	4603      	mov	r3, r0
 8009c68:	f083 0301 	eor.w	r3, r3, #1
 8009c6c:	b2db      	uxtb	r3, r3
 8009c6e:	2b00      	cmp	r3, #0
 8009c70:	d009      	beq.n	8009c86 <lv_obj_set_pos+0x36>
 8009c72:	687b      	ldr	r3, [r7, #4]
 8009c74:	2200      	movs	r2, #0
 8009c76:	461c      	mov	r4, r3
 8009c78:	4615      	mov	r5, r2
 8009c7a:	4622      	mov	r2, r4
 8009c7c:	462b      	mov	r3, r5
 8009c7e:	4846      	ldr	r0, [pc, #280]	; (8009d98 <lv_obj_set_pos+0x148>)
 8009c80:	f016 fa46 	bl	8020110 <lv_debug_log_error>
 8009c84:	e7fe      	b.n	8009c84 <lv_obj_set_pos+0x34>

    /*Convert x and y to absolute coordinates*/
    lv_obj_t * par = obj->parent;
 8009c86:	687b      	ldr	r3, [r7, #4]
 8009c88:	681b      	ldr	r3, [r3, #0]
 8009c8a:	617b      	str	r3, [r7, #20]

    if(par) {
 8009c8c:	697b      	ldr	r3, [r7, #20]
 8009c8e:	2b00      	cmp	r3, #0
 8009c90:	d00f      	beq.n	8009cb2 <lv_obj_set_pos+0x62>
        x = x + par->coords.x1;
 8009c92:	697b      	ldr	r3, [r7, #20]
 8009c94:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8009c98:	b29a      	uxth	r2, r3
 8009c9a:	887b      	ldrh	r3, [r7, #2]
 8009c9c:	4413      	add	r3, r2
 8009c9e:	b29b      	uxth	r3, r3
 8009ca0:	807b      	strh	r3, [r7, #2]
        y = y + par->coords.y1;
 8009ca2:	697b      	ldr	r3, [r7, #20]
 8009ca4:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8009ca8:	b29a      	uxth	r2, r3
 8009caa:	883b      	ldrh	r3, [r7, #0]
 8009cac:	4413      	add	r3, r2
 8009cae:	b29b      	uxth	r3, r3
 8009cb0:	803b      	strh	r3, [r7, #0]
    }


    /*Calculate and set the movement*/
    lv_point_t diff;
    diff.x = x - obj->coords.x1;
 8009cb2:	887a      	ldrh	r2, [r7, #2]
 8009cb4:	687b      	ldr	r3, [r7, #4]
 8009cb6:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8009cba:	b29b      	uxth	r3, r3
 8009cbc:	1ad3      	subs	r3, r2, r3
 8009cbe:	b29b      	uxth	r3, r3
 8009cc0:	b21b      	sxth	r3, r3
 8009cc2:	823b      	strh	r3, [r7, #16]
    diff.y = y - obj->coords.y1;
 8009cc4:	883a      	ldrh	r2, [r7, #0]
 8009cc6:	687b      	ldr	r3, [r7, #4]
 8009cc8:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8009ccc:	b29b      	uxth	r3, r3
 8009cce:	1ad3      	subs	r3, r2, r3
 8009cd0:	b29b      	uxth	r3, r3
 8009cd2:	b21b      	sxth	r3, r3
 8009cd4:	827b      	strh	r3, [r7, #18]

    /* Do nothing if the position is not changed */
    /* It is very important else recursive positioning can
     * occur without position change*/
    if(diff.x == 0 && diff.y == 0) return;
 8009cd6:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8009cda:	2b00      	cmp	r3, #0
 8009cdc:	d103      	bne.n	8009ce6 <lv_obj_set_pos+0x96>
 8009cde:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8009ce2:	2b00      	cmp	r3, #0
 8009ce4:	d054      	beq.n	8009d90 <lv_obj_set_pos+0x140>

    /*Invalidate the original area*/
    lv_obj_invalidate(obj);
 8009ce6:	6878      	ldr	r0, [r7, #4]
 8009ce8:	f7ff fe8a 	bl	8009a00 <lv_obj_invalidate>

    /*Save the original coordinates*/
    lv_area_t ori;
    lv_obj_get_coords(obj, &ori);
 8009cec:	f107 0308 	add.w	r3, r7, #8
 8009cf0:	4619      	mov	r1, r3
 8009cf2:	6878      	ldr	r0, [r7, #4]
 8009cf4:	f001 f862 	bl	800adbc <lv_obj_get_coords>

    obj->coords.x1 += diff.x;
 8009cf8:	687b      	ldr	r3, [r7, #4]
 8009cfa:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8009cfe:	b29a      	uxth	r2, r3
 8009d00:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8009d04:	b29b      	uxth	r3, r3
 8009d06:	4413      	add	r3, r2
 8009d08:	b29b      	uxth	r3, r3
 8009d0a:	b21a      	sxth	r2, r3
 8009d0c:	687b      	ldr	r3, [r7, #4]
 8009d0e:	821a      	strh	r2, [r3, #16]
    obj->coords.y1 += diff.y;
 8009d10:	687b      	ldr	r3, [r7, #4]
 8009d12:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8009d16:	b29a      	uxth	r2, r3
 8009d18:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8009d1c:	b29b      	uxth	r3, r3
 8009d1e:	4413      	add	r3, r2
 8009d20:	b29b      	uxth	r3, r3
 8009d22:	b21a      	sxth	r2, r3
 8009d24:	687b      	ldr	r3, [r7, #4]
 8009d26:	825a      	strh	r2, [r3, #18]
    obj->coords.x2 += diff.x;
 8009d28:	687b      	ldr	r3, [r7, #4]
 8009d2a:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8009d2e:	b29a      	uxth	r2, r3
 8009d30:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8009d34:	b29b      	uxth	r3, r3
 8009d36:	4413      	add	r3, r2
 8009d38:	b29b      	uxth	r3, r3
 8009d3a:	b21a      	sxth	r2, r3
 8009d3c:	687b      	ldr	r3, [r7, #4]
 8009d3e:	829a      	strh	r2, [r3, #20]
    obj->coords.y2 += diff.y;
 8009d40:	687b      	ldr	r3, [r7, #4]
 8009d42:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8009d46:	b29a      	uxth	r2, r3
 8009d48:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8009d4c:	b29b      	uxth	r3, r3
 8009d4e:	4413      	add	r3, r2
 8009d50:	b29b      	uxth	r3, r3
 8009d52:	b21a      	sxth	r2, r3
 8009d54:	687b      	ldr	r3, [r7, #4]
 8009d56:	82da      	strh	r2, [r3, #22]

    refresh_children_position(obj, diff.x, diff.y);
 8009d58:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8009d5c:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 8009d60:	4619      	mov	r1, r3
 8009d62:	6878      	ldr	r0, [r7, #4]
 8009d64:	f002 ff2a 	bl	800cbbc <refresh_children_position>

    /*Inform the object about its new coordinates*/
    obj->signal_cb(obj, LV_SIGNAL_COORD_CHG, &ori);
 8009d68:	687b      	ldr	r3, [r7, #4]
 8009d6a:	69db      	ldr	r3, [r3, #28]
 8009d6c:	f107 0208 	add.w	r2, r7, #8
 8009d70:	2102      	movs	r1, #2
 8009d72:	6878      	ldr	r0, [r7, #4]
 8009d74:	4798      	blx	r3

    /*Send a signal to the parent too*/
    if(par) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
 8009d76:	697b      	ldr	r3, [r7, #20]
 8009d78:	2b00      	cmp	r3, #0
 8009d7a:	d005      	beq.n	8009d88 <lv_obj_set_pos+0x138>
 8009d7c:	697b      	ldr	r3, [r7, #20]
 8009d7e:	69db      	ldr	r3, [r3, #28]
 8009d80:	687a      	ldr	r2, [r7, #4]
 8009d82:	2101      	movs	r1, #1
 8009d84:	6978      	ldr	r0, [r7, #20]
 8009d86:	4798      	blx	r3

    /*Invalidate the new area*/
    lv_obj_invalidate(obj);
 8009d88:	6878      	ldr	r0, [r7, #4]
 8009d8a:	f7ff fe39 	bl	8009a00 <lv_obj_invalidate>
 8009d8e:	e000      	b.n	8009d92 <lv_obj_set_pos+0x142>
    if(diff.x == 0 && diff.y == 0) return;
 8009d90:	bf00      	nop
}
 8009d92:	3718      	adds	r7, #24
 8009d94:	46bd      	mov	sp, r7
 8009d96:	bdb0      	pop	{r4, r5, r7, pc}
 8009d98:	0802e42c 	.word	0x0802e42c

08009d9c <lv_obj_set_x>:
 * Set the x coordinate of a object
 * @param obj pointer to an object
 * @param x new distance from the left side from the parent
 */
void lv_obj_set_x(lv_obj_t * obj, lv_coord_t x)
{
 8009d9c:	b5b0      	push	{r4, r5, r7, lr}
 8009d9e:	b082      	sub	sp, #8
 8009da0:	af00      	add	r7, sp, #0
 8009da2:	6078      	str	r0, [r7, #4]
 8009da4:	460b      	mov	r3, r1
 8009da6:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8009da8:	6878      	ldr	r0, [r7, #4]
 8009daa:	f016 f9a1 	bl	80200f0 <lv_debug_check_null>
 8009dae:	4603      	mov	r3, r0
 8009db0:	f083 0301 	eor.w	r3, r3, #1
 8009db4:	b2db      	uxtb	r3, r3
 8009db6:	2b00      	cmp	r3, #0
 8009db8:	d009      	beq.n	8009dce <lv_obj_set_x+0x32>
 8009dba:	687b      	ldr	r3, [r7, #4]
 8009dbc:	2200      	movs	r2, #0
 8009dbe:	461c      	mov	r4, r3
 8009dc0:	4615      	mov	r5, r2
 8009dc2:	4622      	mov	r2, r4
 8009dc4:	462b      	mov	r3, r5
 8009dc6:	4809      	ldr	r0, [pc, #36]	; (8009dec <lv_obj_set_x+0x50>)
 8009dc8:	f016 f9a2 	bl	8020110 <lv_debug_log_error>
 8009dcc:	e7fe      	b.n	8009dcc <lv_obj_set_x+0x30>

    lv_obj_set_pos(obj, x, lv_obj_get_y(obj));
 8009dce:	6878      	ldr	r0, [r7, #4]
 8009dd0:	f001 f84e 	bl	800ae70 <lv_obj_get_y>
 8009dd4:	4603      	mov	r3, r0
 8009dd6:	461a      	mov	r2, r3
 8009dd8:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8009ddc:	4619      	mov	r1, r3
 8009dde:	6878      	ldr	r0, [r7, #4]
 8009de0:	f7ff ff36 	bl	8009c50 <lv_obj_set_pos>
}
 8009de4:	bf00      	nop
 8009de6:	3708      	adds	r7, #8
 8009de8:	46bd      	mov	sp, r7
 8009dea:	bdb0      	pop	{r4, r5, r7, pc}
 8009dec:	0802e42c 	.word	0x0802e42c

08009df0 <lv_obj_set_y>:
 * Set the y coordinate of a object
 * @param obj pointer to an object
 * @param y new distance from the top of the parent
 */
void lv_obj_set_y(lv_obj_t * obj, lv_coord_t y)
{
 8009df0:	b5b0      	push	{r4, r5, r7, lr}
 8009df2:	b082      	sub	sp, #8
 8009df4:	af00      	add	r7, sp, #0
 8009df6:	6078      	str	r0, [r7, #4]
 8009df8:	460b      	mov	r3, r1
 8009dfa:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8009dfc:	6878      	ldr	r0, [r7, #4]
 8009dfe:	f016 f977 	bl	80200f0 <lv_debug_check_null>
 8009e02:	4603      	mov	r3, r0
 8009e04:	f083 0301 	eor.w	r3, r3, #1
 8009e08:	b2db      	uxtb	r3, r3
 8009e0a:	2b00      	cmp	r3, #0
 8009e0c:	d009      	beq.n	8009e22 <lv_obj_set_y+0x32>
 8009e0e:	687b      	ldr	r3, [r7, #4]
 8009e10:	2200      	movs	r2, #0
 8009e12:	461c      	mov	r4, r3
 8009e14:	4615      	mov	r5, r2
 8009e16:	4622      	mov	r2, r4
 8009e18:	462b      	mov	r3, r5
 8009e1a:	4809      	ldr	r0, [pc, #36]	; (8009e40 <lv_obj_set_y+0x50>)
 8009e1c:	f016 f978 	bl	8020110 <lv_debug_log_error>
 8009e20:	e7fe      	b.n	8009e20 <lv_obj_set_y+0x30>

    lv_obj_set_pos(obj, lv_obj_get_x(obj), y);
 8009e22:	6878      	ldr	r0, [r7, #4]
 8009e24:	f000 ffee 	bl	800ae04 <lv_obj_get_x>
 8009e28:	4603      	mov	r3, r0
 8009e2a:	4619      	mov	r1, r3
 8009e2c:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8009e30:	461a      	mov	r2, r3
 8009e32:	6878      	ldr	r0, [r7, #4]
 8009e34:	f7ff ff0c 	bl	8009c50 <lv_obj_set_pos>
}
 8009e38:	bf00      	nop
 8009e3a:	3708      	adds	r7, #8
 8009e3c:	46bd      	mov	sp, r7
 8009e3e:	bdb0      	pop	{r4, r5, r7, pc}
 8009e40:	0802e42c 	.word	0x0802e42c

08009e44 <lv_obj_set_size>:
 * @param obj pointer to an object
 * @param w new width
 * @param h new height
 */
void lv_obj_set_size(lv_obj_t * obj, lv_coord_t w, lv_coord_t h)
{
 8009e44:	b5b0      	push	{r4, r5, r7, lr}
 8009e46:	b086      	sub	sp, #24
 8009e48:	af00      	add	r7, sp, #0
 8009e4a:	6078      	str	r0, [r7, #4]
 8009e4c:	460b      	mov	r3, r1
 8009e4e:	807b      	strh	r3, [r7, #2]
 8009e50:	4613      	mov	r3, r2
 8009e52:	803b      	strh	r3, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8009e54:	6878      	ldr	r0, [r7, #4]
 8009e56:	f016 f94b 	bl	80200f0 <lv_debug_check_null>
 8009e5a:	4603      	mov	r3, r0
 8009e5c:	f083 0301 	eor.w	r3, r3, #1
 8009e60:	b2db      	uxtb	r3, r3
 8009e62:	2b00      	cmp	r3, #0
 8009e64:	d009      	beq.n	8009e7a <lv_obj_set_size+0x36>
 8009e66:	687b      	ldr	r3, [r7, #4]
 8009e68:	2200      	movs	r2, #0
 8009e6a:	461c      	mov	r4, r3
 8009e6c:	4615      	mov	r5, r2
 8009e6e:	4622      	mov	r2, r4
 8009e70:	462b      	mov	r3, r5
 8009e72:	4844      	ldr	r0, [pc, #272]	; (8009f84 <lv_obj_set_size+0x140>)
 8009e74:	f016 f94c 	bl	8020110 <lv_debug_log_error>
 8009e78:	e7fe      	b.n	8009e78 <lv_obj_set_size+0x34>

    /* Do nothing if the size is not changed */
    /* It is very important else recursive resizing can
     * occur without size change*/
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
 8009e7a:	6878      	ldr	r0, [r7, #4]
 8009e7c:	f001 f82e 	bl	800aedc <lv_obj_get_width>
 8009e80:	4603      	mov	r3, r0
 8009e82:	461a      	mov	r2, r3
 8009e84:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8009e88:	4293      	cmp	r3, r2
 8009e8a:	d108      	bne.n	8009e9e <lv_obj_set_size+0x5a>
 8009e8c:	6878      	ldr	r0, [r7, #4]
 8009e8e:	f001 f849 	bl	800af24 <lv_obj_get_height>
 8009e92:	4603      	mov	r3, r0
 8009e94:	461a      	mov	r2, r3
 8009e96:	f9b7 3000 	ldrsh.w	r3, [r7]
 8009e9a:	4293      	cmp	r3, r2
 8009e9c:	d06e      	beq.n	8009f7c <lv_obj_set_size+0x138>
        return;
    }

    /*Invalidate the original area*/
    lv_obj_invalidate(obj);
 8009e9e:	6878      	ldr	r0, [r7, #4]
 8009ea0:	f7ff fdae 	bl	8009a00 <lv_obj_invalidate>

    /*Save the original coordinates*/
    lv_area_t ori;
    lv_obj_get_coords(obj, &ori);
 8009ea4:	f107 0308 	add.w	r3, r7, #8
 8009ea8:	4619      	mov	r1, r3
 8009eaa:	6878      	ldr	r0, [r7, #4]
 8009eac:	f000 ff86 	bl	800adbc <lv_obj_get_coords>

    /*Set the length and height*/
    obj->coords.y2 = obj->coords.y1 + h - 1;
 8009eb0:	687b      	ldr	r3, [r7, #4]
 8009eb2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8009eb6:	b29a      	uxth	r2, r3
 8009eb8:	883b      	ldrh	r3, [r7, #0]
 8009eba:	4413      	add	r3, r2
 8009ebc:	b29b      	uxth	r3, r3
 8009ebe:	3b01      	subs	r3, #1
 8009ec0:	b29b      	uxth	r3, r3
 8009ec2:	b21a      	sxth	r2, r3
 8009ec4:	687b      	ldr	r3, [r7, #4]
 8009ec6:	82da      	strh	r2, [r3, #22]
    if(lv_obj_get_base_dir(obj) == LV_BIDI_DIR_RTL) {
 8009ec8:	6878      	ldr	r0, [r7, #4]
 8009eca:	f001 fd07 	bl	800b8dc <lv_obj_get_base_dir>
 8009ece:	4603      	mov	r3, r0
 8009ed0:	2b01      	cmp	r3, #1
 8009ed2:	d10c      	bne.n	8009eee <lv_obj_set_size+0xaa>
        obj->coords.x1 = obj->coords.x2 - w + 1;
 8009ed4:	687b      	ldr	r3, [r7, #4]
 8009ed6:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8009eda:	b29a      	uxth	r2, r3
 8009edc:	887b      	ldrh	r3, [r7, #2]
 8009ede:	1ad3      	subs	r3, r2, r3
 8009ee0:	b29b      	uxth	r3, r3
 8009ee2:	3301      	adds	r3, #1
 8009ee4:	b29b      	uxth	r3, r3
 8009ee6:	b21a      	sxth	r2, r3
 8009ee8:	687b      	ldr	r3, [r7, #4]
 8009eea:	821a      	strh	r2, [r3, #16]
 8009eec:	e00b      	b.n	8009f06 <lv_obj_set_size+0xc2>
    }
    else {
        obj->coords.x2 = obj->coords.x1 + w - 1;
 8009eee:	687b      	ldr	r3, [r7, #4]
 8009ef0:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8009ef4:	b29a      	uxth	r2, r3
 8009ef6:	887b      	ldrh	r3, [r7, #2]
 8009ef8:	4413      	add	r3, r2
 8009efa:	b29b      	uxth	r3, r3
 8009efc:	3b01      	subs	r3, #1
 8009efe:	b29b      	uxth	r3, r3
 8009f00:	b21a      	sxth	r2, r3
 8009f02:	687b      	ldr	r3, [r7, #4]
 8009f04:	829a      	strh	r2, [r3, #20]
    }

    /*Send a signal to the object with its new coordinates*/
    obj->signal_cb(obj, LV_SIGNAL_COORD_CHG, &ori);
 8009f06:	687b      	ldr	r3, [r7, #4]
 8009f08:	69db      	ldr	r3, [r3, #28]
 8009f0a:	f107 0208 	add.w	r2, r7, #8
 8009f0e:	2102      	movs	r1, #2
 8009f10:	6878      	ldr	r0, [r7, #4]
 8009f12:	4798      	blx	r3

    /*Send a signal to the parent too*/
    lv_obj_t * par = lv_obj_get_parent(obj);
 8009f14:	6878      	ldr	r0, [r7, #4]
 8009f16:	f000 feff 	bl	800ad18 <lv_obj_get_parent>
 8009f1a:	6138      	str	r0, [r7, #16]
    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
 8009f1c:	693b      	ldr	r3, [r7, #16]
 8009f1e:	2b00      	cmp	r3, #0
 8009f20:	d005      	beq.n	8009f2e <lv_obj_set_size+0xea>
 8009f22:	693b      	ldr	r3, [r7, #16]
 8009f24:	69db      	ldr	r3, [r3, #28]
 8009f26:	687a      	ldr	r2, [r7, #4]
 8009f28:	2101      	movs	r1, #1
 8009f2a:	6938      	ldr	r0, [r7, #16]
 8009f2c:	4798      	blx	r3

    /*Tell the children the parent's size has changed*/
    lv_obj_t * i;
    _LV_LL_READ(obj->child_ll, i) {
 8009f2e:	687b      	ldr	r3, [r7, #4]
 8009f30:	3304      	adds	r3, #4
 8009f32:	4618      	mov	r0, r3
 8009f34:	f016 fc92 	bl	802085c <_lv_ll_get_head>
 8009f38:	6178      	str	r0, [r7, #20]
 8009f3a:	e00d      	b.n	8009f58 <lv_obj_set_size+0x114>
        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG,  &ori);
 8009f3c:	697b      	ldr	r3, [r7, #20]
 8009f3e:	69db      	ldr	r3, [r3, #28]
 8009f40:	f107 0208 	add.w	r2, r7, #8
 8009f44:	2103      	movs	r1, #3
 8009f46:	6978      	ldr	r0, [r7, #20]
 8009f48:	4798      	blx	r3
    _LV_LL_READ(obj->child_ll, i) {
 8009f4a:	687b      	ldr	r3, [r7, #4]
 8009f4c:	3304      	adds	r3, #4
 8009f4e:	6979      	ldr	r1, [r7, #20]
 8009f50:	4618      	mov	r0, r3
 8009f52:	f016 fca9 	bl	80208a8 <_lv_ll_get_next>
 8009f56:	6178      	str	r0, [r7, #20]
 8009f58:	697b      	ldr	r3, [r7, #20]
 8009f5a:	2b00      	cmp	r3, #0
 8009f5c:	d1ee      	bne.n	8009f3c <lv_obj_set_size+0xf8>
    }

    /*Invalidate the new area*/
    lv_obj_invalidate(obj);
 8009f5e:	6878      	ldr	r0, [r7, #4]
 8009f60:	f7ff fd4e 	bl	8009a00 <lv_obj_invalidate>

    /*Automatically realign the object if required*/
#if LV_USE_OBJ_REALIGN
    if(obj->realign.auto_realign) lv_obj_realign(obj);
 8009f64:	687b      	ldr	r3, [r7, #4]
 8009f66:	f893 3049 	ldrb.w	r3, [r3, #73]	; 0x49
 8009f6a:	f003 0301 	and.w	r3, r3, #1
 8009f6e:	b2db      	uxtb	r3, r3
 8009f70:	2b00      	cmp	r3, #0
 8009f72:	d004      	beq.n	8009f7e <lv_obj_set_size+0x13a>
 8009f74:	6878      	ldr	r0, [r7, #4]
 8009f76:	f000 f8f9 	bl	800a16c <lv_obj_realign>
 8009f7a:	e000      	b.n	8009f7e <lv_obj_set_size+0x13a>
        return;
 8009f7c:	bf00      	nop
#endif
}
 8009f7e:	3718      	adds	r7, #24
 8009f80:	46bd      	mov	sp, r7
 8009f82:	bdb0      	pop	{r4, r5, r7, pc}
 8009f84:	0802e42c 	.word	0x0802e42c

08009f88 <lv_obj_set_height>:
 * Set the height of an object
 * @param obj pointer to an object
 * @param h new height
 */
void lv_obj_set_height(lv_obj_t * obj, lv_coord_t h)
{
 8009f88:	b5b0      	push	{r4, r5, r7, lr}
 8009f8a:	b082      	sub	sp, #8
 8009f8c:	af00      	add	r7, sp, #0
 8009f8e:	6078      	str	r0, [r7, #4]
 8009f90:	460b      	mov	r3, r1
 8009f92:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8009f94:	6878      	ldr	r0, [r7, #4]
 8009f96:	f016 f8ab 	bl	80200f0 <lv_debug_check_null>
 8009f9a:	4603      	mov	r3, r0
 8009f9c:	f083 0301 	eor.w	r3, r3, #1
 8009fa0:	b2db      	uxtb	r3, r3
 8009fa2:	2b00      	cmp	r3, #0
 8009fa4:	d009      	beq.n	8009fba <lv_obj_set_height+0x32>
 8009fa6:	687b      	ldr	r3, [r7, #4]
 8009fa8:	2200      	movs	r2, #0
 8009faa:	461c      	mov	r4, r3
 8009fac:	4615      	mov	r5, r2
 8009fae:	4622      	mov	r2, r4
 8009fb0:	462b      	mov	r3, r5
 8009fb2:	4809      	ldr	r0, [pc, #36]	; (8009fd8 <lv_obj_set_height+0x50>)
 8009fb4:	f016 f8ac 	bl	8020110 <lv_debug_log_error>
 8009fb8:	e7fe      	b.n	8009fb8 <lv_obj_set_height+0x30>

    lv_obj_set_size(obj, lv_obj_get_width(obj), h);
 8009fba:	6878      	ldr	r0, [r7, #4]
 8009fbc:	f000 ff8e 	bl	800aedc <lv_obj_get_width>
 8009fc0:	4603      	mov	r3, r0
 8009fc2:	4619      	mov	r1, r3
 8009fc4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8009fc8:	461a      	mov	r2, r3
 8009fca:	6878      	ldr	r0, [r7, #4]
 8009fcc:	f7ff ff3a 	bl	8009e44 <lv_obj_set_size>
}
 8009fd0:	bf00      	nop
 8009fd2:	3708      	adds	r7, #8
 8009fd4:	46bd      	mov	sp, r7
 8009fd6:	bdb0      	pop	{r4, r5, r7, pc}
 8009fd8:	0802e42c 	.word	0x0802e42c

08009fdc <lv_obj_align>:
 * @param align type of alignment (see 'lv_align_t' enum)
 * @param x_ofs x coordinate offset after alignment
 * @param y_ofs y coordinate offset after alignment
 */
void lv_obj_align(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)
{
 8009fdc:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8009fe0:	b088      	sub	sp, #32
 8009fe2:	af04      	add	r7, sp, #16
 8009fe4:	60f8      	str	r0, [r7, #12]
 8009fe6:	60b9      	str	r1, [r7, #8]
 8009fe8:	4611      	mov	r1, r2
 8009fea:	461a      	mov	r2, r3
 8009fec:	460b      	mov	r3, r1
 8009fee:	71fb      	strb	r3, [r7, #7]
 8009ff0:	4613      	mov	r3, r2
 8009ff2:	80bb      	strh	r3, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 8009ff4:	68f8      	ldr	r0, [r7, #12]
 8009ff6:	f016 f87b 	bl	80200f0 <lv_debug_check_null>
 8009ffa:	4603      	mov	r3, r0
 8009ffc:	f083 0301 	eor.w	r3, r3, #1
 800a000:	b2db      	uxtb	r3, r3
 800a002:	2b00      	cmp	r3, #0
 800a004:	d009      	beq.n	800a01a <lv_obj_align+0x3e>
 800a006:	68fb      	ldr	r3, [r7, #12]
 800a008:	2200      	movs	r2, #0
 800a00a:	4698      	mov	r8, r3
 800a00c:	4691      	mov	r9, r2
 800a00e:	4642      	mov	r2, r8
 800a010:	464b      	mov	r3, r9
 800a012:	4823      	ldr	r0, [pc, #140]	; (800a0a0 <lv_obj_align+0xc4>)
 800a014:	f016 f87c 	bl	8020110 <lv_debug_log_error>
 800a018:	e7fe      	b.n	800a018 <lv_obj_align+0x3c>

    if(base == NULL) base = lv_obj_get_parent(obj);
 800a01a:	68bb      	ldr	r3, [r7, #8]
 800a01c:	2b00      	cmp	r3, #0
 800a01e:	d103      	bne.n	800a028 <lv_obj_align+0x4c>
 800a020:	68f8      	ldr	r0, [r7, #12]
 800a022:	f000 fe79 	bl	800ad18 <lv_obj_get_parent>
 800a026:	60b8      	str	r0, [r7, #8]

    LV_ASSERT_OBJ(base, LV_OBJX_NAME);
 800a028:	68b8      	ldr	r0, [r7, #8]
 800a02a:	f016 f861 	bl	80200f0 <lv_debug_check_null>
 800a02e:	4603      	mov	r3, r0
 800a030:	f083 0301 	eor.w	r3, r3, #1
 800a034:	b2db      	uxtb	r3, r3
 800a036:	2b00      	cmp	r3, #0
 800a038:	d009      	beq.n	800a04e <lv_obj_align+0x72>
 800a03a:	68bb      	ldr	r3, [r7, #8]
 800a03c:	2200      	movs	r2, #0
 800a03e:	461c      	mov	r4, r3
 800a040:	4615      	mov	r5, r2
 800a042:	4622      	mov	r2, r4
 800a044:	462b      	mov	r3, r5
 800a046:	4816      	ldr	r0, [pc, #88]	; (800a0a0 <lv_obj_align+0xc4>)
 800a048:	f016 f862 	bl	8020110 <lv_debug_log_error>
 800a04c:	e7fe      	b.n	800a04c <lv_obj_align+0x70>

    obj_align_core(obj, base, align, true, true, x_ofs, y_ofs);
 800a04e:	79fa      	ldrb	r2, [r7, #7]
 800a050:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 800a054:	9302      	str	r3, [sp, #8]
 800a056:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 800a05a:	9301      	str	r3, [sp, #4]
 800a05c:	2301      	movs	r3, #1
 800a05e:	9300      	str	r3, [sp, #0]
 800a060:	2301      	movs	r3, #1
 800a062:	68b9      	ldr	r1, [r7, #8]
 800a064:	68f8      	ldr	r0, [r7, #12]
 800a066:	f002 fe70 	bl	800cd4a <obj_align_core>

#if LV_USE_OBJ_REALIGN
    /*Save the last align parameters to use them in `lv_obj_realign`*/
    obj->realign.align       = align;
 800a06a:	68fb      	ldr	r3, [r7, #12]
 800a06c:	79fa      	ldrb	r2, [r7, #7]
 800a06e:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    obj->realign.xofs        = x_ofs;
 800a072:	68fb      	ldr	r3, [r7, #12]
 800a074:	88ba      	ldrh	r2, [r7, #4]
 800a076:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    obj->realign.yofs        = y_ofs;
 800a07a:	68fb      	ldr	r3, [r7, #12]
 800a07c:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 800a07e:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
    obj->realign.base        = base;
 800a082:	68fb      	ldr	r3, [r7, #12]
 800a084:	68ba      	ldr	r2, [r7, #8]
 800a086:	641a      	str	r2, [r3, #64]	; 0x40
    obj->realign.mid_align = 0;
 800a088:	68fa      	ldr	r2, [r7, #12]
 800a08a:	f892 3049 	ldrb.w	r3, [r2, #73]	; 0x49
 800a08e:	f36f 0341 	bfc	r3, #1, #1
 800a092:	f882 3049 	strb.w	r3, [r2, #73]	; 0x49
#endif
}
 800a096:	bf00      	nop
 800a098:	3710      	adds	r7, #16
 800a09a:	46bd      	mov	sp, r7
 800a09c:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 800a0a0:	0802e42c 	.word	0x0802e42c

0800a0a4 <lv_obj_align_mid>:
 * @param align type of alignment (see 'lv_align_t' enum)
 * @param x_ofs x coordinate offset after alignment
 * @param y_ofs y coordinate offset after alignment
 */
void lv_obj_align_mid(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs)
{
 800a0a4:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 800a0a8:	b088      	sub	sp, #32
 800a0aa:	af04      	add	r7, sp, #16
 800a0ac:	60f8      	str	r0, [r7, #12]
 800a0ae:	60b9      	str	r1, [r7, #8]
 800a0b0:	4611      	mov	r1, r2
 800a0b2:	461a      	mov	r2, r3
 800a0b4:	460b      	mov	r3, r1
 800a0b6:	71fb      	strb	r3, [r7, #7]
 800a0b8:	4613      	mov	r3, r2
 800a0ba:	80bb      	strh	r3, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a0bc:	68f8      	ldr	r0, [r7, #12]
 800a0be:	f016 f817 	bl	80200f0 <lv_debug_check_null>
 800a0c2:	4603      	mov	r3, r0
 800a0c4:	f083 0301 	eor.w	r3, r3, #1
 800a0c8:	b2db      	uxtb	r3, r3
 800a0ca:	2b00      	cmp	r3, #0
 800a0cc:	d009      	beq.n	800a0e2 <lv_obj_align_mid+0x3e>
 800a0ce:	68fb      	ldr	r3, [r7, #12]
 800a0d0:	2200      	movs	r2, #0
 800a0d2:	4698      	mov	r8, r3
 800a0d4:	4691      	mov	r9, r2
 800a0d6:	4642      	mov	r2, r8
 800a0d8:	464b      	mov	r3, r9
 800a0da:	4823      	ldr	r0, [pc, #140]	; (800a168 <lv_obj_align_mid+0xc4>)
 800a0dc:	f016 f818 	bl	8020110 <lv_debug_log_error>
 800a0e0:	e7fe      	b.n	800a0e0 <lv_obj_align_mid+0x3c>

    if(base == NULL) {
 800a0e2:	68bb      	ldr	r3, [r7, #8]
 800a0e4:	2b00      	cmp	r3, #0
 800a0e6:	d103      	bne.n	800a0f0 <lv_obj_align_mid+0x4c>
        base = lv_obj_get_parent(obj);
 800a0e8:	68f8      	ldr	r0, [r7, #12]
 800a0ea:	f000 fe15 	bl	800ad18 <lv_obj_get_parent>
 800a0ee:	60b8      	str	r0, [r7, #8]
    }

    LV_ASSERT_OBJ(base, LV_OBJX_NAME);
 800a0f0:	68b8      	ldr	r0, [r7, #8]
 800a0f2:	f015 fffd 	bl	80200f0 <lv_debug_check_null>
 800a0f6:	4603      	mov	r3, r0
 800a0f8:	f083 0301 	eor.w	r3, r3, #1
 800a0fc:	b2db      	uxtb	r3, r3
 800a0fe:	2b00      	cmp	r3, #0
 800a100:	d009      	beq.n	800a116 <lv_obj_align_mid+0x72>
 800a102:	68bb      	ldr	r3, [r7, #8]
 800a104:	2200      	movs	r2, #0
 800a106:	461c      	mov	r4, r3
 800a108:	4615      	mov	r5, r2
 800a10a:	4622      	mov	r2, r4
 800a10c:	462b      	mov	r3, r5
 800a10e:	4816      	ldr	r0, [pc, #88]	; (800a168 <lv_obj_align_mid+0xc4>)
 800a110:	f015 fffe 	bl	8020110 <lv_debug_log_error>
 800a114:	e7fe      	b.n	800a114 <lv_obj_align_mid+0x70>


    obj_align_mid_core(obj, base, align, true, true, x_ofs, y_ofs);
 800a116:	79fa      	ldrb	r2, [r7, #7]
 800a118:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 800a11c:	9302      	str	r3, [sp, #8]
 800a11e:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 800a122:	9301      	str	r3, [sp, #4]
 800a124:	2301      	movs	r3, #1
 800a126:	9300      	str	r3, [sp, #0]
 800a128:	2301      	movs	r3, #1
 800a12a:	68b9      	ldr	r1, [r7, #8]
 800a12c:	68f8      	ldr	r0, [r7, #12]
 800a12e:	f002 fe75 	bl	800ce1c <obj_align_mid_core>

#if LV_USE_OBJ_REALIGN
    /*Save the last align parameters to use them in `lv_obj_realign`*/
    obj->realign.align       = align;
 800a132:	68fb      	ldr	r3, [r7, #12]
 800a134:	79fa      	ldrb	r2, [r7, #7]
 800a136:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    obj->realign.xofs        = x_ofs;
 800a13a:	68fb      	ldr	r3, [r7, #12]
 800a13c:	88ba      	ldrh	r2, [r7, #4]
 800a13e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    obj->realign.yofs        = y_ofs;
 800a142:	68fb      	ldr	r3, [r7, #12]
 800a144:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 800a146:	f8a3 2046 	strh.w	r2, [r3, #70]	; 0x46
    obj->realign.base        = base;
 800a14a:	68fb      	ldr	r3, [r7, #12]
 800a14c:	68ba      	ldr	r2, [r7, #8]
 800a14e:	641a      	str	r2, [r3, #64]	; 0x40
    obj->realign.mid_align = 1;
 800a150:	68fa      	ldr	r2, [r7, #12]
 800a152:	f892 3049 	ldrb.w	r3, [r2, #73]	; 0x49
 800a156:	f043 0302 	orr.w	r3, r3, #2
 800a15a:	f882 3049 	strb.w	r3, [r2, #73]	; 0x49
#endif
}
 800a15e:	bf00      	nop
 800a160:	3710      	adds	r7, #16
 800a162:	46bd      	mov	sp, r7
 800a164:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 800a168:	0802e42c 	.word	0x0802e42c

0800a16c <lv_obj_realign>:
/**
 * Realign the object based on the last `lv_obj_align` parameters.
 * @param obj pointer to an object
 */
void lv_obj_realign(lv_obj_t * obj)
{
 800a16c:	b5b0      	push	{r4, r5, r7, lr}
 800a16e:	b084      	sub	sp, #16
 800a170:	af02      	add	r7, sp, #8
 800a172:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a174:	6878      	ldr	r0, [r7, #4]
 800a176:	f015 ffbb 	bl	80200f0 <lv_debug_check_null>
 800a17a:	4603      	mov	r3, r0
 800a17c:	f083 0301 	eor.w	r3, r3, #1
 800a180:	b2db      	uxtb	r3, r3
 800a182:	2b00      	cmp	r3, #0
 800a184:	d009      	beq.n	800a19a <lv_obj_realign+0x2e>
 800a186:	687b      	ldr	r3, [r7, #4]
 800a188:	2200      	movs	r2, #0
 800a18a:	461c      	mov	r4, r3
 800a18c:	4615      	mov	r5, r2
 800a18e:	4622      	mov	r2, r4
 800a190:	462b      	mov	r3, r5
 800a192:	4818      	ldr	r0, [pc, #96]	; (800a1f4 <lv_obj_realign+0x88>)
 800a194:	f015 ffbc 	bl	8020110 <lv_debug_log_error>
 800a198:	e7fe      	b.n	800a198 <lv_obj_realign+0x2c>

#if LV_USE_OBJ_REALIGN
    if(obj->realign.mid_align)
 800a19a:	687b      	ldr	r3, [r7, #4]
 800a19c:	f893 3049 	ldrb.w	r3, [r3, #73]	; 0x49
 800a1a0:	f003 0302 	and.w	r3, r3, #2
 800a1a4:	b2db      	uxtb	r3, r3
 800a1a6:	2b00      	cmp	r3, #0
 800a1a8:	d010      	beq.n	800a1cc <lv_obj_realign+0x60>
        lv_obj_align_mid(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
 800a1aa:	687b      	ldr	r3, [r7, #4]
 800a1ac:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800a1ae:	687b      	ldr	r3, [r7, #4]
 800a1b0:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
 800a1b4:	687b      	ldr	r3, [r7, #4]
 800a1b6:	f9b3 0044 	ldrsh.w	r0, [r3, #68]	; 0x44
 800a1ba:	687b      	ldr	r3, [r7, #4]
 800a1bc:	f9b3 3046 	ldrsh.w	r3, [r3, #70]	; 0x46
 800a1c0:	9300      	str	r3, [sp, #0]
 800a1c2:	4603      	mov	r3, r0
 800a1c4:	6878      	ldr	r0, [r7, #4]
 800a1c6:	f7ff ff6d 	bl	800a0a4 <lv_obj_align_mid>
        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
#else
    (void)obj;
    LV_LOG_WARN("lv_obj_realign: no effect because LV_USE_OBJ_REALIGN = 0");
#endif
}
 800a1ca:	e00f      	b.n	800a1ec <lv_obj_realign+0x80>
        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
 800a1cc:	687b      	ldr	r3, [r7, #4]
 800a1ce:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800a1d0:	687b      	ldr	r3, [r7, #4]
 800a1d2:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
 800a1d6:	687b      	ldr	r3, [r7, #4]
 800a1d8:	f9b3 0044 	ldrsh.w	r0, [r3, #68]	; 0x44
 800a1dc:	687b      	ldr	r3, [r7, #4]
 800a1de:	f9b3 3046 	ldrsh.w	r3, [r3, #70]	; 0x46
 800a1e2:	9300      	str	r3, [sp, #0]
 800a1e4:	4603      	mov	r3, r0
 800a1e6:	6878      	ldr	r0, [r7, #4]
 800a1e8:	f7ff fef8 	bl	8009fdc <lv_obj_align>
}
 800a1ec:	bf00      	nop
 800a1ee:	3708      	adds	r7, #8
 800a1f0:	46bd      	mov	sp, r7
 800a1f2:	bdb0      	pop	{r4, r5, r7, pc}
 800a1f4:	0802e42c 	.word	0x0802e42c

0800a1f8 <lv_obj_add_style>:
 * @param part the part of the object which style property should be set.
 * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`
 * @param style pointer to a style to add (Only its pointer will be saved)
 */
void lv_obj_add_style(lv_obj_t * obj, uint8_t part, lv_style_t * style)
{
 800a1f8:	b580      	push	{r7, lr}
 800a1fa:	b086      	sub	sp, #24
 800a1fc:	af00      	add	r7, sp, #0
 800a1fe:	60f8      	str	r0, [r7, #12]
 800a200:	460b      	mov	r3, r1
 800a202:	607a      	str	r2, [r7, #4]
 800a204:	72fb      	strb	r3, [r7, #11]
    if(style == NULL) return;
 800a206:	687b      	ldr	r3, [r7, #4]
 800a208:	2b00      	cmp	r3, #0
 800a20a:	d019      	beq.n	800a240 <lv_obj_add_style+0x48>

    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);
 800a20c:	7afb      	ldrb	r3, [r7, #11]
 800a20e:	4619      	mov	r1, r3
 800a210:	68f8      	ldr	r0, [r7, #12]
 800a212:	f000 ff09 	bl	800b028 <lv_obj_get_style_list>
 800a216:	6178      	str	r0, [r7, #20]
    if(style_dsc == NULL) {
 800a218:	697b      	ldr	r3, [r7, #20]
 800a21a:	2b00      	cmp	r3, #0
 800a21c:	d012      	beq.n	800a244 <lv_obj_add_style+0x4c>
        LV_LOG_WARN("Can't find style with part: %d", part);
        return;
    }

    _lv_style_list_add_style(style_dsc, style);
 800a21e:	6879      	ldr	r1, [r7, #4]
 800a220:	6978      	ldr	r0, [r7, #20]
 800a222:	f005 f909 	bl	800f438 <_lv_style_list_add_style>
#if LV_USE_ANIMATION
    trans_del(obj, part, 0xFF, NULL);
 800a226:	7af9      	ldrb	r1, [r7, #11]
 800a228:	2300      	movs	r3, #0
 800a22a:	22ff      	movs	r2, #255	; 0xff
 800a22c:	68f8      	ldr	r0, [r7, #12]
 800a22e:	f003 fa1f 	bl	800d670 <trans_del>
#endif
    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
 800a232:	7afb      	ldrb	r3, [r7, #11]
 800a234:	22ff      	movs	r2, #255	; 0xff
 800a236:	4619      	mov	r1, r3
 800a238:	68f8      	ldr	r0, [r7, #12]
 800a23a:	f000 f861 	bl	800a300 <lv_obj_refresh_style>
 800a23e:	e002      	b.n	800a246 <lv_obj_add_style+0x4e>
    if(style == NULL) return;
 800a240:	bf00      	nop
 800a242:	e000      	b.n	800a246 <lv_obj_add_style+0x4e>
        return;
 800a244:	bf00      	nop
}
 800a246:	3718      	adds	r7, #24
 800a248:	46bd      	mov	sp, r7
 800a24a:	bd80      	pop	{r7, pc}

0800a24c <lv_obj_clean_style_list>:
 * @param obj pointer to an object
 * @param part the part of the object which style list should be reseted.
 * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`
 */
void lv_obj_clean_style_list(lv_obj_t * obj, uint8_t part)
{
 800a24c:	b580      	push	{r7, lr}
 800a24e:	b084      	sub	sp, #16
 800a250:	af00      	add	r7, sp, #0
 800a252:	6078      	str	r0, [r7, #4]
 800a254:	460b      	mov	r3, r1
 800a256:	70fb      	strb	r3, [r7, #3]
    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);
 800a258:	78fb      	ldrb	r3, [r7, #3]
 800a25a:	4619      	mov	r1, r3
 800a25c:	6878      	ldr	r0, [r7, #4]
 800a25e:	f000 fee3 	bl	800b028 <lv_obj_get_style_list>
 800a262:	60f8      	str	r0, [r7, #12]
    if(style_dsc == NULL) {
 800a264:	68fb      	ldr	r3, [r7, #12]
 800a266:	2b00      	cmp	r3, #0
 800a268:	d009      	beq.n	800a27e <lv_obj_clean_style_list+0x32>
        LV_LOG_WARN("lv_obj_clean_style_list: can't find style with `part`");
        return;
    }

    _lv_style_list_reset(style_dsc);
 800a26a:	68f8      	ldr	r0, [r7, #12]
 800a26c:	f005 fa28 	bl	800f6c0 <_lv_style_list_reset>
#if LV_USE_ANIMATION
    trans_del(obj, part, 0xFF, NULL);
 800a270:	78f9      	ldrb	r1, [r7, #3]
 800a272:	2300      	movs	r3, #0
 800a274:	22ff      	movs	r2, #255	; 0xff
 800a276:	6878      	ldr	r0, [r7, #4]
 800a278:	f003 f9fa 	bl	800d670 <trans_del>
 800a27c:	e000      	b.n	800a280 <lv_obj_clean_style_list+0x34>
        return;
 800a27e:	bf00      	nop
#endif
}
 800a280:	3710      	adds	r7, #16
 800a282:	46bd      	mov	sp, r7
 800a284:	bd80      	pop	{r7, pc}

0800a286 <lv_obj_reset_style_list>:
 * @param obj pointer to an object
 * @param part the part of the object which style list should be reseted.
 * E.g. `LV_OBJ_PART_MAIN`, `LV_BTN_PART_MAIN`, `LV_SLIDER_PART_KNOB`
 */
void lv_obj_reset_style_list(lv_obj_t * obj, uint8_t part)
{
 800a286:	b580      	push	{r7, lr}
 800a288:	b082      	sub	sp, #8
 800a28a:	af00      	add	r7, sp, #0
 800a28c:	6078      	str	r0, [r7, #4]
 800a28e:	460b      	mov	r3, r1
 800a290:	70fb      	strb	r3, [r7, #3]
    lv_obj_clean_style_list(obj, part);
 800a292:	78fb      	ldrb	r3, [r7, #3]
 800a294:	4619      	mov	r1, r3
 800a296:	6878      	ldr	r0, [r7, #4]
 800a298:	f7ff ffd8 	bl	800a24c <lv_obj_clean_style_list>

    lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
 800a29c:	78fb      	ldrb	r3, [r7, #3]
 800a29e:	22ff      	movs	r2, #255	; 0xff
 800a2a0:	4619      	mov	r1, r3
 800a2a2:	6878      	ldr	r0, [r7, #4]
 800a2a4:	f000 f82c 	bl	800a300 <lv_obj_refresh_style>
}
 800a2a8:	bf00      	nop
 800a2aa:	3708      	adds	r7, #8
 800a2ac:	46bd      	mov	sp, r7
 800a2ae:	bd80      	pop	{r7, pc}

0800a2b0 <_lv_obj_set_style_local_ptr>:
 * @note shouldn't be used directly. Use the specific property get functions instead.
 *       For example: `lv_obj_style_get_border_opa()`
 * @note for performance reasons it's not checked if the property really has pointer type
 */
void _lv_obj_set_style_local_ptr(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, const void * value)
{
 800a2b0:	b580      	push	{r7, lr}
 800a2b2:	b086      	sub	sp, #24
 800a2b4:	af00      	add	r7, sp, #0
 800a2b6:	60f8      	str	r0, [r7, #12]
 800a2b8:	607b      	str	r3, [r7, #4]
 800a2ba:	460b      	mov	r3, r1
 800a2bc:	72fb      	strb	r3, [r7, #11]
 800a2be:	4613      	mov	r3, r2
 800a2c0:	813b      	strh	r3, [r7, #8]
    lv_style_list_t * style_dsc = lv_obj_get_style_list(obj, part);
 800a2c2:	7afb      	ldrb	r3, [r7, #11]
 800a2c4:	4619      	mov	r1, r3
 800a2c6:	68f8      	ldr	r0, [r7, #12]
 800a2c8:	f000 feae 	bl	800b028 <lv_obj_get_style_list>
 800a2cc:	6178      	str	r0, [r7, #20]
    _lv_style_list_set_local_ptr(style_dsc, prop, value);
 800a2ce:	893b      	ldrh	r3, [r7, #8]
 800a2d0:	687a      	ldr	r2, [r7, #4]
 800a2d2:	4619      	mov	r1, r3
 800a2d4:	6978      	ldr	r0, [r7, #20]
 800a2d6:	f005 fe5d 	bl	800ff94 <_lv_style_list_set_local_ptr>
#if LV_USE_ANIMATION
    trans_del(obj, part, prop, NULL);
 800a2da:	893a      	ldrh	r2, [r7, #8]
 800a2dc:	7af9      	ldrb	r1, [r7, #11]
 800a2de:	2300      	movs	r3, #0
 800a2e0:	68f8      	ldr	r0, [r7, #12]
 800a2e2:	f003 f9c5 	bl	800d670 <trans_del>
#endif
    lv_obj_refresh_style(obj, part, prop & (~LV_STYLE_STATE_MASK));
 800a2e6:	893b      	ldrh	r3, [r7, #8]
 800a2e8:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800a2ec:	b29a      	uxth	r2, r3
 800a2ee:	7afb      	ldrb	r3, [r7, #11]
 800a2f0:	4619      	mov	r1, r3
 800a2f2:	68f8      	ldr	r0, [r7, #12]
 800a2f4:	f000 f804 	bl	800a300 <lv_obj_refresh_style>
}
 800a2f8:	bf00      	nop
 800a2fa:	3718      	adds	r7, #24
 800a2fc:	46bd      	mov	sp, r7
 800a2fe:	bd80      	pop	{r7, pc}

0800a300 <lv_obj_refresh_style>:
 * @param obj pointer to an object
 * @param part the part of the object which style property should be refreshed.
 * @param prop `LV_STYLE_PROP_ALL` or an `LV_STYLE_...` property. It is used to optimize what needs to be refreshed.
 */
void lv_obj_refresh_style(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)
{
 800a300:	b5b0      	push	{r4, r5, r7, lr}
 800a302:	b084      	sub	sp, #16
 800a304:	af00      	add	r7, sp, #0
 800a306:	6078      	str	r0, [r7, #4]
 800a308:	460b      	mov	r3, r1
 800a30a:	70fb      	strb	r3, [r7, #3]
 800a30c:	4613      	mov	r3, r2
 800a30e:	803b      	strh	r3, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a310:	6878      	ldr	r0, [r7, #4]
 800a312:	f015 feed 	bl	80200f0 <lv_debug_check_null>
 800a316:	4603      	mov	r3, r0
 800a318:	f083 0301 	eor.w	r3, r3, #1
 800a31c:	b2db      	uxtb	r3, r3
 800a31e:	2b00      	cmp	r3, #0
 800a320:	d009      	beq.n	800a336 <lv_obj_refresh_style+0x36>
 800a322:	687b      	ldr	r3, [r7, #4]
 800a324:	2200      	movs	r2, #0
 800a326:	461c      	mov	r4, r3
 800a328:	4615      	mov	r5, r2
 800a32a:	4622      	mov	r2, r4
 800a32c:	462b      	mov	r3, r5
 800a32e:	4848      	ldr	r0, [pc, #288]	; (800a450 <lv_obj_refresh_style+0x150>)
 800a330:	f015 feee 	bl	8020110 <lv_debug_log_error>
 800a334:	e7fe      	b.n	800a334 <lv_obj_refresh_style+0x34>

    invalidate_style_cache(obj, part, prop);
 800a336:	883a      	ldrh	r2, [r7, #0]
 800a338:	78fb      	ldrb	r3, [r7, #3]
 800a33a:	4619      	mov	r1, r3
 800a33c:	6878      	ldr	r0, [r7, #4]
 800a33e:	f003 feb2 	bl	800e0a6 <invalidate_style_cache>

    /*If a real style refresh is required*/
    bool real_refr = false;
 800a342:	2300      	movs	r3, #0
 800a344:	73fb      	strb	r3, [r7, #15]
    switch(prop) {
 800a346:	883b      	ldrh	r3, [r7, #0]
 800a348:	f248 028e 	movw	r2, #32910	; 0x808e
 800a34c:	4293      	cmp	r3, r2
 800a34e:	d043      	beq.n	800a3d8 <lv_obj_refresh_style+0xd8>
 800a350:	f248 028e 	movw	r2, #32910	; 0x808e
 800a354:	4293      	cmp	r3, r2
 800a356:	dc42      	bgt.n	800a3de <lv_obj_refresh_style+0xde>
 800a358:	f248 0281 	movw	r2, #32897	; 0x8081
 800a35c:	4293      	cmp	r3, r2
 800a35e:	dc3e      	bgt.n	800a3de <lv_obj_refresh_style+0xde>
 800a360:	f248 0280 	movw	r2, #32896	; 0x8080
 800a364:	4293      	cmp	r3, r2
 800a366:	da37      	bge.n	800a3d8 <lv_obj_refresh_style+0xd8>
 800a368:	2bff      	cmp	r3, #255	; 0xff
 800a36a:	d035      	beq.n	800a3d8 <lv_obj_refresh_style+0xd8>
 800a36c:	2bff      	cmp	r3, #255	; 0xff
 800a36e:	dc36      	bgt.n	800a3de <lv_obj_refresh_style+0xde>
 800a370:	2b90      	cmp	r3, #144	; 0x90
 800a372:	dc34      	bgt.n	800a3de <lv_obj_refresh_style+0xde>
 800a374:	2b73      	cmp	r3, #115	; 0x73
 800a376:	da10      	bge.n	800a39a <lv_obj_refresh_style+0x9a>
 800a378:	2b71      	cmp	r3, #113	; 0x71
 800a37a:	dc30      	bgt.n	800a3de <lv_obj_refresh_style+0xde>
 800a37c:	2b70      	cmp	r3, #112	; 0x70
 800a37e:	da2b      	bge.n	800a3d8 <lv_obj_refresh_style+0xd8>
 800a380:	2b5c      	cmp	r3, #92	; 0x5c
 800a382:	d029      	beq.n	800a3d8 <lv_obj_refresh_style+0xd8>
 800a384:	2b5c      	cmp	r3, #92	; 0x5c
 800a386:	dc2a      	bgt.n	800a3de <lv_obj_refresh_style+0xde>
 800a388:	2b53      	cmp	r3, #83	; 0x53
 800a38a:	dc28      	bgt.n	800a3de <lv_obj_refresh_style+0xde>
 800a38c:	2b40      	cmp	r3, #64	; 0x40
 800a38e:	da12      	bge.n	800a3b6 <lv_obj_refresh_style+0xb6>
 800a390:	2b07      	cmp	r3, #7
 800a392:	dc1e      	bgt.n	800a3d2 <lv_obj_refresh_style+0xd2>
 800a394:	2b02      	cmp	r3, #2
 800a396:	da1f      	bge.n	800a3d8 <lv_obj_refresh_style+0xd8>
 800a398:	e021      	b.n	800a3de <lv_obj_refresh_style+0xde>
 800a39a:	3b73      	subs	r3, #115	; 0x73
 800a39c:	4a2d      	ldr	r2, [pc, #180]	; (800a454 <lv_obj_refresh_style+0x154>)
 800a39e:	fa22 f303 	lsr.w	r3, r2, r3
 800a3a2:	f003 0301 	and.w	r3, r3, #1
 800a3a6:	2b00      	cmp	r3, #0
 800a3a8:	bf14      	ite	ne
 800a3aa:	2301      	movne	r3, #1
 800a3ac:	2300      	moveq	r3, #0
 800a3ae:	b2db      	uxtb	r3, r3
 800a3b0:	2b00      	cmp	r3, #0
 800a3b2:	d111      	bne.n	800a3d8 <lv_obj_refresh_style+0xd8>
 800a3b4:	e013      	b.n	800a3de <lv_obj_refresh_style+0xde>
 800a3b6:	3b40      	subs	r3, #64	; 0x40
 800a3b8:	4a27      	ldr	r2, [pc, #156]	; (800a458 <lv_obj_refresh_style+0x158>)
 800a3ba:	fa22 f303 	lsr.w	r3, r2, r3
 800a3be:	f003 0301 	and.w	r3, r3, #1
 800a3c2:	2b00      	cmp	r3, #0
 800a3c4:	bf14      	ite	ne
 800a3c6:	2301      	movne	r3, #1
 800a3c8:	2300      	moveq	r3, #0
 800a3ca:	b2db      	uxtb	r3, r3
 800a3cc:	2b00      	cmp	r3, #0
 800a3ce:	d103      	bne.n	800a3d8 <lv_obj_refresh_style+0xd8>
 800a3d0:	e005      	b.n	800a3de <lv_obj_refresh_style+0xde>
 800a3d2:	3b10      	subs	r3, #16
 800a3d4:	2b08      	cmp	r3, #8
 800a3d6:	d802      	bhi.n	800a3de <lv_obj_refresh_style+0xde>
        case LV_STYLE_VALUE_OPA:
        case LV_STYLE_TEXT_LETTER_SPACE:
        case LV_STYLE_TEXT_LINE_SPACE:
        case LV_STYLE_TEXT_FONT:
        case LV_STYLE_LINE_WIDTH:
            real_refr = true;
 800a3d8:	2301      	movs	r3, #1
 800a3da:	73fb      	strb	r3, [r7, #15]
            break;
 800a3dc:	e001      	b.n	800a3e2 <lv_obj_refresh_style+0xe2>
        default:
            real_refr = false;
 800a3de:	2300      	movs	r3, #0
 800a3e0:	73fb      	strb	r3, [r7, #15]
    }

    if(real_refr) {
 800a3e2:	7bfb      	ldrb	r3, [r7, #15]
 800a3e4:	2b00      	cmp	r3, #0
 800a3e6:	d02b      	beq.n	800a440 <lv_obj_refresh_style+0x140>
        lv_obj_invalidate(obj);
 800a3e8:	6878      	ldr	r0, [r7, #4]
 800a3ea:	f7ff fb09 	bl	8009a00 <lv_obj_invalidate>
        obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);
 800a3ee:	687b      	ldr	r3, [r7, #4]
 800a3f0:	69db      	ldr	r3, [r3, #28]
 800a3f2:	2200      	movs	r2, #0
 800a3f4:	2104      	movs	r1, #4
 800a3f6:	6878      	ldr	r0, [r7, #4]
 800a3f8:	4798      	blx	r3

        switch(prop) {
 800a3fa:	883b      	ldrh	r3, [r7, #0]
 800a3fc:	2b18      	cmp	r3, #24
 800a3fe:	dc02      	bgt.n	800a406 <lv_obj_refresh_style+0x106>
 800a400:	2b15      	cmp	r3, #21
 800a402:	da02      	bge.n	800a40a <lv_obj_refresh_style+0x10a>
 800a404:	e00e      	b.n	800a424 <lv_obj_refresh_style+0x124>
 800a406:	2bff      	cmp	r3, #255	; 0xff
 800a408:	d10c      	bne.n	800a424 <lv_obj_refresh_style+0x124>
            case LV_STYLE_PROP_ALL:
            case LV_STYLE_MARGIN_TOP:
            case LV_STYLE_MARGIN_BOTTOM:
            case LV_STYLE_MARGIN_LEFT:
            case LV_STYLE_MARGIN_RIGHT:
                if(obj->parent) obj->parent->signal_cb(obj->parent, LV_SIGNAL_CHILD_CHG, NULL);
 800a40a:	687b      	ldr	r3, [r7, #4]
 800a40c:	681b      	ldr	r3, [r3, #0]
 800a40e:	2b00      	cmp	r3, #0
 800a410:	d007      	beq.n	800a422 <lv_obj_refresh_style+0x122>
 800a412:	687b      	ldr	r3, [r7, #4]
 800a414:	681b      	ldr	r3, [r3, #0]
 800a416:	69db      	ldr	r3, [r3, #28]
 800a418:	687a      	ldr	r2, [r7, #4]
 800a41a:	6810      	ldr	r0, [r2, #0]
 800a41c:	2200      	movs	r2, #0
 800a41e:	2101      	movs	r1, #1
 800a420:	4798      	blx	r3
                break;
 800a422:	bf00      	nop
        }

        lv_obj_invalidate(obj);
 800a424:	6878      	ldr	r0, [r7, #4]
 800a426:	f7ff faeb 	bl	8009a00 <lv_obj_invalidate>

        /*Send style change signals*/
        if(prop == LV_STYLE_PROP_ALL || (prop & LV_STYLE_INHERIT_MASK)) refresh_children_style(obj);
 800a42a:	883b      	ldrh	r3, [r7, #0]
 800a42c:	2bff      	cmp	r3, #255	; 0xff
 800a42e:	d003      	beq.n	800a438 <lv_obj_refresh_style+0x138>
 800a430:	f9b7 3000 	ldrsh.w	r3, [r7]
 800a434:	2b00      	cmp	r3, #0
 800a436:	da06      	bge.n	800a446 <lv_obj_refresh_style+0x146>
 800a438:	6878      	ldr	r0, [r7, #4]
 800a43a:	f002 fc60 	bl	800ccfe <refresh_children_style>
    }
    else {
        lv_obj_invalidate(obj);
    }
}
 800a43e:	e002      	b.n	800a446 <lv_obj_refresh_style+0x146>
        lv_obj_invalidate(obj);
 800a440:	6878      	ldr	r0, [r7, #4]
 800a442:	f7ff fadd 	bl	8009a00 <lv_obj_invalidate>
}
 800a446:	bf00      	nop
 800a448:	3710      	adds	r7, #16
 800a44a:	46bd      	mov	sp, r7
 800a44c:	bdb0      	pop	{r4, r5, r7, pc}
 800a44e:	bf00      	nop
 800a450:	0802e42c 	.word	0x0802e42c
 800a454:	20001a07 	.word	0x20001a07
 800a458:	000f1003 	.word	0x000f1003

0800a45c <lv_obj_report_style_mod>:
 * Notify all object if a style is modified
 * @param style pointer to a style. Only the objects with this style will be notified
 *               (NULL to notify all objects)
 */
void lv_obj_report_style_mod(lv_style_t * style)
{
 800a45c:	b580      	push	{r7, lr}
 800a45e:	b084      	sub	sp, #16
 800a460:	af00      	add	r7, sp, #0
 800a462:	6078      	str	r0, [r7, #4]
    lv_disp_t * d = lv_disp_get_next(NULL);
 800a464:	2000      	movs	r0, #0
 800a466:	f014 fbb9 	bl	801ebdc <lv_disp_get_next>
 800a46a:	60f8      	str	r0, [r7, #12]

    while(d) {
 800a46c:	e018      	b.n	800a4a0 <lv_obj_report_style_mod+0x44>
        lv_obj_t * i;
        _LV_LL_READ(d->scr_ll, i) {
 800a46e:	68fb      	ldr	r3, [r7, #12]
 800a470:	3330      	adds	r3, #48	; 0x30
 800a472:	4618      	mov	r0, r3
 800a474:	f016 f9f2 	bl	802085c <_lv_ll_get_head>
 800a478:	60b8      	str	r0, [r7, #8]
 800a47a:	e00a      	b.n	800a492 <lv_obj_report_style_mod+0x36>
            report_style_mod_core(style, i);
 800a47c:	68b9      	ldr	r1, [r7, #8]
 800a47e:	6878      	ldr	r0, [r7, #4]
 800a480:	f002 fbea 	bl	800cc58 <report_style_mod_core>
        _LV_LL_READ(d->scr_ll, i) {
 800a484:	68fb      	ldr	r3, [r7, #12]
 800a486:	3330      	adds	r3, #48	; 0x30
 800a488:	68b9      	ldr	r1, [r7, #8]
 800a48a:	4618      	mov	r0, r3
 800a48c:	f016 fa0c 	bl	80208a8 <_lv_ll_get_next>
 800a490:	60b8      	str	r0, [r7, #8]
 800a492:	68bb      	ldr	r3, [r7, #8]
 800a494:	2b00      	cmp	r3, #0
 800a496:	d1f1      	bne.n	800a47c <lv_obj_report_style_mod+0x20>
        }
        d = lv_disp_get_next(d);
 800a498:	68f8      	ldr	r0, [r7, #12]
 800a49a:	f014 fb9f 	bl	801ebdc <lv_disp_get_next>
 800a49e:	60f8      	str	r0, [r7, #12]
    while(d) {
 800a4a0:	68fb      	ldr	r3, [r7, #12]
 800a4a2:	2b00      	cmp	r3, #0
 800a4a4:	d1e3      	bne.n	800a46e <lv_obj_report_style_mod+0x12>
    }
}
 800a4a6:	bf00      	nop
 800a4a8:	bf00      	nop
 800a4aa:	3710      	adds	r7, #16
 800a4ac:	46bd      	mov	sp, r7
 800a4ae:	bd80      	pop	{r7, pc}

0800a4b0 <lv_obj_set_adv_hittest>:
 * Set whether advanced hit-testing is enabled on an object
 * @param obj pointer to an object
 * @param en true: advanced hit-testing is enabled
 */
void lv_obj_set_adv_hittest(lv_obj_t * obj, bool en)
{
 800a4b0:	b5b0      	push	{r4, r5, r7, lr}
 800a4b2:	b082      	sub	sp, #8
 800a4b4:	af00      	add	r7, sp, #0
 800a4b6:	6078      	str	r0, [r7, #4]
 800a4b8:	460b      	mov	r3, r1
 800a4ba:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a4bc:	6878      	ldr	r0, [r7, #4]
 800a4be:	f015 fe17 	bl	80200f0 <lv_debug_check_null>
 800a4c2:	4603      	mov	r3, r0
 800a4c4:	f083 0301 	eor.w	r3, r3, #1
 800a4c8:	b2db      	uxtb	r3, r3
 800a4ca:	2b00      	cmp	r3, #0
 800a4cc:	d009      	beq.n	800a4e2 <lv_obj_set_adv_hittest+0x32>
 800a4ce:	687b      	ldr	r3, [r7, #4]
 800a4d0:	2200      	movs	r2, #0
 800a4d2:	461c      	mov	r4, r3
 800a4d4:	4615      	mov	r5, r2
 800a4d6:	4622      	mov	r2, r4
 800a4d8:	462b      	mov	r3, r5
 800a4da:	480c      	ldr	r0, [pc, #48]	; (800a50c <lv_obj_set_adv_hittest+0x5c>)
 800a4dc:	f015 fe18 	bl	8020110 <lv_debug_log_error>
 800a4e0:	e7fe      	b.n	800a4e0 <lv_obj_set_adv_hittest+0x30>

    obj->adv_hittest = en == false ? 0 : 1;
 800a4e2:	78fb      	ldrb	r3, [r7, #3]
 800a4e4:	f083 0301 	eor.w	r3, r3, #1
 800a4e8:	b2db      	uxtb	r3, r3
 800a4ea:	2b00      	cmp	r3, #0
 800a4ec:	d001      	beq.n	800a4f2 <lv_obj_set_adv_hittest+0x42>
 800a4ee:	2100      	movs	r1, #0
 800a4f0:	e000      	b.n	800a4f4 <lv_obj_set_adv_hittest+0x44>
 800a4f2:	2101      	movs	r1, #1
 800a4f4:	687a      	ldr	r2, [r7, #4]
 800a4f6:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 800a4fa:	f361 13c7 	bfi	r3, r1, #7, #1
 800a4fe:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
}
 800a502:	bf00      	nop
 800a504:	3708      	adds	r7, #8
 800a506:	46bd      	mov	sp, r7
 800a508:	bdb0      	pop	{r4, r5, r7, pc}
 800a50a:	bf00      	nop
 800a50c:	0802e42c 	.word	0x0802e42c

0800a510 <lv_obj_set_click>:
 * Enable or disable the clicking of an object
 * @param obj pointer to an object
 * @param en true: make the object clickable
 */
void lv_obj_set_click(lv_obj_t * obj, bool en)
{
 800a510:	b5b0      	push	{r4, r5, r7, lr}
 800a512:	b082      	sub	sp, #8
 800a514:	af00      	add	r7, sp, #0
 800a516:	6078      	str	r0, [r7, #4]
 800a518:	460b      	mov	r3, r1
 800a51a:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a51c:	6878      	ldr	r0, [r7, #4]
 800a51e:	f015 fde7 	bl	80200f0 <lv_debug_check_null>
 800a522:	4603      	mov	r3, r0
 800a524:	f083 0301 	eor.w	r3, r3, #1
 800a528:	b2db      	uxtb	r3, r3
 800a52a:	2b00      	cmp	r3, #0
 800a52c:	d009      	beq.n	800a542 <lv_obj_set_click+0x32>
 800a52e:	687b      	ldr	r3, [r7, #4]
 800a530:	2200      	movs	r2, #0
 800a532:	461c      	mov	r4, r3
 800a534:	4615      	mov	r5, r2
 800a536:	4622      	mov	r2, r4
 800a538:	462b      	mov	r3, r5
 800a53a:	4808      	ldr	r0, [pc, #32]	; (800a55c <lv_obj_set_click+0x4c>)
 800a53c:	f015 fde8 	bl	8020110 <lv_debug_log_error>
 800a540:	e7fe      	b.n	800a540 <lv_obj_set_click+0x30>

    obj->click = (en == true ? 1 : 0);
 800a542:	78f9      	ldrb	r1, [r7, #3]
 800a544:	687a      	ldr	r2, [r7, #4]
 800a546:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 800a54a:	f361 0300 	bfi	r3, r1, #0, #1
 800a54e:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
}
 800a552:	bf00      	nop
 800a554:	3708      	adds	r7, #8
 800a556:	46bd      	mov	sp, r7
 800a558:	bdb0      	pop	{r4, r5, r7, pc}
 800a55a:	bf00      	nop
 800a55c:	0802e42c 	.word	0x0802e42c

0800a560 <lv_obj_add_protect>:
 * Set a bit or bits in the protect filed
 * @param obj pointer to an object
 * @param prot 'OR'-ed values from `lv_protect_t`
 */
void lv_obj_add_protect(lv_obj_t * obj, uint8_t prot)
{
 800a560:	b5b0      	push	{r4, r5, r7, lr}
 800a562:	b082      	sub	sp, #8
 800a564:	af00      	add	r7, sp, #0
 800a566:	6078      	str	r0, [r7, #4]
 800a568:	460b      	mov	r3, r1
 800a56a:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a56c:	6878      	ldr	r0, [r7, #4]
 800a56e:	f015 fdbf 	bl	80200f0 <lv_debug_check_null>
 800a572:	4603      	mov	r3, r0
 800a574:	f083 0301 	eor.w	r3, r3, #1
 800a578:	b2db      	uxtb	r3, r3
 800a57a:	2b00      	cmp	r3, #0
 800a57c:	d009      	beq.n	800a592 <lv_obj_add_protect+0x32>
 800a57e:	687b      	ldr	r3, [r7, #4]
 800a580:	2200      	movs	r2, #0
 800a582:	461c      	mov	r4, r3
 800a584:	4615      	mov	r5, r2
 800a586:	4622      	mov	r2, r4
 800a588:	462b      	mov	r3, r5
 800a58a:	4808      	ldr	r0, [pc, #32]	; (800a5ac <lv_obj_add_protect+0x4c>)
 800a58c:	f015 fdc0 	bl	8020110 <lv_debug_log_error>
 800a590:	e7fe      	b.n	800a590 <lv_obj_add_protect+0x30>

    obj->protect |= prot;
 800a592:	687b      	ldr	r3, [r7, #4]
 800a594:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 800a598:	78fb      	ldrb	r3, [r7, #3]
 800a59a:	4313      	orrs	r3, r2
 800a59c:	b2da      	uxtb	r2, r3
 800a59e:	687b      	ldr	r3, [r7, #4]
 800a5a0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 800a5a4:	bf00      	nop
 800a5a6:	3708      	adds	r7, #8
 800a5a8:	46bd      	mov	sp, r7
 800a5aa:	bdb0      	pop	{r4, r5, r7, pc}
 800a5ac:	0802e42c 	.word	0x0802e42c

0800a5b0 <lv_obj_clear_protect>:
 * Clear a bit or bits in the protect filed
 * @param obj pointer to an object
 * @param prot 'OR'-ed values from `lv_protect_t`
 */
void lv_obj_clear_protect(lv_obj_t * obj, uint8_t prot)
{
 800a5b0:	b5b0      	push	{r4, r5, r7, lr}
 800a5b2:	b082      	sub	sp, #8
 800a5b4:	af00      	add	r7, sp, #0
 800a5b6:	6078      	str	r0, [r7, #4]
 800a5b8:	460b      	mov	r3, r1
 800a5ba:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a5bc:	6878      	ldr	r0, [r7, #4]
 800a5be:	f015 fd97 	bl	80200f0 <lv_debug_check_null>
 800a5c2:	4603      	mov	r3, r0
 800a5c4:	f083 0301 	eor.w	r3, r3, #1
 800a5c8:	b2db      	uxtb	r3, r3
 800a5ca:	2b00      	cmp	r3, #0
 800a5cc:	d009      	beq.n	800a5e2 <lv_obj_clear_protect+0x32>
 800a5ce:	687b      	ldr	r3, [r7, #4]
 800a5d0:	2200      	movs	r2, #0
 800a5d2:	461c      	mov	r4, r3
 800a5d4:	4615      	mov	r5, r2
 800a5d6:	4622      	mov	r2, r4
 800a5d8:	462b      	mov	r3, r5
 800a5da:	480a      	ldr	r0, [pc, #40]	; (800a604 <lv_obj_clear_protect+0x54>)
 800a5dc:	f015 fd98 	bl	8020110 <lv_debug_log_error>
 800a5e0:	e7fe      	b.n	800a5e0 <lv_obj_clear_protect+0x30>

    prot = (~prot) & 0xFF;
 800a5e2:	78fb      	ldrb	r3, [r7, #3]
 800a5e4:	43db      	mvns	r3, r3
 800a5e6:	70fb      	strb	r3, [r7, #3]
    obj->protect &= prot;
 800a5e8:	687b      	ldr	r3, [r7, #4]
 800a5ea:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 800a5ee:	78fb      	ldrb	r3, [r7, #3]
 800a5f0:	4013      	ands	r3, r2
 800a5f2:	b2da      	uxtb	r2, r3
 800a5f4:	687b      	ldr	r3, [r7, #4]
 800a5f6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
}
 800a5fa:	bf00      	nop
 800a5fc:	3708      	adds	r7, #8
 800a5fe:	46bd      	mov	sp, r7
 800a600:	bdb0      	pop	{r4, r5, r7, pc}
 800a602:	bf00      	nop
 800a604:	0802e42c 	.word	0x0802e42c

0800a608 <lv_obj_set_state>:
 * from the previous state to the current
 * @param obj pointer to an object
 * @param state the new state
 */
void lv_obj_set_state(lv_obj_t * obj, lv_state_t new_state)
{
 800a608:	b5b0      	push	{r4, r5, r7, lr}
 800a60a:	b09e      	sub	sp, #120	; 0x78
 800a60c:	af02      	add	r7, sp, #8
 800a60e:	6078      	str	r0, [r7, #4]
 800a610:	460b      	mov	r3, r1
 800a612:	70fb      	strb	r3, [r7, #3]
    if(obj->state == new_state) return;
 800a614:	687b      	ldr	r3, [r7, #4]
 800a616:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800a61a:	78fa      	ldrb	r2, [r7, #3]
 800a61c:	429a      	cmp	r2, r3
 800a61e:	f000 811f 	beq.w	800a860 <lv_obj_set_state+0x258>

    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a622:	6878      	ldr	r0, [r7, #4]
 800a624:	f015 fd64 	bl	80200f0 <lv_debug_check_null>
 800a628:	4603      	mov	r3, r0
 800a62a:	f083 0301 	eor.w	r3, r3, #1
 800a62e:	b2db      	uxtb	r3, r3
 800a630:	2b00      	cmp	r3, #0
 800a632:	d009      	beq.n	800a648 <lv_obj_set_state+0x40>
 800a634:	687b      	ldr	r3, [r7, #4]
 800a636:	2200      	movs	r2, #0
 800a638:	461c      	mov	r4, r3
 800a63a:	4615      	mov	r5, r2
 800a63c:	4622      	mov	r2, r4
 800a63e:	462b      	mov	r3, r5
 800a640:	488a      	ldr	r0, [pc, #552]	; (800a86c <lv_obj_set_state+0x264>)
 800a642:	f015 fd65 	bl	8020110 <lv_debug_log_error>
 800a646:	e7fe      	b.n	800a646 <lv_obj_set_state+0x3e>

#if LV_USE_ANIMATION == 0
    obj->state = new_state;
    lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
#else
    lv_state_t prev_state = obj->state;
 800a648:	687b      	ldr	r3, [r7, #4]
 800a64a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800a64e:	f887 306d 	strb.w	r3, [r7, #109]	; 0x6d
    obj->state = new_state;
 800a652:	687b      	ldr	r3, [r7, #4]
 800a654:	78fa      	ldrb	r2, [r7, #3]
 800a656:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    uint8_t part;
    for(part = 0; part < _LV_OBJ_PART_REAL_LAST; part++) {
 800a65a:	2300      	movs	r3, #0
 800a65c:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
 800a660:	e0f8      	b.n	800a854 <lv_obj_set_state+0x24c>
        lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);
 800a662:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a666:	4619      	mov	r1, r3
 800a668:	6878      	ldr	r0, [r7, #4]
 800a66a:	f000 fcdd 	bl	800b028 <lv_obj_get_style_list>
 800a66e:	66b8      	str	r0, [r7, #104]	; 0x68
        if(style_list == NULL) break;   /*No more style lists*/
 800a670:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800a672:	2b00      	cmp	r3, #0
 800a674:	f000 80f6 	beq.w	800a864 <lv_obj_set_state+0x25c>
        if(style_list->ignore_trans) continue;
 800a678:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800a67a:	795b      	ldrb	r3, [r3, #5]
 800a67c:	f003 0302 	and.w	r3, r3, #2
 800a680:	b2db      	uxtb	r3, r3
 800a682:	2b00      	cmp	r3, #0
 800a684:	f040 80e0 	bne.w	800a848 <lv_obj_set_state+0x240>

        lv_style_int_t time = lv_obj_get_style_transition_time(obj, part);
 800a688:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a68c:	4619      	mov	r1, r3
 800a68e:	6878      	ldr	r0, [r7, #4]
 800a690:	f7fe fd53 	bl	800913a <lv_obj_get_style_transition_time>
 800a694:	4603      	mov	r3, r0
 800a696:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
        lv_style_property_t props[LV_STYLE_TRANS_NUM_MAX];
        lv_style_int_t delay = lv_obj_get_style_transition_delay(obj, part);
 800a69a:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a69e:	4619      	mov	r1, r3
 800a6a0:	6878      	ldr	r0, [r7, #4]
 800a6a2:	f7fe fd5b 	bl	800915c <lv_obj_get_style_transition_delay>
 800a6a6:	4603      	mov	r3, r0
 800a6a8:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
        lv_anim_path_t * path = lv_obj_get_style_transition_path(obj, part);
 800a6ac:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a6b0:	4619      	mov	r1, r3
 800a6b2:	6878      	ldr	r0, [r7, #4]
 800a6b4:	f7fe fdc9 	bl	800924a <lv_obj_get_style_transition_path>
 800a6b8:	6638      	str	r0, [r7, #96]	; 0x60
        props[0] = lv_obj_get_style_transition_prop_1(obj, part);
 800a6ba:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a6be:	4619      	mov	r1, r3
 800a6c0:	6878      	ldr	r0, [r7, #4]
 800a6c2:	f7fe fd5c 	bl	800917e <lv_obj_get_style_transition_prop_1>
 800a6c6:	4603      	mov	r3, r0
 800a6c8:	b29b      	uxth	r3, r3
 800a6ca:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
        props[1] = lv_obj_get_style_transition_prop_2(obj, part);
 800a6ce:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a6d2:	4619      	mov	r1, r3
 800a6d4:	6878      	ldr	r0, [r7, #4]
 800a6d6:	f7fe fd63 	bl	80091a0 <lv_obj_get_style_transition_prop_2>
 800a6da:	4603      	mov	r3, r0
 800a6dc:	b29b      	uxth	r3, r3
 800a6de:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
        props[2] = lv_obj_get_style_transition_prop_3(obj, part);
 800a6e2:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a6e6:	4619      	mov	r1, r3
 800a6e8:	6878      	ldr	r0, [r7, #4]
 800a6ea:	f7fe fd6a 	bl	80091c2 <lv_obj_get_style_transition_prop_3>
 800a6ee:	4603      	mov	r3, r0
 800a6f0:	b29b      	uxth	r3, r3
 800a6f2:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
        props[3] = lv_obj_get_style_transition_prop_4(obj, part);
 800a6f6:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a6fa:	4619      	mov	r1, r3
 800a6fc:	6878      	ldr	r0, [r7, #4]
 800a6fe:	f7fe fd71 	bl	80091e4 <lv_obj_get_style_transition_prop_4>
 800a702:	4603      	mov	r3, r0
 800a704:	b29b      	uxth	r3, r3
 800a706:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
        props[4] = lv_obj_get_style_transition_prop_5(obj, part);
 800a70a:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a70e:	4619      	mov	r1, r3
 800a710:	6878      	ldr	r0, [r7, #4]
 800a712:	f7fe fd78 	bl	8009206 <lv_obj_get_style_transition_prop_5>
 800a716:	4603      	mov	r3, r0
 800a718:	b29b      	uxth	r3, r3
 800a71a:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
        props[5] = lv_obj_get_style_transition_prop_6(obj, part);
 800a71e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a722:	4619      	mov	r1, r3
 800a724:	6878      	ldr	r0, [r7, #4]
 800a726:	f7fe fd7f 	bl	8009228 <lv_obj_get_style_transition_prop_6>
 800a72a:	4603      	mov	r3, r0
 800a72c:	b29b      	uxth	r3, r3
 800a72e:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a

        uint8_t i;
        for(i = 0; i < LV_STYLE_TRANS_NUM_MAX; i++) {
 800a732:	2300      	movs	r3, #0
 800a734:	f887 306e 	strb.w	r3, [r7, #110]	; 0x6e
 800a738:	e07a      	b.n	800a830 <lv_obj_set_state+0x228>
            if(props[i] != 0) {
 800a73a:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 800a73e:	005b      	lsls	r3, r3, #1
 800a740:	3370      	adds	r3, #112	; 0x70
 800a742:	443b      	add	r3, r7
 800a744:	f833 3c20 	ldrh.w	r3, [r3, #-32]
 800a748:	2b00      	cmp	r3, #0
 800a74a:	d06c      	beq.n	800a826 <lv_obj_set_state+0x21e>
                _lv_style_list_add_trans_style(style_list);
 800a74c:	6eb8      	ldr	r0, [r7, #104]	; 0x68
 800a74e:	f005 fbcb 	bl	800fee8 <_lv_style_list_add_trans_style>

                lv_style_trans_t * tr = trans_create(obj, props[i], part, prev_state, new_state);
 800a752:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 800a756:	005b      	lsls	r3, r3, #1
 800a758:	3370      	adds	r3, #112	; 0x70
 800a75a:	443b      	add	r3, r7
 800a75c:	f833 1c20 	ldrh.w	r1, [r3, #-32]
 800a760:	f897 006d 	ldrb.w	r0, [r7, #109]	; 0x6d
 800a764:	f897 206f 	ldrb.w	r2, [r7, #111]	; 0x6f
 800a768:	78fb      	ldrb	r3, [r7, #3]
 800a76a:	9300      	str	r3, [sp, #0]
 800a76c:	4603      	mov	r3, r0
 800a76e:	6878      	ldr	r0, [r7, #4]
 800a770:	f002 fd64 	bl	800d23c <trans_create>
 800a774:	65f8      	str	r0, [r7, #92]	; 0x5c

                /*If there is a pending anim for this property remove it*/
                if(tr) {
 800a776:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800a778:	2b00      	cmp	r3, #0
 800a77a:	d054      	beq.n	800a826 <lv_obj_set_state+0x21e>
                    tr->obj = obj;
 800a77c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800a77e:	687a      	ldr	r2, [r7, #4]
 800a780:	601a      	str	r2, [r3, #0]
                    tr->prop = props[i];
 800a782:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 800a786:	005b      	lsls	r3, r3, #1
 800a788:	3370      	adds	r3, #112	; 0x70
 800a78a:	443b      	add	r3, r7
 800a78c:	f833 2c20 	ldrh.w	r2, [r3, #-32]
 800a790:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800a792:	809a      	strh	r2, [r3, #4]
                    tr->part = part;
 800a794:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800a796:	f897 206f 	ldrb.w	r2, [r7, #111]	; 0x6f
 800a79a:	719a      	strb	r2, [r3, #6]

                    lv_anim_t a;
                    lv_anim_init(&a);
 800a79c:	f107 030c 	add.w	r3, r7, #12
 800a7a0:	4618      	mov	r0, r3
 800a7a2:	f014 fb25 	bl	801edf0 <lv_anim_init>
                    lv_anim_set_var(&a, tr);
 800a7a6:	f107 030c 	add.w	r3, r7, #12
 800a7aa:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 800a7ac:	4618      	mov	r0, r3
 800a7ae:	f7fd ff96 	bl	80086de <lv_anim_set_var>
                    lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)trans_anim_cb);
 800a7b2:	f107 030c 	add.w	r3, r7, #12
 800a7b6:	492e      	ldr	r1, [pc, #184]	; (800a870 <lv_obj_set_state+0x268>)
 800a7b8:	4618      	mov	r0, r3
 800a7ba:	f7fd ff9e 	bl	80086fa <lv_anim_set_exec_cb>
                    lv_anim_set_start_cb(&a, trans_anim_start_cb);
 800a7be:	f107 030c 	add.w	r3, r7, #12
 800a7c2:	492c      	ldr	r1, [pc, #176]	; (800a874 <lv_obj_set_state+0x26c>)
 800a7c4:	4618      	mov	r0, r3
 800a7c6:	f7fd ffed 	bl	80087a4 <lv_anim_set_start_cb>
                    lv_anim_set_ready_cb(&a, trans_anim_ready_cb);
 800a7ca:	f107 030c 	add.w	r3, r7, #12
 800a7ce:	492a      	ldr	r1, [pc, #168]	; (800a878 <lv_obj_set_state+0x270>)
 800a7d0:	4618      	mov	r0, r3
 800a7d2:	f7fd fff5 	bl	80087c0 <lv_anim_set_ready_cb>
                    lv_anim_set_values(&a, 0x00, 0xFF);
 800a7d6:	f107 030c 	add.w	r3, r7, #12
 800a7da:	22ff      	movs	r2, #255	; 0xff
 800a7dc:	2100      	movs	r1, #0
 800a7de:	4618      	mov	r0, r3
 800a7e0:	f7fd ffb6 	bl	8008750 <lv_anim_set_values>
                    lv_anim_set_time(&a, time);
 800a7e4:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 800a7e8:	f107 030c 	add.w	r3, r7, #12
 800a7ec:	4611      	mov	r1, r2
 800a7ee:	4618      	mov	r0, r3
 800a7f0:	f7fd ff91 	bl	8008716 <lv_anim_set_time>
                    lv_anim_set_delay(&a, delay);
 800a7f4:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 800a7f8:	f107 030c 	add.w	r3, r7, #12
 800a7fc:	4611      	mov	r1, r2
 800a7fe:	4618      	mov	r0, r3
 800a800:	f7fd ff97 	bl	8008732 <lv_anim_set_delay>
                    lv_anim_set_path(&a, path);
 800a804:	f107 030c 	add.w	r3, r7, #12
 800a808:	6e39      	ldr	r1, [r7, #96]	; 0x60
 800a80a:	4618      	mov	r0, r3
 800a80c:	f7fd ffba 	bl	8008784 <lv_anim_set_path>
                    a.early_apply = 0;
 800a810:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46
 800a814:	f36f 0300 	bfc	r3, #0, #1
 800a818:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
                    lv_anim_start(&a);
 800a81c:	f107 030c 	add.w	r3, r7, #12
 800a820:	4618      	mov	r0, r3
 800a822:	f014 fb0f 	bl	801ee44 <lv_anim_start>
        for(i = 0; i < LV_STYLE_TRANS_NUM_MAX; i++) {
 800a826:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 800a82a:	3301      	adds	r3, #1
 800a82c:	f887 306e 	strb.w	r3, [r7, #110]	; 0x6e
 800a830:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 800a834:	2b05      	cmp	r3, #5
 800a836:	d980      	bls.n	800a73a <lv_obj_set_state+0x132>
                }

            }
        }
        lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
 800a838:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a83c:	22ff      	movs	r2, #255	; 0xff
 800a83e:	4619      	mov	r1, r3
 800a840:	6878      	ldr	r0, [r7, #4]
 800a842:	f7ff fd5d 	bl	800a300 <lv_obj_refresh_style>
 800a846:	e000      	b.n	800a84a <lv_obj_set_state+0x242>
        if(style_list->ignore_trans) continue;
 800a848:	bf00      	nop
    for(part = 0; part < _LV_OBJ_PART_REAL_LAST; part++) {
 800a84a:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a84e:	3301      	adds	r3, #1
 800a850:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
 800a854:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 800a858:	2b3f      	cmp	r3, #63	; 0x3f
 800a85a:	f67f af02 	bls.w	800a662 <lv_obj_set_state+0x5a>
 800a85e:	e002      	b.n	800a866 <lv_obj_set_state+0x25e>
    if(obj->state == new_state) return;
 800a860:	bf00      	nop
 800a862:	e000      	b.n	800a866 <lv_obj_set_state+0x25e>
        if(style_list == NULL) break;   /*No more style lists*/
 800a864:	bf00      	nop
    }
#endif


}
 800a866:	3770      	adds	r7, #112	; 0x70
 800a868:	46bd      	mov	sp, r7
 800a86a:	bdb0      	pop	{r4, r5, r7, pc}
 800a86c:	0802e42c 	.word	0x0802e42c
 800a870:	0800d721 	.word	0x0800d721
 800a874:	0800d899 	.word	0x0800d899
 800a878:	0800d951 	.word	0x0800d951

0800a87c <lv_obj_add_state>:
 * from the previous state to the current
 * @param obj pointer to an object
 * @param state the state bits to add. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`
 */
void lv_obj_add_state(lv_obj_t * obj, lv_state_t state)
{
 800a87c:	b5b0      	push	{r4, r5, r7, lr}
 800a87e:	b084      	sub	sp, #16
 800a880:	af00      	add	r7, sp, #0
 800a882:	6078      	str	r0, [r7, #4]
 800a884:	460b      	mov	r3, r1
 800a886:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a888:	6878      	ldr	r0, [r7, #4]
 800a88a:	f015 fc31 	bl	80200f0 <lv_debug_check_null>
 800a88e:	4603      	mov	r3, r0
 800a890:	f083 0301 	eor.w	r3, r3, #1
 800a894:	b2db      	uxtb	r3, r3
 800a896:	2b00      	cmp	r3, #0
 800a898:	d009      	beq.n	800a8ae <lv_obj_add_state+0x32>
 800a89a:	687b      	ldr	r3, [r7, #4]
 800a89c:	2200      	movs	r2, #0
 800a89e:	461c      	mov	r4, r3
 800a8a0:	4615      	mov	r5, r2
 800a8a2:	4622      	mov	r2, r4
 800a8a4:	462b      	mov	r3, r5
 800a8a6:	480c      	ldr	r0, [pc, #48]	; (800a8d8 <lv_obj_add_state+0x5c>)
 800a8a8:	f015 fc32 	bl	8020110 <lv_debug_log_error>
 800a8ac:	e7fe      	b.n	800a8ac <lv_obj_add_state+0x30>

    lv_state_t new_state = obj->state | state;
 800a8ae:	687b      	ldr	r3, [r7, #4]
 800a8b0:	f893 203d 	ldrb.w	r2, [r3, #61]	; 0x3d
 800a8b4:	78fb      	ldrb	r3, [r7, #3]
 800a8b6:	4313      	orrs	r3, r2
 800a8b8:	73fb      	strb	r3, [r7, #15]
    if(obj->state != new_state) {
 800a8ba:	687b      	ldr	r3, [r7, #4]
 800a8bc:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800a8c0:	7bfa      	ldrb	r2, [r7, #15]
 800a8c2:	429a      	cmp	r2, r3
 800a8c4:	d004      	beq.n	800a8d0 <lv_obj_add_state+0x54>
        lv_obj_set_state(obj, new_state);
 800a8c6:	7bfb      	ldrb	r3, [r7, #15]
 800a8c8:	4619      	mov	r1, r3
 800a8ca:	6878      	ldr	r0, [r7, #4]
 800a8cc:	f7ff fe9c 	bl	800a608 <lv_obj_set_state>
    }
}
 800a8d0:	bf00      	nop
 800a8d2:	3710      	adds	r7, #16
 800a8d4:	46bd      	mov	sp, r7
 800a8d6:	bdb0      	pop	{r4, r5, r7, pc}
 800a8d8:	0802e42c 	.word	0x0802e42c

0800a8dc <lv_obj_clear_state>:
 * from the previous state to the current
 * @param obj pointer to an object
 * @param state the state bits to remove. E.g `LV_STATE_PRESSED | LV_STATE_FOCUSED`
 */
void lv_obj_clear_state(lv_obj_t * obj, lv_state_t state)
{
 800a8dc:	b5b0      	push	{r4, r5, r7, lr}
 800a8de:	b084      	sub	sp, #16
 800a8e0:	af00      	add	r7, sp, #0
 800a8e2:	6078      	str	r0, [r7, #4]
 800a8e4:	460b      	mov	r3, r1
 800a8e6:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a8e8:	6878      	ldr	r0, [r7, #4]
 800a8ea:	f015 fc01 	bl	80200f0 <lv_debug_check_null>
 800a8ee:	4603      	mov	r3, r0
 800a8f0:	f083 0301 	eor.w	r3, r3, #1
 800a8f4:	b2db      	uxtb	r3, r3
 800a8f6:	2b00      	cmp	r3, #0
 800a8f8:	d009      	beq.n	800a90e <lv_obj_clear_state+0x32>
 800a8fa:	687b      	ldr	r3, [r7, #4]
 800a8fc:	2200      	movs	r2, #0
 800a8fe:	461c      	mov	r4, r3
 800a900:	4615      	mov	r5, r2
 800a902:	4622      	mov	r2, r4
 800a904:	462b      	mov	r3, r5
 800a906:	480f      	ldr	r0, [pc, #60]	; (800a944 <lv_obj_clear_state+0x68>)
 800a908:	f015 fc02 	bl	8020110 <lv_debug_log_error>
 800a90c:	e7fe      	b.n	800a90c <lv_obj_clear_state+0x30>

    lv_state_t new_state = obj->state & (~state);
 800a90e:	687b      	ldr	r3, [r7, #4]
 800a910:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800a914:	b25a      	sxtb	r2, r3
 800a916:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800a91a:	43db      	mvns	r3, r3
 800a91c:	b25b      	sxtb	r3, r3
 800a91e:	4013      	ands	r3, r2
 800a920:	b25b      	sxtb	r3, r3
 800a922:	73fb      	strb	r3, [r7, #15]
    if(obj->state != new_state) {
 800a924:	687b      	ldr	r3, [r7, #4]
 800a926:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800a92a:	7bfa      	ldrb	r2, [r7, #15]
 800a92c:	429a      	cmp	r2, r3
 800a92e:	d004      	beq.n	800a93a <lv_obj_clear_state+0x5e>
        lv_obj_set_state(obj, new_state);
 800a930:	7bfb      	ldrb	r3, [r7, #15]
 800a932:	4619      	mov	r1, r3
 800a934:	6878      	ldr	r0, [r7, #4]
 800a936:	f7ff fe67 	bl	800a608 <lv_obj_set_state>
    }
}
 800a93a:	bf00      	nop
 800a93c:	3710      	adds	r7, #16
 800a93e:	46bd      	mov	sp, r7
 800a940:	bdb0      	pop	{r4, r5, r7, pc}
 800a942:	bf00      	nop
 800a944:	0802e42c 	.word	0x0802e42c

0800a948 <lv_event_send>:
 * @param event the type of the event from `lv_event_t`
 * @param data arbitrary data depending on the object type and the event. (Usually `NULL`)
 * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event
 */
lv_res_t lv_event_send(lv_obj_t * obj, lv_event_t event, const void * data)
{
 800a948:	b5b0      	push	{r4, r5, r7, lr}
 800a94a:	b086      	sub	sp, #24
 800a94c:	af00      	add	r7, sp, #0
 800a94e:	60f8      	str	r0, [r7, #12]
 800a950:	460b      	mov	r3, r1
 800a952:	607a      	str	r2, [r7, #4]
 800a954:	72fb      	strb	r3, [r7, #11]
    if(obj == NULL) return LV_RES_OK;
 800a956:	68fb      	ldr	r3, [r7, #12]
 800a958:	2b00      	cmp	r3, #0
 800a95a:	d101      	bne.n	800a960 <lv_event_send+0x18>
 800a95c:	2301      	movs	r3, #1
 800a95e:	e01c      	b.n	800a99a <lv_event_send+0x52>

    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a960:	68f8      	ldr	r0, [r7, #12]
 800a962:	f015 fbc5 	bl	80200f0 <lv_debug_check_null>
 800a966:	4603      	mov	r3, r0
 800a968:	f083 0301 	eor.w	r3, r3, #1
 800a96c:	b2db      	uxtb	r3, r3
 800a96e:	2b00      	cmp	r3, #0
 800a970:	d009      	beq.n	800a986 <lv_event_send+0x3e>
 800a972:	68fb      	ldr	r3, [r7, #12]
 800a974:	2200      	movs	r2, #0
 800a976:	461c      	mov	r4, r3
 800a978:	4615      	mov	r5, r2
 800a97a:	4622      	mov	r2, r4
 800a97c:	462b      	mov	r3, r5
 800a97e:	4809      	ldr	r0, [pc, #36]	; (800a9a4 <lv_event_send+0x5c>)
 800a980:	f015 fbc6 	bl	8020110 <lv_debug_log_error>
 800a984:	e7fe      	b.n	800a984 <lv_event_send+0x3c>

    lv_res_t res;
    res = lv_event_send_func(obj->event_cb, obj, event, data);
 800a986:	68fb      	ldr	r3, [r7, #12]
 800a988:	6998      	ldr	r0, [r3, #24]
 800a98a:	7afa      	ldrb	r2, [r7, #11]
 800a98c:	687b      	ldr	r3, [r7, #4]
 800a98e:	68f9      	ldr	r1, [r7, #12]
 800a990:	f000 f80a 	bl	800a9a8 <lv_event_send_func>
 800a994:	4603      	mov	r3, r0
 800a996:	75fb      	strb	r3, [r7, #23]
    return res;
 800a998:	7dfb      	ldrb	r3, [r7, #23]
}
 800a99a:	4618      	mov	r0, r3
 800a99c:	3718      	adds	r7, #24
 800a99e:	46bd      	mov	sp, r7
 800a9a0:	bdb0      	pop	{r4, r5, r7, pc}
 800a9a2:	bf00      	nop
 800a9a4:	0802e42c 	.word	0x0802e42c

0800a9a8 <lv_event_send_func>:
 * @param event an event
 * @param data pointer to a custom data
 * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event
 */
lv_res_t lv_event_send_func(lv_event_cb_t event_xcb, lv_obj_t * obj, lv_event_t event, const void * data)
{
 800a9a8:	b5b0      	push	{r4, r5, r7, lr}
 800a9aa:	b08a      	sub	sp, #40	; 0x28
 800a9ac:	af00      	add	r7, sp, #0
 800a9ae:	60f8      	str	r0, [r7, #12]
 800a9b0:	60b9      	str	r1, [r7, #8]
 800a9b2:	603b      	str	r3, [r7, #0]
 800a9b4:	4613      	mov	r3, r2
 800a9b6:	71fb      	strb	r3, [r7, #7]
    if(obj != NULL) {
 800a9b8:	68bb      	ldr	r3, [r7, #8]
 800a9ba:	2b00      	cmp	r3, #0
 800a9bc:	d012      	beq.n	800a9e4 <lv_event_send_func+0x3c>
        LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800a9be:	68b8      	ldr	r0, [r7, #8]
 800a9c0:	f015 fb96 	bl	80200f0 <lv_debug_check_null>
 800a9c4:	4603      	mov	r3, r0
 800a9c6:	f083 0301 	eor.w	r3, r3, #1
 800a9ca:	b2db      	uxtb	r3, r3
 800a9cc:	2b00      	cmp	r3, #0
 800a9ce:	d009      	beq.n	800a9e4 <lv_event_send_func+0x3c>
 800a9d0:	68bb      	ldr	r3, [r7, #8]
 800a9d2:	2200      	movs	r2, #0
 800a9d4:	461c      	mov	r4, r3
 800a9d6:	4615      	mov	r5, r2
 800a9d8:	4622      	mov	r2, r4
 800a9da:	462b      	mov	r3, r5
 800a9dc:	4830      	ldr	r0, [pc, #192]	; (800aaa0 <lv_event_send_func+0xf8>)
 800a9de:	f015 fb97 	bl	8020110 <lv_debug_log_error>
 800a9e2:	e7fe      	b.n	800a9e2 <lv_event_send_func+0x3a>

    /* Build a simple linked list from the objects used in the events
     * It's important to know if an this object was deleted by a nested event
     * called from this `even_cb`. */
    lv_event_temp_data_t event_temp_data;
    event_temp_data.obj     = obj;
 800a9e4:	68bb      	ldr	r3, [r7, #8]
 800a9e6:	613b      	str	r3, [r7, #16]
    event_temp_data.deleted = false;
 800a9e8:	2300      	movs	r3, #0
 800a9ea:	753b      	strb	r3, [r7, #20]
    event_temp_data.prev    = NULL;
 800a9ec:	2300      	movs	r3, #0
 800a9ee:	61bb      	str	r3, [r7, #24]

    if(event_temp_data_head) {
 800a9f0:	4b2c      	ldr	r3, [pc, #176]	; (800aaa4 <lv_event_send_func+0xfc>)
 800a9f2:	681b      	ldr	r3, [r3, #0]
 800a9f4:	2b00      	cmp	r3, #0
 800a9f6:	d002      	beq.n	800a9fe <lv_event_send_func+0x56>
        event_temp_data.prev = event_temp_data_head;
 800a9f8:	4b2a      	ldr	r3, [pc, #168]	; (800aaa4 <lv_event_send_func+0xfc>)
 800a9fa:	681b      	ldr	r3, [r3, #0]
 800a9fc:	61bb      	str	r3, [r7, #24]
    }
    event_temp_data_head = &event_temp_data;
 800a9fe:	4a29      	ldr	r2, [pc, #164]	; (800aaa4 <lv_event_send_func+0xfc>)
 800aa00:	f107 0310 	add.w	r3, r7, #16
 800aa04:	6013      	str	r3, [r2, #0]

    const void * event_act_data_save = event_act_data;
 800aa06:	4b28      	ldr	r3, [pc, #160]	; (800aaa8 <lv_event_send_func+0x100>)
 800aa08:	681b      	ldr	r3, [r3, #0]
 800aa0a:	627b      	str	r3, [r7, #36]	; 0x24
    event_act_data                   = data;
 800aa0c:	4a26      	ldr	r2, [pc, #152]	; (800aaa8 <lv_event_send_func+0x100>)
 800aa0e:	683b      	ldr	r3, [r7, #0]
 800aa10:	6013      	str	r3, [r2, #0]

    /*Call the input device's feedback callback if set*/
    lv_indev_t * indev_act = lv_indev_get_act();
 800aa12:	f7fd fceb 	bl	80083ec <lv_indev_get_act>
 800aa16:	6238      	str	r0, [r7, #32]
    if(indev_act) {
 800aa18:	6a3b      	ldr	r3, [r7, #32]
 800aa1a:	2b00      	cmp	r3, #0
 800aa1c:	d009      	beq.n	800aa32 <lv_event_send_func+0x8a>
        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);
 800aa1e:	6a3b      	ldr	r3, [r7, #32]
 800aa20:	689b      	ldr	r3, [r3, #8]
 800aa22:	2b00      	cmp	r3, #0
 800aa24:	d005      	beq.n	800aa32 <lv_event_send_func+0x8a>
 800aa26:	6a3b      	ldr	r3, [r7, #32]
 800aa28:	689b      	ldr	r3, [r3, #8]
 800aa2a:	6a3a      	ldr	r2, [r7, #32]
 800aa2c:	79f9      	ldrb	r1, [r7, #7]
 800aa2e:	4610      	mov	r0, r2
 800aa30:	4798      	blx	r3
    }

    /*Call the event callback itself*/
    if(event_xcb) event_xcb(obj, event);
 800aa32:	68fb      	ldr	r3, [r7, #12]
 800aa34:	2b00      	cmp	r3, #0
 800aa36:	d004      	beq.n	800aa42 <lv_event_send_func+0x9a>
 800aa38:	79fa      	ldrb	r2, [r7, #7]
 800aa3a:	68fb      	ldr	r3, [r7, #12]
 800aa3c:	4611      	mov	r1, r2
 800aa3e:	68b8      	ldr	r0, [r7, #8]
 800aa40:	4798      	blx	r3

    /*Restore the event data*/
    event_act_data = event_act_data_save;
 800aa42:	4a19      	ldr	r2, [pc, #100]	; (800aaa8 <lv_event_send_func+0x100>)
 800aa44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800aa46:	6013      	str	r3, [r2, #0]

    /*Remove this element from the list*/
    event_temp_data_head = event_temp_data_head->prev;
 800aa48:	4b16      	ldr	r3, [pc, #88]	; (800aaa4 <lv_event_send_func+0xfc>)
 800aa4a:	681b      	ldr	r3, [r3, #0]
 800aa4c:	689b      	ldr	r3, [r3, #8]
 800aa4e:	4a15      	ldr	r2, [pc, #84]	; (800aaa4 <lv_event_send_func+0xfc>)
 800aa50:	6013      	str	r3, [r2, #0]

    if(event_temp_data.deleted) {
 800aa52:	7d3b      	ldrb	r3, [r7, #20]
 800aa54:	2b00      	cmp	r3, #0
 800aa56:	d001      	beq.n	800aa5c <lv_event_send_func+0xb4>
        return LV_RES_INV;
 800aa58:	2300      	movs	r3, #0
 800aa5a:	e01d      	b.n	800aa98 <lv_event_send_func+0xf0>
    }

    if(obj) {
 800aa5c:	68bb      	ldr	r3, [r7, #8]
 800aa5e:	2b00      	cmp	r3, #0
 800aa60:	d019      	beq.n	800aa96 <lv_event_send_func+0xee>
        if(obj->parent_event && obj->parent) {
 800aa62:	68bb      	ldr	r3, [r7, #8]
 800aa64:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800aa68:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800aa6c:	b2db      	uxtb	r3, r3
 800aa6e:	2b00      	cmp	r3, #0
 800aa70:	d011      	beq.n	800aa96 <lv_event_send_func+0xee>
 800aa72:	68bb      	ldr	r3, [r7, #8]
 800aa74:	681b      	ldr	r3, [r3, #0]
 800aa76:	2b00      	cmp	r3, #0
 800aa78:	d00d      	beq.n	800aa96 <lv_event_send_func+0xee>
            lv_res_t res = lv_event_send(obj->parent, event, data);
 800aa7a:	68bb      	ldr	r3, [r7, #8]
 800aa7c:	681b      	ldr	r3, [r3, #0]
 800aa7e:	79f9      	ldrb	r1, [r7, #7]
 800aa80:	683a      	ldr	r2, [r7, #0]
 800aa82:	4618      	mov	r0, r3
 800aa84:	f7ff ff60 	bl	800a948 <lv_event_send>
 800aa88:	4603      	mov	r3, r0
 800aa8a:	77fb      	strb	r3, [r7, #31]
            if(res != LV_RES_OK) {
 800aa8c:	7ffb      	ldrb	r3, [r7, #31]
 800aa8e:	2b01      	cmp	r3, #1
 800aa90:	d001      	beq.n	800aa96 <lv_event_send_func+0xee>
                return LV_RES_INV;
 800aa92:	2300      	movs	r3, #0
 800aa94:	e000      	b.n	800aa98 <lv_event_send_func+0xf0>
            }
        }
    }

    return LV_RES_OK;
 800aa96:	2301      	movs	r3, #1
}
 800aa98:	4618      	mov	r0, r3
 800aa9a:	3728      	adds	r7, #40	; 0x28
 800aa9c:	46bd      	mov	sp, r7
 800aa9e:	bdb0      	pop	{r4, r5, r7, pc}
 800aaa0:	0802e42c 	.word	0x0802e42c
 800aaa4:	200099f0 	.word	0x200099f0
 800aaa8:	200099f4 	.word	0x200099f4

0800aaac <lv_obj_set_signal_cb>:
 * Always call the previous signal function in the new.
 * @param obj pointer to an object
 * @param cb the new signal function
 */
void lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb)
{
 800aaac:	b5b0      	push	{r4, r5, r7, lr}
 800aaae:	b082      	sub	sp, #8
 800aab0:	af00      	add	r7, sp, #0
 800aab2:	6078      	str	r0, [r7, #4]
 800aab4:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800aab6:	6878      	ldr	r0, [r7, #4]
 800aab8:	f015 fb1a 	bl	80200f0 <lv_debug_check_null>
 800aabc:	4603      	mov	r3, r0
 800aabe:	f083 0301 	eor.w	r3, r3, #1
 800aac2:	b2db      	uxtb	r3, r3
 800aac4:	2b00      	cmp	r3, #0
 800aac6:	d009      	beq.n	800aadc <lv_obj_set_signal_cb+0x30>
 800aac8:	687b      	ldr	r3, [r7, #4]
 800aaca:	2200      	movs	r2, #0
 800aacc:	461c      	mov	r4, r3
 800aace:	4615      	mov	r5, r2
 800aad0:	4622      	mov	r2, r4
 800aad2:	462b      	mov	r3, r5
 800aad4:	4805      	ldr	r0, [pc, #20]	; (800aaec <lv_obj_set_signal_cb+0x40>)
 800aad6:	f015 fb1b 	bl	8020110 <lv_debug_log_error>
 800aada:	e7fe      	b.n	800aada <lv_obj_set_signal_cb+0x2e>

    obj->signal_cb = signal_cb;
 800aadc:	687b      	ldr	r3, [r7, #4]
 800aade:	683a      	ldr	r2, [r7, #0]
 800aae0:	61da      	str	r2, [r3, #28]
}
 800aae2:	bf00      	nop
 800aae4:	3708      	adds	r7, #8
 800aae6:	46bd      	mov	sp, r7
 800aae8:	bdb0      	pop	{r4, r5, r7, pc}
 800aaea:	bf00      	nop
 800aaec:	0802e42c 	.word	0x0802e42c

0800aaf0 <lv_signal_send>:
 * @param obj pointer to an object
 * @param event the type of the event from `lv_event_t`.
 * @return LV_RES_OK or LV_RES_INV
 */
lv_res_t lv_signal_send(lv_obj_t * obj, lv_signal_t signal, void * param)
{
 800aaf0:	b580      	push	{r7, lr}
 800aaf2:	b086      	sub	sp, #24
 800aaf4:	af00      	add	r7, sp, #0
 800aaf6:	60f8      	str	r0, [r7, #12]
 800aaf8:	460b      	mov	r3, r1
 800aafa:	607a      	str	r2, [r7, #4]
 800aafc:	72fb      	strb	r3, [r7, #11]
    if(obj == NULL) return LV_RES_OK;
 800aafe:	68fb      	ldr	r3, [r7, #12]
 800ab00:	2b00      	cmp	r3, #0
 800ab02:	d101      	bne.n	800ab08 <lv_signal_send+0x18>
 800ab04:	2301      	movs	r3, #1
 800ab06:	e00e      	b.n	800ab26 <lv_signal_send+0x36>

    lv_res_t res = LV_RES_OK;
 800ab08:	2301      	movs	r3, #1
 800ab0a:	75fb      	strb	r3, [r7, #23]
    if(obj->signal_cb) res = obj->signal_cb(obj, signal, param);
 800ab0c:	68fb      	ldr	r3, [r7, #12]
 800ab0e:	69db      	ldr	r3, [r3, #28]
 800ab10:	2b00      	cmp	r3, #0
 800ab12:	d007      	beq.n	800ab24 <lv_signal_send+0x34>
 800ab14:	68fb      	ldr	r3, [r7, #12]
 800ab16:	69db      	ldr	r3, [r3, #28]
 800ab18:	7af9      	ldrb	r1, [r7, #11]
 800ab1a:	687a      	ldr	r2, [r7, #4]
 800ab1c:	68f8      	ldr	r0, [r7, #12]
 800ab1e:	4798      	blx	r3
 800ab20:	4603      	mov	r3, r0
 800ab22:	75fb      	strb	r3, [r7, #23]

    return res;
 800ab24:	7dfb      	ldrb	r3, [r7, #23]
}
 800ab26:	4618      	mov	r0, r3
 800ab28:	3718      	adds	r7, #24
 800ab2a:	46bd      	mov	sp, r7
 800ab2c:	bd80      	pop	{r7, pc}
	...

0800ab30 <lv_obj_set_design_cb>:
 * Set a new design function for an object
 * @param obj pointer to an object
 * @param design_cb the new design function
 */
void lv_obj_set_design_cb(lv_obj_t * obj, lv_design_cb_t design_cb)
{
 800ab30:	b5b0      	push	{r4, r5, r7, lr}
 800ab32:	b082      	sub	sp, #8
 800ab34:	af00      	add	r7, sp, #0
 800ab36:	6078      	str	r0, [r7, #4]
 800ab38:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800ab3a:	6878      	ldr	r0, [r7, #4]
 800ab3c:	f015 fad8 	bl	80200f0 <lv_debug_check_null>
 800ab40:	4603      	mov	r3, r0
 800ab42:	f083 0301 	eor.w	r3, r3, #1
 800ab46:	b2db      	uxtb	r3, r3
 800ab48:	2b00      	cmp	r3, #0
 800ab4a:	d009      	beq.n	800ab60 <lv_obj_set_design_cb+0x30>
 800ab4c:	687b      	ldr	r3, [r7, #4]
 800ab4e:	2200      	movs	r2, #0
 800ab50:	461c      	mov	r4, r3
 800ab52:	4615      	mov	r5, r2
 800ab54:	4622      	mov	r2, r4
 800ab56:	462b      	mov	r3, r5
 800ab58:	4805      	ldr	r0, [pc, #20]	; (800ab70 <lv_obj_set_design_cb+0x40>)
 800ab5a:	f015 fad9 	bl	8020110 <lv_debug_log_error>
 800ab5e:	e7fe      	b.n	800ab5e <lv_obj_set_design_cb+0x2e>

    obj->design_cb = design_cb;
 800ab60:	687b      	ldr	r3, [r7, #4]
 800ab62:	683a      	ldr	r2, [r7, #0]
 800ab64:	621a      	str	r2, [r3, #32]
}
 800ab66:	bf00      	nop
 800ab68:	3708      	adds	r7, #8
 800ab6a:	46bd      	mov	sp, r7
 800ab6c:	bdb0      	pop	{r4, r5, r7, pc}
 800ab6e:	bf00      	nop
 800ab70:	0802e42c 	.word	0x0802e42c

0800ab74 <lv_obj_allocate_ext_attr>:
 * @param ext_size the size of the new ext. data
 * @return pointer to the allocated ext.
 * If out of memory NULL is returned and the original ext is preserved
 */
void * lv_obj_allocate_ext_attr(lv_obj_t * obj, uint16_t ext_size)
{
 800ab74:	b5b0      	push	{r4, r5, r7, lr}
 800ab76:	b084      	sub	sp, #16
 800ab78:	af00      	add	r7, sp, #0
 800ab7a:	6078      	str	r0, [r7, #4]
 800ab7c:	460b      	mov	r3, r1
 800ab7e:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800ab80:	6878      	ldr	r0, [r7, #4]
 800ab82:	f015 fab5 	bl	80200f0 <lv_debug_check_null>
 800ab86:	4603      	mov	r3, r0
 800ab88:	f083 0301 	eor.w	r3, r3, #1
 800ab8c:	b2db      	uxtb	r3, r3
 800ab8e:	2b00      	cmp	r3, #0
 800ab90:	d009      	beq.n	800aba6 <lv_obj_allocate_ext_attr+0x32>
 800ab92:	687b      	ldr	r3, [r7, #4]
 800ab94:	2200      	movs	r2, #0
 800ab96:	461c      	mov	r4, r3
 800ab98:	4615      	mov	r5, r2
 800ab9a:	4622      	mov	r2, r4
 800ab9c:	462b      	mov	r3, r5
 800ab9e:	480d      	ldr	r0, [pc, #52]	; (800abd4 <lv_obj_allocate_ext_attr+0x60>)
 800aba0:	f015 fab6 	bl	8020110 <lv_debug_log_error>
 800aba4:	e7fe      	b.n	800aba4 <lv_obj_allocate_ext_attr+0x30>

    void * new_ext = lv_mem_realloc(obj->ext_attr, ext_size);
 800aba6:	687b      	ldr	r3, [r7, #4]
 800aba8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800abaa:	887a      	ldrh	r2, [r7, #2]
 800abac:	4611      	mov	r1, r2
 800abae:	4618      	mov	r0, r3
 800abb0:	f016 f8b0 	bl	8020d14 <lv_mem_realloc>
 800abb4:	60f8      	str	r0, [r7, #12]
    if(new_ext == NULL) return NULL;
 800abb6:	68fb      	ldr	r3, [r7, #12]
 800abb8:	2b00      	cmp	r3, #0
 800abba:	d101      	bne.n	800abc0 <lv_obj_allocate_ext_attr+0x4c>
 800abbc:	2300      	movs	r3, #0
 800abbe:	e004      	b.n	800abca <lv_obj_allocate_ext_attr+0x56>

    obj->ext_attr = new_ext;
 800abc0:	687b      	ldr	r3, [r7, #4]
 800abc2:	68fa      	ldr	r2, [r7, #12]
 800abc4:	625a      	str	r2, [r3, #36]	; 0x24
    return (void *)obj->ext_attr;
 800abc6:	687b      	ldr	r3, [r7, #4]
 800abc8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800abca:	4618      	mov	r0, r3
 800abcc:	3710      	adds	r7, #16
 800abce:	46bd      	mov	sp, r7
 800abd0:	bdb0      	pop	{r4, r5, r7, pc}
 800abd2:	bf00      	nop
 800abd4:	0802e42c 	.word	0x0802e42c

0800abd8 <lv_obj_refresh_ext_draw_pad>:
 * Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object to refresh the extended draw area.
 * he object needs to be invalidated by `lv_obj_invalidate(obj)` manually after this function.
 * @param obj pointer to an object
 */
void lv_obj_refresh_ext_draw_pad(lv_obj_t * obj)
{
 800abd8:	b5b0      	push	{r4, r5, r7, lr}
 800abda:	b082      	sub	sp, #8
 800abdc:	af00      	add	r7, sp, #0
 800abde:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800abe0:	6878      	ldr	r0, [r7, #4]
 800abe2:	f015 fa85 	bl	80200f0 <lv_debug_check_null>
 800abe6:	4603      	mov	r3, r0
 800abe8:	f083 0301 	eor.w	r3, r3, #1
 800abec:	b2db      	uxtb	r3, r3
 800abee:	2b00      	cmp	r3, #0
 800abf0:	d009      	beq.n	800ac06 <lv_obj_refresh_ext_draw_pad+0x2e>
 800abf2:	687b      	ldr	r3, [r7, #4]
 800abf4:	2200      	movs	r2, #0
 800abf6:	461c      	mov	r4, r3
 800abf8:	4615      	mov	r5, r2
 800abfa:	4622      	mov	r2, r4
 800abfc:	462b      	mov	r3, r5
 800abfe:	4808      	ldr	r0, [pc, #32]	; (800ac20 <lv_obj_refresh_ext_draw_pad+0x48>)
 800ac00:	f015 fa86 	bl	8020110 <lv_debug_log_error>
 800ac04:	e7fe      	b.n	800ac04 <lv_obj_refresh_ext_draw_pad+0x2c>

    obj->ext_draw_pad = 0;
 800ac06:	687b      	ldr	r3, [r7, #4]
 800ac08:	2200      	movs	r2, #0
 800ac0a:	865a      	strh	r2, [r3, #50]	; 0x32
    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
 800ac0c:	687b      	ldr	r3, [r7, #4]
 800ac0e:	69db      	ldr	r3, [r3, #28]
 800ac10:	2200      	movs	r2, #0
 800ac12:	2106      	movs	r1, #6
 800ac14:	6878      	ldr	r0, [r7, #4]
 800ac16:	4798      	blx	r3

}
 800ac18:	bf00      	nop
 800ac1a:	3708      	adds	r7, #8
 800ac1c:	46bd      	mov	sp, r7
 800ac1e:	bdb0      	pop	{r4, r5, r7, pc}
 800ac20:	0802e42c 	.word	0x0802e42c

0800ac24 <lv_obj_get_screen>:
 * Return with the screen of an object
 * @param obj pointer to an object
 * @return pointer to a screen
 */
lv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)
{
 800ac24:	b5b0      	push	{r4, r5, r7, lr}
 800ac26:	b084      	sub	sp, #16
 800ac28:	af00      	add	r7, sp, #0
 800ac2a:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800ac2c:	6878      	ldr	r0, [r7, #4]
 800ac2e:	f015 fa5f 	bl	80200f0 <lv_debug_check_null>
 800ac32:	4603      	mov	r3, r0
 800ac34:	f083 0301 	eor.w	r3, r3, #1
 800ac38:	b2db      	uxtb	r3, r3
 800ac3a:	2b00      	cmp	r3, #0
 800ac3c:	d009      	beq.n	800ac52 <lv_obj_get_screen+0x2e>
 800ac3e:	687b      	ldr	r3, [r7, #4]
 800ac40:	2200      	movs	r2, #0
 800ac42:	461c      	mov	r4, r3
 800ac44:	4615      	mov	r5, r2
 800ac46:	4622      	mov	r2, r4
 800ac48:	462b      	mov	r3, r5
 800ac4a:	480a      	ldr	r0, [pc, #40]	; (800ac74 <lv_obj_get_screen+0x50>)
 800ac4c:	f015 fa60 	bl	8020110 <lv_debug_log_error>
 800ac50:	e7fe      	b.n	800ac50 <lv_obj_get_screen+0x2c>

    const lv_obj_t * par = obj;
 800ac52:	687b      	ldr	r3, [r7, #4]
 800ac54:	60fb      	str	r3, [r7, #12]
    const lv_obj_t * act_p;

    do {
        act_p = par;
 800ac56:	68fb      	ldr	r3, [r7, #12]
 800ac58:	60bb      	str	r3, [r7, #8]
        par   = lv_obj_get_parent(act_p);
 800ac5a:	68b8      	ldr	r0, [r7, #8]
 800ac5c:	f000 f85c 	bl	800ad18 <lv_obj_get_parent>
 800ac60:	60f8      	str	r0, [r7, #12]
    } while(par != NULL);
 800ac62:	68fb      	ldr	r3, [r7, #12]
 800ac64:	2b00      	cmp	r3, #0
 800ac66:	d1f6      	bne.n	800ac56 <lv_obj_get_screen+0x32>

    return (lv_obj_t *)act_p;
 800ac68:	68bb      	ldr	r3, [r7, #8]
}
 800ac6a:	4618      	mov	r0, r3
 800ac6c:	3710      	adds	r7, #16
 800ac6e:	46bd      	mov	sp, r7
 800ac70:	bdb0      	pop	{r4, r5, r7, pc}
 800ac72:	bf00      	nop
 800ac74:	0802e42c 	.word	0x0802e42c

0800ac78 <lv_obj_get_disp>:
 * Get the display of an object
 * @param scr pointer to an object
 * @return pointer the object's display
 */
lv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)
{
 800ac78:	b5b0      	push	{r4, r5, r7, lr}
 800ac7a:	b086      	sub	sp, #24
 800ac7c:	af00      	add	r7, sp, #0
 800ac7e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800ac80:	6878      	ldr	r0, [r7, #4]
 800ac82:	f015 fa35 	bl	80200f0 <lv_debug_check_null>
 800ac86:	4603      	mov	r3, r0
 800ac88:	f083 0301 	eor.w	r3, r3, #1
 800ac8c:	b2db      	uxtb	r3, r3
 800ac8e:	2b00      	cmp	r3, #0
 800ac90:	d009      	beq.n	800aca6 <lv_obj_get_disp+0x2e>
 800ac92:	687b      	ldr	r3, [r7, #4]
 800ac94:	2200      	movs	r2, #0
 800ac96:	461c      	mov	r4, r3
 800ac98:	4615      	mov	r5, r2
 800ac9a:	4622      	mov	r2, r4
 800ac9c:	462b      	mov	r3, r5
 800ac9e:	481c      	ldr	r0, [pc, #112]	; (800ad10 <lv_obj_get_disp+0x98>)
 800aca0:	f015 fa36 	bl	8020110 <lv_debug_log_error>
 800aca4:	e7fe      	b.n	800aca4 <lv_obj_get_disp+0x2c>

    const lv_obj_t * scr;

    if(obj->parent == NULL)
 800aca6:	687b      	ldr	r3, [r7, #4]
 800aca8:	681b      	ldr	r3, [r3, #0]
 800acaa:	2b00      	cmp	r3, #0
 800acac:	d102      	bne.n	800acb4 <lv_obj_get_disp+0x3c>
        scr = obj; /*`obj` is a screen*/
 800acae:	687b      	ldr	r3, [r7, #4]
 800acb0:	617b      	str	r3, [r7, #20]
 800acb2:	e003      	b.n	800acbc <lv_obj_get_disp+0x44>
    else
        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/
 800acb4:	6878      	ldr	r0, [r7, #4]
 800acb6:	f7ff ffb5 	bl	800ac24 <lv_obj_get_screen>
 800acba:	6178      	str	r0, [r7, #20]

    lv_disp_t * d;
    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {
 800acbc:	4815      	ldr	r0, [pc, #84]	; (800ad14 <lv_obj_get_disp+0x9c>)
 800acbe:	f015 fdcd 	bl	802085c <_lv_ll_get_head>
 800acc2:	6138      	str	r0, [r7, #16]
 800acc4:	e01b      	b.n	800acfe <lv_obj_get_disp+0x86>
        lv_obj_t * s;
        _LV_LL_READ(d->scr_ll, s) {
 800acc6:	693b      	ldr	r3, [r7, #16]
 800acc8:	3330      	adds	r3, #48	; 0x30
 800acca:	4618      	mov	r0, r3
 800accc:	f015 fdc6 	bl	802085c <_lv_ll_get_head>
 800acd0:	60f8      	str	r0, [r7, #12]
 800acd2:	e00c      	b.n	800acee <lv_obj_get_disp+0x76>
            if(s == scr) return d;
 800acd4:	68fa      	ldr	r2, [r7, #12]
 800acd6:	697b      	ldr	r3, [r7, #20]
 800acd8:	429a      	cmp	r2, r3
 800acda:	d101      	bne.n	800ace0 <lv_obj_get_disp+0x68>
 800acdc:	693b      	ldr	r3, [r7, #16]
 800acde:	e012      	b.n	800ad06 <lv_obj_get_disp+0x8e>
        _LV_LL_READ(d->scr_ll, s) {
 800ace0:	693b      	ldr	r3, [r7, #16]
 800ace2:	3330      	adds	r3, #48	; 0x30
 800ace4:	68f9      	ldr	r1, [r7, #12]
 800ace6:	4618      	mov	r0, r3
 800ace8:	f015 fdde 	bl	80208a8 <_lv_ll_get_next>
 800acec:	60f8      	str	r0, [r7, #12]
 800acee:	68fb      	ldr	r3, [r7, #12]
 800acf0:	2b00      	cmp	r3, #0
 800acf2:	d1ef      	bne.n	800acd4 <lv_obj_get_disp+0x5c>
    _LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d) {
 800acf4:	6939      	ldr	r1, [r7, #16]
 800acf6:	4807      	ldr	r0, [pc, #28]	; (800ad14 <lv_obj_get_disp+0x9c>)
 800acf8:	f015 fdd6 	bl	80208a8 <_lv_ll_get_next>
 800acfc:	6138      	str	r0, [r7, #16]
 800acfe:	693b      	ldr	r3, [r7, #16]
 800ad00:	2b00      	cmp	r3, #0
 800ad02:	d1e0      	bne.n	800acc6 <lv_obj_get_disp+0x4e>
        }
    }

    LV_LOG_WARN("lv_scr_get_disp: screen not found")
    return NULL;
 800ad04:	2300      	movs	r3, #0
}
 800ad06:	4618      	mov	r0, r3
 800ad08:	3718      	adds	r7, #24
 800ad0a:	46bd      	mov	sp, r7
 800ad0c:	bdb0      	pop	{r4, r5, r7, pc}
 800ad0e:	bf00      	nop
 800ad10:	0802e42c 	.word	0x0802e42c
 800ad14:	2000a180 	.word	0x2000a180

0800ad18 <lv_obj_get_parent>:
 * Returns with the parent of an object
 * @param obj pointer to an object
 * @return pointer to the parent of  'obj'
 */
lv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)
{
 800ad18:	b5b0      	push	{r4, r5, r7, lr}
 800ad1a:	b082      	sub	sp, #8
 800ad1c:	af00      	add	r7, sp, #0
 800ad1e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800ad20:	6878      	ldr	r0, [r7, #4]
 800ad22:	f015 f9e5 	bl	80200f0 <lv_debug_check_null>
 800ad26:	4603      	mov	r3, r0
 800ad28:	f083 0301 	eor.w	r3, r3, #1
 800ad2c:	b2db      	uxtb	r3, r3
 800ad2e:	2b00      	cmp	r3, #0
 800ad30:	d009      	beq.n	800ad46 <lv_obj_get_parent+0x2e>
 800ad32:	687b      	ldr	r3, [r7, #4]
 800ad34:	2200      	movs	r2, #0
 800ad36:	461c      	mov	r4, r3
 800ad38:	4615      	mov	r5, r2
 800ad3a:	4622      	mov	r2, r4
 800ad3c:	462b      	mov	r3, r5
 800ad3e:	4805      	ldr	r0, [pc, #20]	; (800ad54 <lv_obj_get_parent+0x3c>)
 800ad40:	f015 f9e6 	bl	8020110 <lv_debug_log_error>
 800ad44:	e7fe      	b.n	800ad44 <lv_obj_get_parent+0x2c>

    return obj->parent;
 800ad46:	687b      	ldr	r3, [r7, #4]
 800ad48:	681b      	ldr	r3, [r3, #0]
}
 800ad4a:	4618      	mov	r0, r3
 800ad4c:	3708      	adds	r7, #8
 800ad4e:	46bd      	mov	sp, r7
 800ad50:	bdb0      	pop	{r4, r5, r7, pc}
 800ad52:	bf00      	nop
 800ad54:	0802e42c 	.word	0x0802e42c

0800ad58 <lv_obj_get_child>:
 * @param child NULL at first call to get the next children
 *                  and the previous return value later
 * @return the child after 'act_child' or NULL if no more child
 */
lv_obj_t * lv_obj_get_child(const lv_obj_t * obj, const lv_obj_t * child)
{
 800ad58:	b5b0      	push	{r4, r5, r7, lr}
 800ad5a:	b084      	sub	sp, #16
 800ad5c:	af00      	add	r7, sp, #0
 800ad5e:	6078      	str	r0, [r7, #4]
 800ad60:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800ad62:	6878      	ldr	r0, [r7, #4]
 800ad64:	f015 f9c4 	bl	80200f0 <lv_debug_check_null>
 800ad68:	4603      	mov	r3, r0
 800ad6a:	f083 0301 	eor.w	r3, r3, #1
 800ad6e:	b2db      	uxtb	r3, r3
 800ad70:	2b00      	cmp	r3, #0
 800ad72:	d009      	beq.n	800ad88 <lv_obj_get_child+0x30>
 800ad74:	687b      	ldr	r3, [r7, #4]
 800ad76:	2200      	movs	r2, #0
 800ad78:	461c      	mov	r4, r3
 800ad7a:	4615      	mov	r5, r2
 800ad7c:	4622      	mov	r2, r4
 800ad7e:	462b      	mov	r3, r5
 800ad80:	480d      	ldr	r0, [pc, #52]	; (800adb8 <lv_obj_get_child+0x60>)
 800ad82:	f015 f9c5 	bl	8020110 <lv_debug_log_error>
 800ad86:	e7fe      	b.n	800ad86 <lv_obj_get_child+0x2e>

    lv_obj_t * result = NULL;
 800ad88:	2300      	movs	r3, #0
 800ad8a:	60fb      	str	r3, [r7, #12]

    if(child == NULL) {
 800ad8c:	683b      	ldr	r3, [r7, #0]
 800ad8e:	2b00      	cmp	r3, #0
 800ad90:	d106      	bne.n	800ada0 <lv_obj_get_child+0x48>
        result = _lv_ll_get_head(&obj->child_ll);
 800ad92:	687b      	ldr	r3, [r7, #4]
 800ad94:	3304      	adds	r3, #4
 800ad96:	4618      	mov	r0, r3
 800ad98:	f015 fd60 	bl	802085c <_lv_ll_get_head>
 800ad9c:	60f8      	str	r0, [r7, #12]
 800ad9e:	e006      	b.n	800adae <lv_obj_get_child+0x56>
    }
    else {
        result = _lv_ll_get_next(&obj->child_ll, child);
 800ada0:	687b      	ldr	r3, [r7, #4]
 800ada2:	3304      	adds	r3, #4
 800ada4:	6839      	ldr	r1, [r7, #0]
 800ada6:	4618      	mov	r0, r3
 800ada8:	f015 fd7e 	bl	80208a8 <_lv_ll_get_next>
 800adac:	60f8      	str	r0, [r7, #12]
    }

    return result;
 800adae:	68fb      	ldr	r3, [r7, #12]
}
 800adb0:	4618      	mov	r0, r3
 800adb2:	3710      	adds	r7, #16
 800adb4:	46bd      	mov	sp, r7
 800adb6:	bdb0      	pop	{r4, r5, r7, pc}
 800adb8:	0802e42c 	.word	0x0802e42c

0800adbc <lv_obj_get_coords>:
 * Copy the coordinates of an object to an area
 * @param obj pointer to an object
 * @param cords_p pointer to an area to store the coordinates
 */
void lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p)
{
 800adbc:	b5b0      	push	{r4, r5, r7, lr}
 800adbe:	b082      	sub	sp, #8
 800adc0:	af00      	add	r7, sp, #0
 800adc2:	6078      	str	r0, [r7, #4]
 800adc4:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800adc6:	6878      	ldr	r0, [r7, #4]
 800adc8:	f015 f992 	bl	80200f0 <lv_debug_check_null>
 800adcc:	4603      	mov	r3, r0
 800adce:	f083 0301 	eor.w	r3, r3, #1
 800add2:	b2db      	uxtb	r3, r3
 800add4:	2b00      	cmp	r3, #0
 800add6:	d009      	beq.n	800adec <lv_obj_get_coords+0x30>
 800add8:	687b      	ldr	r3, [r7, #4]
 800adda:	2200      	movs	r2, #0
 800addc:	461c      	mov	r4, r3
 800adde:	4615      	mov	r5, r2
 800ade0:	4622      	mov	r2, r4
 800ade2:	462b      	mov	r3, r5
 800ade4:	4806      	ldr	r0, [pc, #24]	; (800ae00 <lv_obj_get_coords+0x44>)
 800ade6:	f015 f993 	bl	8020110 <lv_debug_log_error>
 800adea:	e7fe      	b.n	800adea <lv_obj_get_coords+0x2e>

    lv_area_copy(cords_p, &obj->coords);
 800adec:	687b      	ldr	r3, [r7, #4]
 800adee:	3310      	adds	r3, #16
 800adf0:	4619      	mov	r1, r3
 800adf2:	6838      	ldr	r0, [r7, #0]
 800adf4:	f7fd fb86 	bl	8008504 <lv_area_copy>
}
 800adf8:	bf00      	nop
 800adfa:	3708      	adds	r7, #8
 800adfc:	46bd      	mov	sp, r7
 800adfe:	bdb0      	pop	{r4, r5, r7, pc}
 800ae00:	0802e42c 	.word	0x0802e42c

0800ae04 <lv_obj_get_x>:
 * Get the x coordinate of object
 * @param obj pointer to an object
 * @return distance of 'obj' from the left side of its parent
 */
lv_coord_t lv_obj_get_x(const lv_obj_t * obj)
{
 800ae04:	b5b0      	push	{r4, r5, r7, lr}
 800ae06:	b084      	sub	sp, #16
 800ae08:	af00      	add	r7, sp, #0
 800ae0a:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800ae0c:	6878      	ldr	r0, [r7, #4]
 800ae0e:	f015 f96f 	bl	80200f0 <lv_debug_check_null>
 800ae12:	4603      	mov	r3, r0
 800ae14:	f083 0301 	eor.w	r3, r3, #1
 800ae18:	b2db      	uxtb	r3, r3
 800ae1a:	2b00      	cmp	r3, #0
 800ae1c:	d009      	beq.n	800ae32 <lv_obj_get_x+0x2e>
 800ae1e:	687b      	ldr	r3, [r7, #4]
 800ae20:	2200      	movs	r2, #0
 800ae22:	461c      	mov	r4, r3
 800ae24:	4615      	mov	r5, r2
 800ae26:	4622      	mov	r2, r4
 800ae28:	462b      	mov	r3, r5
 800ae2a:	4810      	ldr	r0, [pc, #64]	; (800ae6c <lv_obj_get_x+0x68>)
 800ae2c:	f015 f970 	bl	8020110 <lv_debug_log_error>
 800ae30:	e7fe      	b.n	800ae30 <lv_obj_get_x+0x2c>

    lv_coord_t rel_x;
    lv_obj_t * parent = lv_obj_get_parent(obj);
 800ae32:	6878      	ldr	r0, [r7, #4]
 800ae34:	f7ff ff70 	bl	800ad18 <lv_obj_get_parent>
 800ae38:	60b8      	str	r0, [r7, #8]
    if(parent) {
 800ae3a:	68bb      	ldr	r3, [r7, #8]
 800ae3c:	2b00      	cmp	r3, #0
 800ae3e:	d00b      	beq.n	800ae58 <lv_obj_get_x+0x54>
        rel_x             = obj->coords.x1 - parent->coords.x1;
 800ae40:	687b      	ldr	r3, [r7, #4]
 800ae42:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 800ae46:	b29a      	uxth	r2, r3
 800ae48:	68bb      	ldr	r3, [r7, #8]
 800ae4a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 800ae4e:	b29b      	uxth	r3, r3
 800ae50:	1ad3      	subs	r3, r2, r3
 800ae52:	b29b      	uxth	r3, r3
 800ae54:	81fb      	strh	r3, [r7, #14]
 800ae56:	e002      	b.n	800ae5e <lv_obj_get_x+0x5a>
    }
    else {
        rel_x = obj->coords.x1;
 800ae58:	687b      	ldr	r3, [r7, #4]
 800ae5a:	8a1b      	ldrh	r3, [r3, #16]
 800ae5c:	81fb      	strh	r3, [r7, #14]
    }
    return rel_x;
 800ae5e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
 800ae62:	4618      	mov	r0, r3
 800ae64:	3710      	adds	r7, #16
 800ae66:	46bd      	mov	sp, r7
 800ae68:	bdb0      	pop	{r4, r5, r7, pc}
 800ae6a:	bf00      	nop
 800ae6c:	0802e42c 	.word	0x0802e42c

0800ae70 <lv_obj_get_y>:
 * Get the y coordinate of object
 * @param obj pointer to an object
 * @return distance of 'obj' from the top of its parent
 */
lv_coord_t lv_obj_get_y(const lv_obj_t * obj)
{
 800ae70:	b5b0      	push	{r4, r5, r7, lr}
 800ae72:	b084      	sub	sp, #16
 800ae74:	af00      	add	r7, sp, #0
 800ae76:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800ae78:	6878      	ldr	r0, [r7, #4]
 800ae7a:	f015 f939 	bl	80200f0 <lv_debug_check_null>
 800ae7e:	4603      	mov	r3, r0
 800ae80:	f083 0301 	eor.w	r3, r3, #1
 800ae84:	b2db      	uxtb	r3, r3
 800ae86:	2b00      	cmp	r3, #0
 800ae88:	d009      	beq.n	800ae9e <lv_obj_get_y+0x2e>
 800ae8a:	687b      	ldr	r3, [r7, #4]
 800ae8c:	2200      	movs	r2, #0
 800ae8e:	461c      	mov	r4, r3
 800ae90:	4615      	mov	r5, r2
 800ae92:	4622      	mov	r2, r4
 800ae94:	462b      	mov	r3, r5
 800ae96:	4810      	ldr	r0, [pc, #64]	; (800aed8 <lv_obj_get_y+0x68>)
 800ae98:	f015 f93a 	bl	8020110 <lv_debug_log_error>
 800ae9c:	e7fe      	b.n	800ae9c <lv_obj_get_y+0x2c>

    lv_coord_t rel_y;
    lv_obj_t * parent = lv_obj_get_parent(obj);
 800ae9e:	6878      	ldr	r0, [r7, #4]
 800aea0:	f7ff ff3a 	bl	800ad18 <lv_obj_get_parent>
 800aea4:	60b8      	str	r0, [r7, #8]
    if(parent) {
 800aea6:	68bb      	ldr	r3, [r7, #8]
 800aea8:	2b00      	cmp	r3, #0
 800aeaa:	d00b      	beq.n	800aec4 <lv_obj_get_y+0x54>
        rel_y             = obj->coords.y1 - parent->coords.y1;
 800aeac:	687b      	ldr	r3, [r7, #4]
 800aeae:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 800aeb2:	b29a      	uxth	r2, r3
 800aeb4:	68bb      	ldr	r3, [r7, #8]
 800aeb6:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 800aeba:	b29b      	uxth	r3, r3
 800aebc:	1ad3      	subs	r3, r2, r3
 800aebe:	b29b      	uxth	r3, r3
 800aec0:	81fb      	strh	r3, [r7, #14]
 800aec2:	e002      	b.n	800aeca <lv_obj_get_y+0x5a>
    }
    else {
        rel_y = obj->coords.y1;
 800aec4:	687b      	ldr	r3, [r7, #4]
 800aec6:	8a5b      	ldrh	r3, [r3, #18]
 800aec8:	81fb      	strh	r3, [r7, #14]
    }
    return rel_y;
 800aeca:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
 800aece:	4618      	mov	r0, r3
 800aed0:	3710      	adds	r7, #16
 800aed2:	46bd      	mov	sp, r7
 800aed4:	bdb0      	pop	{r4, r5, r7, pc}
 800aed6:	bf00      	nop
 800aed8:	0802e42c 	.word	0x0802e42c

0800aedc <lv_obj_get_width>:
 * Get the width of an object
 * @param obj pointer to an object
 * @return the width
 */
lv_coord_t lv_obj_get_width(const lv_obj_t * obj)
{
 800aedc:	b5b0      	push	{r4, r5, r7, lr}
 800aede:	b082      	sub	sp, #8
 800aee0:	af00      	add	r7, sp, #0
 800aee2:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800aee4:	6878      	ldr	r0, [r7, #4]
 800aee6:	f015 f903 	bl	80200f0 <lv_debug_check_null>
 800aeea:	4603      	mov	r3, r0
 800aeec:	f083 0301 	eor.w	r3, r3, #1
 800aef0:	b2db      	uxtb	r3, r3
 800aef2:	2b00      	cmp	r3, #0
 800aef4:	d009      	beq.n	800af0a <lv_obj_get_width+0x2e>
 800aef6:	687b      	ldr	r3, [r7, #4]
 800aef8:	2200      	movs	r2, #0
 800aefa:	461c      	mov	r4, r3
 800aefc:	4615      	mov	r5, r2
 800aefe:	4622      	mov	r2, r4
 800af00:	462b      	mov	r3, r5
 800af02:	4807      	ldr	r0, [pc, #28]	; (800af20 <lv_obj_get_width+0x44>)
 800af04:	f015 f904 	bl	8020110 <lv_debug_log_error>
 800af08:	e7fe      	b.n	800af08 <lv_obj_get_width+0x2c>

    return lv_area_get_width(&obj->coords);
 800af0a:	687b      	ldr	r3, [r7, #4]
 800af0c:	3310      	adds	r3, #16
 800af0e:	4618      	mov	r0, r3
 800af10:	f7fd fb06 	bl	8008520 <lv_area_get_width>
 800af14:	4603      	mov	r3, r0
}
 800af16:	4618      	mov	r0, r3
 800af18:	3708      	adds	r7, #8
 800af1a:	46bd      	mov	sp, r7
 800af1c:	bdb0      	pop	{r4, r5, r7, pc}
 800af1e:	bf00      	nop
 800af20:	0802e42c 	.word	0x0802e42c

0800af24 <lv_obj_get_height>:
 * Get the height of an object
 * @param obj pointer to an object
 * @return the height
 */
lv_coord_t lv_obj_get_height(const lv_obj_t * obj)
{
 800af24:	b5b0      	push	{r4, r5, r7, lr}
 800af26:	b082      	sub	sp, #8
 800af28:	af00      	add	r7, sp, #0
 800af2a:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800af2c:	6878      	ldr	r0, [r7, #4]
 800af2e:	f015 f8df 	bl	80200f0 <lv_debug_check_null>
 800af32:	4603      	mov	r3, r0
 800af34:	f083 0301 	eor.w	r3, r3, #1
 800af38:	b2db      	uxtb	r3, r3
 800af3a:	2b00      	cmp	r3, #0
 800af3c:	d009      	beq.n	800af52 <lv_obj_get_height+0x2e>
 800af3e:	687b      	ldr	r3, [r7, #4]
 800af40:	2200      	movs	r2, #0
 800af42:	461c      	mov	r4, r3
 800af44:	4615      	mov	r5, r2
 800af46:	4622      	mov	r2, r4
 800af48:	462b      	mov	r3, r5
 800af4a:	4807      	ldr	r0, [pc, #28]	; (800af68 <lv_obj_get_height+0x44>)
 800af4c:	f015 f8e0 	bl	8020110 <lv_debug_log_error>
 800af50:	e7fe      	b.n	800af50 <lv_obj_get_height+0x2c>

    return lv_area_get_height(&obj->coords);
 800af52:	687b      	ldr	r3, [r7, #4]
 800af54:	3310      	adds	r3, #16
 800af56:	4618      	mov	r0, r3
 800af58:	f7fd faf9 	bl	800854e <lv_area_get_height>
 800af5c:	4603      	mov	r3, r0
}
 800af5e:	4618      	mov	r0, r3
 800af60:	3708      	adds	r7, #8
 800af62:	46bd      	mov	sp, r7
 800af64:	bdb0      	pop	{r4, r5, r7, pc}
 800af66:	bf00      	nop
 800af68:	0802e42c 	.word	0x0802e42c

0800af6c <lv_obj_get_width_fit>:
 * Get that width reduced by the left and right padding.
 * @param obj pointer to an object
 * @return the width which still fits into the container
 */
lv_coord_t lv_obj_get_width_fit(const lv_obj_t * obj)
{
 800af6c:	b5b0      	push	{r4, r5, r7, lr}
 800af6e:	b084      	sub	sp, #16
 800af70:	af00      	add	r7, sp, #0
 800af72:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800af74:	6878      	ldr	r0, [r7, #4]
 800af76:	f015 f8bb 	bl	80200f0 <lv_debug_check_null>
 800af7a:	4603      	mov	r3, r0
 800af7c:	f083 0301 	eor.w	r3, r3, #1
 800af80:	b2db      	uxtb	r3, r3
 800af82:	2b00      	cmp	r3, #0
 800af84:	d009      	beq.n	800af9a <lv_obj_get_width_fit+0x2e>
 800af86:	687b      	ldr	r3, [r7, #4]
 800af88:	2200      	movs	r2, #0
 800af8a:	461c      	mov	r4, r3
 800af8c:	4615      	mov	r5, r2
 800af8e:	4622      	mov	r2, r4
 800af90:	462b      	mov	r3, r5
 800af92:	4810      	ldr	r0, [pc, #64]	; (800afd4 <lv_obj_get_width_fit+0x68>)
 800af94:	f015 f8bc 	bl	8020110 <lv_debug_log_error>
 800af98:	e7fe      	b.n	800af98 <lv_obj_get_width_fit+0x2c>

    lv_style_int_t left = lv_obj_get_style_pad_left(obj, LV_OBJ_PART_MAIN);
 800af9a:	2100      	movs	r1, #0
 800af9c:	6878      	ldr	r0, [r7, #4]
 800af9e:	f7fd fcf1 	bl	8008984 <lv_obj_get_style_pad_left>
 800afa2:	4603      	mov	r3, r0
 800afa4:	81fb      	strh	r3, [r7, #14]
    lv_style_int_t right = lv_obj_get_style_pad_right(obj, LV_OBJ_PART_MAIN);
 800afa6:	2100      	movs	r1, #0
 800afa8:	6878      	ldr	r0, [r7, #4]
 800afaa:	f7fd fcfc 	bl	80089a6 <lv_obj_get_style_pad_right>
 800afae:	4603      	mov	r3, r0
 800afb0:	81bb      	strh	r3, [r7, #12]

    return lv_obj_get_width(obj) - left - right;
 800afb2:	6878      	ldr	r0, [r7, #4]
 800afb4:	f7ff ff92 	bl	800aedc <lv_obj_get_width>
 800afb8:	4603      	mov	r3, r0
 800afba:	b29a      	uxth	r2, r3
 800afbc:	89fb      	ldrh	r3, [r7, #14]
 800afbe:	1ad3      	subs	r3, r2, r3
 800afc0:	b29a      	uxth	r2, r3
 800afc2:	89bb      	ldrh	r3, [r7, #12]
 800afc4:	1ad3      	subs	r3, r2, r3
 800afc6:	b29b      	uxth	r3, r3
 800afc8:	b21b      	sxth	r3, r3
}
 800afca:	4618      	mov	r0, r3
 800afcc:	3710      	adds	r7, #16
 800afce:	46bd      	mov	sp, r7
 800afd0:	bdb0      	pop	{r4, r5, r7, pc}
 800afd2:	bf00      	nop
 800afd4:	0802e42c 	.word	0x0802e42c

0800afd8 <lv_obj_get_auto_realign>:
 * Get the automatic realign property of the object.
 * @param obj pointer to an object
 * @return  true: auto realign is enabled; false: auto realign is disabled
 */
bool lv_obj_get_auto_realign(const lv_obj_t * obj)
{
 800afd8:	b5b0      	push	{r4, r5, r7, lr}
 800afda:	b082      	sub	sp, #8
 800afdc:	af00      	add	r7, sp, #0
 800afde:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800afe0:	6878      	ldr	r0, [r7, #4]
 800afe2:	f015 f885 	bl	80200f0 <lv_debug_check_null>
 800afe6:	4603      	mov	r3, r0
 800afe8:	f083 0301 	eor.w	r3, r3, #1
 800afec:	b2db      	uxtb	r3, r3
 800afee:	2b00      	cmp	r3, #0
 800aff0:	d009      	beq.n	800b006 <lv_obj_get_auto_realign+0x2e>
 800aff2:	687b      	ldr	r3, [r7, #4]
 800aff4:	2200      	movs	r2, #0
 800aff6:	461c      	mov	r4, r3
 800aff8:	4615      	mov	r5, r2
 800affa:	4622      	mov	r2, r4
 800affc:	462b      	mov	r3, r5
 800affe:	4809      	ldr	r0, [pc, #36]	; (800b024 <lv_obj_get_auto_realign+0x4c>)
 800b000:	f015 f886 	bl	8020110 <lv_debug_log_error>
 800b004:	e7fe      	b.n	800b004 <lv_obj_get_auto_realign+0x2c>

#if LV_USE_OBJ_REALIGN
    return obj->realign.auto_realign ? true : false;
 800b006:	687b      	ldr	r3, [r7, #4]
 800b008:	f893 3049 	ldrb.w	r3, [r3, #73]	; 0x49
 800b00c:	f003 0301 	and.w	r3, r3, #1
 800b010:	2b00      	cmp	r3, #0
 800b012:	bf14      	ite	ne
 800b014:	2301      	movne	r3, #1
 800b016:	2300      	moveq	r3, #0
 800b018:	b2db      	uxtb	r3, r3
#else
    (void)obj;
    return false;
#endif
}
 800b01a:	4618      	mov	r0, r3
 800b01c:	3708      	adds	r7, #8
 800b01e:	46bd      	mov	sp, r7
 800b020:	bdb0      	pop	{r4, r5, r7, pc}
 800b022:	bf00      	nop
 800b024:	0802e42c 	.word	0x0802e42c

0800b028 <lv_obj_get_style_list>:
/*-----------------
 * Appearance get
 *---------------*/

lv_style_list_t * lv_obj_get_style_list(const lv_obj_t * obj, uint8_t part)
{
 800b028:	b580      	push	{r7, lr}
 800b02a:	b086      	sub	sp, #24
 800b02c:	af00      	add	r7, sp, #0
 800b02e:	6078      	str	r0, [r7, #4]
 800b030:	460b      	mov	r3, r1
 800b032:	70fb      	strb	r3, [r7, #3]
    if(part == LV_OBJ_PART_MAIN) return &((lv_obj_t *)obj)->style_list;
 800b034:	78fb      	ldrb	r3, [r7, #3]
 800b036:	2b00      	cmp	r3, #0
 800b038:	d102      	bne.n	800b040 <lv_obj_get_style_list+0x18>
 800b03a:	687b      	ldr	r3, [r7, #4]
 800b03c:	3328      	adds	r3, #40	; 0x28
 800b03e:	e012      	b.n	800b066 <lv_obj_get_style_list+0x3e>

    lv_get_style_info_t info;
    info.part = part;
 800b040:	78fb      	ldrb	r3, [r7, #3]
 800b042:	733b      	strb	r3, [r7, #12]
    info.result = NULL;
 800b044:	2300      	movs	r3, #0
 800b046:	613b      	str	r3, [r7, #16]

    lv_res_t res;
    res = lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STYLE, &info);
 800b048:	f107 030c 	add.w	r3, r7, #12
 800b04c:	461a      	mov	r2, r3
 800b04e:	2108      	movs	r1, #8
 800b050:	6878      	ldr	r0, [r7, #4]
 800b052:	f7ff fd4d 	bl	800aaf0 <lv_signal_send>
 800b056:	4603      	mov	r3, r0
 800b058:	75fb      	strb	r3, [r7, #23]

    if(res != LV_RES_OK) return NULL;
 800b05a:	7dfb      	ldrb	r3, [r7, #23]
 800b05c:	2b01      	cmp	r3, #1
 800b05e:	d001      	beq.n	800b064 <lv_obj_get_style_list+0x3c>
 800b060:	2300      	movs	r3, #0
 800b062:	e000      	b.n	800b066 <lv_obj_get_style_list+0x3e>

    return info.result;
 800b064:	693b      	ldr	r3, [r7, #16]
}
 800b066:	4618      	mov	r0, r3
 800b068:	3718      	adds	r7, #24
 800b06a:	46bd      	mov	sp, r7
 800b06c:	bd80      	pop	{r7, pc}
	...

0800b070 <_lv_obj_get_style_int>:
 * @note shouldn't be used directly. Use the specific property get functions instead.
 *       For example: `lv_obj_style_get_border_width()`
 * @note for performance reasons it's not checked if the property really has integer type
 */
lv_style_int_t _lv_obj_get_style_int(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)
{
 800b070:	b580      	push	{r7, lr}
 800b072:	b088      	sub	sp, #32
 800b074:	af00      	add	r7, sp, #0
 800b076:	6078      	str	r0, [r7, #4]
 800b078:	460b      	mov	r3, r1
 800b07a:	70fb      	strb	r3, [r7, #3]
 800b07c:	4613      	mov	r3, r2
 800b07e:	803b      	strh	r3, [r7, #0]
    lv_style_property_t prop_ori = prop;
 800b080:	883b      	ldrh	r3, [r7, #0]
 800b082:	833b      	strh	r3, [r7, #24]

    lv_style_attr_t attr;
    attr = prop_ori >> 8;
 800b084:	8b3b      	ldrh	r3, [r7, #24]
 800b086:	0a1b      	lsrs	r3, r3, #8
 800b088:	b29b      	uxth	r3, r3
 800b08a:	75fb      	strb	r3, [r7, #23]

    lv_style_int_t value_act;
    lv_res_t res = LV_RES_INV;
 800b08c:	2300      	movs	r3, #0
 800b08e:	75bb      	strb	r3, [r7, #22]
    const lv_obj_t * parent = obj;
 800b090:	687b      	ldr	r3, [r7, #4]
 800b092:	61fb      	str	r3, [r7, #28]
    while(parent) {
 800b094:	e1ce      	b.n	800b434 <_lv_obj_get_style_int+0x3c4>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
 800b096:	78fb      	ldrb	r3, [r7, #3]
 800b098:	4619      	mov	r1, r3
 800b09a:	69f8      	ldr	r0, [r7, #28]
 800b09c:	f7ff ffc4 	bl	800b028 <lv_obj_get_style_list>
 800b0a0:	6138      	str	r0, [r7, #16]
        if(!list->ignore_cache && list->style_cnt > 0) {
 800b0a2:	693b      	ldr	r3, [r7, #16]
 800b0a4:	795b      	ldrb	r3, [r3, #5]
 800b0a6:	f003 0308 	and.w	r3, r3, #8
 800b0aa:	b2db      	uxtb	r3, r3
 800b0ac:	2b00      	cmp	r3, #0
 800b0ae:	f040 8196 	bne.w	800b3de <_lv_obj_get_style_int+0x36e>
 800b0b2:	693b      	ldr	r3, [r7, #16]
 800b0b4:	791b      	ldrb	r3, [r3, #4]
 800b0b6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800b0ba:	b2db      	uxtb	r3, r3
 800b0bc:	2b00      	cmp	r3, #0
 800b0be:	f000 818e 	beq.w	800b3de <_lv_obj_get_style_int+0x36e>
            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));
 800b0c2:	693b      	ldr	r3, [r7, #16]
 800b0c4:	795b      	ldrb	r3, [r3, #5]
 800b0c6:	f003 0304 	and.w	r3, r3, #4
 800b0ca:	b2db      	uxtb	r3, r3
 800b0cc:	2b00      	cmp	r3, #0
 800b0ce:	d108      	bne.n	800b0e2 <_lv_obj_get_style_int+0x72>
 800b0d0:	883b      	ldrh	r3, [r7, #0]
 800b0d2:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800b0d6:	b29a      	uxth	r2, r3
 800b0d8:	78fb      	ldrb	r3, [r7, #3]
 800b0da:	4619      	mov	r1, r3
 800b0dc:	69f8      	ldr	r0, [r7, #28]
 800b0de:	f002 fd49 	bl	800db74 <update_style_cache>

            bool def = false;
 800b0e2:	2300      	movs	r3, #0
 800b0e4:	76fb      	strb	r3, [r7, #27]
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
 800b0e6:	883b      	ldrh	r3, [r7, #0]
 800b0e8:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800b0ec:	f248 02a0 	movw	r2, #32928	; 0x80a0
 800b0f0:	4293      	cmp	r3, r2
 800b0f2:	f000 8150 	beq.w	800b396 <_lv_obj_get_style_int+0x326>
 800b0f6:	f248 02a0 	movw	r2, #32928	; 0x80a0
 800b0fa:	4293      	cmp	r3, r2
 800b0fc:	f300 816c 	bgt.w	800b3d8 <_lv_obj_get_style_int+0x368>
 800b100:	f248 0283 	movw	r2, #32899	; 0x8083
 800b104:	4293      	cmp	r3, r2
 800b106:	f000 8146 	beq.w	800b396 <_lv_obj_get_style_int+0x326>
 800b10a:	f248 0283 	movw	r2, #32899	; 0x8083
 800b10e:	4293      	cmp	r3, r2
 800b110:	f300 8162 	bgt.w	800b3d8 <_lv_obj_get_style_int+0x368>
 800b114:	f248 0281 	movw	r2, #32897	; 0x8081
 800b118:	4293      	cmp	r3, r2
 800b11a:	f300 815d 	bgt.w	800b3d8 <_lv_obj_get_style_int+0x368>
 800b11e:	f248 0280 	movw	r2, #32896	; 0x8080
 800b122:	4293      	cmp	r3, r2
 800b124:	f280 80dd 	bge.w	800b2e2 <_lv_obj_get_style_int+0x272>
 800b128:	2b91      	cmp	r3, #145	; 0x91
 800b12a:	f000 8134 	beq.w	800b396 <_lv_obj_get_style_int+0x326>
 800b12e:	2b91      	cmp	r3, #145	; 0x91
 800b130:	f300 8152 	bgt.w	800b3d8 <_lv_obj_get_style_int+0x368>
 800b134:	2b50      	cmp	r3, #80	; 0x50
 800b136:	f300 80b9 	bgt.w	800b2ac <_lv_obj_get_style_int+0x23c>
 800b13a:	2b00      	cmp	r3, #0
 800b13c:	dc0f      	bgt.n	800b15e <_lv_obj_get_style_int+0xee>
 800b13e:	e14b      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
 800b140:	3b54      	subs	r3, #84	; 0x54
 800b142:	4ac0      	ldr	r2, [pc, #768]	; (800b444 <_lv_obj_get_style_int+0x3d4>)
 800b144:	fa22 f303 	lsr.w	r3, r2, r3
 800b148:	f003 0301 	and.w	r3, r3, #1
 800b14c:	2b00      	cmp	r3, #0
 800b14e:	bf14      	ite	ne
 800b150:	2301      	movne	r3, #1
 800b152:	2300      	moveq	r3, #0
 800b154:	b2db      	uxtb	r3, r3
 800b156:	2b00      	cmp	r3, #0
 800b158:	f040 811d 	bne.w	800b396 <_lv_obj_get_style_int+0x326>
 800b15c:	e13c      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
 800b15e:	3b01      	subs	r3, #1
 800b160:	2b4f      	cmp	r3, #79	; 0x4f
 800b162:	f200 8139 	bhi.w	800b3d8 <_lv_obj_get_style_int+0x368>
 800b166:	a201      	add	r2, pc, #4	; (adr r2, 800b16c <_lv_obj_get_style_int+0xfc>)
 800b168:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b16c:	0800b35b 	.word	0x0800b35b
 800b170:	0800b2cf 	.word	0x0800b2cf
 800b174:	0800b3d9 	.word	0x0800b3d9
 800b178:	0800b2f7 	.word	0x0800b2f7
 800b17c:	0800b2f7 	.word	0x0800b2f7
 800b180:	0800b2f7 	.word	0x0800b2f7
 800b184:	0800b2f7 	.word	0x0800b2f7
 800b188:	0800b3d9 	.word	0x0800b3d9
 800b18c:	0800b3d9 	.word	0x0800b3d9
 800b190:	0800b3d9 	.word	0x0800b3d9
 800b194:	0800b3d9 	.word	0x0800b3d9
 800b198:	0800b3d9 	.word	0x0800b3d9
 800b19c:	0800b3d9 	.word	0x0800b3d9
 800b1a0:	0800b3d9 	.word	0x0800b3d9
 800b1a4:	0800b3d9 	.word	0x0800b3d9
 800b1a8:	0800b383 	.word	0x0800b383
 800b1ac:	0800b383 	.word	0x0800b383
 800b1b0:	0800b383 	.word	0x0800b383
 800b1b4:	0800b383 	.word	0x0800b383
 800b1b8:	0800b3d9 	.word	0x0800b3d9
 800b1bc:	0800b3d9 	.word	0x0800b3d9
 800b1c0:	0800b3d9 	.word	0x0800b3d9
 800b1c4:	0800b3d9 	.word	0x0800b3d9
 800b1c8:	0800b3d9 	.word	0x0800b3d9
 800b1cc:	0800b3d9 	.word	0x0800b3d9
 800b1d0:	0800b3d9 	.word	0x0800b3d9
 800b1d4:	0800b3d9 	.word	0x0800b3d9
 800b1d8:	0800b3d9 	.word	0x0800b3d9
 800b1dc:	0800b3d9 	.word	0x0800b3d9
 800b1e0:	0800b3d9 	.word	0x0800b3d9
 800b1e4:	0800b3d9 	.word	0x0800b3d9
 800b1e8:	0800b397 	.word	0x0800b397
 800b1ec:	0800b3d9 	.word	0x0800b3d9
 800b1f0:	0800b3d9 	.word	0x0800b3d9
 800b1f4:	0800b2bb 	.word	0x0800b2bb
 800b1f8:	0800b3d9 	.word	0x0800b3d9
 800b1fc:	0800b3d9 	.word	0x0800b3d9
 800b200:	0800b3d9 	.word	0x0800b3d9
 800b204:	0800b3d9 	.word	0x0800b3d9
 800b208:	0800b3d9 	.word	0x0800b3d9
 800b20c:	0800b3d9 	.word	0x0800b3d9
 800b210:	0800b3d9 	.word	0x0800b3d9
 800b214:	0800b3d9 	.word	0x0800b3d9
 800b218:	0800b3d9 	.word	0x0800b3d9
 800b21c:	0800b3d9 	.word	0x0800b3d9
 800b220:	0800b3d9 	.word	0x0800b3d9
 800b224:	0800b3d9 	.word	0x0800b3d9
 800b228:	0800b30b 	.word	0x0800b30b
 800b22c:	0800b31f 	.word	0x0800b31f
 800b230:	0800b397 	.word	0x0800b397
 800b234:	0800b333 	.word	0x0800b333
 800b238:	0800b3d9 	.word	0x0800b3d9
 800b23c:	0800b3d9 	.word	0x0800b3d9
 800b240:	0800b3d9 	.word	0x0800b3d9
 800b244:	0800b3d9 	.word	0x0800b3d9
 800b248:	0800b3d9 	.word	0x0800b3d9
 800b24c:	0800b3d9 	.word	0x0800b3d9
 800b250:	0800b3d9 	.word	0x0800b3d9
 800b254:	0800b3d9 	.word	0x0800b3d9
 800b258:	0800b3d9 	.word	0x0800b3d9
 800b25c:	0800b3d9 	.word	0x0800b3d9
 800b260:	0800b3d9 	.word	0x0800b3d9
 800b264:	0800b3d9 	.word	0x0800b3d9
 800b268:	0800b347 	.word	0x0800b347
 800b26c:	0800b3d9 	.word	0x0800b3d9
 800b270:	0800b397 	.word	0x0800b397
 800b274:	0800b3d9 	.word	0x0800b3d9
 800b278:	0800b3d9 	.word	0x0800b3d9
 800b27c:	0800b3d9 	.word	0x0800b3d9
 800b280:	0800b3d9 	.word	0x0800b3d9
 800b284:	0800b3d9 	.word	0x0800b3d9
 800b288:	0800b3d9 	.word	0x0800b3d9
 800b28c:	0800b3d9 	.word	0x0800b3d9
 800b290:	0800b3d9 	.word	0x0800b3d9
 800b294:	0800b3d9 	.word	0x0800b3d9
 800b298:	0800b3d9 	.word	0x0800b3d9
 800b29c:	0800b3d9 	.word	0x0800b3d9
 800b2a0:	0800b3d9 	.word	0x0800b3d9
 800b2a4:	0800b3d9 	.word	0x0800b3d9
 800b2a8:	0800b36f 	.word	0x0800b36f
 800b2ac:	2b72      	cmp	r3, #114	; 0x72
 800b2ae:	f300 8093 	bgt.w	800b3d8 <_lv_obj_get_style_int+0x368>
 800b2b2:	2b54      	cmp	r3, #84	; 0x54
 800b2b4:	f6bf af44 	bge.w	800b140 <_lv_obj_get_style_int+0xd0>
 800b2b8:	e08e      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                case LV_STYLE_BG_GRAD_DIR:
                    if(list->bg_grad_dir_none) def = true;
 800b2ba:	693b      	ldr	r3, [r7, #16]
 800b2bc:	799b      	ldrb	r3, [r3, #6]
 800b2be:	f003 0310 	and.w	r3, r3, #16
 800b2c2:	b2db      	uxtb	r3, r3
 800b2c4:	2b00      	cmp	r3, #0
 800b2c6:	d070      	beq.n	800b3aa <_lv_obj_get_style_int+0x33a>
 800b2c8:	2301      	movs	r3, #1
 800b2ca:	76fb      	strb	r3, [r7, #27]
                    break;
 800b2cc:	e06d      	b.n	800b3aa <_lv_obj_get_style_int+0x33a>
                case LV_STYLE_CLIP_CORNER:
                    if(list->clip_corner_off) def = true;
 800b2ce:	693b      	ldr	r3, [r7, #16]
 800b2d0:	795b      	ldrb	r3, [r3, #5]
 800b2d2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b2d6:	b2db      	uxtb	r3, r3
 800b2d8:	2b00      	cmp	r3, #0
 800b2da:	d068      	beq.n	800b3ae <_lv_obj_get_style_int+0x33e>
 800b2dc:	2301      	movs	r3, #1
 800b2de:	76fb      	strb	r3, [r7, #27]
                    break;
 800b2e0:	e065      	b.n	800b3ae <_lv_obj_get_style_int+0x33e>
                case LV_STYLE_TEXT_LETTER_SPACE:
                case LV_STYLE_TEXT_LINE_SPACE:
                    if(list->text_space_zero) def = true;
 800b2e2:	693b      	ldr	r3, [r7, #16]
 800b2e4:	79db      	ldrb	r3, [r3, #7]
 800b2e6:	f003 0320 	and.w	r3, r3, #32
 800b2ea:	b2db      	uxtb	r3, r3
 800b2ec:	2b00      	cmp	r3, #0
 800b2ee:	d060      	beq.n	800b3b2 <_lv_obj_get_style_int+0x342>
 800b2f0:	2301      	movs	r3, #1
 800b2f2:	76fb      	strb	r3, [r7, #27]
                    break;
 800b2f4:	e05d      	b.n	800b3b2 <_lv_obj_get_style_int+0x342>
                case LV_STYLE_TRANSFORM_ANGLE:
                case LV_STYLE_TRANSFORM_WIDTH:
                case LV_STYLE_TRANSFORM_HEIGHT:
                case LV_STYLE_TRANSFORM_ZOOM:
                    if(list->transform_all_zero) def = true;
 800b2f6:	693b      	ldr	r3, [r7, #16]
 800b2f8:	795b      	ldrb	r3, [r3, #5]
 800b2fa:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800b2fe:	b2db      	uxtb	r3, r3
 800b300:	2b00      	cmp	r3, #0
 800b302:	d058      	beq.n	800b3b6 <_lv_obj_get_style_int+0x346>
 800b304:	2301      	movs	r3, #1
 800b306:	76fb      	strb	r3, [r7, #27]
                    break;
 800b308:	e055      	b.n	800b3b6 <_lv_obj_get_style_int+0x346>
                case LV_STYLE_BORDER_WIDTH:
                    if(list->border_width_zero) def = true;
 800b30a:	693b      	ldr	r3, [r7, #16]
 800b30c:	799b      	ldrb	r3, [r3, #6]
 800b30e:	f003 0320 	and.w	r3, r3, #32
 800b312:	b2db      	uxtb	r3, r3
 800b314:	2b00      	cmp	r3, #0
 800b316:	d050      	beq.n	800b3ba <_lv_obj_get_style_int+0x34a>
 800b318:	2301      	movs	r3, #1
 800b31a:	76fb      	strb	r3, [r7, #27]
                    break;
 800b31c:	e04d      	b.n	800b3ba <_lv_obj_get_style_int+0x34a>
                case LV_STYLE_BORDER_SIDE:
                    if(list->border_side_full) def = true;
 800b31e:	693b      	ldr	r3, [r7, #16]
 800b320:	799b      	ldrb	r3, [r3, #6]
 800b322:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b326:	b2db      	uxtb	r3, r3
 800b328:	2b00      	cmp	r3, #0
 800b32a:	d048      	beq.n	800b3be <_lv_obj_get_style_int+0x34e>
 800b32c:	2301      	movs	r3, #1
 800b32e:	76fb      	strb	r3, [r7, #27]
                    break;
 800b330:	e045      	b.n	800b3be <_lv_obj_get_style_int+0x34e>
                case LV_STYLE_BORDER_POST:
                    if(list->border_post_off) def = true;
 800b332:	693b      	ldr	r3, [r7, #16]
 800b334:	799b      	ldrb	r3, [r3, #6]
 800b336:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800b33a:	b2db      	uxtb	r3, r3
 800b33c:	2b00      	cmp	r3, #0
 800b33e:	d040      	beq.n	800b3c2 <_lv_obj_get_style_int+0x352>
 800b340:	2301      	movs	r3, #1
 800b342:	76fb      	strb	r3, [r7, #27]
                    break;
 800b344:	e03d      	b.n	800b3c2 <_lv_obj_get_style_int+0x352>
                case LV_STYLE_OUTLINE_WIDTH:
                    if(list->outline_width_zero) def = true;
 800b346:	693b      	ldr	r3, [r7, #16]
 800b348:	79db      	ldrb	r3, [r3, #7]
 800b34a:	f003 0301 	and.w	r3, r3, #1
 800b34e:	b2db      	uxtb	r3, r3
 800b350:	2b00      	cmp	r3, #0
 800b352:	d038      	beq.n	800b3c6 <_lv_obj_get_style_int+0x356>
 800b354:	2301      	movs	r3, #1
 800b356:	76fb      	strb	r3, [r7, #27]
                    break;
 800b358:	e035      	b.n	800b3c6 <_lv_obj_get_style_int+0x356>
                case LV_STYLE_RADIUS:
                    if(list->radius_zero) def = true;
 800b35a:	693b      	ldr	r3, [r7, #16]
 800b35c:	795b      	ldrb	r3, [r3, #5]
 800b35e:	f003 0310 	and.w	r3, r3, #16
 800b362:	b2db      	uxtb	r3, r3
 800b364:	2b00      	cmp	r3, #0
 800b366:	d030      	beq.n	800b3ca <_lv_obj_get_style_int+0x35a>
 800b368:	2301      	movs	r3, #1
 800b36a:	76fb      	strb	r3, [r7, #27]
                    break;
 800b36c:	e02d      	b.n	800b3ca <_lv_obj_get_style_int+0x35a>
                case LV_STYLE_SHADOW_WIDTH:
                    if(list->shadow_width_zero) def = true;
 800b36e:	693b      	ldr	r3, [r7, #16]
 800b370:	79db      	ldrb	r3, [r3, #7]
 800b372:	f003 0304 	and.w	r3, r3, #4
 800b376:	b2db      	uxtb	r3, r3
 800b378:	2b00      	cmp	r3, #0
 800b37a:	d028      	beq.n	800b3ce <_lv_obj_get_style_int+0x35e>
 800b37c:	2301      	movs	r3, #1
 800b37e:	76fb      	strb	r3, [r7, #27]
                    break;
 800b380:	e025      	b.n	800b3ce <_lv_obj_get_style_int+0x35e>
                case LV_STYLE_PAD_TOP:
                case LV_STYLE_PAD_BOTTOM:
                case LV_STYLE_PAD_LEFT:
                case LV_STYLE_PAD_RIGHT:
                    if(list->pad_all_zero) def = true;
 800b382:	693b      	ldr	r3, [r7, #16]
 800b384:	799b      	ldrb	r3, [r3, #6]
 800b386:	f003 0301 	and.w	r3, r3, #1
 800b38a:	b2db      	uxtb	r3, r3
 800b38c:	2b00      	cmp	r3, #0
 800b38e:	d020      	beq.n	800b3d2 <_lv_obj_get_style_int+0x362>
 800b390:	2301      	movs	r3, #1
 800b392:	76fb      	strb	r3, [r7, #27]
                    break;
 800b394:	e01d      	b.n	800b3d2 <_lv_obj_get_style_int+0x362>
                case LV_STYLE_OUTLINE_BLEND_MODE:
                case LV_STYLE_PATTERN_BLEND_MODE:
                case LV_STYLE_SHADOW_BLEND_MODE:
                case LV_STYLE_TEXT_BLEND_MODE:
                case LV_STYLE_VALUE_BLEND_MODE:
                    if(list->blend_mode_all_normal) def = true;
 800b396:	693b      	ldr	r3, [r7, #16]
 800b398:	799b      	ldrb	r3, [r3, #6]
 800b39a:	f003 0302 	and.w	r3, r3, #2
 800b39e:	b2db      	uxtb	r3, r3
 800b3a0:	2b00      	cmp	r3, #0
 800b3a2:	d018      	beq.n	800b3d6 <_lv_obj_get_style_int+0x366>
 800b3a4:	2301      	movs	r3, #1
 800b3a6:	76fb      	strb	r3, [r7, #27]
                    break;
 800b3a8:	e015      	b.n	800b3d6 <_lv_obj_get_style_int+0x366>
                    break;
 800b3aa:	bf00      	nop
 800b3ac:	e014      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                    break;
 800b3ae:	bf00      	nop
 800b3b0:	e012      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                    break;
 800b3b2:	bf00      	nop
 800b3b4:	e010      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                    break;
 800b3b6:	bf00      	nop
 800b3b8:	e00e      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                    break;
 800b3ba:	bf00      	nop
 800b3bc:	e00c      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                    break;
 800b3be:	bf00      	nop
 800b3c0:	e00a      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                    break;
 800b3c2:	bf00      	nop
 800b3c4:	e008      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                    break;
 800b3c6:	bf00      	nop
 800b3c8:	e006      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                    break;
 800b3ca:	bf00      	nop
 800b3cc:	e004      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                    break;
 800b3ce:	bf00      	nop
 800b3d0:	e002      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                    break;
 800b3d2:	bf00      	nop
 800b3d4:	e000      	b.n	800b3d8 <_lv_obj_get_style_int+0x368>
                    break;
 800b3d6:	bf00      	nop
            }

            if(def) {
 800b3d8:	7efb      	ldrb	r3, [r7, #27]
 800b3da:	2b00      	cmp	r3, #0
 800b3dc:	d12f      	bne.n	800b43e <_lv_obj_get_style_int+0x3ce>
                break;
            }
        }

        lv_state_t state = lv_obj_get_state(parent, part);
 800b3de:	78fb      	ldrb	r3, [r7, #3]
 800b3e0:	4619      	mov	r1, r3
 800b3e2:	69f8      	ldr	r0, [r7, #28]
 800b3e4:	f000 fac2 	bl	800b96c <lv_obj_get_state>
 800b3e8:	4603      	mov	r3, r0
 800b3ea:	73fb      	strb	r3, [r7, #15]
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
 800b3ec:	7bfb      	ldrb	r3, [r7, #15]
 800b3ee:	b29b      	uxth	r3, r3
 800b3f0:	021b      	lsls	r3, r3, #8
 800b3f2:	b29a      	uxth	r2, r3
 800b3f4:	8b3b      	ldrh	r3, [r7, #24]
 800b3f6:	4413      	add	r3, r2
 800b3f8:	803b      	strh	r3, [r7, #0]

        res = _lv_style_list_get_int(list, prop, &value_act);
 800b3fa:	f107 020c 	add.w	r2, r7, #12
 800b3fe:	883b      	ldrh	r3, [r7, #0]
 800b400:	4619      	mov	r1, r3
 800b402:	6938      	ldr	r0, [r7, #16]
 800b404:	f004 fddb 	bl	800ffbe <_lv_style_list_get_int>
 800b408:	4603      	mov	r3, r0
 800b40a:	75bb      	strb	r3, [r7, #22]
        if(res == LV_RES_OK) return value_act;
 800b40c:	7dbb      	ldrb	r3, [r7, #22]
 800b40e:	2b01      	cmp	r3, #1
 800b410:	d102      	bne.n	800b418 <_lv_obj_get_style_int+0x3a8>
 800b412:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 800b416:	e03a      	b.n	800b48e <_lv_obj_get_style_int+0x41e>

        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
 800b418:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800b41c:	2b00      	cmp	r3, #0
 800b41e:	da13      	bge.n	800b448 <_lv_obj_get_style_int+0x3d8>

        /*If not found, check the `MAIN` style first*/
        if(part != LV_OBJ_PART_MAIN) {
 800b420:	78fb      	ldrb	r3, [r7, #3]
 800b422:	2b00      	cmp	r3, #0
 800b424:	d002      	beq.n	800b42c <_lv_obj_get_style_int+0x3bc>
            part = LV_OBJ_PART_MAIN;
 800b426:	2300      	movs	r3, #0
 800b428:	70fb      	strb	r3, [r7, #3]
            continue;
 800b42a:	e003      	b.n	800b434 <_lv_obj_get_style_int+0x3c4>
        }

        /*Check the parent too.*/
        parent = lv_obj_get_parent(parent);
 800b42c:	69f8      	ldr	r0, [r7, #28]
 800b42e:	f7ff fc73 	bl	800ad18 <lv_obj_get_parent>
 800b432:	61f8      	str	r0, [r7, #28]
    while(parent) {
 800b434:	69fb      	ldr	r3, [r7, #28]
 800b436:	2b00      	cmp	r3, #0
 800b438:	f47f ae2d 	bne.w	800b096 <_lv_obj_get_style_int+0x26>
 800b43c:	e005      	b.n	800b44a <_lv_obj_get_style_int+0x3da>
                break;
 800b43e:	bf00      	nop
 800b440:	e003      	b.n	800b44a <_lv_obj_get_style_int+0x3da>
 800b442:	bf00      	nop
 800b444:	40001001 	.word	0x40001001
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
 800b448:	bf00      	nop
    }

    /*Handle unset values*/
    prop = prop & (~LV_STYLE_STATE_MASK);
 800b44a:	883b      	ldrh	r3, [r7, #0]
 800b44c:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800b450:	803b      	strh	r3, [r7, #0]
    switch(prop) {
 800b452:	883b      	ldrh	r3, [r7, #0]
 800b454:	2bc0      	cmp	r3, #192	; 0xc0
 800b456:	d012      	beq.n	800b47e <_lv_obj_get_style_int+0x40e>
 800b458:	2bc0      	cmp	r3, #192	; 0xc0
 800b45a:	dc17      	bgt.n	800b48c <_lv_obj_get_style_int+0x41c>
 800b45c:	2b31      	cmp	r3, #49	; 0x31
 800b45e:	d00a      	beq.n	800b476 <_lv_obj_get_style_int+0x406>
 800b460:	2b31      	cmp	r3, #49	; 0x31
 800b462:	dc13      	bgt.n	800b48c <_lv_obj_get_style_int+0x41c>
 800b464:	2b22      	cmp	r3, #34	; 0x22
 800b466:	d00c      	beq.n	800b482 <_lv_obj_get_style_int+0x412>
 800b468:	2b22      	cmp	r3, #34	; 0x22
 800b46a:	dc0f      	bgt.n	800b48c <_lv_obj_get_style_int+0x41c>
 800b46c:	2b03      	cmp	r3, #3
 800b46e:	d004      	beq.n	800b47a <_lv_obj_get_style_int+0x40a>
 800b470:	2b07      	cmp	r3, #7
 800b472:	d008      	beq.n	800b486 <_lv_obj_get_style_int+0x416>
 800b474:	e00a      	b.n	800b48c <_lv_obj_get_style_int+0x41c>
        case LV_STYLE_BORDER_SIDE:
            return LV_BORDER_SIDE_FULL;
 800b476:	230f      	movs	r3, #15
 800b478:	e009      	b.n	800b48e <_lv_obj_get_style_int+0x41e>
        case LV_STYLE_SIZE:
            return LV_DPI / 20;
 800b47a:	2306      	movs	r3, #6
 800b47c:	e007      	b.n	800b48e <_lv_obj_get_style_int+0x41e>
        case LV_STYLE_SCALE_WIDTH:
            return LV_DPI / 8;
 800b47e:	2310      	movs	r3, #16
 800b480:	e005      	b.n	800b48e <_lv_obj_get_style_int+0x41e>
        case LV_STYLE_BG_GRAD_STOP:
            return 255;
 800b482:	23ff      	movs	r3, #255	; 0xff
 800b484:	e003      	b.n	800b48e <_lv_obj_get_style_int+0x41e>
        case LV_STYLE_TRANSFORM_ZOOM:
            return LV_IMG_ZOOM_NONE;
 800b486:	f44f 7380 	mov.w	r3, #256	; 0x100
 800b48a:	e000      	b.n	800b48e <_lv_obj_get_style_int+0x41e>
    }

    return 0;
 800b48c:	2300      	movs	r3, #0
}
 800b48e:	4618      	mov	r0, r3
 800b490:	3720      	adds	r7, #32
 800b492:	46bd      	mov	sp, r7
 800b494:	bd80      	pop	{r7, pc}
 800b496:	bf00      	nop

0800b498 <_lv_obj_get_style_color>:
 * @note shouldn't be used directly. Use the specific property get functions instead.
 *       For example: `lv_obj_style_get_border_color()`
 * @note for performance reasons it's not checked if the property really has color type
 */
lv_color_t _lv_obj_get_style_color(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)
{
 800b498:	b590      	push	{r4, r7, lr}
 800b49a:	b087      	sub	sp, #28
 800b49c:	af00      	add	r7, sp, #0
 800b49e:	6078      	str	r0, [r7, #4]
 800b4a0:	460b      	mov	r3, r1
 800b4a2:	70fb      	strb	r3, [r7, #3]
 800b4a4:	4613      	mov	r3, r2
 800b4a6:	803b      	strh	r3, [r7, #0]
    lv_style_property_t prop_ori = prop;
 800b4a8:	883b      	ldrh	r3, [r7, #0]
 800b4aa:	827b      	strh	r3, [r7, #18]

    lv_style_attr_t attr;
    attr = prop_ori >> 8;
 800b4ac:	8a7b      	ldrh	r3, [r7, #18]
 800b4ae:	0a1b      	lsrs	r3, r3, #8
 800b4b0:	b29b      	uxth	r3, r3
 800b4b2:	747b      	strb	r3, [r7, #17]

    lv_color_t value_act;
    lv_res_t res = LV_RES_INV;
 800b4b4:	2300      	movs	r3, #0
 800b4b6:	743b      	strb	r3, [r7, #16]
    const lv_obj_t * parent = obj;
 800b4b8:	687b      	ldr	r3, [r7, #4]
 800b4ba:	617b      	str	r3, [r7, #20]
    while(parent) {
 800b4bc:	e02f      	b.n	800b51e <_lv_obj_get_style_color+0x86>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
 800b4be:	78fb      	ldrb	r3, [r7, #3]
 800b4c0:	4619      	mov	r1, r3
 800b4c2:	6978      	ldr	r0, [r7, #20]
 800b4c4:	f7ff fdb0 	bl	800b028 <lv_obj_get_style_list>
 800b4c8:	60f8      	str	r0, [r7, #12]

        lv_state_t state = lv_obj_get_state(parent, part);
 800b4ca:	78fb      	ldrb	r3, [r7, #3]
 800b4cc:	4619      	mov	r1, r3
 800b4ce:	6978      	ldr	r0, [r7, #20]
 800b4d0:	f000 fa4c 	bl	800b96c <lv_obj_get_state>
 800b4d4:	4603      	mov	r3, r0
 800b4d6:	72fb      	strb	r3, [r7, #11]
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
 800b4d8:	7afb      	ldrb	r3, [r7, #11]
 800b4da:	b29b      	uxth	r3, r3
 800b4dc:	021b      	lsls	r3, r3, #8
 800b4de:	b29a      	uxth	r2, r3
 800b4e0:	8a7b      	ldrh	r3, [r7, #18]
 800b4e2:	4413      	add	r3, r2
 800b4e4:	803b      	strh	r3, [r7, #0]

        res = _lv_style_list_get_color(list, prop, &value_act);
 800b4e6:	f107 0208 	add.w	r2, r7, #8
 800b4ea:	883b      	ldrh	r3, [r7, #0]
 800b4ec:	4619      	mov	r1, r3
 800b4ee:	68f8      	ldr	r0, [r7, #12]
 800b4f0:	f004 fde3 	bl	80100ba <_lv_style_list_get_color>
 800b4f4:	4603      	mov	r3, r0
 800b4f6:	743b      	strb	r3, [r7, #16]
        if(res == LV_RES_OK) return value_act;
 800b4f8:	7c3b      	ldrb	r3, [r7, #16]
 800b4fa:	2b01      	cmp	r3, #1
 800b4fc:	d101      	bne.n	800b502 <_lv_obj_get_style_color+0x6a>
 800b4fe:	893c      	ldrh	r4, [r7, #8]
 800b500:	e023      	b.n	800b54a <_lv_obj_get_style_color+0xb2>

        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
 800b502:	f997 3011 	ldrsb.w	r3, [r7, #17]
 800b506:	2b00      	cmp	r3, #0
 800b508:	da0d      	bge.n	800b526 <_lv_obj_get_style_color+0x8e>

        /*If not found, check the `MAIN` style first*/
        if(part != LV_OBJ_PART_MAIN) {
 800b50a:	78fb      	ldrb	r3, [r7, #3]
 800b50c:	2b00      	cmp	r3, #0
 800b50e:	d002      	beq.n	800b516 <_lv_obj_get_style_color+0x7e>
            part = LV_OBJ_PART_MAIN;
 800b510:	2300      	movs	r3, #0
 800b512:	70fb      	strb	r3, [r7, #3]
            continue;
 800b514:	e003      	b.n	800b51e <_lv_obj_get_style_color+0x86>
        }

        /*Check the parent too.*/
        parent = lv_obj_get_parent(parent);
 800b516:	6978      	ldr	r0, [r7, #20]
 800b518:	f7ff fbfe 	bl	800ad18 <lv_obj_get_parent>
 800b51c:	6178      	str	r0, [r7, #20]
    while(parent) {
 800b51e:	697b      	ldr	r3, [r7, #20]
 800b520:	2b00      	cmp	r3, #0
 800b522:	d1cc      	bne.n	800b4be <_lv_obj_get_style_color+0x26>
 800b524:	e000      	b.n	800b528 <_lv_obj_get_style_color+0x90>
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
 800b526:	bf00      	nop
    }

    /*Handle unset values*/
    prop = prop & (~LV_STYLE_STATE_MASK);
 800b528:	883b      	ldrh	r3, [r7, #0]
 800b52a:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800b52e:	803b      	strh	r3, [r7, #0]
    switch(prop) {
 800b530:	883b      	ldrh	r3, [r7, #0]
 800b532:	3b29      	subs	r3, #41	; 0x29
 800b534:	2b01      	cmp	r3, #1
 800b536:	d802      	bhi.n	800b53e <_lv_obj_get_style_color+0xa6>
        case LV_STYLE_BG_COLOR:
        case LV_STYLE_BG_GRAD_COLOR:
            return LV_COLOR_WHITE;
 800b538:	4b06      	ldr	r3, [pc, #24]	; (800b554 <_lv_obj_get_style_color+0xbc>)
 800b53a:	881c      	ldrh	r4, [r3, #0]
 800b53c:	e005      	b.n	800b54a <_lv_obj_get_style_color+0xb2>
    }

    return LV_COLOR_BLACK;
 800b53e:	f36f 0404 	bfc	r4, #0, #5
 800b542:	f36f 144a 	bfc	r4, #5, #6
 800b546:	f36f 24cf 	bfc	r4, #11, #5
}
 800b54a:	4623      	mov	r3, r4
 800b54c:	4618      	mov	r0, r3
 800b54e:	371c      	adds	r7, #28
 800b550:	46bd      	mov	sp, r7
 800b552:	bd90      	pop	{r4, r7, pc}
 800b554:	0802e43c 	.word	0x0802e43c

0800b558 <_lv_obj_get_style_opa>:
 * @note shouldn't be used directly. Use the specific property get functions instead.
 *       For example: `lv_obj_style_get_border_opa()`
 * @note for performance reasons it's not checked if the property really has opacity type
 */
lv_opa_t _lv_obj_get_style_opa(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)
{
 800b558:	b580      	push	{r7, lr}
 800b55a:	b088      	sub	sp, #32
 800b55c:	af00      	add	r7, sp, #0
 800b55e:	6078      	str	r0, [r7, #4]
 800b560:	460b      	mov	r3, r1
 800b562:	70fb      	strb	r3, [r7, #3]
 800b564:	4613      	mov	r3, r2
 800b566:	803b      	strh	r3, [r7, #0]
    lv_style_property_t prop_ori = prop;
 800b568:	883b      	ldrh	r3, [r7, #0]
 800b56a:	833b      	strh	r3, [r7, #24]

    lv_style_attr_t attr;
    attr = prop_ori >> 8;
 800b56c:	8b3b      	ldrh	r3, [r7, #24]
 800b56e:	0a1b      	lsrs	r3, r3, #8
 800b570:	b29b      	uxth	r3, r3
 800b572:	75fb      	strb	r3, [r7, #23]

    lv_opa_t value_act;
    lv_res_t res = LV_RES_INV;
 800b574:	2300      	movs	r3, #0
 800b576:	75bb      	strb	r3, [r7, #22]
    const lv_obj_t * parent = obj;
 800b578:	687b      	ldr	r3, [r7, #4]
 800b57a:	61fb      	str	r3, [r7, #28]
    while(parent) {
 800b57c:	e08f      	b.n	800b69e <_lv_obj_get_style_opa+0x146>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
 800b57e:	78fb      	ldrb	r3, [r7, #3]
 800b580:	4619      	mov	r1, r3
 800b582:	69f8      	ldr	r0, [r7, #28]
 800b584:	f7ff fd50 	bl	800b028 <lv_obj_get_style_list>
 800b588:	6138      	str	r0, [r7, #16]

        if(!list->ignore_cache && list->style_cnt > 0) {
 800b58a:	693b      	ldr	r3, [r7, #16]
 800b58c:	795b      	ldrb	r3, [r3, #5]
 800b58e:	f003 0308 	and.w	r3, r3, #8
 800b592:	b2db      	uxtb	r3, r3
 800b594:	2b00      	cmp	r3, #0
 800b596:	d158      	bne.n	800b64a <_lv_obj_get_style_opa+0xf2>
 800b598:	693b      	ldr	r3, [r7, #16]
 800b59a:	791b      	ldrb	r3, [r3, #4]
 800b59c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800b5a0:	b2db      	uxtb	r3, r3
 800b5a2:	2b00      	cmp	r3, #0
 800b5a4:	d051      	beq.n	800b64a <_lv_obj_get_style_opa+0xf2>
            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));
 800b5a6:	693b      	ldr	r3, [r7, #16]
 800b5a8:	795b      	ldrb	r3, [r3, #5]
 800b5aa:	f003 0304 	and.w	r3, r3, #4
 800b5ae:	b2db      	uxtb	r3, r3
 800b5b0:	2b00      	cmp	r3, #0
 800b5b2:	d108      	bne.n	800b5c6 <_lv_obj_get_style_opa+0x6e>
 800b5b4:	883b      	ldrh	r3, [r7, #0]
 800b5b6:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800b5ba:	b29a      	uxth	r2, r3
 800b5bc:	78fb      	ldrb	r3, [r7, #3]
 800b5be:	4619      	mov	r1, r3
 800b5c0:	69f8      	ldr	r0, [r7, #28]
 800b5c2:	f002 fad7 	bl	800db74 <update_style_cache>
            bool def = false;
 800b5c6:	2300      	movs	r3, #0
 800b5c8:	76fb      	strb	r3, [r7, #27]
            switch(prop & (~LV_STYLE_STATE_MASK)) {
 800b5ca:	883b      	ldrh	r3, [r7, #0]
 800b5cc:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800b5d0:	f248 02ad 	movw	r2, #32941	; 0x80ad
 800b5d4:	4293      	cmp	r3, r2
 800b5d6:	d026      	beq.n	800b626 <_lv_obj_get_style_opa+0xce>
 800b5d8:	f248 02ad 	movw	r2, #32941	; 0x80ad
 800b5dc:	4293      	cmp	r3, r2
 800b5de:	dc31      	bgt.n	800b644 <_lv_obj_get_style_opa+0xec>
 800b5e0:	2b2c      	cmp	r3, #44	; 0x2c
 800b5e2:	d00d      	beq.n	800b600 <_lv_obj_get_style_opa+0xa8>
 800b5e4:	f248 020c 	movw	r2, #32780	; 0x800c
 800b5e8:	4293      	cmp	r3, r2
 800b5ea:	d12b      	bne.n	800b644 <_lv_obj_get_style_opa+0xec>
                case LV_STYLE_OPA_SCALE:
                    if(list->opa_scale_cover) def = true;
 800b5ec:	693b      	ldr	r3, [r7, #16]
 800b5ee:	795b      	ldrb	r3, [r3, #5]
 800b5f0:	f003 0320 	and.w	r3, r3, #32
 800b5f4:	b2db      	uxtb	r3, r3
 800b5f6:	2b00      	cmp	r3, #0
 800b5f8:	d01f      	beq.n	800b63a <_lv_obj_get_style_opa+0xe2>
 800b5fa:	2301      	movs	r3, #1
 800b5fc:	76fb      	strb	r3, [r7, #27]
                    break;
 800b5fe:	e01c      	b.n	800b63a <_lv_obj_get_style_opa+0xe2>
                case LV_STYLE_BG_OPA:
                    if(list->bg_opa_cover) return LV_OPA_COVER;     /*Special case, not the default value is used*/
 800b600:	693b      	ldr	r3, [r7, #16]
 800b602:	799b      	ldrb	r3, [r3, #6]
 800b604:	f003 0308 	and.w	r3, r3, #8
 800b608:	b2db      	uxtb	r3, r3
 800b60a:	2b00      	cmp	r3, #0
 800b60c:	d001      	beq.n	800b612 <_lv_obj_get_style_opa+0xba>
 800b60e:	23ff      	movs	r3, #255	; 0xff
 800b610:	e061      	b.n	800b6d6 <_lv_obj_get_style_opa+0x17e>
                    if(list->bg_opa_transp) def = true;
 800b612:	693b      	ldr	r3, [r7, #16]
 800b614:	799b      	ldrb	r3, [r3, #6]
 800b616:	f003 0304 	and.w	r3, r3, #4
 800b61a:	b2db      	uxtb	r3, r3
 800b61c:	2b00      	cmp	r3, #0
 800b61e:	d00e      	beq.n	800b63e <_lv_obj_get_style_opa+0xe6>
 800b620:	2301      	movs	r3, #1
 800b622:	76fb      	strb	r3, [r7, #27]
                    break;
 800b624:	e00b      	b.n	800b63e <_lv_obj_get_style_opa+0xe6>
                case LV_STYLE_IMAGE_RECOLOR_OPA:
                    if(list->img_recolor_opa_transp) def = true;
 800b626:	693b      	ldr	r3, [r7, #16]
 800b628:	79db      	ldrb	r3, [r3, #7]
 800b62a:	f003 0310 	and.w	r3, r3, #16
 800b62e:	b2db      	uxtb	r3, r3
 800b630:	2b00      	cmp	r3, #0
 800b632:	d006      	beq.n	800b642 <_lv_obj_get_style_opa+0xea>
 800b634:	2301      	movs	r3, #1
 800b636:	76fb      	strb	r3, [r7, #27]
                    break;
 800b638:	e003      	b.n	800b642 <_lv_obj_get_style_opa+0xea>
                    break;
 800b63a:	bf00      	nop
 800b63c:	e002      	b.n	800b644 <_lv_obj_get_style_opa+0xec>
                    break;
 800b63e:	bf00      	nop
 800b640:	e000      	b.n	800b644 <_lv_obj_get_style_opa+0xec>
                    break;
 800b642:	bf00      	nop
            }

            if(def) {
 800b644:	7efb      	ldrb	r3, [r7, #27]
 800b646:	2b00      	cmp	r3, #0
 800b648:	d12e      	bne.n	800b6a8 <_lv_obj_get_style_opa+0x150>
                break;
            }
        }


        lv_state_t state = lv_obj_get_state(parent, part);
 800b64a:	78fb      	ldrb	r3, [r7, #3]
 800b64c:	4619      	mov	r1, r3
 800b64e:	69f8      	ldr	r0, [r7, #28]
 800b650:	f000 f98c 	bl	800b96c <lv_obj_get_state>
 800b654:	4603      	mov	r3, r0
 800b656:	73fb      	strb	r3, [r7, #15]
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
 800b658:	7bfb      	ldrb	r3, [r7, #15]
 800b65a:	b29b      	uxth	r3, r3
 800b65c:	021b      	lsls	r3, r3, #8
 800b65e:	b29a      	uxth	r2, r3
 800b660:	8b3b      	ldrh	r3, [r7, #24]
 800b662:	4413      	add	r3, r2
 800b664:	803b      	strh	r3, [r7, #0]

        res = _lv_style_list_get_opa(list, prop, &value_act);
 800b666:	f107 020e 	add.w	r2, r7, #14
 800b66a:	883b      	ldrh	r3, [r7, #0]
 800b66c:	4619      	mov	r1, r3
 800b66e:	6938      	ldr	r0, [r7, #16]
 800b670:	f004 fd9e 	bl	80101b0 <_lv_style_list_get_opa>
 800b674:	4603      	mov	r3, r0
 800b676:	75bb      	strb	r3, [r7, #22]
        if(res == LV_RES_OK) return value_act;
 800b678:	7dbb      	ldrb	r3, [r7, #22]
 800b67a:	2b01      	cmp	r3, #1
 800b67c:	d101      	bne.n	800b682 <_lv_obj_get_style_opa+0x12a>
 800b67e:	7bbb      	ldrb	r3, [r7, #14]
 800b680:	e029      	b.n	800b6d6 <_lv_obj_get_style_opa+0x17e>

        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
 800b682:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800b686:	2b00      	cmp	r3, #0
 800b688:	da10      	bge.n	800b6ac <_lv_obj_get_style_opa+0x154>

        /*If not found, check the `MAIN` style first*/
        if(part != LV_OBJ_PART_MAIN) {
 800b68a:	78fb      	ldrb	r3, [r7, #3]
 800b68c:	2b00      	cmp	r3, #0
 800b68e:	d002      	beq.n	800b696 <_lv_obj_get_style_opa+0x13e>
            part = LV_OBJ_PART_MAIN;
 800b690:	2300      	movs	r3, #0
 800b692:	70fb      	strb	r3, [r7, #3]
            continue;
 800b694:	e003      	b.n	800b69e <_lv_obj_get_style_opa+0x146>
        }

        /*Check the parent too.*/
        parent = lv_obj_get_parent(parent);
 800b696:	69f8      	ldr	r0, [r7, #28]
 800b698:	f7ff fb3e 	bl	800ad18 <lv_obj_get_parent>
 800b69c:	61f8      	str	r0, [r7, #28]
    while(parent) {
 800b69e:	69fb      	ldr	r3, [r7, #28]
 800b6a0:	2b00      	cmp	r3, #0
 800b6a2:	f47f af6c 	bne.w	800b57e <_lv_obj_get_style_opa+0x26>
 800b6a6:	e002      	b.n	800b6ae <_lv_obj_get_style_opa+0x156>
                break;
 800b6a8:	bf00      	nop
 800b6aa:	e000      	b.n	800b6ae <_lv_obj_get_style_opa+0x156>
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
 800b6ac:	bf00      	nop
    }

    /*Handle unset values*/
    prop = prop & (~LV_STYLE_STATE_MASK);
 800b6ae:	883b      	ldrh	r3, [r7, #0]
 800b6b0:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800b6b4:	803b      	strh	r3, [r7, #0]
    switch(prop) {
 800b6b6:	883b      	ldrh	r3, [r7, #0]
 800b6b8:	f248 02ad 	movw	r2, #32941	; 0x80ad
 800b6bc:	4293      	cmp	r3, r2
 800b6be:	d007      	beq.n	800b6d0 <_lv_obj_get_style_opa+0x178>
 800b6c0:	f248 02ad 	movw	r2, #32941	; 0x80ad
 800b6c4:	4293      	cmp	r3, r2
 800b6c6:	dc05      	bgt.n	800b6d4 <_lv_obj_get_style_opa+0x17c>
 800b6c8:	2b2c      	cmp	r3, #44	; 0x2c
 800b6ca:	d001      	beq.n	800b6d0 <_lv_obj_get_style_opa+0x178>
 800b6cc:	2b6d      	cmp	r3, #109	; 0x6d
 800b6ce:	d101      	bne.n	800b6d4 <_lv_obj_get_style_opa+0x17c>
        case LV_STYLE_BG_OPA:
        case LV_STYLE_IMAGE_RECOLOR_OPA:
        case LV_STYLE_PATTERN_RECOLOR_OPA:
            return LV_OPA_TRANSP;
 800b6d0:	2300      	movs	r3, #0
 800b6d2:	e000      	b.n	800b6d6 <_lv_obj_get_style_opa+0x17e>
    }

    return LV_OPA_COVER;
 800b6d4:	23ff      	movs	r3, #255	; 0xff
}
 800b6d6:	4618      	mov	r0, r3
 800b6d8:	3720      	adds	r7, #32
 800b6da:	46bd      	mov	sp, r7
 800b6dc:	bd80      	pop	{r7, pc}
	...

0800b6e0 <_lv_obj_get_style_ptr>:
 * @note shouldn't be used directly. Use the specific property get functions instead.
 *       For example: `lv_obj_style_get_border_opa()`
 * @note for performance reasons it's not checked if the property really has pointer type
 */
const void * _lv_obj_get_style_ptr(const lv_obj_t * obj, uint8_t part, lv_style_property_t prop)
{
 800b6e0:	b580      	push	{r7, lr}
 800b6e2:	b088      	sub	sp, #32
 800b6e4:	af00      	add	r7, sp, #0
 800b6e6:	6078      	str	r0, [r7, #4]
 800b6e8:	460b      	mov	r3, r1
 800b6ea:	70fb      	strb	r3, [r7, #3]
 800b6ec:	4613      	mov	r3, r2
 800b6ee:	803b      	strh	r3, [r7, #0]
    lv_style_property_t prop_ori = prop;
 800b6f0:	883b      	ldrh	r3, [r7, #0]
 800b6f2:	833b      	strh	r3, [r7, #24]

    lv_style_attr_t attr;
    attr = prop_ori >> 8;
 800b6f4:	8b3b      	ldrh	r3, [r7, #24]
 800b6f6:	0a1b      	lsrs	r3, r3, #8
 800b6f8:	b29b      	uxth	r3, r3
 800b6fa:	75fb      	strb	r3, [r7, #23]

    const void * value_act;
    lv_res_t res = LV_RES_INV;
 800b6fc:	2300      	movs	r3, #0
 800b6fe:	75bb      	strb	r3, [r7, #22]
    const lv_obj_t * parent = obj;
 800b700:	687b      	ldr	r3, [r7, #4]
 800b702:	61fb      	str	r3, [r7, #28]
    while(parent) {
 800b704:	e084      	b.n	800b810 <_lv_obj_get_style_ptr+0x130>
        lv_style_list_t * list = lv_obj_get_style_list(parent, part);
 800b706:	78fb      	ldrb	r3, [r7, #3]
 800b708:	4619      	mov	r1, r3
 800b70a:	69f8      	ldr	r0, [r7, #28]
 800b70c:	f7ff fc8c 	bl	800b028 <lv_obj_get_style_list>
 800b710:	6138      	str	r0, [r7, #16]

        if(!list->ignore_cache && list->style_cnt > 0) {
 800b712:	693b      	ldr	r3, [r7, #16]
 800b714:	795b      	ldrb	r3, [r3, #5]
 800b716:	f003 0308 	and.w	r3, r3, #8
 800b71a:	b2db      	uxtb	r3, r3
 800b71c:	2b00      	cmp	r3, #0
 800b71e:	d14d      	bne.n	800b7bc <_lv_obj_get_style_ptr+0xdc>
 800b720:	693b      	ldr	r3, [r7, #16]
 800b722:	791b      	ldrb	r3, [r3, #4]
 800b724:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800b728:	b2db      	uxtb	r3, r3
 800b72a:	2b00      	cmp	r3, #0
 800b72c:	d046      	beq.n	800b7bc <_lv_obj_get_style_ptr+0xdc>
            if(!list->valid_cache) update_style_cache((lv_obj_t *)parent, part, prop  & (~LV_STYLE_STATE_MASK));
 800b72e:	693b      	ldr	r3, [r7, #16]
 800b730:	795b      	ldrb	r3, [r3, #5]
 800b732:	f003 0304 	and.w	r3, r3, #4
 800b736:	b2db      	uxtb	r3, r3
 800b738:	2b00      	cmp	r3, #0
 800b73a:	d108      	bne.n	800b74e <_lv_obj_get_style_ptr+0x6e>
 800b73c:	883b      	ldrh	r3, [r7, #0]
 800b73e:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800b742:	b29a      	uxth	r2, r3
 800b744:	78fb      	ldrb	r3, [r7, #3]
 800b746:	4619      	mov	r1, r3
 800b748:	69f8      	ldr	r0, [r7, #28]
 800b74a:	f002 fa13 	bl	800db74 <update_style_cache>
            bool def = false;
 800b74e:	2300      	movs	r3, #0
 800b750:	76fb      	strb	r3, [r7, #27]
            switch(prop  & (~LV_STYLE_STATE_MASK)) {
 800b752:	883b      	ldrh	r3, [r7, #0]
 800b754:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800b758:	f248 028e 	movw	r2, #32910	; 0x808e
 800b75c:	4293      	cmp	r3, r2
 800b75e:	d01b      	beq.n	800b798 <_lv_obj_get_style_ptr+0xb8>
 800b760:	f248 028e 	movw	r2, #32910	; 0x808e
 800b764:	4293      	cmp	r3, r2
 800b766:	dc26      	bgt.n	800b7b6 <_lv_obj_get_style_ptr+0xd6>
 800b768:	2b6e      	cmp	r3, #110	; 0x6e
 800b76a:	d00b      	beq.n	800b784 <_lv_obj_get_style_ptr+0xa4>
 800b76c:	2b7f      	cmp	r3, #127	; 0x7f
 800b76e:	d122      	bne.n	800b7b6 <_lv_obj_get_style_ptr+0xd6>
                case LV_STYLE_VALUE_STR:
                    if(list->value_txt_str) def = true;
 800b770:	693b      	ldr	r3, [r7, #16]
 800b772:	79db      	ldrb	r3, [r3, #7]
 800b774:	f003 0308 	and.w	r3, r3, #8
 800b778:	b2db      	uxtb	r3, r3
 800b77a:	2b00      	cmp	r3, #0
 800b77c:	d016      	beq.n	800b7ac <_lv_obj_get_style_ptr+0xcc>
 800b77e:	2301      	movs	r3, #1
 800b780:	76fb      	strb	r3, [r7, #27]
                    break;
 800b782:	e013      	b.n	800b7ac <_lv_obj_get_style_ptr+0xcc>
                case LV_STYLE_PATTERN_IMAGE:
                    if(list->pattern_img_null) def = true;
 800b784:	693b      	ldr	r3, [r7, #16]
 800b786:	79db      	ldrb	r3, [r3, #7]
 800b788:	f003 0302 	and.w	r3, r3, #2
 800b78c:	b2db      	uxtb	r3, r3
 800b78e:	2b00      	cmp	r3, #0
 800b790:	d00e      	beq.n	800b7b0 <_lv_obj_get_style_ptr+0xd0>
 800b792:	2301      	movs	r3, #1
 800b794:	76fb      	strb	r3, [r7, #27]
                    break;
 800b796:	e00b      	b.n	800b7b0 <_lv_obj_get_style_ptr+0xd0>
                case LV_STYLE_TEXT_FONT:
                    if(list->text_font_normal) def = true;
 800b798:	693b      	ldr	r3, [r7, #16]
 800b79a:	79db      	ldrb	r3, [r3, #7]
 800b79c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800b7a0:	b2db      	uxtb	r3, r3
 800b7a2:	2b00      	cmp	r3, #0
 800b7a4:	d006      	beq.n	800b7b4 <_lv_obj_get_style_ptr+0xd4>
 800b7a6:	2301      	movs	r3, #1
 800b7a8:	76fb      	strb	r3, [r7, #27]
                    break;
 800b7aa:	e003      	b.n	800b7b4 <_lv_obj_get_style_ptr+0xd4>
                    break;
 800b7ac:	bf00      	nop
 800b7ae:	e002      	b.n	800b7b6 <_lv_obj_get_style_ptr+0xd6>
                    break;
 800b7b0:	bf00      	nop
 800b7b2:	e000      	b.n	800b7b6 <_lv_obj_get_style_ptr+0xd6>
                    break;
 800b7b4:	bf00      	nop
            }

            if(def) {
 800b7b6:	7efb      	ldrb	r3, [r7, #27]
 800b7b8:	2b00      	cmp	r3, #0
 800b7ba:	d12e      	bne.n	800b81a <_lv_obj_get_style_ptr+0x13a>
                break;
            }
        }

        lv_state_t state = lv_obj_get_state(parent, part);
 800b7bc:	78fb      	ldrb	r3, [r7, #3]
 800b7be:	4619      	mov	r1, r3
 800b7c0:	69f8      	ldr	r0, [r7, #28]
 800b7c2:	f000 f8d3 	bl	800b96c <lv_obj_get_state>
 800b7c6:	4603      	mov	r3, r0
 800b7c8:	73fb      	strb	r3, [r7, #15]
        prop = (uint16_t)prop_ori + ((uint16_t)state << LV_STYLE_STATE_POS);
 800b7ca:	7bfb      	ldrb	r3, [r7, #15]
 800b7cc:	b29b      	uxth	r3, r3
 800b7ce:	021b      	lsls	r3, r3, #8
 800b7d0:	b29a      	uxth	r2, r3
 800b7d2:	8b3b      	ldrh	r3, [r7, #24]
 800b7d4:	4413      	add	r3, r2
 800b7d6:	803b      	strh	r3, [r7, #0]

        res = _lv_style_list_get_ptr(list, prop, &value_act);
 800b7d8:	f107 0208 	add.w	r2, r7, #8
 800b7dc:	883b      	ldrh	r3, [r7, #0]
 800b7de:	4619      	mov	r1, r3
 800b7e0:	6938      	ldr	r0, [r7, #16]
 800b7e2:	f004 fd60 	bl	80102a6 <_lv_style_list_get_ptr>
 800b7e6:	4603      	mov	r3, r0
 800b7e8:	75bb      	strb	r3, [r7, #22]
        if(res == LV_RES_OK)  return value_act;
 800b7ea:	7dbb      	ldrb	r3, [r7, #22]
 800b7ec:	2b01      	cmp	r3, #1
 800b7ee:	d101      	bne.n	800b7f4 <_lv_obj_get_style_ptr+0x114>
 800b7f0:	68bb      	ldr	r3, [r7, #8]
 800b7f2:	e02e      	b.n	800b852 <_lv_obj_get_style_ptr+0x172>

        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
 800b7f4:	f997 3017 	ldrsb.w	r3, [r7, #23]
 800b7f8:	2b00      	cmp	r3, #0
 800b7fa:	da10      	bge.n	800b81e <_lv_obj_get_style_ptr+0x13e>

        /*If not found, check the `MAIN` style first*/
        if(part != LV_OBJ_PART_MAIN) {
 800b7fc:	78fb      	ldrb	r3, [r7, #3]
 800b7fe:	2b00      	cmp	r3, #0
 800b800:	d002      	beq.n	800b808 <_lv_obj_get_style_ptr+0x128>
            part = LV_OBJ_PART_MAIN;
 800b802:	2300      	movs	r3, #0
 800b804:	70fb      	strb	r3, [r7, #3]
            continue;
 800b806:	e003      	b.n	800b810 <_lv_obj_get_style_ptr+0x130>
        }

        /*Check the parent too.*/
        parent = lv_obj_get_parent(parent);
 800b808:	69f8      	ldr	r0, [r7, #28]
 800b80a:	f7ff fa85 	bl	800ad18 <lv_obj_get_parent>
 800b80e:	61f8      	str	r0, [r7, #28]
    while(parent) {
 800b810:	69fb      	ldr	r3, [r7, #28]
 800b812:	2b00      	cmp	r3, #0
 800b814:	f47f af77 	bne.w	800b706 <_lv_obj_get_style_ptr+0x26>
 800b818:	e002      	b.n	800b820 <_lv_obj_get_style_ptr+0x140>
                break;
 800b81a:	bf00      	nop
 800b81c:	e000      	b.n	800b820 <_lv_obj_get_style_ptr+0x140>
        if(LV_STYLE_ATTR_GET_INHERIT(attr) == 0) break;
 800b81e:	bf00      	nop
    }

    /*Handle unset values*/
    prop = prop & (~LV_STYLE_STATE_MASK);
 800b820:	883b      	ldrh	r3, [r7, #0]
 800b822:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800b826:	803b      	strh	r3, [r7, #0]
    switch(prop) {
 800b828:	883b      	ldrh	r3, [r7, #0]
 800b82a:	f248 028e 	movw	r2, #32910	; 0x808e
 800b82e:	4293      	cmp	r3, r2
 800b830:	d008      	beq.n	800b844 <_lv_obj_get_style_ptr+0x164>
 800b832:	f248 028e 	movw	r2, #32910	; 0x808e
 800b836:	4293      	cmp	r3, r2
 800b838:	dc0a      	bgt.n	800b850 <_lv_obj_get_style_ptr+0x170>
 800b83a:	2b7e      	cmp	r3, #126	; 0x7e
 800b83c:	d002      	beq.n	800b844 <_lv_obj_get_style_ptr+0x164>
 800b83e:	2bbe      	cmp	r3, #190	; 0xbe
 800b840:	d004      	beq.n	800b84c <_lv_obj_get_style_ptr+0x16c>
 800b842:	e005      	b.n	800b850 <_lv_obj_get_style_ptr+0x170>
        case LV_STYLE_TEXT_FONT:
        case LV_STYLE_VALUE_FONT:
            return lv_theme_get_font_normal();
 800b844:	f017 f994 	bl	8022b70 <lv_theme_get_font_normal>
 800b848:	4603      	mov	r3, r0
 800b84a:	e002      	b.n	800b852 <_lv_obj_get_style_ptr+0x172>
#if LV_USE_ANIMATION
        case LV_STYLE_TRANSITION_PATH:
            return &lv_anim_path_def;
 800b84c:	4b03      	ldr	r3, [pc, #12]	; (800b85c <_lv_obj_get_style_ptr+0x17c>)
 800b84e:	e000      	b.n	800b852 <_lv_obj_get_style_ptr+0x172>
#endif
    }

    return NULL;
 800b850:	2300      	movs	r3, #0
}
 800b852:	4618      	mov	r0, r3
 800b854:	3720      	adds	r7, #32
 800b856:	46bd      	mov	sp, r7
 800b858:	bd80      	pop	{r7, pc}
 800b85a:	bf00      	nop
 800b85c:	080f2308 	.word	0x080f2308

0800b860 <lv_obj_get_hidden>:
 * Get the hidden attribute of an object
 * @param obj pointer to an object
 * @return true: the object is hidden
 */
bool lv_obj_get_hidden(const lv_obj_t * obj)
{
 800b860:	b5b0      	push	{r4, r5, r7, lr}
 800b862:	b082      	sub	sp, #8
 800b864:	af00      	add	r7, sp, #0
 800b866:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800b868:	6878      	ldr	r0, [r7, #4]
 800b86a:	f014 fc41 	bl	80200f0 <lv_debug_check_null>
 800b86e:	4603      	mov	r3, r0
 800b870:	f083 0301 	eor.w	r3, r3, #1
 800b874:	b2db      	uxtb	r3, r3
 800b876:	2b00      	cmp	r3, #0
 800b878:	d009      	beq.n	800b88e <lv_obj_get_hidden+0x2e>
 800b87a:	687b      	ldr	r3, [r7, #4]
 800b87c:	2200      	movs	r2, #0
 800b87e:	461c      	mov	r4, r3
 800b880:	4615      	mov	r5, r2
 800b882:	4622      	mov	r2, r4
 800b884:	462b      	mov	r3, r5
 800b886:	4809      	ldr	r0, [pc, #36]	; (800b8ac <lv_obj_get_hidden+0x4c>)
 800b888:	f014 fc42 	bl	8020110 <lv_debug_log_error>
 800b88c:	e7fe      	b.n	800b88c <lv_obj_get_hidden+0x2c>

    return obj->hidden == 0 ? false : true;
 800b88e:	687b      	ldr	r3, [r7, #4]
 800b890:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800b894:	f003 0310 	and.w	r3, r3, #16
 800b898:	b2db      	uxtb	r3, r3
 800b89a:	2b00      	cmp	r3, #0
 800b89c:	bf14      	ite	ne
 800b89e:	2301      	movne	r3, #1
 800b8a0:	2300      	moveq	r3, #0
 800b8a2:	b2db      	uxtb	r3, r3
}
 800b8a4:	4618      	mov	r0, r3
 800b8a6:	3708      	adds	r7, #8
 800b8a8:	46bd      	mov	sp, r7
 800b8aa:	bdb0      	pop	{r4, r5, r7, pc}
 800b8ac:	0802e42c 	.word	0x0802e42c

0800b8b0 <lv_obj_get_focus_parent>:
* Get the focus parent attribute of an object
* @param obj pointer to an object
* @return true: focus parent is enabled
*/
bool lv_obj_get_focus_parent(const lv_obj_t * obj)
{
 800b8b0:	b480      	push	{r7}
 800b8b2:	b083      	sub	sp, #12
 800b8b4:	af00      	add	r7, sp, #0
 800b8b6:	6078      	str	r0, [r7, #4]
    return obj->focus_parent == 0 ? false : true;
 800b8b8:	687b      	ldr	r3, [r7, #4]
 800b8ba:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 800b8be:	f003 0302 	and.w	r3, r3, #2
 800b8c2:	b2db      	uxtb	r3, r3
 800b8c4:	2b00      	cmp	r3, #0
 800b8c6:	bf14      	ite	ne
 800b8c8:	2301      	movne	r3, #1
 800b8ca:	2300      	moveq	r3, #0
 800b8cc:	b2db      	uxtb	r3, r3
}
 800b8ce:	4618      	mov	r0, r3
 800b8d0:	370c      	adds	r7, #12
 800b8d2:	46bd      	mov	sp, r7
 800b8d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b8d8:	4770      	bx	lr
	...

0800b8dc <lv_obj_get_base_dir>:
    return obj->parent_event == 0 ? false : true;
}


lv_bidi_dir_t lv_obj_get_base_dir(const lv_obj_t * obj)
{
 800b8dc:	b5b0      	push	{r4, r5, r7, lr}
 800b8de:	b082      	sub	sp, #8
 800b8e0:	af00      	add	r7, sp, #0
 800b8e2:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800b8e4:	6878      	ldr	r0, [r7, #4]
 800b8e6:	f014 fc03 	bl	80200f0 <lv_debug_check_null>
 800b8ea:	4603      	mov	r3, r0
 800b8ec:	f083 0301 	eor.w	r3, r3, #1
 800b8f0:	b2db      	uxtb	r3, r3
 800b8f2:	2b00      	cmp	r3, #0
 800b8f4:	d009      	beq.n	800b90a <lv_obj_get_base_dir+0x2e>
 800b8f6:	687b      	ldr	r3, [r7, #4]
 800b8f8:	2200      	movs	r2, #0
 800b8fa:	461c      	mov	r4, r3
 800b8fc:	4615      	mov	r5, r2
 800b8fe:	4622      	mov	r2, r4
 800b900:	462b      	mov	r3, r5
 800b902:	4804      	ldr	r0, [pc, #16]	; (800b914 <lv_obj_get_base_dir+0x38>)
 800b904:	f014 fc04 	bl	8020110 <lv_debug_log_error>
 800b908:	e7fe      	b.n	800b908 <lv_obj_get_base_dir+0x2c>
    }

    return LV_BIDI_BASE_DIR_DEF;
#else
    (void) obj;  /*Unused*/
    return LV_BIDI_DIR_LTR;
 800b90a:	2300      	movs	r3, #0
#endif
}
 800b90c:	4618      	mov	r0, r3
 800b90e:	3708      	adds	r7, #8
 800b910:	46bd      	mov	sp, r7
 800b912:	bdb0      	pop	{r4, r5, r7, pc}
 800b914:	0802e42c 	.word	0x0802e42c

0800b918 <lv_obj_is_protected>:
 * @param obj pointer to an object
 * @param prot protect bits to test ('OR'ed values of `lv_protect_t`)
 * @return false: none of the given bits are set, true: at least one bit is set
 */
bool lv_obj_is_protected(const lv_obj_t * obj, uint8_t prot)
{
 800b918:	b5b0      	push	{r4, r5, r7, lr}
 800b91a:	b082      	sub	sp, #8
 800b91c:	af00      	add	r7, sp, #0
 800b91e:	6078      	str	r0, [r7, #4]
 800b920:	460b      	mov	r3, r1
 800b922:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800b924:	6878      	ldr	r0, [r7, #4]
 800b926:	f014 fbe3 	bl	80200f0 <lv_debug_check_null>
 800b92a:	4603      	mov	r3, r0
 800b92c:	f083 0301 	eor.w	r3, r3, #1
 800b930:	b2db      	uxtb	r3, r3
 800b932:	2b00      	cmp	r3, #0
 800b934:	d009      	beq.n	800b94a <lv_obj_is_protected+0x32>
 800b936:	687b      	ldr	r3, [r7, #4]
 800b938:	2200      	movs	r2, #0
 800b93a:	461c      	mov	r4, r3
 800b93c:	4615      	mov	r5, r2
 800b93e:	4622      	mov	r2, r4
 800b940:	462b      	mov	r3, r5
 800b942:	4809      	ldr	r0, [pc, #36]	; (800b968 <lv_obj_is_protected+0x50>)
 800b944:	f014 fbe4 	bl	8020110 <lv_debug_log_error>
 800b948:	e7fe      	b.n	800b948 <lv_obj_is_protected+0x30>

    return (obj->protect & prot) == 0 ? false : true;
 800b94a:	687b      	ldr	r3, [r7, #4]
 800b94c:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 800b950:	78fb      	ldrb	r3, [r7, #3]
 800b952:	4013      	ands	r3, r2
 800b954:	b2db      	uxtb	r3, r3
 800b956:	2b00      	cmp	r3, #0
 800b958:	bf14      	ite	ne
 800b95a:	2301      	movne	r3, #1
 800b95c:	2300      	moveq	r3, #0
 800b95e:	b2db      	uxtb	r3, r3
}
 800b960:	4618      	mov	r0, r3
 800b962:	3708      	adds	r7, #8
 800b964:	46bd      	mov	sp, r7
 800b966:	bdb0      	pop	{r4, r5, r7, pc}
 800b968:	0802e42c 	.word	0x0802e42c

0800b96c <lv_obj_get_state>:

lv_state_t lv_obj_get_state(const lv_obj_t * obj, uint8_t part)
{
 800b96c:	b5b0      	push	{r4, r5, r7, lr}
 800b96e:	b084      	sub	sp, #16
 800b970:	af00      	add	r7, sp, #0
 800b972:	6078      	str	r0, [r7, #4]
 800b974:	460b      	mov	r3, r1
 800b976:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800b978:	6878      	ldr	r0, [r7, #4]
 800b97a:	f014 fbb9 	bl	80200f0 <lv_debug_check_null>
 800b97e:	4603      	mov	r3, r0
 800b980:	f083 0301 	eor.w	r3, r3, #1
 800b984:	b2db      	uxtb	r3, r3
 800b986:	2b00      	cmp	r3, #0
 800b988:	d009      	beq.n	800b99e <lv_obj_get_state+0x32>
 800b98a:	687b      	ldr	r3, [r7, #4]
 800b98c:	2200      	movs	r2, #0
 800b98e:	461c      	mov	r4, r3
 800b990:	4615      	mov	r5, r2
 800b992:	4622      	mov	r2, r4
 800b994:	462b      	mov	r3, r5
 800b996:	480d      	ldr	r0, [pc, #52]	; (800b9cc <lv_obj_get_state+0x60>)
 800b998:	f014 fbba 	bl	8020110 <lv_debug_log_error>
 800b99c:	e7fe      	b.n	800b99c <lv_obj_get_state+0x30>

    if(part < _LV_OBJ_PART_REAL_LAST) return ((lv_obj_t *)obj)->state;
 800b99e:	78fb      	ldrb	r3, [r7, #3]
 800b9a0:	2b3f      	cmp	r3, #63	; 0x3f
 800b9a2:	d803      	bhi.n	800b9ac <lv_obj_get_state+0x40>
 800b9a4:	687b      	ldr	r3, [r7, #4]
 800b9a6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800b9aa:	e00b      	b.n	800b9c4 <lv_obj_get_state+0x58>

    /*If a real part is asked, then use the object's signal to get its state.
     * A real object can be in different state then the main part
     * and only the object itself knows who to get it's state. */
    lv_get_state_info_t info;
    info.part = part;
 800b9ac:	78fb      	ldrb	r3, [r7, #3]
 800b9ae:	733b      	strb	r3, [r7, #12]
    info.result = LV_STATE_DEFAULT;
 800b9b0:	2300      	movs	r3, #0
 800b9b2:	737b      	strb	r3, [r7, #13]
    lv_signal_send((lv_obj_t *)obj, LV_SIGNAL_GET_STATE_DSC, &info);
 800b9b4:	f107 030c 	add.w	r3, r7, #12
 800b9b8:	461a      	mov	r2, r3
 800b9ba:	2109      	movs	r1, #9
 800b9bc:	6878      	ldr	r0, [r7, #4]
 800b9be:	f7ff f897 	bl	800aaf0 <lv_signal_send>

    return info.result;
 800b9c2:	7b7b      	ldrb	r3, [r7, #13]

}
 800b9c4:	4618      	mov	r0, r3
 800b9c6:	3710      	adds	r7, #16
 800b9c8:	46bd      	mov	sp, r7
 800b9ca:	bdb0      	pop	{r4, r5, r7, pc}
 800b9cc:	0802e42c 	.word	0x0802e42c

0800b9d0 <lv_obj_get_signal_cb>:
 * Get the signal function of an object
 * @param obj pointer to an object
 * @return the signal function
 */
lv_signal_cb_t lv_obj_get_signal_cb(const lv_obj_t * obj)
{
 800b9d0:	b5b0      	push	{r4, r5, r7, lr}
 800b9d2:	b082      	sub	sp, #8
 800b9d4:	af00      	add	r7, sp, #0
 800b9d6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800b9d8:	6878      	ldr	r0, [r7, #4]
 800b9da:	f014 fb89 	bl	80200f0 <lv_debug_check_null>
 800b9de:	4603      	mov	r3, r0
 800b9e0:	f083 0301 	eor.w	r3, r3, #1
 800b9e4:	b2db      	uxtb	r3, r3
 800b9e6:	2b00      	cmp	r3, #0
 800b9e8:	d009      	beq.n	800b9fe <lv_obj_get_signal_cb+0x2e>
 800b9ea:	687b      	ldr	r3, [r7, #4]
 800b9ec:	2200      	movs	r2, #0
 800b9ee:	461c      	mov	r4, r3
 800b9f0:	4615      	mov	r5, r2
 800b9f2:	4622      	mov	r2, r4
 800b9f4:	462b      	mov	r3, r5
 800b9f6:	4805      	ldr	r0, [pc, #20]	; (800ba0c <lv_obj_get_signal_cb+0x3c>)
 800b9f8:	f014 fb8a 	bl	8020110 <lv_debug_log_error>
 800b9fc:	e7fe      	b.n	800b9fc <lv_obj_get_signal_cb+0x2c>

    return obj->signal_cb;
 800b9fe:	687b      	ldr	r3, [r7, #4]
 800ba00:	69db      	ldr	r3, [r3, #28]
}
 800ba02:	4618      	mov	r0, r3
 800ba04:	3708      	adds	r7, #8
 800ba06:	46bd      	mov	sp, r7
 800ba08:	bdb0      	pop	{r4, r5, r7, pc}
 800ba0a:	bf00      	nop
 800ba0c:	0802e42c 	.word	0x0802e42c

0800ba10 <lv_obj_get_design_cb>:
 * Get the design function of an object
 * @param obj pointer to an object
 * @return the design function
 */
lv_design_cb_t lv_obj_get_design_cb(const lv_obj_t * obj)
{
 800ba10:	b5b0      	push	{r4, r5, r7, lr}
 800ba12:	b082      	sub	sp, #8
 800ba14:	af00      	add	r7, sp, #0
 800ba16:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800ba18:	6878      	ldr	r0, [r7, #4]
 800ba1a:	f014 fb69 	bl	80200f0 <lv_debug_check_null>
 800ba1e:	4603      	mov	r3, r0
 800ba20:	f083 0301 	eor.w	r3, r3, #1
 800ba24:	b2db      	uxtb	r3, r3
 800ba26:	2b00      	cmp	r3, #0
 800ba28:	d009      	beq.n	800ba3e <lv_obj_get_design_cb+0x2e>
 800ba2a:	687b      	ldr	r3, [r7, #4]
 800ba2c:	2200      	movs	r2, #0
 800ba2e:	461c      	mov	r4, r3
 800ba30:	4615      	mov	r5, r2
 800ba32:	4622      	mov	r2, r4
 800ba34:	462b      	mov	r3, r5
 800ba36:	4805      	ldr	r0, [pc, #20]	; (800ba4c <lv_obj_get_design_cb+0x3c>)
 800ba38:	f014 fb6a 	bl	8020110 <lv_debug_log_error>
 800ba3c:	e7fe      	b.n	800ba3c <lv_obj_get_design_cb+0x2c>

    return obj->design_cb;
 800ba3e:	687b      	ldr	r3, [r7, #4]
 800ba40:	6a1b      	ldr	r3, [r3, #32]
}
 800ba42:	4618      	mov	r0, r3
 800ba44:	3708      	adds	r7, #8
 800ba46:	46bd      	mov	sp, r7
 800ba48:	bdb0      	pop	{r4, r5, r7, pc}
 800ba4a:	bf00      	nop
 800ba4c:	0802e42c 	.word	0x0802e42c

0800ba50 <lv_obj_get_ext_attr>:
 * @param obj pointer to an object
 * @return the ext pointer but not the dynamic version
 *         Use it as ext->data1, and NOT da(ext)->data1
 */
void * lv_obj_get_ext_attr(const lv_obj_t * obj)
{
 800ba50:	b5b0      	push	{r4, r5, r7, lr}
 800ba52:	b082      	sub	sp, #8
 800ba54:	af00      	add	r7, sp, #0
 800ba56:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800ba58:	6878      	ldr	r0, [r7, #4]
 800ba5a:	f014 fb49 	bl	80200f0 <lv_debug_check_null>
 800ba5e:	4603      	mov	r3, r0
 800ba60:	f083 0301 	eor.w	r3, r3, #1
 800ba64:	b2db      	uxtb	r3, r3
 800ba66:	2b00      	cmp	r3, #0
 800ba68:	d009      	beq.n	800ba7e <lv_obj_get_ext_attr+0x2e>
 800ba6a:	687b      	ldr	r3, [r7, #4]
 800ba6c:	2200      	movs	r2, #0
 800ba6e:	461c      	mov	r4, r3
 800ba70:	4615      	mov	r5, r2
 800ba72:	4622      	mov	r2, r4
 800ba74:	462b      	mov	r3, r5
 800ba76:	4805      	ldr	r0, [pc, #20]	; (800ba8c <lv_obj_get_ext_attr+0x3c>)
 800ba78:	f014 fb4a 	bl	8020110 <lv_debug_log_error>
 800ba7c:	e7fe      	b.n	800ba7c <lv_obj_get_ext_attr+0x2c>

    return obj->ext_attr;
 800ba7e:	687b      	ldr	r3, [r7, #4]
 800ba80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 800ba82:	4618      	mov	r0, r3
 800ba84:	3708      	adds	r7, #8
 800ba86:	46bd      	mov	sp, r7
 800ba88:	bdb0      	pop	{r4, r5, r7, pc}
 800ba8a:	bf00      	nop
 800ba8c:	0802e42c 	.word	0x0802e42c

0800ba90 <lv_obj_get_group>:
 * Get the group of the object
 * @param obj pointer to an object
 * @return the pointer to group of the object
 */
void * lv_obj_get_group(const lv_obj_t * obj)
{
 800ba90:	b5b0      	push	{r4, r5, r7, lr}
 800ba92:	b082      	sub	sp, #8
 800ba94:	af00      	add	r7, sp, #0
 800ba96:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800ba98:	6878      	ldr	r0, [r7, #4]
 800ba9a:	f014 fb29 	bl	80200f0 <lv_debug_check_null>
 800ba9e:	4603      	mov	r3, r0
 800baa0:	f083 0301 	eor.w	r3, r3, #1
 800baa4:	b2db      	uxtb	r3, r3
 800baa6:	2b00      	cmp	r3, #0
 800baa8:	d009      	beq.n	800babe <lv_obj_get_group+0x2e>
 800baaa:	687b      	ldr	r3, [r7, #4]
 800baac:	2200      	movs	r2, #0
 800baae:	461c      	mov	r4, r3
 800bab0:	4615      	mov	r5, r2
 800bab2:	4622      	mov	r2, r4
 800bab4:	462b      	mov	r3, r5
 800bab6:	4805      	ldr	r0, [pc, #20]	; (800bacc <lv_obj_get_group+0x3c>)
 800bab8:	f014 fb2a 	bl	8020110 <lv_debug_log_error>
 800babc:	e7fe      	b.n	800babc <lv_obj_get_group+0x2c>

#if LV_USE_GROUP
    return obj->group_p;
 800babe:	687b      	ldr	r3, [r7, #4]
 800bac0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
#else
    LV_UNUSED(obj);
    return NULL;
#endif
}
 800bac2:	4618      	mov	r0, r3
 800bac4:	3708      	adds	r7, #8
 800bac6:	46bd      	mov	sp, r7
 800bac8:	bdb0      	pop	{r4, r5, r7, pc}
 800baca:	bf00      	nop
 800bacc:	0802e42c 	.word	0x0802e42c

0800bad0 <lv_obj_is_focused>:
 * Tell whether the object is the focused object of a group or not.
 * @param obj pointer to an object
 * @return true: the object is focused, false: the object is not focused or not in a group
 */
bool lv_obj_is_focused(const lv_obj_t * obj)
{
 800bad0:	b5b0      	push	{r4, r5, r7, lr}
 800bad2:	b082      	sub	sp, #8
 800bad4:	af00      	add	r7, sp, #0
 800bad6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(obj, LV_OBJX_NAME);
 800bad8:	6878      	ldr	r0, [r7, #4]
 800bada:	f014 fb09 	bl	80200f0 <lv_debug_check_null>
 800bade:	4603      	mov	r3, r0
 800bae0:	f083 0301 	eor.w	r3, r3, #1
 800bae4:	b2db      	uxtb	r3, r3
 800bae6:	2b00      	cmp	r3, #0
 800bae8:	d009      	beq.n	800bafe <lv_obj_is_focused+0x2e>
 800baea:	687b      	ldr	r3, [r7, #4]
 800baec:	2200      	movs	r2, #0
 800baee:	461c      	mov	r4, r3
 800baf0:	4615      	mov	r5, r2
 800baf2:	4622      	mov	r2, r4
 800baf4:	462b      	mov	r3, r5
 800baf6:	480c      	ldr	r0, [pc, #48]	; (800bb28 <lv_obj_is_focused+0x58>)
 800baf8:	f014 fb0a 	bl	8020110 <lv_debug_log_error>
 800bafc:	e7fe      	b.n	800bafc <lv_obj_is_focused+0x2c>

#if LV_USE_GROUP
    if(obj->group_p) {
 800bafe:	687b      	ldr	r3, [r7, #4]
 800bb00:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800bb02:	2b00      	cmp	r3, #0
 800bb04:	d00a      	beq.n	800bb1c <lv_obj_is_focused+0x4c>
        if(lv_group_get_focused(obj->group_p) == obj) return true;
 800bb06:	687b      	ldr	r3, [r7, #4]
 800bb08:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800bb0a:	4618      	mov	r0, r3
 800bb0c:	f7fc fb1a 	bl	8008144 <lv_group_get_focused>
 800bb10:	4602      	mov	r2, r0
 800bb12:	687b      	ldr	r3, [r7, #4]
 800bb14:	4293      	cmp	r3, r2
 800bb16:	d101      	bne.n	800bb1c <lv_obj_is_focused+0x4c>
 800bb18:	2301      	movs	r3, #1
 800bb1a:	e000      	b.n	800bb1e <lv_obj_is_focused+0x4e>
    }
    return false;
 800bb1c:	2300      	movs	r3, #0
#else
    LV_UNUSED(obj);
    return false;
#endif
}
 800bb1e:	4618      	mov	r0, r3
 800bb20:	3708      	adds	r7, #8
 800bb22:	46bd      	mov	sp, r7
 800bb24:	bdb0      	pop	{r4, r5, r7, pc}
 800bb26:	bf00      	nop
 800bb28:	0802e42c 	.word	0x0802e42c

0800bb2c <lv_obj_is_point_on_coords>:
 * whether the point is even within the object (as an optimization).
 * @param obj object to check
 * @param point screen-space point
 */
bool lv_obj_is_point_on_coords(lv_obj_t * obj, const lv_point_t * point)
{
 800bb2c:	b580      	push	{r7, lr}
 800bb2e:	b084      	sub	sp, #16
 800bb30:	af00      	add	r7, sp, #0
 800bb32:	6078      	str	r0, [r7, #4]
 800bb34:	6039      	str	r1, [r7, #0]
#if LV_USE_EXT_CLICK_AREA == LV_EXT_CLICK_AREA_TINY
    lv_area_t ext_area;
    ext_area.x1 = obj->coords.x1 - obj->ext_click_pad_hor;
 800bb36:	687b      	ldr	r3, [r7, #4]
 800bb38:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 800bb3c:	b29a      	uxth	r2, r3
 800bb3e:	687b      	ldr	r3, [r7, #4]
 800bb40:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800bb44:	b29b      	uxth	r3, r3
 800bb46:	1ad3      	subs	r3, r2, r3
 800bb48:	b29b      	uxth	r3, r3
 800bb4a:	b21b      	sxth	r3, r3
 800bb4c:	813b      	strh	r3, [r7, #8]
    ext_area.x2 = obj->coords.x2 + obj->ext_click_pad_hor;
 800bb4e:	687b      	ldr	r3, [r7, #4]
 800bb50:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 800bb54:	b29a      	uxth	r2, r3
 800bb56:	687b      	ldr	r3, [r7, #4]
 800bb58:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800bb5c:	b29b      	uxth	r3, r3
 800bb5e:	4413      	add	r3, r2
 800bb60:	b29b      	uxth	r3, r3
 800bb62:	b21b      	sxth	r3, r3
 800bb64:	81bb      	strh	r3, [r7, #12]
    ext_area.y1 = obj->coords.y1 - obj->ext_click_pad_ver;
 800bb66:	687b      	ldr	r3, [r7, #4]
 800bb68:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 800bb6c:	b29a      	uxth	r2, r3
 800bb6e:	687b      	ldr	r3, [r7, #4]
 800bb70:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 800bb74:	b29b      	uxth	r3, r3
 800bb76:	1ad3      	subs	r3, r2, r3
 800bb78:	b29b      	uxth	r3, r3
 800bb7a:	b21b      	sxth	r3, r3
 800bb7c:	817b      	strh	r3, [r7, #10]
    ext_area.y2 = obj->coords.y2 + obj->ext_click_pad_ver;
 800bb7e:	687b      	ldr	r3, [r7, #4]
 800bb80:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800bb84:	b29a      	uxth	r2, r3
 800bb86:	687b      	ldr	r3, [r7, #4]
 800bb88:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 800bb8c:	b29b      	uxth	r3, r3
 800bb8e:	4413      	add	r3, r2
 800bb90:	b29b      	uxth	r3, r3
 800bb92:	b21b      	sxth	r3, r3
 800bb94:	81fb      	strh	r3, [r7, #14]

    if(!_lv_area_is_point_on(&ext_area, point, 0)) {
 800bb96:	f107 0308 	add.w	r3, r7, #8
 800bb9a:	2200      	movs	r2, #0
 800bb9c:	6839      	ldr	r1, [r7, #0]
 800bb9e:	4618      	mov	r0, r3
 800bba0:	f013 fcf1 	bl	801f586 <_lv_area_is_point_on>
 800bba4:	4603      	mov	r3, r0
 800bba6:	f083 0301 	eor.w	r3, r3, #1
 800bbaa:	b2db      	uxtb	r3, r3
 800bbac:	2b00      	cmp	r3, #0
 800bbae:	d001      	beq.n	800bbb4 <lv_obj_is_point_on_coords+0x88>

    if(!_lv_area_is_point_on(&ext_area, point, 0)) {
#else
    if(!_lv_area_is_point_on(&obj->coords, point, 0)) {
#endif
        return false;
 800bbb0:	2300      	movs	r3, #0
 800bbb2:	e000      	b.n	800bbb6 <lv_obj_is_point_on_coords+0x8a>
    }
    return true;
 800bbb4:	2301      	movs	r3, #1
}
 800bbb6:	4618      	mov	r0, r3
 800bbb8:	3710      	adds	r7, #16
 800bbba:	46bd      	mov	sp, r7
 800bbbc:	bd80      	pop	{r7, pc}

0800bbbe <lv_obj_handle_get_type_signal>:
 * @param buf pointer to `lv_obj_type_t`. (`param` in the signal callback)
 * @param name name of the object. E.g. "lv_btn". (Only the pointer is saved)
 * @return LV_RES_OK
 */
lv_res_t lv_obj_handle_get_type_signal(lv_obj_type_t * buf, const char * name)
{
 800bbbe:	b480      	push	{r7}
 800bbc0:	b085      	sub	sp, #20
 800bbc2:	af00      	add	r7, sp, #0
 800bbc4:	6078      	str	r0, [r7, #4]
 800bbc6:	6039      	str	r1, [r7, #0]
    uint8_t i;
    for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 800bbc8:	2300      	movs	r3, #0
 800bbca:	73fb      	strb	r3, [r7, #15]
 800bbcc:	e008      	b.n	800bbe0 <lv_obj_handle_get_type_signal+0x22>
        if(buf->type[i] == NULL) break;
 800bbce:	7bfa      	ldrb	r2, [r7, #15]
 800bbd0:	687b      	ldr	r3, [r7, #4]
 800bbd2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bbd6:	2b00      	cmp	r3, #0
 800bbd8:	d006      	beq.n	800bbe8 <lv_obj_handle_get_type_signal+0x2a>
    for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 800bbda:	7bfb      	ldrb	r3, [r7, #15]
 800bbdc:	3301      	adds	r3, #1
 800bbde:	73fb      	strb	r3, [r7, #15]
 800bbe0:	7bfb      	ldrb	r3, [r7, #15]
 800bbe2:	2b06      	cmp	r3, #6
 800bbe4:	d9f3      	bls.n	800bbce <lv_obj_handle_get_type_signal+0x10>
 800bbe6:	e000      	b.n	800bbea <lv_obj_handle_get_type_signal+0x2c>
        if(buf->type[i] == NULL) break;
 800bbe8:	bf00      	nop
    }
    buf->type[i] = name;
 800bbea:	7bfa      	ldrb	r2, [r7, #15]
 800bbec:	687b      	ldr	r3, [r7, #4]
 800bbee:	6839      	ldr	r1, [r7, #0]
 800bbf0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

    return LV_RES_OK;
 800bbf4:	2301      	movs	r3, #1
}
 800bbf6:	4618      	mov	r0, r3
 800bbf8:	3714      	adds	r7, #20
 800bbfa:	46bd      	mov	sp, r7
 800bbfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc00:	4770      	bx	lr

0800bc02 <lv_obj_init_draw_rect_dsc>:
 * @param draw_dsc the descriptor the initialize
 * @note Only the relevant fields will be set.
 * E.g. if `border width == 0` the other border properties won't be evaluated.
 */
void lv_obj_init_draw_rect_dsc(lv_obj_t * obj, uint8_t part, lv_draw_rect_dsc_t * draw_dsc)
{
 800bc02:	b590      	push	{r4, r7, lr}
 800bc04:	b087      	sub	sp, #28
 800bc06:	af00      	add	r7, sp, #0
 800bc08:	60f8      	str	r0, [r7, #12]
 800bc0a:	460b      	mov	r3, r1
 800bc0c:	607a      	str	r2, [r7, #4]
 800bc0e:	72fb      	strb	r3, [r7, #11]
    draw_dsc->radius = lv_obj_get_style_radius(obj, part);
 800bc10:	7afb      	ldrb	r3, [r7, #11]
 800bc12:	4619      	mov	r1, r3
 800bc14:	68f8      	ldr	r0, [r7, #12]
 800bc16:	f7fc fe16 	bl	8008846 <lv_obj_get_style_radius>
 800bc1a:	4603      	mov	r3, r0
 800bc1c:	461a      	mov	r2, r3
 800bc1e:	687b      	ldr	r3, [r7, #4]
 800bc20:	801a      	strh	r2, [r3, #0]

#if LV_USE_OPA_SCALE
    lv_opa_t opa_scale = lv_obj_get_style_opa_scale(obj, part);
 800bc22:	7afb      	ldrb	r3, [r7, #11]
 800bc24:	4619      	mov	r1, r3
 800bc26:	68f8      	ldr	r0, [r7, #12]
 800bc28:	f7fc fe78 	bl	800891c <lv_obj_get_style_opa_scale>
 800bc2c:	4603      	mov	r3, r0
 800bc2e:	75fb      	strb	r3, [r7, #23]
    if(opa_scale <= LV_OPA_MIN) {
 800bc30:	7dfb      	ldrb	r3, [r7, #23]
 800bc32:	2b02      	cmp	r3, #2
 800bc34:	d812      	bhi.n	800bc5c <lv_obj_init_draw_rect_dsc+0x5a>
        draw_dsc->bg_opa = LV_OPA_TRANSP;
 800bc36:	687b      	ldr	r3, [r7, #4]
 800bc38:	2200      	movs	r2, #0
 800bc3a:	731a      	strb	r2, [r3, #12]
        draw_dsc->border_opa = LV_OPA_TRANSP;
 800bc3c:	687b      	ldr	r3, [r7, #4]
 800bc3e:	2200      	movs	r2, #0
 800bc40:	751a      	strb	r2, [r3, #20]
        draw_dsc->shadow_opa = LV_OPA_TRANSP;
 800bc42:	687b      	ldr	r3, [r7, #4]
 800bc44:	2200      	movs	r2, #0
 800bc46:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
        draw_dsc->pattern_opa = LV_OPA_TRANSP;
 800bc4a:	687b      	ldr	r3, [r7, #4]
 800bc4c:	2200      	movs	r2, #0
 800bc4e:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
        draw_dsc->value_opa = LV_OPA_TRANSP;
 800bc52:	687b      	ldr	r3, [r7, #4]
 800bc54:	2200      	movs	r2, #0
 800bc56:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
        return;
 800bc5a:	e220      	b.n	800c09e <lv_obj_init_draw_rect_dsc+0x49c>
    }
#endif

    if(draw_dsc->bg_opa != LV_OPA_TRANSP) {
 800bc5c:	687b      	ldr	r3, [r7, #4]
 800bc5e:	7b1b      	ldrb	r3, [r3, #12]
 800bc60:	2b00      	cmp	r3, #0
 800bc62:	d042      	beq.n	800bcea <lv_obj_init_draw_rect_dsc+0xe8>
        draw_dsc->bg_opa = lv_obj_get_style_bg_opa(obj, part);
 800bc64:	7afb      	ldrb	r3, [r7, #11]
 800bc66:	4619      	mov	r1, r3
 800bc68:	68f8      	ldr	r0, [r7, #12]
 800bc6a:	f7fc ff15 	bl	8008a98 <lv_obj_get_style_bg_opa>
 800bc6e:	4603      	mov	r3, r0
 800bc70:	461a      	mov	r2, r3
 800bc72:	687b      	ldr	r3, [r7, #4]
 800bc74:	731a      	strb	r2, [r3, #12]
        if(draw_dsc->bg_opa > LV_OPA_MIN) {
 800bc76:	687b      	ldr	r3, [r7, #4]
 800bc78:	7b1b      	ldrb	r3, [r3, #12]
 800bc7a:	2b02      	cmp	r3, #2
 800bc7c:	d935      	bls.n	800bcea <lv_obj_init_draw_rect_dsc+0xe8>
            draw_dsc->bg_color = lv_obj_get_style_bg_color(obj, part);
 800bc7e:	687c      	ldr	r4, [r7, #4]
 800bc80:	7afb      	ldrb	r3, [r7, #11]
 800bc82:	4619      	mov	r1, r3
 800bc84:	68f8      	ldr	r0, [r7, #12]
 800bc86:	f7fc fee5 	bl	8008a54 <lv_obj_get_style_bg_color>
 800bc8a:	8060      	strh	r0, [r4, #2]
            draw_dsc->bg_grad_dir =  lv_obj_get_style_bg_grad_dir(obj, part);
 800bc8c:	7afb      	ldrb	r3, [r7, #11]
 800bc8e:	4619      	mov	r1, r3
 800bc90:	68f8      	ldr	r0, [r7, #12]
 800bc92:	f7fc fecd 	bl	8008a30 <lv_obj_get_style_bg_grad_dir>
 800bc96:	4603      	mov	r3, r0
 800bc98:	461a      	mov	r2, r3
 800bc9a:	687b      	ldr	r3, [r7, #4]
 800bc9c:	719a      	strb	r2, [r3, #6]
            if(draw_dsc->bg_grad_dir != LV_GRAD_DIR_NONE) {
 800bc9e:	687b      	ldr	r3, [r7, #4]
 800bca0:	799b      	ldrb	r3, [r3, #6]
 800bca2:	2b00      	cmp	r3, #0
 800bca4:	d018      	beq.n	800bcd8 <lv_obj_init_draw_rect_dsc+0xd6>
                draw_dsc->bg_grad_color = lv_obj_get_style_bg_grad_color(obj, part);
 800bca6:	687c      	ldr	r4, [r7, #4]
 800bca8:	7afb      	ldrb	r3, [r7, #11]
 800bcaa:	4619      	mov	r1, r3
 800bcac:	68f8      	ldr	r0, [r7, #12]
 800bcae:	f7fc fee2 	bl	8008a76 <lv_obj_get_style_bg_grad_color>
 800bcb2:	80a0      	strh	r0, [r4, #4]
                draw_dsc->bg_main_color_stop =  lv_obj_get_style_bg_main_stop(obj, part);
 800bcb4:	7afb      	ldrb	r3, [r7, #11]
 800bcb6:	4619      	mov	r1, r3
 800bcb8:	68f8      	ldr	r0, [r7, #12]
 800bcba:	f7fc fe97 	bl	80089ec <lv_obj_get_style_bg_main_stop>
 800bcbe:	4603      	mov	r3, r0
 800bcc0:	461a      	mov	r2, r3
 800bcc2:	687b      	ldr	r3, [r7, #4]
 800bcc4:	811a      	strh	r2, [r3, #8]
                draw_dsc->bg_grad_color_stop =  lv_obj_get_style_bg_grad_stop(obj, part);
 800bcc6:	7afb      	ldrb	r3, [r7, #11]
 800bcc8:	4619      	mov	r1, r3
 800bcca:	68f8      	ldr	r0, [r7, #12]
 800bccc:	f7fc fe9f 	bl	8008a0e <lv_obj_get_style_bg_grad_stop>
 800bcd0:	4603      	mov	r3, r0
 800bcd2:	461a      	mov	r2, r3
 800bcd4:	687b      	ldr	r3, [r7, #4]
 800bcd6:	815a      	strh	r2, [r3, #10]
            }

#if LV_USE_BLEND_MODES
            draw_dsc->bg_blend_mode = lv_obj_get_style_bg_blend_mode(obj, part);
 800bcd8:	7afb      	ldrb	r3, [r7, #11]
 800bcda:	4619      	mov	r1, r3
 800bcdc:	68f8      	ldr	r0, [r7, #12]
 800bcde:	f7fc fe73 	bl	80089c8 <lv_obj_get_style_bg_blend_mode>
 800bce2:	4603      	mov	r3, r0
 800bce4:	461a      	mov	r2, r3
 800bce6:	687b      	ldr	r3, [r7, #4]
 800bce8:	735a      	strb	r2, [r3, #13]
#endif
        }
    }

    draw_dsc->border_width = lv_obj_get_style_border_width(obj, part);
 800bcea:	7afb      	ldrb	r3, [r7, #11]
 800bcec:	4619      	mov	r1, r3
 800bcee:	68f8      	ldr	r0, [r7, #12]
 800bcf0:	f7fc fee3 	bl	8008aba <lv_obj_get_style_border_width>
 800bcf4:	4603      	mov	r3, r0
 800bcf6:	461a      	mov	r2, r3
 800bcf8:	687b      	ldr	r3, [r7, #4]
 800bcfa:	821a      	strh	r2, [r3, #16]
    if(draw_dsc->border_width) {
 800bcfc:	687b      	ldr	r3, [r7, #4]
 800bcfe:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 800bd02:	2b00      	cmp	r3, #0
 800bd04:	d029      	beq.n	800bd5a <lv_obj_init_draw_rect_dsc+0x158>
        if(draw_dsc->border_opa != LV_OPA_TRANSP) {
 800bd06:	687b      	ldr	r3, [r7, #4]
 800bd08:	7d1b      	ldrb	r3, [r3, #20]
 800bd0a:	2b00      	cmp	r3, #0
 800bd0c:	d025      	beq.n	800bd5a <lv_obj_init_draw_rect_dsc+0x158>
            draw_dsc->border_opa = lv_obj_get_style_border_opa(obj, part);
 800bd0e:	7afb      	ldrb	r3, [r7, #11]
 800bd10:	4619      	mov	r1, r3
 800bd12:	68f8      	ldr	r0, [r7, #12]
 800bd14:	f7fc ff2d 	bl	8008b72 <lv_obj_get_style_border_opa>
 800bd18:	4603      	mov	r3, r0
 800bd1a:	461a      	mov	r2, r3
 800bd1c:	687b      	ldr	r3, [r7, #4]
 800bd1e:	751a      	strb	r2, [r3, #20]
            if(draw_dsc->border_opa > LV_OPA_MIN) {
 800bd20:	687b      	ldr	r3, [r7, #4]
 800bd22:	7d1b      	ldrb	r3, [r3, #20]
 800bd24:	2b02      	cmp	r3, #2
 800bd26:	d90f      	bls.n	800bd48 <lv_obj_init_draw_rect_dsc+0x146>
                draw_dsc->border_side = lv_obj_get_style_border_side(obj, part);
 800bd28:	7afb      	ldrb	r3, [r7, #11]
 800bd2a:	4619      	mov	r1, r3
 800bd2c:	68f8      	ldr	r0, [r7, #12]
 800bd2e:	f7fc fed5 	bl	8008adc <lv_obj_get_style_border_side>
 800bd32:	4603      	mov	r3, r0
 800bd34:	b21a      	sxth	r2, r3
 800bd36:	687b      	ldr	r3, [r7, #4]
 800bd38:	825a      	strh	r2, [r3, #18]
                draw_dsc->border_color = lv_obj_get_style_border_color(obj, part);
 800bd3a:	687c      	ldr	r4, [r7, #4]
 800bd3c:	7afb      	ldrb	r3, [r7, #11]
 800bd3e:	4619      	mov	r1, r3
 800bd40:	68f8      	ldr	r0, [r7, #12]
 800bd42:	f7fc ff05 	bl	8008b50 <lv_obj_get_style_border_color>
 800bd46:	81e0      	strh	r0, [r4, #14]
            }
#if LV_USE_BLEND_MODES
            draw_dsc->border_blend_mode = lv_obj_get_style_border_blend_mode(obj, part);
 800bd48:	7afb      	ldrb	r3, [r7, #11]
 800bd4a:	4619      	mov	r1, r3
 800bd4c:	68f8      	ldr	r0, [r7, #12]
 800bd4e:	f7fc fed7 	bl	8008b00 <lv_obj_get_style_border_blend_mode>
 800bd52:	4603      	mov	r3, r0
 800bd54:	461a      	mov	r2, r3
 800bd56:	687b      	ldr	r3, [r7, #4]
 800bd58:	755a      	strb	r2, [r3, #21]
#endif
        }
    }

#if LV_USE_OUTLINE
    draw_dsc->outline_width = lv_obj_get_style_outline_width(obj, part);
 800bd5a:	7afb      	ldrb	r3, [r7, #11]
 800bd5c:	4619      	mov	r1, r3
 800bd5e:	68f8      	ldr	r0, [r7, #12]
 800bd60:	f7fc ff18 	bl	8008b94 <lv_obj_get_style_outline_width>
 800bd64:	4603      	mov	r3, r0
 800bd66:	461a      	mov	r2, r3
 800bd68:	687b      	ldr	r3, [r7, #4]
 800bd6a:	835a      	strh	r2, [r3, #26]
    if(draw_dsc->outline_width) {
 800bd6c:	687b      	ldr	r3, [r7, #4]
 800bd6e:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 800bd72:	2b00      	cmp	r3, #0
 800bd74:	d029      	beq.n	800bdca <lv_obj_init_draw_rect_dsc+0x1c8>
        if(draw_dsc->outline_opa != LV_OPA_TRANSP) {
 800bd76:	687b      	ldr	r3, [r7, #4]
 800bd78:	7f9b      	ldrb	r3, [r3, #30]
 800bd7a:	2b00      	cmp	r3, #0
 800bd7c:	d025      	beq.n	800bdca <lv_obj_init_draw_rect_dsc+0x1c8>
            draw_dsc->outline_opa = lv_obj_get_style_outline_opa(obj, part);
 800bd7e:	7afb      	ldrb	r3, [r7, #11]
 800bd80:	4619      	mov	r1, r3
 800bd82:	68f8      	ldr	r0, [r7, #12]
 800bd84:	f7fc ff4b 	bl	8008c1e <lv_obj_get_style_outline_opa>
 800bd88:	4603      	mov	r3, r0
 800bd8a:	461a      	mov	r2, r3
 800bd8c:	687b      	ldr	r3, [r7, #4]
 800bd8e:	779a      	strb	r2, [r3, #30]
            if(draw_dsc->outline_opa > LV_OPA_MIN) {
 800bd90:	687b      	ldr	r3, [r7, #4]
 800bd92:	7f9b      	ldrb	r3, [r3, #30]
 800bd94:	2b02      	cmp	r3, #2
 800bd96:	d90f      	bls.n	800bdb8 <lv_obj_init_draw_rect_dsc+0x1b6>
                draw_dsc->outline_pad = lv_obj_get_style_outline_pad(obj, part);
 800bd98:	7afb      	ldrb	r3, [r7, #11]
 800bd9a:	4619      	mov	r1, r3
 800bd9c:	68f8      	ldr	r0, [r7, #12]
 800bd9e:	f7fc ff0a 	bl	8008bb6 <lv_obj_get_style_outline_pad>
 800bda2:	4603      	mov	r3, r0
 800bda4:	461a      	mov	r2, r3
 800bda6:	687b      	ldr	r3, [r7, #4]
 800bda8:	839a      	strh	r2, [r3, #28]
                draw_dsc->outline_color = lv_obj_get_style_outline_color(obj, part);
 800bdaa:	687c      	ldr	r4, [r7, #4]
 800bdac:	7afb      	ldrb	r3, [r7, #11]
 800bdae:	4619      	mov	r1, r3
 800bdb0:	68f8      	ldr	r0, [r7, #12]
 800bdb2:	f7fc ff23 	bl	8008bfc <lv_obj_get_style_outline_color>
 800bdb6:	8320      	strh	r0, [r4, #24]
            }
#if LV_USE_BLEND_MODES
            draw_dsc->outline_blend_mode = lv_obj_get_style_outline_blend_mode(obj, part);
 800bdb8:	7afb      	ldrb	r3, [r7, #11]
 800bdba:	4619      	mov	r1, r3
 800bdbc:	68f8      	ldr	r0, [r7, #12]
 800bdbe:	f7fc ff0b 	bl	8008bd8 <lv_obj_get_style_outline_blend_mode>
 800bdc2:	4603      	mov	r3, r0
 800bdc4:	461a      	mov	r2, r3
 800bdc6:	687b      	ldr	r3, [r7, #4]
 800bdc8:	77da      	strb	r2, [r3, #31]
        }
    }
#endif

#if LV_USE_PATTERN
    draw_dsc->pattern_image = lv_obj_get_style_pattern_image(obj, part);
 800bdca:	7afb      	ldrb	r3, [r7, #11]
 800bdcc:	4619      	mov	r1, r3
 800bdce:	68f8      	ldr	r0, [r7, #12]
 800bdd0:	f7fd f809 	bl	8008de6 <lv_obj_get_style_pattern_image>
 800bdd4:	4602      	mov	r2, r0
 800bdd6:	687b      	ldr	r3, [r7, #4]
 800bdd8:	62da      	str	r2, [r3, #44]	; 0x2c
    if(draw_dsc->pattern_image) {
 800bdda:	687b      	ldr	r3, [r7, #4]
 800bddc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bdde:	2b00      	cmp	r3, #0
 800bde0:	d059      	beq.n	800be96 <lv_obj_init_draw_rect_dsc+0x294>
        if(draw_dsc->pattern_opa != LV_OPA_TRANSP) {
 800bde2:	687b      	ldr	r3, [r7, #4]
 800bde4:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 800bde8:	2b00      	cmp	r3, #0
 800bdea:	d054      	beq.n	800be96 <lv_obj_init_draw_rect_dsc+0x294>
            draw_dsc->pattern_opa = lv_obj_get_style_pattern_opa(obj, part);
 800bdec:	7afb      	ldrb	r3, [r7, #11]
 800bdee:	4619      	mov	r1, r3
 800bdf0:	68f8      	ldr	r0, [r7, #12]
 800bdf2:	f7fc ffd6 	bl	8008da2 <lv_obj_get_style_pattern_opa>
 800bdf6:	4603      	mov	r3, r0
 800bdf8:	461a      	mov	r2, r3
 800bdfa:	687b      	ldr	r3, [r7, #4]
 800bdfc:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
            if(draw_dsc->pattern_opa > LV_OPA_MIN) {
 800be00:	687b      	ldr	r3, [r7, #4]
 800be02:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 800be06:	2b02      	cmp	r3, #2
 800be08:	d945      	bls.n	800be96 <lv_obj_init_draw_rect_dsc+0x294>
                draw_dsc->pattern_recolor_opa = lv_obj_get_style_pattern_recolor_opa(obj, part);
 800be0a:	7afb      	ldrb	r3, [r7, #11]
 800be0c:	4619      	mov	r1, r3
 800be0e:	68f8      	ldr	r0, [r7, #12]
 800be10:	f7fc ffd8 	bl	8008dc4 <lv_obj_get_style_pattern_recolor_opa>
 800be14:	4603      	mov	r3, r0
 800be16:	461a      	mov	r2, r3
 800be18:	687b      	ldr	r3, [r7, #4]
 800be1a:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
                draw_dsc->pattern_repeat = lv_obj_get_style_pattern_repeat(obj, part);
 800be1e:	7afb      	ldrb	r3, [r7, #11]
 800be20:	4619      	mov	r1, r3
 800be22:	68f8      	ldr	r0, [r7, #12]
 800be24:	f7fc ff84 	bl	8008d30 <lv_obj_get_style_pattern_repeat>
 800be28:	4603      	mov	r3, r0
 800be2a:	4619      	mov	r1, r3
 800be2c:	687a      	ldr	r2, [r7, #4]
 800be2e:	f892 3038 	ldrb.w	r3, [r2, #56]	; 0x38
 800be32:	f361 0300 	bfi	r3, r1, #0, #1
 800be36:	f882 3038 	strb.w	r3, [r2, #56]	; 0x38
                if(lv_img_src_get_type(draw_dsc->pattern_image) == LV_IMG_SRC_SYMBOL) {
 800be3a:	687b      	ldr	r3, [r7, #4]
 800be3c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800be3e:	4618      	mov	r0, r3
 800be40:	f006 fbc9 	bl	80125d6 <lv_img_src_get_type>
 800be44:	4603      	mov	r3, r0
 800be46:	2b02      	cmp	r3, #2
 800be48:	d10f      	bne.n	800be6a <lv_obj_init_draw_rect_dsc+0x268>
                    draw_dsc->pattern_recolor = lv_obj_get_style_pattern_recolor(obj, part);
 800be4a:	687c      	ldr	r4, [r7, #4]
 800be4c:	7afb      	ldrb	r3, [r7, #11]
 800be4e:	4619      	mov	r1, r3
 800be50:	68f8      	ldr	r0, [r7, #12]
 800be52:	f7fc ff95 	bl	8008d80 <lv_obj_get_style_pattern_recolor>
 800be56:	86a0      	strh	r0, [r4, #52]	; 0x34
                    draw_dsc->pattern_font = lv_obj_get_style_text_font(obj, part);
 800be58:	7afb      	ldrb	r3, [r7, #11]
 800be5a:	4619      	mov	r1, r3
 800be5c:	68f8      	ldr	r0, [r7, #12]
 800be5e:	f7fd f8ff 	bl	8009060 <lv_obj_get_style_text_font>
 800be62:	4602      	mov	r2, r0
 800be64:	687b      	ldr	r3, [r7, #4]
 800be66:	631a      	str	r2, [r3, #48]	; 0x30
 800be68:	e00b      	b.n	800be82 <lv_obj_init_draw_rect_dsc+0x280>
                }
                else if(draw_dsc->pattern_recolor_opa > LV_OPA_MIN) {
 800be6a:	687b      	ldr	r3, [r7, #4]
 800be6c:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 800be70:	2b02      	cmp	r3, #2
 800be72:	d906      	bls.n	800be82 <lv_obj_init_draw_rect_dsc+0x280>
                    draw_dsc->pattern_recolor = lv_obj_get_style_pattern_recolor(obj, part);
 800be74:	687c      	ldr	r4, [r7, #4]
 800be76:	7afb      	ldrb	r3, [r7, #11]
 800be78:	4619      	mov	r1, r3
 800be7a:	68f8      	ldr	r0, [r7, #12]
 800be7c:	f7fc ff80 	bl	8008d80 <lv_obj_get_style_pattern_recolor>
 800be80:	86a0      	strh	r0, [r4, #52]	; 0x34
                }
#if LV_USE_BLEND_MODES
                draw_dsc->pattern_blend_mode = lv_obj_get_style_pattern_blend_mode(obj, part);
 800be82:	7afb      	ldrb	r3, [r7, #11]
 800be84:	4619      	mov	r1, r3
 800be86:	68f8      	ldr	r0, [r7, #12]
 800be88:	f7fc ff68 	bl	8008d5c <lv_obj_get_style_pattern_blend_mode>
 800be8c:	4603      	mov	r3, r0
 800be8e:	461a      	mov	r2, r3
 800be90:	687b      	ldr	r3, [r7, #4]
 800be92:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
        }
    }
#endif

#if LV_USE_SHADOW
    draw_dsc->shadow_width = lv_obj_get_style_shadow_width(obj, part);
 800be96:	7afb      	ldrb	r3, [r7, #11]
 800be98:	4619      	mov	r1, r3
 800be9a:	68f8      	ldr	r0, [r7, #12]
 800be9c:	f7fc fed0 	bl	8008c40 <lv_obj_get_style_shadow_width>
 800bea0:	4603      	mov	r3, r0
 800bea2:	461a      	mov	r2, r3
 800bea4:	687b      	ldr	r3, [r7, #4]
 800bea6:	845a      	strh	r2, [r3, #34]	; 0x22
    if(draw_dsc->shadow_width) {
 800bea8:	687b      	ldr	r3, [r7, #4]
 800beaa:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
 800beae:	2b00      	cmp	r3, #0
 800beb0:	d03f      	beq.n	800bf32 <lv_obj_init_draw_rect_dsc+0x330>
        if(draw_dsc->shadow_opa > LV_OPA_MIN) {
 800beb2:	687b      	ldr	r3, [r7, #4]
 800beb4:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 800beb8:	2b02      	cmp	r3, #2
 800beba:	d93a      	bls.n	800bf32 <lv_obj_init_draw_rect_dsc+0x330>
            draw_dsc->shadow_opa = lv_obj_get_style_shadow_opa(obj, part);
 800bebc:	7afb      	ldrb	r3, [r7, #11]
 800bebe:	4619      	mov	r1, r3
 800bec0:	68f8      	ldr	r0, [r7, #12]
 800bec2:	f7fc ff24 	bl	8008d0e <lv_obj_get_style_shadow_opa>
 800bec6:	4603      	mov	r3, r0
 800bec8:	461a      	mov	r2, r3
 800beca:	687b      	ldr	r3, [r7, #4]
 800becc:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
            if(draw_dsc->shadow_opa > LV_OPA_MIN) {
 800bed0:	687b      	ldr	r3, [r7, #4]
 800bed2:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 800bed6:	2b02      	cmp	r3, #2
 800bed8:	d92b      	bls.n	800bf32 <lv_obj_init_draw_rect_dsc+0x330>
                draw_dsc->shadow_ofs_x = lv_obj_get_style_shadow_ofs_x(obj, part);
 800beda:	7afb      	ldrb	r3, [r7, #11]
 800bedc:	4619      	mov	r1, r3
 800bede:	68f8      	ldr	r0, [r7, #12]
 800bee0:	f7fc febf 	bl	8008c62 <lv_obj_get_style_shadow_ofs_x>
 800bee4:	4603      	mov	r3, r0
 800bee6:	461a      	mov	r2, r3
 800bee8:	687b      	ldr	r3, [r7, #4]
 800beea:	849a      	strh	r2, [r3, #36]	; 0x24
                draw_dsc->shadow_ofs_y = lv_obj_get_style_shadow_ofs_y(obj, part);
 800beec:	7afb      	ldrb	r3, [r7, #11]
 800beee:	4619      	mov	r1, r3
 800bef0:	68f8      	ldr	r0, [r7, #12]
 800bef2:	f7fc fec7 	bl	8008c84 <lv_obj_get_style_shadow_ofs_y>
 800bef6:	4603      	mov	r3, r0
 800bef8:	461a      	mov	r2, r3
 800befa:	687b      	ldr	r3, [r7, #4]
 800befc:	84da      	strh	r2, [r3, #38]	; 0x26
                draw_dsc->shadow_spread = lv_obj_get_style_shadow_spread(obj, part);
 800befe:	7afb      	ldrb	r3, [r7, #11]
 800bf00:	4619      	mov	r1, r3
 800bf02:	68f8      	ldr	r0, [r7, #12]
 800bf04:	f7fc fecf 	bl	8008ca6 <lv_obj_get_style_shadow_spread>
 800bf08:	4603      	mov	r3, r0
 800bf0a:	461a      	mov	r2, r3
 800bf0c:	687b      	ldr	r3, [r7, #4]
 800bf0e:	851a      	strh	r2, [r3, #40]	; 0x28
                draw_dsc->shadow_color = lv_obj_get_style_shadow_color(obj, part);
 800bf10:	687c      	ldr	r4, [r7, #4]
 800bf12:	7afb      	ldrb	r3, [r7, #11]
 800bf14:	4619      	mov	r1, r3
 800bf16:	68f8      	ldr	r0, [r7, #12]
 800bf18:	f7fc fee8 	bl	8008cec <lv_obj_get_style_shadow_color>
 800bf1c:	8420      	strh	r0, [r4, #32]
#if LV_USE_BLEND_MODES
                draw_dsc->shadow_blend_mode = lv_obj_get_style_shadow_blend_mode(obj, part);
 800bf1e:	7afb      	ldrb	r3, [r7, #11]
 800bf20:	4619      	mov	r1, r3
 800bf22:	68f8      	ldr	r0, [r7, #12]
 800bf24:	f7fc fed0 	bl	8008cc8 <lv_obj_get_style_shadow_blend_mode>
 800bf28:	4603      	mov	r3, r0
 800bf2a:	461a      	mov	r2, r3
 800bf2c:	687b      	ldr	r3, [r7, #4]
 800bf2e:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
        }
    }
#endif

#if LV_USE_VALUE_STR
    draw_dsc->value_str = lv_obj_get_style_value_str(obj, part);
 800bf32:	7afb      	ldrb	r3, [r7, #11]
 800bf34:	4619      	mov	r1, r3
 800bf36:	68f8      	ldr	r0, [r7, #12]
 800bf38:	f7fd f801 	bl	8008f3e <lv_obj_get_style_value_str>
 800bf3c:	4602      	mov	r2, r0
 800bf3e:	687b      	ldr	r3, [r7, #4]
 800bf40:	63da      	str	r2, [r3, #60]	; 0x3c
    if(draw_dsc->value_str) {
 800bf42:	687b      	ldr	r3, [r7, #4]
 800bf44:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800bf46:	2b00      	cmp	r3, #0
 800bf48:	d05f      	beq.n	800c00a <lv_obj_init_draw_rect_dsc+0x408>
        if(draw_dsc->value_opa > LV_OPA_MIN) {
 800bf4a:	687b      	ldr	r3, [r7, #4]
 800bf4c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800bf50:	2b02      	cmp	r3, #2
 800bf52:	d95a      	bls.n	800c00a <lv_obj_init_draw_rect_dsc+0x408>
            draw_dsc->value_opa = lv_obj_get_style_value_opa(obj, part);
 800bf54:	7afb      	ldrb	r3, [r7, #11]
 800bf56:	4619      	mov	r1, r3
 800bf58:	68f8      	ldr	r0, [r7, #12]
 800bf5a:	f7fc ffce 	bl	8008efa <lv_obj_get_style_value_opa>
 800bf5e:	4603      	mov	r3, r0
 800bf60:	461a      	mov	r2, r3
 800bf62:	687b      	ldr	r3, [r7, #4]
 800bf64:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
            if(draw_dsc->value_opa > LV_OPA_MIN) {
 800bf68:	687b      	ldr	r3, [r7, #4]
 800bf6a:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800bf6e:	2b02      	cmp	r3, #2
 800bf70:	d94b      	bls.n	800c00a <lv_obj_init_draw_rect_dsc+0x408>
                draw_dsc->value_ofs_x = lv_obj_get_style_value_ofs_x(obj, part);
 800bf72:	7afb      	ldrb	r3, [r7, #11]
 800bf74:	4619      	mov	r1, r3
 800bf76:	68f8      	ldr	r0, [r7, #12]
 800bf78:	f7fc ff7a 	bl	8008e70 <lv_obj_get_style_value_ofs_x>
 800bf7c:	4603      	mov	r3, r0
 800bf7e:	461a      	mov	r2, r3
 800bf80:	687b      	ldr	r3, [r7, #4]
 800bf82:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
                draw_dsc->value_ofs_y = lv_obj_get_style_value_ofs_y(obj, part);
 800bf86:	7afb      	ldrb	r3, [r7, #11]
 800bf88:	4619      	mov	r1, r3
 800bf8a:	68f8      	ldr	r0, [r7, #12]
 800bf8c:	f7fc ff81 	bl	8008e92 <lv_obj_get_style_value_ofs_y>
 800bf90:	4603      	mov	r3, r0
 800bf92:	461a      	mov	r2, r3
 800bf94:	687b      	ldr	r3, [r7, #4]
 800bf96:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
                draw_dsc->value_color = lv_obj_get_style_value_color(obj, part);
 800bf9a:	687c      	ldr	r4, [r7, #4]
 800bf9c:	7afb      	ldrb	r3, [r7, #11]
 800bf9e:	4619      	mov	r1, r3
 800bfa0:	68f8      	ldr	r0, [r7, #12]
 800bfa2:	f7fc ff99 	bl	8008ed8 <lv_obj_get_style_value_color>
 800bfa6:	f8a4 0046 	strh.w	r0, [r4, #70]	; 0x46
                draw_dsc->value_font = lv_obj_get_style_value_font(obj, part);
 800bfaa:	7afb      	ldrb	r3, [r7, #11]
 800bfac:	4619      	mov	r1, r3
 800bfae:	68f8      	ldr	r0, [r7, #12]
 800bfb0:	f7fc ffb4 	bl	8008f1c <lv_obj_get_style_value_font>
 800bfb4:	4602      	mov	r2, r0
 800bfb6:	687b      	ldr	r3, [r7, #4]
 800bfb8:	641a      	str	r2, [r3, #64]	; 0x40
                draw_dsc->value_letter_space = lv_obj_get_style_value_letter_space(obj, part);
 800bfba:	7afb      	ldrb	r3, [r7, #11]
 800bfbc:	4619      	mov	r1, r3
 800bfbe:	68f8      	ldr	r0, [r7, #12]
 800bfc0:	f7fc ff22 	bl	8008e08 <lv_obj_get_style_value_letter_space>
 800bfc4:	4603      	mov	r3, r0
 800bfc6:	461a      	mov	r2, r3
 800bfc8:	687b      	ldr	r3, [r7, #4]
 800bfca:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
                draw_dsc->value_line_space = lv_obj_get_style_value_line_space(obj, part);
 800bfce:	7afb      	ldrb	r3, [r7, #11]
 800bfd0:	4619      	mov	r1, r3
 800bfd2:	68f8      	ldr	r0, [r7, #12]
 800bfd4:	f7fc ff29 	bl	8008e2a <lv_obj_get_style_value_line_space>
 800bfd8:	4603      	mov	r3, r0
 800bfda:	461a      	mov	r2, r3
 800bfdc:	687b      	ldr	r3, [r7, #4]
 800bfde:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
                draw_dsc->value_align = lv_obj_get_style_value_align(obj, part);
 800bfe2:	7afb      	ldrb	r3, [r7, #11]
 800bfe4:	4619      	mov	r1, r3
 800bfe6:	68f8      	ldr	r0, [r7, #12]
 800bfe8:	f7fc ff64 	bl	8008eb4 <lv_obj_get_style_value_align>
 800bfec:	4603      	mov	r3, r0
 800bfee:	461a      	mov	r2, r3
 800bff0:	687b      	ldr	r3, [r7, #4]
 800bff2:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
#if LV_USE_BLEND_MODES
                draw_dsc->value_blend_mode = lv_obj_get_style_value_blend_mode(obj, part);
 800bff6:	7afb      	ldrb	r3, [r7, #11]
 800bff8:	4619      	mov	r1, r3
 800bffa:	68f8      	ldr	r0, [r7, #12]
 800bffc:	f7fc ff26 	bl	8008e4c <lv_obj_get_style_value_blend_mode>
 800c000:	4603      	mov	r3, r0
 800c002:	461a      	mov	r2, r3
 800c004:	687b      	ldr	r3, [r7, #4]
 800c006:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
        }
    }
#endif

#if LV_USE_OPA_SCALE
    if(opa_scale < LV_OPA_MAX) {
 800c00a:	7dfb      	ldrb	r3, [r7, #23]
 800c00c:	2bfc      	cmp	r3, #252	; 0xfc
 800c00e:	d846      	bhi.n	800c09e <lv_obj_init_draw_rect_dsc+0x49c>
        draw_dsc->bg_opa = (uint16_t)((uint16_t)draw_dsc->bg_opa * opa_scale) >> 8;
 800c010:	687b      	ldr	r3, [r7, #4]
 800c012:	7b1b      	ldrb	r3, [r3, #12]
 800c014:	b29a      	uxth	r2, r3
 800c016:	7dfb      	ldrb	r3, [r7, #23]
 800c018:	b29b      	uxth	r3, r3
 800c01a:	fb12 f303 	smulbb	r3, r2, r3
 800c01e:	b29b      	uxth	r3, r3
 800c020:	0a1b      	lsrs	r3, r3, #8
 800c022:	b29b      	uxth	r3, r3
 800c024:	b2da      	uxtb	r2, r3
 800c026:	687b      	ldr	r3, [r7, #4]
 800c028:	731a      	strb	r2, [r3, #12]
        draw_dsc->border_opa = (uint16_t)((uint16_t)draw_dsc->border_opa * opa_scale) >> 8;
 800c02a:	687b      	ldr	r3, [r7, #4]
 800c02c:	7d1b      	ldrb	r3, [r3, #20]
 800c02e:	b29a      	uxth	r2, r3
 800c030:	7dfb      	ldrb	r3, [r7, #23]
 800c032:	b29b      	uxth	r3, r3
 800c034:	fb12 f303 	smulbb	r3, r2, r3
 800c038:	b29b      	uxth	r3, r3
 800c03a:	0a1b      	lsrs	r3, r3, #8
 800c03c:	b29b      	uxth	r3, r3
 800c03e:	b2da      	uxtb	r2, r3
 800c040:	687b      	ldr	r3, [r7, #4]
 800c042:	751a      	strb	r2, [r3, #20]
        draw_dsc->shadow_opa = (uint16_t)((uint16_t)draw_dsc->shadow_opa * opa_scale) >> 8;
 800c044:	687b      	ldr	r3, [r7, #4]
 800c046:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 800c04a:	b29a      	uxth	r2, r3
 800c04c:	7dfb      	ldrb	r3, [r7, #23]
 800c04e:	b29b      	uxth	r3, r3
 800c050:	fb12 f303 	smulbb	r3, r2, r3
 800c054:	b29b      	uxth	r3, r3
 800c056:	0a1b      	lsrs	r3, r3, #8
 800c058:	b29b      	uxth	r3, r3
 800c05a:	b2da      	uxtb	r2, r3
 800c05c:	687b      	ldr	r3, [r7, #4]
 800c05e:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
        draw_dsc->pattern_opa = (uint16_t)((uint16_t)draw_dsc->pattern_opa * opa_scale) >> 8;
 800c062:	687b      	ldr	r3, [r7, #4]
 800c064:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 800c068:	b29a      	uxth	r2, r3
 800c06a:	7dfb      	ldrb	r3, [r7, #23]
 800c06c:	b29b      	uxth	r3, r3
 800c06e:	fb12 f303 	smulbb	r3, r2, r3
 800c072:	b29b      	uxth	r3, r3
 800c074:	0a1b      	lsrs	r3, r3, #8
 800c076:	b29b      	uxth	r3, r3
 800c078:	b2da      	uxtb	r2, r3
 800c07a:	687b      	ldr	r3, [r7, #4]
 800c07c:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
        draw_dsc->value_opa = (uint16_t)((uint16_t)draw_dsc->value_opa * opa_scale) >> 8;
 800c080:	687b      	ldr	r3, [r7, #4]
 800c082:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800c086:	b29a      	uxth	r2, r3
 800c088:	7dfb      	ldrb	r3, [r7, #23]
 800c08a:	b29b      	uxth	r3, r3
 800c08c:	fb12 f303 	smulbb	r3, r2, r3
 800c090:	b29b      	uxth	r3, r3
 800c092:	0a1b      	lsrs	r3, r3, #8
 800c094:	b29b      	uxth	r3, r3
 800c096:	b2da      	uxtb	r2, r3
 800c098:	687b      	ldr	r3, [r7, #4]
 800c09a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    }
#endif
}
 800c09e:	371c      	adds	r7, #28
 800c0a0:	46bd      	mov	sp, r7
 800c0a2:	bd90      	pop	{r4, r7, pc}

0800c0a4 <lv_obj_init_draw_label_dsc>:

void lv_obj_init_draw_label_dsc(lv_obj_t * obj, uint8_t part, lv_draw_label_dsc_t * draw_dsc)
{
 800c0a4:	b590      	push	{r4, r7, lr}
 800c0a6:	b087      	sub	sp, #28
 800c0a8:	af00      	add	r7, sp, #0
 800c0aa:	60f8      	str	r0, [r7, #12]
 800c0ac:	460b      	mov	r3, r1
 800c0ae:	607a      	str	r2, [r7, #4]
 800c0b0:	72fb      	strb	r3, [r7, #11]
    draw_dsc->opa = lv_obj_get_style_text_opa(obj, part);
 800c0b2:	7afb      	ldrb	r3, [r7, #11]
 800c0b4:	4619      	mov	r1, r3
 800c0b6:	68f8      	ldr	r0, [r7, #12]
 800c0b8:	f7fc ffc0 	bl	800903c <lv_obj_get_style_text_opa>
 800c0bc:	4603      	mov	r3, r0
 800c0be:	461a      	mov	r2, r3
 800c0c0:	687b      	ldr	r3, [r7, #4]
 800c0c2:	721a      	strb	r2, [r3, #8]
    if(draw_dsc->opa <= LV_OPA_MIN) return;
 800c0c4:	687b      	ldr	r3, [r7, #4]
 800c0c6:	7a1b      	ldrb	r3, [r3, #8]
 800c0c8:	2b02      	cmp	r3, #2
 800c0ca:	d961      	bls.n	800c190 <lv_obj_init_draw_label_dsc+0xec>

#if LV_USE_OPA_SCALE
    lv_opa_t opa_scale = lv_obj_get_style_opa_scale(obj, part);
 800c0cc:	7afb      	ldrb	r3, [r7, #11]
 800c0ce:	4619      	mov	r1, r3
 800c0d0:	68f8      	ldr	r0, [r7, #12]
 800c0d2:	f7fc fc23 	bl	800891c <lv_obj_get_style_opa_scale>
 800c0d6:	4603      	mov	r3, r0
 800c0d8:	75fb      	strb	r3, [r7, #23]
    if(opa_scale < LV_OPA_MAX) {
 800c0da:	7dfb      	ldrb	r3, [r7, #23]
 800c0dc:	2bfc      	cmp	r3, #252	; 0xfc
 800c0de:	d80c      	bhi.n	800c0fa <lv_obj_init_draw_label_dsc+0x56>
        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa_scale) >> 8;
 800c0e0:	687b      	ldr	r3, [r7, #4]
 800c0e2:	7a1b      	ldrb	r3, [r3, #8]
 800c0e4:	b29a      	uxth	r2, r3
 800c0e6:	7dfb      	ldrb	r3, [r7, #23]
 800c0e8:	b29b      	uxth	r3, r3
 800c0ea:	fb12 f303 	smulbb	r3, r2, r3
 800c0ee:	b29b      	uxth	r3, r3
 800c0f0:	0a1b      	lsrs	r3, r3, #8
 800c0f2:	b29b      	uxth	r3, r3
 800c0f4:	b2da      	uxtb	r2, r3
 800c0f6:	687b      	ldr	r3, [r7, #4]
 800c0f8:	721a      	strb	r2, [r3, #8]
    }
    if(draw_dsc->opa <= LV_OPA_MIN) return;
 800c0fa:	687b      	ldr	r3, [r7, #4]
 800c0fc:	7a1b      	ldrb	r3, [r3, #8]
 800c0fe:	2b02      	cmp	r3, #2
 800c100:	d948      	bls.n	800c194 <lv_obj_init_draw_label_dsc+0xf0>
#endif

    draw_dsc->color = lv_obj_get_style_text_color(obj, part);
 800c102:	687c      	ldr	r4, [r7, #4]
 800c104:	7afb      	ldrb	r3, [r7, #11]
 800c106:	4619      	mov	r1, r3
 800c108:	68f8      	ldr	r0, [r7, #12]
 800c10a:	f7fc ff73 	bl	8008ff4 <lv_obj_get_style_text_color>
 800c10e:	8020      	strh	r0, [r4, #0]
    draw_dsc->letter_space = lv_obj_get_style_text_letter_space(obj, part);
 800c110:	7afb      	ldrb	r3, [r7, #11]
 800c112:	4619      	mov	r1, r3
 800c114:	68f8      	ldr	r0, [r7, #12]
 800c116:	f7fc ff23 	bl	8008f60 <lv_obj_get_style_text_letter_space>
 800c11a:	4603      	mov	r3, r0
 800c11c:	461a      	mov	r2, r3
 800c11e:	687b      	ldr	r3, [r7, #4]
 800c120:	819a      	strh	r2, [r3, #12]
    draw_dsc->line_space = lv_obj_get_style_text_line_space(obj, part);
 800c122:	7afb      	ldrb	r3, [r7, #11]
 800c124:	4619      	mov	r1, r3
 800c126:	68f8      	ldr	r0, [r7, #12]
 800c128:	f7fc ff2c 	bl	8008f84 <lv_obj_get_style_text_line_space>
 800c12c:	4603      	mov	r3, r0
 800c12e:	461a      	mov	r2, r3
 800c130:	687b      	ldr	r3, [r7, #4]
 800c132:	815a      	strh	r2, [r3, #10]
    draw_dsc->decor = lv_obj_get_style_text_decor(obj, part);
 800c134:	7afb      	ldrb	r3, [r7, #11]
 800c136:	4619      	mov	r1, r3
 800c138:	68f8      	ldr	r0, [r7, #12]
 800c13a:	f7fc ff35 	bl	8008fa8 <lv_obj_get_style_text_decor>
 800c13e:	4603      	mov	r3, r0
 800c140:	461a      	mov	r2, r3
 800c142:	687b      	ldr	r3, [r7, #4]
 800c144:	779a      	strb	r2, [r3, #30]
#if LV_USE_BLEND_MODES
    draw_dsc->blend_mode = lv_obj_get_style_text_blend_mode(obj, part);
 800c146:	7afb      	ldrb	r3, [r7, #11]
 800c148:	4619      	mov	r1, r3
 800c14a:	68f8      	ldr	r0, [r7, #12]
 800c14c:	f7fc ff3f 	bl	8008fce <lv_obj_get_style_text_blend_mode>
 800c150:	4603      	mov	r3, r0
 800c152:	461a      	mov	r2, r3
 800c154:	687b      	ldr	r3, [r7, #4]
 800c156:	77da      	strb	r2, [r3, #31]
#endif

    draw_dsc->font = lv_obj_get_style_text_font(obj, part);
 800c158:	7afb      	ldrb	r3, [r7, #11]
 800c15a:	4619      	mov	r1, r3
 800c15c:	68f8      	ldr	r0, [r7, #12]
 800c15e:	f7fc ff7f 	bl	8009060 <lv_obj_get_style_text_font>
 800c162:	4602      	mov	r2, r0
 800c164:	687b      	ldr	r3, [r7, #4]
 800c166:	605a      	str	r2, [r3, #4]

    if(draw_dsc->sel_start != LV_DRAW_LABEL_NO_TXT_SEL && draw_dsc->sel_end != LV_DRAW_LABEL_NO_TXT_SEL) {
 800c168:	687b      	ldr	r3, [r7, #4]
 800c16a:	691b      	ldr	r3, [r3, #16]
 800c16c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800c170:	4293      	cmp	r3, r2
 800c172:	d010      	beq.n	800c196 <lv_obj_init_draw_label_dsc+0xf2>
 800c174:	687b      	ldr	r3, [r7, #4]
 800c176:	695b      	ldr	r3, [r3, #20]
 800c178:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800c17c:	4293      	cmp	r3, r2
 800c17e:	d00a      	beq.n	800c196 <lv_obj_init_draw_label_dsc+0xf2>
        draw_dsc->color = lv_obj_get_style_text_sel_color(obj, part);
 800c180:	687c      	ldr	r4, [r7, #4]
 800c182:	7afb      	ldrb	r3, [r7, #11]
 800c184:	4619      	mov	r1, r3
 800c186:	68f8      	ldr	r0, [r7, #12]
 800c188:	f7fc ff46 	bl	8009018 <lv_obj_get_style_text_sel_color>
 800c18c:	8020      	strh	r0, [r4, #0]
 800c18e:	e002      	b.n	800c196 <lv_obj_init_draw_label_dsc+0xf2>
    if(draw_dsc->opa <= LV_OPA_MIN) return;
 800c190:	bf00      	nop
 800c192:	e000      	b.n	800c196 <lv_obj_init_draw_label_dsc+0xf2>
    if(draw_dsc->opa <= LV_OPA_MIN) return;
 800c194:	bf00      	nop
    }

#if LV_USE_BIDI
    draw_dsc->bidi_dir = lv_obj_get_base_dir(obj);
#endif
}
 800c196:	371c      	adds	r7, #28
 800c198:	46bd      	mov	sp, r7
 800c19a:	bd90      	pop	{r4, r7, pc}

0800c19c <lv_obj_init_draw_img_dsc>:

void lv_obj_init_draw_img_dsc(lv_obj_t * obj, uint8_t part, lv_draw_img_dsc_t * draw_dsc)
{
 800c19c:	b590      	push	{r4, r7, lr}
 800c19e:	b087      	sub	sp, #28
 800c1a0:	af00      	add	r7, sp, #0
 800c1a2:	60f8      	str	r0, [r7, #12]
 800c1a4:	460b      	mov	r3, r1
 800c1a6:	607a      	str	r2, [r7, #4]
 800c1a8:	72fb      	strb	r3, [r7, #11]
    draw_dsc->opa = lv_obj_get_style_image_opa(obj, part);
 800c1aa:	7afb      	ldrb	r3, [r7, #11]
 800c1ac:	4619      	mov	r1, r3
 800c1ae:	68f8      	ldr	r0, [r7, #12]
 800c1b0:	f7fc ff9f 	bl	80090f2 <lv_obj_get_style_image_opa>
 800c1b4:	4603      	mov	r3, r0
 800c1b6:	461a      	mov	r2, r3
 800c1b8:	687b      	ldr	r3, [r7, #4]
 800c1ba:	701a      	strb	r2, [r3, #0]
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
 800c1bc:	687b      	ldr	r3, [r7, #4]
 800c1be:	781b      	ldrb	r3, [r3, #0]
 800c1c0:	2b02      	cmp	r3, #2
 800c1c2:	d957      	bls.n	800c274 <lv_obj_init_draw_img_dsc+0xd8>

#if LV_USE_OPA_SCALE
    lv_opa_t opa_scale = lv_obj_get_style_opa_scale(obj, part);
 800c1c4:	7afb      	ldrb	r3, [r7, #11]
 800c1c6:	4619      	mov	r1, r3
 800c1c8:	68f8      	ldr	r0, [r7, #12]
 800c1ca:	f7fc fba7 	bl	800891c <lv_obj_get_style_opa_scale>
 800c1ce:	4603      	mov	r3, r0
 800c1d0:	75fb      	strb	r3, [r7, #23]
    if(opa_scale < LV_OPA_MAX) {
 800c1d2:	7dfb      	ldrb	r3, [r7, #23]
 800c1d4:	2bfc      	cmp	r3, #252	; 0xfc
 800c1d6:	d80c      	bhi.n	800c1f2 <lv_obj_init_draw_img_dsc+0x56>
        draw_dsc->opa = (uint16_t)((uint16_t)draw_dsc->opa * opa_scale) >> 8;
 800c1d8:	687b      	ldr	r3, [r7, #4]
 800c1da:	781b      	ldrb	r3, [r3, #0]
 800c1dc:	b29a      	uxth	r2, r3
 800c1de:	7dfb      	ldrb	r3, [r7, #23]
 800c1e0:	b29b      	uxth	r3, r3
 800c1e2:	fb12 f303 	smulbb	r3, r2, r3
 800c1e6:	b29b      	uxth	r3, r3
 800c1e8:	0a1b      	lsrs	r3, r3, #8
 800c1ea:	b29b      	uxth	r3, r3
 800c1ec:	b2da      	uxtb	r2, r3
 800c1ee:	687b      	ldr	r3, [r7, #4]
 800c1f0:	701a      	strb	r2, [r3, #0]
    }
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
 800c1f2:	687b      	ldr	r3, [r7, #4]
 800c1f4:	781b      	ldrb	r3, [r3, #0]
 800c1f6:	2b02      	cmp	r3, #2
 800c1f8:	d93e      	bls.n	800c278 <lv_obj_init_draw_img_dsc+0xdc>
#endif

    draw_dsc->angle = 0;
 800c1fa:	687b      	ldr	r3, [r7, #4]
 800c1fc:	2200      	movs	r2, #0
 800c1fe:	805a      	strh	r2, [r3, #2]
    draw_dsc->zoom = LV_IMG_ZOOM_NONE;
 800c200:	687b      	ldr	r3, [r7, #4]
 800c202:	f44f 7280 	mov.w	r2, #256	; 0x100
 800c206:	811a      	strh	r2, [r3, #8]
    draw_dsc->pivot.x = lv_area_get_width(&obj->coords) / 2;
 800c208:	68fb      	ldr	r3, [r7, #12]
 800c20a:	3310      	adds	r3, #16
 800c20c:	4618      	mov	r0, r3
 800c20e:	f7fc f987 	bl	8008520 <lv_area_get_width>
 800c212:	4603      	mov	r3, r0
 800c214:	0fda      	lsrs	r2, r3, #31
 800c216:	4413      	add	r3, r2
 800c218:	105b      	asrs	r3, r3, #1
 800c21a:	b21a      	sxth	r2, r3
 800c21c:	687b      	ldr	r3, [r7, #4]
 800c21e:	809a      	strh	r2, [r3, #4]
    draw_dsc->pivot.y = lv_area_get_height(&obj->coords) / 2;
 800c220:	68fb      	ldr	r3, [r7, #12]
 800c222:	3310      	adds	r3, #16
 800c224:	4618      	mov	r0, r3
 800c226:	f7fc f992 	bl	800854e <lv_area_get_height>
 800c22a:	4603      	mov	r3, r0
 800c22c:	0fda      	lsrs	r2, r3, #31
 800c22e:	4413      	add	r3, r2
 800c230:	105b      	asrs	r3, r3, #1
 800c232:	b21a      	sxth	r2, r3
 800c234:	687b      	ldr	r3, [r7, #4]
 800c236:	80da      	strh	r2, [r3, #6]

    draw_dsc->recolor_opa = lv_obj_get_style_image_recolor_opa(obj, part);
 800c238:	7afb      	ldrb	r3, [r7, #11]
 800c23a:	4619      	mov	r1, r3
 800c23c:	68f8      	ldr	r0, [r7, #12]
 800c23e:	f7fc ff6a 	bl	8009116 <lv_obj_get_style_image_recolor_opa>
 800c242:	4603      	mov	r3, r0
 800c244:	461a      	mov	r2, r3
 800c246:	687b      	ldr	r3, [r7, #4]
 800c248:	729a      	strb	r2, [r3, #10]
    if(draw_dsc->recolor_opa > 0) {
 800c24a:	687b      	ldr	r3, [r7, #4]
 800c24c:	7a9b      	ldrb	r3, [r3, #10]
 800c24e:	2b00      	cmp	r3, #0
 800c250:	d006      	beq.n	800c260 <lv_obj_init_draw_img_dsc+0xc4>
        draw_dsc->recolor = lv_obj_get_style_image_recolor(obj, part);
 800c252:	687c      	ldr	r4, [r7, #4]
 800c254:	7afb      	ldrb	r3, [r7, #11]
 800c256:	4619      	mov	r1, r3
 800c258:	68f8      	ldr	r0, [r7, #12]
 800c25a:	f7fc ff38 	bl	80090ce <lv_obj_get_style_image_recolor>
 800c25e:	81a0      	strh	r0, [r4, #12]
    }
#if LV_USE_BLEND_MODES
    draw_dsc->blend_mode = lv_obj_get_style_image_blend_mode(obj, part);
 800c260:	7afb      	ldrb	r3, [r7, #11]
 800c262:	4619      	mov	r1, r3
 800c264:	68f8      	ldr	r0, [r7, #12]
 800c266:	f7fc ff1f 	bl	80090a8 <lv_obj_get_style_image_blend_mode>
 800c26a:	4603      	mov	r3, r0
 800c26c:	461a      	mov	r2, r3
 800c26e:	687b      	ldr	r3, [r7, #4]
 800c270:	739a      	strb	r2, [r3, #14]
 800c272:	e002      	b.n	800c27a <lv_obj_init_draw_img_dsc+0xde>
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
 800c274:	bf00      	nop
 800c276:	e000      	b.n	800c27a <lv_obj_init_draw_img_dsc+0xde>
    if(draw_dsc->opa <= LV_OPA_MIN)  return;
 800c278:	bf00      	nop
#endif
}
 800c27a:	371c      	adds	r7, #28
 800c27c:	46bd      	mov	sp, r7
 800c27e:	bd90      	pop	{r4, r7, pc}

0800c280 <lv_obj_get_draw_rect_ext_pad_size>:
 * Get the required extra size (around the object's part) to draw shadow, outline, value etc.
 * @param obj pointer to an object
 * @param part part of the object
 */
lv_coord_t lv_obj_get_draw_rect_ext_pad_size(lv_obj_t * obj, uint8_t part)
{
 800c280:	b580      	push	{r7, lr}
 800c282:	b096      	sub	sp, #88	; 0x58
 800c284:	af04      	add	r7, sp, #16
 800c286:	6078      	str	r0, [r7, #4]
 800c288:	460b      	mov	r3, r1
 800c28a:	70fb      	strb	r3, [r7, #3]
    lv_coord_t s = 0;
 800c28c:	2300      	movs	r3, #0
 800c28e:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46

    lv_coord_t sh_width = lv_obj_get_style_shadow_width(obj, part);
 800c292:	78fb      	ldrb	r3, [r7, #3]
 800c294:	4619      	mov	r1, r3
 800c296:	6878      	ldr	r0, [r7, #4]
 800c298:	f7fc fcd2 	bl	8008c40 <lv_obj_get_style_shadow_width>
 800c29c:	4603      	mov	r3, r0
 800c29e:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
    if(sh_width) {
 800c2a2:	f9b7 3044 	ldrsh.w	r3, [r7, #68]	; 0x44
 800c2a6:	2b00      	cmp	r3, #0
 800c2a8:	d054      	beq.n	800c354 <lv_obj_get_draw_rect_ext_pad_size+0xd4>
        lv_opa_t sh_opa = lv_obj_get_style_shadow_opa(obj, part);
 800c2aa:	78fb      	ldrb	r3, [r7, #3]
 800c2ac:	4619      	mov	r1, r3
 800c2ae:	6878      	ldr	r0, [r7, #4]
 800c2b0:	f7fc fd2d 	bl	8008d0e <lv_obj_get_style_shadow_opa>
 800c2b4:	4603      	mov	r3, r0
 800c2b6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
        if(sh_opa > LV_OPA_MIN) {
 800c2ba:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 800c2be:	2b02      	cmp	r3, #2
 800c2c0:	d948      	bls.n	800c354 <lv_obj_get_draw_rect_ext_pad_size+0xd4>
            sh_width = sh_width / 2;    /*THe blur adds only half width*/
 800c2c2:	f9b7 3044 	ldrsh.w	r3, [r7, #68]	; 0x44
 800c2c6:	0fda      	lsrs	r2, r3, #31
 800c2c8:	4413      	add	r3, r2
 800c2ca:	105b      	asrs	r3, r3, #1
 800c2cc:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
            sh_width++;
 800c2d0:	f9b7 3044 	ldrsh.w	r3, [r7, #68]	; 0x44
 800c2d4:	b29b      	uxth	r3, r3
 800c2d6:	3301      	adds	r3, #1
 800c2d8:	b29b      	uxth	r3, r3
 800c2da:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
            sh_width += lv_obj_get_style_shadow_spread(obj, part);
 800c2de:	78fb      	ldrb	r3, [r7, #3]
 800c2e0:	4619      	mov	r1, r3
 800c2e2:	6878      	ldr	r0, [r7, #4]
 800c2e4:	f7fc fcdf 	bl	8008ca6 <lv_obj_get_style_shadow_spread>
 800c2e8:	4603      	mov	r3, r0
 800c2ea:	b29a      	uxth	r2, r3
 800c2ec:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 800c2f0:	4413      	add	r3, r2
 800c2f2:	b29b      	uxth	r3, r3
 800c2f4:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
            lv_style_int_t sh_ofs_x = lv_obj_get_style_shadow_ofs_x(obj, part);
 800c2f8:	78fb      	ldrb	r3, [r7, #3]
 800c2fa:	4619      	mov	r1, r3
 800c2fc:	6878      	ldr	r0, [r7, #4]
 800c2fe:	f7fc fcb0 	bl	8008c62 <lv_obj_get_style_shadow_ofs_x>
 800c302:	4603      	mov	r3, r0
 800c304:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
            lv_style_int_t sh_ofs_y = lv_obj_get_style_shadow_ofs_y(obj, part);
 800c308:	78fb      	ldrb	r3, [r7, #3]
 800c30a:	4619      	mov	r1, r3
 800c30c:	6878      	ldr	r0, [r7, #4]
 800c30e:	f7fc fcb9 	bl	8008c84 <lv_obj_get_style_shadow_ofs_y>
 800c312:	4603      	mov	r3, r0
 800c314:	87fb      	strh	r3, [r7, #62]	; 0x3e
            sh_width += LV_MATH_MAX(LV_MATH_ABS(sh_ofs_x), LV_MATH_ABS(sh_ofs_y));
 800c316:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 800c31a:	2b00      	cmp	r3, #0
 800c31c:	bfb8      	it	lt
 800c31e:	425b      	neglt	r3, r3
 800c320:	b29a      	uxth	r2, r3
 800c322:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 800c326:	2b00      	cmp	r3, #0
 800c328:	bfb8      	it	lt
 800c32a:	425b      	neglt	r3, r3
 800c32c:	b29b      	uxth	r3, r3
 800c32e:	4293      	cmp	r3, r2
 800c330:	bf38      	it	cc
 800c332:	4613      	movcc	r3, r2
 800c334:	b29a      	uxth	r2, r3
 800c336:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 800c33a:	4413      	add	r3, r2
 800c33c:	b29b      	uxth	r3, r3
 800c33e:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
            s = LV_MATH_MAX(s, sh_width);
 800c342:	f9b7 2044 	ldrsh.w	r2, [r7, #68]	; 0x44
 800c346:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 800c34a:	4293      	cmp	r3, r2
 800c34c:	bfb8      	it	lt
 800c34e:	4613      	movlt	r3, r2
 800c350:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
        }
    }

    const char * value_str = lv_obj_get_style_value_str(obj, part);
 800c354:	78fb      	ldrb	r3, [r7, #3]
 800c356:	4619      	mov	r1, r3
 800c358:	6878      	ldr	r0, [r7, #4]
 800c35a:	f7fc fdf0 	bl	8008f3e <lv_obj_get_style_value_str>
 800c35e:	63b8      	str	r0, [r7, #56]	; 0x38
    if(value_str) {
 800c360:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800c362:	2b00      	cmp	r3, #0
 800c364:	f000 80d0 	beq.w	800c508 <lv_obj_get_draw_rect_ext_pad_size+0x288>
        lv_opa_t value_opa = lv_obj_get_style_value_opa(obj, part);
 800c368:	78fb      	ldrb	r3, [r7, #3]
 800c36a:	4619      	mov	r1, r3
 800c36c:	6878      	ldr	r0, [r7, #4]
 800c36e:	f7fc fdc4 	bl	8008efa <lv_obj_get_style_value_opa>
 800c372:	4603      	mov	r3, r0
 800c374:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        if(value_opa > LV_OPA_MIN) {
 800c378:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 800c37c:	2b02      	cmp	r3, #2
 800c37e:	f240 80c3 	bls.w	800c508 <lv_obj_get_draw_rect_ext_pad_size+0x288>
            lv_style_int_t letter_space = lv_obj_get_style_value_letter_space(obj, part);
 800c382:	78fb      	ldrb	r3, [r7, #3]
 800c384:	4619      	mov	r1, r3
 800c386:	6878      	ldr	r0, [r7, #4]
 800c388:	f7fc fd3e 	bl	8008e08 <lv_obj_get_style_value_letter_space>
 800c38c:	4603      	mov	r3, r0
 800c38e:	86bb      	strh	r3, [r7, #52]	; 0x34
            lv_style_int_t line_space = lv_obj_get_style_value_letter_space(obj, part);
 800c390:	78fb      	ldrb	r3, [r7, #3]
 800c392:	4619      	mov	r1, r3
 800c394:	6878      	ldr	r0, [r7, #4]
 800c396:	f7fc fd37 	bl	8008e08 <lv_obj_get_style_value_letter_space>
 800c39a:	4603      	mov	r3, r0
 800c39c:	867b      	strh	r3, [r7, #50]	; 0x32
            const lv_font_t * font = lv_obj_get_style_value_font(obj, part);
 800c39e:	78fb      	ldrb	r3, [r7, #3]
 800c3a0:	4619      	mov	r1, r3
 800c3a2:	6878      	ldr	r0, [r7, #4]
 800c3a4:	f7fc fdba 	bl	8008f1c <lv_obj_get_style_value_font>
 800c3a8:	62f8      	str	r0, [r7, #44]	; 0x2c

            lv_point_t txt_size;
            _lv_txt_get_size(&txt_size, value_str, font, letter_space, line_space, LV_COORD_MAX, LV_TXT_FLAG_NONE);
 800c3aa:	f9b7 2034 	ldrsh.w	r2, [r7, #52]	; 0x34
 800c3ae:	f107 0014 	add.w	r0, r7, #20
 800c3b2:	2300      	movs	r3, #0
 800c3b4:	9302      	str	r3, [sp, #8]
 800c3b6:	f647 4318 	movw	r3, #31768	; 0x7c18
 800c3ba:	9301      	str	r3, [sp, #4]
 800c3bc:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 800c3c0:	9300      	str	r3, [sp, #0]
 800c3c2:	4613      	mov	r3, r2
 800c3c4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c3c6:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800c3c8:	f015 fe60 	bl	802208c <_lv_txt_get_size>

            lv_area_t value_area;
            value_area.x1 = 0;
 800c3cc:	2300      	movs	r3, #0
 800c3ce:	81bb      	strh	r3, [r7, #12]
            value_area.y1 = 0;
 800c3d0:	2300      	movs	r3, #0
 800c3d2:	81fb      	strh	r3, [r7, #14]
            value_area.x2 = txt_size.x - 1;
 800c3d4:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800c3d8:	b29b      	uxth	r3, r3
 800c3da:	3b01      	subs	r3, #1
 800c3dc:	b29b      	uxth	r3, r3
 800c3de:	b21b      	sxth	r3, r3
 800c3e0:	823b      	strh	r3, [r7, #16]
            value_area.y2 = txt_size.y - 1;
 800c3e2:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800c3e6:	b29b      	uxth	r3, r3
 800c3e8:	3b01      	subs	r3, #1
 800c3ea:	b29b      	uxth	r3, r3
 800c3ec:	b21b      	sxth	r3, r3
 800c3ee:	827b      	strh	r3, [r7, #18]

            lv_style_int_t align = lv_obj_get_style_value_align(obj, part);
 800c3f0:	78fb      	ldrb	r3, [r7, #3]
 800c3f2:	4619      	mov	r1, r3
 800c3f4:	6878      	ldr	r0, [r7, #4]
 800c3f6:	f7fc fd5d 	bl	8008eb4 <lv_obj_get_style_value_align>
 800c3fa:	4603      	mov	r3, r0
 800c3fc:	857b      	strh	r3, [r7, #42]	; 0x2a
            lv_style_int_t xofs = lv_obj_get_style_value_ofs_x(obj, part);
 800c3fe:	78fb      	ldrb	r3, [r7, #3]
 800c400:	4619      	mov	r1, r3
 800c402:	6878      	ldr	r0, [r7, #4]
 800c404:	f7fc fd34 	bl	8008e70 <lv_obj_get_style_value_ofs_x>
 800c408:	4603      	mov	r3, r0
 800c40a:	853b      	strh	r3, [r7, #40]	; 0x28
            lv_style_int_t yofs = lv_obj_get_style_value_ofs_y(obj, part);
 800c40c:	78fb      	ldrb	r3, [r7, #3]
 800c40e:	4619      	mov	r1, r3
 800c410:	6878      	ldr	r0, [r7, #4]
 800c412:	f7fc fd3e 	bl	8008e92 <lv_obj_get_style_value_ofs_y>
 800c416:	4603      	mov	r3, r0
 800c418:	84fb      	strh	r3, [r7, #38]	; 0x26
            lv_point_t p_align;
            _lv_area_align(&obj->coords, &value_area, align, &p_align);
 800c41a:	687b      	ldr	r3, [r7, #4]
 800c41c:	f103 0010 	add.w	r0, r3, #16
 800c420:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800c422:	b2da      	uxtb	r2, r3
 800c424:	f107 0308 	add.w	r3, r7, #8
 800c428:	f107 010c 	add.w	r1, r7, #12
 800c42c:	f013 fa96 	bl	801f95c <_lv_area_align>

            value_area.x1 += p_align.x + xofs;
 800c430:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 800c434:	b29a      	uxth	r2, r3
 800c436:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 800c43a:	b299      	uxth	r1, r3
 800c43c:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800c43e:	440b      	add	r3, r1
 800c440:	b29b      	uxth	r3, r3
 800c442:	4413      	add	r3, r2
 800c444:	b29b      	uxth	r3, r3
 800c446:	b21b      	sxth	r3, r3
 800c448:	81bb      	strh	r3, [r7, #12]
            value_area.y1 += p_align.y + yofs;
 800c44a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800c44e:	b29a      	uxth	r2, r3
 800c450:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 800c454:	b299      	uxth	r1, r3
 800c456:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800c458:	440b      	add	r3, r1
 800c45a:	b29b      	uxth	r3, r3
 800c45c:	4413      	add	r3, r2
 800c45e:	b29b      	uxth	r3, r3
 800c460:	b21b      	sxth	r3, r3
 800c462:	81fb      	strh	r3, [r7, #14]
            value_area.x2 += p_align.x + xofs;
 800c464:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800c468:	b29a      	uxth	r2, r3
 800c46a:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 800c46e:	b299      	uxth	r1, r3
 800c470:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800c472:	440b      	add	r3, r1
 800c474:	b29b      	uxth	r3, r3
 800c476:	4413      	add	r3, r2
 800c478:	b29b      	uxth	r3, r3
 800c47a:	b21b      	sxth	r3, r3
 800c47c:	823b      	strh	r3, [r7, #16]
            value_area.y2 += p_align.y + yofs;
 800c47e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800c482:	b29a      	uxth	r2, r3
 800c484:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 800c488:	b299      	uxth	r1, r3
 800c48a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800c48c:	440b      	add	r3, r1
 800c48e:	b29b      	uxth	r3, r3
 800c490:	4413      	add	r3, r2
 800c492:	b29b      	uxth	r3, r3
 800c494:	b21b      	sxth	r3, r3
 800c496:	827b      	strh	r3, [r7, #18]

            s = LV_MATH_MAX(s, obj->coords.x1 - value_area.x1);
 800c498:	687b      	ldr	r3, [r7, #4]
 800c49a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 800c49e:	461a      	mov	r2, r3
 800c4a0:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 800c4a4:	1ad2      	subs	r2, r2, r3
 800c4a6:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 800c4aa:	4293      	cmp	r3, r2
 800c4ac:	bfb8      	it	lt
 800c4ae:	4613      	movlt	r3, r2
 800c4b0:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            s = LV_MATH_MAX(s, obj->coords.y1 - value_area.y1);
 800c4b4:	687b      	ldr	r3, [r7, #4]
 800c4b6:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 800c4ba:	461a      	mov	r2, r3
 800c4bc:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800c4c0:	1ad2      	subs	r2, r2, r3
 800c4c2:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 800c4c6:	4293      	cmp	r3, r2
 800c4c8:	bfb8      	it	lt
 800c4ca:	4613      	movlt	r3, r2
 800c4cc:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            s = LV_MATH_MAX(s, value_area.x2 - obj->coords.x2);
 800c4d0:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 800c4d4:	461a      	mov	r2, r3
 800c4d6:	687b      	ldr	r3, [r7, #4]
 800c4d8:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 800c4dc:	1ad2      	subs	r2, r2, r3
 800c4de:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 800c4e2:	4293      	cmp	r3, r2
 800c4e4:	bfb8      	it	lt
 800c4e6:	4613      	movlt	r3, r2
 800c4e8:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            s = LV_MATH_MAX(s, value_area.y2 - obj->coords.y2);
 800c4ec:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800c4f0:	461a      	mov	r2, r3
 800c4f2:	687b      	ldr	r3, [r7, #4]
 800c4f4:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800c4f8:	1ad2      	subs	r2, r2, r3
 800c4fa:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 800c4fe:	4293      	cmp	r3, r2
 800c500:	bfb8      	it	lt
 800c502:	4613      	movlt	r3, r2
 800c504:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
        }
    }

    lv_style_int_t outline_width = lv_obj_get_style_outline_width(obj, part);
 800c508:	78fb      	ldrb	r3, [r7, #3]
 800c50a:	4619      	mov	r1, r3
 800c50c:	6878      	ldr	r0, [r7, #4]
 800c50e:	f7fc fb41 	bl	8008b94 <lv_obj_get_style_outline_width>
 800c512:	4603      	mov	r3, r0
 800c514:	84bb      	strh	r3, [r7, #36]	; 0x24
    if(outline_width) {
 800c516:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 800c51a:	2b00      	cmp	r3, #0
 800c51c:	d01e      	beq.n	800c55c <lv_obj_get_draw_rect_ext_pad_size+0x2dc>
        lv_opa_t outline_opa = lv_obj_get_style_outline_opa(obj, part);
 800c51e:	78fb      	ldrb	r3, [r7, #3]
 800c520:	4619      	mov	r1, r3
 800c522:	6878      	ldr	r0, [r7, #4]
 800c524:	f7fc fb7b 	bl	8008c1e <lv_obj_get_style_outline_opa>
 800c528:	4603      	mov	r3, r0
 800c52a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        if(outline_opa > LV_OPA_MIN) {
 800c52e:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800c532:	2b02      	cmp	r3, #2
 800c534:	d912      	bls.n	800c55c <lv_obj_get_draw_rect_ext_pad_size+0x2dc>
            lv_style_int_t outline_pad = lv_obj_get_style_outline_pad(obj, part);
 800c536:	78fb      	ldrb	r3, [r7, #3]
 800c538:	4619      	mov	r1, r3
 800c53a:	6878      	ldr	r0, [r7, #4]
 800c53c:	f7fc fb3b 	bl	8008bb6 <lv_obj_get_style_outline_pad>
 800c540:	4603      	mov	r3, r0
 800c542:	843b      	strh	r3, [r7, #32]
            s = LV_MATH_MAX(s, outline_pad + outline_width);
 800c544:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 800c548:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 800c54c:	441a      	add	r2, r3
 800c54e:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 800c552:	4293      	cmp	r3, r2
 800c554:	bfb8      	it	lt
 800c556:	4613      	movlt	r3, r2
 800c558:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
        }
    }

    lv_coord_t w = lv_obj_get_style_transform_width(obj, part);
 800c55c:	78fb      	ldrb	r3, [r7, #3]
 800c55e:	4619      	mov	r1, r3
 800c560:	6878      	ldr	r0, [r7, #4]
 800c562:	f7fc f997 	bl	8008894 <lv_obj_get_style_transform_width>
 800c566:	4603      	mov	r3, r0
 800c568:	83fb      	strh	r3, [r7, #30]
    lv_coord_t h = lv_obj_get_style_transform_height(obj, part);
 800c56a:	78fb      	ldrb	r3, [r7, #3]
 800c56c:	4619      	mov	r1, r3
 800c56e:	6878      	ldr	r0, [r7, #4]
 800c570:	f7fc f9a1 	bl	80088b6 <lv_obj_get_style_transform_height>
 800c574:	4603      	mov	r3, r0
 800c576:	83bb      	strh	r3, [r7, #28]
    lv_coord_t wh = LV_MATH_MAX(w, h);
 800c578:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 800c57c:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800c580:	4293      	cmp	r3, r2
 800c582:	bfb8      	it	lt
 800c584:	4613      	movlt	r3, r2
 800c586:	837b      	strh	r3, [r7, #26]
    if(wh > 0) s += wh;
 800c588:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800c58c:	2b00      	cmp	r3, #0
 800c58e:	dd06      	ble.n	800c59e <lv_obj_get_draw_rect_ext_pad_size+0x31e>
 800c590:	f8b7 2046 	ldrh.w	r2, [r7, #70]	; 0x46
 800c594:	8b7b      	ldrh	r3, [r7, #26]
 800c596:	4413      	add	r3, r2
 800c598:	b29b      	uxth	r3, r3
 800c59a:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46

    return s;
 800c59e:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
}
 800c5a2:	4618      	mov	r0, r3
 800c5a4:	3748      	adds	r7, #72	; 0x48
 800c5a6:	46bd      	mov	sp, r7
 800c5a8:	bd80      	pop	{r7, pc}

0800c5aa <obj_del_core>:

    lv_obj_del(obj);
}

static void obj_del_core(lv_obj_t * obj)
{
 800c5aa:	b580      	push	{r7, lr}
 800c5ac:	b088      	sub	sp, #32
 800c5ae:	af00      	add	r7, sp, #0
 800c5b0:	6078      	str	r0, [r7, #4]
    /*Let the user free the resources used in `LV_EVENT_DELETE`*/
    lv_event_send(obj, LV_EVENT_DELETE, NULL);
 800c5b2:	2200      	movs	r2, #0
 800c5b4:	2115      	movs	r1, #21
 800c5b6:	6878      	ldr	r0, [r7, #4]
 800c5b8:	f7fe f9c6 	bl	800a948 <lv_event_send>

    /*Delete from the group*/
#if LV_USE_GROUP
    lv_group_t * group = lv_obj_get_group(obj);
 800c5bc:	6878      	ldr	r0, [r7, #4]
 800c5be:	f7ff fa67 	bl	800ba90 <lv_obj_get_group>
 800c5c2:	6178      	str	r0, [r7, #20]
    if(group) lv_group_remove_obj(obj);
 800c5c4:	697b      	ldr	r3, [r7, #20]
 800c5c6:	2b00      	cmp	r3, #0
 800c5c8:	d002      	beq.n	800c5d0 <obj_del_core+0x26>
 800c5ca:	6878      	ldr	r0, [r7, #4]
 800c5cc:	f7fb fd26 	bl	800801c <lv_group_remove_obj>
#endif

    /*Remove the animations from this object*/
#if LV_USE_ANIMATION
    lv_anim_del(obj, NULL);
 800c5d0:	2100      	movs	r1, #0
 800c5d2:	6878      	ldr	r0, [r7, #4]
 800c5d4:	f012 fc9c 	bl	801ef10 <lv_anim_del>
    trans_del(obj, 0xFF, 0xFF, NULL);
 800c5d8:	2300      	movs	r3, #0
 800c5da:	22ff      	movs	r2, #255	; 0xff
 800c5dc:	21ff      	movs	r1, #255	; 0xff
 800c5de:	6878      	ldr	r0, [r7, #4]
 800c5e0:	f001 f846 	bl	800d670 <trans_del>
#endif

    /*Recursively delete the children*/
    lv_obj_t * i;
    lv_obj_t * i_next;
    i = _lv_ll_get_head(&(obj->child_ll));
 800c5e4:	687b      	ldr	r3, [r7, #4]
 800c5e6:	3304      	adds	r3, #4
 800c5e8:	4618      	mov	r0, r3
 800c5ea:	f014 f937 	bl	802085c <_lv_ll_get_head>
 800c5ee:	61f8      	str	r0, [r7, #28]
    while(i != NULL) {
 800c5f0:	e00b      	b.n	800c60a <obj_del_core+0x60>
        /*Get the next object before delete this*/
        i_next = _lv_ll_get_next(&(obj->child_ll), i);
 800c5f2:	687b      	ldr	r3, [r7, #4]
 800c5f4:	3304      	adds	r3, #4
 800c5f6:	69f9      	ldr	r1, [r7, #28]
 800c5f8:	4618      	mov	r0, r3
 800c5fa:	f014 f955 	bl	80208a8 <_lv_ll_get_next>
 800c5fe:	60b8      	str	r0, [r7, #8]

        /*Call the recursive del to the child too*/
        obj_del_core(i);
 800c600:	69f8      	ldr	r0, [r7, #28]
 800c602:	f7ff ffd2 	bl	800c5aa <obj_del_core>

        /*Set i to the next node*/
        i = i_next;
 800c606:	68bb      	ldr	r3, [r7, #8]
 800c608:	61fb      	str	r3, [r7, #28]
    while(i != NULL) {
 800c60a:	69fb      	ldr	r3, [r7, #28]
 800c60c:	2b00      	cmp	r3, #0
 800c60e:	d1f0      	bne.n	800c5f2 <obj_del_core+0x48>
    }

    lv_event_mark_deleted(obj);
 800c610:	6878      	ldr	r0, [r7, #4]
 800c612:	f001 f9f1 	bl	800d9f8 <lv_event_mark_deleted>

    /* Reset all input devices if the object to delete is used*/
    lv_indev_t * indev = lv_indev_get_next(NULL);
 800c616:	2000      	movs	r0, #0
 800c618:	f012 fb3c 	bl	801ec94 <lv_indev_get_next>
 800c61c:	61b8      	str	r0, [r7, #24]
    while(indev) {
 800c61e:	e028      	b.n	800c672 <obj_del_core+0xc8>
        if(indev->proc.types.pointer.act_obj == obj || indev->proc.types.pointer.last_obj == obj) {
 800c620:	69bb      	ldr	r3, [r7, #24]
 800c622:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800c624:	687a      	ldr	r2, [r7, #4]
 800c626:	429a      	cmp	r2, r3
 800c628:	d004      	beq.n	800c634 <obj_del_core+0x8a>
 800c62a:	69bb      	ldr	r3, [r7, #24]
 800c62c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c62e:	687a      	ldr	r2, [r7, #4]
 800c630:	429a      	cmp	r2, r3
 800c632:	d103      	bne.n	800c63c <obj_del_core+0x92>
            lv_indev_reset(indev, obj);
 800c634:	6879      	ldr	r1, [r7, #4]
 800c636:	69b8      	ldr	r0, [r7, #24]
 800c638:	f7fb fee4 	bl	8008404 <lv_indev_reset>
        }
        if(indev->proc.types.pointer.last_pressed == obj) {
 800c63c:	69bb      	ldr	r3, [r7, #24]
 800c63e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800c640:	687a      	ldr	r2, [r7, #4]
 800c642:	429a      	cmp	r2, r3
 800c644:	d102      	bne.n	800c64c <obj_del_core+0xa2>
            indev->proc.types.pointer.last_pressed = NULL;
 800c646:	69bb      	ldr	r3, [r7, #24]
 800c648:	2200      	movs	r2, #0
 800c64a:	63da      	str	r2, [r3, #60]	; 0x3c
        }

#if LV_USE_GROUP
        if(indev->group == group && obj == lv_indev_get_obj_act()) {
 800c64c:	69bb      	ldr	r3, [r7, #24]
 800c64e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800c650:	697a      	ldr	r2, [r7, #20]
 800c652:	429a      	cmp	r2, r3
 800c654:	d109      	bne.n	800c66a <obj_del_core+0xc0>
 800c656:	f7fb ff27 	bl	80084a8 <lv_indev_get_obj_act>
 800c65a:	4602      	mov	r2, r0
 800c65c:	687b      	ldr	r3, [r7, #4]
 800c65e:	4293      	cmp	r3, r2
 800c660:	d103      	bne.n	800c66a <obj_del_core+0xc0>
            lv_indev_reset(indev, obj);
 800c662:	6879      	ldr	r1, [r7, #4]
 800c664:	69b8      	ldr	r0, [r7, #24]
 800c666:	f7fb fecd 	bl	8008404 <lv_indev_reset>
        }
#endif
        indev = lv_indev_get_next(indev);
 800c66a:	69b8      	ldr	r0, [r7, #24]
 800c66c:	f012 fb12 	bl	801ec94 <lv_indev_get_next>
 800c670:	61b8      	str	r0, [r7, #24]
    while(indev) {
 800c672:	69bb      	ldr	r3, [r7, #24]
 800c674:	2b00      	cmp	r3, #0
 800c676:	d1d3      	bne.n	800c620 <obj_del_core+0x76>
    }

    /* All children deleted.
     * Now clean up the object specific data*/
    obj->signal_cb(obj, LV_SIGNAL_CLEANUP, NULL);
 800c678:	687b      	ldr	r3, [r7, #4]
 800c67a:	69db      	ldr	r3, [r3, #28]
 800c67c:	2200      	movs	r2, #0
 800c67e:	2100      	movs	r1, #0
 800c680:	6878      	ldr	r0, [r7, #4]
 800c682:	4798      	blx	r3

    /*Remove the object from parent's children list*/
    lv_obj_t * par = lv_obj_get_parent(obj);
 800c684:	6878      	ldr	r0, [r7, #4]
 800c686:	f7fe fb47 	bl	800ad18 <lv_obj_get_parent>
 800c68a:	6138      	str	r0, [r7, #16]
    if(par == NULL) { /*It is a screen*/
 800c68c:	693b      	ldr	r3, [r7, #16]
 800c68e:	2b00      	cmp	r3, #0
 800c690:	d10a      	bne.n	800c6a8 <obj_del_core+0xfe>
        lv_disp_t * d = lv_obj_get_disp(obj);
 800c692:	6878      	ldr	r0, [r7, #4]
 800c694:	f7fe faf0 	bl	800ac78 <lv_obj_get_disp>
 800c698:	60f8      	str	r0, [r7, #12]
        _lv_ll_remove(&d->scr_ll, obj);
 800c69a:	68fb      	ldr	r3, [r7, #12]
 800c69c:	3330      	adds	r3, #48	; 0x30
 800c69e:	6879      	ldr	r1, [r7, #4]
 800c6a0:	4618      	mov	r0, r3
 800c6a2:	f014 f82d 	bl	8020700 <_lv_ll_remove>
 800c6a6:	e005      	b.n	800c6b4 <obj_del_core+0x10a>
    }
    else {
        _lv_ll_remove(&(par->child_ll), obj);
 800c6a8:	693b      	ldr	r3, [r7, #16]
 800c6aa:	3304      	adds	r3, #4
 800c6ac:	6879      	ldr	r1, [r7, #4]
 800c6ae:	4618      	mov	r0, r3
 800c6b0:	f014 f826 	bl	8020700 <_lv_ll_remove>
    }

    /*Delete the base objects*/
    if(obj->ext_attr != NULL) lv_mem_free(obj->ext_attr);
 800c6b4:	687b      	ldr	r3, [r7, #4]
 800c6b6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c6b8:	2b00      	cmp	r3, #0
 800c6ba:	d004      	beq.n	800c6c6 <obj_del_core+0x11c>
 800c6bc:	687b      	ldr	r3, [r7, #4]
 800c6be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c6c0:	4618      	mov	r0, r3
 800c6c2:	f014 fad1 	bl	8020c68 <lv_mem_free>
    lv_mem_free(obj); /*Free the object itself*/
 800c6c6:	6878      	ldr	r0, [r7, #4]
 800c6c8:	f014 face 	bl	8020c68 <lv_mem_free>
}
 800c6cc:	bf00      	nop
 800c6ce:	3720      	adds	r7, #32
 800c6d0:	46bd      	mov	sp, r7
 800c6d2:	bd80      	pop	{r7, pc}

0800c6d4 <lv_obj_design>:
 *                                  (return 'true' if yes)
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 * @param return an element of `lv_design_res_t`
 */
static lv_design_res_t lv_obj_design(lv_obj_t * obj, const lv_area_t * clip_area, lv_design_mode_t mode)
{
 800c6d4:	b580      	push	{r7, lr}
 800c6d6:	b0a6      	sub	sp, #152	; 0x98
 800c6d8:	af00      	add	r7, sp, #0
 800c6da:	60f8      	str	r0, [r7, #12]
 800c6dc:	60b9      	str	r1, [r7, #8]
 800c6de:	4613      	mov	r3, r2
 800c6e0:	71fb      	strb	r3, [r7, #7]
    if(mode == LV_DESIGN_COVER_CHK) {
 800c6e2:	79fb      	ldrb	r3, [r7, #7]
 800c6e4:	2b02      	cmp	r3, #2
 800c6e6:	f040 8085 	bne.w	800c7f4 <lv_obj_design+0x120>
        if(lv_obj_get_style_clip_corner(obj, LV_OBJ_PART_MAIN)) return LV_DESIGN_RES_MASKED;
 800c6ea:	2100      	movs	r1, #0
 800c6ec:	68f8      	ldr	r0, [r7, #12]
 800c6ee:	f7fc f8bb 	bl	8008868 <lv_obj_get_style_clip_corner>
 800c6f2:	4603      	mov	r3, r0
 800c6f4:	2b00      	cmp	r3, #0
 800c6f6:	d001      	beq.n	800c6fc <lv_obj_design+0x28>
 800c6f8:	2303      	movs	r3, #3
 800c6fa:	e183      	b.n	800ca04 <lv_obj_design+0x330>

        /*Most trivial test. Is the mask fully IN the object? If no it surely doesn't cover it*/
        lv_coord_t r = lv_obj_get_style_radius(obj, LV_OBJ_PART_MAIN);
 800c6fc:	2100      	movs	r1, #0
 800c6fe:	68f8      	ldr	r0, [r7, #12]
 800c700:	f7fc f8a1 	bl	8008846 <lv_obj_get_style_radius>
 800c704:	4603      	mov	r3, r0
 800c706:	f8a7 3084 	strh.w	r3, [r7, #132]	; 0x84
        lv_coord_t w = lv_obj_get_style_transform_width(obj, LV_OBJ_PART_MAIN);
 800c70a:	2100      	movs	r1, #0
 800c70c:	68f8      	ldr	r0, [r7, #12]
 800c70e:	f7fc f8c1 	bl	8008894 <lv_obj_get_style_transform_width>
 800c712:	4603      	mov	r3, r0
 800c714:	f8a7 3082 	strh.w	r3, [r7, #130]	; 0x82
        lv_coord_t h = lv_obj_get_style_transform_height(obj, LV_OBJ_PART_MAIN);
 800c718:	2100      	movs	r1, #0
 800c71a:	68f8      	ldr	r0, [r7, #12]
 800c71c:	f7fc f8cb 	bl	80088b6 <lv_obj_get_style_transform_height>
 800c720:	4603      	mov	r3, r0
 800c722:	f8a7 3080 	strh.w	r3, [r7, #128]	; 0x80
        lv_area_t coords;
        lv_area_copy(&coords, &obj->coords);
 800c726:	68fb      	ldr	r3, [r7, #12]
 800c728:	f103 0210 	add.w	r2, r3, #16
 800c72c:	f107 0378 	add.w	r3, r7, #120	; 0x78
 800c730:	4611      	mov	r1, r2
 800c732:	4618      	mov	r0, r3
 800c734:	f7fb fee6 	bl	8008504 <lv_area_copy>
        coords.x1 -= w;
 800c738:	f9b7 3078 	ldrsh.w	r3, [r7, #120]	; 0x78
 800c73c:	b29a      	uxth	r2, r3
 800c73e:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 800c742:	1ad3      	subs	r3, r2, r3
 800c744:	b29b      	uxth	r3, r3
 800c746:	b21b      	sxth	r3, r3
 800c748:	f8a7 3078 	strh.w	r3, [r7, #120]	; 0x78
        coords.x2 += w;
 800c74c:	f9b7 307c 	ldrsh.w	r3, [r7, #124]	; 0x7c
 800c750:	b29a      	uxth	r2, r3
 800c752:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 800c756:	4413      	add	r3, r2
 800c758:	b29b      	uxth	r3, r3
 800c75a:	b21b      	sxth	r3, r3
 800c75c:	f8a7 307c 	strh.w	r3, [r7, #124]	; 0x7c
        coords.y1 -= h;
 800c760:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 800c764:	b29a      	uxth	r2, r3
 800c766:	f8b7 3080 	ldrh.w	r3, [r7, #128]	; 0x80
 800c76a:	1ad3      	subs	r3, r2, r3
 800c76c:	b29b      	uxth	r3, r3
 800c76e:	b21b      	sxth	r3, r3
 800c770:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a
        coords.y2 += h;
 800c774:	f9b7 307e 	ldrsh.w	r3, [r7, #126]	; 0x7e
 800c778:	b29a      	uxth	r2, r3
 800c77a:	f8b7 3080 	ldrh.w	r3, [r7, #128]	; 0x80
 800c77e:	4413      	add	r3, r2
 800c780:	b29b      	uxth	r3, r3
 800c782:	b21b      	sxth	r3, r3
 800c784:	f8a7 307e 	strh.w	r3, [r7, #126]	; 0x7e

        if(_lv_area_is_in(clip_area, &coords, r) == false) return LV_DESIGN_RES_NOT_COVER;
 800c788:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 800c78c:	f107 0378 	add.w	r3, r7, #120	; 0x78
 800c790:	4619      	mov	r1, r3
 800c792:	68b8      	ldr	r0, [r7, #8]
 800c794:	f013 f84c 	bl	801f830 <_lv_area_is_in>
 800c798:	4603      	mov	r3, r0
 800c79a:	f083 0301 	eor.w	r3, r3, #1
 800c79e:	b2db      	uxtb	r3, r3
 800c7a0:	2b00      	cmp	r3, #0
 800c7a2:	d001      	beq.n	800c7a8 <lv_obj_design+0xd4>
 800c7a4:	2302      	movs	r3, #2
 800c7a6:	e12d      	b.n	800ca04 <lv_obj_design+0x330>

        if(lv_obj_get_style_bg_opa(obj, LV_OBJ_PART_MAIN) < LV_OPA_MAX) return LV_DESIGN_RES_NOT_COVER;
 800c7a8:	2100      	movs	r1, #0
 800c7aa:	68f8      	ldr	r0, [r7, #12]
 800c7ac:	f7fc f974 	bl	8008a98 <lv_obj_get_style_bg_opa>
 800c7b0:	4603      	mov	r3, r0
 800c7b2:	2bfc      	cmp	r3, #252	; 0xfc
 800c7b4:	d801      	bhi.n	800c7ba <lv_obj_design+0xe6>
 800c7b6:	2302      	movs	r3, #2
 800c7b8:	e124      	b.n	800ca04 <lv_obj_design+0x330>

        if(lv_obj_get_style_bg_blend_mode(obj, LV_OBJ_PART_MAIN) != LV_BLEND_MODE_NORMAL) return LV_DESIGN_RES_NOT_COVER;
 800c7ba:	2100      	movs	r1, #0
 800c7bc:	68f8      	ldr	r0, [r7, #12]
 800c7be:	f7fc f903 	bl	80089c8 <lv_obj_get_style_bg_blend_mode>
 800c7c2:	4603      	mov	r3, r0
 800c7c4:	2b00      	cmp	r3, #0
 800c7c6:	d001      	beq.n	800c7cc <lv_obj_design+0xf8>
 800c7c8:	2302      	movs	r3, #2
 800c7ca:	e11b      	b.n	800ca04 <lv_obj_design+0x330>
        if(lv_obj_get_style_border_blend_mode(obj, LV_OBJ_PART_MAIN) != LV_BLEND_MODE_NORMAL) return LV_DESIGN_RES_NOT_COVER;
 800c7cc:	2100      	movs	r1, #0
 800c7ce:	68f8      	ldr	r0, [r7, #12]
 800c7d0:	f7fc f996 	bl	8008b00 <lv_obj_get_style_border_blend_mode>
 800c7d4:	4603      	mov	r3, r0
 800c7d6:	2b00      	cmp	r3, #0
 800c7d8:	d001      	beq.n	800c7de <lv_obj_design+0x10a>
 800c7da:	2302      	movs	r3, #2
 800c7dc:	e112      	b.n	800ca04 <lv_obj_design+0x330>
        if(lv_obj_get_style_opa_scale(obj, LV_OBJ_PART_MAIN) < LV_OPA_MAX) return LV_DESIGN_RES_NOT_COVER;
 800c7de:	2100      	movs	r1, #0
 800c7e0:	68f8      	ldr	r0, [r7, #12]
 800c7e2:	f7fc f89b 	bl	800891c <lv_obj_get_style_opa_scale>
 800c7e6:	4603      	mov	r3, r0
 800c7e8:	2bfc      	cmp	r3, #252	; 0xfc
 800c7ea:	d801      	bhi.n	800c7f0 <lv_obj_design+0x11c>
 800c7ec:	2302      	movs	r3, #2
 800c7ee:	e109      	b.n	800ca04 <lv_obj_design+0x330>

        return  LV_DESIGN_RES_COVER;
 800c7f0:	2301      	movs	r3, #1
 800c7f2:	e107      	b.n	800ca04 <lv_obj_design+0x330>

    }
    else if(mode == LV_DESIGN_DRAW_MAIN) {
 800c7f4:	79fb      	ldrb	r3, [r7, #7]
 800c7f6:	2b00      	cmp	r3, #0
 800c7f8:	f040 8087 	bne.w	800c90a <lv_obj_design+0x236>
        lv_draw_rect_dsc_t draw_dsc;
        lv_draw_rect_dsc_init(&draw_dsc);
 800c7fc:	f107 0314 	add.w	r3, r7, #20
 800c800:	4618      	mov	r0, r3
 800c802:	f00a ffff 	bl	8017804 <lv_draw_rect_dsc_init>
        /*If the border is drawn later disable loading its properties*/
        if(lv_obj_get_style_border_post(obj, LV_OBJ_PART_MAIN)) {
 800c806:	2100      	movs	r1, #0
 800c808:	68f8      	ldr	r0, [r7, #12]
 800c80a:	f7fc f98b 	bl	8008b24 <lv_obj_get_style_border_post>
 800c80e:	4603      	mov	r3, r0
 800c810:	2b00      	cmp	r3, #0
 800c812:	d005      	beq.n	800c820 <lv_obj_design+0x14c>
            draw_dsc.border_post = 1;
 800c814:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 800c818:	f043 0301 	orr.w	r3, r3, #1
 800c81c:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
        }

        lv_obj_init_draw_rect_dsc(obj, LV_OBJ_PART_MAIN, &draw_dsc);
 800c820:	f107 0314 	add.w	r3, r7, #20
 800c824:	461a      	mov	r2, r3
 800c826:	2100      	movs	r1, #0
 800c828:	68f8      	ldr	r0, [r7, #12]
 800c82a:	f7ff f9ea 	bl	800bc02 <lv_obj_init_draw_rect_dsc>

        lv_coord_t w = lv_obj_get_style_transform_width(obj, LV_OBJ_PART_MAIN);
 800c82e:	2100      	movs	r1, #0
 800c830:	68f8      	ldr	r0, [r7, #12]
 800c832:	f7fc f82f 	bl	8008894 <lv_obj_get_style_transform_width>
 800c836:	4603      	mov	r3, r0
 800c838:	f8a7 308e 	strh.w	r3, [r7, #142]	; 0x8e
        lv_coord_t h = lv_obj_get_style_transform_height(obj, LV_OBJ_PART_MAIN);
 800c83c:	2100      	movs	r1, #0
 800c83e:	68f8      	ldr	r0, [r7, #12]
 800c840:	f7fc f839 	bl	80088b6 <lv_obj_get_style_transform_height>
 800c844:	4603      	mov	r3, r0
 800c846:	f8a7 308c 	strh.w	r3, [r7, #140]	; 0x8c
        lv_area_t coords;
        lv_area_copy(&coords, &obj->coords);
 800c84a:	68fb      	ldr	r3, [r7, #12]
 800c84c:	f103 0210 	add.w	r2, r3, #16
 800c850:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800c854:	4611      	mov	r1, r2
 800c856:	4618      	mov	r0, r3
 800c858:	f7fb fe54 	bl	8008504 <lv_area_copy>
        coords.x1 -= w;
 800c85c:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 800c860:	b29a      	uxth	r2, r3
 800c862:	f8b7 308e 	ldrh.w	r3, [r7, #142]	; 0x8e
 800c866:	1ad3      	subs	r3, r2, r3
 800c868:	b29b      	uxth	r3, r3
 800c86a:	b21b      	sxth	r3, r3
 800c86c:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
        coords.x2 += w;
 800c870:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 800c874:	b29a      	uxth	r2, r3
 800c876:	f8b7 308e 	ldrh.w	r3, [r7, #142]	; 0x8e
 800c87a:	4413      	add	r3, r2
 800c87c:	b29b      	uxth	r3, r3
 800c87e:	b21b      	sxth	r3, r3
 800c880:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
        coords.y1 -= h;
 800c884:	f9b7 3072 	ldrsh.w	r3, [r7, #114]	; 0x72
 800c888:	b29a      	uxth	r2, r3
 800c88a:	f8b7 308c 	ldrh.w	r3, [r7, #140]	; 0x8c
 800c88e:	1ad3      	subs	r3, r2, r3
 800c890:	b29b      	uxth	r3, r3
 800c892:	b21b      	sxth	r3, r3
 800c894:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
        coords.y2 += h;
 800c898:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 800c89c:	b29a      	uxth	r2, r3
 800c89e:	f8b7 308c 	ldrh.w	r3, [r7, #140]	; 0x8c
 800c8a2:	4413      	add	r3, r2
 800c8a4:	b29b      	uxth	r3, r3
 800c8a6:	b21b      	sxth	r3, r3
 800c8a8:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

        lv_draw_rect(&coords, clip_area, &draw_dsc);
 800c8ac:	f107 0214 	add.w	r2, r7, #20
 800c8b0:	f107 0370 	add.w	r3, r7, #112	; 0x70
 800c8b4:	68b9      	ldr	r1, [r7, #8]
 800c8b6:	4618      	mov	r0, r3
 800c8b8:	f00b f832 	bl	8017920 <lv_draw_rect>

        if(lv_obj_get_style_clip_corner(obj, LV_OBJ_PART_MAIN)) {
 800c8bc:	2100      	movs	r1, #0
 800c8be:	68f8      	ldr	r0, [r7, #12]
 800c8c0:	f7fb ffd2 	bl	8008868 <lv_obj_get_style_clip_corner>
 800c8c4:	4603      	mov	r3, r0
 800c8c6:	2b00      	cmp	r3, #0
 800c8c8:	f000 809b 	beq.w	800ca02 <lv_obj_design+0x32e>
            lv_draw_mask_radius_param_t * mp = _lv_mem_buf_get(sizeof(lv_draw_mask_radius_param_t));
 800c8cc:	201c      	movs	r0, #28
 800c8ce:	f014 fadf 	bl	8020e90 <_lv_mem_buf_get>
 800c8d2:	f8c7 0088 	str.w	r0, [r7, #136]	; 0x88

            lv_coord_t r = lv_obj_get_style_radius(obj, LV_OBJ_PART_MAIN);
 800c8d6:	2100      	movs	r1, #0
 800c8d8:	68f8      	ldr	r0, [r7, #12]
 800c8da:	f7fb ffb4 	bl	8008846 <lv_obj_get_style_radius>
 800c8de:	4603      	mov	r3, r0
 800c8e0:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86

            lv_draw_mask_radius_init(mp, &obj->coords, r, false);
 800c8e4:	68fb      	ldr	r3, [r7, #12]
 800c8e6:	f103 0110 	add.w	r1, r3, #16
 800c8ea:	f9b7 2086 	ldrsh.w	r2, [r7, #134]	; 0x86
 800c8ee:	2300      	movs	r3, #0
 800c8f0:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
 800c8f4:	f009 fd46 	bl	8016384 <lv_draw_mask_radius_init>
            /*Add the mask and use `obj+8` as custom id. Don't use `obj` directly because it might be used by the user*/
            lv_draw_mask_add(mp, obj + 8);
 800c8f8:	68fb      	ldr	r3, [r7, #12]
 800c8fa:	f503 7318 	add.w	r3, r3, #608	; 0x260
 800c8fe:	4619      	mov	r1, r3
 800c900:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
 800c904:	f009 fb24 	bl	8015f50 <lv_draw_mask_add>
 800c908:	e07b      	b.n	800ca02 <lv_obj_design+0x32e>
        }
    }
    else if(mode == LV_DESIGN_DRAW_POST) {
 800c90a:	79fb      	ldrb	r3, [r7, #7]
 800c90c:	2b01      	cmp	r3, #1
 800c90e:	d178      	bne.n	800ca02 <lv_obj_design+0x32e>
        if(lv_obj_get_style_clip_corner(obj, LV_OBJ_PART_MAIN)) {
 800c910:	2100      	movs	r1, #0
 800c912:	68f8      	ldr	r0, [r7, #12]
 800c914:	f7fb ffa8 	bl	8008868 <lv_obj_get_style_clip_corner>
 800c918:	4603      	mov	r3, r0
 800c91a:	2b00      	cmp	r3, #0
 800c91c:	d00b      	beq.n	800c936 <lv_obj_design+0x262>
            lv_draw_mask_radius_param_t * param = lv_draw_mask_remove_custom(obj + 8);
 800c91e:	68fb      	ldr	r3, [r7, #12]
 800c920:	f503 7318 	add.w	r3, r3, #608	; 0x260
 800c924:	4618      	mov	r0, r3
 800c926:	f009 fbb1 	bl	801608c <lv_draw_mask_remove_custom>
 800c92a:	f8c7 0094 	str.w	r0, [r7, #148]	; 0x94
            _lv_mem_buf_release(param);
 800c92e:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
 800c932:	f014 fb8d 	bl	8021050 <_lv_mem_buf_release>
        }

        /*If the border is drawn later disable loading other properties*/
        if(lv_obj_get_style_border_post(obj, LV_OBJ_PART_MAIN)) {
 800c936:	2100      	movs	r1, #0
 800c938:	68f8      	ldr	r0, [r7, #12]
 800c93a:	f7fc f8f3 	bl	8008b24 <lv_obj_get_style_border_post>
 800c93e:	4603      	mov	r3, r0
 800c940:	2b00      	cmp	r3, #0
 800c942:	d05e      	beq.n	800ca02 <lv_obj_design+0x32e>
            lv_draw_rect_dsc_t draw_dsc;
            lv_draw_rect_dsc_init(&draw_dsc);
 800c944:	f107 0314 	add.w	r3, r7, #20
 800c948:	4618      	mov	r0, r3
 800c94a:	f00a ff5b 	bl	8017804 <lv_draw_rect_dsc_init>
            draw_dsc.bg_opa = LV_OPA_TRANSP;
 800c94e:	2300      	movs	r3, #0
 800c950:	f887 3020 	strb.w	r3, [r7, #32]
            draw_dsc.pattern_opa = LV_OPA_TRANSP;
 800c954:	2300      	movs	r3, #0
 800c956:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a
            draw_dsc.shadow_opa = LV_OPA_TRANSP;
 800c95a:	2300      	movs	r3, #0
 800c95c:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
            draw_dsc.value_opa = LV_OPA_TRANSP;
 800c960:	2300      	movs	r3, #0
 800c962:	f887 3058 	strb.w	r3, [r7, #88]	; 0x58
            lv_obj_init_draw_rect_dsc(obj, LV_OBJ_PART_MAIN, &draw_dsc);
 800c966:	f107 0314 	add.w	r3, r7, #20
 800c96a:	461a      	mov	r2, r3
 800c96c:	2100      	movs	r1, #0
 800c96e:	68f8      	ldr	r0, [r7, #12]
 800c970:	f7ff f947 	bl	800bc02 <lv_obj_init_draw_rect_dsc>

            lv_coord_t w = lv_obj_get_style_transform_width(obj, LV_OBJ_PART_MAIN);
 800c974:	2100      	movs	r1, #0
 800c976:	68f8      	ldr	r0, [r7, #12]
 800c978:	f7fb ff8c 	bl	8008894 <lv_obj_get_style_transform_width>
 800c97c:	4603      	mov	r3, r0
 800c97e:	f8a7 3092 	strh.w	r3, [r7, #146]	; 0x92
            lv_coord_t h = lv_obj_get_style_transform_height(obj, LV_OBJ_PART_MAIN);
 800c982:	2100      	movs	r1, #0
 800c984:	68f8      	ldr	r0, [r7, #12]
 800c986:	f7fb ff96 	bl	80088b6 <lv_obj_get_style_transform_height>
 800c98a:	4603      	mov	r3, r0
 800c98c:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
            lv_area_t coords;
            lv_area_copy(&coords, &obj->coords);
 800c990:	68fb      	ldr	r3, [r7, #12]
 800c992:	f103 0210 	add.w	r2, r3, #16
 800c996:	f107 0368 	add.w	r3, r7, #104	; 0x68
 800c99a:	4611      	mov	r1, r2
 800c99c:	4618      	mov	r0, r3
 800c99e:	f7fb fdb1 	bl	8008504 <lv_area_copy>
            coords.x1 -= w;
 800c9a2:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 800c9a6:	b29a      	uxth	r2, r3
 800c9a8:	f8b7 3092 	ldrh.w	r3, [r7, #146]	; 0x92
 800c9ac:	1ad3      	subs	r3, r2, r3
 800c9ae:	b29b      	uxth	r3, r3
 800c9b0:	b21b      	sxth	r3, r3
 800c9b2:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
            coords.x2 += w;
 800c9b6:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 800c9ba:	b29a      	uxth	r2, r3
 800c9bc:	f8b7 3092 	ldrh.w	r3, [r7, #146]	; 0x92
 800c9c0:	4413      	add	r3, r2
 800c9c2:	b29b      	uxth	r3, r3
 800c9c4:	b21b      	sxth	r3, r3
 800c9c6:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
            coords.y1 -= h;
 800c9ca:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 800c9ce:	b29a      	uxth	r2, r3
 800c9d0:	f8b7 3090 	ldrh.w	r3, [r7, #144]	; 0x90
 800c9d4:	1ad3      	subs	r3, r2, r3
 800c9d6:	b29b      	uxth	r3, r3
 800c9d8:	b21b      	sxth	r3, r3
 800c9da:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
            coords.y2 += h;
 800c9de:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 800c9e2:	b29a      	uxth	r2, r3
 800c9e4:	f8b7 3090 	ldrh.w	r3, [r7, #144]	; 0x90
 800c9e8:	4413      	add	r3, r2
 800c9ea:	b29b      	uxth	r3, r3
 800c9ec:	b21b      	sxth	r3, r3
 800c9ee:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
            lv_draw_rect(&coords, clip_area, &draw_dsc);
 800c9f2:	f107 0214 	add.w	r2, r7, #20
 800c9f6:	f107 0368 	add.w	r3, r7, #104	; 0x68
 800c9fa:	68b9      	ldr	r1, [r7, #8]
 800c9fc:	4618      	mov	r0, r3
 800c9fe:	f00a ff8f 	bl	8017920 <lv_draw_rect>
        }
    }

    return LV_DESIGN_RES_OK;
 800ca02:	2300      	movs	r3, #0
}
 800ca04:	4618      	mov	r0, r3
 800ca06:	3798      	adds	r7, #152	; 0x98
 800ca08:	46bd      	mov	sp, r7
 800ca0a:	bd80      	pop	{r7, pc}

0800ca0c <lv_obj_get_focused_obj>:
 * Get the really focused object by taking `focus_parent` into account.
 * @param obj the start object
 * @return the object to really focus
 */
lv_obj_t * lv_obj_get_focused_obj(const lv_obj_t * obj)
{
 800ca0c:	b580      	push	{r7, lr}
 800ca0e:	b084      	sub	sp, #16
 800ca10:	af00      	add	r7, sp, #0
 800ca12:	6078      	str	r0, [r7, #4]
    if(obj == NULL) return NULL;
 800ca14:	687b      	ldr	r3, [r7, #4]
 800ca16:	2b00      	cmp	r3, #0
 800ca18:	d101      	bne.n	800ca1e <lv_obj_get_focused_obj+0x12>
 800ca1a:	2300      	movs	r3, #0
 800ca1c:	e010      	b.n	800ca40 <lv_obj_get_focused_obj+0x34>
    const lv_obj_t * focus_obj = obj;
 800ca1e:	687b      	ldr	r3, [r7, #4]
 800ca20:	60fb      	str	r3, [r7, #12]
    while(lv_obj_get_focus_parent(focus_obj) != false && focus_obj != NULL) {
 800ca22:	e003      	b.n	800ca2c <lv_obj_get_focused_obj+0x20>
        focus_obj = lv_obj_get_parent(focus_obj);
 800ca24:	68f8      	ldr	r0, [r7, #12]
 800ca26:	f7fe f977 	bl	800ad18 <lv_obj_get_parent>
 800ca2a:	60f8      	str	r0, [r7, #12]
    while(lv_obj_get_focus_parent(focus_obj) != false && focus_obj != NULL) {
 800ca2c:	68f8      	ldr	r0, [r7, #12]
 800ca2e:	f7fe ff3f 	bl	800b8b0 <lv_obj_get_focus_parent>
 800ca32:	4603      	mov	r3, r0
 800ca34:	2b00      	cmp	r3, #0
 800ca36:	d002      	beq.n	800ca3e <lv_obj_get_focused_obj+0x32>
 800ca38:	68fb      	ldr	r3, [r7, #12]
 800ca3a:	2b00      	cmp	r3, #0
 800ca3c:	d1f2      	bne.n	800ca24 <lv_obj_get_focused_obj+0x18>
    }

    return (lv_obj_t *)focus_obj;
 800ca3e:	68fb      	ldr	r3, [r7, #12]
}
 800ca40:	4618      	mov	r0, r3
 800ca42:	3710      	adds	r7, #16
 800ca44:	46bd      	mov	sp, r7
 800ca46:	bd80      	pop	{r7, pc}

0800ca48 <lv_obj_signal>:
 * @param sign signal type
 * @param param parameter for the signal (depends on signal type)
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_obj_signal(lv_obj_t * obj, lv_signal_t sign, void * param)
{
 800ca48:	b580      	push	{r7, lr}
 800ca4a:	b088      	sub	sp, #32
 800ca4c:	af00      	add	r7, sp, #0
 800ca4e:	60f8      	str	r0, [r7, #12]
 800ca50:	460b      	mov	r3, r1
 800ca52:	607a      	str	r2, [r7, #4]
 800ca54:	72fb      	strb	r3, [r7, #11]
    if(sign == LV_SIGNAL_GET_STYLE) {
 800ca56:	7afb      	ldrb	r3, [r7, #11]
 800ca58:	2b08      	cmp	r3, #8
 800ca5a:	d110      	bne.n	800ca7e <lv_obj_signal+0x36>
        lv_get_style_info_t * info = param;
 800ca5c:	687b      	ldr	r3, [r7, #4]
 800ca5e:	617b      	str	r3, [r7, #20]
        if(info->part == LV_OBJ_PART_MAIN) info->result = &obj->style_list;
 800ca60:	697b      	ldr	r3, [r7, #20]
 800ca62:	781b      	ldrb	r3, [r3, #0]
 800ca64:	2b00      	cmp	r3, #0
 800ca66:	d105      	bne.n	800ca74 <lv_obj_signal+0x2c>
 800ca68:	68fb      	ldr	r3, [r7, #12]
 800ca6a:	f103 0228 	add.w	r2, r3, #40	; 0x28
 800ca6e:	697b      	ldr	r3, [r7, #20]
 800ca70:	605a      	str	r2, [r3, #4]
 800ca72:	e002      	b.n	800ca7a <lv_obj_signal+0x32>
        else info->result = NULL;
 800ca74:	697b      	ldr	r3, [r7, #20]
 800ca76:	2200      	movs	r2, #0
 800ca78:	605a      	str	r2, [r3, #4]
        return LV_RES_OK;
 800ca7a:	2301      	movs	r3, #1
 800ca7c:	e098      	b.n	800cbb0 <lv_obj_signal+0x168>
    }
    else if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
 800ca7e:	7afb      	ldrb	r3, [r7, #11]
 800ca80:	2b07      	cmp	r3, #7
 800ca82:	d105      	bne.n	800ca90 <lv_obj_signal+0x48>
 800ca84:	494c      	ldr	r1, [pc, #304]	; (800cbb8 <lv_obj_signal+0x170>)
 800ca86:	6878      	ldr	r0, [r7, #4]
 800ca88:	f7ff f899 	bl	800bbbe <lv_obj_handle_get_type_signal>
 800ca8c:	4603      	mov	r3, r0
 800ca8e:	e08f      	b.n	800cbb0 <lv_obj_signal+0x168>

    lv_res_t res = LV_RES_OK;
 800ca90:	2301      	movs	r3, #1
 800ca92:	77fb      	strb	r3, [r7, #31]

    if(sign == LV_SIGNAL_CHILD_CHG) {
 800ca94:	7afb      	ldrb	r3, [r7, #11]
 800ca96:	2b01      	cmp	r3, #1
 800ca98:	d10a      	bne.n	800cab0 <lv_obj_signal+0x68>
        /*Return 'invalid' if the child change signal is not enabled*/
        if(lv_obj_is_protected(obj, LV_PROTECT_CHILD_CHG) != false) res = LV_RES_INV;
 800ca9a:	2101      	movs	r1, #1
 800ca9c:	68f8      	ldr	r0, [r7, #12]
 800ca9e:	f7fe ff3b 	bl	800b918 <lv_obj_is_protected>
 800caa2:	4603      	mov	r3, r0
 800caa4:	2b00      	cmp	r3, #0
 800caa6:	f000 8082 	beq.w	800cbae <lv_obj_signal+0x166>
 800caaa:	2300      	movs	r3, #0
 800caac:	77fb      	strb	r3, [r7, #31]
 800caae:	e07e      	b.n	800cbae <lv_obj_signal+0x166>
    }
    else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 800cab0:	7afb      	ldrb	r3, [r7, #11]
 800cab2:	2b06      	cmp	r3, #6
 800cab4:	d111      	bne.n	800cada <lv_obj_signal+0x92>
        lv_coord_t d = lv_obj_get_draw_rect_ext_pad_size(obj, LV_OBJ_PART_MAIN);
 800cab6:	2100      	movs	r1, #0
 800cab8:	68f8      	ldr	r0, [r7, #12]
 800caba:	f7ff fbe1 	bl	800c280 <lv_obj_get_draw_rect_ext_pad_size>
 800cabe:	4603      	mov	r3, r0
 800cac0:	837b      	strh	r3, [r7, #26]
        obj->ext_draw_pad = LV_MATH_MAX(obj->ext_draw_pad, d);
 800cac2:	68fb      	ldr	r3, [r7, #12]
 800cac4:	f9b3 3032 	ldrsh.w	r3, [r3, #50]	; 0x32
 800cac8:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 800cacc:	4293      	cmp	r3, r2
 800cace:	bfb8      	it	lt
 800cad0:	4613      	movlt	r3, r2
 800cad2:	b21a      	sxth	r2, r3
 800cad4:	68fb      	ldr	r3, [r7, #12]
 800cad6:	865a      	strh	r2, [r3, #50]	; 0x32
 800cad8:	e069      	b.n	800cbae <lv_obj_signal+0x166>
    }
#if LV_USE_OBJ_REALIGN
    else if(sign == LV_SIGNAL_PARENT_SIZE_CHG) {
 800cada:	7afb      	ldrb	r3, [r7, #11]
 800cadc:	2b03      	cmp	r3, #3
 800cade:	d10b      	bne.n	800caf8 <lv_obj_signal+0xb0>
        if(obj->realign.auto_realign) {
 800cae0:	68fb      	ldr	r3, [r7, #12]
 800cae2:	f893 3049 	ldrb.w	r3, [r3, #73]	; 0x49
 800cae6:	f003 0301 	and.w	r3, r3, #1
 800caea:	b2db      	uxtb	r3, r3
 800caec:	2b00      	cmp	r3, #0
 800caee:	d05e      	beq.n	800cbae <lv_obj_signal+0x166>
            lv_obj_realign(obj);
 800caf0:	68f8      	ldr	r0, [r7, #12]
 800caf2:	f7fd fb3b 	bl	800a16c <lv_obj_realign>
 800caf6:	e05a      	b.n	800cbae <lv_obj_signal+0x166>
        }
    }
#endif
    else if(sign == LV_SIGNAL_STYLE_CHG) {
 800caf8:	7afb      	ldrb	r3, [r7, #11]
 800cafa:	2b04      	cmp	r3, #4
 800cafc:	d103      	bne.n	800cb06 <lv_obj_signal+0xbe>
        lv_obj_refresh_ext_draw_pad(obj);
 800cafe:	68f8      	ldr	r0, [r7, #12]
 800cb00:	f7fe f86a 	bl	800abd8 <lv_obj_refresh_ext_draw_pad>
 800cb04:	e053      	b.n	800cbae <lv_obj_signal+0x166>
    }
    else if(sign == LV_SIGNAL_PRESSED) {
 800cb06:	7afb      	ldrb	r3, [r7, #11]
 800cb08:	2b0b      	cmp	r3, #11
 800cb0a:	d104      	bne.n	800cb16 <lv_obj_signal+0xce>
        lv_obj_add_state(obj, LV_STATE_PRESSED);
 800cb0c:	2110      	movs	r1, #16
 800cb0e:	68f8      	ldr	r0, [r7, #12]
 800cb10:	f7fd feb4 	bl	800a87c <lv_obj_add_state>
 800cb14:	e04b      	b.n	800cbae <lv_obj_signal+0x166>
    }
    else if(sign == LV_SIGNAL_RELEASED || sign == LV_SIGNAL_PRESS_LOST) {
 800cb16:	7afb      	ldrb	r3, [r7, #11]
 800cb18:	2b0e      	cmp	r3, #14
 800cb1a:	d002      	beq.n	800cb22 <lv_obj_signal+0xda>
 800cb1c:	7afb      	ldrb	r3, [r7, #11]
 800cb1e:	2b0d      	cmp	r3, #13
 800cb20:	d104      	bne.n	800cb2c <lv_obj_signal+0xe4>
        lv_obj_clear_state(obj, LV_STATE_PRESSED);
 800cb22:	2110      	movs	r1, #16
 800cb24:	68f8      	ldr	r0, [r7, #12]
 800cb26:	f7fd fed9 	bl	800a8dc <lv_obj_clear_state>
 800cb2a:	e040      	b.n	800cbae <lv_obj_signal+0x166>
    }
    else if(sign == LV_SIGNAL_FOCUS) {
 800cb2c:	7afb      	ldrb	r3, [r7, #11]
 800cb2e:	2b16      	cmp	r3, #22
 800cb30:	d12a      	bne.n	800cb88 <lv_obj_signal+0x140>
        bool editing = false;
 800cb32:	2300      	movs	r3, #0
 800cb34:	77bb      	strb	r3, [r7, #30]
#if LV_USE_GROUP
        editing = lv_group_get_editing(lv_obj_get_group(obj));
 800cb36:	68f8      	ldr	r0, [r7, #12]
 800cb38:	f7fe ffaa 	bl	800ba90 <lv_obj_get_group>
 800cb3c:	4603      	mov	r3, r0
 800cb3e:	4618      	mov	r0, r3
 800cb40:	f7fb fb18 	bl	8008174 <lv_group_get_editing>
 800cb44:	4603      	mov	r3, r0
 800cb46:	77bb      	strb	r3, [r7, #30]
#endif
        if(editing) {
 800cb48:	7fbb      	ldrb	r3, [r7, #30]
 800cb4a:	2b00      	cmp	r3, #0
 800cb4c:	d00f      	beq.n	800cb6e <lv_obj_signal+0x126>
            uint8_t state = LV_STATE_FOCUSED;
 800cb4e:	2302      	movs	r3, #2
 800cb50:	777b      	strb	r3, [r7, #29]
            state |= LV_STATE_EDITED;
 800cb52:	7f7b      	ldrb	r3, [r7, #29]
 800cb54:	f043 0304 	orr.w	r3, r3, #4
 800cb58:	777b      	strb	r3, [r7, #29]

            /*if using focus mode, change target to parent*/
            obj = lv_obj_get_focused_obj(obj);
 800cb5a:	68f8      	ldr	r0, [r7, #12]
 800cb5c:	f7ff ff56 	bl	800ca0c <lv_obj_get_focused_obj>
 800cb60:	60f8      	str	r0, [r7, #12]

            lv_obj_add_state(obj, state);
 800cb62:	7f7b      	ldrb	r3, [r7, #29]
 800cb64:	4619      	mov	r1, r3
 800cb66:	68f8      	ldr	r0, [r7, #12]
 800cb68:	f7fd fe88 	bl	800a87c <lv_obj_add_state>
 800cb6c:	e01f      	b.n	800cbae <lv_obj_signal+0x166>
        }
        else {

            /*if using focus mode, change target to parent*/
            obj = lv_obj_get_focused_obj(obj);
 800cb6e:	68f8      	ldr	r0, [r7, #12]
 800cb70:	f7ff ff4c 	bl	800ca0c <lv_obj_get_focused_obj>
 800cb74:	60f8      	str	r0, [r7, #12]

            lv_obj_add_state(obj, LV_STATE_FOCUSED);
 800cb76:	2102      	movs	r1, #2
 800cb78:	68f8      	ldr	r0, [r7, #12]
 800cb7a:	f7fd fe7f 	bl	800a87c <lv_obj_add_state>
            lv_obj_clear_state(obj, LV_STATE_EDITED);
 800cb7e:	2104      	movs	r1, #4
 800cb80:	68f8      	ldr	r0, [r7, #12]
 800cb82:	f7fd feab 	bl	800a8dc <lv_obj_clear_state>
 800cb86:	e012      	b.n	800cbae <lv_obj_signal+0x166>
        }
    }
    else if(sign == LV_SIGNAL_DEFOCUS) {
 800cb88:	7afb      	ldrb	r3, [r7, #11]
 800cb8a:	2b17      	cmp	r3, #23
 800cb8c:	d108      	bne.n	800cba0 <lv_obj_signal+0x158>

        /*if using focus mode, change target to parent*/
        obj = lv_obj_get_focused_obj(obj);
 800cb8e:	68f8      	ldr	r0, [r7, #12]
 800cb90:	f7ff ff3c 	bl	800ca0c <lv_obj_get_focused_obj>
 800cb94:	60f8      	str	r0, [r7, #12]

        lv_obj_clear_state(obj, LV_STATE_FOCUSED | LV_STATE_EDITED);
 800cb96:	2106      	movs	r1, #6
 800cb98:	68f8      	ldr	r0, [r7, #12]
 800cb9a:	f7fd fe9f 	bl	800a8dc <lv_obj_clear_state>
 800cb9e:	e006      	b.n	800cbae <lv_obj_signal+0x166>
    }
    else if(sign == LV_SIGNAL_CLEANUP) {
 800cba0:	7afb      	ldrb	r3, [r7, #11]
 800cba2:	2b00      	cmp	r3, #0
 800cba4:	d103      	bne.n	800cbae <lv_obj_signal+0x166>
        lv_obj_clean_style_list(obj, LV_OBJ_PART_MAIN);
 800cba6:	2100      	movs	r1, #0
 800cba8:	68f8      	ldr	r0, [r7, #12]
 800cbaa:	f7fd fb4f 	bl	800a24c <lv_obj_clean_style_list>
    }

    return res;
 800cbae:	7ffb      	ldrb	r3, [r7, #31]
}
 800cbb0:	4618      	mov	r0, r3
 800cbb2:	3720      	adds	r7, #32
 800cbb4:	46bd      	mov	sp, r7
 800cbb6:	bd80      	pop	{r7, pc}
 800cbb8:	0802e440 	.word	0x0802e440

0800cbbc <refresh_children_position>:
 * @param obj pointer to an object which children will be repositioned
 * @param x_diff x coordinate shift
 * @param y_diff y coordinate shift
 */
static void refresh_children_position(lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff)
{
 800cbbc:	b580      	push	{r7, lr}
 800cbbe:	b084      	sub	sp, #16
 800cbc0:	af00      	add	r7, sp, #0
 800cbc2:	6078      	str	r0, [r7, #4]
 800cbc4:	460b      	mov	r3, r1
 800cbc6:	807b      	strh	r3, [r7, #2]
 800cbc8:	4613      	mov	r3, r2
 800cbca:	803b      	strh	r3, [r7, #0]
    lv_obj_t * i;
    _LV_LL_READ(obj->child_ll, i) {
 800cbcc:	687b      	ldr	r3, [r7, #4]
 800cbce:	3304      	adds	r3, #4
 800cbd0:	4618      	mov	r0, r3
 800cbd2:	f013 fe43 	bl	802085c <_lv_ll_get_head>
 800cbd6:	60f8      	str	r0, [r7, #12]
 800cbd8:	e036      	b.n	800cc48 <refresh_children_position+0x8c>
        i->coords.x1 += x_diff;
 800cbda:	68fb      	ldr	r3, [r7, #12]
 800cbdc:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 800cbe0:	b29a      	uxth	r2, r3
 800cbe2:	887b      	ldrh	r3, [r7, #2]
 800cbe4:	4413      	add	r3, r2
 800cbe6:	b29b      	uxth	r3, r3
 800cbe8:	b21a      	sxth	r2, r3
 800cbea:	68fb      	ldr	r3, [r7, #12]
 800cbec:	821a      	strh	r2, [r3, #16]
        i->coords.y1 += y_diff;
 800cbee:	68fb      	ldr	r3, [r7, #12]
 800cbf0:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 800cbf4:	b29a      	uxth	r2, r3
 800cbf6:	883b      	ldrh	r3, [r7, #0]
 800cbf8:	4413      	add	r3, r2
 800cbfa:	b29b      	uxth	r3, r3
 800cbfc:	b21a      	sxth	r2, r3
 800cbfe:	68fb      	ldr	r3, [r7, #12]
 800cc00:	825a      	strh	r2, [r3, #18]
        i->coords.x2 += x_diff;
 800cc02:	68fb      	ldr	r3, [r7, #12]
 800cc04:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 800cc08:	b29a      	uxth	r2, r3
 800cc0a:	887b      	ldrh	r3, [r7, #2]
 800cc0c:	4413      	add	r3, r2
 800cc0e:	b29b      	uxth	r3, r3
 800cc10:	b21a      	sxth	r2, r3
 800cc12:	68fb      	ldr	r3, [r7, #12]
 800cc14:	829a      	strh	r2, [r3, #20]
        i->coords.y2 += y_diff;
 800cc16:	68fb      	ldr	r3, [r7, #12]
 800cc18:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800cc1c:	b29a      	uxth	r2, r3
 800cc1e:	883b      	ldrh	r3, [r7, #0]
 800cc20:	4413      	add	r3, r2
 800cc22:	b29b      	uxth	r3, r3
 800cc24:	b21a      	sxth	r2, r3
 800cc26:	68fb      	ldr	r3, [r7, #12]
 800cc28:	82da      	strh	r2, [r3, #22]

        refresh_children_position(i, x_diff, y_diff);
 800cc2a:	f9b7 2000 	ldrsh.w	r2, [r7]
 800cc2e:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800cc32:	4619      	mov	r1, r3
 800cc34:	68f8      	ldr	r0, [r7, #12]
 800cc36:	f7ff ffc1 	bl	800cbbc <refresh_children_position>
    _LV_LL_READ(obj->child_ll, i) {
 800cc3a:	687b      	ldr	r3, [r7, #4]
 800cc3c:	3304      	adds	r3, #4
 800cc3e:	68f9      	ldr	r1, [r7, #12]
 800cc40:	4618      	mov	r0, r3
 800cc42:	f013 fe31 	bl	80208a8 <_lv_ll_get_next>
 800cc46:	60f8      	str	r0, [r7, #12]
 800cc48:	68fb      	ldr	r3, [r7, #12]
 800cc4a:	2b00      	cmp	r3, #0
 800cc4c:	d1c5      	bne.n	800cbda <refresh_children_position+0x1e>
    }
}
 800cc4e:	bf00      	nop
 800cc50:	bf00      	nop
 800cc52:	3710      	adds	r7, #16
 800cc54:	46bd      	mov	sp, r7
 800cc56:	bd80      	pop	{r7, pc}

0800cc58 <report_style_mod_core>:
 * Refresh the style of all children of an object. (Called recursively)
 * @param style refresh objects only with this style_list.
 * @param obj pointer to an object
 */
static void report_style_mod_core(void * style, lv_obj_t * obj)
{
 800cc58:	b580      	push	{r7, lr}
 800cc5a:	b086      	sub	sp, #24
 800cc5c:	af00      	add	r7, sp, #0
 800cc5e:	6078      	str	r0, [r7, #4]
 800cc60:	6039      	str	r1, [r7, #0]
    uint8_t part;
    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {
 800cc62:	2300      	movs	r3, #0
 800cc64:	75fb      	strb	r3, [r7, #23]
 800cc66:	e02e      	b.n	800ccc6 <report_style_mod_core+0x6e>
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
 800cc68:	7dfb      	ldrb	r3, [r7, #23]
 800cc6a:	4619      	mov	r1, r3
 800cc6c:	6838      	ldr	r0, [r7, #0]
 800cc6e:	f7fe f9db 	bl	800b028 <lv_obj_get_style_list>
 800cc72:	60f8      	str	r0, [r7, #12]
        if(list == NULL) break;
 800cc74:	68fb      	ldr	r3, [r7, #12]
 800cc76:	2b00      	cmp	r3, #0
 800cc78:	d029      	beq.n	800ccce <report_style_mod_core+0x76>

        uint8_t ci;
        for(ci = 0; ci < list->style_cnt; ci++) {
 800cc7a:	2300      	movs	r3, #0
 800cc7c:	75bb      	strb	r3, [r7, #22]
 800cc7e:	e016      	b.n	800ccae <report_style_mod_core+0x56>
            lv_style_t * class = lv_style_list_get_style(list, ci);
 800cc80:	7dbb      	ldrb	r3, [r7, #22]
 800cc82:	4619      	mov	r1, r3
 800cc84:	68f8      	ldr	r0, [r7, #12]
 800cc86:	f7fb fda9 	bl	80087dc <lv_style_list_get_style>
 800cc8a:	60b8      	str	r0, [r7, #8]
            if(class == style || style == NULL) {
 800cc8c:	68ba      	ldr	r2, [r7, #8]
 800cc8e:	687b      	ldr	r3, [r7, #4]
 800cc90:	429a      	cmp	r2, r3
 800cc92:	d002      	beq.n	800cc9a <report_style_mod_core+0x42>
 800cc94:	687b      	ldr	r3, [r7, #4]
 800cc96:	2b00      	cmp	r3, #0
 800cc98:	d106      	bne.n	800cca8 <report_style_mod_core+0x50>
                lv_obj_refresh_style(obj, part, LV_STYLE_PROP_ALL);
 800cc9a:	7dfb      	ldrb	r3, [r7, #23]
 800cc9c:	22ff      	movs	r2, #255	; 0xff
 800cc9e:	4619      	mov	r1, r3
 800cca0:	6838      	ldr	r0, [r7, #0]
 800cca2:	f7fd fb2d 	bl	800a300 <lv_obj_refresh_style>
                break;
 800cca6:	e00b      	b.n	800ccc0 <report_style_mod_core+0x68>
        for(ci = 0; ci < list->style_cnt; ci++) {
 800cca8:	7dbb      	ldrb	r3, [r7, #22]
 800ccaa:	3301      	adds	r3, #1
 800ccac:	75bb      	strb	r3, [r7, #22]
 800ccae:	68fb      	ldr	r3, [r7, #12]
 800ccb0:	791b      	ldrb	r3, [r3, #4]
 800ccb2:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800ccb6:	b2db      	uxtb	r3, r3
 800ccb8:	461a      	mov	r2, r3
 800ccba:	7dbb      	ldrb	r3, [r7, #22]
 800ccbc:	4293      	cmp	r3, r2
 800ccbe:	d3df      	bcc.n	800cc80 <report_style_mod_core+0x28>
    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {
 800ccc0:	7dfb      	ldrb	r3, [r7, #23]
 800ccc2:	3301      	adds	r3, #1
 800ccc4:	75fb      	strb	r3, [r7, #23]
 800ccc6:	7dfb      	ldrb	r3, [r7, #23]
 800ccc8:	2b40      	cmp	r3, #64	; 0x40
 800ccca:	d1cd      	bne.n	800cc68 <report_style_mod_core+0x10>
 800cccc:	e000      	b.n	800ccd0 <report_style_mod_core+0x78>
        if(list == NULL) break;
 800ccce:	bf00      	nop
            }
        }
    }

    lv_obj_t * child = lv_obj_get_child(obj, NULL);
 800ccd0:	2100      	movs	r1, #0
 800ccd2:	6838      	ldr	r0, [r7, #0]
 800ccd4:	f7fe f840 	bl	800ad58 <lv_obj_get_child>
 800ccd8:	6138      	str	r0, [r7, #16]
    while(child) {
 800ccda:	e008      	b.n	800ccee <report_style_mod_core+0x96>
        report_style_mod_core(style, child);
 800ccdc:	6939      	ldr	r1, [r7, #16]
 800ccde:	6878      	ldr	r0, [r7, #4]
 800cce0:	f7ff ffba 	bl	800cc58 <report_style_mod_core>
        child = lv_obj_get_child(obj, child);
 800cce4:	6939      	ldr	r1, [r7, #16]
 800cce6:	6838      	ldr	r0, [r7, #0]
 800cce8:	f7fe f836 	bl	800ad58 <lv_obj_get_child>
 800ccec:	6138      	str	r0, [r7, #16]
    while(child) {
 800ccee:	693b      	ldr	r3, [r7, #16]
 800ccf0:	2b00      	cmp	r3, #0
 800ccf2:	d1f3      	bne.n	800ccdc <report_style_mod_core+0x84>
    }

}
 800ccf4:	bf00      	nop
 800ccf6:	bf00      	nop
 800ccf8:	3718      	adds	r7, #24
 800ccfa:	46bd      	mov	sp, r7
 800ccfc:	bd80      	pop	{r7, pc}

0800ccfe <refresh_children_style>:
 * Recursively refresh the style of the children. Go deeper until a not NULL style is found
 * because the NULL styles are inherited from the parent
 * @param obj pointer to an object
 */
static void refresh_children_style(lv_obj_t * obj)
{
 800ccfe:	b580      	push	{r7, lr}
 800cd00:	b084      	sub	sp, #16
 800cd02:	af00      	add	r7, sp, #0
 800cd04:	6078      	str	r0, [r7, #4]
    lv_obj_t * child = lv_obj_get_child(obj, NULL);
 800cd06:	2100      	movs	r1, #0
 800cd08:	6878      	ldr	r0, [r7, #4]
 800cd0a:	f7fe f825 	bl	800ad58 <lv_obj_get_child>
 800cd0e:	60f8      	str	r0, [r7, #12]
    while(child != NULL) {
 800cd10:	e013      	b.n	800cd3a <refresh_children_style+0x3c>
        lv_obj_invalidate(child);
 800cd12:	68f8      	ldr	r0, [r7, #12]
 800cd14:	f7fc fe74 	bl	8009a00 <lv_obj_invalidate>
        child->signal_cb(child, LV_SIGNAL_STYLE_CHG, NULL);
 800cd18:	68fb      	ldr	r3, [r7, #12]
 800cd1a:	69db      	ldr	r3, [r3, #28]
 800cd1c:	2200      	movs	r2, #0
 800cd1e:	2104      	movs	r1, #4
 800cd20:	68f8      	ldr	r0, [r7, #12]
 800cd22:	4798      	blx	r3
        lv_obj_invalidate(child);
 800cd24:	68f8      	ldr	r0, [r7, #12]
 800cd26:	f7fc fe6b 	bl	8009a00 <lv_obj_invalidate>

        refresh_children_style(child); /*Check children too*/
 800cd2a:	68f8      	ldr	r0, [r7, #12]
 800cd2c:	f7ff ffe7 	bl	800ccfe <refresh_children_style>
        child = lv_obj_get_child(obj, child);
 800cd30:	68f9      	ldr	r1, [r7, #12]
 800cd32:	6878      	ldr	r0, [r7, #4]
 800cd34:	f7fe f810 	bl	800ad58 <lv_obj_get_child>
 800cd38:	60f8      	str	r0, [r7, #12]
    while(child != NULL) {
 800cd3a:	68fb      	ldr	r3, [r7, #12]
 800cd3c:	2b00      	cmp	r3, #0
 800cd3e:	d1e8      	bne.n	800cd12 <refresh_children_style+0x14>
    }
}
 800cd40:	bf00      	nop
 800cd42:	bf00      	nop
 800cd44:	3710      	adds	r7, #16
 800cd46:	46bd      	mov	sp, r7
 800cd48:	bd80      	pop	{r7, pc}

0800cd4a <obj_align_core>:
    }
}

static void obj_align_core(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, bool x_set, bool y_set,
                           lv_coord_t x_ofs, lv_coord_t y_ofs)
{
 800cd4a:	b580      	push	{r7, lr}
 800cd4c:	b088      	sub	sp, #32
 800cd4e:	af00      	add	r7, sp, #0
 800cd50:	60f8      	str	r0, [r7, #12]
 800cd52:	60b9      	str	r1, [r7, #8]
 800cd54:	4611      	mov	r1, r2
 800cd56:	461a      	mov	r2, r3
 800cd58:	460b      	mov	r3, r1
 800cd5a:	71fb      	strb	r3, [r7, #7]
 800cd5c:	4613      	mov	r3, r2
 800cd5e:	71bb      	strb	r3, [r7, #6]
    lv_point_t new_pos;
    _lv_area_align(&base->coords, &obj->coords, align, &new_pos);
 800cd60:	68bb      	ldr	r3, [r7, #8]
 800cd62:	f103 0010 	add.w	r0, r3, #16
 800cd66:	68fb      	ldr	r3, [r7, #12]
 800cd68:	f103 0110 	add.w	r1, r3, #16
 800cd6c:	f107 0314 	add.w	r3, r7, #20
 800cd70:	79fa      	ldrb	r2, [r7, #7]
 800cd72:	f012 fdf3 	bl	801f95c <_lv_area_align>

    /*Bring together the coordination system of base and obj*/
    lv_obj_t * par        = lv_obj_get_parent(obj);
 800cd76:	68f8      	ldr	r0, [r7, #12]
 800cd78:	f7fd ffce 	bl	800ad18 <lv_obj_get_parent>
 800cd7c:	61f8      	str	r0, [r7, #28]
    lv_coord_t par_abs_x  = par->coords.x1;
 800cd7e:	69fb      	ldr	r3, [r7, #28]
 800cd80:	8a1b      	ldrh	r3, [r3, #16]
 800cd82:	837b      	strh	r3, [r7, #26]
    lv_coord_t par_abs_y  = par->coords.y1;
 800cd84:	69fb      	ldr	r3, [r7, #28]
 800cd86:	8a5b      	ldrh	r3, [r3, #18]
 800cd88:	833b      	strh	r3, [r7, #24]
    new_pos.x += x_ofs;
 800cd8a:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800cd8e:	b29a      	uxth	r2, r3
 800cd90:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 800cd92:	4413      	add	r3, r2
 800cd94:	b29b      	uxth	r3, r3
 800cd96:	b21b      	sxth	r3, r3
 800cd98:	82bb      	strh	r3, [r7, #20]
    new_pos.y += y_ofs;
 800cd9a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800cd9e:	b29a      	uxth	r2, r3
 800cda0:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 800cda2:	4413      	add	r3, r2
 800cda4:	b29b      	uxth	r3, r3
 800cda6:	b21b      	sxth	r3, r3
 800cda8:	82fb      	strh	r3, [r7, #22]
    new_pos.x -= par_abs_x;
 800cdaa:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800cdae:	b29a      	uxth	r2, r3
 800cdb0:	8b7b      	ldrh	r3, [r7, #26]
 800cdb2:	1ad3      	subs	r3, r2, r3
 800cdb4:	b29b      	uxth	r3, r3
 800cdb6:	b21b      	sxth	r3, r3
 800cdb8:	82bb      	strh	r3, [r7, #20]
    new_pos.y -= par_abs_y;
 800cdba:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800cdbe:	b29a      	uxth	r2, r3
 800cdc0:	8b3b      	ldrh	r3, [r7, #24]
 800cdc2:	1ad3      	subs	r3, r2, r3
 800cdc4:	b29b      	uxth	r3, r3
 800cdc6:	b21b      	sxth	r3, r3
 800cdc8:	82fb      	strh	r3, [r7, #22]

    if(x_set && y_set) lv_obj_set_pos(obj, new_pos.x, new_pos.y);
 800cdca:	79bb      	ldrb	r3, [r7, #6]
 800cdcc:	2b00      	cmp	r3, #0
 800cdce:	d00c      	beq.n	800cdea <obj_align_core+0xa0>
 800cdd0:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800cdd4:	2b00      	cmp	r3, #0
 800cdd6:	d008      	beq.n	800cdea <obj_align_core+0xa0>
 800cdd8:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800cddc:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 800cde0:	4619      	mov	r1, r3
 800cde2:	68f8      	ldr	r0, [r7, #12]
 800cde4:	f7fc ff34 	bl	8009c50 <lv_obj_set_pos>
    else if(x_set) lv_obj_set_x(obj, new_pos.x);
    else if(y_set) lv_obj_set_y(obj, new_pos.y);
}
 800cde8:	e013      	b.n	800ce12 <obj_align_core+0xc8>
    else if(x_set) lv_obj_set_x(obj, new_pos.x);
 800cdea:	79bb      	ldrb	r3, [r7, #6]
 800cdec:	2b00      	cmp	r3, #0
 800cdee:	d006      	beq.n	800cdfe <obj_align_core+0xb4>
 800cdf0:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 800cdf4:	4619      	mov	r1, r3
 800cdf6:	68f8      	ldr	r0, [r7, #12]
 800cdf8:	f7fc ffd0 	bl	8009d9c <lv_obj_set_x>
}
 800cdfc:	e009      	b.n	800ce12 <obj_align_core+0xc8>
    else if(y_set) lv_obj_set_y(obj, new_pos.y);
 800cdfe:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 800ce02:	2b00      	cmp	r3, #0
 800ce04:	d005      	beq.n	800ce12 <obj_align_core+0xc8>
 800ce06:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800ce0a:	4619      	mov	r1, r3
 800ce0c:	68f8      	ldr	r0, [r7, #12]
 800ce0e:	f7fc ffef 	bl	8009df0 <lv_obj_set_y>
}
 800ce12:	bf00      	nop
 800ce14:	3720      	adds	r7, #32
 800ce16:	46bd      	mov	sp, r7
 800ce18:	bd80      	pop	{r7, pc}
	...

0800ce1c <obj_align_mid_core>:

static void obj_align_mid_core(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align,  bool x_set, bool y_set,
                               lv_coord_t x_ofs, lv_coord_t y_ofs)
{
 800ce1c:	b580      	push	{r7, lr}
 800ce1e:	b08a      	sub	sp, #40	; 0x28
 800ce20:	af00      	add	r7, sp, #0
 800ce22:	60f8      	str	r0, [r7, #12]
 800ce24:	60b9      	str	r1, [r7, #8]
 800ce26:	4611      	mov	r1, r2
 800ce28:	461a      	mov	r2, r3
 800ce2a:	460b      	mov	r3, r1
 800ce2c:	71fb      	strb	r3, [r7, #7]
 800ce2e:	4613      	mov	r3, r2
 800ce30:	71bb      	strb	r3, [r7, #6]
    lv_coord_t new_x = lv_obj_get_x(obj);
 800ce32:	68f8      	ldr	r0, [r7, #12]
 800ce34:	f7fd ffe6 	bl	800ae04 <lv_obj_get_x>
 800ce38:	4603      	mov	r3, r0
 800ce3a:	84fb      	strh	r3, [r7, #38]	; 0x26
    lv_coord_t new_y = lv_obj_get_y(obj);
 800ce3c:	68f8      	ldr	r0, [r7, #12]
 800ce3e:	f7fe f817 	bl	800ae70 <lv_obj_get_y>
 800ce42:	4603      	mov	r3, r0
 800ce44:	84bb      	strh	r3, [r7, #36]	; 0x24

    lv_coord_t obj_w_half = lv_obj_get_width(obj) / 2;
 800ce46:	68f8      	ldr	r0, [r7, #12]
 800ce48:	f7fe f848 	bl	800aedc <lv_obj_get_width>
 800ce4c:	4603      	mov	r3, r0
 800ce4e:	0fda      	lsrs	r2, r3, #31
 800ce50:	4413      	add	r3, r2
 800ce52:	105b      	asrs	r3, r3, #1
 800ce54:	847b      	strh	r3, [r7, #34]	; 0x22
    lv_coord_t obj_h_half = lv_obj_get_height(obj) / 2;
 800ce56:	68f8      	ldr	r0, [r7, #12]
 800ce58:	f7fe f864 	bl	800af24 <lv_obj_get_height>
 800ce5c:	4603      	mov	r3, r0
 800ce5e:	0fda      	lsrs	r2, r3, #31
 800ce60:	4413      	add	r3, r2
 800ce62:	105b      	asrs	r3, r3, #1
 800ce64:	843b      	strh	r3, [r7, #32]


    switch(align) {
 800ce66:	79fb      	ldrb	r3, [r7, #7]
 800ce68:	2b14      	cmp	r3, #20
 800ce6a:	f200 8194 	bhi.w	800d196 <obj_align_mid_core+0x37a>
 800ce6e:	a201      	add	r2, pc, #4	; (adr r2, 800ce74 <obj_align_mid_core+0x58>)
 800ce70:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ce74:	0800cec9 	.word	0x0800cec9
 800ce78:	0800ceff 	.word	0x0800ceff
 800ce7c:	0800cf11 	.word	0x0800cf11
 800ce80:	0800cf35 	.word	0x0800cf35
 800ce84:	0800cf51 	.word	0x0800cf51
 800ce88:	0800cf6d 	.word	0x0800cf6d
 800ce8c:	0800cf9b 	.word	0x0800cf9b
 800ce90:	0800cfc1 	.word	0x0800cfc1
 800ce94:	0800cfe5 	.word	0x0800cfe5
 800ce98:	0800d013 	.word	0x0800d013
 800ce9c:	0800d025 	.word	0x0800d025
 800cea0:	0800d049 	.word	0x0800d049
 800cea4:	0800d065 	.word	0x0800d065
 800cea8:	0800d081 	.word	0x0800d081
 800ceac:	0800d0af 	.word	0x0800d0af
 800ceb0:	0800d0d5 	.word	0x0800d0d5
 800ceb4:	0800d0e7 	.word	0x0800d0e7
 800ceb8:	0800d10b 	.word	0x0800d10b
 800cebc:	0800d127 	.word	0x0800d127
 800cec0:	0800d143 	.word	0x0800d143
 800cec4:	0800d171 	.word	0x0800d171
        case LV_ALIGN_CENTER:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 800cec8:	68b8      	ldr	r0, [r7, #8]
 800ceca:	f7fe f807 	bl	800aedc <lv_obj_get_width>
 800cece:	4603      	mov	r3, r0
 800ced0:	0fda      	lsrs	r2, r3, #31
 800ced2:	4413      	add	r3, r2
 800ced4:	105b      	asrs	r3, r3, #1
 800ced6:	b21b      	sxth	r3, r3
 800ced8:	b29a      	uxth	r2, r3
 800ceda:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800cedc:	1ad3      	subs	r3, r2, r3
 800cede:	b29b      	uxth	r3, r3
 800cee0:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 800cee2:	68b8      	ldr	r0, [r7, #8]
 800cee4:	f7fe f81e 	bl	800af24 <lv_obj_get_height>
 800cee8:	4603      	mov	r3, r0
 800ceea:	0fda      	lsrs	r2, r3, #31
 800ceec:	4413      	add	r3, r2
 800ceee:	105b      	asrs	r3, r3, #1
 800cef0:	b21b      	sxth	r3, r3
 800cef2:	b29a      	uxth	r2, r3
 800cef4:	8c3b      	ldrh	r3, [r7, #32]
 800cef6:	1ad3      	subs	r3, r2, r3
 800cef8:	b29b      	uxth	r3, r3
 800cefa:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800cefc:	e14b      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_IN_TOP_LEFT:
            new_x = -obj_w_half;
 800cefe:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800cf00:	425b      	negs	r3, r3
 800cf02:	b29b      	uxth	r3, r3
 800cf04:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 800cf06:	8c3b      	ldrh	r3, [r7, #32]
 800cf08:	425b      	negs	r3, r3
 800cf0a:	b29b      	uxth	r3, r3
 800cf0c:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800cf0e:	e142      	b.n	800d196 <obj_align_mid_core+0x37a>
        case LV_ALIGN_IN_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 800cf10:	68b8      	ldr	r0, [r7, #8]
 800cf12:	f7fd ffe3 	bl	800aedc <lv_obj_get_width>
 800cf16:	4603      	mov	r3, r0
 800cf18:	0fda      	lsrs	r2, r3, #31
 800cf1a:	4413      	add	r3, r2
 800cf1c:	105b      	asrs	r3, r3, #1
 800cf1e:	b21b      	sxth	r3, r3
 800cf20:	b29a      	uxth	r2, r3
 800cf22:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800cf24:	1ad3      	subs	r3, r2, r3
 800cf26:	b29b      	uxth	r3, r3
 800cf28:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 800cf2a:	8c3b      	ldrh	r3, [r7, #32]
 800cf2c:	425b      	negs	r3, r3
 800cf2e:	b29b      	uxth	r3, r3
 800cf30:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800cf32:	e130      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_IN_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 800cf34:	68b8      	ldr	r0, [r7, #8]
 800cf36:	f7fd ffd1 	bl	800aedc <lv_obj_get_width>
 800cf3a:	4603      	mov	r3, r0
 800cf3c:	b29a      	uxth	r2, r3
 800cf3e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800cf40:	1ad3      	subs	r3, r2, r3
 800cf42:	b29b      	uxth	r3, r3
 800cf44:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 800cf46:	8c3b      	ldrh	r3, [r7, #32]
 800cf48:	425b      	negs	r3, r3
 800cf4a:	b29b      	uxth	r3, r3
 800cf4c:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800cf4e:	e122      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_IN_BOTTOM_LEFT:
            new_x = -obj_w_half;
 800cf50:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800cf52:	425b      	negs	r3, r3
 800cf54:	b29b      	uxth	r3, r3
 800cf56:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 800cf58:	68b8      	ldr	r0, [r7, #8]
 800cf5a:	f7fd ffe3 	bl	800af24 <lv_obj_get_height>
 800cf5e:	4603      	mov	r3, r0
 800cf60:	b29a      	uxth	r2, r3
 800cf62:	8c3b      	ldrh	r3, [r7, #32]
 800cf64:	1ad3      	subs	r3, r2, r3
 800cf66:	b29b      	uxth	r3, r3
 800cf68:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800cf6a:	e114      	b.n	800d196 <obj_align_mid_core+0x37a>
        case LV_ALIGN_IN_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 800cf6c:	68b8      	ldr	r0, [r7, #8]
 800cf6e:	f7fd ffb5 	bl	800aedc <lv_obj_get_width>
 800cf72:	4603      	mov	r3, r0
 800cf74:	0fda      	lsrs	r2, r3, #31
 800cf76:	4413      	add	r3, r2
 800cf78:	105b      	asrs	r3, r3, #1
 800cf7a:	b21b      	sxth	r3, r3
 800cf7c:	b29a      	uxth	r2, r3
 800cf7e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800cf80:	1ad3      	subs	r3, r2, r3
 800cf82:	b29b      	uxth	r3, r3
 800cf84:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 800cf86:	68b8      	ldr	r0, [r7, #8]
 800cf88:	f7fd ffcc 	bl	800af24 <lv_obj_get_height>
 800cf8c:	4603      	mov	r3, r0
 800cf8e:	b29a      	uxth	r2, r3
 800cf90:	8c3b      	ldrh	r3, [r7, #32]
 800cf92:	1ad3      	subs	r3, r2, r3
 800cf94:	b29b      	uxth	r3, r3
 800cf96:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800cf98:	e0fd      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_IN_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 800cf9a:	68b8      	ldr	r0, [r7, #8]
 800cf9c:	f7fd ff9e 	bl	800aedc <lv_obj_get_width>
 800cfa0:	4603      	mov	r3, r0
 800cfa2:	b29a      	uxth	r2, r3
 800cfa4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800cfa6:	1ad3      	subs	r3, r2, r3
 800cfa8:	b29b      	uxth	r3, r3
 800cfaa:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 800cfac:	68b8      	ldr	r0, [r7, #8]
 800cfae:	f7fd ffb9 	bl	800af24 <lv_obj_get_height>
 800cfb2:	4603      	mov	r3, r0
 800cfb4:	b29a      	uxth	r2, r3
 800cfb6:	8c3b      	ldrh	r3, [r7, #32]
 800cfb8:	1ad3      	subs	r3, r2, r3
 800cfba:	b29b      	uxth	r3, r3
 800cfbc:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800cfbe:	e0ea      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_IN_LEFT_MID:
            new_x = -obj_w_half;
 800cfc0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800cfc2:	425b      	negs	r3, r3
 800cfc4:	b29b      	uxth	r3, r3
 800cfc6:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 800cfc8:	68b8      	ldr	r0, [r7, #8]
 800cfca:	f7fd ffab 	bl	800af24 <lv_obj_get_height>
 800cfce:	4603      	mov	r3, r0
 800cfd0:	0fda      	lsrs	r2, r3, #31
 800cfd2:	4413      	add	r3, r2
 800cfd4:	105b      	asrs	r3, r3, #1
 800cfd6:	b21b      	sxth	r3, r3
 800cfd8:	b29a      	uxth	r2, r3
 800cfda:	8c3b      	ldrh	r3, [r7, #32]
 800cfdc:	1ad3      	subs	r3, r2, r3
 800cfde:	b29b      	uxth	r3, r3
 800cfe0:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800cfe2:	e0d8      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_IN_RIGHT_MID:
            new_x = lv_obj_get_width(base) - obj_w_half;
 800cfe4:	68b8      	ldr	r0, [r7, #8]
 800cfe6:	f7fd ff79 	bl	800aedc <lv_obj_get_width>
 800cfea:	4603      	mov	r3, r0
 800cfec:	b29a      	uxth	r2, r3
 800cfee:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800cff0:	1ad3      	subs	r3, r2, r3
 800cff2:	b29b      	uxth	r3, r3
 800cff4:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 800cff6:	68b8      	ldr	r0, [r7, #8]
 800cff8:	f7fd ff94 	bl	800af24 <lv_obj_get_height>
 800cffc:	4603      	mov	r3, r0
 800cffe:	0fda      	lsrs	r2, r3, #31
 800d000:	4413      	add	r3, r2
 800d002:	105b      	asrs	r3, r3, #1
 800d004:	b21b      	sxth	r3, r3
 800d006:	b29a      	uxth	r2, r3
 800d008:	8c3b      	ldrh	r3, [r7, #32]
 800d00a:	1ad3      	subs	r3, r2, r3
 800d00c:	b29b      	uxth	r3, r3
 800d00e:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d010:	e0c1      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_TOP_LEFT:
            new_x = -obj_w_half;
 800d012:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d014:	425b      	negs	r3, r3
 800d016:	b29b      	uxth	r3, r3
 800d018:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 800d01a:	8c3b      	ldrh	r3, [r7, #32]
 800d01c:	425b      	negs	r3, r3
 800d01e:	b29b      	uxth	r3, r3
 800d020:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d022:	e0b8      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 800d024:	68b8      	ldr	r0, [r7, #8]
 800d026:	f7fd ff59 	bl	800aedc <lv_obj_get_width>
 800d02a:	4603      	mov	r3, r0
 800d02c:	0fda      	lsrs	r2, r3, #31
 800d02e:	4413      	add	r3, r2
 800d030:	105b      	asrs	r3, r3, #1
 800d032:	b21b      	sxth	r3, r3
 800d034:	b29a      	uxth	r2, r3
 800d036:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d038:	1ad3      	subs	r3, r2, r3
 800d03a:	b29b      	uxth	r3, r3
 800d03c:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 800d03e:	8c3b      	ldrh	r3, [r7, #32]
 800d040:	425b      	negs	r3, r3
 800d042:	b29b      	uxth	r3, r3
 800d044:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d046:	e0a6      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 800d048:	68b8      	ldr	r0, [r7, #8]
 800d04a:	f7fd ff47 	bl	800aedc <lv_obj_get_width>
 800d04e:	4603      	mov	r3, r0
 800d050:	b29a      	uxth	r2, r3
 800d052:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d054:	1ad3      	subs	r3, r2, r3
 800d056:	b29b      	uxth	r3, r3
 800d058:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 800d05a:	8c3b      	ldrh	r3, [r7, #32]
 800d05c:	425b      	negs	r3, r3
 800d05e:	b29b      	uxth	r3, r3
 800d060:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d062:	e098      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_BOTTOM_LEFT:
            new_x = -obj_w_half;
 800d064:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d066:	425b      	negs	r3, r3
 800d068:	b29b      	uxth	r3, r3
 800d06a:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 800d06c:	68b8      	ldr	r0, [r7, #8]
 800d06e:	f7fd ff59 	bl	800af24 <lv_obj_get_height>
 800d072:	4603      	mov	r3, r0
 800d074:	b29a      	uxth	r2, r3
 800d076:	8c3b      	ldrh	r3, [r7, #32]
 800d078:	1ad3      	subs	r3, r2, r3
 800d07a:	b29b      	uxth	r3, r3
 800d07c:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d07e:	e08a      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 800d080:	68b8      	ldr	r0, [r7, #8]
 800d082:	f7fd ff2b 	bl	800aedc <lv_obj_get_width>
 800d086:	4603      	mov	r3, r0
 800d088:	0fda      	lsrs	r2, r3, #31
 800d08a:	4413      	add	r3, r2
 800d08c:	105b      	asrs	r3, r3, #1
 800d08e:	b21b      	sxth	r3, r3
 800d090:	b29a      	uxth	r2, r3
 800d092:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d094:	1ad3      	subs	r3, r2, r3
 800d096:	b29b      	uxth	r3, r3
 800d098:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 800d09a:	68b8      	ldr	r0, [r7, #8]
 800d09c:	f7fd ff42 	bl	800af24 <lv_obj_get_height>
 800d0a0:	4603      	mov	r3, r0
 800d0a2:	b29a      	uxth	r2, r3
 800d0a4:	8c3b      	ldrh	r3, [r7, #32]
 800d0a6:	1ad3      	subs	r3, r2, r3
 800d0a8:	b29b      	uxth	r3, r3
 800d0aa:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d0ac:	e073      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 800d0ae:	68b8      	ldr	r0, [r7, #8]
 800d0b0:	f7fd ff14 	bl	800aedc <lv_obj_get_width>
 800d0b4:	4603      	mov	r3, r0
 800d0b6:	b29a      	uxth	r2, r3
 800d0b8:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d0ba:	1ad3      	subs	r3, r2, r3
 800d0bc:	b29b      	uxth	r3, r3
 800d0be:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 800d0c0:	68b8      	ldr	r0, [r7, #8]
 800d0c2:	f7fd ff2f 	bl	800af24 <lv_obj_get_height>
 800d0c6:	4603      	mov	r3, r0
 800d0c8:	b29a      	uxth	r2, r3
 800d0ca:	8c3b      	ldrh	r3, [r7, #32]
 800d0cc:	1ad3      	subs	r3, r2, r3
 800d0ce:	b29b      	uxth	r3, r3
 800d0d0:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d0d2:	e060      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_LEFT_TOP:
            new_x = -obj_w_half;
 800d0d4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d0d6:	425b      	negs	r3, r3
 800d0d8:	b29b      	uxth	r3, r3
 800d0da:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 800d0dc:	8c3b      	ldrh	r3, [r7, #32]
 800d0de:	425b      	negs	r3, r3
 800d0e0:	b29b      	uxth	r3, r3
 800d0e2:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d0e4:	e057      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_LEFT_MID:
            new_x = -obj_w_half;
 800d0e6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d0e8:	425b      	negs	r3, r3
 800d0ea:	b29b      	uxth	r3, r3
 800d0ec:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 800d0ee:	68b8      	ldr	r0, [r7, #8]
 800d0f0:	f7fd ff18 	bl	800af24 <lv_obj_get_height>
 800d0f4:	4603      	mov	r3, r0
 800d0f6:	0fda      	lsrs	r2, r3, #31
 800d0f8:	4413      	add	r3, r2
 800d0fa:	105b      	asrs	r3, r3, #1
 800d0fc:	b21b      	sxth	r3, r3
 800d0fe:	b29a      	uxth	r2, r3
 800d100:	8c3b      	ldrh	r3, [r7, #32]
 800d102:	1ad3      	subs	r3, r2, r3
 800d104:	b29b      	uxth	r3, r3
 800d106:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d108:	e045      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_LEFT_BOTTOM:
            new_x = -obj_w_half;
 800d10a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d10c:	425b      	negs	r3, r3
 800d10e:	b29b      	uxth	r3, r3
 800d110:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 800d112:	68b8      	ldr	r0, [r7, #8]
 800d114:	f7fd ff06 	bl	800af24 <lv_obj_get_height>
 800d118:	4603      	mov	r3, r0
 800d11a:	b29a      	uxth	r2, r3
 800d11c:	8c3b      	ldrh	r3, [r7, #32]
 800d11e:	1ad3      	subs	r3, r2, r3
 800d120:	b29b      	uxth	r3, r3
 800d122:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d124:	e037      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_RIGHT_TOP:
            new_x = lv_obj_get_width(base) - obj_w_half;
 800d126:	68b8      	ldr	r0, [r7, #8]
 800d128:	f7fd fed8 	bl	800aedc <lv_obj_get_width>
 800d12c:	4603      	mov	r3, r0
 800d12e:	b29a      	uxth	r2, r3
 800d130:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d132:	1ad3      	subs	r3, r2, r3
 800d134:	b29b      	uxth	r3, r3
 800d136:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 800d138:	8c3b      	ldrh	r3, [r7, #32]
 800d13a:	425b      	negs	r3, r3
 800d13c:	b29b      	uxth	r3, r3
 800d13e:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d140:	e029      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_RIGHT_MID:
            new_x = lv_obj_get_width(base) - obj_w_half;
 800d142:	68b8      	ldr	r0, [r7, #8]
 800d144:	f7fd feca 	bl	800aedc <lv_obj_get_width>
 800d148:	4603      	mov	r3, r0
 800d14a:	b29a      	uxth	r2, r3
 800d14c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d14e:	1ad3      	subs	r3, r2, r3
 800d150:	b29b      	uxth	r3, r3
 800d152:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 800d154:	68b8      	ldr	r0, [r7, #8]
 800d156:	f7fd fee5 	bl	800af24 <lv_obj_get_height>
 800d15a:	4603      	mov	r3, r0
 800d15c:	0fda      	lsrs	r2, r3, #31
 800d15e:	4413      	add	r3, r2
 800d160:	105b      	asrs	r3, r3, #1
 800d162:	b21b      	sxth	r3, r3
 800d164:	b29a      	uxth	r2, r3
 800d166:	8c3b      	ldrh	r3, [r7, #32]
 800d168:	1ad3      	subs	r3, r2, r3
 800d16a:	b29b      	uxth	r3, r3
 800d16c:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d16e:	e012      	b.n	800d196 <obj_align_mid_core+0x37a>

        case LV_ALIGN_OUT_RIGHT_BOTTOM:
            new_x = lv_obj_get_width(base) - obj_w_half;
 800d170:	68b8      	ldr	r0, [r7, #8]
 800d172:	f7fd feb3 	bl	800aedc <lv_obj_get_width>
 800d176:	4603      	mov	r3, r0
 800d178:	b29a      	uxth	r2, r3
 800d17a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d17c:	1ad3      	subs	r3, r2, r3
 800d17e:	b29b      	uxth	r3, r3
 800d180:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 800d182:	68b8      	ldr	r0, [r7, #8]
 800d184:	f7fd fece 	bl	800af24 <lv_obj_get_height>
 800d188:	4603      	mov	r3, r0
 800d18a:	b29a      	uxth	r2, r3
 800d18c:	8c3b      	ldrh	r3, [r7, #32]
 800d18e:	1ad3      	subs	r3, r2, r3
 800d190:	b29b      	uxth	r3, r3
 800d192:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 800d194:	bf00      	nop
    }

    /*Bring together the coordination system of base and obj*/
    lv_obj_t * par        = lv_obj_get_parent(obj);
 800d196:	68f8      	ldr	r0, [r7, #12]
 800d198:	f7fd fdbe 	bl	800ad18 <lv_obj_get_parent>
 800d19c:	61f8      	str	r0, [r7, #28]
    lv_coord_t base_abs_x = base->coords.x1;
 800d19e:	68bb      	ldr	r3, [r7, #8]
 800d1a0:	8a1b      	ldrh	r3, [r3, #16]
 800d1a2:	837b      	strh	r3, [r7, #26]
    lv_coord_t base_abs_y = base->coords.y1;
 800d1a4:	68bb      	ldr	r3, [r7, #8]
 800d1a6:	8a5b      	ldrh	r3, [r3, #18]
 800d1a8:	833b      	strh	r3, [r7, #24]
    lv_coord_t par_abs_x  = par->coords.x1;
 800d1aa:	69fb      	ldr	r3, [r7, #28]
 800d1ac:	8a1b      	ldrh	r3, [r3, #16]
 800d1ae:	82fb      	strh	r3, [r7, #22]
    lv_coord_t par_abs_y  = par->coords.y1;
 800d1b0:	69fb      	ldr	r3, [r7, #28]
 800d1b2:	8a5b      	ldrh	r3, [r3, #18]
 800d1b4:	82bb      	strh	r3, [r7, #20]
    new_x += x_ofs + base_abs_x;
 800d1b6:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 800d1b8:	8b7b      	ldrh	r3, [r7, #26]
 800d1ba:	4413      	add	r3, r2
 800d1bc:	b29a      	uxth	r2, r3
 800d1be:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800d1c0:	4413      	add	r3, r2
 800d1c2:	b29b      	uxth	r3, r3
 800d1c4:	84fb      	strh	r3, [r7, #38]	; 0x26
    new_y += y_ofs + base_abs_y;
 800d1c6:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 800d1c8:	8b3b      	ldrh	r3, [r7, #24]
 800d1ca:	4413      	add	r3, r2
 800d1cc:	b29a      	uxth	r2, r3
 800d1ce:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d1d0:	4413      	add	r3, r2
 800d1d2:	b29b      	uxth	r3, r3
 800d1d4:	84bb      	strh	r3, [r7, #36]	; 0x24
    new_x -= par_abs_x;
 800d1d6:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 800d1d8:	8afb      	ldrh	r3, [r7, #22]
 800d1da:	1ad3      	subs	r3, r2, r3
 800d1dc:	b29b      	uxth	r3, r3
 800d1de:	84fb      	strh	r3, [r7, #38]	; 0x26
    new_y -= par_abs_y;
 800d1e0:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 800d1e2:	8abb      	ldrh	r3, [r7, #20]
 800d1e4:	1ad3      	subs	r3, r2, r3
 800d1e6:	b29b      	uxth	r3, r3
 800d1e8:	84bb      	strh	r3, [r7, #36]	; 0x24
    if(x_set && y_set) lv_obj_set_pos(obj, new_x, new_y);
 800d1ea:	79bb      	ldrb	r3, [r7, #6]
 800d1ec:	2b00      	cmp	r3, #0
 800d1ee:	d00c      	beq.n	800d20a <obj_align_mid_core+0x3ee>
 800d1f0:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800d1f4:	2b00      	cmp	r3, #0
 800d1f6:	d008      	beq.n	800d20a <obj_align_mid_core+0x3ee>
 800d1f8:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 800d1fc:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 800d200:	4619      	mov	r1, r3
 800d202:	68f8      	ldr	r0, [r7, #12]
 800d204:	f7fc fd24 	bl	8009c50 <lv_obj_set_pos>
    else if(x_set) lv_obj_set_x(obj, new_x);
    else if(y_set) lv_obj_set_y(obj, new_y);

}
 800d208:	e013      	b.n	800d232 <obj_align_mid_core+0x416>
    else if(x_set) lv_obj_set_x(obj, new_x);
 800d20a:	79bb      	ldrb	r3, [r7, #6]
 800d20c:	2b00      	cmp	r3, #0
 800d20e:	d006      	beq.n	800d21e <obj_align_mid_core+0x402>
 800d210:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 800d214:	4619      	mov	r1, r3
 800d216:	68f8      	ldr	r0, [r7, #12]
 800d218:	f7fc fdc0 	bl	8009d9c <lv_obj_set_x>
}
 800d21c:	e009      	b.n	800d232 <obj_align_mid_core+0x416>
    else if(y_set) lv_obj_set_y(obj, new_y);
 800d21e:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 800d222:	2b00      	cmp	r3, #0
 800d224:	d005      	beq.n	800d232 <obj_align_mid_core+0x416>
 800d226:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 800d22a:	4619      	mov	r1, r3
 800d22c:	68f8      	ldr	r0, [r7, #12]
 800d22e:	f7fc fddf 	bl	8009df0 <lv_obj_set_y>
}
 800d232:	bf00      	nop
 800d234:	3728      	adds	r7, #40	; 0x28
 800d236:	46bd      	mov	sp, r7
 800d238:	bd80      	pop	{r7, pc}
 800d23a:	bf00      	nop

0800d23c <trans_create>:
 * @param new_state the new state of the object
 * @return pointer to the allocated `the transaction` variable or `NULL` if no transition created
 */
static lv_style_trans_t * trans_create(lv_obj_t * obj, lv_style_property_t prop, uint8_t part, lv_state_t prev_state,
                                       lv_state_t new_state)
{
 800d23c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800d240:	b08e      	sub	sp, #56	; 0x38
 800d242:	af00      	add	r7, sp, #0
 800d244:	60f8      	str	r0, [r7, #12]
 800d246:	4608      	mov	r0, r1
 800d248:	4611      	mov	r1, r2
 800d24a:	461a      	mov	r2, r3
 800d24c:	4603      	mov	r3, r0
 800d24e:	817b      	strh	r3, [r7, #10]
 800d250:	460b      	mov	r3, r1
 800d252:	727b      	strb	r3, [r7, #9]
 800d254:	4613      	mov	r3, r2
 800d256:	723b      	strb	r3, [r7, #8]
    lv_style_trans_t * tr;
    lv_style_list_t * style_list = lv_obj_get_style_list(obj, part);
 800d258:	7a7b      	ldrb	r3, [r7, #9]
 800d25a:	4619      	mov	r1, r3
 800d25c:	68f8      	ldr	r0, [r7, #12]
 800d25e:	f7fd fee3 	bl	800b028 <lv_obj_get_style_list>
 800d262:	62f8      	str	r0, [r7, #44]	; 0x2c
    lv_style_t * style_trans = _lv_style_list_get_transition_style(style_list);
 800d264:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800d266:	f002 fe28 	bl	800feba <_lv_style_list_get_transition_style>
 800d26a:	62b8      	str	r0, [r7, #40]	; 0x28

    /*Get the previous and current values*/
    if((prop & 0xF) < LV_STYLE_ID_COLOR) { /*Int*/
 800d26c:	897b      	ldrh	r3, [r7, #10]
 800d26e:	f003 030f 	and.w	r3, r3, #15
 800d272:	2b08      	cmp	r3, #8
 800d274:	f300 80b1 	bgt.w	800d3da <trans_create+0x19e>
        style_list->skip_trans = 1;
 800d278:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d27a:	7953      	ldrb	r3, [r2, #5]
 800d27c:	f043 0301 	orr.w	r3, r3, #1
 800d280:	7153      	strb	r3, [r2, #5]
        obj->state = prev_state;
 800d282:	68fb      	ldr	r3, [r7, #12]
 800d284:	7a3a      	ldrb	r2, [r7, #8]
 800d286:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        lv_style_int_t int1 = _lv_obj_get_style_int(obj, part, prop);
 800d28a:	897a      	ldrh	r2, [r7, #10]
 800d28c:	7a7b      	ldrb	r3, [r7, #9]
 800d28e:	4619      	mov	r1, r3
 800d290:	68f8      	ldr	r0, [r7, #12]
 800d292:	f7fd feed 	bl	800b070 <_lv_obj_get_style_int>
 800d296:	4603      	mov	r3, r0
 800d298:	867b      	strh	r3, [r7, #50]	; 0x32
        obj->state = new_state;
 800d29a:	68fb      	ldr	r3, [r7, #12]
 800d29c:	f897 2058 	ldrb.w	r2, [r7, #88]	; 0x58
 800d2a0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        lv_style_int_t int2 =  _lv_obj_get_style_int(obj, part, prop);
 800d2a4:	897a      	ldrh	r2, [r7, #10]
 800d2a6:	7a7b      	ldrb	r3, [r7, #9]
 800d2a8:	4619      	mov	r1, r3
 800d2aa:	68f8      	ldr	r0, [r7, #12]
 800d2ac:	f7fd fee0 	bl	800b070 <_lv_obj_get_style_int>
 800d2b0:	4603      	mov	r3, r0
 800d2b2:	863b      	strh	r3, [r7, #48]	; 0x30
        style_list->skip_trans = 0;
 800d2b4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d2b6:	7953      	ldrb	r3, [r2, #5]
 800d2b8:	f36f 0300 	bfc	r3, #0, #1
 800d2bc:	7153      	strb	r3, [r2, #5]

        if(int1 == int2)  return NULL;
 800d2be:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 800d2c2:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 800d2c6:	429a      	cmp	r2, r3
 800d2c8:	d101      	bne.n	800d2ce <trans_create+0x92>
 800d2ca:	2300      	movs	r3, #0
 800d2cc:	e1cb      	b.n	800d666 <trans_create+0x42a>
        obj->state = prev_state;
 800d2ce:	68fb      	ldr	r3, [r7, #12]
 800d2d0:	7a3a      	ldrb	r2, [r7, #8]
 800d2d2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        int1 = _lv_obj_get_style_int(obj, part, prop);
 800d2d6:	897a      	ldrh	r2, [r7, #10]
 800d2d8:	7a7b      	ldrb	r3, [r7, #9]
 800d2da:	4619      	mov	r1, r3
 800d2dc:	68f8      	ldr	r0, [r7, #12]
 800d2de:	f7fd fec7 	bl	800b070 <_lv_obj_get_style_int>
 800d2e2:	4603      	mov	r3, r0
 800d2e4:	867b      	strh	r3, [r7, #50]	; 0x32
        obj->state = new_state;
 800d2e6:	68fb      	ldr	r3, [r7, #12]
 800d2e8:	f897 2058 	ldrb.w	r2, [r7, #88]	; 0x58
 800d2ec:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        _lv_style_set_int(style_trans, prop, int1);   /*Be sure `trans_style` has a valid value */
 800d2f0:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 800d2f4:	897b      	ldrh	r3, [r7, #10]
 800d2f6:	4619      	mov	r1, r3
 800d2f8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d2fa:	f002 fa6d 	bl	800f7d8 <_lv_style_set_int>

        if(prop == LV_STYLE_RADIUS) {
 800d2fe:	897b      	ldrh	r3, [r7, #10]
 800d300:	2b01      	cmp	r3, #1
 800d302:	d147      	bne.n	800d394 <trans_create+0x158>
            if(int1 == LV_RADIUS_CIRCLE || int2 == LV_RADIUS_CIRCLE) {
 800d304:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 800d308:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800d30c:	4293      	cmp	r3, r2
 800d30e:	d005      	beq.n	800d31c <trans_create+0xe0>
 800d310:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 800d314:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800d318:	4293      	cmp	r3, r2
 800d31a:	d13b      	bne.n	800d394 <trans_create+0x158>
                lv_coord_t whalf = lv_obj_get_width(obj) / 2;
 800d31c:	68f8      	ldr	r0, [r7, #12]
 800d31e:	f7fd fddd 	bl	800aedc <lv_obj_get_width>
 800d322:	4603      	mov	r3, r0
 800d324:	0fda      	lsrs	r2, r3, #31
 800d326:	4413      	add	r3, r2
 800d328:	105b      	asrs	r3, r3, #1
 800d32a:	84bb      	strh	r3, [r7, #36]	; 0x24
                lv_coord_t hhalf = lv_obj_get_width(obj) / 2;
 800d32c:	68f8      	ldr	r0, [r7, #12]
 800d32e:	f7fd fdd5 	bl	800aedc <lv_obj_get_width>
 800d332:	4603      	mov	r3, r0
 800d334:	0fda      	lsrs	r2, r3, #31
 800d336:	4413      	add	r3, r2
 800d338:	105b      	asrs	r3, r3, #1
 800d33a:	847b      	strh	r3, [r7, #34]	; 0x22
                if(int1 == LV_RADIUS_CIRCLE) int1 = LV_MATH_MIN(whalf + 1, hhalf + 1);
 800d33c:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 800d340:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800d344:	4293      	cmp	r3, r2
 800d346:	d10f      	bne.n	800d368 <trans_create+0x12c>
 800d348:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 800d34c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 800d350:	429a      	cmp	r2, r3
 800d352:	da04      	bge.n	800d35e <trans_create+0x122>
 800d354:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d356:	3301      	adds	r3, #1
 800d358:	b29b      	uxth	r3, r3
 800d35a:	b21b      	sxth	r3, r3
 800d35c:	e003      	b.n	800d366 <trans_create+0x12a>
 800d35e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d360:	3301      	adds	r3, #1
 800d362:	b29b      	uxth	r3, r3
 800d364:	b21b      	sxth	r3, r3
 800d366:	867b      	strh	r3, [r7, #50]	; 0x32
                if(int2 == LV_RADIUS_CIRCLE) int2 = LV_MATH_MIN(whalf + 1, hhalf + 1);
 800d368:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 800d36c:	f647 72ff 	movw	r2, #32767	; 0x7fff
 800d370:	4293      	cmp	r3, r2
 800d372:	d10f      	bne.n	800d394 <trans_create+0x158>
 800d374:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 800d378:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 800d37c:	429a      	cmp	r2, r3
 800d37e:	da04      	bge.n	800d38a <trans_create+0x14e>
 800d380:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800d382:	3301      	adds	r3, #1
 800d384:	b29b      	uxth	r3, r3
 800d386:	b21b      	sxth	r3, r3
 800d388:	e003      	b.n	800d392 <trans_create+0x156>
 800d38a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800d38c:	3301      	adds	r3, #1
 800d38e:	b29b      	uxth	r3, r3
 800d390:	b21b      	sxth	r3, r3
 800d392:	863b      	strh	r3, [r7, #48]	; 0x30
            }
        }

        tr = _lv_ll_ins_head(&LV_GC_ROOT(_lv_obj_style_trans_ll));
 800d394:	48ae      	ldr	r0, [pc, #696]	; (800d650 <trans_create+0x414>)
 800d396:	f013 f904 	bl	80205a2 <_lv_ll_ins_head>
 800d39a:	6378      	str	r0, [r7, #52]	; 0x34
        LV_ASSERT_MEM(tr);
 800d39c:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800d39e:	f012 fea7 	bl	80200f0 <lv_debug_check_null>
 800d3a2:	4603      	mov	r3, r0
 800d3a4:	f083 0301 	eor.w	r3, r3, #1
 800d3a8:	b2db      	uxtb	r3, r3
 800d3aa:	2b00      	cmp	r3, #0
 800d3ac:	d009      	beq.n	800d3c2 <trans_create+0x186>
 800d3ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d3b0:	2200      	movs	r2, #0
 800d3b2:	603b      	str	r3, [r7, #0]
 800d3b4:	607a      	str	r2, [r7, #4]
 800d3b6:	e9d7 2300 	ldrd	r2, r3, [r7]
 800d3ba:	48a6      	ldr	r0, [pc, #664]	; (800d654 <trans_create+0x418>)
 800d3bc:	f012 fea8 	bl	8020110 <lv_debug_log_error>
 800d3c0:	e7fe      	b.n	800d3c0 <trans_create+0x184>
        if(tr == NULL) return NULL;
 800d3c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d3c4:	2b00      	cmp	r3, #0
 800d3c6:	d101      	bne.n	800d3cc <trans_create+0x190>
 800d3c8:	2300      	movs	r3, #0
 800d3ca:	e14c      	b.n	800d666 <trans_create+0x42a>
        tr->start_value._int = int1;
 800d3cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d3ce:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
 800d3d0:	811a      	strh	r2, [r3, #8]
        tr->end_value._int = int2;
 800d3d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d3d4:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 800d3d6:	819a      	strh	r2, [r3, #12]
 800d3d8:	e144      	b.n	800d664 <trans_create+0x428>
    }
    else if((prop & 0xF) < LV_STYLE_ID_OPA) { /*Color*/
 800d3da:	897b      	ldrh	r3, [r7, #10]
 800d3dc:	f003 030f 	and.w	r3, r3, #15
 800d3e0:	2b0b      	cmp	r3, #11
 800d3e2:	dc62      	bgt.n	800d4aa <trans_create+0x26e>
        style_list->skip_trans = 1;
 800d3e4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d3e6:	7953      	ldrb	r3, [r2, #5]
 800d3e8:	f043 0301 	orr.w	r3, r3, #1
 800d3ec:	7153      	strb	r3, [r2, #5]
        obj->state = prev_state;
 800d3ee:	68fb      	ldr	r3, [r7, #12]
 800d3f0:	7a3a      	ldrb	r2, [r7, #8]
 800d3f2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        lv_color_t c1 = _lv_obj_get_style_color(obj, part, prop);
 800d3f6:	897a      	ldrh	r2, [r7, #10]
 800d3f8:	7a7b      	ldrb	r3, [r7, #9]
 800d3fa:	4619      	mov	r1, r3
 800d3fc:	68f8      	ldr	r0, [r7, #12]
 800d3fe:	f7fe f84b 	bl	800b498 <_lv_obj_get_style_color>
 800d402:	4603      	mov	r3, r0
 800d404:	843b      	strh	r3, [r7, #32]
        obj->state = new_state;
 800d406:	68fb      	ldr	r3, [r7, #12]
 800d408:	f897 2058 	ldrb.w	r2, [r7, #88]	; 0x58
 800d40c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        lv_color_t c2 =  _lv_obj_get_style_color(obj, part, prop);
 800d410:	897a      	ldrh	r2, [r7, #10]
 800d412:	7a7b      	ldrb	r3, [r7, #9]
 800d414:	4619      	mov	r1, r3
 800d416:	68f8      	ldr	r0, [r7, #12]
 800d418:	f7fe f83e 	bl	800b498 <_lv_obj_get_style_color>
 800d41c:	4603      	mov	r3, r0
 800d41e:	83bb      	strh	r3, [r7, #28]
        style_list->skip_trans = 0;
 800d420:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d422:	7953      	ldrb	r3, [r2, #5]
 800d424:	f36f 0300 	bfc	r3, #0, #1
 800d428:	7153      	strb	r3, [r2, #5]

        if(c1.full == c2.full) return NULL;
 800d42a:	8c3a      	ldrh	r2, [r7, #32]
 800d42c:	8bbb      	ldrh	r3, [r7, #28]
 800d42e:	429a      	cmp	r2, r3
 800d430:	d101      	bne.n	800d436 <trans_create+0x1fa>
 800d432:	2300      	movs	r3, #0
 800d434:	e117      	b.n	800d666 <trans_create+0x42a>
        obj->state = prev_state;
 800d436:	68fb      	ldr	r3, [r7, #12]
 800d438:	7a3a      	ldrb	r2, [r7, #8]
 800d43a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        c1 = _lv_obj_get_style_color(obj, part, prop);
 800d43e:	897a      	ldrh	r2, [r7, #10]
 800d440:	7a7b      	ldrb	r3, [r7, #9]
 800d442:	4619      	mov	r1, r3
 800d444:	68f8      	ldr	r0, [r7, #12]
 800d446:	f7fe f827 	bl	800b498 <_lv_obj_get_style_color>
 800d44a:	4603      	mov	r3, r0
 800d44c:	843b      	strh	r3, [r7, #32]
        obj->state = new_state;
 800d44e:	68fb      	ldr	r3, [r7, #12]
 800d450:	f897 2058 	ldrb.w	r2, [r7, #88]	; 0x58
 800d454:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        _lv_style_set_color(style_trans, prop, c1);    /*Be sure `trans_style` has a valid value */
 800d458:	897b      	ldrh	r3, [r7, #10]
 800d45a:	8c3a      	ldrh	r2, [r7, #32]
 800d45c:	4619      	mov	r1, r3
 800d45e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d460:	f002 fa4a 	bl	800f8f8 <_lv_style_set_color>

        tr = _lv_ll_ins_head(&LV_GC_ROOT(_lv_obj_style_trans_ll));
 800d464:	487a      	ldr	r0, [pc, #488]	; (800d650 <trans_create+0x414>)
 800d466:	f013 f89c 	bl	80205a2 <_lv_ll_ins_head>
 800d46a:	6378      	str	r0, [r7, #52]	; 0x34
        LV_ASSERT_MEM(tr);
 800d46c:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800d46e:	f012 fe3f 	bl	80200f0 <lv_debug_check_null>
 800d472:	4603      	mov	r3, r0
 800d474:	f083 0301 	eor.w	r3, r3, #1
 800d478:	b2db      	uxtb	r3, r3
 800d47a:	2b00      	cmp	r3, #0
 800d47c:	d009      	beq.n	800d492 <trans_create+0x256>
 800d47e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d480:	2200      	movs	r2, #0
 800d482:	469a      	mov	sl, r3
 800d484:	4693      	mov	fp, r2
 800d486:	4652      	mov	r2, sl
 800d488:	465b      	mov	r3, fp
 800d48a:	4872      	ldr	r0, [pc, #456]	; (800d654 <trans_create+0x418>)
 800d48c:	f012 fe40 	bl	8020110 <lv_debug_log_error>
 800d490:	e7fe      	b.n	800d490 <trans_create+0x254>
        if(tr == NULL) return NULL;
 800d492:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d494:	2b00      	cmp	r3, #0
 800d496:	d101      	bne.n	800d49c <trans_create+0x260>
 800d498:	2300      	movs	r3, #0
 800d49a:	e0e4      	b.n	800d666 <trans_create+0x42a>
        tr->start_value._color = c1;
 800d49c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d49e:	8c3a      	ldrh	r2, [r7, #32]
 800d4a0:	811a      	strh	r2, [r3, #8]
        tr->end_value._color = c2;
 800d4a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d4a4:	8bba      	ldrh	r2, [r7, #28]
 800d4a6:	819a      	strh	r2, [r3, #12]
 800d4a8:	e0dc      	b.n	800d664 <trans_create+0x428>
    }
    else if((prop & 0xF) < LV_STYLE_ID_PTR) { /*Opa*/
 800d4aa:	897b      	ldrh	r3, [r7, #10]
 800d4ac:	f003 030f 	and.w	r3, r3, #15
 800d4b0:	2b0d      	cmp	r3, #13
 800d4b2:	dc6a      	bgt.n	800d58a <trans_create+0x34e>
        style_list->skip_trans = 1;
 800d4b4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d4b6:	7953      	ldrb	r3, [r2, #5]
 800d4b8:	f043 0301 	orr.w	r3, r3, #1
 800d4bc:	7153      	strb	r3, [r2, #5]
        obj->state = prev_state;
 800d4be:	68fb      	ldr	r3, [r7, #12]
 800d4c0:	7a3a      	ldrb	r2, [r7, #8]
 800d4c2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        lv_opa_t o1 = _lv_obj_get_style_opa(obj, part, prop);
 800d4c6:	897a      	ldrh	r2, [r7, #10]
 800d4c8:	7a7b      	ldrb	r3, [r7, #9]
 800d4ca:	4619      	mov	r1, r3
 800d4cc:	68f8      	ldr	r0, [r7, #12]
 800d4ce:	f7fe f843 	bl	800b558 <_lv_obj_get_style_opa>
 800d4d2:	4603      	mov	r3, r0
 800d4d4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        obj->state = new_state;
 800d4d8:	68fb      	ldr	r3, [r7, #12]
 800d4da:	f897 2058 	ldrb.w	r2, [r7, #88]	; 0x58
 800d4de:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        lv_opa_t o2 =  _lv_obj_get_style_opa(obj, part, prop);
 800d4e2:	897a      	ldrh	r2, [r7, #10]
 800d4e4:	7a7b      	ldrb	r3, [r7, #9]
 800d4e6:	4619      	mov	r1, r3
 800d4e8:	68f8      	ldr	r0, [r7, #12]
 800d4ea:	f7fe f835 	bl	800b558 <_lv_obj_get_style_opa>
 800d4ee:	4603      	mov	r3, r0
 800d4f0:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
        style_list->skip_trans = 0;
 800d4f4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d4f6:	7953      	ldrb	r3, [r2, #5]
 800d4f8:	f36f 0300 	bfc	r3, #0, #1
 800d4fc:	7153      	strb	r3, [r2, #5]

        if(o1 == o2) return NULL;
 800d4fe:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800d502:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 800d506:	429a      	cmp	r2, r3
 800d508:	d101      	bne.n	800d50e <trans_create+0x2d2>
 800d50a:	2300      	movs	r3, #0
 800d50c:	e0ab      	b.n	800d666 <trans_create+0x42a>

        obj->state = prev_state;
 800d50e:	68fb      	ldr	r3, [r7, #12]
 800d510:	7a3a      	ldrb	r2, [r7, #8]
 800d512:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        o1 = _lv_obj_get_style_opa(obj, part, prop);
 800d516:	897a      	ldrh	r2, [r7, #10]
 800d518:	7a7b      	ldrb	r3, [r7, #9]
 800d51a:	4619      	mov	r1, r3
 800d51c:	68f8      	ldr	r0, [r7, #12]
 800d51e:	f7fe f81b 	bl	800b558 <_lv_obj_get_style_opa>
 800d522:	4603      	mov	r3, r0
 800d524:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        obj->state = new_state;
 800d528:	68fb      	ldr	r3, [r7, #12]
 800d52a:	f897 2058 	ldrb.w	r2, [r7, #88]	; 0x58
 800d52e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        _lv_style_set_opa(style_trans, prop, o1);   /*Be sure `trans_style` has a valid value */
 800d532:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800d536:	897b      	ldrh	r3, [r7, #10]
 800d538:	4619      	mov	r1, r3
 800d53a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d53c:	f002 fa6c 	bl	800fa18 <_lv_style_set_opa>

        tr = _lv_ll_ins_head(&LV_GC_ROOT(_lv_obj_style_trans_ll));
 800d540:	4843      	ldr	r0, [pc, #268]	; (800d650 <trans_create+0x414>)
 800d542:	f013 f82e 	bl	80205a2 <_lv_ll_ins_head>
 800d546:	6378      	str	r0, [r7, #52]	; 0x34
        LV_ASSERT_MEM(tr);
 800d548:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800d54a:	f012 fdd1 	bl	80200f0 <lv_debug_check_null>
 800d54e:	4603      	mov	r3, r0
 800d550:	f083 0301 	eor.w	r3, r3, #1
 800d554:	b2db      	uxtb	r3, r3
 800d556:	2b00      	cmp	r3, #0
 800d558:	d009      	beq.n	800d56e <trans_create+0x332>
 800d55a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d55c:	2200      	movs	r2, #0
 800d55e:	4698      	mov	r8, r3
 800d560:	4691      	mov	r9, r2
 800d562:	4642      	mov	r2, r8
 800d564:	464b      	mov	r3, r9
 800d566:	483b      	ldr	r0, [pc, #236]	; (800d654 <trans_create+0x418>)
 800d568:	f012 fdd2 	bl	8020110 <lv_debug_log_error>
 800d56c:	e7fe      	b.n	800d56c <trans_create+0x330>
        if(tr == NULL) return NULL;
 800d56e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d570:	2b00      	cmp	r3, #0
 800d572:	d101      	bne.n	800d578 <trans_create+0x33c>
 800d574:	2300      	movs	r3, #0
 800d576:	e076      	b.n	800d666 <trans_create+0x42a>
        tr->start_value._opa = o1;
 800d578:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d57a:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 800d57e:	721a      	strb	r2, [r3, #8]
        tr->end_value._opa = o2;
 800d580:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d582:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 800d586:	731a      	strb	r2, [r3, #12]
 800d588:	e06c      	b.n	800d664 <trans_create+0x428>
    }
    else {      /*Ptr*/
        obj->state = prev_state;
 800d58a:	68fb      	ldr	r3, [r7, #12]
 800d58c:	7a3a      	ldrb	r2, [r7, #8]
 800d58e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        style_list->skip_trans = 1;
 800d592:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d594:	7953      	ldrb	r3, [r2, #5]
 800d596:	f043 0301 	orr.w	r3, r3, #1
 800d59a:	7153      	strb	r3, [r2, #5]
        const void * p1 = _lv_obj_get_style_ptr(obj, part, prop);
 800d59c:	897a      	ldrh	r2, [r7, #10]
 800d59e:	7a7b      	ldrb	r3, [r7, #9]
 800d5a0:	4619      	mov	r1, r3
 800d5a2:	68f8      	ldr	r0, [r7, #12]
 800d5a4:	f7fe f89c 	bl	800b6e0 <_lv_obj_get_style_ptr>
 800d5a8:	4603      	mov	r3, r0
 800d5aa:	61bb      	str	r3, [r7, #24]
        obj->state = new_state;
 800d5ac:	68fb      	ldr	r3, [r7, #12]
 800d5ae:	f897 2058 	ldrb.w	r2, [r7, #88]	; 0x58
 800d5b2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        const void * p2 = _lv_obj_get_style_ptr(obj, part, prop);
 800d5b6:	897a      	ldrh	r2, [r7, #10]
 800d5b8:	7a7b      	ldrb	r3, [r7, #9]
 800d5ba:	4619      	mov	r1, r3
 800d5bc:	68f8      	ldr	r0, [r7, #12]
 800d5be:	f7fe f88f 	bl	800b6e0 <_lv_obj_get_style_ptr>
 800d5c2:	4603      	mov	r3, r0
 800d5c4:	617b      	str	r3, [r7, #20]
        style_list->skip_trans = 0;
 800d5c6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d5c8:	7953      	ldrb	r3, [r2, #5]
 800d5ca:	f36f 0300 	bfc	r3, #0, #1
 800d5ce:	7153      	strb	r3, [r2, #5]

        if(memcmp(&p1, &p2, sizeof(const void *)) == 0)  return NULL;
 800d5d0:	f107 0114 	add.w	r1, r7, #20
 800d5d4:	f107 0318 	add.w	r3, r7, #24
 800d5d8:	2204      	movs	r2, #4
 800d5da:	4618      	mov	r0, r3
 800d5dc:	f020 fe34 	bl	802e248 <memcmp>
 800d5e0:	4603      	mov	r3, r0
 800d5e2:	2b00      	cmp	r3, #0
 800d5e4:	d101      	bne.n	800d5ea <trans_create+0x3ae>
 800d5e6:	2300      	movs	r3, #0
 800d5e8:	e03d      	b.n	800d666 <trans_create+0x42a>
        obj->state = prev_state;
 800d5ea:	68fb      	ldr	r3, [r7, #12]
 800d5ec:	7a3a      	ldrb	r2, [r7, #8]
 800d5ee:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        p1 = _lv_obj_get_style_ptr(obj, part, prop);
 800d5f2:	897a      	ldrh	r2, [r7, #10]
 800d5f4:	7a7b      	ldrb	r3, [r7, #9]
 800d5f6:	4619      	mov	r1, r3
 800d5f8:	68f8      	ldr	r0, [r7, #12]
 800d5fa:	f7fe f871 	bl	800b6e0 <_lv_obj_get_style_ptr>
 800d5fe:	4603      	mov	r3, r0
 800d600:	61bb      	str	r3, [r7, #24]
        obj->state = new_state;
 800d602:	68fb      	ldr	r3, [r7, #12]
 800d604:	f897 2058 	ldrb.w	r2, [r7, #88]	; 0x58
 800d608:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        _lv_style_set_ptr(style_trans, prop, p1);   /*Be sure `trans_style` has a valid value */
 800d60c:	69ba      	ldr	r2, [r7, #24]
 800d60e:	897b      	ldrh	r3, [r7, #10]
 800d610:	4619      	mov	r1, r3
 800d612:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d614:	f002 fa90 	bl	800fb38 <_lv_style_set_ptr>

        tr = _lv_ll_ins_head(&LV_GC_ROOT(_lv_obj_style_trans_ll));
 800d618:	480d      	ldr	r0, [pc, #52]	; (800d650 <trans_create+0x414>)
 800d61a:	f012 ffc2 	bl	80205a2 <_lv_ll_ins_head>
 800d61e:	6378      	str	r0, [r7, #52]	; 0x34
        LV_ASSERT_MEM(tr);
 800d620:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800d622:	f012 fd65 	bl	80200f0 <lv_debug_check_null>
 800d626:	4603      	mov	r3, r0
 800d628:	f083 0301 	eor.w	r3, r3, #1
 800d62c:	b2db      	uxtb	r3, r3
 800d62e:	2b00      	cmp	r3, #0
 800d630:	d009      	beq.n	800d646 <trans_create+0x40a>
 800d632:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d634:	2200      	movs	r2, #0
 800d636:	461c      	mov	r4, r3
 800d638:	4615      	mov	r5, r2
 800d63a:	4622      	mov	r2, r4
 800d63c:	462b      	mov	r3, r5
 800d63e:	4805      	ldr	r0, [pc, #20]	; (800d654 <trans_create+0x418>)
 800d640:	f012 fd66 	bl	8020110 <lv_debug_log_error>
 800d644:	e7fe      	b.n	800d644 <trans_create+0x408>
        if(tr == NULL) return NULL;
 800d646:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d648:	2b00      	cmp	r3, #0
 800d64a:	d105      	bne.n	800d658 <trans_create+0x41c>
 800d64c:	2300      	movs	r3, #0
 800d64e:	e00a      	b.n	800d666 <trans_create+0x42a>
 800d650:	2000a1c8 	.word	0x2000a1c8
 800d654:	0802e41c 	.word	0x0802e41c
        tr->start_value._ptr = p1;
 800d658:	69ba      	ldr	r2, [r7, #24]
 800d65a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d65c:	609a      	str	r2, [r3, #8]
        tr->end_value._ptr = p2;
 800d65e:	697a      	ldr	r2, [r7, #20]
 800d660:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800d662:	60da      	str	r2, [r3, #12]
    }

    return tr;
 800d664:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 800d666:	4618      	mov	r0, r3
 800d668:	3738      	adds	r7, #56	; 0x38
 800d66a:	46bd      	mov	sp, r7
 800d66c:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0800d670 <trans_del>:
 * @param part a part of object or 0xFF to remove from all parts
 * @param prop a property or 0xFF to remove all properties
 * @param tr_limit delete transitions only "older" then this. `NULL` is not used
 */
static void trans_del(lv_obj_t * obj, uint8_t part, lv_style_property_t prop, lv_style_trans_t * tr_limit)
{
 800d670:	b580      	push	{r7, lr}
 800d672:	b088      	sub	sp, #32
 800d674:	af00      	add	r7, sp, #0
 800d676:	60f8      	str	r0, [r7, #12]
 800d678:	607b      	str	r3, [r7, #4]
 800d67a:	460b      	mov	r3, r1
 800d67c:	72fb      	strb	r3, [r7, #11]
 800d67e:	4613      	mov	r3, r2
 800d680:	813b      	strh	r3, [r7, #8]
    lv_style_trans_t * tr;
    lv_style_trans_t * tr_prev;
    tr = _lv_ll_get_tail(&LV_GC_ROOT(_lv_obj_style_trans_ll));
 800d682:	4826      	ldr	r0, [pc, #152]	; (800d71c <trans_del+0xac>)
 800d684:	f013 f8fd 	bl	8020882 <_lv_ll_get_tail>
 800d688:	61f8      	str	r0, [r7, #28]
    while(tr != NULL) {
 800d68a:	e03d      	b.n	800d708 <trans_del+0x98>
        if(tr == tr_limit) break;
 800d68c:	69fa      	ldr	r2, [r7, #28]
 800d68e:	687b      	ldr	r3, [r7, #4]
 800d690:	429a      	cmp	r2, r3
 800d692:	d03d      	beq.n	800d710 <trans_del+0xa0>

        /*'tr' might be deleted, so get the next object while 'tr' is valid*/
        tr_prev = _lv_ll_get_prev(&LV_GC_ROOT(_lv_obj_style_trans_ll), tr);
 800d694:	69f9      	ldr	r1, [r7, #28]
 800d696:	4821      	ldr	r0, [pc, #132]	; (800d71c <trans_del+0xac>)
 800d698:	f013 f920 	bl	80208dc <_lv_ll_get_prev>
 800d69c:	61b8      	str	r0, [r7, #24]

        if(tr->obj == obj && (part == tr->part || part == 0xFF) && (prop == tr->prop || prop == 0xFF)) {
 800d69e:	69fb      	ldr	r3, [r7, #28]
 800d6a0:	681b      	ldr	r3, [r3, #0]
 800d6a2:	68fa      	ldr	r2, [r7, #12]
 800d6a4:	429a      	cmp	r2, r3
 800d6a6:	d12d      	bne.n	800d704 <trans_del+0x94>
 800d6a8:	69fb      	ldr	r3, [r7, #28]
 800d6aa:	799b      	ldrb	r3, [r3, #6]
 800d6ac:	7afa      	ldrb	r2, [r7, #11]
 800d6ae:	429a      	cmp	r2, r3
 800d6b0:	d002      	beq.n	800d6b8 <trans_del+0x48>
 800d6b2:	7afb      	ldrb	r3, [r7, #11]
 800d6b4:	2bff      	cmp	r3, #255	; 0xff
 800d6b6:	d125      	bne.n	800d704 <trans_del+0x94>
 800d6b8:	69fb      	ldr	r3, [r7, #28]
 800d6ba:	889b      	ldrh	r3, [r3, #4]
 800d6bc:	893a      	ldrh	r2, [r7, #8]
 800d6be:	429a      	cmp	r2, r3
 800d6c0:	d002      	beq.n	800d6c8 <trans_del+0x58>
 800d6c2:	893b      	ldrh	r3, [r7, #8]
 800d6c4:	2bff      	cmp	r3, #255	; 0xff
 800d6c6:	d11d      	bne.n	800d704 <trans_del+0x94>
            /* Remove the transitioned property from trans. style
             * to allow changing it by normal styles*/
            lv_style_list_t * list = lv_obj_get_style_list(tr->obj, tr->part);
 800d6c8:	69fb      	ldr	r3, [r7, #28]
 800d6ca:	681a      	ldr	r2, [r3, #0]
 800d6cc:	69fb      	ldr	r3, [r7, #28]
 800d6ce:	799b      	ldrb	r3, [r3, #6]
 800d6d0:	4619      	mov	r1, r3
 800d6d2:	4610      	mov	r0, r2
 800d6d4:	f7fd fca8 	bl	800b028 <lv_obj_get_style_list>
 800d6d8:	6178      	str	r0, [r7, #20]
            lv_style_t * style_trans = _lv_style_list_get_transition_style(list);
 800d6da:	6978      	ldr	r0, [r7, #20]
 800d6dc:	f002 fbed 	bl	800feba <_lv_style_list_get_transition_style>
 800d6e0:	6138      	str	r0, [r7, #16]
            lv_style_remove_prop(style_trans, tr->prop);
 800d6e2:	69fb      	ldr	r3, [r7, #28]
 800d6e4:	889b      	ldrh	r3, [r3, #4]
 800d6e6:	4619      	mov	r1, r3
 800d6e8:	6938      	ldr	r0, [r7, #16]
 800d6ea:	f001 fd65 	bl	800f1b8 <lv_style_remove_prop>

            lv_anim_del(tr, NULL);
 800d6ee:	2100      	movs	r1, #0
 800d6f0:	69f8      	ldr	r0, [r7, #28]
 800d6f2:	f011 fc0d 	bl	801ef10 <lv_anim_del>
            _lv_ll_remove(&LV_GC_ROOT(_lv_obj_style_trans_ll), tr);
 800d6f6:	69f9      	ldr	r1, [r7, #28]
 800d6f8:	4808      	ldr	r0, [pc, #32]	; (800d71c <trans_del+0xac>)
 800d6fa:	f013 f801 	bl	8020700 <_lv_ll_remove>
            lv_mem_free(tr);
 800d6fe:	69f8      	ldr	r0, [r7, #28]
 800d700:	f013 fab2 	bl	8020c68 <lv_mem_free>
        }
        tr = tr_prev;
 800d704:	69bb      	ldr	r3, [r7, #24]
 800d706:	61fb      	str	r3, [r7, #28]
    while(tr != NULL) {
 800d708:	69fb      	ldr	r3, [r7, #28]
 800d70a:	2b00      	cmp	r3, #0
 800d70c:	d1be      	bne.n	800d68c <trans_del+0x1c>
    }
}
 800d70e:	e000      	b.n	800d712 <trans_del+0xa2>
        if(tr == tr_limit) break;
 800d710:	bf00      	nop
}
 800d712:	bf00      	nop
 800d714:	3720      	adds	r7, #32
 800d716:	46bd      	mov	sp, r7
 800d718:	bd80      	pop	{r7, pc}
 800d71a:	bf00      	nop
 800d71c:	2000a1c8 	.word	0x2000a1c8

0800d720 <trans_anim_cb>:

static void trans_anim_cb(lv_style_trans_t * tr, lv_anim_value_t v)
{
 800d720:	b580      	push	{r7, lr}
 800d722:	b088      	sub	sp, #32
 800d724:	af00      	add	r7, sp, #0
 800d726:	6078      	str	r0, [r7, #4]
 800d728:	460b      	mov	r3, r1
 800d72a:	807b      	strh	r3, [r7, #2]
    lv_style_list_t * list = lv_obj_get_style_list(tr->obj, tr->part);
 800d72c:	687b      	ldr	r3, [r7, #4]
 800d72e:	681a      	ldr	r2, [r3, #0]
 800d730:	687b      	ldr	r3, [r7, #4]
 800d732:	799b      	ldrb	r3, [r3, #6]
 800d734:	4619      	mov	r1, r3
 800d736:	4610      	mov	r0, r2
 800d738:	f7fd fc76 	bl	800b028 <lv_obj_get_style_list>
 800d73c:	6178      	str	r0, [r7, #20]
    lv_style_t * style = _lv_style_list_get_transition_style(list);
 800d73e:	6978      	ldr	r0, [r7, #20]
 800d740:	f002 fbbb 	bl	800feba <_lv_style_list_get_transition_style>
 800d744:	6138      	str	r0, [r7, #16]

    if((tr->prop & 0xF) < LV_STYLE_ID_COLOR) { /*Value*/
 800d746:	687b      	ldr	r3, [r7, #4]
 800d748:	889b      	ldrh	r3, [r3, #4]
 800d74a:	f003 030f 	and.w	r3, r3, #15
 800d74e:	2b08      	cmp	r3, #8
 800d750:	dc2d      	bgt.n	800d7ae <trans_anim_cb+0x8e>
        lv_style_int_t x;
        if(v == 0) x = tr->start_value._int;
 800d752:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800d756:	2b00      	cmp	r3, #0
 800d758:	d103      	bne.n	800d762 <trans_anim_cb+0x42>
 800d75a:	687b      	ldr	r3, [r7, #4]
 800d75c:	891b      	ldrh	r3, [r3, #8]
 800d75e:	83fb      	strh	r3, [r7, #30]
 800d760:	e01c      	b.n	800d79c <trans_anim_cb+0x7c>
        else if(v == 255) x = tr->end_value._int;
 800d762:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800d766:	2bff      	cmp	r3, #255	; 0xff
 800d768:	d103      	bne.n	800d772 <trans_anim_cb+0x52>
 800d76a:	687b      	ldr	r3, [r7, #4]
 800d76c:	899b      	ldrh	r3, [r3, #12]
 800d76e:	83fb      	strh	r3, [r7, #30]
 800d770:	e014      	b.n	800d79c <trans_anim_cb+0x7c>
        else x = tr->start_value._int + ((int32_t)((int32_t)(tr->end_value._int - tr->start_value._int) * v) >> 8);
 800d772:	687b      	ldr	r3, [r7, #4]
 800d774:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 800d778:	b29a      	uxth	r2, r3
 800d77a:	687b      	ldr	r3, [r7, #4]
 800d77c:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800d780:	4619      	mov	r1, r3
 800d782:	687b      	ldr	r3, [r7, #4]
 800d784:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 800d788:	1acb      	subs	r3, r1, r3
 800d78a:	f9b7 1002 	ldrsh.w	r1, [r7, #2]
 800d78e:	fb01 f303 	mul.w	r3, r1, r3
 800d792:	121b      	asrs	r3, r3, #8
 800d794:	b29b      	uxth	r3, r3
 800d796:	4413      	add	r3, r2
 800d798:	b29b      	uxth	r3, r3
 800d79a:	83fb      	strh	r3, [r7, #30]
        _lv_style_set_int(style, tr->prop, x);
 800d79c:	687b      	ldr	r3, [r7, #4]
 800d79e:	889b      	ldrh	r3, [r3, #4]
 800d7a0:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 800d7a4:	4619      	mov	r1, r3
 800d7a6:	6938      	ldr	r0, [r7, #16]
 800d7a8:	f002 f816 	bl	800f7d8 <_lv_style_set_int>
 800d7ac:	e067      	b.n	800d87e <trans_anim_cb+0x15e>
    }
    else if((tr->prop & 0xF) < LV_STYLE_ID_OPA) { /*Color*/
 800d7ae:	687b      	ldr	r3, [r7, #4]
 800d7b0:	889b      	ldrh	r3, [r3, #4]
 800d7b2:	f003 030f 	and.w	r3, r3, #15
 800d7b6:	2b0b      	cmp	r3, #11
 800d7b8:	dc21      	bgt.n	800d7fe <trans_anim_cb+0xde>
        lv_color_t x;
        if(v <= 0) x = tr->start_value._color;
 800d7ba:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800d7be:	2b00      	cmp	r3, #0
 800d7c0:	dc03      	bgt.n	800d7ca <trans_anim_cb+0xaa>
 800d7c2:	687b      	ldr	r3, [r7, #4]
 800d7c4:	891b      	ldrh	r3, [r3, #8]
 800d7c6:	81bb      	strh	r3, [r7, #12]
 800d7c8:	e011      	b.n	800d7ee <trans_anim_cb+0xce>
        else if(v >= 255) x = tr->end_value._color;
 800d7ca:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800d7ce:	2bfe      	cmp	r3, #254	; 0xfe
 800d7d0:	dd03      	ble.n	800d7da <trans_anim_cb+0xba>
 800d7d2:	687b      	ldr	r3, [r7, #4]
 800d7d4:	899b      	ldrh	r3, [r3, #12]
 800d7d6:	81bb      	strh	r3, [r7, #12]
 800d7d8:	e009      	b.n	800d7ee <trans_anim_cb+0xce>
        else x = lv_color_mix(tr->end_value._color, tr->start_value._color, v);
 800d7da:	887b      	ldrh	r3, [r7, #2]
 800d7dc:	b2da      	uxtb	r2, r3
 800d7de:	6879      	ldr	r1, [r7, #4]
 800d7e0:	687b      	ldr	r3, [r7, #4]
 800d7e2:	8909      	ldrh	r1, [r1, #8]
 800d7e4:	8998      	ldrh	r0, [r3, #12]
 800d7e6:	f7fa fec9 	bl	800857c <lv_color_mix>
 800d7ea:	4603      	mov	r3, r0
 800d7ec:	81bb      	strh	r3, [r7, #12]
        _lv_style_set_color(style, tr->prop, x);
 800d7ee:	687b      	ldr	r3, [r7, #4]
 800d7f0:	889b      	ldrh	r3, [r3, #4]
 800d7f2:	89ba      	ldrh	r2, [r7, #12]
 800d7f4:	4619      	mov	r1, r3
 800d7f6:	6938      	ldr	r0, [r7, #16]
 800d7f8:	f002 f87e 	bl	800f8f8 <_lv_style_set_color>
 800d7fc:	e03f      	b.n	800d87e <trans_anim_cb+0x15e>
    }
    else if((tr->prop & 0xF) < LV_STYLE_ID_PTR) { /*Opa*/
 800d7fe:	687b      	ldr	r3, [r7, #4]
 800d800:	889b      	ldrh	r3, [r3, #4]
 800d802:	f003 030f 	and.w	r3, r3, #15
 800d806:	2b0d      	cmp	r3, #13
 800d808:	dc27      	bgt.n	800d85a <trans_anim_cb+0x13a>
        lv_opa_t x;
        if(v <= 0) x = tr->start_value._opa;
 800d80a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800d80e:	2b00      	cmp	r3, #0
 800d810:	dc03      	bgt.n	800d81a <trans_anim_cb+0xfa>
 800d812:	687b      	ldr	r3, [r7, #4]
 800d814:	7a1b      	ldrb	r3, [r3, #8]
 800d816:	777b      	strb	r3, [r7, #29]
 800d818:	e017      	b.n	800d84a <trans_anim_cb+0x12a>
        else if(v >= 255) x = tr->end_value._opa;
 800d81a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800d81e:	2bfe      	cmp	r3, #254	; 0xfe
 800d820:	dd03      	ble.n	800d82a <trans_anim_cb+0x10a>
 800d822:	687b      	ldr	r3, [r7, #4]
 800d824:	7b1b      	ldrb	r3, [r3, #12]
 800d826:	777b      	strb	r3, [r7, #29]
 800d828:	e00f      	b.n	800d84a <trans_anim_cb+0x12a>
        else x = tr->start_value._opa + (((tr->end_value._opa - tr->start_value._opa) * v) >> 8);
 800d82a:	687b      	ldr	r3, [r7, #4]
 800d82c:	7a1a      	ldrb	r2, [r3, #8]
 800d82e:	687b      	ldr	r3, [r7, #4]
 800d830:	7b1b      	ldrb	r3, [r3, #12]
 800d832:	4619      	mov	r1, r3
 800d834:	687b      	ldr	r3, [r7, #4]
 800d836:	7a1b      	ldrb	r3, [r3, #8]
 800d838:	1acb      	subs	r3, r1, r3
 800d83a:	f9b7 1002 	ldrsh.w	r1, [r7, #2]
 800d83e:	fb01 f303 	mul.w	r3, r1, r3
 800d842:	121b      	asrs	r3, r3, #8
 800d844:	b2db      	uxtb	r3, r3
 800d846:	4413      	add	r3, r2
 800d848:	777b      	strb	r3, [r7, #29]
        _lv_style_set_opa(style, tr->prop, x);
 800d84a:	687b      	ldr	r3, [r7, #4]
 800d84c:	889b      	ldrh	r3, [r3, #4]
 800d84e:	7f7a      	ldrb	r2, [r7, #29]
 800d850:	4619      	mov	r1, r3
 800d852:	6938      	ldr	r0, [r7, #16]
 800d854:	f002 f8e0 	bl	800fa18 <_lv_style_set_opa>
 800d858:	e011      	b.n	800d87e <trans_anim_cb+0x15e>
    }
    else {
        const void * x;
        if(v < 128) x = tr->start_value._ptr;
 800d85a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800d85e:	2b7f      	cmp	r3, #127	; 0x7f
 800d860:	dc03      	bgt.n	800d86a <trans_anim_cb+0x14a>
 800d862:	687b      	ldr	r3, [r7, #4]
 800d864:	689b      	ldr	r3, [r3, #8]
 800d866:	61bb      	str	r3, [r7, #24]
 800d868:	e002      	b.n	800d870 <trans_anim_cb+0x150>
        else x = tr->end_value._ptr;
 800d86a:	687b      	ldr	r3, [r7, #4]
 800d86c:	68db      	ldr	r3, [r3, #12]
 800d86e:	61bb      	str	r3, [r7, #24]
        _lv_style_set_ptr(style, tr->prop, x);
 800d870:	687b      	ldr	r3, [r7, #4]
 800d872:	889b      	ldrh	r3, [r3, #4]
 800d874:	69ba      	ldr	r2, [r7, #24]
 800d876:	4619      	mov	r1, r3
 800d878:	6938      	ldr	r0, [r7, #16]
 800d87a:	f002 f95d 	bl	800fb38 <_lv_style_set_ptr>
    }
    lv_obj_refresh_style(tr->obj, tr->part, tr->prop);
 800d87e:	687b      	ldr	r3, [r7, #4]
 800d880:	6818      	ldr	r0, [r3, #0]
 800d882:	687b      	ldr	r3, [r7, #4]
 800d884:	7999      	ldrb	r1, [r3, #6]
 800d886:	687b      	ldr	r3, [r7, #4]
 800d888:	889b      	ldrh	r3, [r3, #4]
 800d88a:	461a      	mov	r2, r3
 800d88c:	f7fc fd38 	bl	800a300 <lv_obj_refresh_style>

}
 800d890:	bf00      	nop
 800d892:	3720      	adds	r7, #32
 800d894:	46bd      	mov	sp, r7
 800d896:	bd80      	pop	{r7, pc}

0800d898 <trans_anim_start_cb>:

static void trans_anim_start_cb(lv_anim_t * a)
{
 800d898:	b590      	push	{r4, r7, lr}
 800d89a:	b085      	sub	sp, #20
 800d89c:	af00      	add	r7, sp, #0
 800d89e:	6078      	str	r0, [r7, #4]
    lv_style_trans_t * tr = a->var;
 800d8a0:	687b      	ldr	r3, [r7, #4]
 800d8a2:	681b      	ldr	r3, [r3, #0]
 800d8a4:	60fb      	str	r3, [r7, #12]

    lv_style_property_t prop_tmp = tr->prop;
 800d8a6:	68fb      	ldr	r3, [r7, #12]
 800d8a8:	889b      	ldrh	r3, [r3, #4]
 800d8aa:	817b      	strh	r3, [r7, #10]

    /*Start the animation from the current value*/
    if((prop_tmp & 0xF) < LV_STYLE_ID_COLOR) { /*Int*/
 800d8ac:	897b      	ldrh	r3, [r7, #10]
 800d8ae:	f003 030f 	and.w	r3, r3, #15
 800d8b2:	2b08      	cmp	r3, #8
 800d8b4:	dc0c      	bgt.n	800d8d0 <trans_anim_start_cb+0x38>
        tr->start_value._int = _lv_obj_get_style_int(tr->obj, tr->part, prop_tmp);
 800d8b6:	68fb      	ldr	r3, [r7, #12]
 800d8b8:	6818      	ldr	r0, [r3, #0]
 800d8ba:	68fb      	ldr	r3, [r7, #12]
 800d8bc:	799b      	ldrb	r3, [r3, #6]
 800d8be:	897a      	ldrh	r2, [r7, #10]
 800d8c0:	4619      	mov	r1, r3
 800d8c2:	f7fd fbd5 	bl	800b070 <_lv_obj_get_style_int>
 800d8c6:	4603      	mov	r3, r0
 800d8c8:	461a      	mov	r2, r3
 800d8ca:	68fb      	ldr	r3, [r7, #12]
 800d8cc:	811a      	strh	r2, [r3, #8]
 800d8ce:	e02c      	b.n	800d92a <trans_anim_start_cb+0x92>
    }
    else if((prop_tmp & 0xF) < LV_STYLE_ID_OPA) { /*Color*/
 800d8d0:	897b      	ldrh	r3, [r7, #10]
 800d8d2:	f003 030f 	and.w	r3, r3, #15
 800d8d6:	2b0b      	cmp	r3, #11
 800d8d8:	dc0a      	bgt.n	800d8f0 <trans_anim_start_cb+0x58>
        tr->start_value._color = _lv_obj_get_style_color(tr->obj, tr->part, prop_tmp);
 800d8da:	68fb      	ldr	r3, [r7, #12]
 800d8dc:	6818      	ldr	r0, [r3, #0]
 800d8de:	68fb      	ldr	r3, [r7, #12]
 800d8e0:	799b      	ldrb	r3, [r3, #6]
 800d8e2:	68fc      	ldr	r4, [r7, #12]
 800d8e4:	897a      	ldrh	r2, [r7, #10]
 800d8e6:	4619      	mov	r1, r3
 800d8e8:	f7fd fdd6 	bl	800b498 <_lv_obj_get_style_color>
 800d8ec:	8120      	strh	r0, [r4, #8]
 800d8ee:	e01c      	b.n	800d92a <trans_anim_start_cb+0x92>
    }
    else if((prop_tmp & 0xF) < LV_STYLE_ID_PTR) { /*Opa*/
 800d8f0:	897b      	ldrh	r3, [r7, #10]
 800d8f2:	f003 030f 	and.w	r3, r3, #15
 800d8f6:	2b0d      	cmp	r3, #13
 800d8f8:	dc0c      	bgt.n	800d914 <trans_anim_start_cb+0x7c>
        tr->start_value._opa = _lv_obj_get_style_opa(tr->obj, tr->part, prop_tmp);
 800d8fa:	68fb      	ldr	r3, [r7, #12]
 800d8fc:	6818      	ldr	r0, [r3, #0]
 800d8fe:	68fb      	ldr	r3, [r7, #12]
 800d900:	799b      	ldrb	r3, [r3, #6]
 800d902:	897a      	ldrh	r2, [r7, #10]
 800d904:	4619      	mov	r1, r3
 800d906:	f7fd fe27 	bl	800b558 <_lv_obj_get_style_opa>
 800d90a:	4603      	mov	r3, r0
 800d90c:	461a      	mov	r2, r3
 800d90e:	68fb      	ldr	r3, [r7, #12]
 800d910:	721a      	strb	r2, [r3, #8]
 800d912:	e00a      	b.n	800d92a <trans_anim_start_cb+0x92>
    }
    else {      /*Ptr*/
        tr->start_value._ptr = _lv_obj_get_style_ptr(tr->obj, tr->part, prop_tmp);
 800d914:	68fb      	ldr	r3, [r7, #12]
 800d916:	6818      	ldr	r0, [r3, #0]
 800d918:	68fb      	ldr	r3, [r7, #12]
 800d91a:	799b      	ldrb	r3, [r3, #6]
 800d91c:	897a      	ldrh	r2, [r7, #10]
 800d91e:	4619      	mov	r1, r3
 800d920:	f7fd fede 	bl	800b6e0 <_lv_obj_get_style_ptr>
 800d924:	4602      	mov	r2, r0
 800d926:	68fb      	ldr	r3, [r7, #12]
 800d928:	609a      	str	r2, [r3, #8]
    }

    /*Init prop to an invalid values to be sure `trans_del` won't delete this added `tr`*/
    tr->prop = 0;
 800d92a:	68fb      	ldr	r3, [r7, #12]
 800d92c:	2200      	movs	r2, #0
 800d92e:	809a      	strh	r2, [r3, #4]
    /*Delete the relate transition if any*/
    trans_del(tr->obj, tr->part, prop_tmp, tr);
 800d930:	68fb      	ldr	r3, [r7, #12]
 800d932:	6818      	ldr	r0, [r3, #0]
 800d934:	68fb      	ldr	r3, [r7, #12]
 800d936:	7999      	ldrb	r1, [r3, #6]
 800d938:	897a      	ldrh	r2, [r7, #10]
 800d93a:	68fb      	ldr	r3, [r7, #12]
 800d93c:	f7ff fe98 	bl	800d670 <trans_del>

    tr->prop = prop_tmp;
 800d940:	68fb      	ldr	r3, [r7, #12]
 800d942:	897a      	ldrh	r2, [r7, #10]
 800d944:	809a      	strh	r2, [r3, #4]

}
 800d946:	bf00      	nop
 800d948:	3714      	adds	r7, #20
 800d94a:	46bd      	mov	sp, r7
 800d94c:	bd90      	pop	{r4, r7, pc}
	...

0800d950 <trans_anim_ready_cb>:

static void trans_anim_ready_cb(lv_anim_t * a)
{
 800d950:	b580      	push	{r7, lr}
 800d952:	b088      	sub	sp, #32
 800d954:	af00      	add	r7, sp, #0
 800d956:	6078      	str	r0, [r7, #4]
    lv_style_trans_t * tr = a->var;
 800d958:	687b      	ldr	r3, [r7, #4]
 800d95a:	681b      	ldr	r3, [r3, #0]
 800d95c:	617b      	str	r3, [r7, #20]

    /* Remove the transitioned property from trans. style
     * if there no more transitions for this property
     * It allows changing it by normal styles*/

    bool running = false;
 800d95e:	2300      	movs	r3, #0
 800d960:	77fb      	strb	r3, [r7, #31]
    lv_style_trans_t * tr_i;
    _LV_LL_READ(LV_GC_ROOT(_lv_obj_style_trans_ll), tr_i) {
 800d962:	4824      	ldr	r0, [pc, #144]	; (800d9f4 <trans_anim_ready_cb+0xa4>)
 800d964:	f012 ff7a 	bl	802085c <_lv_ll_get_head>
 800d968:	61b8      	str	r0, [r7, #24]
 800d96a:	e01c      	b.n	800d9a6 <trans_anim_ready_cb+0x56>
        if(tr_i != tr && tr_i->obj == tr->obj && tr_i->part == tr->part && tr_i->prop == tr->prop) {
 800d96c:	69ba      	ldr	r2, [r7, #24]
 800d96e:	697b      	ldr	r3, [r7, #20]
 800d970:	429a      	cmp	r2, r3
 800d972:	d013      	beq.n	800d99c <trans_anim_ready_cb+0x4c>
 800d974:	69bb      	ldr	r3, [r7, #24]
 800d976:	681a      	ldr	r2, [r3, #0]
 800d978:	697b      	ldr	r3, [r7, #20]
 800d97a:	681b      	ldr	r3, [r3, #0]
 800d97c:	429a      	cmp	r2, r3
 800d97e:	d10d      	bne.n	800d99c <trans_anim_ready_cb+0x4c>
 800d980:	69bb      	ldr	r3, [r7, #24]
 800d982:	799a      	ldrb	r2, [r3, #6]
 800d984:	697b      	ldr	r3, [r7, #20]
 800d986:	799b      	ldrb	r3, [r3, #6]
 800d988:	429a      	cmp	r2, r3
 800d98a:	d107      	bne.n	800d99c <trans_anim_ready_cb+0x4c>
 800d98c:	69bb      	ldr	r3, [r7, #24]
 800d98e:	889a      	ldrh	r2, [r3, #4]
 800d990:	697b      	ldr	r3, [r7, #20]
 800d992:	889b      	ldrh	r3, [r3, #4]
 800d994:	429a      	cmp	r2, r3
 800d996:	d101      	bne.n	800d99c <trans_anim_ready_cb+0x4c>
            running = true;
 800d998:	2301      	movs	r3, #1
 800d99a:	77fb      	strb	r3, [r7, #31]
    _LV_LL_READ(LV_GC_ROOT(_lv_obj_style_trans_ll), tr_i) {
 800d99c:	69b9      	ldr	r1, [r7, #24]
 800d99e:	4815      	ldr	r0, [pc, #84]	; (800d9f4 <trans_anim_ready_cb+0xa4>)
 800d9a0:	f012 ff82 	bl	80208a8 <_lv_ll_get_next>
 800d9a4:	61b8      	str	r0, [r7, #24]
 800d9a6:	69bb      	ldr	r3, [r7, #24]
 800d9a8:	2b00      	cmp	r3, #0
 800d9aa:	d1df      	bne.n	800d96c <trans_anim_ready_cb+0x1c>
        }
    }

    if(!running) {
 800d9ac:	7ffb      	ldrb	r3, [r7, #31]
 800d9ae:	f083 0301 	eor.w	r3, r3, #1
 800d9b2:	b2db      	uxtb	r3, r3
 800d9b4:	2b00      	cmp	r3, #0
 800d9b6:	d012      	beq.n	800d9de <trans_anim_ready_cb+0x8e>
        lv_style_list_t * list = lv_obj_get_style_list(tr->obj, tr->part);
 800d9b8:	697b      	ldr	r3, [r7, #20]
 800d9ba:	681a      	ldr	r2, [r3, #0]
 800d9bc:	697b      	ldr	r3, [r7, #20]
 800d9be:	799b      	ldrb	r3, [r3, #6]
 800d9c0:	4619      	mov	r1, r3
 800d9c2:	4610      	mov	r0, r2
 800d9c4:	f7fd fb30 	bl	800b028 <lv_obj_get_style_list>
 800d9c8:	6138      	str	r0, [r7, #16]
        lv_style_t * style_trans = _lv_style_list_get_transition_style(list);
 800d9ca:	6938      	ldr	r0, [r7, #16]
 800d9cc:	f002 fa75 	bl	800feba <_lv_style_list_get_transition_style>
 800d9d0:	60f8      	str	r0, [r7, #12]
        lv_style_remove_prop(style_trans, tr->prop);
 800d9d2:	697b      	ldr	r3, [r7, #20]
 800d9d4:	889b      	ldrh	r3, [r3, #4]
 800d9d6:	4619      	mov	r1, r3
 800d9d8:	68f8      	ldr	r0, [r7, #12]
 800d9da:	f001 fbed 	bl	800f1b8 <lv_style_remove_prop>
    }

    _lv_ll_remove(&LV_GC_ROOT(_lv_obj_style_trans_ll), tr);
 800d9de:	6979      	ldr	r1, [r7, #20]
 800d9e0:	4804      	ldr	r0, [pc, #16]	; (800d9f4 <trans_anim_ready_cb+0xa4>)
 800d9e2:	f012 fe8d 	bl	8020700 <_lv_ll_remove>
    lv_mem_free(tr);
 800d9e6:	6978      	ldr	r0, [r7, #20]
 800d9e8:	f013 f93e 	bl	8020c68 <lv_mem_free>
}
 800d9ec:	bf00      	nop
 800d9ee:	3720      	adds	r7, #32
 800d9f0:	46bd      	mov	sp, r7
 800d9f2:	bd80      	pop	{r7, pc}
 800d9f4:	2000a1c8 	.word	0x2000a1c8

0800d9f8 <lv_event_mark_deleted>:
}

#endif

static void lv_event_mark_deleted(lv_obj_t * obj)
{
 800d9f8:	b480      	push	{r7}
 800d9fa:	b085      	sub	sp, #20
 800d9fc:	af00      	add	r7, sp, #0
 800d9fe:	6078      	str	r0, [r7, #4]
    lv_event_temp_data_t * t = event_temp_data_head;
 800da00:	4b0c      	ldr	r3, [pc, #48]	; (800da34 <lv_event_mark_deleted+0x3c>)
 800da02:	681b      	ldr	r3, [r3, #0]
 800da04:	60fb      	str	r3, [r7, #12]

    while(t) {
 800da06:	e00a      	b.n	800da1e <lv_event_mark_deleted+0x26>
        if(t->obj == obj) t->deleted = true;
 800da08:	68fb      	ldr	r3, [r7, #12]
 800da0a:	681b      	ldr	r3, [r3, #0]
 800da0c:	687a      	ldr	r2, [r7, #4]
 800da0e:	429a      	cmp	r2, r3
 800da10:	d102      	bne.n	800da18 <lv_event_mark_deleted+0x20>
 800da12:	68fb      	ldr	r3, [r7, #12]
 800da14:	2201      	movs	r2, #1
 800da16:	711a      	strb	r2, [r3, #4]
        t = t->prev;
 800da18:	68fb      	ldr	r3, [r7, #12]
 800da1a:	689b      	ldr	r3, [r3, #8]
 800da1c:	60fb      	str	r3, [r7, #12]
    while(t) {
 800da1e:	68fb      	ldr	r3, [r7, #12]
 800da20:	2b00      	cmp	r3, #0
 800da22:	d1f1      	bne.n	800da08 <lv_event_mark_deleted+0x10>
    }
}
 800da24:	bf00      	nop
 800da26:	bf00      	nop
 800da28:	3714      	adds	r7, #20
 800da2a:	46bd      	mov	sp, r7
 800da2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da30:	4770      	bx	lr
 800da32:	bf00      	nop
 800da34:	200099f0 	.word	0x200099f0

0800da38 <style_prop_is_cacheble>:

    return false;
}

static bool style_prop_is_cacheble(lv_style_property_t prop)
{
 800da38:	b480      	push	{r7}
 800da3a:	b083      	sub	sp, #12
 800da3c:	af00      	add	r7, sp, #0
 800da3e:	4603      	mov	r3, r0
 800da40:	80fb      	strh	r3, [r7, #6]

    switch(prop) {
 800da42:	88fb      	ldrh	r3, [r7, #6]
 800da44:	f248 02ad 	movw	r2, #32941	; 0x80ad
 800da48:	4293      	cmp	r3, r2
 800da4a:	f000 8082 	beq.w	800db52 <style_prop_is_cacheble+0x11a>
 800da4e:	f248 02ad 	movw	r2, #32941	; 0x80ad
 800da52:	4293      	cmp	r3, r2
 800da54:	dc7f      	bgt.n	800db56 <style_prop_is_cacheble+0x11e>
 800da56:	f248 02a0 	movw	r2, #32928	; 0x80a0
 800da5a:	4293      	cmp	r3, r2
 800da5c:	d079      	beq.n	800db52 <style_prop_is_cacheble+0x11a>
 800da5e:	f248 02a0 	movw	r2, #32928	; 0x80a0
 800da62:	4293      	cmp	r3, r2
 800da64:	dc77      	bgt.n	800db56 <style_prop_is_cacheble+0x11e>
 800da66:	f248 028e 	movw	r2, #32910	; 0x808e
 800da6a:	4293      	cmp	r3, r2
 800da6c:	dc73      	bgt.n	800db56 <style_prop_is_cacheble+0x11e>
 800da6e:	f248 0280 	movw	r2, #32896	; 0x8080
 800da72:	4293      	cmp	r3, r2
 800da74:	da20      	bge.n	800dab8 <style_prop_is_cacheble+0x80>
 800da76:	f248 020c 	movw	r2, #32780	; 0x800c
 800da7a:	4293      	cmp	r3, r2
 800da7c:	d069      	beq.n	800db52 <style_prop_is_cacheble+0x11a>
 800da7e:	f248 020c 	movw	r2, #32780	; 0x800c
 800da82:	4293      	cmp	r3, r2
 800da84:	dc67      	bgt.n	800db56 <style_prop_is_cacheble+0x11e>
 800da86:	2bff      	cmp	r3, #255	; 0xff
 800da88:	d063      	beq.n	800db52 <style_prop_is_cacheble+0x11a>
 800da8a:	2bff      	cmp	r3, #255	; 0xff
 800da8c:	dc63      	bgt.n	800db56 <style_prop_is_cacheble+0x11e>
 800da8e:	2b91      	cmp	r3, #145	; 0x91
 800da90:	d05f      	beq.n	800db52 <style_prop_is_cacheble+0x11a>
 800da92:	2b91      	cmp	r3, #145	; 0x91
 800da94:	dc5f      	bgt.n	800db56 <style_prop_is_cacheble+0x11e>
 800da96:	2b7f      	cmp	r3, #127	; 0x7f
 800da98:	d05b      	beq.n	800db52 <style_prop_is_cacheble+0x11a>
 800da9a:	2b7f      	cmp	r3, #127	; 0x7f
 800da9c:	dc5b      	bgt.n	800db56 <style_prop_is_cacheble+0x11e>
 800da9e:	2b72      	cmp	r3, #114	; 0x72
 800daa0:	dc59      	bgt.n	800db56 <style_prop_is_cacheble+0x11e>
 800daa2:	2b54      	cmp	r3, #84	; 0x54
 800daa4:	da19      	bge.n	800dada <style_prop_is_cacheble+0xa2>
 800daa6:	2b50      	cmp	r3, #80	; 0x50
 800daa8:	dc55      	bgt.n	800db56 <style_prop_is_cacheble+0x11e>
 800daaa:	2b40      	cmp	r3, #64	; 0x40
 800daac:	da23      	bge.n	800daf6 <style_prop_is_cacheble+0xbe>
 800daae:	2b13      	cmp	r3, #19
 800dab0:	dc4a      	bgt.n	800db48 <style_prop_is_cacheble+0x110>
 800dab2:	2b00      	cmp	r3, #0
 800dab4:	dc3b      	bgt.n	800db2e <style_prop_is_cacheble+0xf6>
 800dab6:	e04e      	b.n	800db56 <style_prop_is_cacheble+0x11e>
 800dab8:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
 800dabc:	3b80      	subs	r3, #128	; 0x80
 800dabe:	f244 020b 	movw	r2, #16395	; 0x400b
 800dac2:	fa22 f303 	lsr.w	r3, r2, r3
 800dac6:	f003 0301 	and.w	r3, r3, #1
 800daca:	2b00      	cmp	r3, #0
 800dacc:	bf14      	ite	ne
 800dace:	2301      	movne	r3, #1
 800dad0:	2300      	moveq	r3, #0
 800dad2:	b2db      	uxtb	r3, r3
 800dad4:	2b00      	cmp	r3, #0
 800dad6:	d13c      	bne.n	800db52 <style_prop_is_cacheble+0x11a>
 800dad8:	e03d      	b.n	800db56 <style_prop_is_cacheble+0x11e>
 800dada:	3b54      	subs	r3, #84	; 0x54
 800dadc:	4a21      	ldr	r2, [pc, #132]	; (800db64 <style_prop_is_cacheble+0x12c>)
 800dade:	fa22 f303 	lsr.w	r3, r2, r3
 800dae2:	f003 0301 	and.w	r3, r3, #1
 800dae6:	2b00      	cmp	r3, #0
 800dae8:	bf14      	ite	ne
 800daea:	2301      	movne	r3, #1
 800daec:	2300      	moveq	r3, #0
 800daee:	b2db      	uxtb	r3, r3
 800daf0:	2b00      	cmp	r3, #0
 800daf2:	d12e      	bne.n	800db52 <style_prop_is_cacheble+0x11a>
 800daf4:	e02f      	b.n	800db56 <style_prop_is_cacheble+0x11e>
 800daf6:	3b40      	subs	r3, #64	; 0x40
 800daf8:	4a1b      	ldr	r2, [pc, #108]	; (800db68 <style_prop_is_cacheble+0x130>)
 800dafa:	fa22 f303 	lsr.w	r3, r2, r3
 800dafe:	f003 0301 	and.w	r3, r3, #1
 800db02:	2b00      	cmp	r3, #0
 800db04:	bf14      	ite	ne
 800db06:	2301      	movne	r3, #1
 800db08:	2300      	moveq	r3, #0
 800db0a:	b2db      	uxtb	r3, r3
 800db0c:	2b00      	cmp	r3, #0
 800db0e:	d120      	bne.n	800db52 <style_prop_is_cacheble+0x11a>
 800db10:	e021      	b.n	800db56 <style_prop_is_cacheble+0x11e>
 800db12:	3b20      	subs	r3, #32
 800db14:	4a15      	ldr	r2, [pc, #84]	; (800db6c <style_prop_is_cacheble+0x134>)
 800db16:	fa22 f303 	lsr.w	r3, r2, r3
 800db1a:	f003 0301 	and.w	r3, r3, #1
 800db1e:	2b00      	cmp	r3, #0
 800db20:	bf14      	ite	ne
 800db22:	2301      	movne	r3, #1
 800db24:	2300      	moveq	r3, #0
 800db26:	b2db      	uxtb	r3, r3
 800db28:	2b00      	cmp	r3, #0
 800db2a:	d112      	bne.n	800db52 <style_prop_is_cacheble+0x11a>
 800db2c:	e013      	b.n	800db56 <style_prop_is_cacheble+0x11e>
 800db2e:	461a      	mov	r2, r3
 800db30:	4b0f      	ldr	r3, [pc, #60]	; (800db70 <style_prop_is_cacheble+0x138>)
 800db32:	40d3      	lsrs	r3, r2
 800db34:	f003 0301 	and.w	r3, r3, #1
 800db38:	2b00      	cmp	r3, #0
 800db3a:	bf14      	ite	ne
 800db3c:	2301      	movne	r3, #1
 800db3e:	2300      	moveq	r3, #0
 800db40:	b2db      	uxtb	r3, r3
 800db42:	2b00      	cmp	r3, #0
 800db44:	d105      	bne.n	800db52 <style_prop_is_cacheble+0x11a>
 800db46:	e006      	b.n	800db56 <style_prop_is_cacheble+0x11e>
 800db48:	2b33      	cmp	r3, #51	; 0x33
 800db4a:	dc04      	bgt.n	800db56 <style_prop_is_cacheble+0x11e>
 800db4c:	2b20      	cmp	r3, #32
 800db4e:	dae0      	bge.n	800db12 <style_prop_is_cacheble+0xda>
 800db50:	e001      	b.n	800db56 <style_prop_is_cacheble+0x11e>
        case LV_STYLE_OUTLINE_BLEND_MODE:
        case LV_STYLE_PATTERN_BLEND_MODE:
        case LV_STYLE_SHADOW_BLEND_MODE:
        case LV_STYLE_TEXT_BLEND_MODE:
        case LV_STYLE_VALUE_BLEND_MODE:
            return true;
 800db52:	2301      	movs	r3, #1
 800db54:	e000      	b.n	800db58 <style_prop_is_cacheble+0x120>
            break;
        default:
            return false;
 800db56:	2300      	movs	r3, #0
    }
}
 800db58:	4618      	mov	r0, r3
 800db5a:	370c      	adds	r7, #12
 800db5c:	46bd      	mov	sp, r7
 800db5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db62:	4770      	bx	lr
 800db64:	44001001 	.word	0x44001001
 800db68:	00010005 	.word	0x00010005
 800db6c:	000f1009 	.word	0x000f1009
 800db70:	000f00f6 	.word	0x000f00f6

0800db74 <update_style_cache>:
 * @param obj pointer to an obejct
 * @param part the part of the object
 * @param prop the property which triggered the update
 */
static void update_style_cache(lv_obj_t * obj, uint8_t part, uint16_t prop)
{
 800db74:	b580      	push	{r7, lr}
 800db76:	b084      	sub	sp, #16
 800db78:	af00      	add	r7, sp, #0
 800db7a:	6078      	str	r0, [r7, #4]
 800db7c:	460b      	mov	r3, r1
 800db7e:	70fb      	strb	r3, [r7, #3]
 800db80:	4613      	mov	r3, r2
 800db82:	803b      	strh	r3, [r7, #0]
    if(style_prop_is_cacheble(prop) == false) return;
 800db84:	883b      	ldrh	r3, [r7, #0]
 800db86:	4618      	mov	r0, r3
 800db88:	f7ff ff56 	bl	800da38 <style_prop_is_cacheble>
 800db8c:	4603      	mov	r3, r0
 800db8e:	f083 0301 	eor.w	r3, r3, #1
 800db92:	b2db      	uxtb	r3, r3
 800db94:	2b00      	cmp	r3, #0
 800db96:	f040 81e0 	bne.w	800df5a <update_style_cache+0x3e6>

    lv_style_list_t * list = lv_obj_get_style_list(obj, part);
 800db9a:	78fb      	ldrb	r3, [r7, #3]
 800db9c:	4619      	mov	r1, r3
 800db9e:	6878      	ldr	r0, [r7, #4]
 800dba0:	f7fd fa42 	bl	800b028 <lv_obj_get_style_list>
 800dba4:	60f8      	str	r0, [r7, #12]

    bool ignore_cache_ori = list->ignore_cache;
 800dba6:	68fb      	ldr	r3, [r7, #12]
 800dba8:	795b      	ldrb	r3, [r3, #5]
 800dbaa:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800dbae:	b2db      	uxtb	r3, r3
 800dbb0:	2b00      	cmp	r3, #0
 800dbb2:	bf14      	ite	ne
 800dbb4:	2301      	movne	r3, #1
 800dbb6:	2300      	moveq	r3, #0
 800dbb8:	72fb      	strb	r3, [r7, #11]
    list->ignore_cache = 1;
 800dbba:	68fa      	ldr	r2, [r7, #12]
 800dbbc:	7953      	ldrb	r3, [r2, #5]
 800dbbe:	f043 0308 	orr.w	r3, r3, #8
 800dbc2:	7153      	strb	r3, [r2, #5]

#if LV_USE_OPA_SCALE
    list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;
 800dbc4:	78fb      	ldrb	r3, [r7, #3]
 800dbc6:	4619      	mov	r1, r3
 800dbc8:	6878      	ldr	r0, [r7, #4]
 800dbca:	f7fa fea7 	bl	800891c <lv_obj_get_style_opa_scale>
 800dbce:	4603      	mov	r3, r0
 800dbd0:	2bff      	cmp	r3, #255	; 0xff
 800dbd2:	bf0c      	ite	eq
 800dbd4:	2301      	moveq	r3, #1
 800dbd6:	2300      	movne	r3, #0
 800dbd8:	b2d9      	uxtb	r1, r3
 800dbda:	68fa      	ldr	r2, [r7, #12]
 800dbdc:	7953      	ldrb	r3, [r2, #5]
 800dbde:	f361 1345 	bfi	r3, r1, #5, #1
 800dbe2:	7153      	strb	r3, [r2, #5]
#else
    list->opa_scale_cover    = 1;
#endif
    list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;
 800dbe4:	78fb      	ldrb	r3, [r7, #3]
 800dbe6:	4619      	mov	r1, r3
 800dbe8:	6878      	ldr	r0, [r7, #4]
 800dbea:	f7fb f9dd 	bl	8008fa8 <lv_obj_get_style_text_decor>
 800dbee:	4603      	mov	r3, r0
 800dbf0:	2b00      	cmp	r3, #0
 800dbf2:	bf0c      	ite	eq
 800dbf4:	2301      	moveq	r3, #1
 800dbf6:	2300      	movne	r3, #0
 800dbf8:	b2d9      	uxtb	r1, r3
 800dbfa:	68fa      	ldr	r2, [r7, #12]
 800dbfc:	79d3      	ldrb	r3, [r2, #7]
 800dbfe:	f361 1386 	bfi	r3, r1, #6, #1
 800dc02:	71d3      	strb	r3, [r2, #7]
    list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == LV_THEME_DEFAULT_FONT_NORMAL ? 1 : 0;
 800dc04:	78fb      	ldrb	r3, [r7, #3]
 800dc06:	4619      	mov	r1, r3
 800dc08:	6878      	ldr	r0, [r7, #4]
 800dc0a:	f7fb fa29 	bl	8009060 <lv_obj_get_style_text_font>
 800dc0e:	4603      	mov	r3, r0
 800dc10:	4a9f      	ldr	r2, [pc, #636]	; (800de90 <update_style_cache+0x31c>)
 800dc12:	4293      	cmp	r3, r2
 800dc14:	bf0c      	ite	eq
 800dc16:	2301      	moveq	r3, #1
 800dc18:	2300      	movne	r3, #0
 800dc1a:	b2d9      	uxtb	r1, r3
 800dc1c:	68fa      	ldr	r2, [r7, #12]
 800dc1e:	79d3      	ldrb	r3, [r2, #7]
 800dc20:	f361 13c7 	bfi	r3, r1, #7, #1
 800dc24:	71d3      	strb	r3, [r2, #7]

    list->text_space_zero = 1;
 800dc26:	68fa      	ldr	r2, [r7, #12]
 800dc28:	79d3      	ldrb	r3, [r2, #7]
 800dc2a:	f043 0320 	orr.w	r3, r3, #32
 800dc2e:	71d3      	strb	r3, [r2, #7]
    if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
 800dc30:	78fb      	ldrb	r3, [r7, #3]
 800dc32:	4619      	mov	r1, r3
 800dc34:	6878      	ldr	r0, [r7, #4]
 800dc36:	f7fb f993 	bl	8008f60 <lv_obj_get_style_text_letter_space>
 800dc3a:	4603      	mov	r3, r0
 800dc3c:	2b00      	cmp	r3, #0
 800dc3e:	d107      	bne.n	800dc50 <update_style_cache+0xdc>
       lv_obj_get_style_text_line_space(obj, part) != 0) {
 800dc40:	78fb      	ldrb	r3, [r7, #3]
 800dc42:	4619      	mov	r1, r3
 800dc44:	6878      	ldr	r0, [r7, #4]
 800dc46:	f7fb f99d 	bl	8008f84 <lv_obj_get_style_text_line_space>
 800dc4a:	4603      	mov	r3, r0
    if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
 800dc4c:	2b00      	cmp	r3, #0
 800dc4e:	d004      	beq.n	800dc5a <update_style_cache+0xe6>
        list->text_space_zero = 0;
 800dc50:	68fa      	ldr	r2, [r7, #12]
 800dc52:	79d3      	ldrb	r3, [r2, #7]
 800dc54:	f36f 1345 	bfc	r3, #5, #1
 800dc58:	71d3      	strb	r3, [r2, #7]
    }


    lv_opa_t bg_opa = lv_obj_get_style_bg_opa(obj, part);
 800dc5a:	78fb      	ldrb	r3, [r7, #3]
 800dc5c:	4619      	mov	r1, r3
 800dc5e:	6878      	ldr	r0, [r7, #4]
 800dc60:	f7fa ff1a 	bl	8008a98 <lv_obj_get_style_bg_opa>
 800dc64:	4603      	mov	r3, r0
 800dc66:	72bb      	strb	r3, [r7, #10]
    list->bg_opa_transp    = bg_opa == LV_OPA_TRANSP ? 1 : 0;
 800dc68:	7abb      	ldrb	r3, [r7, #10]
 800dc6a:	2b00      	cmp	r3, #0
 800dc6c:	bf0c      	ite	eq
 800dc6e:	2301      	moveq	r3, #1
 800dc70:	2300      	movne	r3, #0
 800dc72:	b2d9      	uxtb	r1, r3
 800dc74:	68fa      	ldr	r2, [r7, #12]
 800dc76:	7993      	ldrb	r3, [r2, #6]
 800dc78:	f361 0382 	bfi	r3, r1, #2, #1
 800dc7c:	7193      	strb	r3, [r2, #6]
    list->bg_opa_cover     = bg_opa == LV_OPA_COVER ? 1 : 0;
 800dc7e:	7abb      	ldrb	r3, [r7, #10]
 800dc80:	2bff      	cmp	r3, #255	; 0xff
 800dc82:	bf0c      	ite	eq
 800dc84:	2301      	moveq	r3, #1
 800dc86:	2300      	movne	r3, #0
 800dc88:	b2d9      	uxtb	r1, r3
 800dc8a:	68fa      	ldr	r2, [r7, #12]
 800dc8c:	7993      	ldrb	r3, [r2, #6]
 800dc8e:	f361 03c3 	bfi	r3, r1, #3, #1
 800dc92:	7193      	strb	r3, [r2, #6]

    list->bg_grad_dir_none  = lv_obj_get_style_bg_grad_dir(obj, part) == LV_GRAD_DIR_NONE ? 1 : 0;
 800dc94:	78fb      	ldrb	r3, [r7, #3]
 800dc96:	4619      	mov	r1, r3
 800dc98:	6878      	ldr	r0, [r7, #4]
 800dc9a:	f7fa fec9 	bl	8008a30 <lv_obj_get_style_bg_grad_dir>
 800dc9e:	4603      	mov	r3, r0
 800dca0:	2b00      	cmp	r3, #0
 800dca2:	bf0c      	ite	eq
 800dca4:	2301      	moveq	r3, #1
 800dca6:	2300      	movne	r3, #0
 800dca8:	b2d9      	uxtb	r1, r3
 800dcaa:	68fa      	ldr	r2, [r7, #12]
 800dcac:	7993      	ldrb	r3, [r2, #6]
 800dcae:	f361 1304 	bfi	r3, r1, #4, #1
 800dcb2:	7193      	strb	r3, [r2, #6]
    list->border_width_zero = lv_obj_get_style_border_width(obj, part) == 0 ? 1 : 0;
 800dcb4:	78fb      	ldrb	r3, [r7, #3]
 800dcb6:	4619      	mov	r1, r3
 800dcb8:	6878      	ldr	r0, [r7, #4]
 800dcba:	f7fa fefe 	bl	8008aba <lv_obj_get_style_border_width>
 800dcbe:	4603      	mov	r3, r0
 800dcc0:	2b00      	cmp	r3, #0
 800dcc2:	bf0c      	ite	eq
 800dcc4:	2301      	moveq	r3, #1
 800dcc6:	2300      	movne	r3, #0
 800dcc8:	b2d9      	uxtb	r1, r3
 800dcca:	68fa      	ldr	r2, [r7, #12]
 800dccc:	7993      	ldrb	r3, [r2, #6]
 800dcce:	f361 1345 	bfi	r3, r1, #5, #1
 800dcd2:	7193      	strb	r3, [r2, #6]
    list->border_side_full = lv_obj_get_style_border_side(obj, part) == LV_BORDER_SIDE_FULL ? 1 : 0;
 800dcd4:	78fb      	ldrb	r3, [r7, #3]
 800dcd6:	4619      	mov	r1, r3
 800dcd8:	6878      	ldr	r0, [r7, #4]
 800dcda:	f7fa feff 	bl	8008adc <lv_obj_get_style_border_side>
 800dcde:	4603      	mov	r3, r0
 800dce0:	2b0f      	cmp	r3, #15
 800dce2:	bf0c      	ite	eq
 800dce4:	2301      	moveq	r3, #1
 800dce6:	2300      	movne	r3, #0
 800dce8:	b2d9      	uxtb	r1, r3
 800dcea:	68fa      	ldr	r2, [r7, #12]
 800dcec:	7993      	ldrb	r3, [r2, #6]
 800dcee:	f361 1386 	bfi	r3, r1, #6, #1
 800dcf2:	7193      	strb	r3, [r2, #6]
    list->border_post_off = lv_obj_get_style_border_post(obj, part) == 0 ? 1 : 0;
 800dcf4:	78fb      	ldrb	r3, [r7, #3]
 800dcf6:	4619      	mov	r1, r3
 800dcf8:	6878      	ldr	r0, [r7, #4]
 800dcfa:	f7fa ff13 	bl	8008b24 <lv_obj_get_style_border_post>
 800dcfe:	4603      	mov	r3, r0
 800dd00:	f083 0301 	eor.w	r3, r3, #1
 800dd04:	b2d9      	uxtb	r1, r3
 800dd06:	68fa      	ldr	r2, [r7, #12]
 800dd08:	7993      	ldrb	r3, [r2, #6]
 800dd0a:	f361 13c7 	bfi	r3, r1, #7, #1
 800dd0e:	7193      	strb	r3, [r2, #6]
    list->clip_corner_off   = lv_obj_get_style_clip_corner(obj, part) == false ? 1 : 0;
 800dd10:	78fb      	ldrb	r3, [r7, #3]
 800dd12:	4619      	mov	r1, r3
 800dd14:	6878      	ldr	r0, [r7, #4]
 800dd16:	f7fa fda7 	bl	8008868 <lv_obj_get_style_clip_corner>
 800dd1a:	4603      	mov	r3, r0
 800dd1c:	f083 0301 	eor.w	r3, r3, #1
 800dd20:	b2d9      	uxtb	r1, r3
 800dd22:	68fa      	ldr	r2, [r7, #12]
 800dd24:	7953      	ldrb	r3, [r2, #5]
 800dd26:	f361 1386 	bfi	r3, r1, #6, #1
 800dd2a:	7153      	strb	r3, [r2, #5]
    list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;
 800dd2c:	78fb      	ldrb	r3, [r7, #3]
 800dd2e:	4619      	mov	r1, r3
 800dd30:	6878      	ldr	r0, [r7, #4]
 800dd32:	f7fb f9f0 	bl	8009116 <lv_obj_get_style_image_recolor_opa>
 800dd36:	4603      	mov	r3, r0
 800dd38:	2b00      	cmp	r3, #0
 800dd3a:	bf0c      	ite	eq
 800dd3c:	2301      	moveq	r3, #1
 800dd3e:	2300      	movne	r3, #0
 800dd40:	b2d9      	uxtb	r1, r3
 800dd42:	68fa      	ldr	r2, [r7, #12]
 800dd44:	79d3      	ldrb	r3, [r2, #7]
 800dd46:	f361 1304 	bfi	r3, r1, #4, #1
 800dd4a:	71d3      	strb	r3, [r2, #7]
    list->outline_width_zero    = lv_obj_get_style_outline_width(obj, part) == 0 ? 1 : 0;
 800dd4c:	78fb      	ldrb	r3, [r7, #3]
 800dd4e:	4619      	mov	r1, r3
 800dd50:	6878      	ldr	r0, [r7, #4]
 800dd52:	f7fa ff1f 	bl	8008b94 <lv_obj_get_style_outline_width>
 800dd56:	4603      	mov	r3, r0
 800dd58:	2b00      	cmp	r3, #0
 800dd5a:	bf0c      	ite	eq
 800dd5c:	2301      	moveq	r3, #1
 800dd5e:	2300      	movne	r3, #0
 800dd60:	b2d9      	uxtb	r1, r3
 800dd62:	68fa      	ldr	r2, [r7, #12]
 800dd64:	79d3      	ldrb	r3, [r2, #7]
 800dd66:	f361 0300 	bfi	r3, r1, #0, #1
 800dd6a:	71d3      	strb	r3, [r2, #7]
    list->pattern_img_null    = lv_obj_get_style_pattern_image(obj, part) == NULL ? 1 : 0;
 800dd6c:	78fb      	ldrb	r3, [r7, #3]
 800dd6e:	4619      	mov	r1, r3
 800dd70:	6878      	ldr	r0, [r7, #4]
 800dd72:	f7fb f838 	bl	8008de6 <lv_obj_get_style_pattern_image>
 800dd76:	4603      	mov	r3, r0
 800dd78:	2b00      	cmp	r3, #0
 800dd7a:	bf0c      	ite	eq
 800dd7c:	2301      	moveq	r3, #1
 800dd7e:	2300      	movne	r3, #0
 800dd80:	b2d9      	uxtb	r1, r3
 800dd82:	68fa      	ldr	r2, [r7, #12]
 800dd84:	79d3      	ldrb	r3, [r2, #7]
 800dd86:	f361 0341 	bfi	r3, r1, #1, #1
 800dd8a:	71d3      	strb	r3, [r2, #7]
    list->radius_zero    = lv_obj_get_style_radius(obj, part) == 0 ? 1 : 0;
 800dd8c:	78fb      	ldrb	r3, [r7, #3]
 800dd8e:	4619      	mov	r1, r3
 800dd90:	6878      	ldr	r0, [r7, #4]
 800dd92:	f7fa fd58 	bl	8008846 <lv_obj_get_style_radius>
 800dd96:	4603      	mov	r3, r0
 800dd98:	2b00      	cmp	r3, #0
 800dd9a:	bf0c      	ite	eq
 800dd9c:	2301      	moveq	r3, #1
 800dd9e:	2300      	movne	r3, #0
 800dda0:	b2d9      	uxtb	r1, r3
 800dda2:	68fa      	ldr	r2, [r7, #12]
 800dda4:	7953      	ldrb	r3, [r2, #5]
 800dda6:	f361 1304 	bfi	r3, r1, #4, #1
 800ddaa:	7153      	strb	r3, [r2, #5]
    list->shadow_width_zero    = lv_obj_get_style_shadow_width(obj, part) == 0 ? 1 : 0;
 800ddac:	78fb      	ldrb	r3, [r7, #3]
 800ddae:	4619      	mov	r1, r3
 800ddb0:	6878      	ldr	r0, [r7, #4]
 800ddb2:	f7fa ff45 	bl	8008c40 <lv_obj_get_style_shadow_width>
 800ddb6:	4603      	mov	r3, r0
 800ddb8:	2b00      	cmp	r3, #0
 800ddba:	bf0c      	ite	eq
 800ddbc:	2301      	moveq	r3, #1
 800ddbe:	2300      	movne	r3, #0
 800ddc0:	b2d9      	uxtb	r1, r3
 800ddc2:	68fa      	ldr	r2, [r7, #12]
 800ddc4:	79d3      	ldrb	r3, [r2, #7]
 800ddc6:	f361 0382 	bfi	r3, r1, #2, #1
 800ddca:	71d3      	strb	r3, [r2, #7]
    list->value_txt_str    = lv_obj_get_style_value_str(obj, part) == NULL ? 1 : 0;
 800ddcc:	78fb      	ldrb	r3, [r7, #3]
 800ddce:	4619      	mov	r1, r3
 800ddd0:	6878      	ldr	r0, [r7, #4]
 800ddd2:	f7fb f8b4 	bl	8008f3e <lv_obj_get_style_value_str>
 800ddd6:	4603      	mov	r3, r0
 800ddd8:	2b00      	cmp	r3, #0
 800ddda:	bf0c      	ite	eq
 800dddc:	2301      	moveq	r3, #1
 800ddde:	2300      	movne	r3, #0
 800dde0:	b2d9      	uxtb	r1, r3
 800dde2:	68fa      	ldr	r2, [r7, #12]
 800dde4:	79d3      	ldrb	r3, [r2, #7]
 800dde6:	f361 03c3 	bfi	r3, r1, #3, #1
 800ddea:	71d3      	strb	r3, [r2, #7]


    list->transform_all_zero  = 1;
 800ddec:	68fa      	ldr	r2, [r7, #12]
 800ddee:	7953      	ldrb	r3, [r2, #5]
 800ddf0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800ddf4:	7153      	strb	r3, [r2, #5]
    if(lv_obj_get_style_transform_angle(obj, part) != 0 ||
 800ddf6:	78fb      	ldrb	r3, [r7, #3]
 800ddf8:	4619      	mov	r1, r3
 800ddfa:	6878      	ldr	r0, [r7, #4]
 800ddfc:	f7fa fd6c 	bl	80088d8 <lv_obj_get_style_transform_angle>
 800de00:	4603      	mov	r3, r0
 800de02:	2b00      	cmp	r3, #0
 800de04:	d118      	bne.n	800de38 <update_style_cache+0x2c4>
       lv_obj_get_style_transform_width(obj, part) != 0 ||
 800de06:	78fb      	ldrb	r3, [r7, #3]
 800de08:	4619      	mov	r1, r3
 800de0a:	6878      	ldr	r0, [r7, #4]
 800de0c:	f7fa fd42 	bl	8008894 <lv_obj_get_style_transform_width>
 800de10:	4603      	mov	r3, r0
    if(lv_obj_get_style_transform_angle(obj, part) != 0 ||
 800de12:	2b00      	cmp	r3, #0
 800de14:	d110      	bne.n	800de38 <update_style_cache+0x2c4>
       lv_obj_get_style_transform_height(obj, part) != 0 ||
 800de16:	78fb      	ldrb	r3, [r7, #3]
 800de18:	4619      	mov	r1, r3
 800de1a:	6878      	ldr	r0, [r7, #4]
 800de1c:	f7fa fd4b 	bl	80088b6 <lv_obj_get_style_transform_height>
 800de20:	4603      	mov	r3, r0
       lv_obj_get_style_transform_width(obj, part) != 0 ||
 800de22:	2b00      	cmp	r3, #0
 800de24:	d108      	bne.n	800de38 <update_style_cache+0x2c4>
       lv_obj_get_style_transform_zoom(obj, part) != LV_IMG_ZOOM_NONE) {
 800de26:	78fb      	ldrb	r3, [r7, #3]
 800de28:	4619      	mov	r1, r3
 800de2a:	6878      	ldr	r0, [r7, #4]
 800de2c:	f7fa fd65 	bl	80088fa <lv_obj_get_style_transform_zoom>
 800de30:	4603      	mov	r3, r0
       lv_obj_get_style_transform_height(obj, part) != 0 ||
 800de32:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800de36:	d004      	beq.n	800de42 <update_style_cache+0x2ce>
        list->transform_all_zero  = 0;
 800de38:	68fa      	ldr	r2, [r7, #12]
 800de3a:	7953      	ldrb	r3, [r2, #5]
 800de3c:	f36f 13c7 	bfc	r3, #7, #1
 800de40:	7153      	strb	r3, [r2, #5]
    }

    list->pad_all_zero  = 1;
 800de42:	68fa      	ldr	r2, [r7, #12]
 800de44:	7993      	ldrb	r3, [r2, #6]
 800de46:	f043 0301 	orr.w	r3, r3, #1
 800de4a:	7193      	strb	r3, [r2, #6]
    if(lv_obj_get_style_pad_top(obj, part) != 0 ||
 800de4c:	78fb      	ldrb	r3, [r7, #3]
 800de4e:	4619      	mov	r1, r3
 800de50:	6878      	ldr	r0, [r7, #4]
 800de52:	f7fa fd75 	bl	8008940 <lv_obj_get_style_pad_top>
 800de56:	4603      	mov	r3, r0
 800de58:	2b00      	cmp	r3, #0
 800de5a:	d11b      	bne.n	800de94 <update_style_cache+0x320>
       lv_obj_get_style_pad_bottom(obj, part) != 0 ||
 800de5c:	78fb      	ldrb	r3, [r7, #3]
 800de5e:	4619      	mov	r1, r3
 800de60:	6878      	ldr	r0, [r7, #4]
 800de62:	f7fa fd7e 	bl	8008962 <lv_obj_get_style_pad_bottom>
 800de66:	4603      	mov	r3, r0
    if(lv_obj_get_style_pad_top(obj, part) != 0 ||
 800de68:	2b00      	cmp	r3, #0
 800de6a:	d113      	bne.n	800de94 <update_style_cache+0x320>
       lv_obj_get_style_pad_left(obj, part) != 0 ||
 800de6c:	78fb      	ldrb	r3, [r7, #3]
 800de6e:	4619      	mov	r1, r3
 800de70:	6878      	ldr	r0, [r7, #4]
 800de72:	f7fa fd87 	bl	8008984 <lv_obj_get_style_pad_left>
 800de76:	4603      	mov	r3, r0
       lv_obj_get_style_pad_bottom(obj, part) != 0 ||
 800de78:	2b00      	cmp	r3, #0
 800de7a:	d10b      	bne.n	800de94 <update_style_cache+0x320>
       lv_obj_get_style_pad_right(obj, part) != 0) {
 800de7c:	78fb      	ldrb	r3, [r7, #3]
 800de7e:	4619      	mov	r1, r3
 800de80:	6878      	ldr	r0, [r7, #4]
 800de82:	f7fa fd90 	bl	80089a6 <lv_obj_get_style_pad_right>
 800de86:	4603      	mov	r3, r0
       lv_obj_get_style_pad_left(obj, part) != 0 ||
 800de88:	2b00      	cmp	r3, #0
 800de8a:	d008      	beq.n	800de9e <update_style_cache+0x32a>
 800de8c:	e002      	b.n	800de94 <update_style_cache+0x320>
 800de8e:	bf00      	nop
 800de90:	200001a8 	.word	0x200001a8
        list->pad_all_zero  = 0;
 800de94:	68fa      	ldr	r2, [r7, #12]
 800de96:	7993      	ldrb	r3, [r2, #6]
 800de98:	f36f 0300 	bfc	r3, #0, #1
 800de9c:	7193      	strb	r3, [r2, #6]
    }

    list->blend_mode_all_normal = 1;
 800de9e:	68fa      	ldr	r2, [r7, #12]
 800dea0:	7993      	ldrb	r3, [r2, #6]
 800dea2:	f043 0302 	orr.w	r3, r3, #2
 800dea6:	7193      	strb	r3, [r2, #6]
#if LV_USE_BLEND_MODES
    if(lv_obj_get_style_bg_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800dea8:	78fb      	ldrb	r3, [r7, #3]
 800deaa:	4619      	mov	r1, r3
 800deac:	6878      	ldr	r0, [r7, #4]
 800deae:	f7fa fd8b 	bl	80089c8 <lv_obj_get_style_bg_blend_mode>
 800deb2:	4603      	mov	r3, r0
 800deb4:	2b00      	cmp	r3, #0
 800deb6:	d13f      	bne.n	800df38 <update_style_cache+0x3c4>
       lv_obj_get_style_border_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800deb8:	78fb      	ldrb	r3, [r7, #3]
 800deba:	4619      	mov	r1, r3
 800debc:	6878      	ldr	r0, [r7, #4]
 800debe:	f7fa fe1f 	bl	8008b00 <lv_obj_get_style_border_blend_mode>
 800dec2:	4603      	mov	r3, r0
    if(lv_obj_get_style_bg_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800dec4:	2b00      	cmp	r3, #0
 800dec6:	d137      	bne.n	800df38 <update_style_cache+0x3c4>
       lv_obj_get_style_pattern_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800dec8:	78fb      	ldrb	r3, [r7, #3]
 800deca:	4619      	mov	r1, r3
 800decc:	6878      	ldr	r0, [r7, #4]
 800dece:	f7fa ff45 	bl	8008d5c <lv_obj_get_style_pattern_blend_mode>
 800ded2:	4603      	mov	r3, r0
       lv_obj_get_style_border_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800ded4:	2b00      	cmp	r3, #0
 800ded6:	d12f      	bne.n	800df38 <update_style_cache+0x3c4>
       lv_obj_get_style_outline_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800ded8:	78fb      	ldrb	r3, [r7, #3]
 800deda:	4619      	mov	r1, r3
 800dedc:	6878      	ldr	r0, [r7, #4]
 800dede:	f7fa fe7b 	bl	8008bd8 <lv_obj_get_style_outline_blend_mode>
 800dee2:	4603      	mov	r3, r0
       lv_obj_get_style_pattern_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800dee4:	2b00      	cmp	r3, #0
 800dee6:	d127      	bne.n	800df38 <update_style_cache+0x3c4>
       lv_obj_get_style_value_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800dee8:	78fb      	ldrb	r3, [r7, #3]
 800deea:	4619      	mov	r1, r3
 800deec:	6878      	ldr	r0, [r7, #4]
 800deee:	f7fa ffad 	bl	8008e4c <lv_obj_get_style_value_blend_mode>
 800def2:	4603      	mov	r3, r0
       lv_obj_get_style_outline_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800def4:	2b00      	cmp	r3, #0
 800def6:	d11f      	bne.n	800df38 <update_style_cache+0x3c4>
       lv_obj_get_style_text_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800def8:	78fb      	ldrb	r3, [r7, #3]
 800defa:	4619      	mov	r1, r3
 800defc:	6878      	ldr	r0, [r7, #4]
 800defe:	f7fb f866 	bl	8008fce <lv_obj_get_style_text_blend_mode>
 800df02:	4603      	mov	r3, r0
       lv_obj_get_style_value_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800df04:	2b00      	cmp	r3, #0
 800df06:	d117      	bne.n	800df38 <update_style_cache+0x3c4>
       lv_obj_get_style_line_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800df08:	78fb      	ldrb	r3, [r7, #3]
 800df0a:	4619      	mov	r1, r3
 800df0c:	6878      	ldr	r0, [r7, #4]
 800df0e:	f7fb f8b9 	bl	8009084 <lv_obj_get_style_line_blend_mode>
 800df12:	4603      	mov	r3, r0
       lv_obj_get_style_text_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800df14:	2b00      	cmp	r3, #0
 800df16:	d10f      	bne.n	800df38 <update_style_cache+0x3c4>
       lv_obj_get_style_image_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800df18:	78fb      	ldrb	r3, [r7, #3]
 800df1a:	4619      	mov	r1, r3
 800df1c:	6878      	ldr	r0, [r7, #4]
 800df1e:	f7fb f8c3 	bl	80090a8 <lv_obj_get_style_image_blend_mode>
 800df22:	4603      	mov	r3, r0
       lv_obj_get_style_line_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800df24:	2b00      	cmp	r3, #0
 800df26:	d107      	bne.n	800df38 <update_style_cache+0x3c4>
       lv_obj_get_style_shadow_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL) {
 800df28:	78fb      	ldrb	r3, [r7, #3]
 800df2a:	4619      	mov	r1, r3
 800df2c:	6878      	ldr	r0, [r7, #4]
 800df2e:	f7fa fecb 	bl	8008cc8 <lv_obj_get_style_shadow_blend_mode>
 800df32:	4603      	mov	r3, r0
       lv_obj_get_style_image_blend_mode(obj, part) != LV_BLEND_MODE_NORMAL ||
 800df34:	2b00      	cmp	r3, #0
 800df36:	d004      	beq.n	800df42 <update_style_cache+0x3ce>
        list->blend_mode_all_normal = 0;
 800df38:	68fa      	ldr	r2, [r7, #12]
 800df3a:	7993      	ldrb	r3, [r2, #6]
 800df3c:	f36f 0341 	bfc	r3, #1, #1
 800df40:	7193      	strb	r3, [r2, #6]
    }
#endif
    list->ignore_cache = ignore_cache_ori;
 800df42:	68fa      	ldr	r2, [r7, #12]
 800df44:	7953      	ldrb	r3, [r2, #5]
 800df46:	7af9      	ldrb	r1, [r7, #11]
 800df48:	f361 03c3 	bfi	r3, r1, #3, #1
 800df4c:	7153      	strb	r3, [r2, #5]
    list->valid_cache = 1;
 800df4e:	68fa      	ldr	r2, [r7, #12]
 800df50:	7953      	ldrb	r3, [r2, #5]
 800df52:	f043 0304 	orr.w	r3, r3, #4
 800df56:	7153      	strb	r3, [r2, #5]
 800df58:	e000      	b.n	800df5c <update_style_cache+0x3e8>
    if(style_prop_is_cacheble(prop) == false) return;
 800df5a:	bf00      	nop
}
 800df5c:	3710      	adds	r7, #16
 800df5e:	46bd      	mov	sp, r7
 800df60:	bd80      	pop	{r7, pc}
 800df62:	bf00      	nop

0800df64 <update_style_cache_children>:
 * Update the cache of style list
 * @param obj pointer to an object
 * @param part the part of the object
 */
static void update_style_cache_children(lv_obj_t * obj)
{
 800df64:	b590      	push	{r4, r7, lr}
 800df66:	b087      	sub	sp, #28
 800df68:	af00      	add	r7, sp, #0
 800df6a:	6078      	str	r0, [r7, #4]
    uint8_t part;
    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {
 800df6c:	2300      	movs	r3, #0
 800df6e:	75fb      	strb	r3, [r7, #23]
 800df70:	e07d      	b.n	800e06e <update_style_cache_children+0x10a>
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
 800df72:	7dfb      	ldrb	r3, [r7, #23]
 800df74:	4619      	mov	r1, r3
 800df76:	6878      	ldr	r0, [r7, #4]
 800df78:	f7fd f856 	bl	800b028 <lv_obj_get_style_list>
 800df7c:	60f8      	str	r0, [r7, #12]
        if(list == NULL) break;
 800df7e:	68fb      	ldr	r3, [r7, #12]
 800df80:	2b00      	cmp	r3, #0
 800df82:	d079      	beq.n	800e078 <update_style_cache_children+0x114>

        bool ignore_cache_ori = list->ignore_cache;
 800df84:	68fb      	ldr	r3, [r7, #12]
 800df86:	795b      	ldrb	r3, [r3, #5]
 800df88:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800df8c:	b2db      	uxtb	r3, r3
 800df8e:	2b00      	cmp	r3, #0
 800df90:	bf14      	ite	ne
 800df92:	2301      	movne	r3, #1
 800df94:	2300      	moveq	r3, #0
 800df96:	72fb      	strb	r3, [r7, #11]
        list->ignore_cache = 1;
 800df98:	68fa      	ldr	r2, [r7, #12]
 800df9a:	7953      	ldrb	r3, [r2, #5]
 800df9c:	f043 0308 	orr.w	r3, r3, #8
 800dfa0:	7153      	strb	r3, [r2, #5]

        list->opa_scale_cover    = lv_obj_get_style_opa_scale(obj, part) == LV_OPA_COVER ? 1 : 0;
 800dfa2:	7dfb      	ldrb	r3, [r7, #23]
 800dfa4:	4619      	mov	r1, r3
 800dfa6:	6878      	ldr	r0, [r7, #4]
 800dfa8:	f7fa fcb8 	bl	800891c <lv_obj_get_style_opa_scale>
 800dfac:	4603      	mov	r3, r0
 800dfae:	2bff      	cmp	r3, #255	; 0xff
 800dfb0:	bf0c      	ite	eq
 800dfb2:	2301      	moveq	r3, #1
 800dfb4:	2300      	movne	r3, #0
 800dfb6:	b2d9      	uxtb	r1, r3
 800dfb8:	68fa      	ldr	r2, [r7, #12]
 800dfba:	7953      	ldrb	r3, [r2, #5]
 800dfbc:	f361 1345 	bfi	r3, r1, #5, #1
 800dfc0:	7153      	strb	r3, [r2, #5]
        list->text_decor_none    = lv_obj_get_style_text_decor(obj, part) == LV_TEXT_DECOR_NONE ? 1 : 0;
 800dfc2:	7dfb      	ldrb	r3, [r7, #23]
 800dfc4:	4619      	mov	r1, r3
 800dfc6:	6878      	ldr	r0, [r7, #4]
 800dfc8:	f7fa ffee 	bl	8008fa8 <lv_obj_get_style_text_decor>
 800dfcc:	4603      	mov	r3, r0
 800dfce:	2b00      	cmp	r3, #0
 800dfd0:	bf0c      	ite	eq
 800dfd2:	2301      	moveq	r3, #1
 800dfd4:	2300      	movne	r3, #0
 800dfd6:	b2d9      	uxtb	r1, r3
 800dfd8:	68fa      	ldr	r2, [r7, #12]
 800dfda:	79d3      	ldrb	r3, [r2, #7]
 800dfdc:	f361 1386 	bfi	r3, r1, #6, #1
 800dfe0:	71d3      	strb	r3, [r2, #7]
        list->text_font_normal    = lv_obj_get_style_text_font(obj, part) == lv_theme_get_font_normal() ? 1 : 0;
 800dfe2:	7dfb      	ldrb	r3, [r7, #23]
 800dfe4:	4619      	mov	r1, r3
 800dfe6:	6878      	ldr	r0, [r7, #4]
 800dfe8:	f7fb f83a 	bl	8009060 <lv_obj_get_style_text_font>
 800dfec:	4604      	mov	r4, r0
 800dfee:	f014 fdbf 	bl	8022b70 <lv_theme_get_font_normal>
 800dff2:	4603      	mov	r3, r0
 800dff4:	429c      	cmp	r4, r3
 800dff6:	bf0c      	ite	eq
 800dff8:	2301      	moveq	r3, #1
 800dffa:	2300      	movne	r3, #0
 800dffc:	b2d9      	uxtb	r1, r3
 800dffe:	68fa      	ldr	r2, [r7, #12]
 800e000:	79d3      	ldrb	r3, [r2, #7]
 800e002:	f361 13c7 	bfi	r3, r1, #7, #1
 800e006:	71d3      	strb	r3, [r2, #7]
        list->img_recolor_opa_transp    = lv_obj_get_style_image_recolor_opa(obj, part) == LV_OPA_TRANSP ? 1 : 0;
 800e008:	7dfb      	ldrb	r3, [r7, #23]
 800e00a:	4619      	mov	r1, r3
 800e00c:	6878      	ldr	r0, [r7, #4]
 800e00e:	f7fb f882 	bl	8009116 <lv_obj_get_style_image_recolor_opa>
 800e012:	4603      	mov	r3, r0
 800e014:	2b00      	cmp	r3, #0
 800e016:	bf0c      	ite	eq
 800e018:	2301      	moveq	r3, #1
 800e01a:	2300      	movne	r3, #0
 800e01c:	b2d9      	uxtb	r1, r3
 800e01e:	68fa      	ldr	r2, [r7, #12]
 800e020:	79d3      	ldrb	r3, [r2, #7]
 800e022:	f361 1304 	bfi	r3, r1, #4, #1
 800e026:	71d3      	strb	r3, [r2, #7]

        list->text_space_zero = 1;
 800e028:	68fa      	ldr	r2, [r7, #12]
 800e02a:	79d3      	ldrb	r3, [r2, #7]
 800e02c:	f043 0320 	orr.w	r3, r3, #32
 800e030:	71d3      	strb	r3, [r2, #7]
        if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
 800e032:	7dfb      	ldrb	r3, [r7, #23]
 800e034:	4619      	mov	r1, r3
 800e036:	6878      	ldr	r0, [r7, #4]
 800e038:	f7fa ff92 	bl	8008f60 <lv_obj_get_style_text_letter_space>
 800e03c:	4603      	mov	r3, r0
 800e03e:	2b00      	cmp	r3, #0
 800e040:	d107      	bne.n	800e052 <update_style_cache_children+0xee>
           lv_obj_get_style_text_line_space(obj, part) != 0) {
 800e042:	7dfb      	ldrb	r3, [r7, #23]
 800e044:	4619      	mov	r1, r3
 800e046:	6878      	ldr	r0, [r7, #4]
 800e048:	f7fa ff9c 	bl	8008f84 <lv_obj_get_style_text_line_space>
 800e04c:	4603      	mov	r3, r0
        if(lv_obj_get_style_text_letter_space(obj, part) != 0 ||
 800e04e:	2b00      	cmp	r3, #0
 800e050:	d004      	beq.n	800e05c <update_style_cache_children+0xf8>
            list->text_space_zero = 0;
 800e052:	68fa      	ldr	r2, [r7, #12]
 800e054:	79d3      	ldrb	r3, [r2, #7]
 800e056:	f36f 1345 	bfc	r3, #5, #1
 800e05a:	71d3      	strb	r3, [r2, #7]
        }

        list->ignore_cache = ignore_cache_ori;
 800e05c:	68fa      	ldr	r2, [r7, #12]
 800e05e:	7953      	ldrb	r3, [r2, #5]
 800e060:	7af9      	ldrb	r1, [r7, #11]
 800e062:	f361 03c3 	bfi	r3, r1, #3, #1
 800e066:	7153      	strb	r3, [r2, #5]
    for(part = 0; part != _LV_OBJ_PART_REAL_LAST; part++) {
 800e068:	7dfb      	ldrb	r3, [r7, #23]
 800e06a:	3301      	adds	r3, #1
 800e06c:	75fb      	strb	r3, [r7, #23]
 800e06e:	7dfb      	ldrb	r3, [r7, #23]
 800e070:	2b40      	cmp	r3, #64	; 0x40
 800e072:	f47f af7e 	bne.w	800df72 <update_style_cache_children+0xe>
 800e076:	e000      	b.n	800e07a <update_style_cache_children+0x116>
        if(list == NULL) break;
 800e078:	bf00      	nop
    }

    lv_obj_t * child = lv_obj_get_child(obj, NULL);
 800e07a:	2100      	movs	r1, #0
 800e07c:	6878      	ldr	r0, [r7, #4]
 800e07e:	f7fc fe6b 	bl	800ad58 <lv_obj_get_child>
 800e082:	6138      	str	r0, [r7, #16]
    while(child) {
 800e084:	e007      	b.n	800e096 <update_style_cache_children+0x132>
        update_style_cache_children(child);
 800e086:	6938      	ldr	r0, [r7, #16]
 800e088:	f7ff ff6c 	bl	800df64 <update_style_cache_children>
        child = lv_obj_get_child(obj, child);
 800e08c:	6939      	ldr	r1, [r7, #16]
 800e08e:	6878      	ldr	r0, [r7, #4]
 800e090:	f7fc fe62 	bl	800ad58 <lv_obj_get_child>
 800e094:	6138      	str	r0, [r7, #16]
    while(child) {
 800e096:	693b      	ldr	r3, [r7, #16]
 800e098:	2b00      	cmp	r3, #0
 800e09a:	d1f4      	bne.n	800e086 <update_style_cache_children+0x122>
    }

}
 800e09c:	bf00      	nop
 800e09e:	bf00      	nop
 800e0a0:	371c      	adds	r7, #28
 800e0a2:	46bd      	mov	sp, r7
 800e0a4:	bd90      	pop	{r4, r7, pc}

0800e0a6 <invalidate_style_cache>:
 * Mark the object and all of it's children's style lists as invalid.
 * The cache will be updated when a cached property asked nest time
 * @param obj pointer to an object
 */
static void invalidate_style_cache(lv_obj_t * obj, uint8_t part, lv_style_property_t prop)
{
 800e0a6:	b580      	push	{r7, lr}
 800e0a8:	b086      	sub	sp, #24
 800e0aa:	af00      	add	r7, sp, #0
 800e0ac:	6078      	str	r0, [r7, #4]
 800e0ae:	460b      	mov	r3, r1
 800e0b0:	70fb      	strb	r3, [r7, #3]
 800e0b2:	4613      	mov	r3, r2
 800e0b4:	803b      	strh	r3, [r7, #0]
    if(style_prop_is_cacheble(prop) == false) return;
 800e0b6:	883b      	ldrh	r3, [r7, #0]
 800e0b8:	4618      	mov	r0, r3
 800e0ba:	f7ff fcbd 	bl	800da38 <style_prop_is_cacheble>
 800e0be:	4603      	mov	r3, r0
 800e0c0:	f083 0301 	eor.w	r3, r3, #1
 800e0c4:	b2db      	uxtb	r3, r3
 800e0c6:	2b00      	cmp	r3, #0
 800e0c8:	d155      	bne.n	800e176 <invalidate_style_cache+0xd0>

    if(part != LV_OBJ_PART_ALL) {
 800e0ca:	78fb      	ldrb	r3, [r7, #3]
 800e0cc:	2bff      	cmp	r3, #255	; 0xff
 800e0ce:	d00e      	beq.n	800e0ee <invalidate_style_cache+0x48>
        lv_style_list_t * list = lv_obj_get_style_list(obj, part);
 800e0d0:	78fb      	ldrb	r3, [r7, #3]
 800e0d2:	4619      	mov	r1, r3
 800e0d4:	6878      	ldr	r0, [r7, #4]
 800e0d6:	f7fc ffa7 	bl	800b028 <lv_obj_get_style_list>
 800e0da:	60b8      	str	r0, [r7, #8]
        if(list == NULL) return;
 800e0dc:	68bb      	ldr	r3, [r7, #8]
 800e0de:	2b00      	cmp	r3, #0
 800e0e0:	d04b      	beq.n	800e17a <invalidate_style_cache+0xd4>
        list->valid_cache = 0;
 800e0e2:	68ba      	ldr	r2, [r7, #8]
 800e0e4:	7953      	ldrb	r3, [r2, #5]
 800e0e6:	f36f 0382 	bfc	r3, #2, #1
 800e0ea:	7153      	strb	r3, [r2, #5]
 800e0ec:	e031      	b.n	800e152 <invalidate_style_cache+0xac>
    }
    else {

        for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
 800e0ee:	2300      	movs	r3, #0
 800e0f0:	70fb      	strb	r3, [r7, #3]
 800e0f2:	e010      	b.n	800e116 <invalidate_style_cache+0x70>
            lv_style_list_t * list = lv_obj_get_style_list(obj, part);
 800e0f4:	78fb      	ldrb	r3, [r7, #3]
 800e0f6:	4619      	mov	r1, r3
 800e0f8:	6878      	ldr	r0, [r7, #4]
 800e0fa:	f7fc ff95 	bl	800b028 <lv_obj_get_style_list>
 800e0fe:	6138      	str	r0, [r7, #16]
            if(list == NULL) break;
 800e100:	693b      	ldr	r3, [r7, #16]
 800e102:	2b00      	cmp	r3, #0
 800e104:	d00b      	beq.n	800e11e <invalidate_style_cache+0x78>
            list->valid_cache = 0;
 800e106:	693a      	ldr	r2, [r7, #16]
 800e108:	7953      	ldrb	r3, [r2, #5]
 800e10a:	f36f 0382 	bfc	r3, #2, #1
 800e10e:	7153      	strb	r3, [r2, #5]
        for(part = 0; part < _LV_OBJ_PART_REAL_FIRST; part++) {
 800e110:	78fb      	ldrb	r3, [r7, #3]
 800e112:	3301      	adds	r3, #1
 800e114:	70fb      	strb	r3, [r7, #3]
 800e116:	78fb      	ldrb	r3, [r7, #3]
 800e118:	2b3f      	cmp	r3, #63	; 0x3f
 800e11a:	d9eb      	bls.n	800e0f4 <invalidate_style_cache+0x4e>
 800e11c:	e000      	b.n	800e120 <invalidate_style_cache+0x7a>
            if(list == NULL) break;
 800e11e:	bf00      	nop
        }
        for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
 800e120:	2340      	movs	r3, #64	; 0x40
 800e122:	70fb      	strb	r3, [r7, #3]
 800e124:	e010      	b.n	800e148 <invalidate_style_cache+0xa2>
            lv_style_list_t * list = lv_obj_get_style_list(obj, part);
 800e126:	78fb      	ldrb	r3, [r7, #3]
 800e128:	4619      	mov	r1, r3
 800e12a:	6878      	ldr	r0, [r7, #4]
 800e12c:	f7fc ff7c 	bl	800b028 <lv_obj_get_style_list>
 800e130:	60f8      	str	r0, [r7, #12]
            if(list == NULL) break;
 800e132:	68fb      	ldr	r3, [r7, #12]
 800e134:	2b00      	cmp	r3, #0
 800e136:	d00b      	beq.n	800e150 <invalidate_style_cache+0xaa>
            list->valid_cache = 0;
 800e138:	68fa      	ldr	r2, [r7, #12]
 800e13a:	7953      	ldrb	r3, [r2, #5]
 800e13c:	f36f 0382 	bfc	r3, #2, #1
 800e140:	7153      	strb	r3, [r2, #5]
        for(part = _LV_OBJ_PART_REAL_FIRST; part < 0xFF; part++) {
 800e142:	78fb      	ldrb	r3, [r7, #3]
 800e144:	3301      	adds	r3, #1
 800e146:	70fb      	strb	r3, [r7, #3]
 800e148:	78fb      	ldrb	r3, [r7, #3]
 800e14a:	2bff      	cmp	r3, #255	; 0xff
 800e14c:	d1eb      	bne.n	800e126 <invalidate_style_cache+0x80>
 800e14e:	e000      	b.n	800e152 <invalidate_style_cache+0xac>
            if(list == NULL) break;
 800e150:	bf00      	nop
        }
    }

    lv_obj_t * child = lv_obj_get_child(obj, NULL);
 800e152:	2100      	movs	r1, #0
 800e154:	6878      	ldr	r0, [r7, #4]
 800e156:	f7fc fdff 	bl	800ad58 <lv_obj_get_child>
 800e15a:	6178      	str	r0, [r7, #20]
    while(child) {
 800e15c:	e007      	b.n	800e16e <invalidate_style_cache+0xc8>
        update_style_cache_children(child);
 800e15e:	6978      	ldr	r0, [r7, #20]
 800e160:	f7ff ff00 	bl	800df64 <update_style_cache_children>
        child = lv_obj_get_child(obj, child);
 800e164:	6979      	ldr	r1, [r7, #20]
 800e166:	6878      	ldr	r0, [r7, #4]
 800e168:	f7fc fdf6 	bl	800ad58 <lv_obj_get_child>
 800e16c:	6178      	str	r0, [r7, #20]
    while(child) {
 800e16e:	697b      	ldr	r3, [r7, #20]
 800e170:	2b00      	cmp	r3, #0
 800e172:	d1f4      	bne.n	800e15e <invalidate_style_cache+0xb8>
 800e174:	e002      	b.n	800e17c <invalidate_style_cache+0xd6>
    if(style_prop_is_cacheble(prop) == false) return;
 800e176:	bf00      	nop
 800e178:	e000      	b.n	800e17c <invalidate_style_cache+0xd6>
        if(list == NULL) return;
 800e17a:	bf00      	nop
    }
}
 800e17c:	3718      	adds	r7, #24
 800e17e:	46bd      	mov	sp, r7
 800e180:	bd80      	pop	{r7, pc}

0800e182 <_lv_memcpy_small>:
{
 800e182:	b480      	push	{r7}
 800e184:	b087      	sub	sp, #28
 800e186:	af00      	add	r7, sp, #0
 800e188:	60f8      	str	r0, [r7, #12]
 800e18a:	60b9      	str	r1, [r7, #8]
 800e18c:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 800e18e:	68fb      	ldr	r3, [r7, #12]
 800e190:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 800e192:	68bb      	ldr	r3, [r7, #8]
 800e194:	613b      	str	r3, [r7, #16]
    while(len) {
 800e196:	e00c      	b.n	800e1b2 <_lv_memcpy_small+0x30>
        *d8 = *s8;
 800e198:	693b      	ldr	r3, [r7, #16]
 800e19a:	781a      	ldrb	r2, [r3, #0]
 800e19c:	697b      	ldr	r3, [r7, #20]
 800e19e:	701a      	strb	r2, [r3, #0]
        d8++;
 800e1a0:	697b      	ldr	r3, [r7, #20]
 800e1a2:	3301      	adds	r3, #1
 800e1a4:	617b      	str	r3, [r7, #20]
        s8++;
 800e1a6:	693b      	ldr	r3, [r7, #16]
 800e1a8:	3301      	adds	r3, #1
 800e1aa:	613b      	str	r3, [r7, #16]
        len--;
 800e1ac:	687b      	ldr	r3, [r7, #4]
 800e1ae:	3b01      	subs	r3, #1
 800e1b0:	607b      	str	r3, [r7, #4]
    while(len) {
 800e1b2:	687b      	ldr	r3, [r7, #4]
 800e1b4:	2b00      	cmp	r3, #0
 800e1b6:	d1ef      	bne.n	800e198 <_lv_memcpy_small+0x16>
    return dst;
 800e1b8:	68fb      	ldr	r3, [r7, #12]
}
 800e1ba:	4618      	mov	r0, r3
 800e1bc:	371c      	adds	r7, #28
 800e1be:	46bd      	mov	sp, r7
 800e1c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e1c4:	4770      	bx	lr

0800e1c6 <lv_area_copy>:
{
 800e1c6:	b580      	push	{r7, lr}
 800e1c8:	b082      	sub	sp, #8
 800e1ca:	af00      	add	r7, sp, #0
 800e1cc:	6078      	str	r0, [r7, #4]
 800e1ce:	6039      	str	r1, [r7, #0]
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
 800e1d0:	2208      	movs	r2, #8
 800e1d2:	6839      	ldr	r1, [r7, #0]
 800e1d4:	6878      	ldr	r0, [r7, #4]
 800e1d6:	f7ff ffd4 	bl	800e182 <_lv_memcpy_small>
}
 800e1da:	bf00      	nop
 800e1dc:	3708      	adds	r7, #8
 800e1de:	46bd      	mov	sp, r7
 800e1e0:	bd80      	pop	{r7, pc}

0800e1e2 <lv_area_get_width>:
{
 800e1e2:	b480      	push	{r7}
 800e1e4:	b083      	sub	sp, #12
 800e1e6:	af00      	add	r7, sp, #0
 800e1e8:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 800e1ea:	687b      	ldr	r3, [r7, #4]
 800e1ec:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800e1f0:	b29a      	uxth	r2, r3
 800e1f2:	687b      	ldr	r3, [r7, #4]
 800e1f4:	f9b3 3000 	ldrsh.w	r3, [r3]
 800e1f8:	b29b      	uxth	r3, r3
 800e1fa:	1ad3      	subs	r3, r2, r3
 800e1fc:	b29b      	uxth	r3, r3
 800e1fe:	3301      	adds	r3, #1
 800e200:	b29b      	uxth	r3, r3
 800e202:	b21b      	sxth	r3, r3
}
 800e204:	4618      	mov	r0, r3
 800e206:	370c      	adds	r7, #12
 800e208:	46bd      	mov	sp, r7
 800e20a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e20e:	4770      	bx	lr

0800e210 <lv_area_get_height>:
{
 800e210:	b480      	push	{r7}
 800e212:	b083      	sub	sp, #12
 800e214:	af00      	add	r7, sp, #0
 800e216:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 800e218:	687b      	ldr	r3, [r7, #4]
 800e21a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800e21e:	b29a      	uxth	r2, r3
 800e220:	687b      	ldr	r3, [r7, #4]
 800e222:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800e226:	b29b      	uxth	r3, r3
 800e228:	1ad3      	subs	r3, r2, r3
 800e22a:	b29b      	uxth	r3, r3
 800e22c:	3301      	adds	r3, #1
 800e22e:	b29b      	uxth	r3, r3
 800e230:	b21b      	sxth	r3, r3
}
 800e232:	4618      	mov	r0, r3
 800e234:	370c      	adds	r7, #12
 800e236:	46bd      	mov	sp, r7
 800e238:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e23c:	4770      	bx	lr

0800e23e <lv_obj_get_style_opa_scale>:
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
 800e23e:	b580      	push	{r7, lr}
 800e240:	b082      	sub	sp, #8
 800e242:	af00      	add	r7, sp, #0
 800e244:	6078      	str	r0, [r7, #4]
 800e246:	460b      	mov	r3, r1
 800e248:	70fb      	strb	r3, [r7, #3]
 800e24a:	78fb      	ldrb	r3, [r7, #3]
 800e24c:	f248 020c 	movw	r2, #32780	; 0x800c
 800e250:	4619      	mov	r1, r3
 800e252:	6878      	ldr	r0, [r7, #4]
 800e254:	f7fd f980 	bl	800b558 <_lv_obj_get_style_opa>
 800e258:	4603      	mov	r3, r0
 800e25a:	4618      	mov	r0, r3
 800e25c:	3708      	adds	r7, #8
 800e25e:	46bd      	mov	sp, r7
 800e260:	bd80      	pop	{r7, pc}

0800e262 <_lv_refr_init>:

/**
 * Initialize the screen refresh subsystem
 */
void _lv_refr_init(void)
{
 800e262:	b480      	push	{r7}
 800e264:	af00      	add	r7, sp, #0
    /*Nothing to do*/
}
 800e266:	bf00      	nop
 800e268:	46bd      	mov	sp, r7
 800e26a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e26e:	4770      	bx	lr

0800e270 <_lv_inv_area>:
 * @param area_p pointer to area which should be invalidated (NULL: delete the invalidated areas)
 * @param disp pointer to display where the area should be invalidated (NULL can be used if there is
 * only one display)
 */
void _lv_inv_area(lv_disp_t * disp, const lv_area_t * area_p)
{
 800e270:	b580      	push	{r7, lr}
 800e272:	b088      	sub	sp, #32
 800e274:	af00      	add	r7, sp, #0
 800e276:	6078      	str	r0, [r7, #4]
 800e278:	6039      	str	r1, [r7, #0]
    if(!disp) disp = lv_disp_get_default();
 800e27a:	687b      	ldr	r3, [r7, #4]
 800e27c:	2b00      	cmp	r3, #0
 800e27e:	d102      	bne.n	800e286 <_lv_inv_area+0x16>
 800e280:	f010 fbf8 	bl	801ea74 <lv_disp_get_default>
 800e284:	6078      	str	r0, [r7, #4]
    if(!disp) return;
 800e286:	687b      	ldr	r3, [r7, #4]
 800e288:	2b00      	cmp	r3, #0
 800e28a:	f000 80a2 	beq.w	800e3d2 <_lv_inv_area+0x162>

    /*Clear the invalidate buffer if the parameter is NULL*/
    if(area_p == NULL) {
 800e28e:	683b      	ldr	r3, [r7, #0]
 800e290:	2b00      	cmp	r3, #0
 800e292:	d107      	bne.n	800e2a4 <_lv_inv_area+0x34>
        disp->inv_p = 0;
 800e294:	687a      	ldr	r2, [r7, #4]
 800e296:	f8b2 3176 	ldrh.w	r3, [r2, #374]	; 0x176
 800e29a:	f36f 0309 	bfc	r3, #0, #10
 800e29e:	f8a2 3176 	strh.w	r3, [r2, #374]	; 0x176
        return;
 800e2a2:	e099      	b.n	800e3d8 <_lv_inv_area+0x168>
    }

    lv_area_t scr_area;
    scr_area.x1 = 0;
 800e2a4:	2300      	movs	r3, #0
 800e2a6:	82bb      	strh	r3, [r7, #20]
    scr_area.y1 = 0;
 800e2a8:	2300      	movs	r3, #0
 800e2aa:	82fb      	strh	r3, [r7, #22]
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
 800e2ac:	6878      	ldr	r0, [r7, #4]
 800e2ae:	f010 fbed 	bl	801ea8c <lv_disp_get_hor_res>
 800e2b2:	4603      	mov	r3, r0
 800e2b4:	b29b      	uxth	r3, r3
 800e2b6:	3b01      	subs	r3, #1
 800e2b8:	b29b      	uxth	r3, r3
 800e2ba:	b21b      	sxth	r3, r3
 800e2bc:	833b      	strh	r3, [r7, #24]
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
 800e2be:	6878      	ldr	r0, [r7, #4]
 800e2c0:	f010 fc06 	bl	801ead0 <lv_disp_get_ver_res>
 800e2c4:	4603      	mov	r3, r0
 800e2c6:	b29b      	uxth	r3, r3
 800e2c8:	3b01      	subs	r3, #1
 800e2ca:	b29b      	uxth	r3, r3
 800e2cc:	b21b      	sxth	r3, r3
 800e2ce:	837b      	strh	r3, [r7, #26]

    lv_area_t com_area;
    bool suc;

    suc = _lv_area_intersect(&com_area, area_p, &scr_area);
 800e2d0:	f107 0214 	add.w	r2, r7, #20
 800e2d4:	f107 030c 	add.w	r3, r7, #12
 800e2d8:	6839      	ldr	r1, [r7, #0]
 800e2da:	4618      	mov	r0, r3
 800e2dc:	f011 f8c6 	bl	801f46c <_lv_area_intersect>
 800e2e0:	4603      	mov	r3, r0
 800e2e2:	777b      	strb	r3, [r7, #29]

    /*The area is truncated to the screen*/
    if(suc != false) {
 800e2e4:	7f7b      	ldrb	r3, [r7, #29]
 800e2e6:	2b00      	cmp	r3, #0
 800e2e8:	d076      	beq.n	800e3d8 <_lv_inv_area+0x168>
        if(disp->driver.rounder_cb) disp->driver.rounder_cb(&disp->driver, &com_area);
 800e2ea:	687b      	ldr	r3, [r7, #4]
 800e2ec:	691b      	ldr	r3, [r3, #16]
 800e2ee:	2b00      	cmp	r3, #0
 800e2f0:	d006      	beq.n	800e300 <_lv_inv_area+0x90>
 800e2f2:	687b      	ldr	r3, [r7, #4]
 800e2f4:	691b      	ldr	r3, [r3, #16]
 800e2f6:	687a      	ldr	r2, [r7, #4]
 800e2f8:	f107 010c 	add.w	r1, r7, #12
 800e2fc:	4610      	mov	r0, r2
 800e2fe:	4798      	blx	r3

        /*Save only if this area is not in one of the saved areas*/
        uint16_t i;
        for(i = 0; i < disp->inv_p; i++) {
 800e300:	2300      	movs	r3, #0
 800e302:	83fb      	strh	r3, [r7, #30]
 800e304:	e011      	b.n	800e32a <_lv_inv_area+0xba>
            if(_lv_area_is_in(&com_area, &disp->inv_areas[i], 0) != false) return;
 800e306:	8bfb      	ldrh	r3, [r7, #30]
 800e308:	330a      	adds	r3, #10
 800e30a:	00db      	lsls	r3, r3, #3
 800e30c:	687a      	ldr	r2, [r7, #4]
 800e30e:	4413      	add	r3, r2
 800e310:	1d99      	adds	r1, r3, #6
 800e312:	f107 030c 	add.w	r3, r7, #12
 800e316:	2200      	movs	r2, #0
 800e318:	4618      	mov	r0, r3
 800e31a:	f011 fa89 	bl	801f830 <_lv_area_is_in>
 800e31e:	4603      	mov	r3, r0
 800e320:	2b00      	cmp	r3, #0
 800e322:	d158      	bne.n	800e3d6 <_lv_inv_area+0x166>
        for(i = 0; i < disp->inv_p; i++) {
 800e324:	8bfb      	ldrh	r3, [r7, #30]
 800e326:	3301      	adds	r3, #1
 800e328:	83fb      	strh	r3, [r7, #30]
 800e32a:	687b      	ldr	r3, [r7, #4]
 800e32c:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e330:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e334:	b29b      	uxth	r3, r3
 800e336:	461a      	mov	r2, r3
 800e338:	8bfb      	ldrh	r3, [r7, #30]
 800e33a:	4293      	cmp	r3, r2
 800e33c:	d3e3      	bcc.n	800e306 <_lv_inv_area+0x96>
        }

        /*Save the area*/
        if(disp->inv_p < LV_INV_BUF_SIZE) {
 800e33e:	687b      	ldr	r3, [r7, #4]
 800e340:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e344:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e348:	b29b      	uxth	r3, r3
 800e34a:	2b1f      	cmp	r3, #31
 800e34c:	d811      	bhi.n	800e372 <_lv_inv_area+0x102>
            lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);
 800e34e:	687b      	ldr	r3, [r7, #4]
 800e350:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e354:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e358:	b29b      	uxth	r3, r3
 800e35a:	330a      	adds	r3, #10
 800e35c:	00db      	lsls	r3, r3, #3
 800e35e:	687a      	ldr	r2, [r7, #4]
 800e360:	4413      	add	r3, r2
 800e362:	3306      	adds	r3, #6
 800e364:	f107 020c 	add.w	r2, r7, #12
 800e368:	4611      	mov	r1, r2
 800e36a:	4618      	mov	r0, r3
 800e36c:	f7ff ff2b 	bl	800e1c6 <lv_area_copy>
 800e370:	e017      	b.n	800e3a2 <_lv_inv_area+0x132>
        }
        else {   /*If no place for the area add the screen*/
            disp->inv_p = 0;
 800e372:	687a      	ldr	r2, [r7, #4]
 800e374:	f8b2 3176 	ldrh.w	r3, [r2, #374]	; 0x176
 800e378:	f36f 0309 	bfc	r3, #0, #10
 800e37c:	f8a2 3176 	strh.w	r3, [r2, #374]	; 0x176
            lv_area_copy(&disp->inv_areas[disp->inv_p], &scr_area);
 800e380:	687b      	ldr	r3, [r7, #4]
 800e382:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e386:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e38a:	b29b      	uxth	r3, r3
 800e38c:	330a      	adds	r3, #10
 800e38e:	00db      	lsls	r3, r3, #3
 800e390:	687a      	ldr	r2, [r7, #4]
 800e392:	4413      	add	r3, r2
 800e394:	3306      	adds	r3, #6
 800e396:	f107 0214 	add.w	r2, r7, #20
 800e39a:	4611      	mov	r1, r2
 800e39c:	4618      	mov	r0, r3
 800e39e:	f7ff ff12 	bl	800e1c6 <lv_area_copy>
        }
        disp->inv_p++;
 800e3a2:	687b      	ldr	r3, [r7, #4]
 800e3a4:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e3a8:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e3ac:	b29b      	uxth	r3, r3
 800e3ae:	3301      	adds	r3, #1
 800e3b0:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e3b4:	b299      	uxth	r1, r3
 800e3b6:	687a      	ldr	r2, [r7, #4]
 800e3b8:	f8b2 3176 	ldrh.w	r3, [r2, #374]	; 0x176
 800e3bc:	f361 0309 	bfi	r3, r1, #0, #10
 800e3c0:	f8a2 3176 	strh.w	r3, [r2, #374]	; 0x176
        lv_task_set_prio(disp->refr_task, LV_REFR_TASK_PRIO);
 800e3c4:	687b      	ldr	r3, [r7, #4]
 800e3c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e3c8:	2103      	movs	r1, #3
 800e3ca:	4618      	mov	r0, r3
 800e3cc:	f013 fd78 	bl	8021ec0 <lv_task_set_prio>
 800e3d0:	e002      	b.n	800e3d8 <_lv_inv_area+0x168>
    if(!disp) return;
 800e3d2:	bf00      	nop
 800e3d4:	e000      	b.n	800e3d8 <_lv_inv_area+0x168>
            if(_lv_area_is_in(&com_area, &disp->inv_areas[i], 0) != false) return;
 800e3d6:	bf00      	nop
    }
}
 800e3d8:	3720      	adds	r7, #32
 800e3da:	46bd      	mov	sp, r7
 800e3dc:	bd80      	pop	{r7, pc}
	...

0800e3e0 <_lv_refr_get_disp_refreshing>:
/**
 * Get the display which is being refreshed
 * @return the display being refreshed
 */
lv_disp_t * _lv_refr_get_disp_refreshing(void)
{
 800e3e0:	b480      	push	{r7}
 800e3e2:	af00      	add	r7, sp, #0
    return disp_refr;
 800e3e4:	4b03      	ldr	r3, [pc, #12]	; (800e3f4 <_lv_refr_get_disp_refreshing+0x14>)
 800e3e6:	681b      	ldr	r3, [r3, #0]
}
 800e3e8:	4618      	mov	r0, r3
 800e3ea:	46bd      	mov	sp, r7
 800e3ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e3f0:	4770      	bx	lr
 800e3f2:	bf00      	nop
 800e3f4:	200099fc 	.word	0x200099fc

0800e3f8 <_lv_disp_refr_task>:
/**
 * Called periodically to handle the refreshing
 * @param task pointer to the task itself
 */
void _lv_disp_refr_task(lv_task_t * task)
{
 800e3f8:	b580      	push	{r7, lr}
 800e3fa:	b08e      	sub	sp, #56	; 0x38
 800e3fc:	af00      	add	r7, sp, #0
 800e3fe:	6078      	str	r0, [r7, #4]
    LV_LOG_TRACE("lv_refr_task: started");

    uint32_t start = lv_tick_get();
 800e400:	f010 fc78 	bl	801ecf4 <lv_tick_get>
 800e404:	62b8      	str	r0, [r7, #40]	; 0x28
    uint32_t elaps = 0;
 800e406:	2300      	movs	r3, #0
 800e408:	627b      	str	r3, [r7, #36]	; 0x24

    disp_refr = task->user_data;
 800e40a:	687b      	ldr	r3, [r7, #4]
 800e40c:	68db      	ldr	r3, [r3, #12]
 800e40e:	4a82      	ldr	r2, [pc, #520]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e410:	6013      	str	r3, [r2, #0]

#if LV_USE_PERF_MONITOR == 0
    /* Ensure the task does not run again automatically.
     * This is done before refreshing in case refreshing invalidates something else.
     */
    lv_task_set_prio(task, LV_TASK_PRIO_OFF);
 800e412:	2100      	movs	r1, #0
 800e414:	6878      	ldr	r0, [r7, #4]
 800e416:	f013 fd53 	bl	8021ec0 <lv_task_set_prio>
#endif

    /*Do nothing if there is no active screen*/
    if(disp_refr->act_scr == NULL) {
 800e41a:	4b7f      	ldr	r3, [pc, #508]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e41c:	681b      	ldr	r3, [r3, #0]
 800e41e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800e420:	2b00      	cmp	r3, #0
 800e422:	d108      	bne.n	800e436 <_lv_disp_refr_task+0x3e>
        disp_refr->inv_p = 0;
 800e424:	4b7c      	ldr	r3, [pc, #496]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e426:	681a      	ldr	r2, [r3, #0]
 800e428:	f8b2 3176 	ldrh.w	r3, [r2, #374]	; 0x176
 800e42c:	f36f 0309 	bfc	r3, #0, #10
 800e430:	f8a2 3176 	strh.w	r3, [r2, #374]	; 0x176
        return;
 800e434:	e0ed      	b.n	800e612 <_lv_disp_refr_task+0x21a>
    }

    lv_refr_join_area();
 800e436:	f000 f8f3 	bl	800e620 <lv_refr_join_area>

    lv_refr_areas();
 800e43a:	f000 f995 	bl	800e768 <lv_refr_areas>

    /*If refresh happened ...*/
    if(disp_refr->inv_p != 0) {
 800e43e:	4b76      	ldr	r3, [pc, #472]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e440:	681b      	ldr	r3, [r3, #0]
 800e442:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e446:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e44a:	b29b      	uxth	r3, r3
 800e44c:	2b00      	cmp	r3, #0
 800e44e:	f000 80dc 	beq.w	800e60a <_lv_disp_refr_task+0x212>
        /* In true double buffered mode copy the refreshed areas to the new VDB to keep it up to date.
         * With set_px_cb we don't know anything about the buffer (even it's size) so skip copying.*/
        if(lv_disp_is_true_double_buf(disp_refr)) {
 800e452:	4b71      	ldr	r3, [pc, #452]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e454:	681b      	ldr	r3, [r3, #0]
 800e456:	4618      	mov	r0, r3
 800e458:	f010 fbfb 	bl	801ec52 <lv_disp_is_true_double_buf>
 800e45c:	4603      	mov	r3, r0
 800e45e:	2b00      	cmp	r3, #0
 800e460:	f000 80a8 	beq.w	800e5b4 <_lv_disp_refr_task+0x1bc>
            if(disp_refr->driver.set_px_cb) {
 800e464:	4b6c      	ldr	r3, [pc, #432]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e466:	681b      	ldr	r3, [r3, #0]
 800e468:	695b      	ldr	r3, [r3, #20]
 800e46a:	2b00      	cmp	r3, #0
 800e46c:	f040 80a2 	bne.w	800e5b4 <_lv_disp_refr_task+0x1bc>
                LV_LOG_WARN("Can't handle 2 screen sized buffers with set_px_cb. Display is not refreshed.");
            }
            else {
                lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 800e470:	4b69      	ldr	r3, [pc, #420]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e472:	681b      	ldr	r3, [r3, #0]
 800e474:	4618      	mov	r0, r3
 800e476:	f010 fbc9 	bl	801ec0c <lv_disp_get_buf>
 800e47a:	6238      	str	r0, [r7, #32]

                /*Flush the content of the VDB*/
                lv_refr_vdb_flush();
 800e47c:	f000 fda6 	bl	800efcc <lv_refr_vdb_flush>

                /* With true double buffering the flushing should be only the address change of the
                 * current frame buffer. Wait until the address change is ready and copy the changed
                 * content to the other frame buffer (new active VDB) to keep the buffers synchronized*/
                while(vdb->flushing);
 800e480:	bf00      	nop
 800e482:	6a3b      	ldr	r3, [r7, #32]
 800e484:	699b      	ldr	r3, [r3, #24]
 800e486:	2b00      	cmp	r3, #0
 800e488:	d1fb      	bne.n	800e482 <_lv_disp_refr_task+0x8a>

                lv_color_t * copy_buf = NULL;
 800e48a:	2300      	movs	r3, #0
 800e48c:	61fb      	str	r3, [r7, #28]
#if LV_USE_GPU_STM32_DMA2D
                LV_UNUSED(copy_buf);
#else
                copy_buf = _lv_mem_buf_get(disp_refr->driver.hor_res * sizeof(lv_color_t));
 800e48e:	4b62      	ldr	r3, [pc, #392]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e490:	681b      	ldr	r3, [r3, #0]
 800e492:	f9b3 3000 	ldrsh.w	r3, [r3]
 800e496:	005b      	lsls	r3, r3, #1
 800e498:	4618      	mov	r0, r3
 800e49a:	f012 fcf9 	bl	8020e90 <_lv_mem_buf_get>
 800e49e:	61f8      	str	r0, [r7, #28]
#endif

                uint8_t * buf_act = (uint8_t *)vdb->buf_act;
 800e4a0:	6a3b      	ldr	r3, [r7, #32]
 800e4a2:	689b      	ldr	r3, [r3, #8]
 800e4a4:	61bb      	str	r3, [r7, #24]
                uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
 800e4a6:	6a3b      	ldr	r3, [r7, #32]
 800e4a8:	689a      	ldr	r2, [r3, #8]
 800e4aa:	6a3b      	ldr	r3, [r7, #32]
 800e4ac:	681b      	ldr	r3, [r3, #0]
 800e4ae:	429a      	cmp	r2, r3
 800e4b0:	d102      	bne.n	800e4b8 <_lv_disp_refr_task+0xc0>
 800e4b2:	6a3b      	ldr	r3, [r7, #32]
 800e4b4:	685b      	ldr	r3, [r3, #4]
 800e4b6:	e001      	b.n	800e4bc <_lv_disp_refr_task+0xc4>
 800e4b8:	6a3b      	ldr	r3, [r7, #32]
 800e4ba:	681b      	ldr	r3, [r3, #0]
 800e4bc:	617b      	str	r3, [r7, #20]

                lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
 800e4be:	4b56      	ldr	r3, [pc, #344]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e4c0:	681b      	ldr	r3, [r3, #0]
 800e4c2:	4618      	mov	r0, r3
 800e4c4:	f010 fae2 	bl	801ea8c <lv_disp_get_hor_res>
 800e4c8:	4603      	mov	r3, r0
 800e4ca:	827b      	strh	r3, [r7, #18]
                uint16_t a;
                for(a = 0; a < disp_refr->inv_p; a++) {
 800e4cc:	2300      	movs	r3, #0
 800e4ce:	86fb      	strh	r3, [r7, #54]	; 0x36
 800e4d0:	e05f      	b.n	800e592 <_lv_disp_refr_task+0x19a>
                    if(disp_refr->inv_area_joined[a] == 0) {
 800e4d2:	4b51      	ldr	r3, [pc, #324]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e4d4:	681a      	ldr	r2, [r3, #0]
 800e4d6:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800e4d8:	4413      	add	r3, r2
 800e4da:	f893 3156 	ldrb.w	r3, [r3, #342]	; 0x156
 800e4de:	2b00      	cmp	r3, #0
 800e4e0:	d154      	bne.n	800e58c <_lv_disp_refr_task+0x194>
                        uint32_t start_offs =
                            (hres * disp_refr->inv_areas[a].y1 + disp_refr->inv_areas[a].x1) * sizeof(lv_color_t);
 800e4e2:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 800e4e6:	4b4c      	ldr	r3, [pc, #304]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e4e8:	6819      	ldr	r1, [r3, #0]
 800e4ea:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800e4ec:	330a      	adds	r3, #10
 800e4ee:	00db      	lsls	r3, r3, #3
 800e4f0:	440b      	add	r3, r1
 800e4f2:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 800e4f6:	fb03 f202 	mul.w	r2, r3, r2
 800e4fa:	4b47      	ldr	r3, [pc, #284]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e4fc:	6819      	ldr	r1, [r3, #0]
 800e4fe:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800e500:	330a      	adds	r3, #10
 800e502:	00db      	lsls	r3, r3, #3
 800e504:	440b      	add	r3, r1
 800e506:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800e50a:	4413      	add	r3, r2
                        uint32_t start_offs =
 800e50c:	005b      	lsls	r3, r3, #1
 800e50e:	633b      	str	r3, [r7, #48]	; 0x30
                                                lv_area_get_width(&disp_refr->inv_areas[a]),
                                                lv_area_get_height(&disp_refr->inv_areas[a]));
#else

                        lv_coord_t y;
                        uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
 800e510:	4b41      	ldr	r3, [pc, #260]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e512:	681a      	ldr	r2, [r3, #0]
 800e514:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800e516:	330a      	adds	r3, #10
 800e518:	00db      	lsls	r3, r3, #3
 800e51a:	4413      	add	r3, r2
 800e51c:	3306      	adds	r3, #6
 800e51e:	4618      	mov	r0, r3
 800e520:	f7ff fe5f 	bl	800e1e2 <lv_area_get_width>
 800e524:	4603      	mov	r3, r0
 800e526:	005b      	lsls	r3, r3, #1
 800e528:	60fb      	str	r3, [r7, #12]

                        for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
 800e52a:	4b3b      	ldr	r3, [pc, #236]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e52c:	681a      	ldr	r2, [r3, #0]
 800e52e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800e530:	330a      	adds	r3, #10
 800e532:	00db      	lsls	r3, r3, #3
 800e534:	4413      	add	r3, r2
 800e536:	891b      	ldrh	r3, [r3, #8]
 800e538:	85fb      	strh	r3, [r7, #46]	; 0x2e
 800e53a:	e01b      	b.n	800e574 <_lv_disp_refr_task+0x17c>
                            /* The frame buffer is probably in an external RAM where sequential access is much faster.
                             * So first copy a line into a buffer and write it back the ext. RAM */
                            _lv_memcpy(copy_buf, buf_ina + start_offs, line_length);
 800e53c:	697a      	ldr	r2, [r7, #20]
 800e53e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e540:	4413      	add	r3, r2
 800e542:	68fa      	ldr	r2, [r7, #12]
 800e544:	4619      	mov	r1, r3
 800e546:	69f8      	ldr	r0, [r7, #28]
 800e548:	f012 fe08 	bl	802115c <_lv_memcpy>
                            _lv_memcpy(buf_act + start_offs, copy_buf, line_length);
 800e54c:	69ba      	ldr	r2, [r7, #24]
 800e54e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800e550:	4413      	add	r3, r2
 800e552:	68fa      	ldr	r2, [r7, #12]
 800e554:	69f9      	ldr	r1, [r7, #28]
 800e556:	4618      	mov	r0, r3
 800e558:	f012 fe00 	bl	802115c <_lv_memcpy>
                            start_offs += hres * sizeof(lv_color_t);
 800e55c:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800e560:	005b      	lsls	r3, r3, #1
 800e562:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800e564:	4413      	add	r3, r2
 800e566:	633b      	str	r3, [r7, #48]	; 0x30
                        for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
 800e568:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 800e56c:	b29b      	uxth	r3, r3
 800e56e:	3301      	adds	r3, #1
 800e570:	b29b      	uxth	r3, r3
 800e572:	85fb      	strh	r3, [r7, #46]	; 0x2e
 800e574:	4b28      	ldr	r3, [pc, #160]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e576:	681a      	ldr	r2, [r3, #0]
 800e578:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800e57a:	330a      	adds	r3, #10
 800e57c:	00db      	lsls	r3, r3, #3
 800e57e:	4413      	add	r3, r2
 800e580:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800e584:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 800e588:	429a      	cmp	r2, r3
 800e58a:	ddd7      	ble.n	800e53c <_lv_disp_refr_task+0x144>
                for(a = 0; a < disp_refr->inv_p; a++) {
 800e58c:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800e58e:	3301      	adds	r3, #1
 800e590:	86fb      	strh	r3, [r7, #54]	; 0x36
 800e592:	4b21      	ldr	r3, [pc, #132]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e594:	681b      	ldr	r3, [r3, #0]
 800e596:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e59a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e59e:	b29b      	uxth	r3, r3
 800e5a0:	461a      	mov	r2, r3
 800e5a2:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 800e5a4:	4293      	cmp	r3, r2
 800e5a6:	d394      	bcc.n	800e4d2 <_lv_disp_refr_task+0xda>
                        }
#endif
                    }
                }

                if(copy_buf) _lv_mem_buf_release(copy_buf);
 800e5a8:	69fb      	ldr	r3, [r7, #28]
 800e5aa:	2b00      	cmp	r3, #0
 800e5ac:	d002      	beq.n	800e5b4 <_lv_disp_refr_task+0x1bc>
 800e5ae:	69f8      	ldr	r0, [r7, #28]
 800e5b0:	f012 fd4e 	bl	8021050 <_lv_mem_buf_release>
            }
        } /*End of true double buffer handling*/

        /*Clean up*/
        _lv_memset_00(disp_refr->inv_areas, sizeof(disp_refr->inv_areas));
 800e5b4:	4b18      	ldr	r3, [pc, #96]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e5b6:	681b      	ldr	r3, [r3, #0]
 800e5b8:	3356      	adds	r3, #86	; 0x56
 800e5ba:	f44f 7180 	mov.w	r1, #256	; 0x100
 800e5be:	4618      	mov	r0, r3
 800e5c0:	f013 f872 	bl	80216a8 <_lv_memset_00>
        _lv_memset_00(disp_refr->inv_area_joined, sizeof(disp_refr->inv_area_joined));
 800e5c4:	4b14      	ldr	r3, [pc, #80]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e5c6:	681b      	ldr	r3, [r3, #0]
 800e5c8:	f503 73ab 	add.w	r3, r3, #342	; 0x156
 800e5cc:	2120      	movs	r1, #32
 800e5ce:	4618      	mov	r0, r3
 800e5d0:	f013 f86a 	bl	80216a8 <_lv_memset_00>
        disp_refr->inv_p = 0;
 800e5d4:	4b10      	ldr	r3, [pc, #64]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e5d6:	681a      	ldr	r2, [r3, #0]
 800e5d8:	f8b2 3176 	ldrh.w	r3, [r2, #374]	; 0x176
 800e5dc:	f36f 0309 	bfc	r3, #0, #10
 800e5e0:	f8a2 3176 	strh.w	r3, [r2, #374]	; 0x176

        elaps = lv_tick_elaps(start);
 800e5e4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800e5e6:	f010 fb9f 	bl	801ed28 <lv_tick_elaps>
 800e5ea:	6278      	str	r0, [r7, #36]	; 0x24
        /*Call monitor cb if present*/
        if(disp_refr->driver.monitor_cb) {
 800e5ec:	4b0a      	ldr	r3, [pc, #40]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e5ee:	681b      	ldr	r3, [r3, #0]
 800e5f0:	699b      	ldr	r3, [r3, #24]
 800e5f2:	2b00      	cmp	r3, #0
 800e5f4:	d009      	beq.n	800e60a <_lv_disp_refr_task+0x212>
            disp_refr->driver.monitor_cb(&disp_refr->driver, elaps, px_num);
 800e5f6:	4b08      	ldr	r3, [pc, #32]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e5f8:	681b      	ldr	r3, [r3, #0]
 800e5fa:	699b      	ldr	r3, [r3, #24]
 800e5fc:	4a06      	ldr	r2, [pc, #24]	; (800e618 <_lv_disp_refr_task+0x220>)
 800e5fe:	6812      	ldr	r2, [r2, #0]
 800e600:	4610      	mov	r0, r2
 800e602:	4a06      	ldr	r2, [pc, #24]	; (800e61c <_lv_disp_refr_task+0x224>)
 800e604:	6812      	ldr	r2, [r2, #0]
 800e606:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800e608:	4798      	blx	r3
        }
    }

    _lv_mem_buf_free_all();
 800e60a:	f012 fd61 	bl	80210d0 <_lv_mem_buf_free_all>
    _lv_font_clean_up_fmt_txt();
 800e60e:	f00f fbc7 	bl	801dda0 <_lv_font_clean_up_fmt_txt>
        lv_obj_align(perf_label, NULL, LV_ALIGN_IN_BOTTOM_RIGHT, 0, 0);
    }
#endif

    LV_LOG_TRACE("lv_refr_task: ready");
}
 800e612:	3738      	adds	r7, #56	; 0x38
 800e614:	46bd      	mov	sp, r7
 800e616:	bd80      	pop	{r7, pc}
 800e618:	200099fc 	.word	0x200099fc
 800e61c:	200099f8 	.word	0x200099f8

0800e620 <lv_refr_join_area>:

/**
 * Join the areas which has got common parts
 */
static void lv_refr_join_area(void)
{
 800e620:	b5b0      	push	{r4, r5, r7, lr}
 800e622:	b084      	sub	sp, #16
 800e624:	af00      	add	r7, sp, #0
    uint32_t join_from;
    uint32_t join_in;
    lv_area_t joined_area;
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
 800e626:	2300      	movs	r3, #0
 800e628:	60bb      	str	r3, [r7, #8]
 800e62a:	e08a      	b.n	800e742 <lv_refr_join_area+0x122>
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
 800e62c:	4b4d      	ldr	r3, [pc, #308]	; (800e764 <lv_refr_join_area+0x144>)
 800e62e:	681a      	ldr	r2, [r3, #0]
 800e630:	68bb      	ldr	r3, [r7, #8]
 800e632:	4413      	add	r3, r2
 800e634:	f503 73ab 	add.w	r3, r3, #342	; 0x156
 800e638:	781b      	ldrb	r3, [r3, #0]
 800e63a:	2b00      	cmp	r3, #0
 800e63c:	d17d      	bne.n	800e73a <lv_refr_join_area+0x11a>

        /*Check all areas to join them in 'join_in'*/
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
 800e63e:	2300      	movs	r3, #0
 800e640:	60fb      	str	r3, [r7, #12]
 800e642:	e06e      	b.n	800e722 <lv_refr_join_area+0x102>
            /*Handle only unjoined areas and ignore itself*/
            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {
 800e644:	4b47      	ldr	r3, [pc, #284]	; (800e764 <lv_refr_join_area+0x144>)
 800e646:	681a      	ldr	r2, [r3, #0]
 800e648:	68fb      	ldr	r3, [r7, #12]
 800e64a:	4413      	add	r3, r2
 800e64c:	f503 73ab 	add.w	r3, r3, #342	; 0x156
 800e650:	781b      	ldrb	r3, [r3, #0]
 800e652:	2b00      	cmp	r3, #0
 800e654:	d15f      	bne.n	800e716 <lv_refr_join_area+0xf6>
 800e656:	68ba      	ldr	r2, [r7, #8]
 800e658:	68fb      	ldr	r3, [r7, #12]
 800e65a:	429a      	cmp	r2, r3
 800e65c:	d05b      	beq.n	800e716 <lv_refr_join_area+0xf6>
                continue;
            }

            /*Check if the areas are on each other*/
            if(_lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {
 800e65e:	4b41      	ldr	r3, [pc, #260]	; (800e764 <lv_refr_join_area+0x144>)
 800e660:	681a      	ldr	r2, [r3, #0]
 800e662:	68bb      	ldr	r3, [r7, #8]
 800e664:	330a      	adds	r3, #10
 800e666:	00db      	lsls	r3, r3, #3
 800e668:	4413      	add	r3, r2
 800e66a:	1d98      	adds	r0, r3, #6
 800e66c:	4b3d      	ldr	r3, [pc, #244]	; (800e764 <lv_refr_join_area+0x144>)
 800e66e:	681a      	ldr	r2, [r3, #0]
 800e670:	68fb      	ldr	r3, [r7, #12]
 800e672:	330a      	adds	r3, #10
 800e674:	00db      	lsls	r3, r3, #3
 800e676:	4413      	add	r3, r2
 800e678:	3306      	adds	r3, #6
 800e67a:	4619      	mov	r1, r3
 800e67c:	f011 f8aa 	bl	801f7d4 <_lv_area_is_on>
 800e680:	4603      	mov	r3, r0
 800e682:	f083 0301 	eor.w	r3, r3, #1
 800e686:	b2db      	uxtb	r3, r3
 800e688:	2b00      	cmp	r3, #0
 800e68a:	d146      	bne.n	800e71a <lv_refr_join_area+0xfa>
                continue;
            }

            _lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);
 800e68c:	4b35      	ldr	r3, [pc, #212]	; (800e764 <lv_refr_join_area+0x144>)
 800e68e:	681a      	ldr	r2, [r3, #0]
 800e690:	68bb      	ldr	r3, [r7, #8]
 800e692:	330a      	adds	r3, #10
 800e694:	00db      	lsls	r3, r3, #3
 800e696:	4413      	add	r3, r2
 800e698:	1d99      	adds	r1, r3, #6
 800e69a:	4b32      	ldr	r3, [pc, #200]	; (800e764 <lv_refr_join_area+0x144>)
 800e69c:	681a      	ldr	r2, [r3, #0]
 800e69e:	68fb      	ldr	r3, [r7, #12]
 800e6a0:	330a      	adds	r3, #10
 800e6a2:	00db      	lsls	r3, r3, #3
 800e6a4:	4413      	add	r3, r2
 800e6a6:	1d9a      	adds	r2, r3, #6
 800e6a8:	463b      	mov	r3, r7
 800e6aa:	4618      	mov	r0, r3
 800e6ac:	f010 ff2f 	bl	801f50e <_lv_area_join>

            /*Join two area only if the joined area size is smaller*/
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
 800e6b0:	463b      	mov	r3, r7
 800e6b2:	4618      	mov	r0, r3
 800e6b4:	f010 feb9 	bl	801f42a <lv_area_get_size>
 800e6b8:	4604      	mov	r4, r0
 800e6ba:	4b2a      	ldr	r3, [pc, #168]	; (800e764 <lv_refr_join_area+0x144>)
 800e6bc:	681a      	ldr	r2, [r3, #0]
 800e6be:	68bb      	ldr	r3, [r7, #8]
 800e6c0:	330a      	adds	r3, #10
 800e6c2:	00db      	lsls	r3, r3, #3
 800e6c4:	4413      	add	r3, r2
 800e6c6:	3306      	adds	r3, #6
 800e6c8:	4618      	mov	r0, r3
 800e6ca:	f010 feae 	bl	801f42a <lv_area_get_size>
 800e6ce:	4605      	mov	r5, r0
                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {
 800e6d0:	4b24      	ldr	r3, [pc, #144]	; (800e764 <lv_refr_join_area+0x144>)
 800e6d2:	681a      	ldr	r2, [r3, #0]
 800e6d4:	68fb      	ldr	r3, [r7, #12]
 800e6d6:	330a      	adds	r3, #10
 800e6d8:	00db      	lsls	r3, r3, #3
 800e6da:	4413      	add	r3, r2
 800e6dc:	3306      	adds	r3, #6
 800e6de:	4618      	mov	r0, r3
 800e6e0:	f010 fea3 	bl	801f42a <lv_area_get_size>
 800e6e4:	4603      	mov	r3, r0
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
 800e6e6:	442b      	add	r3, r5
 800e6e8:	429c      	cmp	r4, r3
 800e6ea:	d217      	bcs.n	800e71c <lv_refr_join_area+0xfc>
                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);
 800e6ec:	4b1d      	ldr	r3, [pc, #116]	; (800e764 <lv_refr_join_area+0x144>)
 800e6ee:	681a      	ldr	r2, [r3, #0]
 800e6f0:	68bb      	ldr	r3, [r7, #8]
 800e6f2:	330a      	adds	r3, #10
 800e6f4:	00db      	lsls	r3, r3, #3
 800e6f6:	4413      	add	r3, r2
 800e6f8:	3306      	adds	r3, #6
 800e6fa:	463a      	mov	r2, r7
 800e6fc:	4611      	mov	r1, r2
 800e6fe:	4618      	mov	r0, r3
 800e700:	f7ff fd61 	bl	800e1c6 <lv_area_copy>

                /*Mark 'join_form' is joined into 'join_in'*/
                disp_refr->inv_area_joined[join_from] = 1;
 800e704:	4b17      	ldr	r3, [pc, #92]	; (800e764 <lv_refr_join_area+0x144>)
 800e706:	681a      	ldr	r2, [r3, #0]
 800e708:	68fb      	ldr	r3, [r7, #12]
 800e70a:	4413      	add	r3, r2
 800e70c:	f503 73ab 	add.w	r3, r3, #342	; 0x156
 800e710:	2201      	movs	r2, #1
 800e712:	701a      	strb	r2, [r3, #0]
 800e714:	e002      	b.n	800e71c <lv_refr_join_area+0xfc>
                continue;
 800e716:	bf00      	nop
 800e718:	e000      	b.n	800e71c <lv_refr_join_area+0xfc>
                continue;
 800e71a:	bf00      	nop
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
 800e71c:	68fb      	ldr	r3, [r7, #12]
 800e71e:	3301      	adds	r3, #1
 800e720:	60fb      	str	r3, [r7, #12]
 800e722:	4b10      	ldr	r3, [pc, #64]	; (800e764 <lv_refr_join_area+0x144>)
 800e724:	681b      	ldr	r3, [r3, #0]
 800e726:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e72a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e72e:	b29b      	uxth	r3, r3
 800e730:	461a      	mov	r2, r3
 800e732:	68fb      	ldr	r3, [r7, #12]
 800e734:	4293      	cmp	r3, r2
 800e736:	d385      	bcc.n	800e644 <lv_refr_join_area+0x24>
 800e738:	e000      	b.n	800e73c <lv_refr_join_area+0x11c>
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
 800e73a:	bf00      	nop
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
 800e73c:	68bb      	ldr	r3, [r7, #8]
 800e73e:	3301      	adds	r3, #1
 800e740:	60bb      	str	r3, [r7, #8]
 800e742:	4b08      	ldr	r3, [pc, #32]	; (800e764 <lv_refr_join_area+0x144>)
 800e744:	681b      	ldr	r3, [r3, #0]
 800e746:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e74a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e74e:	b29b      	uxth	r3, r3
 800e750:	461a      	mov	r2, r3
 800e752:	68bb      	ldr	r3, [r7, #8]
 800e754:	4293      	cmp	r3, r2
 800e756:	f4ff af69 	bcc.w	800e62c <lv_refr_join_area+0xc>
            }
        }
    }
}
 800e75a:	bf00      	nop
 800e75c:	bf00      	nop
 800e75e:	3710      	adds	r7, #16
 800e760:	46bd      	mov	sp, r7
 800e762:	bdb0      	pop	{r4, r5, r7, pc}
 800e764:	200099fc 	.word	0x200099fc

0800e768 <lv_refr_areas>:

/**
 * Refresh the joined areas
 */
static void lv_refr_areas(void)
{
 800e768:	b580      	push	{r7, lr}
 800e76a:	b082      	sub	sp, #8
 800e76c:	af00      	add	r7, sp, #0
    px_num = 0;
 800e76e:	4b48      	ldr	r3, [pc, #288]	; (800e890 <lv_refr_areas+0x128>)
 800e770:	2200      	movs	r2, #0
 800e772:	601a      	str	r2, [r3, #0]

    if(disp_refr->inv_p == 0) return;
 800e774:	4b47      	ldr	r3, [pc, #284]	; (800e894 <lv_refr_areas+0x12c>)
 800e776:	681b      	ldr	r3, [r3, #0]
 800e778:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e77c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e780:	b29b      	uxth	r3, r3
 800e782:	2b00      	cmp	r3, #0
 800e784:	d07f      	beq.n	800e886 <lv_refr_areas+0x11e>

    /*Find the last area which will be drawn*/
    int32_t i;
    int32_t last_i = 0;
 800e786:	2300      	movs	r3, #0
 800e788:	603b      	str	r3, [r7, #0]
    for(i = disp_refr->inv_p - 1; i >= 0; i--) {
 800e78a:	4b42      	ldr	r3, [pc, #264]	; (800e894 <lv_refr_areas+0x12c>)
 800e78c:	681b      	ldr	r3, [r3, #0]
 800e78e:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e792:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e796:	b29b      	uxth	r3, r3
 800e798:	3b01      	subs	r3, #1
 800e79a:	607b      	str	r3, [r7, #4]
 800e79c:	e00e      	b.n	800e7bc <lv_refr_areas+0x54>
        if(disp_refr->inv_area_joined[i] == 0) {
 800e79e:	4b3d      	ldr	r3, [pc, #244]	; (800e894 <lv_refr_areas+0x12c>)
 800e7a0:	681a      	ldr	r2, [r3, #0]
 800e7a2:	687b      	ldr	r3, [r7, #4]
 800e7a4:	4413      	add	r3, r2
 800e7a6:	f503 73ab 	add.w	r3, r3, #342	; 0x156
 800e7aa:	781b      	ldrb	r3, [r3, #0]
 800e7ac:	2b00      	cmp	r3, #0
 800e7ae:	d102      	bne.n	800e7b6 <lv_refr_areas+0x4e>
            last_i = i;
 800e7b0:	687b      	ldr	r3, [r7, #4]
 800e7b2:	603b      	str	r3, [r7, #0]
            break;
 800e7b4:	e005      	b.n	800e7c2 <lv_refr_areas+0x5a>
    for(i = disp_refr->inv_p - 1; i >= 0; i--) {
 800e7b6:	687b      	ldr	r3, [r7, #4]
 800e7b8:	3b01      	subs	r3, #1
 800e7ba:	607b      	str	r3, [r7, #4]
 800e7bc:	687b      	ldr	r3, [r7, #4]
 800e7be:	2b00      	cmp	r3, #0
 800e7c0:	daed      	bge.n	800e79e <lv_refr_areas+0x36>
        }
    }

    disp_refr->driver.buffer->last_area = 0;
 800e7c2:	4b34      	ldr	r3, [pc, #208]	; (800e894 <lv_refr_areas+0x12c>)
 800e7c4:	681b      	ldr	r3, [r3, #0]
 800e7c6:	685a      	ldr	r2, [r3, #4]
 800e7c8:	f892 3020 	ldrb.w	r3, [r2, #32]
 800e7cc:	f36f 0300 	bfc	r3, #0, #1
 800e7d0:	f882 3020 	strb.w	r3, [r2, #32]
    disp_refr->driver.buffer->last_part = 0;
 800e7d4:	4b2f      	ldr	r3, [pc, #188]	; (800e894 <lv_refr_areas+0x12c>)
 800e7d6:	681b      	ldr	r3, [r3, #0]
 800e7d8:	685a      	ldr	r2, [r3, #4]
 800e7da:	f892 3020 	ldrb.w	r3, [r2, #32]
 800e7de:	f36f 0341 	bfc	r3, #1, #1
 800e7e2:	f882 3020 	strb.w	r3, [r2, #32]

    for(i = 0; i < disp_refr->inv_p; i++) {
 800e7e6:	2300      	movs	r3, #0
 800e7e8:	607b      	str	r3, [r7, #4]
 800e7ea:	e040      	b.n	800e86e <lv_refr_areas+0x106>
        /*Refresh the unjoined areas*/
        if(disp_refr->inv_area_joined[i] == 0) {
 800e7ec:	4b29      	ldr	r3, [pc, #164]	; (800e894 <lv_refr_areas+0x12c>)
 800e7ee:	681a      	ldr	r2, [r3, #0]
 800e7f0:	687b      	ldr	r3, [r7, #4]
 800e7f2:	4413      	add	r3, r2
 800e7f4:	f503 73ab 	add.w	r3, r3, #342	; 0x156
 800e7f8:	781b      	ldrb	r3, [r3, #0]
 800e7fa:	2b00      	cmp	r3, #0
 800e7fc:	d134      	bne.n	800e868 <lv_refr_areas+0x100>

            if(i == last_i) disp_refr->driver.buffer->last_area = 1;
 800e7fe:	687a      	ldr	r2, [r7, #4]
 800e800:	683b      	ldr	r3, [r7, #0]
 800e802:	429a      	cmp	r2, r3
 800e804:	d108      	bne.n	800e818 <lv_refr_areas+0xb0>
 800e806:	4b23      	ldr	r3, [pc, #140]	; (800e894 <lv_refr_areas+0x12c>)
 800e808:	681b      	ldr	r3, [r3, #0]
 800e80a:	685a      	ldr	r2, [r3, #4]
 800e80c:	f892 3020 	ldrb.w	r3, [r2, #32]
 800e810:	f043 0301 	orr.w	r3, r3, #1
 800e814:	f882 3020 	strb.w	r3, [r2, #32]
            disp_refr->driver.buffer->last_part = 0;
 800e818:	4b1e      	ldr	r3, [pc, #120]	; (800e894 <lv_refr_areas+0x12c>)
 800e81a:	681b      	ldr	r3, [r3, #0]
 800e81c:	685a      	ldr	r2, [r3, #4]
 800e81e:	f892 3020 	ldrb.w	r3, [r2, #32]
 800e822:	f36f 0341 	bfc	r3, #1, #1
 800e826:	f882 3020 	strb.w	r3, [r2, #32]
            lv_refr_area(&disp_refr->inv_areas[i]);
 800e82a:	4b1a      	ldr	r3, [pc, #104]	; (800e894 <lv_refr_areas+0x12c>)
 800e82c:	681a      	ldr	r2, [r3, #0]
 800e82e:	687b      	ldr	r3, [r7, #4]
 800e830:	330a      	adds	r3, #10
 800e832:	00db      	lsls	r3, r3, #3
 800e834:	4413      	add	r3, r2
 800e836:	3306      	adds	r3, #6
 800e838:	4618      	mov	r0, r3
 800e83a:	f000 f82d 	bl	800e898 <lv_refr_area>

            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
 800e83e:	4b15      	ldr	r3, [pc, #84]	; (800e894 <lv_refr_areas+0x12c>)
 800e840:	681b      	ldr	r3, [r3, #0]
 800e842:	699b      	ldr	r3, [r3, #24]
 800e844:	2b00      	cmp	r3, #0
 800e846:	d00f      	beq.n	800e868 <lv_refr_areas+0x100>
 800e848:	4b12      	ldr	r3, [pc, #72]	; (800e894 <lv_refr_areas+0x12c>)
 800e84a:	681a      	ldr	r2, [r3, #0]
 800e84c:	687b      	ldr	r3, [r7, #4]
 800e84e:	330a      	adds	r3, #10
 800e850:	00db      	lsls	r3, r3, #3
 800e852:	4413      	add	r3, r2
 800e854:	3306      	adds	r3, #6
 800e856:	4618      	mov	r0, r3
 800e858:	f010 fde7 	bl	801f42a <lv_area_get_size>
 800e85c:	4602      	mov	r2, r0
 800e85e:	4b0c      	ldr	r3, [pc, #48]	; (800e890 <lv_refr_areas+0x128>)
 800e860:	681b      	ldr	r3, [r3, #0]
 800e862:	4413      	add	r3, r2
 800e864:	4a0a      	ldr	r2, [pc, #40]	; (800e890 <lv_refr_areas+0x128>)
 800e866:	6013      	str	r3, [r2, #0]
    for(i = 0; i < disp_refr->inv_p; i++) {
 800e868:	687b      	ldr	r3, [r7, #4]
 800e86a:	3301      	adds	r3, #1
 800e86c:	607b      	str	r3, [r7, #4]
 800e86e:	4b09      	ldr	r3, [pc, #36]	; (800e894 <lv_refr_areas+0x12c>)
 800e870:	681b      	ldr	r3, [r3, #0]
 800e872:	f8b3 3176 	ldrh.w	r3, [r3, #374]	; 0x176
 800e876:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800e87a:	b29b      	uxth	r3, r3
 800e87c:	461a      	mov	r2, r3
 800e87e:	687b      	ldr	r3, [r7, #4]
 800e880:	4293      	cmp	r3, r2
 800e882:	dbb3      	blt.n	800e7ec <lv_refr_areas+0x84>
 800e884:	e000      	b.n	800e888 <lv_refr_areas+0x120>
    if(disp_refr->inv_p == 0) return;
 800e886:	bf00      	nop
        }
    }
}
 800e888:	3708      	adds	r7, #8
 800e88a:	46bd      	mov	sp, r7
 800e88c:	bd80      	pop	{r7, pc}
 800e88e:	bf00      	nop
 800e890:	200099f8 	.word	0x200099f8
 800e894:	200099fc 	.word	0x200099fc

0800e898 <lv_refr_area>:
/**
 * Refresh an area if there is Virtual Display Buffer
 * @param area_p  pointer to an area to refresh
 */
static void lv_refr_area(const lv_area_t * area_p)
{
 800e898:	b590      	push	{r4, r7, lr}
 800e89a:	b08d      	sub	sp, #52	; 0x34
 800e89c:	af00      	add	r7, sp, #0
 800e89e:	6078      	str	r0, [r7, #4]
    /*True double buffering: there are two screen sized buffers. Just redraw directly into a
     * buffer*/
    if(lv_disp_is_true_double_buf(disp_refr)) {
 800e8a0:	4b8e      	ldr	r3, [pc, #568]	; (800eadc <lv_refr_area+0x244>)
 800e8a2:	681b      	ldr	r3, [r3, #0]
 800e8a4:	4618      	mov	r0, r3
 800e8a6:	f010 f9d4 	bl	801ec52 <lv_disp_is_true_double_buf>
 800e8aa:	4603      	mov	r3, r0
 800e8ac:	2b00      	cmp	r3, #0
 800e8ae:	d030      	beq.n	800e912 <lv_refr_area+0x7a>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 800e8b0:	4b8a      	ldr	r3, [pc, #552]	; (800eadc <lv_refr_area+0x244>)
 800e8b2:	681b      	ldr	r3, [r3, #0]
 800e8b4:	4618      	mov	r0, r3
 800e8b6:	f010 f9a9 	bl	801ec0c <lv_disp_get_buf>
 800e8ba:	6178      	str	r0, [r7, #20]
        vdb->area.x1        = 0;
 800e8bc:	697b      	ldr	r3, [r7, #20]
 800e8be:	2200      	movs	r2, #0
 800e8c0:	821a      	strh	r2, [r3, #16]
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
 800e8c2:	4b86      	ldr	r3, [pc, #536]	; (800eadc <lv_refr_area+0x244>)
 800e8c4:	681b      	ldr	r3, [r3, #0]
 800e8c6:	4618      	mov	r0, r3
 800e8c8:	f010 f8e0 	bl	801ea8c <lv_disp_get_hor_res>
 800e8cc:	4603      	mov	r3, r0
 800e8ce:	b29b      	uxth	r3, r3
 800e8d0:	3b01      	subs	r3, #1
 800e8d2:	b29b      	uxth	r3, r3
 800e8d4:	b21a      	sxth	r2, r3
 800e8d6:	697b      	ldr	r3, [r7, #20]
 800e8d8:	829a      	strh	r2, [r3, #20]
        vdb->area.y1        = 0;
 800e8da:	697b      	ldr	r3, [r7, #20]
 800e8dc:	2200      	movs	r2, #0
 800e8de:	825a      	strh	r2, [r3, #18]
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
 800e8e0:	4b7e      	ldr	r3, [pc, #504]	; (800eadc <lv_refr_area+0x244>)
 800e8e2:	681b      	ldr	r3, [r3, #0]
 800e8e4:	4618      	mov	r0, r3
 800e8e6:	f010 f8f3 	bl	801ead0 <lv_disp_get_ver_res>
 800e8ea:	4603      	mov	r3, r0
 800e8ec:	b29b      	uxth	r3, r3
 800e8ee:	3b01      	subs	r3, #1
 800e8f0:	b29b      	uxth	r3, r3
 800e8f2:	b21a      	sxth	r2, r3
 800e8f4:	697b      	ldr	r3, [r7, #20]
 800e8f6:	82da      	strh	r2, [r3, #22]
        disp_refr->driver.buffer->last_part = 1;
 800e8f8:	4b78      	ldr	r3, [pc, #480]	; (800eadc <lv_refr_area+0x244>)
 800e8fa:	681b      	ldr	r3, [r3, #0]
 800e8fc:	685a      	ldr	r2, [r3, #4]
 800e8fe:	f892 3020 	ldrb.w	r3, [r2, #32]
 800e902:	f043 0302 	orr.w	r3, r3, #2
 800e906:	f882 3020 	strb.w	r3, [r2, #32]
        lv_refr_area_part(area_p);
 800e90a:	6878      	ldr	r0, [r7, #4]
 800e90c:	f000 f8e8 	bl	800eae0 <lv_refr_area_part>
 800e910:	e0e1      	b.n	800ead6 <lv_refr_area+0x23e>
    }
    /*The buffer is smaller: refresh the area in parts*/
    else {
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 800e912:	4b72      	ldr	r3, [pc, #456]	; (800eadc <lv_refr_area+0x244>)
 800e914:	681b      	ldr	r3, [r3, #0]
 800e916:	4618      	mov	r0, r3
 800e918:	f010 f978 	bl	801ec0c <lv_disp_get_buf>
 800e91c:	6238      	str	r0, [r7, #32]
        /*Calculate the max row num*/
        lv_coord_t w = lv_area_get_width(area_p);
 800e91e:	6878      	ldr	r0, [r7, #4]
 800e920:	f7ff fc5f 	bl	800e1e2 <lv_area_get_width>
 800e924:	4603      	mov	r3, r0
 800e926:	83fb      	strh	r3, [r7, #30]
        lv_coord_t h = lv_area_get_height(area_p);
 800e928:	6878      	ldr	r0, [r7, #4]
 800e92a:	f7ff fc71 	bl	800e210 <lv_area_get_height>
 800e92e:	4603      	mov	r3, r0
 800e930:	83bb      	strh	r3, [r7, #28]
        lv_coord_t y2 =
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
 800e932:	687b      	ldr	r3, [r7, #4]
 800e934:	f9b3 4006 	ldrsh.w	r4, [r3, #6]
 800e938:	4b68      	ldr	r3, [pc, #416]	; (800eadc <lv_refr_area+0x244>)
 800e93a:	681b      	ldr	r3, [r3, #0]
 800e93c:	4618      	mov	r0, r3
 800e93e:	f010 f8c7 	bl	801ead0 <lv_disp_get_ver_res>
 800e942:	4603      	mov	r3, r0
        lv_coord_t y2 =
 800e944:	429c      	cmp	r4, r3
 800e946:	db0a      	blt.n	800e95e <lv_refr_area+0xc6>
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
 800e948:	4b64      	ldr	r3, [pc, #400]	; (800eadc <lv_refr_area+0x244>)
 800e94a:	681b      	ldr	r3, [r3, #0]
 800e94c:	4618      	mov	r0, r3
 800e94e:	f010 f8bf 	bl	801ead0 <lv_disp_get_ver_res>
 800e952:	4603      	mov	r3, r0
 800e954:	b29b      	uxth	r3, r3
 800e956:	3b01      	subs	r3, #1
 800e958:	b29b      	uxth	r3, r3
        lv_coord_t y2 =
 800e95a:	b21b      	sxth	r3, r3
 800e95c:	e002      	b.n	800e964 <lv_refr_area+0xcc>
 800e95e:	687b      	ldr	r3, [r7, #4]
 800e960:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800e964:	837b      	strh	r3, [r7, #26]

        int32_t max_row = (uint32_t)vdb->size / w;
 800e966:	6a3b      	ldr	r3, [r7, #32]
 800e968:	68da      	ldr	r2, [r3, #12]
 800e96a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800e96e:	fbb2 f3f3 	udiv	r3, r2, r3
 800e972:	62fb      	str	r3, [r7, #44]	; 0x2c

        if(max_row > h) max_row = h;
 800e974:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 800e978:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800e97a:	429a      	cmp	r2, r3
 800e97c:	dd02      	ble.n	800e984 <lv_refr_area+0xec>
 800e97e:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 800e982:	62fb      	str	r3, [r7, #44]	; 0x2c

        /*Round down the lines of VDB if rounding is added*/
        if(disp_refr->driver.rounder_cb) {
 800e984:	4b55      	ldr	r3, [pc, #340]	; (800eadc <lv_refr_area+0x244>)
 800e986:	681b      	ldr	r3, [r3, #0]
 800e988:	691b      	ldr	r3, [r3, #16]
 800e98a:	2b00      	cmp	r3, #0
 800e98c:	d034      	beq.n	800e9f8 <lv_refr_area+0x160>
            lv_area_t tmp;
            tmp.x1 = 0;
 800e98e:	2300      	movs	r3, #0
 800e990:	81bb      	strh	r3, [r7, #12]
            tmp.x2 = 0;
 800e992:	2300      	movs	r3, #0
 800e994:	823b      	strh	r3, [r7, #16]
            tmp.y1 = 0;
 800e996:	2300      	movs	r3, #0
 800e998:	81fb      	strh	r3, [r7, #14]

            lv_coord_t h_tmp = max_row;
 800e99a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e99c:	857b      	strh	r3, [r7, #42]	; 0x2a
            do {
                tmp.y2 = h_tmp - 1;
 800e99e:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800e9a0:	3b01      	subs	r3, #1
 800e9a2:	b29b      	uxth	r3, r3
 800e9a4:	b21b      	sxth	r3, r3
 800e9a6:	827b      	strh	r3, [r7, #18]
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
 800e9a8:	4b4c      	ldr	r3, [pc, #304]	; (800eadc <lv_refr_area+0x244>)
 800e9aa:	681b      	ldr	r3, [r3, #0]
 800e9ac:	691b      	ldr	r3, [r3, #16]
 800e9ae:	4a4b      	ldr	r2, [pc, #300]	; (800eadc <lv_refr_area+0x244>)
 800e9b0:	6812      	ldr	r2, [r2, #0]
 800e9b2:	4610      	mov	r0, r2
 800e9b4:	f107 020c 	add.w	r2, r7, #12
 800e9b8:	4611      	mov	r1, r2
 800e9ba:	4798      	blx	r3

                /*If this height fits into `max_row` then fine*/
                if(lv_area_get_height(&tmp) <= max_row) break;
 800e9bc:	f107 030c 	add.w	r3, r7, #12
 800e9c0:	4618      	mov	r0, r3
 800e9c2:	f7ff fc25 	bl	800e210 <lv_area_get_height>
 800e9c6:	4603      	mov	r3, r0
 800e9c8:	461a      	mov	r2, r3
 800e9ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800e9cc:	4293      	cmp	r3, r2
 800e9ce:	da0a      	bge.n	800e9e6 <lv_refr_area+0x14e>

                /*Decrement the height of the area until it fits into `max_row` after rounding*/
                h_tmp--;
 800e9d0:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 800e9d4:	b29b      	uxth	r3, r3
 800e9d6:	3b01      	subs	r3, #1
 800e9d8:	b29b      	uxth	r3, r3
 800e9da:	857b      	strh	r3, [r7, #42]	; 0x2a
            } while(h_tmp > 0);
 800e9dc:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 800e9e0:	2b00      	cmp	r3, #0
 800e9e2:	dcdc      	bgt.n	800e99e <lv_refr_area+0x106>
 800e9e4:	e000      	b.n	800e9e8 <lv_refr_area+0x150>
                if(lv_area_get_height(&tmp) <= max_row) break;
 800e9e6:	bf00      	nop

            if(h_tmp <= 0) {
 800e9e8:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 800e9ec:	2b00      	cmp	r3, #0
 800e9ee:	dd71      	ble.n	800ead4 <lv_refr_area+0x23c>
                LV_LOG_WARN("Can't set VDB height using the round function. (Wrong round_cb or to "
                            "small VDB)");
                return;
            }
            else {
                max_row = tmp.y2 + 1;
 800e9f0:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 800e9f4:	3301      	adds	r3, #1
 800e9f6:	62fb      	str	r3, [r7, #44]	; 0x2c
            }
        }

        /*Always use the full row*/
        lv_coord_t row;
        lv_coord_t row_last = 0;
 800e9f8:	2300      	movs	r3, #0
 800e9fa:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
 800e9fc:	687b      	ldr	r3, [r7, #4]
 800e9fe:	885b      	ldrh	r3, [r3, #2]
 800ea00:	853b      	strh	r3, [r7, #40]	; 0x28
 800ea02:	e03b      	b.n	800ea7c <lv_refr_area+0x1e4>
            /*Calc. the next y coordinates of VDB*/
            vdb->area.x1 = area_p->x1;
 800ea04:	687b      	ldr	r3, [r7, #4]
 800ea06:	f9b3 2000 	ldrsh.w	r2, [r3]
 800ea0a:	6a3b      	ldr	r3, [r7, #32]
 800ea0c:	821a      	strh	r2, [r3, #16]
            vdb->area.x2 = area_p->x2;
 800ea0e:	687b      	ldr	r3, [r7, #4]
 800ea10:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 800ea14:	6a3b      	ldr	r3, [r7, #32]
 800ea16:	829a      	strh	r2, [r3, #20]
            vdb->area.y1 = row;
 800ea18:	6a3b      	ldr	r3, [r7, #32]
 800ea1a:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 800ea1c:	825a      	strh	r2, [r3, #18]
            vdb->area.y2 = row + max_row - 1;
 800ea1e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ea20:	b29a      	uxth	r2, r3
 800ea22:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800ea24:	4413      	add	r3, r2
 800ea26:	b29b      	uxth	r3, r3
 800ea28:	3b01      	subs	r3, #1
 800ea2a:	b29b      	uxth	r3, r3
 800ea2c:	b21a      	sxth	r2, r3
 800ea2e:	6a3b      	ldr	r3, [r7, #32]
 800ea30:	82da      	strh	r2, [r3, #22]
            if(vdb->area.y2 > y2) vdb->area.y2 = y2;
 800ea32:	6a3b      	ldr	r3, [r7, #32]
 800ea34:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800ea38:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 800ea3c:	429a      	cmp	r2, r3
 800ea3e:	da02      	bge.n	800ea46 <lv_refr_area+0x1ae>
 800ea40:	6a3b      	ldr	r3, [r7, #32]
 800ea42:	8b7a      	ldrh	r2, [r7, #26]
 800ea44:	82da      	strh	r2, [r3, #22]
            row_last = vdb->area.y2;
 800ea46:	6a3b      	ldr	r3, [r7, #32]
 800ea48:	8adb      	ldrh	r3, [r3, #22]
 800ea4a:	84fb      	strh	r3, [r7, #38]	; 0x26
            if(y2 == row_last) disp_refr->driver.buffer->last_part = 1;
 800ea4c:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 800ea50:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 800ea54:	429a      	cmp	r2, r3
 800ea56:	d108      	bne.n	800ea6a <lv_refr_area+0x1d2>
 800ea58:	4b20      	ldr	r3, [pc, #128]	; (800eadc <lv_refr_area+0x244>)
 800ea5a:	681b      	ldr	r3, [r3, #0]
 800ea5c:	685a      	ldr	r2, [r3, #4]
 800ea5e:	f892 3020 	ldrb.w	r3, [r2, #32]
 800ea62:	f043 0302 	orr.w	r3, r3, #2
 800ea66:	f882 3020 	strb.w	r3, [r2, #32]
            lv_refr_area_part(area_p);
 800ea6a:	6878      	ldr	r0, [r7, #4]
 800ea6c:	f000 f838 	bl	800eae0 <lv_refr_area_part>
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
 800ea70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ea72:	b29a      	uxth	r2, r3
 800ea74:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800ea76:	4413      	add	r3, r2
 800ea78:	b29b      	uxth	r3, r3
 800ea7a:	853b      	strh	r3, [r7, #40]	; 0x28
 800ea7c:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
 800ea80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ea82:	4413      	add	r3, r2
 800ea84:	1e5a      	subs	r2, r3, #1
 800ea86:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800ea8a:	429a      	cmp	r2, r3
 800ea8c:	ddba      	ble.n	800ea04 <lv_refr_area+0x16c>
        }

        /*If the last y coordinates are not handled yet ...*/
        if(y2 != row_last) {
 800ea8e:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 800ea92:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 800ea96:	429a      	cmp	r2, r3
 800ea98:	d01d      	beq.n	800ead6 <lv_refr_area+0x23e>
            /*Calc. the next y coordinates of VDB*/
            vdb->area.x1 = area_p->x1;
 800ea9a:	687b      	ldr	r3, [r7, #4]
 800ea9c:	f9b3 2000 	ldrsh.w	r2, [r3]
 800eaa0:	6a3b      	ldr	r3, [r7, #32]
 800eaa2:	821a      	strh	r2, [r3, #16]
            vdb->area.x2 = area_p->x2;
 800eaa4:	687b      	ldr	r3, [r7, #4]
 800eaa6:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 800eaaa:	6a3b      	ldr	r3, [r7, #32]
 800eaac:	829a      	strh	r2, [r3, #20]
            vdb->area.y1 = row;
 800eaae:	6a3b      	ldr	r3, [r7, #32]
 800eab0:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 800eab2:	825a      	strh	r2, [r3, #18]
            vdb->area.y2 = y2;
 800eab4:	6a3b      	ldr	r3, [r7, #32]
 800eab6:	8b7a      	ldrh	r2, [r7, #26]
 800eab8:	82da      	strh	r2, [r3, #22]

            disp_refr->driver.buffer->last_part = 1;
 800eaba:	4b08      	ldr	r3, [pc, #32]	; (800eadc <lv_refr_area+0x244>)
 800eabc:	681b      	ldr	r3, [r3, #0]
 800eabe:	685a      	ldr	r2, [r3, #4]
 800eac0:	f892 3020 	ldrb.w	r3, [r2, #32]
 800eac4:	f043 0302 	orr.w	r3, r3, #2
 800eac8:	f882 3020 	strb.w	r3, [r2, #32]
            lv_refr_area_part(area_p);
 800eacc:	6878      	ldr	r0, [r7, #4]
 800eace:	f000 f807 	bl	800eae0 <lv_refr_area_part>
 800ead2:	e000      	b.n	800ead6 <lv_refr_area+0x23e>
                return;
 800ead4:	bf00      	nop
        }
    }
}
 800ead6:	3734      	adds	r7, #52	; 0x34
 800ead8:	46bd      	mov	sp, r7
 800eada:	bd90      	pop	{r4, r7, pc}
 800eadc:	200099fc 	.word	0x200099fc

0800eae0 <lv_refr_area_part>:
/**
 * Refresh a part of an area which is on the actual Virtual Display Buffer
 * @param area_p pointer to an area to refresh
 */
static void lv_refr_area_part(const lv_area_t * area_p)
{
 800eae0:	b580      	push	{r7, lr}
 800eae2:	b0a6      	sub	sp, #152	; 0x98
 800eae4:	af02      	add	r7, sp, #8
 800eae6:	6078      	str	r0, [r7, #4]
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 800eae8:	4b81      	ldr	r3, [pc, #516]	; (800ecf0 <lv_refr_area_part+0x210>)
 800eaea:	681b      	ldr	r3, [r3, #0]
 800eaec:	4618      	mov	r0, r3
 800eaee:	f010 f88d 	bl	801ec0c <lv_disp_get_buf>
 800eaf2:	f8c7 0084 	str.w	r0, [r7, #132]	; 0x84

    /*In non double buffered mode, before rendering the next part wait until the previous image is
     * flushed*/
    if(lv_disp_is_double_buf(disp_refr) == false) {
 800eaf6:	4b7e      	ldr	r3, [pc, #504]	; (800ecf0 <lv_refr_area_part+0x210>)
 800eaf8:	681b      	ldr	r3, [r3, #0]
 800eafa:	4618      	mov	r0, r3
 800eafc:	f010 f892 	bl	801ec24 <lv_disp_is_double_buf>
 800eb00:	4603      	mov	r3, r0
 800eb02:	f083 0301 	eor.w	r3, r3, #1
 800eb06:	b2db      	uxtb	r3, r3
 800eb08:	2b00      	cmp	r3, #0
 800eb0a:	d011      	beq.n	800eb30 <lv_refr_area_part+0x50>
        while(vdb->flushing) {
 800eb0c:	e00b      	b.n	800eb26 <lv_refr_area_part+0x46>
            if(disp_refr->driver.wait_cb) disp_refr->driver.wait_cb(&disp_refr->driver);
 800eb0e:	4b78      	ldr	r3, [pc, #480]	; (800ecf0 <lv_refr_area_part+0x210>)
 800eb10:	681b      	ldr	r3, [r3, #0]
 800eb12:	69db      	ldr	r3, [r3, #28]
 800eb14:	2b00      	cmp	r3, #0
 800eb16:	d006      	beq.n	800eb26 <lv_refr_area_part+0x46>
 800eb18:	4b75      	ldr	r3, [pc, #468]	; (800ecf0 <lv_refr_area_part+0x210>)
 800eb1a:	681b      	ldr	r3, [r3, #0]
 800eb1c:	69db      	ldr	r3, [r3, #28]
 800eb1e:	4a74      	ldr	r2, [pc, #464]	; (800ecf0 <lv_refr_area_part+0x210>)
 800eb20:	6812      	ldr	r2, [r2, #0]
 800eb22:	4610      	mov	r0, r2
 800eb24:	4798      	blx	r3
        while(vdb->flushing) {
 800eb26:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800eb2a:	699b      	ldr	r3, [r3, #24]
 800eb2c:	2b00      	cmp	r3, #0
 800eb2e:	d1ee      	bne.n	800eb0e <lv_refr_area_part+0x2e>
        }
    }

    lv_obj_t * top_act_scr = NULL;
 800eb30:	2300      	movs	r3, #0
 800eb32:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    lv_obj_t * top_prev_scr = NULL;
 800eb36:	2300      	movs	r3, #0
 800eb38:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

    /*Get the new mask from the original area and the act. VDB
     It will be a part of 'area_p'*/
    lv_area_t start_mask;
    _lv_area_intersect(&start_mask, area_p, &vdb->area);
 800eb3c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 800eb40:	f103 0210 	add.w	r2, r3, #16
 800eb44:	f107 0378 	add.w	r3, r7, #120	; 0x78
 800eb48:	6879      	ldr	r1, [r7, #4]
 800eb4a:	4618      	mov	r0, r3
 800eb4c:	f010 fc8e 	bl	801f46c <_lv_area_intersect>

    /*Get the most top object which is not covered by others*/
    top_act_scr = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));
 800eb50:	4b67      	ldr	r3, [pc, #412]	; (800ecf0 <lv_refr_area_part+0x210>)
 800eb52:	681b      	ldr	r3, [r3, #0]
 800eb54:	4618      	mov	r0, r3
 800eb56:	f7f9 f9a1 	bl	8007e9c <lv_disp_get_scr_act>
 800eb5a:	4602      	mov	r2, r0
 800eb5c:	f107 0378 	add.w	r3, r7, #120	; 0x78
 800eb60:	4611      	mov	r1, r2
 800eb62:	4618      	mov	r0, r3
 800eb64:	f000 f8c6 	bl	800ecf4 <lv_refr_get_top_obj>
 800eb68:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
    if(disp_refr->prev_scr) {
 800eb6c:	4b60      	ldr	r3, [pc, #384]	; (800ecf0 <lv_refr_area_part+0x210>)
 800eb6e:	681b      	ldr	r3, [r3, #0]
 800eb70:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800eb72:	2b00      	cmp	r3, #0
 800eb74:	d00a      	beq.n	800eb8c <lv_refr_area_part+0xac>
        top_prev_scr = lv_refr_get_top_obj(&start_mask, disp_refr->prev_scr);
 800eb76:	4b5e      	ldr	r3, [pc, #376]	; (800ecf0 <lv_refr_area_part+0x210>)
 800eb78:	681b      	ldr	r3, [r3, #0]
 800eb7a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800eb7c:	f107 0378 	add.w	r3, r7, #120	; 0x78
 800eb80:	4611      	mov	r1, r2
 800eb82:	4618      	mov	r0, r3
 800eb84:	f000 f8b6 	bl	800ecf4 <lv_refr_get_top_obj>
 800eb88:	f8c7 0088 	str.w	r0, [r7, #136]	; 0x88
    }

    /*Draw a display background if there is no top object*/
    if(top_act_scr == NULL && top_prev_scr == NULL) {
 800eb8c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800eb90:	2b00      	cmp	r3, #0
 800eb92:	d15e      	bne.n	800ec52 <lv_refr_area_part+0x172>
 800eb94:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800eb98:	2b00      	cmp	r3, #0
 800eb9a:	d15a      	bne.n	800ec52 <lv_refr_area_part+0x172>
        if(disp_refr->bg_img) {
 800eb9c:	4b54      	ldr	r3, [pc, #336]	; (800ecf0 <lv_refr_area_part+0x210>)
 800eb9e:	681b      	ldr	r3, [r3, #0]
 800eba0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800eba2:	2b00      	cmp	r3, #0
 800eba4:	d03d      	beq.n	800ec22 <lv_refr_area_part+0x142>
            lv_draw_img_dsc_t dsc;
            lv_draw_img_dsc_init(&dsc);
 800eba6:	f107 0368 	add.w	r3, r7, #104	; 0x68
 800ebaa:	4618      	mov	r0, r3
 800ebac:	f003 fc2e 	bl	801240c <lv_draw_img_dsc_init>
            dsc.opa = disp_refr->bg_opa;
 800ebb0:	4b4f      	ldr	r3, [pc, #316]	; (800ecf0 <lv_refr_area_part+0x210>)
 800ebb2:	681b      	ldr	r3, [r3, #0]
 800ebb4:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800ebb8:	f887 3068 	strb.w	r3, [r7, #104]	; 0x68
            lv_img_header_t header;
            lv_res_t res;
            res = lv_img_decoder_get_info(disp_refr->bg_img, &header);
 800ebbc:	4b4c      	ldr	r3, [pc, #304]	; (800ecf0 <lv_refr_area_part+0x210>)
 800ebbe:	681b      	ldr	r3, [r3, #0]
 800ebc0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800ebc2:	f107 0264 	add.w	r2, r7, #100	; 0x64
 800ebc6:	4611      	mov	r1, r2
 800ebc8:	4618      	mov	r0, r3
 800ebca:	f00d ff2f 	bl	801ca2c <lv_img_decoder_get_info>
 800ebce:	4603      	mov	r3, r0
 800ebd0:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
            if(res == LV_RES_OK) {
 800ebd4:	f897 3083 	ldrb.w	r3, [r7, #131]	; 0x83
 800ebd8:	2b01      	cmp	r3, #1
 800ebda:	d13a      	bne.n	800ec52 <lv_refr_area_part+0x172>
                lv_area_t a;
                lv_area_set(&a, 0, 0, header.w - 1, header.h - 1);
 800ebdc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800ebde:	f3c3 238a 	ubfx	r3, r3, #10, #11
 800ebe2:	b29b      	uxth	r3, r3
 800ebe4:	3b01      	subs	r3, #1
 800ebe6:	b29b      	uxth	r3, r3
 800ebe8:	b21a      	sxth	r2, r3
 800ebea:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800ebee:	f3c3 134a 	ubfx	r3, r3, #5, #11
 800ebf2:	b29b      	uxth	r3, r3
 800ebf4:	3b01      	subs	r3, #1
 800ebf6:	b29b      	uxth	r3, r3
 800ebf8:	b21b      	sxth	r3, r3
 800ebfa:	f107 005c 	add.w	r0, r7, #92	; 0x5c
 800ebfe:	9300      	str	r3, [sp, #0]
 800ec00:	4613      	mov	r3, r2
 800ec02:	2200      	movs	r2, #0
 800ec04:	2100      	movs	r1, #0
 800ec06:	f010 fbd9 	bl	801f3bc <lv_area_set>
                lv_draw_img(&a, &start_mask, disp_refr->bg_img, &dsc);
 800ec0a:	4b39      	ldr	r3, [pc, #228]	; (800ecf0 <lv_refr_area_part+0x210>)
 800ec0c:	681b      	ldr	r3, [r3, #0]
 800ec0e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800ec10:	f107 0368 	add.w	r3, r7, #104	; 0x68
 800ec14:	f107 0178 	add.w	r1, r7, #120	; 0x78
 800ec18:	f107 005c 	add.w	r0, r7, #92	; 0x5c
 800ec1c:	f003 fc1e 	bl	801245c <lv_draw_img>
 800ec20:	e017      	b.n	800ec52 <lv_refr_area_part+0x172>
                LV_LOG_WARN("Can't draw the background image")
            }
        }
        else {
            lv_draw_rect_dsc_t dsc;
            lv_draw_rect_dsc_init(&dsc);
 800ec22:	f107 0308 	add.w	r3, r7, #8
 800ec26:	4618      	mov	r0, r3
 800ec28:	f008 fdec 	bl	8017804 <lv_draw_rect_dsc_init>
            dsc.bg_color = disp_refr->bg_color;
 800ec2c:	4b30      	ldr	r3, [pc, #192]	; (800ecf0 <lv_refr_area_part+0x210>)
 800ec2e:	681b      	ldr	r3, [r3, #0]
 800ec30:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 800ec34:	817b      	strh	r3, [r7, #10]
            dsc.bg_opa = disp_refr->bg_opa;
 800ec36:	4b2e      	ldr	r3, [pc, #184]	; (800ecf0 <lv_refr_area_part+0x210>)
 800ec38:	681b      	ldr	r3, [r3, #0]
 800ec3a:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 800ec3e:	753b      	strb	r3, [r7, #20]
            lv_draw_rect(&start_mask, &start_mask, &dsc);
 800ec40:	f107 0208 	add.w	r2, r7, #8
 800ec44:	f107 0178 	add.w	r1, r7, #120	; 0x78
 800ec48:	f107 0378 	add.w	r3, r7, #120	; 0x78
 800ec4c:	4618      	mov	r0, r3
 800ec4e:	f008 fe67 	bl	8017920 <lv_draw_rect>

        }
    }
    /*Refresh the previous screen if any*/
    if(disp_refr->prev_scr) {
 800ec52:	4b27      	ldr	r3, [pc, #156]	; (800ecf0 <lv_refr_area_part+0x210>)
 800ec54:	681b      	ldr	r3, [r3, #0]
 800ec56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ec58:	2b00      	cmp	r3, #0
 800ec5a:	d00f      	beq.n	800ec7c <lv_refr_area_part+0x19c>
        /*Get the most top object which is not covered by others*/
        if(top_prev_scr == NULL) {
 800ec5c:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 800ec60:	2b00      	cmp	r3, #0
 800ec62:	d104      	bne.n	800ec6e <lv_refr_area_part+0x18e>
            top_prev_scr = disp_refr->prev_scr;
 800ec64:	4b22      	ldr	r3, [pc, #136]	; (800ecf0 <lv_refr_area_part+0x210>)
 800ec66:	681b      	ldr	r3, [r3, #0]
 800ec68:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ec6a:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
        }
        /*Do the refreshing from the top object*/
        lv_refr_obj_and_children(top_prev_scr, &start_mask);
 800ec6e:	f107 0378 	add.w	r3, r7, #120	; 0x78
 800ec72:	4619      	mov	r1, r3
 800ec74:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
 800ec78:	f000 f896 	bl	800eda8 <lv_refr_obj_and_children>

    }


    if(top_act_scr == NULL) {
 800ec7c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 800ec80:	2b00      	cmp	r3, #0
 800ec82:	d104      	bne.n	800ec8e <lv_refr_area_part+0x1ae>
        top_act_scr = disp_refr->act_scr;
 800ec84:	4b1a      	ldr	r3, [pc, #104]	; (800ecf0 <lv_refr_area_part+0x210>)
 800ec86:	681b      	ldr	r3, [r3, #0]
 800ec88:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ec8a:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    }
    /*Do the refreshing from the top object*/
    lv_refr_obj_and_children(top_act_scr, &start_mask);
 800ec8e:	f107 0378 	add.w	r3, r7, #120	; 0x78
 800ec92:	4619      	mov	r1, r3
 800ec94:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 800ec98:	f000 f886 	bl	800eda8 <lv_refr_obj_and_children>

    /*Also refresh top and sys layer unconditionally*/
    lv_refr_obj_and_children(lv_disp_get_layer_top(disp_refr), &start_mask);
 800ec9c:	4b14      	ldr	r3, [pc, #80]	; (800ecf0 <lv_refr_area_part+0x210>)
 800ec9e:	681b      	ldr	r3, [r3, #0]
 800eca0:	4618      	mov	r0, r3
 800eca2:	f7f9 f925 	bl	8007ef0 <lv_disp_get_layer_top>
 800eca6:	4602      	mov	r2, r0
 800eca8:	f107 0378 	add.w	r3, r7, #120	; 0x78
 800ecac:	4619      	mov	r1, r3
 800ecae:	4610      	mov	r0, r2
 800ecb0:	f000 f87a 	bl	800eda8 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_sys(disp_refr), &start_mask);
 800ecb4:	4b0e      	ldr	r3, [pc, #56]	; (800ecf0 <lv_refr_area_part+0x210>)
 800ecb6:	681b      	ldr	r3, [r3, #0]
 800ecb8:	4618      	mov	r0, r3
 800ecba:	f7f9 f92e 	bl	8007f1a <lv_disp_get_layer_sys>
 800ecbe:	4602      	mov	r2, r0
 800ecc0:	f107 0378 	add.w	r3, r7, #120	; 0x78
 800ecc4:	4619      	mov	r1, r3
 800ecc6:	4610      	mov	r0, r2
 800ecc8:	f000 f86e 	bl	800eda8 <lv_refr_obj_and_children>

    /* In true double buffered mode flush only once when all areas were rendered.
     * In normal mode flush after every area */
    if(lv_disp_is_true_double_buf(disp_refr) == false) {
 800eccc:	4b08      	ldr	r3, [pc, #32]	; (800ecf0 <lv_refr_area_part+0x210>)
 800ecce:	681b      	ldr	r3, [r3, #0]
 800ecd0:	4618      	mov	r0, r3
 800ecd2:	f00f ffbe 	bl	801ec52 <lv_disp_is_true_double_buf>
 800ecd6:	4603      	mov	r3, r0
 800ecd8:	f083 0301 	eor.w	r3, r3, #1
 800ecdc:	b2db      	uxtb	r3, r3
 800ecde:	2b00      	cmp	r3, #0
 800ece0:	d001      	beq.n	800ece6 <lv_refr_area_part+0x206>
        lv_refr_vdb_flush();
 800ece2:	f000 f973 	bl	800efcc <lv_refr_vdb_flush>
    }
}
 800ece6:	bf00      	nop
 800ece8:	3790      	adds	r7, #144	; 0x90
 800ecea:	46bd      	mov	sp, r7
 800ecec:	bd80      	pop	{r7, pc}
 800ecee:	bf00      	nop
 800ecf0:	200099fc 	.word	0x200099fc

0800ecf4 <lv_refr_get_top_obj>:
 * @param area_p pointer to an area
 * @param obj the first object to start the searching (typically a screen)
 * @return
 */
static lv_obj_t * lv_refr_get_top_obj(const lv_area_t * area_p, lv_obj_t * obj)
{
 800ecf4:	b580      	push	{r7, lr}
 800ecf6:	b086      	sub	sp, #24
 800ecf8:	af00      	add	r7, sp, #0
 800ecfa:	6078      	str	r0, [r7, #4]
 800ecfc:	6039      	str	r1, [r7, #0]
    lv_obj_t * found_p = NULL;
 800ecfe:	2300      	movs	r3, #0
 800ed00:	617b      	str	r3, [r7, #20]

    /*If this object is fully cover the draw area check the children too */
    if(_lv_area_is_in(area_p, &obj->coords, 0) && obj->hidden == 0) {
 800ed02:	683b      	ldr	r3, [r7, #0]
 800ed04:	3310      	adds	r3, #16
 800ed06:	2200      	movs	r2, #0
 800ed08:	4619      	mov	r1, r3
 800ed0a:	6878      	ldr	r0, [r7, #4]
 800ed0c:	f010 fd90 	bl	801f830 <_lv_area_is_in>
 800ed10:	4603      	mov	r3, r0
 800ed12:	2b00      	cmp	r3, #0
 800ed14:	d043      	beq.n	800ed9e <lv_refr_get_top_obj+0xaa>
 800ed16:	683b      	ldr	r3, [r7, #0]
 800ed18:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800ed1c:	f003 0310 	and.w	r3, r3, #16
 800ed20:	b2db      	uxtb	r3, r3
 800ed22:	2b00      	cmp	r3, #0
 800ed24:	d13b      	bne.n	800ed9e <lv_refr_get_top_obj+0xaa>
        lv_design_res_t design_res = obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK);
 800ed26:	683b      	ldr	r3, [r7, #0]
 800ed28:	6a1b      	ldr	r3, [r3, #32]
 800ed2a:	2202      	movs	r2, #2
 800ed2c:	6879      	ldr	r1, [r7, #4]
 800ed2e:	6838      	ldr	r0, [r7, #0]
 800ed30:	4798      	blx	r3
 800ed32:	4603      	mov	r3, r0
 800ed34:	74fb      	strb	r3, [r7, #19]
        if(design_res == LV_DESIGN_RES_MASKED) return NULL;
 800ed36:	7cfb      	ldrb	r3, [r7, #19]
 800ed38:	2b03      	cmp	r3, #3
 800ed3a:	d101      	bne.n	800ed40 <lv_refr_get_top_obj+0x4c>
 800ed3c:	2300      	movs	r3, #0
 800ed3e:	e02f      	b.n	800eda0 <lv_refr_get_top_obj+0xac>

#if LV_USE_OPA_SCALE
        if(design_res == LV_DESIGN_RES_COVER && lv_obj_get_style_opa_scale(obj, LV_OBJ_PART_MAIN) != LV_OPA_COVER) {
 800ed40:	7cfb      	ldrb	r3, [r7, #19]
 800ed42:	2b01      	cmp	r3, #1
 800ed44:	d108      	bne.n	800ed58 <lv_refr_get_top_obj+0x64>
 800ed46:	2100      	movs	r1, #0
 800ed48:	6838      	ldr	r0, [r7, #0]
 800ed4a:	f7ff fa78 	bl	800e23e <lv_obj_get_style_opa_scale>
 800ed4e:	4603      	mov	r3, r0
 800ed50:	2bff      	cmp	r3, #255	; 0xff
 800ed52:	d001      	beq.n	800ed58 <lv_refr_get_top_obj+0x64>
            design_res = LV_DESIGN_RES_NOT_COVER;
 800ed54:	2302      	movs	r3, #2
 800ed56:	74fb      	strb	r3, [r7, #19]
        }
#endif

        lv_obj_t * i;
        _LV_LL_READ(obj->child_ll, i) {
 800ed58:	683b      	ldr	r3, [r7, #0]
 800ed5a:	3304      	adds	r3, #4
 800ed5c:	4618      	mov	r0, r3
 800ed5e:	f011 fd7d 	bl	802085c <_lv_ll_get_head>
 800ed62:	60f8      	str	r0, [r7, #12]
 800ed64:	e00e      	b.n	800ed84 <lv_refr_get_top_obj+0x90>
            found_p = lv_refr_get_top_obj(area_p, i);
 800ed66:	68f9      	ldr	r1, [r7, #12]
 800ed68:	6878      	ldr	r0, [r7, #4]
 800ed6a:	f7ff ffc3 	bl	800ecf4 <lv_refr_get_top_obj>
 800ed6e:	6178      	str	r0, [r7, #20]

            /*If a children is ok then break*/
            if(found_p != NULL) {
 800ed70:	697b      	ldr	r3, [r7, #20]
 800ed72:	2b00      	cmp	r3, #0
 800ed74:	d10a      	bne.n	800ed8c <lv_refr_get_top_obj+0x98>
        _LV_LL_READ(obj->child_ll, i) {
 800ed76:	683b      	ldr	r3, [r7, #0]
 800ed78:	3304      	adds	r3, #4
 800ed7a:	68f9      	ldr	r1, [r7, #12]
 800ed7c:	4618      	mov	r0, r3
 800ed7e:	f011 fd93 	bl	80208a8 <_lv_ll_get_next>
 800ed82:	60f8      	str	r0, [r7, #12]
 800ed84:	68fb      	ldr	r3, [r7, #12]
 800ed86:	2b00      	cmp	r3, #0
 800ed88:	d1ed      	bne.n	800ed66 <lv_refr_get_top_obj+0x72>
 800ed8a:	e000      	b.n	800ed8e <lv_refr_get_top_obj+0x9a>
                break;
 800ed8c:	bf00      	nop
            }
        }

        /*If no better children use this object*/
        if(found_p == NULL) {
 800ed8e:	697b      	ldr	r3, [r7, #20]
 800ed90:	2b00      	cmp	r3, #0
 800ed92:	d104      	bne.n	800ed9e <lv_refr_get_top_obj+0xaa>
            if(design_res == LV_DESIGN_RES_COVER) {
 800ed94:	7cfb      	ldrb	r3, [r7, #19]
 800ed96:	2b01      	cmp	r3, #1
 800ed98:	d101      	bne.n	800ed9e <lv_refr_get_top_obj+0xaa>
                found_p = obj;
 800ed9a:	683b      	ldr	r3, [r7, #0]
 800ed9c:	617b      	str	r3, [r7, #20]
            }
        }
    }

    return found_p;
 800ed9e:	697b      	ldr	r3, [r7, #20]
}
 800eda0:	4618      	mov	r0, r3
 800eda2:	3718      	adds	r7, #24
 800eda4:	46bd      	mov	sp, r7
 800eda6:	bd80      	pop	{r7, pc}

0800eda8 <lv_refr_obj_and_children>:
 * Make the refreshing from an object. Draw all its children and the youngers too.
 * @param top_p pointer to an objects. Start the drawing from it.
 * @param mask_p pointer to an area, the objects will be drawn only here
 */
static void lv_refr_obj_and_children(lv_obj_t * top_p, const lv_area_t * mask_p)
{
 800eda8:	b580      	push	{r7, lr}
 800edaa:	b086      	sub	sp, #24
 800edac:	af00      	add	r7, sp, #0
 800edae:	6078      	str	r0, [r7, #4]
 800edb0:	6039      	str	r1, [r7, #0]
    /* Normally always will be a top_obj (at least the screen)
     * but in special cases (e.g. if the screen has alpha) it won't.
     * In this case use the screen directly */
    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);
 800edb2:	687b      	ldr	r3, [r7, #4]
 800edb4:	2b00      	cmp	r3, #0
 800edb6:	d105      	bne.n	800edc4 <lv_refr_obj_and_children+0x1c>
 800edb8:	4b20      	ldr	r3, [pc, #128]	; (800ee3c <lv_refr_obj_and_children+0x94>)
 800edba:	681b      	ldr	r3, [r3, #0]
 800edbc:	4618      	mov	r0, r3
 800edbe:	f7f9 f86d 	bl	8007e9c <lv_disp_get_scr_act>
 800edc2:	6078      	str	r0, [r7, #4]
    if(top_p == NULL) return;  /*Shouldn't happen*/
 800edc4:	687b      	ldr	r3, [r7, #4]
 800edc6:	2b00      	cmp	r3, #0
 800edc8:	d034      	beq.n	800ee34 <lv_refr_obj_and_children+0x8c>

    /*Refresh the top object and its children*/
    lv_refr_obj(top_p, mask_p);
 800edca:	6839      	ldr	r1, [r7, #0]
 800edcc:	6878      	ldr	r0, [r7, #4]
 800edce:	f000 f837 	bl	800ee40 <lv_refr_obj>

    /*Draw the 'younger' sibling objects because they can be on top_obj */
    lv_obj_t * par;
    lv_obj_t * border_p = top_p;
 800edd2:	687b      	ldr	r3, [r7, #4]
 800edd4:	613b      	str	r3, [r7, #16]

    par = lv_obj_get_parent(top_p);
 800edd6:	6878      	ldr	r0, [r7, #4]
 800edd8:	f7fb ff9e 	bl	800ad18 <lv_obj_get_parent>
 800eddc:	6178      	str	r0, [r7, #20]

    /*Do until not reach the screen*/
    while(par != NULL) {
 800edde:	e025      	b.n	800ee2c <lv_refr_obj_and_children+0x84>
        /*object before border_p has to be redrawn*/
        lv_obj_t * i = _lv_ll_get_prev(&(par->child_ll), border_p);
 800ede0:	697b      	ldr	r3, [r7, #20]
 800ede2:	3304      	adds	r3, #4
 800ede4:	6939      	ldr	r1, [r7, #16]
 800ede6:	4618      	mov	r0, r3
 800ede8:	f011 fd78 	bl	80208dc <_lv_ll_get_prev>
 800edec:	60f8      	str	r0, [r7, #12]

        while(i != NULL) {
 800edee:	e00a      	b.n	800ee06 <lv_refr_obj_and_children+0x5e>
            /*Refresh the objects*/
            lv_refr_obj(i, mask_p);
 800edf0:	6839      	ldr	r1, [r7, #0]
 800edf2:	68f8      	ldr	r0, [r7, #12]
 800edf4:	f000 f824 	bl	800ee40 <lv_refr_obj>
            i = _lv_ll_get_prev(&(par->child_ll), i);
 800edf8:	697b      	ldr	r3, [r7, #20]
 800edfa:	3304      	adds	r3, #4
 800edfc:	68f9      	ldr	r1, [r7, #12]
 800edfe:	4618      	mov	r0, r3
 800ee00:	f011 fd6c 	bl	80208dc <_lv_ll_get_prev>
 800ee04:	60f8      	str	r0, [r7, #12]
        while(i != NULL) {
 800ee06:	68fb      	ldr	r3, [r7, #12]
 800ee08:	2b00      	cmp	r3, #0
 800ee0a:	d1f1      	bne.n	800edf0 <lv_refr_obj_and_children+0x48>
        }

        /*Call the post draw design function of the parents of the to object*/
        if(par->design_cb) par->design_cb(par, mask_p, LV_DESIGN_DRAW_POST);
 800ee0c:	697b      	ldr	r3, [r7, #20]
 800ee0e:	6a1b      	ldr	r3, [r3, #32]
 800ee10:	2b00      	cmp	r3, #0
 800ee12:	d005      	beq.n	800ee20 <lv_refr_obj_and_children+0x78>
 800ee14:	697b      	ldr	r3, [r7, #20]
 800ee16:	6a1b      	ldr	r3, [r3, #32]
 800ee18:	2201      	movs	r2, #1
 800ee1a:	6839      	ldr	r1, [r7, #0]
 800ee1c:	6978      	ldr	r0, [r7, #20]
 800ee1e:	4798      	blx	r3

        /*The new border will be there last parents,
         *so the 'younger' brothers of parent will be refreshed*/
        border_p = par;
 800ee20:	697b      	ldr	r3, [r7, #20]
 800ee22:	613b      	str	r3, [r7, #16]
        /*Go a level deeper*/
        par = lv_obj_get_parent(par);
 800ee24:	6978      	ldr	r0, [r7, #20]
 800ee26:	f7fb ff77 	bl	800ad18 <lv_obj_get_parent>
 800ee2a:	6178      	str	r0, [r7, #20]
    while(par != NULL) {
 800ee2c:	697b      	ldr	r3, [r7, #20]
 800ee2e:	2b00      	cmp	r3, #0
 800ee30:	d1d6      	bne.n	800ede0 <lv_refr_obj_and_children+0x38>
 800ee32:	e000      	b.n	800ee36 <lv_refr_obj_and_children+0x8e>
    if(top_p == NULL) return;  /*Shouldn't happen*/
 800ee34:	bf00      	nop
    }
}
 800ee36:	3718      	adds	r7, #24
 800ee38:	46bd      	mov	sp, r7
 800ee3a:	bd80      	pop	{r7, pc}
 800ee3c:	200099fc 	.word	0x200099fc

0800ee40 <lv_refr_obj>:
 * Refresh an object an all of its children. (Called recursively)
 * @param obj pointer to an object to refresh
 * @param mask_ori_p pointer to an area, the objects will be drawn only here
 */
static void lv_refr_obj(lv_obj_t * obj, const lv_area_t * mask_ori_p)
{
 800ee40:	b580      	push	{r7, lr}
 800ee42:	b08e      	sub	sp, #56	; 0x38
 800ee44:	af00      	add	r7, sp, #0
 800ee46:	6078      	str	r0, [r7, #4]
 800ee48:	6039      	str	r1, [r7, #0]
    /*Do not refresh hidden objects*/
    if(obj->hidden != 0) return;
 800ee4a:	687b      	ldr	r3, [r7, #4]
 800ee4c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800ee50:	f003 0310 	and.w	r3, r3, #16
 800ee54:	b2db      	uxtb	r3, r3
 800ee56:	2b00      	cmp	r3, #0
 800ee58:	f040 80b4 	bne.w	800efc4 <lv_refr_obj+0x184>
    /* Truncate the original mask to the coordinates of the parent
     * because the parent and its children are visible only here */
    lv_area_t obj_mask;
    lv_area_t obj_ext_mask;
    lv_area_t obj_area;
    lv_coord_t ext_size = obj->ext_draw_pad;
 800ee5c:	687b      	ldr	r3, [r7, #4]
 800ee5e:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 800ee60:	867b      	strh	r3, [r7, #50]	; 0x32
    lv_obj_get_coords(obj, &obj_area);
 800ee62:	f107 0318 	add.w	r3, r7, #24
 800ee66:	4619      	mov	r1, r3
 800ee68:	6878      	ldr	r0, [r7, #4]
 800ee6a:	f7fb ffa7 	bl	800adbc <lv_obj_get_coords>
    obj_area.x1 -= ext_size;
 800ee6e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800ee72:	b29a      	uxth	r2, r3
 800ee74:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800ee76:	1ad3      	subs	r3, r2, r3
 800ee78:	b29b      	uxth	r3, r3
 800ee7a:	b21b      	sxth	r3, r3
 800ee7c:	833b      	strh	r3, [r7, #24]
    obj_area.y1 -= ext_size;
 800ee7e:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800ee82:	b29a      	uxth	r2, r3
 800ee84:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800ee86:	1ad3      	subs	r3, r2, r3
 800ee88:	b29b      	uxth	r3, r3
 800ee8a:	b21b      	sxth	r3, r3
 800ee8c:	837b      	strh	r3, [r7, #26]
    obj_area.x2 += ext_size;
 800ee8e:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 800ee92:	b29a      	uxth	r2, r3
 800ee94:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800ee96:	4413      	add	r3, r2
 800ee98:	b29b      	uxth	r3, r3
 800ee9a:	b21b      	sxth	r3, r3
 800ee9c:	83bb      	strh	r3, [r7, #28]
    obj_area.y2 += ext_size;
 800ee9e:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 800eea2:	b29a      	uxth	r2, r3
 800eea4:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800eea6:	4413      	add	r3, r2
 800eea8:	b29b      	uxth	r3, r3
 800eeaa:	b21b      	sxth	r3, r3
 800eeac:	83fb      	strh	r3, [r7, #30]
    union_ok = _lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
 800eeae:	f107 0218 	add.w	r2, r7, #24
 800eeb2:	f107 0320 	add.w	r3, r7, #32
 800eeb6:	6839      	ldr	r1, [r7, #0]
 800eeb8:	4618      	mov	r0, r3
 800eeba:	f010 fad7 	bl	801f46c <_lv_area_intersect>
 800eebe:	4603      	mov	r3, r0
 800eec0:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31

    /*Draw the parent and its children only if they ore on 'mask_parent'*/
    if(union_ok != false) {
 800eec4:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 800eec8:	2b00      	cmp	r3, #0
 800eeca:	d07c      	beq.n	800efc6 <lv_refr_obj+0x186>

        /* Redraw the object */
        if(obj->design_cb) obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_MAIN);
 800eecc:	687b      	ldr	r3, [r7, #4]
 800eece:	6a1b      	ldr	r3, [r3, #32]
 800eed0:	2b00      	cmp	r3, #0
 800eed2:	d006      	beq.n	800eee2 <lv_refr_obj+0xa2>
 800eed4:	687b      	ldr	r3, [r7, #4]
 800eed6:	6a1b      	ldr	r3, [r3, #32]
 800eed8:	f107 0120 	add.w	r1, r7, #32
 800eedc:	2200      	movs	r2, #0
 800eede:	6878      	ldr	r0, [r7, #4]
 800eee0:	4798      	blx	r3
#if LV_COLOR_DEPTH == 32
        debug_color.ch.alpha = 0xff;
#endif
#endif
        /*Create a new 'obj_mask' without 'ext_size' because the children can't be visible there*/
        lv_obj_get_coords(obj, &obj_area);
 800eee2:	f107 0318 	add.w	r3, r7, #24
 800eee6:	4619      	mov	r1, r3
 800eee8:	6878      	ldr	r0, [r7, #4]
 800eeea:	f7fb ff67 	bl	800adbc <lv_obj_get_coords>
        union_ok = _lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);
 800eeee:	f107 0218 	add.w	r2, r7, #24
 800eef2:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800eef6:	6839      	ldr	r1, [r7, #0]
 800eef8:	4618      	mov	r0, r3
 800eefa:	f010 fab7 	bl	801f46c <_lv_area_intersect>
 800eefe:	4603      	mov	r3, r0
 800ef00:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
        if(union_ok != false) {
 800ef04:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 800ef08:	2b00      	cmp	r3, #0
 800ef0a:	d04f      	beq.n	800efac <lv_refr_obj+0x16c>
            lv_area_t mask_child; /*Mask from obj and its child*/
            lv_obj_t * child_p;
            lv_area_t child_area;
            _LV_LL_READ_BACK(obj->child_ll, child_p) {
 800ef0c:	687b      	ldr	r3, [r7, #4]
 800ef0e:	3304      	adds	r3, #4
 800ef10:	4618      	mov	r0, r3
 800ef12:	f011 fcb6 	bl	8020882 <_lv_ll_get_tail>
 800ef16:	6378      	str	r0, [r7, #52]	; 0x34
 800ef18:	e045      	b.n	800efa6 <lv_refr_obj+0x166>
                lv_obj_get_coords(child_p, &child_area);
 800ef1a:	f107 0308 	add.w	r3, r7, #8
 800ef1e:	4619      	mov	r1, r3
 800ef20:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800ef22:	f7fb ff4b 	bl	800adbc <lv_obj_get_coords>
                ext_size = child_p->ext_draw_pad;
 800ef26:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ef28:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 800ef2a:	867b      	strh	r3, [r7, #50]	; 0x32
                child_area.x1 -= ext_size;
 800ef2c:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 800ef30:	b29a      	uxth	r2, r3
 800ef32:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800ef34:	1ad3      	subs	r3, r2, r3
 800ef36:	b29b      	uxth	r3, r3
 800ef38:	b21b      	sxth	r3, r3
 800ef3a:	813b      	strh	r3, [r7, #8]
                child_area.y1 -= ext_size;
 800ef3c:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 800ef40:	b29a      	uxth	r2, r3
 800ef42:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800ef44:	1ad3      	subs	r3, r2, r3
 800ef46:	b29b      	uxth	r3, r3
 800ef48:	b21b      	sxth	r3, r3
 800ef4a:	817b      	strh	r3, [r7, #10]
                child_area.x2 += ext_size;
 800ef4c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 800ef50:	b29a      	uxth	r2, r3
 800ef52:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800ef54:	4413      	add	r3, r2
 800ef56:	b29b      	uxth	r3, r3
 800ef58:	b21b      	sxth	r3, r3
 800ef5a:	81bb      	strh	r3, [r7, #12]
                child_area.y2 += ext_size;
 800ef5c:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800ef60:	b29a      	uxth	r2, r3
 800ef62:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 800ef64:	4413      	add	r3, r2
 800ef66:	b29b      	uxth	r3, r3
 800ef68:	b21b      	sxth	r3, r3
 800ef6a:	81fb      	strh	r3, [r7, #14]
                /* Get the union (common parts) of original mask (from obj)
                 * and its child */
                union_ok = _lv_area_intersect(&mask_child, &obj_mask, &child_area);
 800ef6c:	f107 0208 	add.w	r2, r7, #8
 800ef70:	f107 0128 	add.w	r1, r7, #40	; 0x28
 800ef74:	f107 0310 	add.w	r3, r7, #16
 800ef78:	4618      	mov	r0, r3
 800ef7a:	f010 fa77 	bl	801f46c <_lv_area_intersect>
 800ef7e:	4603      	mov	r3, r0
 800ef80:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31

                /*If the parent and the child has common area then refresh the child */
                if(union_ok) {
 800ef84:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 800ef88:	2b00      	cmp	r3, #0
 800ef8a:	d005      	beq.n	800ef98 <lv_refr_obj+0x158>
                    /*Refresh the next children*/
                    lv_refr_obj(child_p, &mask_child);
 800ef8c:	f107 0310 	add.w	r3, r7, #16
 800ef90:	4619      	mov	r1, r3
 800ef92:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800ef94:	f7ff ff54 	bl	800ee40 <lv_refr_obj>
            _LV_LL_READ_BACK(obj->child_ll, child_p) {
 800ef98:	687b      	ldr	r3, [r7, #4]
 800ef9a:	3304      	adds	r3, #4
 800ef9c:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800ef9e:	4618      	mov	r0, r3
 800efa0:	f011 fc9c 	bl	80208dc <_lv_ll_get_prev>
 800efa4:	6378      	str	r0, [r7, #52]	; 0x34
 800efa6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800efa8:	2b00      	cmp	r3, #0
 800efaa:	d1b6      	bne.n	800ef1a <lv_refr_obj+0xda>
                }
            }
        }

        /* If all the children are redrawn make 'post draw' design */
        if(obj->design_cb) obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_POST);
 800efac:	687b      	ldr	r3, [r7, #4]
 800efae:	6a1b      	ldr	r3, [r3, #32]
 800efb0:	2b00      	cmp	r3, #0
 800efb2:	d008      	beq.n	800efc6 <lv_refr_obj+0x186>
 800efb4:	687b      	ldr	r3, [r7, #4]
 800efb6:	6a1b      	ldr	r3, [r3, #32]
 800efb8:	f107 0120 	add.w	r1, r7, #32
 800efbc:	2201      	movs	r2, #1
 800efbe:	6878      	ldr	r0, [r7, #4]
 800efc0:	4798      	blx	r3
 800efc2:	e000      	b.n	800efc6 <lv_refr_obj+0x186>
    if(obj->hidden != 0) return;
 800efc4:	bf00      	nop
    }
}
 800efc6:	3738      	adds	r7, #56	; 0x38
 800efc8:	46bd      	mov	sp, r7
 800efca:	bd80      	pop	{r7, pc}

0800efcc <lv_refr_vdb_flush>:

/**
 * Flush the content of the VDB
 */
static void lv_refr_vdb_flush(void)
{
 800efcc:	b580      	push	{r7, lr}
 800efce:	b082      	sub	sp, #8
 800efd0:	af00      	add	r7, sp, #0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 800efd2:	4b33      	ldr	r3, [pc, #204]	; (800f0a0 <lv_refr_vdb_flush+0xd4>)
 800efd4:	681b      	ldr	r3, [r3, #0]
 800efd6:	4618      	mov	r0, r3
 800efd8:	f00f fe18 	bl	801ec0c <lv_disp_get_buf>
 800efdc:	6078      	str	r0, [r7, #4]

    /*In double buffered mode wait until the other buffer is flushed before flushing the current
     * one*/
    if(lv_disp_is_double_buf(disp_refr)) {
 800efde:	4b30      	ldr	r3, [pc, #192]	; (800f0a0 <lv_refr_vdb_flush+0xd4>)
 800efe0:	681b      	ldr	r3, [r3, #0]
 800efe2:	4618      	mov	r0, r3
 800efe4:	f00f fe1e 	bl	801ec24 <lv_disp_is_double_buf>
 800efe8:	4603      	mov	r3, r0
 800efea:	2b00      	cmp	r3, #0
 800efec:	d010      	beq.n	800f010 <lv_refr_vdb_flush+0x44>
        while(vdb->flushing) {
 800efee:	e00b      	b.n	800f008 <lv_refr_vdb_flush+0x3c>
            if(disp_refr->driver.wait_cb) disp_refr->driver.wait_cb(&disp_refr->driver);
 800eff0:	4b2b      	ldr	r3, [pc, #172]	; (800f0a0 <lv_refr_vdb_flush+0xd4>)
 800eff2:	681b      	ldr	r3, [r3, #0]
 800eff4:	69db      	ldr	r3, [r3, #28]
 800eff6:	2b00      	cmp	r3, #0
 800eff8:	d006      	beq.n	800f008 <lv_refr_vdb_flush+0x3c>
 800effa:	4b29      	ldr	r3, [pc, #164]	; (800f0a0 <lv_refr_vdb_flush+0xd4>)
 800effc:	681b      	ldr	r3, [r3, #0]
 800effe:	69db      	ldr	r3, [r3, #28]
 800f000:	4a27      	ldr	r2, [pc, #156]	; (800f0a0 <lv_refr_vdb_flush+0xd4>)
 800f002:	6812      	ldr	r2, [r2, #0]
 800f004:	4610      	mov	r0, r2
 800f006:	4798      	blx	r3
        while(vdb->flushing) {
 800f008:	687b      	ldr	r3, [r7, #4]
 800f00a:	699b      	ldr	r3, [r3, #24]
 800f00c:	2b00      	cmp	r3, #0
 800f00e:	d1ef      	bne.n	800eff0 <lv_refr_vdb_flush+0x24>
        }
    }

    vdb->flushing = 1;
 800f010:	687b      	ldr	r3, [r7, #4]
 800f012:	2201      	movs	r2, #1
 800f014:	619a      	str	r2, [r3, #24]

    if(disp_refr->driver.buffer->last_area && disp_refr->driver.buffer->last_part) vdb->flushing_last = 1;
 800f016:	4b22      	ldr	r3, [pc, #136]	; (800f0a0 <lv_refr_vdb_flush+0xd4>)
 800f018:	681b      	ldr	r3, [r3, #0]
 800f01a:	685b      	ldr	r3, [r3, #4]
 800f01c:	6a1b      	ldr	r3, [r3, #32]
 800f01e:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800f022:	b2db      	uxtb	r3, r3
 800f024:	2b00      	cmp	r3, #0
 800f026:	d00c      	beq.n	800f042 <lv_refr_vdb_flush+0x76>
 800f028:	4b1d      	ldr	r3, [pc, #116]	; (800f0a0 <lv_refr_vdb_flush+0xd4>)
 800f02a:	681b      	ldr	r3, [r3, #0]
 800f02c:	685b      	ldr	r3, [r3, #4]
 800f02e:	6a1b      	ldr	r3, [r3, #32]
 800f030:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800f034:	b2db      	uxtb	r3, r3
 800f036:	2b00      	cmp	r3, #0
 800f038:	d003      	beq.n	800f042 <lv_refr_vdb_flush+0x76>
 800f03a:	687b      	ldr	r3, [r7, #4]
 800f03c:	2201      	movs	r2, #1
 800f03e:	61da      	str	r2, [r3, #28]
 800f040:	e002      	b.n	800f048 <lv_refr_vdb_flush+0x7c>
    else vdb->flushing_last = 0;
 800f042:	687b      	ldr	r3, [r7, #4]
 800f044:	2200      	movs	r2, #0
 800f046:	61da      	str	r2, [r3, #28]

    /*Flush the rendered content to the display*/
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
 800f048:	f7ff f9ca 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 800f04c:	6038      	str	r0, [r7, #0]
    if(disp->driver.flush_cb) disp->driver.flush_cb(&disp->driver, &vdb->area, vdb->buf_act);
 800f04e:	683b      	ldr	r3, [r7, #0]
 800f050:	68db      	ldr	r3, [r3, #12]
 800f052:	2b00      	cmp	r3, #0
 800f054:	d008      	beq.n	800f068 <lv_refr_vdb_flush+0x9c>
 800f056:	683b      	ldr	r3, [r7, #0]
 800f058:	68db      	ldr	r3, [r3, #12]
 800f05a:	6838      	ldr	r0, [r7, #0]
 800f05c:	687a      	ldr	r2, [r7, #4]
 800f05e:	f102 0110 	add.w	r1, r2, #16
 800f062:	687a      	ldr	r2, [r7, #4]
 800f064:	6892      	ldr	r2, [r2, #8]
 800f066:	4798      	blx	r3

    if(vdb->buf1 && vdb->buf2) {
 800f068:	687b      	ldr	r3, [r7, #4]
 800f06a:	681b      	ldr	r3, [r3, #0]
 800f06c:	2b00      	cmp	r3, #0
 800f06e:	d012      	beq.n	800f096 <lv_refr_vdb_flush+0xca>
 800f070:	687b      	ldr	r3, [r7, #4]
 800f072:	685b      	ldr	r3, [r3, #4]
 800f074:	2b00      	cmp	r3, #0
 800f076:	d00e      	beq.n	800f096 <lv_refr_vdb_flush+0xca>
        if(vdb->buf_act == vdb->buf1)
 800f078:	687b      	ldr	r3, [r7, #4]
 800f07a:	689a      	ldr	r2, [r3, #8]
 800f07c:	687b      	ldr	r3, [r7, #4]
 800f07e:	681b      	ldr	r3, [r3, #0]
 800f080:	429a      	cmp	r2, r3
 800f082:	d104      	bne.n	800f08e <lv_refr_vdb_flush+0xc2>
            vdb->buf_act = vdb->buf2;
 800f084:	687b      	ldr	r3, [r7, #4]
 800f086:	685a      	ldr	r2, [r3, #4]
 800f088:	687b      	ldr	r3, [r7, #4]
 800f08a:	609a      	str	r2, [r3, #8]
        else
            vdb->buf_act = vdb->buf1;
    }
}
 800f08c:	e003      	b.n	800f096 <lv_refr_vdb_flush+0xca>
            vdb->buf_act = vdb->buf1;
 800f08e:	687b      	ldr	r3, [r7, #4]
 800f090:	681a      	ldr	r2, [r3, #0]
 800f092:	687b      	ldr	r3, [r7, #4]
 800f094:	609a      	str	r2, [r3, #8]
}
 800f096:	bf00      	nop
 800f098:	3708      	adds	r7, #8
 800f09a:	46bd      	mov	sp, r7
 800f09c:	bd80      	pop	{r7, pc}
 800f09e:	bf00      	nop
 800f0a0:	200099fc 	.word	0x200099fc

0800f0a4 <_lv_memcpy_small>:
{
 800f0a4:	b480      	push	{r7}
 800f0a6:	b087      	sub	sp, #28
 800f0a8:	af00      	add	r7, sp, #0
 800f0aa:	60f8      	str	r0, [r7, #12]
 800f0ac:	60b9      	str	r1, [r7, #8]
 800f0ae:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 800f0b0:	68fb      	ldr	r3, [r7, #12]
 800f0b2:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 800f0b4:	68bb      	ldr	r3, [r7, #8]
 800f0b6:	613b      	str	r3, [r7, #16]
    while(len) {
 800f0b8:	e00c      	b.n	800f0d4 <_lv_memcpy_small+0x30>
        *d8 = *s8;
 800f0ba:	693b      	ldr	r3, [r7, #16]
 800f0bc:	781a      	ldrb	r2, [r3, #0]
 800f0be:	697b      	ldr	r3, [r7, #20]
 800f0c0:	701a      	strb	r2, [r3, #0]
        d8++;
 800f0c2:	697b      	ldr	r3, [r7, #20]
 800f0c4:	3301      	adds	r3, #1
 800f0c6:	617b      	str	r3, [r7, #20]
        s8++;
 800f0c8:	693b      	ldr	r3, [r7, #16]
 800f0ca:	3301      	adds	r3, #1
 800f0cc:	613b      	str	r3, [r7, #16]
        len--;
 800f0ce:	687b      	ldr	r3, [r7, #4]
 800f0d0:	3b01      	subs	r3, #1
 800f0d2:	607b      	str	r3, [r7, #4]
    while(len) {
 800f0d4:	687b      	ldr	r3, [r7, #4]
 800f0d6:	2b00      	cmp	r3, #0
 800f0d8:	d1ef      	bne.n	800f0ba <_lv_memcpy_small+0x16>
    return dst;
 800f0da:	68fb      	ldr	r3, [r7, #12]
}
 800f0dc:	4618      	mov	r0, r3
 800f0de:	371c      	adds	r7, #28
 800f0e0:	46bd      	mov	sp, r7
 800f0e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f0e6:	4770      	bx	lr

0800f0e8 <lv_style_list_get_style>:
{
 800f0e8:	b480      	push	{r7}
 800f0ea:	b083      	sub	sp, #12
 800f0ec:	af00      	add	r7, sp, #0
 800f0ee:	6078      	str	r0, [r7, #4]
 800f0f0:	460b      	mov	r3, r1
 800f0f2:	70fb      	strb	r3, [r7, #3]
    if(list->has_trans && list->skip_trans) id++;
 800f0f4:	687b      	ldr	r3, [r7, #4]
 800f0f6:	791b      	ldrb	r3, [r3, #4]
 800f0f8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800f0fc:	b2db      	uxtb	r3, r3
 800f0fe:	2b00      	cmp	r3, #0
 800f100:	d009      	beq.n	800f116 <lv_style_list_get_style+0x2e>
 800f102:	687b      	ldr	r3, [r7, #4]
 800f104:	795b      	ldrb	r3, [r3, #5]
 800f106:	f003 0301 	and.w	r3, r3, #1
 800f10a:	b2db      	uxtb	r3, r3
 800f10c:	2b00      	cmp	r3, #0
 800f10e:	d002      	beq.n	800f116 <lv_style_list_get_style+0x2e>
 800f110:	78fb      	ldrb	r3, [r7, #3]
 800f112:	3301      	adds	r3, #1
 800f114:	70fb      	strb	r3, [r7, #3]
    if(list->style_cnt == 0 || id >= list->style_cnt) return NULL;
 800f116:	687b      	ldr	r3, [r7, #4]
 800f118:	791b      	ldrb	r3, [r3, #4]
 800f11a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f11e:	b2db      	uxtb	r3, r3
 800f120:	2b00      	cmp	r3, #0
 800f122:	d008      	beq.n	800f136 <lv_style_list_get_style+0x4e>
 800f124:	687b      	ldr	r3, [r7, #4]
 800f126:	791b      	ldrb	r3, [r3, #4]
 800f128:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f12c:	b2db      	uxtb	r3, r3
 800f12e:	461a      	mov	r2, r3
 800f130:	78fb      	ldrb	r3, [r7, #3]
 800f132:	4293      	cmp	r3, r2
 800f134:	d301      	bcc.n	800f13a <lv_style_list_get_style+0x52>
 800f136:	2300      	movs	r3, #0
 800f138:	e005      	b.n	800f146 <lv_style_list_get_style+0x5e>
    return list->style_list[id];
 800f13a:	687b      	ldr	r3, [r7, #4]
 800f13c:	681a      	ldr	r2, [r3, #0]
 800f13e:	78fb      	ldrb	r3, [r7, #3]
 800f140:	009b      	lsls	r3, r3, #2
 800f142:	4413      	add	r3, r2
 800f144:	681b      	ldr	r3, [r3, #0]
}
 800f146:	4618      	mov	r0, r3
 800f148:	370c      	adds	r7, #12
 800f14a:	46bd      	mov	sp, r7
 800f14c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f150:	4770      	bx	lr

0800f152 <lv_style_init>:
/**
 * Initialize a style
 * @param style pointer to a style to initialize
 */
void lv_style_init(lv_style_t * style)
{
 800f152:	b580      	push	{r7, lr}
 800f154:	b082      	sub	sp, #8
 800f156:	af00      	add	r7, sp, #0
 800f158:	6078      	str	r0, [r7, #4]
    _lv_memset_00(style, sizeof(lv_style_t));
 800f15a:	2104      	movs	r1, #4
 800f15c:	6878      	ldr	r0, [r7, #4]
 800f15e:	f012 faa3 	bl	80216a8 <_lv_memset_00>
#if LV_USE_ASSERT_STYLE
    style->sentinel = LV_DEBUG_STYLE_SENTINEL_VALUE;
#endif
}
 800f162:	bf00      	nop
 800f164:	3708      	adds	r7, #8
 800f166:	46bd      	mov	sp, r7
 800f168:	bd80      	pop	{r7, pc}

0800f16a <lv_style_copy>:
 * Copy a style with all its properties
 * @param style_dest pointer to the destination style. (Should be initialized with `lv_style_init()`)
 * @param style_src pointer to the source (to copy )style
 */
void lv_style_copy(lv_style_t * style_dest, const lv_style_t * style_src)
{
 800f16a:	b580      	push	{r7, lr}
 800f16c:	b084      	sub	sp, #16
 800f16e:	af00      	add	r7, sp, #0
 800f170:	6078      	str	r0, [r7, #4]
 800f172:	6039      	str	r1, [r7, #0]
    if(style_src == NULL) return;
 800f174:	683b      	ldr	r3, [r7, #0]
 800f176:	2b00      	cmp	r3, #0
 800f178:	d018      	beq.n	800f1ac <lv_style_copy+0x42>

    LV_ASSERT_STYLE(style_dest);
    LV_ASSERT_STYLE(style_src);

    if(style_src->map == NULL) return;
 800f17a:	683b      	ldr	r3, [r7, #0]
 800f17c:	681b      	ldr	r3, [r3, #0]
 800f17e:	2b00      	cmp	r3, #0
 800f180:	d016      	beq.n	800f1b0 <lv_style_copy+0x46>

    uint16_t size = _lv_style_get_mem_size(style_src);
 800f182:	6838      	ldr	r0, [r7, #0]
 800f184:	f000 fb03 	bl	800f78e <_lv_style_get_mem_size>
 800f188:	4603      	mov	r3, r0
 800f18a:	81fb      	strh	r3, [r7, #14]
    style_dest->map = lv_mem_alloc(size);
 800f18c:	89fb      	ldrh	r3, [r7, #14]
 800f18e:	4618      	mov	r0, r3
 800f190:	f011 fd20 	bl	8020bd4 <lv_mem_alloc>
 800f194:	4602      	mov	r2, r0
 800f196:	687b      	ldr	r3, [r7, #4]
 800f198:	601a      	str	r2, [r3, #0]
    _lv_memcpy(style_dest->map, style_src->map, size);
 800f19a:	687b      	ldr	r3, [r7, #4]
 800f19c:	6818      	ldr	r0, [r3, #0]
 800f19e:	683b      	ldr	r3, [r7, #0]
 800f1a0:	681b      	ldr	r3, [r3, #0]
 800f1a2:	89fa      	ldrh	r2, [r7, #14]
 800f1a4:	4619      	mov	r1, r3
 800f1a6:	f011 ffd9 	bl	802115c <_lv_memcpy>
 800f1aa:	e002      	b.n	800f1b2 <lv_style_copy+0x48>
    if(style_src == NULL) return;
 800f1ac:	bf00      	nop
 800f1ae:	e000      	b.n	800f1b2 <lv_style_copy+0x48>
    if(style_src->map == NULL) return;
 800f1b0:	bf00      	nop
}
 800f1b2:	3710      	adds	r7, #16
 800f1b4:	46bd      	mov	sp, r7
 800f1b6:	bd80      	pop	{r7, pc}

0800f1b8 <lv_style_remove_prop>:
 * @param prop  a style property ORed with a state.
 * E.g. `LV_STYLE_BORDER_WIDTH | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`
 * @return true: the property was found and removed; false: the property wasn't found
 */
bool lv_style_remove_prop(lv_style_t * style, lv_style_property_t prop)
{
 800f1b8:	b580      	push	{r7, lr}
 800f1ba:	b088      	sub	sp, #32
 800f1bc:	af00      	add	r7, sp, #0
 800f1be:	6078      	str	r0, [r7, #4]
 800f1c0:	460b      	mov	r3, r1
 800f1c2:	807b      	strh	r3, [r7, #2]
    if(style == NULL) return false;
 800f1c4:	687b      	ldr	r3, [r7, #4]
 800f1c6:	2b00      	cmp	r3, #0
 800f1c8:	d101      	bne.n	800f1ce <lv_style_remove_prop+0x16>
 800f1ca:	2300      	movs	r3, #0
 800f1cc:	e049      	b.n	800f262 <lv_style_remove_prop+0xaa>
    LV_ASSERT_STYLE(style);

    int32_t id = get_property_index(style, prop);
 800f1ce:	887b      	ldrh	r3, [r7, #2]
 800f1d0:	4619      	mov	r1, r3
 800f1d2:	6878      	ldr	r0, [r7, #4]
 800f1d4:	f001 f8e2 	bl	801039c <get_property_index>
 800f1d8:	61b8      	str	r0, [r7, #24]
    /*The property exists but not sure it's state is the same*/
    if(id >= 0) {
 800f1da:	69bb      	ldr	r3, [r7, #24]
 800f1dc:	2b00      	cmp	r3, #0
 800f1de:	db3f      	blt.n	800f260 <lv_style_remove_prop+0xa8>
        lv_style_attr_t attr_found;
        lv_style_attr_t attr_goal;

        attr_found = get_style_prop_attr(style, id);
 800f1e0:	69bb      	ldr	r3, [r7, #24]
 800f1e2:	4619      	mov	r1, r3
 800f1e4:	6878      	ldr	r0, [r7, #4]
 800f1e6:	f001 f9bb 	bl	8010560 <get_style_prop_attr>
 800f1ea:	4603      	mov	r3, r0
 800f1ec:	75fb      	strb	r3, [r7, #23]
        attr_goal = (prop >> 8) & 0xFFU;
 800f1ee:	887b      	ldrh	r3, [r7, #2]
 800f1f0:	0a1b      	lsrs	r3, r3, #8
 800f1f2:	b29b      	uxth	r3, r3
 800f1f4:	75bb      	strb	r3, [r7, #22]

        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
 800f1f6:	7dfa      	ldrb	r2, [r7, #23]
 800f1f8:	7dbb      	ldrb	r3, [r7, #22]
 800f1fa:	4053      	eors	r3, r2
 800f1fc:	b2db      	uxtb	r3, r3
 800f1fe:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800f202:	2b00      	cmp	r3, #0
 800f204:	d12c      	bne.n	800f260 <lv_style_remove_prop+0xa8>
            uint32_t map_size = _lv_style_get_mem_size(style);
 800f206:	6878      	ldr	r0, [r7, #4]
 800f208:	f000 fac1 	bl	800f78e <_lv_style_get_mem_size>
 800f20c:	4603      	mov	r3, r0
 800f20e:	613b      	str	r3, [r7, #16]
            uint8_t prop_size = get_prop_size(prop);
 800f210:	887b      	ldrh	r3, [r7, #2]
 800f212:	b2db      	uxtb	r3, r3
 800f214:	4618      	mov	r0, r3
 800f216:	f001 f9b4 	bl	8010582 <get_prop_size>
 800f21a:	4603      	mov	r3, r0
 800f21c:	73fb      	strb	r3, [r7, #15]

            /*Move the props to fill the space of the property to delete*/
            uint32_t i;
            for(i = id; i < map_size - prop_size; i++) {
 800f21e:	69bb      	ldr	r3, [r7, #24]
 800f220:	61fb      	str	r3, [r7, #28]
 800f222:	e00e      	b.n	800f242 <lv_style_remove_prop+0x8a>
                style->map[i] = style->map[i + prop_size];
 800f224:	687b      	ldr	r3, [r7, #4]
 800f226:	681a      	ldr	r2, [r3, #0]
 800f228:	7bf9      	ldrb	r1, [r7, #15]
 800f22a:	69fb      	ldr	r3, [r7, #28]
 800f22c:	440b      	add	r3, r1
 800f22e:	441a      	add	r2, r3
 800f230:	687b      	ldr	r3, [r7, #4]
 800f232:	6819      	ldr	r1, [r3, #0]
 800f234:	69fb      	ldr	r3, [r7, #28]
 800f236:	440b      	add	r3, r1
 800f238:	7812      	ldrb	r2, [r2, #0]
 800f23a:	701a      	strb	r2, [r3, #0]
            for(i = id; i < map_size - prop_size; i++) {
 800f23c:	69fb      	ldr	r3, [r7, #28]
 800f23e:	3301      	adds	r3, #1
 800f240:	61fb      	str	r3, [r7, #28]
 800f242:	7bfb      	ldrb	r3, [r7, #15]
 800f244:	693a      	ldr	r2, [r7, #16]
 800f246:	1ad3      	subs	r3, r2, r3
 800f248:	69fa      	ldr	r2, [r7, #28]
 800f24a:	429a      	cmp	r2, r3
 800f24c:	d3ea      	bcc.n	800f224 <lv_style_remove_prop+0x6c>
            }

            style_resize(style, map_size - prop_size);
 800f24e:	7bfb      	ldrb	r3, [r7, #15]
 800f250:	693a      	ldr	r2, [r7, #16]
 800f252:	1ad3      	subs	r3, r2, r3
 800f254:	4619      	mov	r1, r3
 800f256:	6878      	ldr	r0, [r7, #4]
 800f258:	f001 f942 	bl	80104e0 <style_resize>

            return true;
 800f25c:	2301      	movs	r3, #1
 800f25e:	e000      	b.n	800f262 <lv_style_remove_prop+0xaa>
        }
    }

    return false;
 800f260:	2300      	movs	r3, #0
}
 800f262:	4618      	mov	r0, r3
 800f264:	3720      	adds	r7, #32
 800f266:	46bd      	mov	sp, r7
 800f268:	bd80      	pop	{r7, pc}

0800f26a <lv_style_list_init>:
/**
 * Initialize a style list
 * @param list a style list to initialize
 */
void lv_style_list_init(lv_style_list_t * list)
{
 800f26a:	b580      	push	{r7, lr}
 800f26c:	b082      	sub	sp, #8
 800f26e:	af00      	add	r7, sp, #0
 800f270:	6078      	str	r0, [r7, #4]
    _lv_memset_00(list, sizeof(lv_style_list_t));
 800f272:	2108      	movs	r1, #8
 800f274:	6878      	ldr	r0, [r7, #4]
 800f276:	f012 fa17 	bl	80216a8 <_lv_memset_00>
#if LV_USE_ASSERT_STYLE
    list->sentinel = LV_DEBUG_STYLE_LIST_SENTINEL_VALUE;
#endif
}
 800f27a:	bf00      	nop
 800f27c:	3708      	adds	r7, #8
 800f27e:	46bd      	mov	sp, r7
 800f280:	bd80      	pop	{r7, pc}

0800f282 <lv_style_list_copy>:
 * Copy a style list with all its styles and local style properties
 * @param list_dest pointer to the destination style list. (should be initialized with `lv_style_list_init()`)
 * @param list_src pointer to the source (to copy) style list.
 */
void lv_style_list_copy(lv_style_list_t * list_dest, const lv_style_list_t * list_src)
{
 800f282:	b580      	push	{r7, lr}
 800f284:	b084      	sub	sp, #16
 800f286:	af00      	add	r7, sp, #0
 800f288:	6078      	str	r0, [r7, #4]
 800f28a:	6039      	str	r1, [r7, #0]
    LV_ASSERT_STYLE_LIST(list_dest);
    LV_ASSERT_STYLE_LIST(list_src);

    _lv_style_list_reset(list_dest);
 800f28c:	6878      	ldr	r0, [r7, #4]
 800f28e:	f000 fa17 	bl	800f6c0 <_lv_style_list_reset>

    if(list_src->style_list == NULL) return;
 800f292:	683b      	ldr	r3, [r7, #0]
 800f294:	681b      	ldr	r3, [r3, #0]
 800f296:	2b00      	cmp	r3, #0
 800f298:	f000 80ca 	beq.w	800f430 <lv_style_list_copy+0x1ae>

    /*Copy the styles but skip the transitions*/
    if(list_src->has_local == 0) {
 800f29c:	683b      	ldr	r3, [r7, #0]
 800f29e:	791b      	ldrb	r3, [r3, #4]
 800f2a0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f2a4:	b2db      	uxtb	r3, r3
 800f2a6:	2b00      	cmp	r3, #0
 800f2a8:	d156      	bne.n	800f358 <lv_style_list_copy+0xd6>
        if(list_src->has_trans) {
 800f2aa:	683b      	ldr	r3, [r7, #0]
 800f2ac:	791b      	ldrb	r3, [r3, #4]
 800f2ae:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800f2b2:	b2db      	uxtb	r3, r3
 800f2b4:	2b00      	cmp	r3, #0
 800f2b6:	d02b      	beq.n	800f310 <lv_style_list_copy+0x8e>
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));
 800f2b8:	683b      	ldr	r3, [r7, #0]
 800f2ba:	791b      	ldrb	r3, [r3, #4]
 800f2bc:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f2c0:	b2db      	uxtb	r3, r3
 800f2c2:	3b01      	subs	r3, #1
 800f2c4:	009b      	lsls	r3, r3, #2
 800f2c6:	4618      	mov	r0, r3
 800f2c8:	f011 fc84 	bl	8020bd4 <lv_mem_alloc>
 800f2cc:	4602      	mov	r2, r0
 800f2ce:	687b      	ldr	r3, [r7, #4]
 800f2d0:	601a      	str	r2, [r3, #0]
            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));
 800f2d2:	687b      	ldr	r3, [r7, #4]
 800f2d4:	6818      	ldr	r0, [r3, #0]
 800f2d6:	683b      	ldr	r3, [r7, #0]
 800f2d8:	681b      	ldr	r3, [r3, #0]
 800f2da:	1d19      	adds	r1, r3, #4
 800f2dc:	683b      	ldr	r3, [r7, #0]
 800f2de:	791b      	ldrb	r3, [r3, #4]
 800f2e0:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f2e4:	b2db      	uxtb	r3, r3
 800f2e6:	3b01      	subs	r3, #1
 800f2e8:	009b      	lsls	r3, r3, #2
 800f2ea:	461a      	mov	r2, r3
 800f2ec:	f011 ff36 	bl	802115c <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt - 1;
 800f2f0:	683b      	ldr	r3, [r7, #0]
 800f2f2:	791b      	ldrb	r3, [r3, #4]
 800f2f4:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f2f8:	b2db      	uxtb	r3, r3
 800f2fa:	3b01      	subs	r3, #1
 800f2fc:	b2db      	uxtb	r3, r3
 800f2fe:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f302:	b2d9      	uxtb	r1, r3
 800f304:	687a      	ldr	r2, [r7, #4]
 800f306:	7913      	ldrb	r3, [r2, #4]
 800f308:	f361 0305 	bfi	r3, r1, #0, #6
 800f30c:	7113      	strb	r3, [r2, #4]
 800f30e:	e090      	b.n	800f432 <lv_style_list_copy+0x1b0>
        }
        else {
            list_dest->style_list = lv_mem_alloc(list_src->style_cnt * sizeof(lv_style_t *));
 800f310:	683b      	ldr	r3, [r7, #0]
 800f312:	791b      	ldrb	r3, [r3, #4]
 800f314:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f318:	b2db      	uxtb	r3, r3
 800f31a:	009b      	lsls	r3, r3, #2
 800f31c:	4618      	mov	r0, r3
 800f31e:	f011 fc59 	bl	8020bd4 <lv_mem_alloc>
 800f322:	4602      	mov	r2, r0
 800f324:	687b      	ldr	r3, [r7, #4]
 800f326:	601a      	str	r2, [r3, #0]
            _lv_memcpy(list_dest->style_list, list_src->style_list, list_src->style_cnt * sizeof(lv_style_t *));
 800f328:	687b      	ldr	r3, [r7, #4]
 800f32a:	6818      	ldr	r0, [r3, #0]
 800f32c:	683b      	ldr	r3, [r7, #0]
 800f32e:	6819      	ldr	r1, [r3, #0]
 800f330:	683b      	ldr	r3, [r7, #0]
 800f332:	791b      	ldrb	r3, [r3, #4]
 800f334:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f338:	b2db      	uxtb	r3, r3
 800f33a:	009b      	lsls	r3, r3, #2
 800f33c:	461a      	mov	r2, r3
 800f33e:	f011 ff0d 	bl	802115c <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt;
 800f342:	683b      	ldr	r3, [r7, #0]
 800f344:	791b      	ldrb	r3, [r3, #4]
 800f346:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f34a:	b2d9      	uxtb	r1, r3
 800f34c:	687a      	ldr	r2, [r7, #4]
 800f34e:	7913      	ldrb	r3, [r2, #4]
 800f350:	f361 0305 	bfi	r3, r1, #0, #6
 800f354:	7113      	strb	r3, [r2, #4]
 800f356:	e06c      	b.n	800f432 <lv_style_list_copy+0x1b0>
        }
    }
    else {
        if(list_src->has_trans) {
 800f358:	683b      	ldr	r3, [r7, #0]
 800f35a:	791b      	ldrb	r3, [r3, #4]
 800f35c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800f360:	b2db      	uxtb	r3, r3
 800f362:	2b00      	cmp	r3, #0
 800f364:	d02c      	beq.n	800f3c0 <lv_style_list_copy+0x13e>
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 2) * sizeof(lv_style_t *));
 800f366:	683b      	ldr	r3, [r7, #0]
 800f368:	791b      	ldrb	r3, [r3, #4]
 800f36a:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f36e:	b2db      	uxtb	r3, r3
 800f370:	3b02      	subs	r3, #2
 800f372:	009b      	lsls	r3, r3, #2
 800f374:	4618      	mov	r0, r3
 800f376:	f011 fc2d 	bl	8020bd4 <lv_mem_alloc>
 800f37a:	4602      	mov	r2, r0
 800f37c:	687b      	ldr	r3, [r7, #4]
 800f37e:	601a      	str	r2, [r3, #0]
            _lv_memcpy(list_dest->style_list, list_src->style_list + 2, (list_src->style_cnt - 2) * sizeof(lv_style_t *));
 800f380:	687b      	ldr	r3, [r7, #4]
 800f382:	6818      	ldr	r0, [r3, #0]
 800f384:	683b      	ldr	r3, [r7, #0]
 800f386:	681b      	ldr	r3, [r3, #0]
 800f388:	f103 0108 	add.w	r1, r3, #8
 800f38c:	683b      	ldr	r3, [r7, #0]
 800f38e:	791b      	ldrb	r3, [r3, #4]
 800f390:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f394:	b2db      	uxtb	r3, r3
 800f396:	3b02      	subs	r3, #2
 800f398:	009b      	lsls	r3, r3, #2
 800f39a:	461a      	mov	r2, r3
 800f39c:	f011 fede 	bl	802115c <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt - 2;
 800f3a0:	683b      	ldr	r3, [r7, #0]
 800f3a2:	791b      	ldrb	r3, [r3, #4]
 800f3a4:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f3a8:	b2db      	uxtb	r3, r3
 800f3aa:	3b02      	subs	r3, #2
 800f3ac:	b2db      	uxtb	r3, r3
 800f3ae:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f3b2:	b2d9      	uxtb	r1, r3
 800f3b4:	687a      	ldr	r2, [r7, #4]
 800f3b6:	7913      	ldrb	r3, [r2, #4]
 800f3b8:	f361 0305 	bfi	r3, r1, #0, #6
 800f3bc:	7113      	strb	r3, [r2, #4]
 800f3be:	e02a      	b.n	800f416 <lv_style_list_copy+0x194>
        }
        else {
            list_dest->style_list = lv_mem_alloc((list_src->style_cnt - 1) * sizeof(lv_style_t *));
 800f3c0:	683b      	ldr	r3, [r7, #0]
 800f3c2:	791b      	ldrb	r3, [r3, #4]
 800f3c4:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f3c8:	b2db      	uxtb	r3, r3
 800f3ca:	3b01      	subs	r3, #1
 800f3cc:	009b      	lsls	r3, r3, #2
 800f3ce:	4618      	mov	r0, r3
 800f3d0:	f011 fc00 	bl	8020bd4 <lv_mem_alloc>
 800f3d4:	4602      	mov	r2, r0
 800f3d6:	687b      	ldr	r3, [r7, #4]
 800f3d8:	601a      	str	r2, [r3, #0]
            _lv_memcpy(list_dest->style_list, list_src->style_list + 1, (list_src->style_cnt - 1) * sizeof(lv_style_t *));
 800f3da:	687b      	ldr	r3, [r7, #4]
 800f3dc:	6818      	ldr	r0, [r3, #0]
 800f3de:	683b      	ldr	r3, [r7, #0]
 800f3e0:	681b      	ldr	r3, [r3, #0]
 800f3e2:	1d19      	adds	r1, r3, #4
 800f3e4:	683b      	ldr	r3, [r7, #0]
 800f3e6:	791b      	ldrb	r3, [r3, #4]
 800f3e8:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f3ec:	b2db      	uxtb	r3, r3
 800f3ee:	3b01      	subs	r3, #1
 800f3f0:	009b      	lsls	r3, r3, #2
 800f3f2:	461a      	mov	r2, r3
 800f3f4:	f011 feb2 	bl	802115c <_lv_memcpy>
            list_dest->style_cnt = list_src->style_cnt - 1;
 800f3f8:	683b      	ldr	r3, [r7, #0]
 800f3fa:	791b      	ldrb	r3, [r3, #4]
 800f3fc:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f400:	b2db      	uxtb	r3, r3
 800f402:	3b01      	subs	r3, #1
 800f404:	b2db      	uxtb	r3, r3
 800f406:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f40a:	b2d9      	uxtb	r1, r3
 800f40c:	687a      	ldr	r2, [r7, #4]
 800f40e:	7913      	ldrb	r3, [r2, #4]
 800f410:	f361 0305 	bfi	r3, r1, #0, #6
 800f414:	7113      	strb	r3, [r2, #4]
        }

        lv_style_t * local_style = get_alloc_local_style(list_dest);
 800f416:	6878      	ldr	r0, [r7, #4]
 800f418:	f001 f81e 	bl	8010458 <get_alloc_local_style>
 800f41c:	60f8      	str	r0, [r7, #12]
        lv_style_copy(local_style, get_alloc_local_style((lv_style_list_t *)list_src));
 800f41e:	6838      	ldr	r0, [r7, #0]
 800f420:	f001 f81a 	bl	8010458 <get_alloc_local_style>
 800f424:	4603      	mov	r3, r0
 800f426:	4619      	mov	r1, r3
 800f428:	68f8      	ldr	r0, [r7, #12]
 800f42a:	f7ff fe9e 	bl	800f16a <lv_style_copy>
 800f42e:	e000      	b.n	800f432 <lv_style_list_copy+0x1b0>
    if(list_src->style_list == NULL) return;
 800f430:	bf00      	nop
    }
}
 800f432:	3710      	adds	r7, #16
 800f434:	46bd      	mov	sp, r7
 800f436:	bd80      	pop	{r7, pc}

0800f438 <_lv_style_list_add_style>:
 * (It should be static, global or dynamically allocated)
 * @param list pointer to a style list
 * @param style pointer to a style to add
 */
void _lv_style_list_add_style(lv_style_list_t * list, lv_style_t * style)
{
 800f438:	b5b0      	push	{r4, r5, r7, lr}
 800f43a:	b084      	sub	sp, #16
 800f43c:	af00      	add	r7, sp, #0
 800f43e:	6078      	str	r0, [r7, #4]
 800f440:	6039      	str	r1, [r7, #0]
    LV_ASSERT_STYLE_LIST(list);
    LV_ASSERT_STYLE(style);

    if(list == NULL) return;
 800f442:	687b      	ldr	r3, [r7, #4]
 800f444:	2b00      	cmp	r3, #0
 800f446:	d07c      	beq.n	800f542 <_lv_style_list_add_style+0x10a>

    /*Remove the style first if already exists*/
    _lv_style_list_remove_style(list, style);
 800f448:	6839      	ldr	r1, [r7, #0]
 800f44a:	6878      	ldr	r0, [r7, #4]
 800f44c:	f000 f882 	bl	800f554 <_lv_style_list_remove_style>

    lv_style_t ** new_classes;
    if(list->style_cnt == 0) new_classes = lv_mem_alloc(sizeof(lv_style_t *));
 800f450:	687b      	ldr	r3, [r7, #4]
 800f452:	791b      	ldrb	r3, [r3, #4]
 800f454:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f458:	b2db      	uxtb	r3, r3
 800f45a:	2b00      	cmp	r3, #0
 800f45c:	d104      	bne.n	800f468 <_lv_style_list_add_style+0x30>
 800f45e:	2004      	movs	r0, #4
 800f460:	f011 fbb8 	bl	8020bd4 <lv_mem_alloc>
 800f464:	60f8      	str	r0, [r7, #12]
 800f466:	e00d      	b.n	800f484 <_lv_style_list_add_style+0x4c>
    else new_classes = lv_mem_realloc(list->style_list, sizeof(lv_style_t *) * (list->style_cnt + 1));
 800f468:	687b      	ldr	r3, [r7, #4]
 800f46a:	681a      	ldr	r2, [r3, #0]
 800f46c:	687b      	ldr	r3, [r7, #4]
 800f46e:	791b      	ldrb	r3, [r3, #4]
 800f470:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f474:	b2db      	uxtb	r3, r3
 800f476:	3301      	adds	r3, #1
 800f478:	009b      	lsls	r3, r3, #2
 800f47a:	4619      	mov	r1, r3
 800f47c:	4610      	mov	r0, r2
 800f47e:	f011 fc49 	bl	8020d14 <lv_mem_realloc>
 800f482:	60f8      	str	r0, [r7, #12]
    LV_ASSERT_MEM(new_classes);
 800f484:	68f8      	ldr	r0, [r7, #12]
 800f486:	f010 fe33 	bl	80200f0 <lv_debug_check_null>
 800f48a:	4603      	mov	r3, r0
 800f48c:	f083 0301 	eor.w	r3, r3, #1
 800f490:	b2db      	uxtb	r3, r3
 800f492:	2b00      	cmp	r3, #0
 800f494:	d009      	beq.n	800f4aa <_lv_style_list_add_style+0x72>
 800f496:	68fb      	ldr	r3, [r7, #12]
 800f498:	2200      	movs	r2, #0
 800f49a:	461c      	mov	r4, r3
 800f49c:	4615      	mov	r5, r2
 800f49e:	4622      	mov	r2, r4
 800f4a0:	462b      	mov	r3, r5
 800f4a2:	482b      	ldr	r0, [pc, #172]	; (800f550 <_lv_style_list_add_style+0x118>)
 800f4a4:	f010 fe34 	bl	8020110 <lv_debug_log_error>
 800f4a8:	e7fe      	b.n	800f4a8 <_lv_style_list_add_style+0x70>
    if(new_classes == NULL) {
 800f4aa:	68fb      	ldr	r3, [r7, #12]
 800f4ac:	2b00      	cmp	r3, #0
 800f4ae:	d04a      	beq.n	800f546 <_lv_style_list_add_style+0x10e>
        return;
    }

    /*Make space for the new style at the beginning. Leave local and trans style if exists*/
    uint8_t i;
    uint8_t first_style = 0;
 800f4b0:	2300      	movs	r3, #0
 800f4b2:	72bb      	strb	r3, [r7, #10]
    if(list->has_trans) first_style++;
 800f4b4:	687b      	ldr	r3, [r7, #4]
 800f4b6:	791b      	ldrb	r3, [r3, #4]
 800f4b8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800f4bc:	b2db      	uxtb	r3, r3
 800f4be:	2b00      	cmp	r3, #0
 800f4c0:	d002      	beq.n	800f4c8 <_lv_style_list_add_style+0x90>
 800f4c2:	7abb      	ldrb	r3, [r7, #10]
 800f4c4:	3301      	adds	r3, #1
 800f4c6:	72bb      	strb	r3, [r7, #10]
    if(list->has_local) first_style++;
 800f4c8:	687b      	ldr	r3, [r7, #4]
 800f4ca:	791b      	ldrb	r3, [r3, #4]
 800f4cc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f4d0:	b2db      	uxtb	r3, r3
 800f4d2:	2b00      	cmp	r3, #0
 800f4d4:	d002      	beq.n	800f4dc <_lv_style_list_add_style+0xa4>
 800f4d6:	7abb      	ldrb	r3, [r7, #10]
 800f4d8:	3301      	adds	r3, #1
 800f4da:	72bb      	strb	r3, [r7, #10]
    for(i = list->style_cnt; i > first_style; i--) {
 800f4dc:	687b      	ldr	r3, [r7, #4]
 800f4de:	791b      	ldrb	r3, [r3, #4]
 800f4e0:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f4e4:	b2db      	uxtb	r3, r3
 800f4e6:	72fb      	strb	r3, [r7, #11]
 800f4e8:	e00f      	b.n	800f50a <_lv_style_list_add_style+0xd2>
        new_classes[i] = new_classes[i - 1];
 800f4ea:	7afb      	ldrb	r3, [r7, #11]
 800f4ec:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 800f4f0:	3b01      	subs	r3, #1
 800f4f2:	009b      	lsls	r3, r3, #2
 800f4f4:	68fa      	ldr	r2, [r7, #12]
 800f4f6:	441a      	add	r2, r3
 800f4f8:	7afb      	ldrb	r3, [r7, #11]
 800f4fa:	009b      	lsls	r3, r3, #2
 800f4fc:	68f9      	ldr	r1, [r7, #12]
 800f4fe:	440b      	add	r3, r1
 800f500:	6812      	ldr	r2, [r2, #0]
 800f502:	601a      	str	r2, [r3, #0]
    for(i = list->style_cnt; i > first_style; i--) {
 800f504:	7afb      	ldrb	r3, [r7, #11]
 800f506:	3b01      	subs	r3, #1
 800f508:	72fb      	strb	r3, [r7, #11]
 800f50a:	7afa      	ldrb	r2, [r7, #11]
 800f50c:	7abb      	ldrb	r3, [r7, #10]
 800f50e:	429a      	cmp	r2, r3
 800f510:	d8eb      	bhi.n	800f4ea <_lv_style_list_add_style+0xb2>
    }

    new_classes[first_style] = style;
 800f512:	7abb      	ldrb	r3, [r7, #10]
 800f514:	009b      	lsls	r3, r3, #2
 800f516:	68fa      	ldr	r2, [r7, #12]
 800f518:	4413      	add	r3, r2
 800f51a:	683a      	ldr	r2, [r7, #0]
 800f51c:	601a      	str	r2, [r3, #0]
    list->style_cnt++;
 800f51e:	687b      	ldr	r3, [r7, #4]
 800f520:	791b      	ldrb	r3, [r3, #4]
 800f522:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f526:	b2db      	uxtb	r3, r3
 800f528:	3301      	adds	r3, #1
 800f52a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f52e:	b2d9      	uxtb	r1, r3
 800f530:	687a      	ldr	r2, [r7, #4]
 800f532:	7913      	ldrb	r3, [r2, #4]
 800f534:	f361 0305 	bfi	r3, r1, #0, #6
 800f538:	7113      	strb	r3, [r2, #4]
    list->style_list = new_classes;
 800f53a:	687b      	ldr	r3, [r7, #4]
 800f53c:	68fa      	ldr	r2, [r7, #12]
 800f53e:	601a      	str	r2, [r3, #0]
 800f540:	e002      	b.n	800f548 <_lv_style_list_add_style+0x110>
    if(list == NULL) return;
 800f542:	bf00      	nop
 800f544:	e000      	b.n	800f548 <_lv_style_list_add_style+0x110>
        return;
 800f546:	bf00      	nop
}
 800f548:	3710      	adds	r7, #16
 800f54a:	46bd      	mov	sp, r7
 800f54c:	bdb0      	pop	{r4, r5, r7, pc}
 800f54e:	bf00      	nop
 800f550:	0802e448 	.word	0x0802e448

0800f554 <_lv_style_list_remove_style>:
 * Remove a style from a style list
 * @param style_list pointer to a style list
 * @param style pointer to a style to remove
 */
void _lv_style_list_remove_style(lv_style_list_t * list, lv_style_t * style)
{
 800f554:	b5b0      	push	{r4, r5, r7, lr}
 800f556:	b084      	sub	sp, #16
 800f558:	af00      	add	r7, sp, #0
 800f55a:	6078      	str	r0, [r7, #4]
 800f55c:	6039      	str	r1, [r7, #0]
    LV_ASSERT_STYLE_LIST(list);
    LV_ASSERT_STYLE(style);

    if(list->style_cnt == 0) return;
 800f55e:	687b      	ldr	r3, [r7, #4]
 800f560:	791b      	ldrb	r3, [r3, #4]
 800f562:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f566:	b2db      	uxtb	r3, r3
 800f568:	2b00      	cmp	r3, #0
 800f56a:	f000 809f 	beq.w	800f6ac <_lv_style_list_remove_style+0x158>

    /*Check if the style really exists here*/
    uint8_t i;
    bool found = false;
 800f56e:	2300      	movs	r3, #0
 800f570:	73bb      	strb	r3, [r7, #14]
    for(i = 0; i < list->style_cnt; i++) {
 800f572:	2300      	movs	r3, #0
 800f574:	73fb      	strb	r3, [r7, #15]
 800f576:	e00e      	b.n	800f596 <_lv_style_list_remove_style+0x42>
        if(list->style_list[i] == style) {
 800f578:	687b      	ldr	r3, [r7, #4]
 800f57a:	681a      	ldr	r2, [r3, #0]
 800f57c:	7bfb      	ldrb	r3, [r7, #15]
 800f57e:	009b      	lsls	r3, r3, #2
 800f580:	4413      	add	r3, r2
 800f582:	681b      	ldr	r3, [r3, #0]
 800f584:	683a      	ldr	r2, [r7, #0]
 800f586:	429a      	cmp	r2, r3
 800f588:	d102      	bne.n	800f590 <_lv_style_list_remove_style+0x3c>
            found = true;
 800f58a:	2301      	movs	r3, #1
 800f58c:	73bb      	strb	r3, [r7, #14]
            break;
 800f58e:	e00b      	b.n	800f5a8 <_lv_style_list_remove_style+0x54>
    for(i = 0; i < list->style_cnt; i++) {
 800f590:	7bfb      	ldrb	r3, [r7, #15]
 800f592:	3301      	adds	r3, #1
 800f594:	73fb      	strb	r3, [r7, #15]
 800f596:	687b      	ldr	r3, [r7, #4]
 800f598:	791b      	ldrb	r3, [r3, #4]
 800f59a:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f59e:	b2db      	uxtb	r3, r3
 800f5a0:	461a      	mov	r2, r3
 800f5a2:	7bfb      	ldrb	r3, [r7, #15]
 800f5a4:	4293      	cmp	r3, r2
 800f5a6:	d3e7      	bcc.n	800f578 <_lv_style_list_remove_style+0x24>
        }
    }
    if(found == false) return;
 800f5a8:	7bbb      	ldrb	r3, [r7, #14]
 800f5aa:	f083 0301 	eor.w	r3, r3, #1
 800f5ae:	b2db      	uxtb	r3, r3
 800f5b0:	2b00      	cmp	r3, #0
 800f5b2:	d17d      	bne.n	800f6b0 <_lv_style_list_remove_style+0x15c>

    if(list->style_cnt == 1) {
 800f5b4:	687b      	ldr	r3, [r7, #4]
 800f5b6:	791b      	ldrb	r3, [r3, #4]
 800f5b8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f5bc:	b2db      	uxtb	r3, r3
 800f5be:	2b01      	cmp	r3, #1
 800f5c0:	d112      	bne.n	800f5e8 <_lv_style_list_remove_style+0x94>
        lv_mem_free(list->style_list);
 800f5c2:	687b      	ldr	r3, [r7, #4]
 800f5c4:	681b      	ldr	r3, [r3, #0]
 800f5c6:	4618      	mov	r0, r3
 800f5c8:	f011 fb4e 	bl	8020c68 <lv_mem_free>
        list->style_list = NULL;
 800f5cc:	687b      	ldr	r3, [r7, #4]
 800f5ce:	2200      	movs	r2, #0
 800f5d0:	601a      	str	r2, [r3, #0]
        list->style_cnt = 0;
 800f5d2:	687a      	ldr	r2, [r7, #4]
 800f5d4:	7913      	ldrb	r3, [r2, #4]
 800f5d6:	f36f 0305 	bfc	r3, #0, #6
 800f5da:	7113      	strb	r3, [r2, #4]
        list->has_local = 0;
 800f5dc:	687a      	ldr	r2, [r7, #4]
 800f5de:	7913      	ldrb	r3, [r2, #4]
 800f5e0:	f36f 1386 	bfc	r3, #6, #1
 800f5e4:	7113      	strb	r3, [r2, #4]
        return;
 800f5e6:	e066      	b.n	800f6b6 <_lv_style_list_remove_style+0x162>
    }

    lv_style_t ** new_classes = lv_mem_alloc(sizeof(lv_style_t *) * (list->style_cnt - 1));
 800f5e8:	687b      	ldr	r3, [r7, #4]
 800f5ea:	791b      	ldrb	r3, [r3, #4]
 800f5ec:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f5f0:	b2db      	uxtb	r3, r3
 800f5f2:	3b01      	subs	r3, #1
 800f5f4:	009b      	lsls	r3, r3, #2
 800f5f6:	4618      	mov	r0, r3
 800f5f8:	f011 faec 	bl	8020bd4 <lv_mem_alloc>
 800f5fc:	60b8      	str	r0, [r7, #8]
    LV_ASSERT_MEM(new_classes);
 800f5fe:	68b8      	ldr	r0, [r7, #8]
 800f600:	f010 fd76 	bl	80200f0 <lv_debug_check_null>
 800f604:	4603      	mov	r3, r0
 800f606:	f083 0301 	eor.w	r3, r3, #1
 800f60a:	b2db      	uxtb	r3, r3
 800f60c:	2b00      	cmp	r3, #0
 800f60e:	d009      	beq.n	800f624 <_lv_style_list_remove_style+0xd0>
 800f610:	68bb      	ldr	r3, [r7, #8]
 800f612:	2200      	movs	r2, #0
 800f614:	461c      	mov	r4, r3
 800f616:	4615      	mov	r5, r2
 800f618:	4622      	mov	r2, r4
 800f61a:	462b      	mov	r3, r5
 800f61c:	4827      	ldr	r0, [pc, #156]	; (800f6bc <_lv_style_list_remove_style+0x168>)
 800f61e:	f010 fd77 	bl	8020110 <lv_debug_log_error>
 800f622:	e7fe      	b.n	800f622 <_lv_style_list_remove_style+0xce>
    if(new_classes == NULL) {
 800f624:	68bb      	ldr	r3, [r7, #8]
 800f626:	2b00      	cmp	r3, #0
 800f628:	d044      	beq.n	800f6b4 <_lv_style_list_remove_style+0x160>
        LV_LOG_WARN("lv_style_list_remove_style: couldn't reallocate class list");
        return;
    }
    uint8_t j;
    for(i = 0, j = 0; i < list->style_cnt; i++) {
 800f62a:	2300      	movs	r3, #0
 800f62c:	73fb      	strb	r3, [r7, #15]
 800f62e:	2300      	movs	r3, #0
 800f630:	737b      	strb	r3, [r7, #13]
 800f632:	e01b      	b.n	800f66c <_lv_style_list_remove_style+0x118>
        if(list->style_list[i] == style) continue;
 800f634:	687b      	ldr	r3, [r7, #4]
 800f636:	681a      	ldr	r2, [r3, #0]
 800f638:	7bfb      	ldrb	r3, [r7, #15]
 800f63a:	009b      	lsls	r3, r3, #2
 800f63c:	4413      	add	r3, r2
 800f63e:	681b      	ldr	r3, [r3, #0]
 800f640:	683a      	ldr	r2, [r7, #0]
 800f642:	429a      	cmp	r2, r3
 800f644:	d00e      	beq.n	800f664 <_lv_style_list_remove_style+0x110>
        new_classes[j] = list->style_list[i];
 800f646:	687b      	ldr	r3, [r7, #4]
 800f648:	681a      	ldr	r2, [r3, #0]
 800f64a:	7bfb      	ldrb	r3, [r7, #15]
 800f64c:	009b      	lsls	r3, r3, #2
 800f64e:	441a      	add	r2, r3
 800f650:	7b7b      	ldrb	r3, [r7, #13]
 800f652:	009b      	lsls	r3, r3, #2
 800f654:	68b9      	ldr	r1, [r7, #8]
 800f656:	440b      	add	r3, r1
 800f658:	6812      	ldr	r2, [r2, #0]
 800f65a:	601a      	str	r2, [r3, #0]
        j++;
 800f65c:	7b7b      	ldrb	r3, [r7, #13]
 800f65e:	3301      	adds	r3, #1
 800f660:	737b      	strb	r3, [r7, #13]
 800f662:	e000      	b.n	800f666 <_lv_style_list_remove_style+0x112>
        if(list->style_list[i] == style) continue;
 800f664:	bf00      	nop
    for(i = 0, j = 0; i < list->style_cnt; i++) {
 800f666:	7bfb      	ldrb	r3, [r7, #15]
 800f668:	3301      	adds	r3, #1
 800f66a:	73fb      	strb	r3, [r7, #15]
 800f66c:	687b      	ldr	r3, [r7, #4]
 800f66e:	791b      	ldrb	r3, [r3, #4]
 800f670:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f674:	b2db      	uxtb	r3, r3
 800f676:	461a      	mov	r2, r3
 800f678:	7bfb      	ldrb	r3, [r7, #15]
 800f67a:	4293      	cmp	r3, r2
 800f67c:	d3da      	bcc.n	800f634 <_lv_style_list_remove_style+0xe0>

    }

    lv_mem_free(list->style_list);
 800f67e:	687b      	ldr	r3, [r7, #4]
 800f680:	681b      	ldr	r3, [r3, #0]
 800f682:	4618      	mov	r0, r3
 800f684:	f011 faf0 	bl	8020c68 <lv_mem_free>

    list->style_cnt--;
 800f688:	687b      	ldr	r3, [r7, #4]
 800f68a:	791b      	ldrb	r3, [r3, #4]
 800f68c:	f3c3 0305 	ubfx	r3, r3, #0, #6
 800f690:	b2db      	uxtb	r3, r3
 800f692:	333f      	adds	r3, #63	; 0x3f
 800f694:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f698:	b2d9      	uxtb	r1, r3
 800f69a:	687a      	ldr	r2, [r7, #4]
 800f69c:	7913      	ldrb	r3, [r2, #4]
 800f69e:	f361 0305 	bfi	r3, r1, #0, #6
 800f6a2:	7113      	strb	r3, [r2, #4]
    list->style_list = new_classes;
 800f6a4:	687b      	ldr	r3, [r7, #4]
 800f6a6:	68ba      	ldr	r2, [r7, #8]
 800f6a8:	601a      	str	r2, [r3, #0]
 800f6aa:	e004      	b.n	800f6b6 <_lv_style_list_remove_style+0x162>
    if(list->style_cnt == 0) return;
 800f6ac:	bf00      	nop
 800f6ae:	e002      	b.n	800f6b6 <_lv_style_list_remove_style+0x162>
    if(found == false) return;
 800f6b0:	bf00      	nop
 800f6b2:	e000      	b.n	800f6b6 <_lv_style_list_remove_style+0x162>
        return;
 800f6b4:	bf00      	nop
}
 800f6b6:	3710      	adds	r7, #16
 800f6b8:	46bd      	mov	sp, r7
 800f6ba:	bdb0      	pop	{r4, r5, r7, pc}
 800f6bc:	0802e448 	.word	0x0802e448

0800f6c0 <_lv_style_list_reset>:
 * Remove all styles added from style list, clear the local style, transition style and free all allocated memories.
 * Leave `ignore_trans` flag as it is.
 * @param list pointer to a style list.
 */
void _lv_style_list_reset(lv_style_list_t * list)
{
 800f6c0:	b580      	push	{r7, lr}
 800f6c2:	b084      	sub	sp, #16
 800f6c4:	af00      	add	r7, sp, #0
 800f6c6:	6078      	str	r0, [r7, #4]
    LV_ASSERT_STYLE_LIST(list);

    if(list == NULL) return;
 800f6c8:	687b      	ldr	r3, [r7, #4]
 800f6ca:	2b00      	cmp	r3, #0
 800f6cc:	d04b      	beq.n	800f766 <_lv_style_list_reset+0xa6>

    if(list->has_local) {
 800f6ce:	687b      	ldr	r3, [r7, #4]
 800f6d0:	791b      	ldrb	r3, [r3, #4]
 800f6d2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f6d6:	b2db      	uxtb	r3, r3
 800f6d8:	2b00      	cmp	r3, #0
 800f6da:	d00c      	beq.n	800f6f6 <_lv_style_list_reset+0x36>
        lv_style_t * local = lv_style_list_get_local_style(list);
 800f6dc:	6878      	ldr	r0, [r7, #4]
 800f6de:	f000 fbcb 	bl	800fe78 <lv_style_list_get_local_style>
 800f6e2:	60f8      	str	r0, [r7, #12]
        if(local) {
 800f6e4:	68fb      	ldr	r3, [r7, #12]
 800f6e6:	2b00      	cmp	r3, #0
 800f6e8:	d005      	beq.n	800f6f6 <_lv_style_list_reset+0x36>
            lv_style_reset(local);
 800f6ea:	68f8      	ldr	r0, [r7, #12]
 800f6ec:	f000 f83f 	bl	800f76e <lv_style_reset>
            lv_mem_free(local);
 800f6f0:	68f8      	ldr	r0, [r7, #12]
 800f6f2:	f011 fab9 	bl	8020c68 <lv_mem_free>
        }
    }

    if(list->has_trans) {
 800f6f6:	687b      	ldr	r3, [r7, #4]
 800f6f8:	791b      	ldrb	r3, [r3, #4]
 800f6fa:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800f6fe:	b2db      	uxtb	r3, r3
 800f700:	2b00      	cmp	r3, #0
 800f702:	d00c      	beq.n	800f71e <_lv_style_list_reset+0x5e>
        lv_style_t * trans = _lv_style_list_get_transition_style(list);
 800f704:	6878      	ldr	r0, [r7, #4]
 800f706:	f000 fbd8 	bl	800feba <_lv_style_list_get_transition_style>
 800f70a:	60b8      	str	r0, [r7, #8]
        if(trans) {
 800f70c:	68bb      	ldr	r3, [r7, #8]
 800f70e:	2b00      	cmp	r3, #0
 800f710:	d005      	beq.n	800f71e <_lv_style_list_reset+0x5e>
            lv_style_reset(trans);
 800f712:	68b8      	ldr	r0, [r7, #8]
 800f714:	f000 f82b 	bl	800f76e <lv_style_reset>
            lv_mem_free(trans);
 800f718:	68b8      	ldr	r0, [r7, #8]
 800f71a:	f011 faa5 	bl	8020c68 <lv_mem_free>
        }
    }

    if(list->style_cnt > 0) lv_mem_free(list->style_list);
 800f71e:	687b      	ldr	r3, [r7, #4]
 800f720:	791b      	ldrb	r3, [r3, #4]
 800f722:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800f726:	b2db      	uxtb	r3, r3
 800f728:	2b00      	cmp	r3, #0
 800f72a:	d004      	beq.n	800f736 <_lv_style_list_reset+0x76>
 800f72c:	687b      	ldr	r3, [r7, #4]
 800f72e:	681b      	ldr	r3, [r3, #0]
 800f730:	4618      	mov	r0, r3
 800f732:	f011 fa99 	bl	8020c68 <lv_mem_free>
    list->style_list = NULL;
 800f736:	687b      	ldr	r3, [r7, #4]
 800f738:	2200      	movs	r2, #0
 800f73a:	601a      	str	r2, [r3, #0]
    list->style_cnt = 0;
 800f73c:	687a      	ldr	r2, [r7, #4]
 800f73e:	7913      	ldrb	r3, [r2, #4]
 800f740:	f36f 0305 	bfc	r3, #0, #6
 800f744:	7113      	strb	r3, [r2, #4]
    list->has_local = 0;
 800f746:	687a      	ldr	r2, [r7, #4]
 800f748:	7913      	ldrb	r3, [r2, #4]
 800f74a:	f36f 1386 	bfc	r3, #6, #1
 800f74e:	7113      	strb	r3, [r2, #4]
    list->has_trans = 0;
 800f750:	687a      	ldr	r2, [r7, #4]
 800f752:	7913      	ldrb	r3, [r2, #4]
 800f754:	f36f 13c7 	bfc	r3, #7, #1
 800f758:	7113      	strb	r3, [r2, #4]
    list->skip_trans = 0;
 800f75a:	687a      	ldr	r2, [r7, #4]
 800f75c:	7953      	ldrb	r3, [r2, #5]
 800f75e:	f36f 0300 	bfc	r3, #0, #1
 800f762:	7153      	strb	r3, [r2, #5]
 800f764:	e000      	b.n	800f768 <_lv_style_list_reset+0xa8>
    if(list == NULL) return;
 800f766:	bf00      	nop

    /* Intentionally leave `ignore_trans` as it is,
     * because it's independent from the styles in the list*/
}
 800f768:	3710      	adds	r7, #16
 800f76a:	46bd      	mov	sp, r7
 800f76c:	bd80      	pop	{r7, pc}

0800f76e <lv_style_reset>:
/**
 * Clear all properties from a style and all allocated memories.
 * @param style pointer to a style
 */
void lv_style_reset(lv_style_t * style)
{
 800f76e:	b580      	push	{r7, lr}
 800f770:	b082      	sub	sp, #8
 800f772:	af00      	add	r7, sp, #0
 800f774:	6078      	str	r0, [r7, #4]
    LV_ASSERT_STYLE(style);

    lv_mem_free(style->map);
 800f776:	687b      	ldr	r3, [r7, #4]
 800f778:	681b      	ldr	r3, [r3, #0]
 800f77a:	4618      	mov	r0, r3
 800f77c:	f011 fa74 	bl	8020c68 <lv_mem_free>
    style->map = NULL;
 800f780:	687b      	ldr	r3, [r7, #4]
 800f782:	2200      	movs	r2, #0
 800f784:	601a      	str	r2, [r3, #0]
}
 800f786:	bf00      	nop
 800f788:	3708      	adds	r7, #8
 800f78a:	46bd      	mov	sp, r7
 800f78c:	bd80      	pop	{r7, pc}

0800f78e <_lv_style_get_mem_size>:
 * Get the size of the properties in a style in bytes
 * @param style pointer to a style
 * @return size of the properties in bytes
 */
uint16_t _lv_style_get_mem_size(const lv_style_t * style)
{
 800f78e:	b580      	push	{r7, lr}
 800f790:	b084      	sub	sp, #16
 800f792:	af00      	add	r7, sp, #0
 800f794:	6078      	str	r0, [r7, #4]
    LV_ASSERT_STYLE(style);

    if(style->map == NULL) return 0;
 800f796:	687b      	ldr	r3, [r7, #4]
 800f798:	681b      	ldr	r3, [r3, #0]
 800f79a:	2b00      	cmp	r3, #0
 800f79c:	d101      	bne.n	800f7a2 <_lv_style_get_mem_size+0x14>
 800f79e:	2300      	movs	r3, #0
 800f7a0:	e015      	b.n	800f7ce <_lv_style_get_mem_size+0x40>

    size_t i = 0;
 800f7a2:	2300      	movs	r3, #0
 800f7a4:	60fb      	str	r3, [r7, #12]
    uint8_t prop_id;
    while((prop_id = get_style_prop_id(style, i)) != _LV_STYLE_CLOSEING_PROP) {
 800f7a6:	e005      	b.n	800f7b4 <_lv_style_get_mem_size+0x26>
        i = get_next_prop_index(prop_id, i);
 800f7a8:	7afb      	ldrb	r3, [r7, #11]
 800f7aa:	68f9      	ldr	r1, [r7, #12]
 800f7ac:	4618      	mov	r0, r3
 800f7ae:	f000 ff12 	bl	80105d6 <get_next_prop_index>
 800f7b2:	60f8      	str	r0, [r7, #12]
    while((prop_id = get_style_prop_id(style, i)) != _LV_STYLE_CLOSEING_PROP) {
 800f7b4:	68f9      	ldr	r1, [r7, #12]
 800f7b6:	6878      	ldr	r0, [r7, #4]
 800f7b8:	f000 fec3 	bl	8010542 <get_style_prop_id>
 800f7bc:	4603      	mov	r3, r0
 800f7be:	72fb      	strb	r3, [r7, #11]
 800f7c0:	7afb      	ldrb	r3, [r7, #11]
 800f7c2:	2bff      	cmp	r3, #255	; 0xff
 800f7c4:	d1f0      	bne.n	800f7a8 <_lv_style_get_mem_size+0x1a>
    }

    return i + sizeof(lv_style_property_t);
 800f7c6:	68fb      	ldr	r3, [r7, #12]
 800f7c8:	b29b      	uxth	r3, r3
 800f7ca:	3302      	adds	r3, #2
 800f7cc:	b29b      	uxth	r3, r3
}
 800f7ce:	4618      	mov	r0, r3
 800f7d0:	3710      	adds	r7, #16
 800f7d2:	46bd      	mov	sp, r7
 800f7d4:	bd80      	pop	{r7, pc}
	...

0800f7d8 <_lv_style_set_int>:
 * @note shouldn't be used directly. Use the specific property set functions instead.
 *       For example: `lv_style_set_border_width()`
 * @note for performance reasons it's not checked if the property really has integer type
 */
void _lv_style_set_int(lv_style_t * style, lv_style_property_t prop, lv_style_int_t value)
{
 800f7d8:	b5b0      	push	{r4, r5, r7, lr}
 800f7da:	b086      	sub	sp, #24
 800f7dc:	af00      	add	r7, sp, #0
 800f7de:	6078      	str	r0, [r7, #4]
 800f7e0:	460b      	mov	r3, r1
 800f7e2:	807b      	strh	r3, [r7, #2]
 800f7e4:	4613      	mov	r3, r2
 800f7e6:	803b      	strh	r3, [r7, #0]
    LV_ASSERT_STYLE(style);

    int32_t id = get_property_index(style, prop);
 800f7e8:	887b      	ldrh	r3, [r7, #2]
 800f7ea:	4619      	mov	r1, r3
 800f7ec:	6878      	ldr	r0, [r7, #4]
 800f7ee:	f000 fdd5 	bl	801039c <get_property_index>
 800f7f2:	6138      	str	r0, [r7, #16]
    /*The property already exists but not sure it's state is the same*/
    if(id >= 0) {
 800f7f4:	693b      	ldr	r3, [r7, #16]
 800f7f6:	2b00      	cmp	r3, #0
 800f7f8:	db1d      	blt.n	800f836 <_lv_style_set_int+0x5e>
        lv_style_attr_t attr_found;
        lv_style_attr_t attr_goal;

        attr_found = get_style_prop_attr(style, id);
 800f7fa:	693b      	ldr	r3, [r7, #16]
 800f7fc:	4619      	mov	r1, r3
 800f7fe:	6878      	ldr	r0, [r7, #4]
 800f800:	f000 feae 	bl	8010560 <get_style_prop_attr>
 800f804:	4603      	mov	r3, r0
 800f806:	73fb      	strb	r3, [r7, #15]
        attr_goal = (prop >> 8) & 0xFFU;
 800f808:	887b      	ldrh	r3, [r7, #2]
 800f80a:	0a1b      	lsrs	r3, r3, #8
 800f80c:	b29b      	uxth	r3, r3
 800f80e:	73bb      	strb	r3, [r7, #14]

        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
 800f810:	7bfa      	ldrb	r2, [r7, #15]
 800f812:	7bbb      	ldrb	r3, [r7, #14]
 800f814:	4053      	eors	r3, r2
 800f816:	b2db      	uxtb	r3, r3
 800f818:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800f81c:	2b00      	cmp	r3, #0
 800f81e:	d10a      	bne.n	800f836 <_lv_style_set_int+0x5e>
            _lv_memcpy_small(style->map + id + sizeof(lv_style_property_t), &value, sizeof(lv_style_int_t));
 800f820:	687b      	ldr	r3, [r7, #4]
 800f822:	681a      	ldr	r2, [r3, #0]
 800f824:	693b      	ldr	r3, [r7, #16]
 800f826:	3302      	adds	r3, #2
 800f828:	4413      	add	r3, r2
 800f82a:	4639      	mov	r1, r7
 800f82c:	2202      	movs	r2, #2
 800f82e:	4618      	mov	r0, r3
 800f830:	f7ff fc38 	bl	800f0a4 <_lv_memcpy_small>
            return;
 800f834:	e05b      	b.n	800f8ee <_lv_style_set_int+0x116>
        }
    }

    /*Add new property if not exists yet*/
    uint8_t new_prop_size = (sizeof(lv_style_property_t) + sizeof(lv_style_int_t));
 800f836:	2304      	movs	r3, #4
 800f838:	737b      	strb	r3, [r7, #13]
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
 800f83a:	23ff      	movs	r3, #255	; 0xff
 800f83c:	817b      	strh	r3, [r7, #10]
    uint8_t end_mark_size = sizeof(end_mark);
 800f83e:	2302      	movs	r3, #2
 800f840:	733b      	strb	r3, [r7, #12]

    uint16_t size = _lv_style_get_mem_size(style);
 800f842:	6878      	ldr	r0, [r7, #4]
 800f844:	f7ff ffa3 	bl	800f78e <_lv_style_get_mem_size>
 800f848:	4603      	mov	r3, r0
 800f84a:	82fb      	strh	r3, [r7, #22]
    if(size == 0) size += end_mark_size;
 800f84c:	8afb      	ldrh	r3, [r7, #22]
 800f84e:	2b00      	cmp	r3, #0
 800f850:	d104      	bne.n	800f85c <_lv_style_set_int+0x84>
 800f852:	7b3b      	ldrb	r3, [r7, #12]
 800f854:	b29a      	uxth	r2, r3
 800f856:	8afb      	ldrh	r3, [r7, #22]
 800f858:	4413      	add	r3, r2
 800f85a:	82fb      	strh	r3, [r7, #22]
    size += sizeof(lv_style_property_t) + sizeof(lv_style_int_t);
 800f85c:	8afb      	ldrh	r3, [r7, #22]
 800f85e:	3304      	adds	r3, #4
 800f860:	82fb      	strh	r3, [r7, #22]
    style_resize(style, size);
 800f862:	8afb      	ldrh	r3, [r7, #22]
 800f864:	4619      	mov	r1, r3
 800f866:	6878      	ldr	r0, [r7, #4]
 800f868:	f000 fe3a 	bl	80104e0 <style_resize>
    LV_ASSERT_MEM(style->map);
 800f86c:	687b      	ldr	r3, [r7, #4]
 800f86e:	681b      	ldr	r3, [r3, #0]
 800f870:	4618      	mov	r0, r3
 800f872:	f010 fc3d 	bl	80200f0 <lv_debug_check_null>
 800f876:	4603      	mov	r3, r0
 800f878:	f083 0301 	eor.w	r3, r3, #1
 800f87c:	b2db      	uxtb	r3, r3
 800f87e:	2b00      	cmp	r3, #0
 800f880:	d00b      	beq.n	800f89a <_lv_style_set_int+0xc2>
 800f882:	687b      	ldr	r3, [r7, #4]
 800f884:	681b      	ldr	r3, [r3, #0]
 800f886:	461a      	mov	r2, r3
 800f888:	2300      	movs	r3, #0
 800f88a:	4614      	mov	r4, r2
 800f88c:	461d      	mov	r5, r3
 800f88e:	4622      	mov	r2, r4
 800f890:	462b      	mov	r3, r5
 800f892:	4818      	ldr	r0, [pc, #96]	; (800f8f4 <_lv_style_set_int+0x11c>)
 800f894:	f010 fc3c 	bl	8020110 <lv_debug_log_error>
 800f898:	e7fe      	b.n	800f898 <_lv_style_set_int+0xc0>
    if(style == NULL) return;
 800f89a:	687b      	ldr	r3, [r7, #4]
 800f89c:	2b00      	cmp	r3, #0
 800f89e:	d025      	beq.n	800f8ec <_lv_style_set_int+0x114>

    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
 800f8a0:	687b      	ldr	r3, [r7, #4]
 800f8a2:	681a      	ldr	r2, [r3, #0]
 800f8a4:	8af9      	ldrh	r1, [r7, #22]
 800f8a6:	7b7b      	ldrb	r3, [r7, #13]
 800f8a8:	1ac9      	subs	r1, r1, r3
 800f8aa:	7b3b      	ldrb	r3, [r7, #12]
 800f8ac:	1acb      	subs	r3, r1, r3
 800f8ae:	4413      	add	r3, r2
 800f8b0:	1cb9      	adds	r1, r7, #2
 800f8b2:	2202      	movs	r2, #2
 800f8b4:	4618      	mov	r0, r3
 800f8b6:	f7ff fbf5 	bl	800f0a4 <_lv_memcpy_small>
    _lv_memcpy_small(style->map + size - sizeof(lv_style_int_t) - end_mark_size, &value, sizeof(lv_style_int_t));
 800f8ba:	687b      	ldr	r3, [r7, #4]
 800f8bc:	681a      	ldr	r2, [r3, #0]
 800f8be:	8af9      	ldrh	r1, [r7, #22]
 800f8c0:	7b3b      	ldrb	r3, [r7, #12]
 800f8c2:	1acb      	subs	r3, r1, r3
 800f8c4:	3b02      	subs	r3, #2
 800f8c6:	4413      	add	r3, r2
 800f8c8:	4639      	mov	r1, r7
 800f8ca:	2202      	movs	r2, #2
 800f8cc:	4618      	mov	r0, r3
 800f8ce:	f7ff fbe9 	bl	800f0a4 <_lv_memcpy_small>
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
 800f8d2:	687b      	ldr	r3, [r7, #4]
 800f8d4:	681a      	ldr	r2, [r3, #0]
 800f8d6:	8af9      	ldrh	r1, [r7, #22]
 800f8d8:	7b3b      	ldrb	r3, [r7, #12]
 800f8da:	1acb      	subs	r3, r1, r3
 800f8dc:	4413      	add	r3, r2
 800f8de:	f107 010a 	add.w	r1, r7, #10
 800f8e2:	2202      	movs	r2, #2
 800f8e4:	4618      	mov	r0, r3
 800f8e6:	f7ff fbdd 	bl	800f0a4 <_lv_memcpy_small>
 800f8ea:	e000      	b.n	800f8ee <_lv_style_set_int+0x116>
    if(style == NULL) return;
 800f8ec:	bf00      	nop
}
 800f8ee:	3718      	adds	r7, #24
 800f8f0:	46bd      	mov	sp, r7
 800f8f2:	bdb0      	pop	{r4, r5, r7, pc}
 800f8f4:	0802e448 	.word	0x0802e448

0800f8f8 <_lv_style_set_color>:
 * @note shouldn't be used directly. Use the specific property set functions instead.
 *       For example: `lv_style_set_border_color()`
 * @note for performance reasons it's not checked if the property really has color type
 */
void _lv_style_set_color(lv_style_t * style, lv_style_property_t prop, lv_color_t color)
{
 800f8f8:	b5b0      	push	{r4, r5, r7, lr}
 800f8fa:	b086      	sub	sp, #24
 800f8fc:	af00      	add	r7, sp, #0
 800f8fe:	6078      	str	r0, [r7, #4]
 800f900:	460b      	mov	r3, r1
 800f902:	803a      	strh	r2, [r7, #0]
 800f904:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_STYLE(style);

    int32_t id = get_property_index(style, prop);
 800f906:	887b      	ldrh	r3, [r7, #2]
 800f908:	4619      	mov	r1, r3
 800f90a:	6878      	ldr	r0, [r7, #4]
 800f90c:	f000 fd46 	bl	801039c <get_property_index>
 800f910:	6138      	str	r0, [r7, #16]
    /*The property already exists but not sure it's state is the same*/
    if(id >= 0) {
 800f912:	693b      	ldr	r3, [r7, #16]
 800f914:	2b00      	cmp	r3, #0
 800f916:	db1d      	blt.n	800f954 <_lv_style_set_color+0x5c>
        lv_style_attr_t attr_found;
        lv_style_attr_t attr_goal;

        attr_found = get_style_prop_attr(style, id);
 800f918:	693b      	ldr	r3, [r7, #16]
 800f91a:	4619      	mov	r1, r3
 800f91c:	6878      	ldr	r0, [r7, #4]
 800f91e:	f000 fe1f 	bl	8010560 <get_style_prop_attr>
 800f922:	4603      	mov	r3, r0
 800f924:	73fb      	strb	r3, [r7, #15]
        attr_goal = (prop >> 8) & 0xFFU;
 800f926:	887b      	ldrh	r3, [r7, #2]
 800f928:	0a1b      	lsrs	r3, r3, #8
 800f92a:	b29b      	uxth	r3, r3
 800f92c:	73bb      	strb	r3, [r7, #14]

        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
 800f92e:	7bfa      	ldrb	r2, [r7, #15]
 800f930:	7bbb      	ldrb	r3, [r7, #14]
 800f932:	4053      	eors	r3, r2
 800f934:	b2db      	uxtb	r3, r3
 800f936:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800f93a:	2b00      	cmp	r3, #0
 800f93c:	d10a      	bne.n	800f954 <_lv_style_set_color+0x5c>
            _lv_memcpy_small(style->map + id + sizeof(lv_style_property_t), &color, sizeof(lv_color_t));
 800f93e:	687b      	ldr	r3, [r7, #4]
 800f940:	681a      	ldr	r2, [r3, #0]
 800f942:	693b      	ldr	r3, [r7, #16]
 800f944:	3302      	adds	r3, #2
 800f946:	4413      	add	r3, r2
 800f948:	4639      	mov	r1, r7
 800f94a:	2202      	movs	r2, #2
 800f94c:	4618      	mov	r0, r3
 800f94e:	f7ff fba9 	bl	800f0a4 <_lv_memcpy_small>
            return;
 800f952:	e05b      	b.n	800fa0c <_lv_style_set_color+0x114>
        }
    }

    /*Add new property if not exists yet*/
    uint8_t new_prop_size = (sizeof(lv_style_property_t) + sizeof(lv_color_t));
 800f954:	2304      	movs	r3, #4
 800f956:	737b      	strb	r3, [r7, #13]
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
 800f958:	23ff      	movs	r3, #255	; 0xff
 800f95a:	817b      	strh	r3, [r7, #10]
    uint8_t end_mark_size = sizeof(end_mark);
 800f95c:	2302      	movs	r3, #2
 800f95e:	733b      	strb	r3, [r7, #12]

    uint16_t size = _lv_style_get_mem_size(style);
 800f960:	6878      	ldr	r0, [r7, #4]
 800f962:	f7ff ff14 	bl	800f78e <_lv_style_get_mem_size>
 800f966:	4603      	mov	r3, r0
 800f968:	82fb      	strh	r3, [r7, #22]
    if(size == 0) size += end_mark_size;
 800f96a:	8afb      	ldrh	r3, [r7, #22]
 800f96c:	2b00      	cmp	r3, #0
 800f96e:	d104      	bne.n	800f97a <_lv_style_set_color+0x82>
 800f970:	7b3b      	ldrb	r3, [r7, #12]
 800f972:	b29a      	uxth	r2, r3
 800f974:	8afb      	ldrh	r3, [r7, #22]
 800f976:	4413      	add	r3, r2
 800f978:	82fb      	strh	r3, [r7, #22]

    size += sizeof(lv_style_property_t) + sizeof(lv_color_t);
 800f97a:	8afb      	ldrh	r3, [r7, #22]
 800f97c:	3304      	adds	r3, #4
 800f97e:	82fb      	strh	r3, [r7, #22]
    style_resize(style, size);
 800f980:	8afb      	ldrh	r3, [r7, #22]
 800f982:	4619      	mov	r1, r3
 800f984:	6878      	ldr	r0, [r7, #4]
 800f986:	f000 fdab 	bl	80104e0 <style_resize>
    LV_ASSERT_MEM(style->map);
 800f98a:	687b      	ldr	r3, [r7, #4]
 800f98c:	681b      	ldr	r3, [r3, #0]
 800f98e:	4618      	mov	r0, r3
 800f990:	f010 fbae 	bl	80200f0 <lv_debug_check_null>
 800f994:	4603      	mov	r3, r0
 800f996:	f083 0301 	eor.w	r3, r3, #1
 800f99a:	b2db      	uxtb	r3, r3
 800f99c:	2b00      	cmp	r3, #0
 800f99e:	d00b      	beq.n	800f9b8 <_lv_style_set_color+0xc0>
 800f9a0:	687b      	ldr	r3, [r7, #4]
 800f9a2:	681b      	ldr	r3, [r3, #0]
 800f9a4:	461a      	mov	r2, r3
 800f9a6:	2300      	movs	r3, #0
 800f9a8:	4614      	mov	r4, r2
 800f9aa:	461d      	mov	r5, r3
 800f9ac:	4622      	mov	r2, r4
 800f9ae:	462b      	mov	r3, r5
 800f9b0:	4818      	ldr	r0, [pc, #96]	; (800fa14 <_lv_style_set_color+0x11c>)
 800f9b2:	f010 fbad 	bl	8020110 <lv_debug_log_error>
 800f9b6:	e7fe      	b.n	800f9b6 <_lv_style_set_color+0xbe>
    if(style == NULL) return;
 800f9b8:	687b      	ldr	r3, [r7, #4]
 800f9ba:	2b00      	cmp	r3, #0
 800f9bc:	d025      	beq.n	800fa0a <_lv_style_set_color+0x112>

    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
 800f9be:	687b      	ldr	r3, [r7, #4]
 800f9c0:	681a      	ldr	r2, [r3, #0]
 800f9c2:	8af9      	ldrh	r1, [r7, #22]
 800f9c4:	7b7b      	ldrb	r3, [r7, #13]
 800f9c6:	1ac9      	subs	r1, r1, r3
 800f9c8:	7b3b      	ldrb	r3, [r7, #12]
 800f9ca:	1acb      	subs	r3, r1, r3
 800f9cc:	4413      	add	r3, r2
 800f9ce:	1cb9      	adds	r1, r7, #2
 800f9d0:	2202      	movs	r2, #2
 800f9d2:	4618      	mov	r0, r3
 800f9d4:	f7ff fb66 	bl	800f0a4 <_lv_memcpy_small>
    _lv_memcpy_small(style->map + size - sizeof(lv_color_t) - end_mark_size, &color, sizeof(lv_color_t));
 800f9d8:	687b      	ldr	r3, [r7, #4]
 800f9da:	681a      	ldr	r2, [r3, #0]
 800f9dc:	8af9      	ldrh	r1, [r7, #22]
 800f9de:	7b3b      	ldrb	r3, [r7, #12]
 800f9e0:	1acb      	subs	r3, r1, r3
 800f9e2:	3b02      	subs	r3, #2
 800f9e4:	4413      	add	r3, r2
 800f9e6:	4639      	mov	r1, r7
 800f9e8:	2202      	movs	r2, #2
 800f9ea:	4618      	mov	r0, r3
 800f9ec:	f7ff fb5a 	bl	800f0a4 <_lv_memcpy_small>
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
 800f9f0:	687b      	ldr	r3, [r7, #4]
 800f9f2:	681a      	ldr	r2, [r3, #0]
 800f9f4:	8af9      	ldrh	r1, [r7, #22]
 800f9f6:	7b3b      	ldrb	r3, [r7, #12]
 800f9f8:	1acb      	subs	r3, r1, r3
 800f9fa:	4413      	add	r3, r2
 800f9fc:	f107 010a 	add.w	r1, r7, #10
 800fa00:	2202      	movs	r2, #2
 800fa02:	4618      	mov	r0, r3
 800fa04:	f7ff fb4e 	bl	800f0a4 <_lv_memcpy_small>
 800fa08:	e000      	b.n	800fa0c <_lv_style_set_color+0x114>
    if(style == NULL) return;
 800fa0a:	bf00      	nop
}
 800fa0c:	3718      	adds	r7, #24
 800fa0e:	46bd      	mov	sp, r7
 800fa10:	bdb0      	pop	{r4, r5, r7, pc}
 800fa12:	bf00      	nop
 800fa14:	0802e448 	.word	0x0802e448

0800fa18 <_lv_style_set_opa>:
 * @note shouldn't be used directly. Use the specific property set functions instead.
 *       For example: `lv_style_set_border_opa()`
 * @note for performance reasons it's not checked if the property really has opacity type
 */
void _lv_style_set_opa(lv_style_t * style, lv_style_property_t prop, lv_opa_t opa)
{
 800fa18:	b5b0      	push	{r4, r5, r7, lr}
 800fa1a:	b086      	sub	sp, #24
 800fa1c:	af00      	add	r7, sp, #0
 800fa1e:	6078      	str	r0, [r7, #4]
 800fa20:	460b      	mov	r3, r1
 800fa22:	807b      	strh	r3, [r7, #2]
 800fa24:	4613      	mov	r3, r2
 800fa26:	707b      	strb	r3, [r7, #1]
    LV_ASSERT_STYLE(style);

    int32_t id = get_property_index(style, prop);
 800fa28:	887b      	ldrh	r3, [r7, #2]
 800fa2a:	4619      	mov	r1, r3
 800fa2c:	6878      	ldr	r0, [r7, #4]
 800fa2e:	f000 fcb5 	bl	801039c <get_property_index>
 800fa32:	6138      	str	r0, [r7, #16]
    /*The property already exists but not sure it's state is the same*/
    if(id >= 0) {
 800fa34:	693b      	ldr	r3, [r7, #16]
 800fa36:	2b00      	cmp	r3, #0
 800fa38:	db1d      	blt.n	800fa76 <_lv_style_set_opa+0x5e>
        lv_style_attr_t attr_found;
        lv_style_attr_t attr_goal;

        attr_found = get_style_prop_attr(style, id);
 800fa3a:	693b      	ldr	r3, [r7, #16]
 800fa3c:	4619      	mov	r1, r3
 800fa3e:	6878      	ldr	r0, [r7, #4]
 800fa40:	f000 fd8e 	bl	8010560 <get_style_prop_attr>
 800fa44:	4603      	mov	r3, r0
 800fa46:	73fb      	strb	r3, [r7, #15]
        attr_goal = (prop >> 8) & 0xFFU;
 800fa48:	887b      	ldrh	r3, [r7, #2]
 800fa4a:	0a1b      	lsrs	r3, r3, #8
 800fa4c:	b29b      	uxth	r3, r3
 800fa4e:	73bb      	strb	r3, [r7, #14]

        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
 800fa50:	7bfa      	ldrb	r2, [r7, #15]
 800fa52:	7bbb      	ldrb	r3, [r7, #14]
 800fa54:	4053      	eors	r3, r2
 800fa56:	b2db      	uxtb	r3, r3
 800fa58:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800fa5c:	2b00      	cmp	r3, #0
 800fa5e:	d10a      	bne.n	800fa76 <_lv_style_set_opa+0x5e>
            _lv_memcpy_small(style->map + id + sizeof(lv_style_property_t), &opa, sizeof(lv_opa_t));
 800fa60:	687b      	ldr	r3, [r7, #4]
 800fa62:	681a      	ldr	r2, [r3, #0]
 800fa64:	693b      	ldr	r3, [r7, #16]
 800fa66:	3302      	adds	r3, #2
 800fa68:	4413      	add	r3, r2
 800fa6a:	1c79      	adds	r1, r7, #1
 800fa6c:	2201      	movs	r2, #1
 800fa6e:	4618      	mov	r0, r3
 800fa70:	f7ff fb18 	bl	800f0a4 <_lv_memcpy_small>
            return;
 800fa74:	e05b      	b.n	800fb2e <_lv_style_set_opa+0x116>
        }
    }

    /*Add new property if not exists yet*/
    uint8_t new_prop_size = (sizeof(lv_style_property_t) + sizeof(lv_opa_t));
 800fa76:	2303      	movs	r3, #3
 800fa78:	737b      	strb	r3, [r7, #13]
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
 800fa7a:	23ff      	movs	r3, #255	; 0xff
 800fa7c:	817b      	strh	r3, [r7, #10]
    uint8_t end_mark_size = sizeof(end_mark);
 800fa7e:	2302      	movs	r3, #2
 800fa80:	733b      	strb	r3, [r7, #12]

    uint16_t size = _lv_style_get_mem_size(style);
 800fa82:	6878      	ldr	r0, [r7, #4]
 800fa84:	f7ff fe83 	bl	800f78e <_lv_style_get_mem_size>
 800fa88:	4603      	mov	r3, r0
 800fa8a:	82fb      	strh	r3, [r7, #22]
    if(size == 0) size += end_mark_size;
 800fa8c:	8afb      	ldrh	r3, [r7, #22]
 800fa8e:	2b00      	cmp	r3, #0
 800fa90:	d104      	bne.n	800fa9c <_lv_style_set_opa+0x84>
 800fa92:	7b3b      	ldrb	r3, [r7, #12]
 800fa94:	b29a      	uxth	r2, r3
 800fa96:	8afb      	ldrh	r3, [r7, #22]
 800fa98:	4413      	add	r3, r2
 800fa9a:	82fb      	strh	r3, [r7, #22]

    size += sizeof(lv_style_property_t) + sizeof(lv_opa_t);
 800fa9c:	8afb      	ldrh	r3, [r7, #22]
 800fa9e:	3303      	adds	r3, #3
 800faa0:	82fb      	strh	r3, [r7, #22]
    style_resize(style, size);
 800faa2:	8afb      	ldrh	r3, [r7, #22]
 800faa4:	4619      	mov	r1, r3
 800faa6:	6878      	ldr	r0, [r7, #4]
 800faa8:	f000 fd1a 	bl	80104e0 <style_resize>
    LV_ASSERT_MEM(style->map);
 800faac:	687b      	ldr	r3, [r7, #4]
 800faae:	681b      	ldr	r3, [r3, #0]
 800fab0:	4618      	mov	r0, r3
 800fab2:	f010 fb1d 	bl	80200f0 <lv_debug_check_null>
 800fab6:	4603      	mov	r3, r0
 800fab8:	f083 0301 	eor.w	r3, r3, #1
 800fabc:	b2db      	uxtb	r3, r3
 800fabe:	2b00      	cmp	r3, #0
 800fac0:	d00b      	beq.n	800fada <_lv_style_set_opa+0xc2>
 800fac2:	687b      	ldr	r3, [r7, #4]
 800fac4:	681b      	ldr	r3, [r3, #0]
 800fac6:	461a      	mov	r2, r3
 800fac8:	2300      	movs	r3, #0
 800faca:	4614      	mov	r4, r2
 800facc:	461d      	mov	r5, r3
 800face:	4622      	mov	r2, r4
 800fad0:	462b      	mov	r3, r5
 800fad2:	4818      	ldr	r0, [pc, #96]	; (800fb34 <_lv_style_set_opa+0x11c>)
 800fad4:	f010 fb1c 	bl	8020110 <lv_debug_log_error>
 800fad8:	e7fe      	b.n	800fad8 <_lv_style_set_opa+0xc0>
    if(style == NULL) return;
 800fada:	687b      	ldr	r3, [r7, #4]
 800fadc:	2b00      	cmp	r3, #0
 800fade:	d025      	beq.n	800fb2c <_lv_style_set_opa+0x114>

    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
 800fae0:	687b      	ldr	r3, [r7, #4]
 800fae2:	681a      	ldr	r2, [r3, #0]
 800fae4:	8af9      	ldrh	r1, [r7, #22]
 800fae6:	7b7b      	ldrb	r3, [r7, #13]
 800fae8:	1ac9      	subs	r1, r1, r3
 800faea:	7b3b      	ldrb	r3, [r7, #12]
 800faec:	1acb      	subs	r3, r1, r3
 800faee:	4413      	add	r3, r2
 800faf0:	1cb9      	adds	r1, r7, #2
 800faf2:	2202      	movs	r2, #2
 800faf4:	4618      	mov	r0, r3
 800faf6:	f7ff fad5 	bl	800f0a4 <_lv_memcpy_small>
    _lv_memcpy_small(style->map + size - sizeof(lv_opa_t) - end_mark_size, &opa, sizeof(lv_opa_t));
 800fafa:	687b      	ldr	r3, [r7, #4]
 800fafc:	681a      	ldr	r2, [r3, #0]
 800fafe:	8af9      	ldrh	r1, [r7, #22]
 800fb00:	7b3b      	ldrb	r3, [r7, #12]
 800fb02:	1acb      	subs	r3, r1, r3
 800fb04:	3b01      	subs	r3, #1
 800fb06:	4413      	add	r3, r2
 800fb08:	1c79      	adds	r1, r7, #1
 800fb0a:	2201      	movs	r2, #1
 800fb0c:	4618      	mov	r0, r3
 800fb0e:	f7ff fac9 	bl	800f0a4 <_lv_memcpy_small>
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
 800fb12:	687b      	ldr	r3, [r7, #4]
 800fb14:	681a      	ldr	r2, [r3, #0]
 800fb16:	8af9      	ldrh	r1, [r7, #22]
 800fb18:	7b3b      	ldrb	r3, [r7, #12]
 800fb1a:	1acb      	subs	r3, r1, r3
 800fb1c:	4413      	add	r3, r2
 800fb1e:	f107 010a 	add.w	r1, r7, #10
 800fb22:	2202      	movs	r2, #2
 800fb24:	4618      	mov	r0, r3
 800fb26:	f7ff fabd 	bl	800f0a4 <_lv_memcpy_small>
 800fb2a:	e000      	b.n	800fb2e <_lv_style_set_opa+0x116>
    if(style == NULL) return;
 800fb2c:	bf00      	nop
}
 800fb2e:	3718      	adds	r7, #24
 800fb30:	46bd      	mov	sp, r7
 800fb32:	bdb0      	pop	{r4, r5, r7, pc}
 800fb34:	0802e448 	.word	0x0802e448

0800fb38 <_lv_style_set_ptr>:
 * @note shouldn't be used directly. Use the specific property set functions instead.
 *       For example: `lv_style_set_border_width()`
 * @note for performance reasons it's not checked if the property is really has pointer type
 */
void _lv_style_set_ptr(lv_style_t * style, lv_style_property_t prop, const void * p)
{
 800fb38:	b5b0      	push	{r4, r5, r7, lr}
 800fb3a:	b088      	sub	sp, #32
 800fb3c:	af00      	add	r7, sp, #0
 800fb3e:	60f8      	str	r0, [r7, #12]
 800fb40:	460b      	mov	r3, r1
 800fb42:	607a      	str	r2, [r7, #4]
 800fb44:	817b      	strh	r3, [r7, #10]
    LV_ASSERT_STYLE(style);

    int32_t id = get_property_index(style, prop);
 800fb46:	897b      	ldrh	r3, [r7, #10]
 800fb48:	4619      	mov	r1, r3
 800fb4a:	68f8      	ldr	r0, [r7, #12]
 800fb4c:	f000 fc26 	bl	801039c <get_property_index>
 800fb50:	61b8      	str	r0, [r7, #24]
    /*The property already exists but not sure it's state is the same*/
    if(id >= 0) {
 800fb52:	69bb      	ldr	r3, [r7, #24]
 800fb54:	2b00      	cmp	r3, #0
 800fb56:	db1d      	blt.n	800fb94 <_lv_style_set_ptr+0x5c>
        lv_style_attr_t attr_found;
        lv_style_attr_t attr_goal;

        attr_found = get_style_prop_attr(style, id);
 800fb58:	69bb      	ldr	r3, [r7, #24]
 800fb5a:	4619      	mov	r1, r3
 800fb5c:	68f8      	ldr	r0, [r7, #12]
 800fb5e:	f000 fcff 	bl	8010560 <get_style_prop_attr>
 800fb62:	4603      	mov	r3, r0
 800fb64:	75fb      	strb	r3, [r7, #23]
        attr_goal = (prop >> 8) & 0xFFU;
 800fb66:	897b      	ldrh	r3, [r7, #10]
 800fb68:	0a1b      	lsrs	r3, r3, #8
 800fb6a:	b29b      	uxth	r3, r3
 800fb6c:	75bb      	strb	r3, [r7, #22]

        if(LV_STYLE_ATTR_GET_STATE(attr_found) == LV_STYLE_ATTR_GET_STATE(attr_goal)) {
 800fb6e:	7dfa      	ldrb	r2, [r7, #23]
 800fb70:	7dbb      	ldrb	r3, [r7, #22]
 800fb72:	4053      	eors	r3, r2
 800fb74:	b2db      	uxtb	r3, r3
 800fb76:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800fb7a:	2b00      	cmp	r3, #0
 800fb7c:	d10a      	bne.n	800fb94 <_lv_style_set_ptr+0x5c>
            _lv_memcpy_small(style->map + id + sizeof(lv_style_property_t), &p, sizeof(const void *));
 800fb7e:	68fb      	ldr	r3, [r7, #12]
 800fb80:	681a      	ldr	r2, [r3, #0]
 800fb82:	69bb      	ldr	r3, [r7, #24]
 800fb84:	3302      	adds	r3, #2
 800fb86:	4413      	add	r3, r2
 800fb88:	1d39      	adds	r1, r7, #4
 800fb8a:	2204      	movs	r2, #4
 800fb8c:	4618      	mov	r0, r3
 800fb8e:	f7ff fa89 	bl	800f0a4 <_lv_memcpy_small>
            return;
 800fb92:	e05c      	b.n	800fc4e <_lv_style_set_ptr+0x116>
        }
    }

    /*Add new property if not exists yet*/
    uint8_t new_prop_size = (sizeof(lv_style_property_t) + sizeof(const void *));
 800fb94:	2306      	movs	r3, #6
 800fb96:	757b      	strb	r3, [r7, #21]
    lv_style_property_t end_mark = _LV_STYLE_CLOSEING_PROP;
 800fb98:	23ff      	movs	r3, #255	; 0xff
 800fb9a:	827b      	strh	r3, [r7, #18]
    uint8_t end_mark_size = sizeof(end_mark);
 800fb9c:	2302      	movs	r3, #2
 800fb9e:	753b      	strb	r3, [r7, #20]

    uint16_t size = _lv_style_get_mem_size(style);
 800fba0:	68f8      	ldr	r0, [r7, #12]
 800fba2:	f7ff fdf4 	bl	800f78e <_lv_style_get_mem_size>
 800fba6:	4603      	mov	r3, r0
 800fba8:	83fb      	strh	r3, [r7, #30]
    if(size == 0) size += end_mark_size;
 800fbaa:	8bfb      	ldrh	r3, [r7, #30]
 800fbac:	2b00      	cmp	r3, #0
 800fbae:	d104      	bne.n	800fbba <_lv_style_set_ptr+0x82>
 800fbb0:	7d3b      	ldrb	r3, [r7, #20]
 800fbb2:	b29a      	uxth	r2, r3
 800fbb4:	8bfb      	ldrh	r3, [r7, #30]
 800fbb6:	4413      	add	r3, r2
 800fbb8:	83fb      	strh	r3, [r7, #30]

    size += sizeof(lv_style_property_t) + sizeof(const void *);
 800fbba:	8bfb      	ldrh	r3, [r7, #30]
 800fbbc:	3306      	adds	r3, #6
 800fbbe:	83fb      	strh	r3, [r7, #30]
    style_resize(style, size);
 800fbc0:	8bfb      	ldrh	r3, [r7, #30]
 800fbc2:	4619      	mov	r1, r3
 800fbc4:	68f8      	ldr	r0, [r7, #12]
 800fbc6:	f000 fc8b 	bl	80104e0 <style_resize>
    LV_ASSERT_MEM(style->map);
 800fbca:	68fb      	ldr	r3, [r7, #12]
 800fbcc:	681b      	ldr	r3, [r3, #0]
 800fbce:	4618      	mov	r0, r3
 800fbd0:	f010 fa8e 	bl	80200f0 <lv_debug_check_null>
 800fbd4:	4603      	mov	r3, r0
 800fbd6:	f083 0301 	eor.w	r3, r3, #1
 800fbda:	b2db      	uxtb	r3, r3
 800fbdc:	2b00      	cmp	r3, #0
 800fbde:	d00b      	beq.n	800fbf8 <_lv_style_set_ptr+0xc0>
 800fbe0:	68fb      	ldr	r3, [r7, #12]
 800fbe2:	681b      	ldr	r3, [r3, #0]
 800fbe4:	461a      	mov	r2, r3
 800fbe6:	2300      	movs	r3, #0
 800fbe8:	4614      	mov	r4, r2
 800fbea:	461d      	mov	r5, r3
 800fbec:	4622      	mov	r2, r4
 800fbee:	462b      	mov	r3, r5
 800fbf0:	4818      	ldr	r0, [pc, #96]	; (800fc54 <_lv_style_set_ptr+0x11c>)
 800fbf2:	f010 fa8d 	bl	8020110 <lv_debug_log_error>
 800fbf6:	e7fe      	b.n	800fbf6 <_lv_style_set_ptr+0xbe>
    if(style == NULL) return;
 800fbf8:	68fb      	ldr	r3, [r7, #12]
 800fbfa:	2b00      	cmp	r3, #0
 800fbfc:	d026      	beq.n	800fc4c <_lv_style_set_ptr+0x114>

    _lv_memcpy_small(style->map + size - new_prop_size - end_mark_size, &prop, sizeof(lv_style_property_t));
 800fbfe:	68fb      	ldr	r3, [r7, #12]
 800fc00:	681a      	ldr	r2, [r3, #0]
 800fc02:	8bf9      	ldrh	r1, [r7, #30]
 800fc04:	7d7b      	ldrb	r3, [r7, #21]
 800fc06:	1ac9      	subs	r1, r1, r3
 800fc08:	7d3b      	ldrb	r3, [r7, #20]
 800fc0a:	1acb      	subs	r3, r1, r3
 800fc0c:	4413      	add	r3, r2
 800fc0e:	f107 010a 	add.w	r1, r7, #10
 800fc12:	2202      	movs	r2, #2
 800fc14:	4618      	mov	r0, r3
 800fc16:	f7ff fa45 	bl	800f0a4 <_lv_memcpy_small>
    _lv_memcpy_small(style->map + size - sizeof(const void *) - end_mark_size, &p, sizeof(const void *));
 800fc1a:	68fb      	ldr	r3, [r7, #12]
 800fc1c:	681a      	ldr	r2, [r3, #0]
 800fc1e:	8bf9      	ldrh	r1, [r7, #30]
 800fc20:	7d3b      	ldrb	r3, [r7, #20]
 800fc22:	1acb      	subs	r3, r1, r3
 800fc24:	3b04      	subs	r3, #4
 800fc26:	4413      	add	r3, r2
 800fc28:	1d39      	adds	r1, r7, #4
 800fc2a:	2204      	movs	r2, #4
 800fc2c:	4618      	mov	r0, r3
 800fc2e:	f7ff fa39 	bl	800f0a4 <_lv_memcpy_small>
    _lv_memcpy_small(style->map + size - end_mark_size, &end_mark, sizeof(end_mark));
 800fc32:	68fb      	ldr	r3, [r7, #12]
 800fc34:	681a      	ldr	r2, [r3, #0]
 800fc36:	8bf9      	ldrh	r1, [r7, #30]
 800fc38:	7d3b      	ldrb	r3, [r7, #20]
 800fc3a:	1acb      	subs	r3, r1, r3
 800fc3c:	4413      	add	r3, r2
 800fc3e:	f107 0112 	add.w	r1, r7, #18
 800fc42:	2202      	movs	r2, #2
 800fc44:	4618      	mov	r0, r3
 800fc46:	f7ff fa2d 	bl	800f0a4 <_lv_memcpy_small>
 800fc4a:	e000      	b.n	800fc4e <_lv_style_set_ptr+0x116>
    if(style == NULL) return;
 800fc4c:	bf00      	nop
}
 800fc4e:	3720      	adds	r7, #32
 800fc50:	46bd      	mov	sp, r7
 800fc52:	bdb0      	pop	{r4, r5, r7, pc}
 800fc54:	0802e448 	.word	0x0802e448

0800fc58 <_lv_style_get_int>:
 * @return the weight of the found property (how well it fits to the style state).
 *         Higher number is means better fit
 *         -1 if the not found (`res` will be undefined)
 */
int16_t _lv_style_get_int(const lv_style_t * style, lv_style_property_t prop, void * v_res)
{
 800fc58:	b580      	push	{r7, lr}
 800fc5a:	b088      	sub	sp, #32
 800fc5c:	af00      	add	r7, sp, #0
 800fc5e:	60f8      	str	r0, [r7, #12]
 800fc60:	460b      	mov	r3, r1
 800fc62:	607a      	str	r2, [r7, #4]
 800fc64:	817b      	strh	r3, [r7, #10]
    lv_style_int_t * res = (lv_style_int_t *)v_res;
 800fc66:	687b      	ldr	r3, [r7, #4]
 800fc68:	61fb      	str	r3, [r7, #28]
    LV_ASSERT_STYLE(style);

    if(style == NULL) return -1;
 800fc6a:	68fb      	ldr	r3, [r7, #12]
 800fc6c:	2b00      	cmp	r3, #0
 800fc6e:	d102      	bne.n	800fc76 <_lv_style_get_int+0x1e>
 800fc70:	f04f 33ff 	mov.w	r3, #4294967295
 800fc74:	e030      	b.n	800fcd8 <_lv_style_get_int+0x80>
    if(style->map == NULL) return -1;
 800fc76:	68fb      	ldr	r3, [r7, #12]
 800fc78:	681b      	ldr	r3, [r3, #0]
 800fc7a:	2b00      	cmp	r3, #0
 800fc7c:	d102      	bne.n	800fc84 <_lv_style_get_int+0x2c>
 800fc7e:	f04f 33ff 	mov.w	r3, #4294967295
 800fc82:	e029      	b.n	800fcd8 <_lv_style_get_int+0x80>

    int32_t id = get_property_index(style, prop);
 800fc84:	897b      	ldrh	r3, [r7, #10]
 800fc86:	4619      	mov	r1, r3
 800fc88:	68f8      	ldr	r0, [r7, #12]
 800fc8a:	f000 fb87 	bl	801039c <get_property_index>
 800fc8e:	61b8      	str	r0, [r7, #24]
    if(id < 0) {
 800fc90:	69bb      	ldr	r3, [r7, #24]
 800fc92:	2b00      	cmp	r3, #0
 800fc94:	da02      	bge.n	800fc9c <_lv_style_get_int+0x44>
        return -1;
 800fc96:	f04f 33ff 	mov.w	r3, #4294967295
 800fc9a:	e01d      	b.n	800fcd8 <_lv_style_get_int+0x80>
    }
    else {
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_style_int_t));
 800fc9c:	68fb      	ldr	r3, [r7, #12]
 800fc9e:	681a      	ldr	r2, [r3, #0]
 800fca0:	69bb      	ldr	r3, [r7, #24]
 800fca2:	3302      	adds	r3, #2
 800fca4:	4413      	add	r3, r2
 800fca6:	2202      	movs	r2, #2
 800fca8:	4619      	mov	r1, r3
 800fcaa:	69f8      	ldr	r0, [r7, #28]
 800fcac:	f7ff f9fa 	bl	800f0a4 <_lv_memcpy_small>
        lv_style_attr_t attr_act;
        attr_act = get_style_prop_attr(style, id);
 800fcb0:	69bb      	ldr	r3, [r7, #24]
 800fcb2:	4619      	mov	r1, r3
 800fcb4:	68f8      	ldr	r0, [r7, #12]
 800fcb6:	f000 fc53 	bl	8010560 <get_style_prop_attr>
 800fcba:	4603      	mov	r3, r0
 800fcbc:	75fb      	strb	r3, [r7, #23]

        lv_style_attr_t attr_goal;
        attr_goal = (prop >> 8) & 0xFF;
 800fcbe:	897b      	ldrh	r3, [r7, #10]
 800fcc0:	0a1b      	lsrs	r3, r3, #8
 800fcc2:	b29b      	uxth	r3, r3
 800fcc4:	75bb      	strb	r3, [r7, #22]

        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);
 800fcc6:	7dfb      	ldrb	r3, [r7, #23]
 800fcc8:	b21b      	sxth	r3, r3
 800fcca:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800fcce:	b21a      	sxth	r2, r3
 800fcd0:	7dbb      	ldrb	r3, [r7, #22]
 800fcd2:	b21b      	sxth	r3, r3
 800fcd4:	4013      	ands	r3, r2
 800fcd6:	b21b      	sxth	r3, r3
    }
}
 800fcd8:	4618      	mov	r0, r3
 800fcda:	3720      	adds	r7, #32
 800fcdc:	46bd      	mov	sp, r7
 800fcde:	bd80      	pop	{r7, pc}

0800fce0 <_lv_style_get_opa>:
 * @note shouldn't be used directly. Use the specific property get functions instead.
 *       For example: `lv_style_get_border_opa()`
 * @note for performance reasons it's not checked if the property really has opacity type
 */
int16_t _lv_style_get_opa(const lv_style_t * style, lv_style_property_t prop, void * v_res)
{
 800fce0:	b580      	push	{r7, lr}
 800fce2:	b088      	sub	sp, #32
 800fce4:	af00      	add	r7, sp, #0
 800fce6:	60f8      	str	r0, [r7, #12]
 800fce8:	460b      	mov	r3, r1
 800fcea:	607a      	str	r2, [r7, #4]
 800fcec:	817b      	strh	r3, [r7, #10]
    lv_opa_t * res = (lv_opa_t *)v_res;
 800fcee:	687b      	ldr	r3, [r7, #4]
 800fcf0:	61fb      	str	r3, [r7, #28]
    LV_ASSERT_STYLE(style);

    if(style == NULL) return -1;
 800fcf2:	68fb      	ldr	r3, [r7, #12]
 800fcf4:	2b00      	cmp	r3, #0
 800fcf6:	d102      	bne.n	800fcfe <_lv_style_get_opa+0x1e>
 800fcf8:	f04f 33ff 	mov.w	r3, #4294967295
 800fcfc:	e030      	b.n	800fd60 <_lv_style_get_opa+0x80>
    if(style->map == NULL) return -1;
 800fcfe:	68fb      	ldr	r3, [r7, #12]
 800fd00:	681b      	ldr	r3, [r3, #0]
 800fd02:	2b00      	cmp	r3, #0
 800fd04:	d102      	bne.n	800fd0c <_lv_style_get_opa+0x2c>
 800fd06:	f04f 33ff 	mov.w	r3, #4294967295
 800fd0a:	e029      	b.n	800fd60 <_lv_style_get_opa+0x80>

    int32_t id = get_property_index(style, prop);
 800fd0c:	897b      	ldrh	r3, [r7, #10]
 800fd0e:	4619      	mov	r1, r3
 800fd10:	68f8      	ldr	r0, [r7, #12]
 800fd12:	f000 fb43 	bl	801039c <get_property_index>
 800fd16:	61b8      	str	r0, [r7, #24]
    if(id < 0) {
 800fd18:	69bb      	ldr	r3, [r7, #24]
 800fd1a:	2b00      	cmp	r3, #0
 800fd1c:	da02      	bge.n	800fd24 <_lv_style_get_opa+0x44>
        return -1;
 800fd1e:	f04f 33ff 	mov.w	r3, #4294967295
 800fd22:	e01d      	b.n	800fd60 <_lv_style_get_opa+0x80>
    }
    else {
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_opa_t));
 800fd24:	68fb      	ldr	r3, [r7, #12]
 800fd26:	681a      	ldr	r2, [r3, #0]
 800fd28:	69bb      	ldr	r3, [r7, #24]
 800fd2a:	3302      	adds	r3, #2
 800fd2c:	4413      	add	r3, r2
 800fd2e:	2201      	movs	r2, #1
 800fd30:	4619      	mov	r1, r3
 800fd32:	69f8      	ldr	r0, [r7, #28]
 800fd34:	f7ff f9b6 	bl	800f0a4 <_lv_memcpy_small>
        lv_style_attr_t attr_act;
        attr_act = get_style_prop_attr(style, id);
 800fd38:	69bb      	ldr	r3, [r7, #24]
 800fd3a:	4619      	mov	r1, r3
 800fd3c:	68f8      	ldr	r0, [r7, #12]
 800fd3e:	f000 fc0f 	bl	8010560 <get_style_prop_attr>
 800fd42:	4603      	mov	r3, r0
 800fd44:	75fb      	strb	r3, [r7, #23]

        lv_style_attr_t attr_goal;
        attr_goal = (prop >> 8) & 0xFF;
 800fd46:	897b      	ldrh	r3, [r7, #10]
 800fd48:	0a1b      	lsrs	r3, r3, #8
 800fd4a:	b29b      	uxth	r3, r3
 800fd4c:	75bb      	strb	r3, [r7, #22]

        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);
 800fd4e:	7dfb      	ldrb	r3, [r7, #23]
 800fd50:	b21b      	sxth	r3, r3
 800fd52:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800fd56:	b21a      	sxth	r2, r3
 800fd58:	7dbb      	ldrb	r3, [r7, #22]
 800fd5a:	b21b      	sxth	r3, r3
 800fd5c:	4013      	ands	r3, r2
 800fd5e:	b21b      	sxth	r3, r3
    }
}
 800fd60:	4618      	mov	r0, r3
 800fd62:	3720      	adds	r7, #32
 800fd64:	46bd      	mov	sp, r7
 800fd66:	bd80      	pop	{r7, pc}

0800fd68 <_lv_style_get_color>:
 * @note shouldn't be used directly. Use the specific property get functions instead.
 *       For example: `lv_style_get_border_color()`
 * @note for performance reasons it's not checked if the property really has color type
 */
int16_t _lv_style_get_color(const lv_style_t * style, lv_style_property_t prop, void * v_res)
{
 800fd68:	b580      	push	{r7, lr}
 800fd6a:	b088      	sub	sp, #32
 800fd6c:	af00      	add	r7, sp, #0
 800fd6e:	60f8      	str	r0, [r7, #12]
 800fd70:	460b      	mov	r3, r1
 800fd72:	607a      	str	r2, [r7, #4]
 800fd74:	817b      	strh	r3, [r7, #10]
    lv_color_t * res = (lv_color_t *)v_res;
 800fd76:	687b      	ldr	r3, [r7, #4]
 800fd78:	61fb      	str	r3, [r7, #28]
    if(style == NULL) return -1;
 800fd7a:	68fb      	ldr	r3, [r7, #12]
 800fd7c:	2b00      	cmp	r3, #0
 800fd7e:	d102      	bne.n	800fd86 <_lv_style_get_color+0x1e>
 800fd80:	f04f 33ff 	mov.w	r3, #4294967295
 800fd84:	e030      	b.n	800fde8 <_lv_style_get_color+0x80>
    if(style->map == NULL) return -1;
 800fd86:	68fb      	ldr	r3, [r7, #12]
 800fd88:	681b      	ldr	r3, [r3, #0]
 800fd8a:	2b00      	cmp	r3, #0
 800fd8c:	d102      	bne.n	800fd94 <_lv_style_get_color+0x2c>
 800fd8e:	f04f 33ff 	mov.w	r3, #4294967295
 800fd92:	e029      	b.n	800fde8 <_lv_style_get_color+0x80>
    int32_t id = get_property_index(style, prop);
 800fd94:	897b      	ldrh	r3, [r7, #10]
 800fd96:	4619      	mov	r1, r3
 800fd98:	68f8      	ldr	r0, [r7, #12]
 800fd9a:	f000 faff 	bl	801039c <get_property_index>
 800fd9e:	61b8      	str	r0, [r7, #24]
    if(id < 0) {
 800fda0:	69bb      	ldr	r3, [r7, #24]
 800fda2:	2b00      	cmp	r3, #0
 800fda4:	da02      	bge.n	800fdac <_lv_style_get_color+0x44>
        return -1;
 800fda6:	f04f 33ff 	mov.w	r3, #4294967295
 800fdaa:	e01d      	b.n	800fde8 <_lv_style_get_color+0x80>
    }
    else {
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(lv_color_t));
 800fdac:	68fb      	ldr	r3, [r7, #12]
 800fdae:	681a      	ldr	r2, [r3, #0]
 800fdb0:	69bb      	ldr	r3, [r7, #24]
 800fdb2:	3302      	adds	r3, #2
 800fdb4:	4413      	add	r3, r2
 800fdb6:	2202      	movs	r2, #2
 800fdb8:	4619      	mov	r1, r3
 800fdba:	69f8      	ldr	r0, [r7, #28]
 800fdbc:	f7ff f972 	bl	800f0a4 <_lv_memcpy_small>
        lv_style_attr_t attr_act;
        attr_act = get_style_prop_attr(style, id);
 800fdc0:	69bb      	ldr	r3, [r7, #24]
 800fdc2:	4619      	mov	r1, r3
 800fdc4:	68f8      	ldr	r0, [r7, #12]
 800fdc6:	f000 fbcb 	bl	8010560 <get_style_prop_attr>
 800fdca:	4603      	mov	r3, r0
 800fdcc:	75fb      	strb	r3, [r7, #23]

        lv_style_attr_t attr_goal;
        attr_goal = (prop >> 8) & 0xFF;
 800fdce:	897b      	ldrh	r3, [r7, #10]
 800fdd0:	0a1b      	lsrs	r3, r3, #8
 800fdd2:	b29b      	uxth	r3, r3
 800fdd4:	75bb      	strb	r3, [r7, #22]

        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);
 800fdd6:	7dfb      	ldrb	r3, [r7, #23]
 800fdd8:	b21b      	sxth	r3, r3
 800fdda:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800fdde:	b21a      	sxth	r2, r3
 800fde0:	7dbb      	ldrb	r3, [r7, #22]
 800fde2:	b21b      	sxth	r3, r3
 800fde4:	4013      	ands	r3, r2
 800fde6:	b21b      	sxth	r3, r3
    }
}
 800fde8:	4618      	mov	r0, r3
 800fdea:	3720      	adds	r7, #32
 800fdec:	46bd      	mov	sp, r7
 800fdee:	bd80      	pop	{r7, pc}

0800fdf0 <_lv_style_get_ptr>:
 * @note shouldn't be used directly. Use the specific property get functions instead.
 *       For example: `lv_style_get_text_font()`
 * @note for performance reasons it's not checked if the property really has pointer type
 */
int16_t _lv_style_get_ptr(const lv_style_t * style, lv_style_property_t prop, void * v_res)
{
 800fdf0:	b580      	push	{r7, lr}
 800fdf2:	b088      	sub	sp, #32
 800fdf4:	af00      	add	r7, sp, #0
 800fdf6:	60f8      	str	r0, [r7, #12]
 800fdf8:	460b      	mov	r3, r1
 800fdfa:	607a      	str	r2, [r7, #4]
 800fdfc:	817b      	strh	r3, [r7, #10]
    const void ** res = (const void **)v_res;
 800fdfe:	687b      	ldr	r3, [r7, #4]
 800fe00:	61fb      	str	r3, [r7, #28]
    if(style == NULL) return -1;
 800fe02:	68fb      	ldr	r3, [r7, #12]
 800fe04:	2b00      	cmp	r3, #0
 800fe06:	d102      	bne.n	800fe0e <_lv_style_get_ptr+0x1e>
 800fe08:	f04f 33ff 	mov.w	r3, #4294967295
 800fe0c:	e030      	b.n	800fe70 <_lv_style_get_ptr+0x80>
    if(style->map == NULL) return -1;
 800fe0e:	68fb      	ldr	r3, [r7, #12]
 800fe10:	681b      	ldr	r3, [r3, #0]
 800fe12:	2b00      	cmp	r3, #0
 800fe14:	d102      	bne.n	800fe1c <_lv_style_get_ptr+0x2c>
 800fe16:	f04f 33ff 	mov.w	r3, #4294967295
 800fe1a:	e029      	b.n	800fe70 <_lv_style_get_ptr+0x80>

    int32_t id = get_property_index(style, prop);
 800fe1c:	897b      	ldrh	r3, [r7, #10]
 800fe1e:	4619      	mov	r1, r3
 800fe20:	68f8      	ldr	r0, [r7, #12]
 800fe22:	f000 fabb 	bl	801039c <get_property_index>
 800fe26:	61b8      	str	r0, [r7, #24]
    if(id < 0) {
 800fe28:	69bb      	ldr	r3, [r7, #24]
 800fe2a:	2b00      	cmp	r3, #0
 800fe2c:	da02      	bge.n	800fe34 <_lv_style_get_ptr+0x44>
        return -1;
 800fe2e:	f04f 33ff 	mov.w	r3, #4294967295
 800fe32:	e01d      	b.n	800fe70 <_lv_style_get_ptr+0x80>
    }
    else {
        _lv_memcpy_small(res, &style->map[id + sizeof(lv_style_property_t)], sizeof(const void *));
 800fe34:	68fb      	ldr	r3, [r7, #12]
 800fe36:	681a      	ldr	r2, [r3, #0]
 800fe38:	69bb      	ldr	r3, [r7, #24]
 800fe3a:	3302      	adds	r3, #2
 800fe3c:	4413      	add	r3, r2
 800fe3e:	2204      	movs	r2, #4
 800fe40:	4619      	mov	r1, r3
 800fe42:	69f8      	ldr	r0, [r7, #28]
 800fe44:	f7ff f92e 	bl	800f0a4 <_lv_memcpy_small>
        lv_style_attr_t attr_act;
        attr_act = get_style_prop_attr(style, id);
 800fe48:	69bb      	ldr	r3, [r7, #24]
 800fe4a:	4619      	mov	r1, r3
 800fe4c:	68f8      	ldr	r0, [r7, #12]
 800fe4e:	f000 fb87 	bl	8010560 <get_style_prop_attr>
 800fe52:	4603      	mov	r3, r0
 800fe54:	75fb      	strb	r3, [r7, #23]

        lv_style_attr_t attr_goal;
        attr_goal = (prop >> 8) & 0xFF;
 800fe56:	897b      	ldrh	r3, [r7, #10]
 800fe58:	0a1b      	lsrs	r3, r3, #8
 800fe5a:	b29b      	uxth	r3, r3
 800fe5c:	75bb      	strb	r3, [r7, #22]

        return LV_STYLE_ATTR_GET_STATE(attr_act) & LV_STYLE_ATTR_GET_STATE(attr_goal);
 800fe5e:	7dfb      	ldrb	r3, [r7, #23]
 800fe60:	b21b      	sxth	r3, r3
 800fe62:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800fe66:	b21a      	sxth	r2, r3
 800fe68:	7dbb      	ldrb	r3, [r7, #22]
 800fe6a:	b21b      	sxth	r3, r3
 800fe6c:	4013      	ands	r3, r2
 800fe6e:	b21b      	sxth	r3, r3
    }
}
 800fe70:	4618      	mov	r0, r3
 800fe72:	3720      	adds	r7, #32
 800fe74:	46bd      	mov	sp, r7
 800fe76:	bd80      	pop	{r7, pc}

0800fe78 <lv_style_list_get_local_style>:
 * Get the local style of a style list
 * @param list pointer to a style list where the local property should be set
 * @return pointer to the local style if exists else `NULL`.
 */
lv_style_t * lv_style_list_get_local_style(lv_style_list_t * list)
{
 800fe78:	b480      	push	{r7}
 800fe7a:	b083      	sub	sp, #12
 800fe7c:	af00      	add	r7, sp, #0
 800fe7e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_STYLE_LIST(list);

    if(!list->has_local) return NULL;
 800fe80:	687b      	ldr	r3, [r7, #4]
 800fe82:	791b      	ldrb	r3, [r3, #4]
 800fe84:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800fe88:	b2db      	uxtb	r3, r3
 800fe8a:	2b00      	cmp	r3, #0
 800fe8c:	d101      	bne.n	800fe92 <lv_style_list_get_local_style+0x1a>
 800fe8e:	2300      	movs	r3, #0
 800fe90:	e00d      	b.n	800feae <lv_style_list_get_local_style+0x36>
    if(list->has_trans) return list->style_list[1];
 800fe92:	687b      	ldr	r3, [r7, #4]
 800fe94:	791b      	ldrb	r3, [r3, #4]
 800fe96:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800fe9a:	b2db      	uxtb	r3, r3
 800fe9c:	2b00      	cmp	r3, #0
 800fe9e:	d003      	beq.n	800fea8 <lv_style_list_get_local_style+0x30>
 800fea0:	687b      	ldr	r3, [r7, #4]
 800fea2:	681b      	ldr	r3, [r3, #0]
 800fea4:	685b      	ldr	r3, [r3, #4]
 800fea6:	e002      	b.n	800feae <lv_style_list_get_local_style+0x36>
    else return list->style_list[0];
 800fea8:	687b      	ldr	r3, [r7, #4]
 800feaa:	681b      	ldr	r3, [r3, #0]
 800feac:	681b      	ldr	r3, [r3, #0]
}
 800feae:	4618      	mov	r0, r3
 800feb0:	370c      	adds	r7, #12
 800feb2:	46bd      	mov	sp, r7
 800feb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800feb8:	4770      	bx	lr

0800feba <_lv_style_list_get_transition_style>:
 * Get the transition style of a style list
 * @param list pointer to a style list where the local property should be set
 * @return pointer to the transition style if exists else `NULL`.
 */
lv_style_t * _lv_style_list_get_transition_style(lv_style_list_t * list)
{
 800feba:	b480      	push	{r7}
 800febc:	b083      	sub	sp, #12
 800febe:	af00      	add	r7, sp, #0
 800fec0:	6078      	str	r0, [r7, #4]
    LV_ASSERT_STYLE_LIST(list);

    if(!list->has_trans) return NULL;
 800fec2:	687b      	ldr	r3, [r7, #4]
 800fec4:	791b      	ldrb	r3, [r3, #4]
 800fec6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800feca:	b2db      	uxtb	r3, r3
 800fecc:	2b00      	cmp	r3, #0
 800fece:	d101      	bne.n	800fed4 <_lv_style_list_get_transition_style+0x1a>
 800fed0:	2300      	movs	r3, #0
 800fed2:	e002      	b.n	800feda <_lv_style_list_get_transition_style+0x20>
    return list->style_list[0];
 800fed4:	687b      	ldr	r3, [r7, #4]
 800fed6:	681b      	ldr	r3, [r3, #0]
 800fed8:	681b      	ldr	r3, [r3, #0]
}
 800feda:	4618      	mov	r0, r3
 800fedc:	370c      	adds	r7, #12
 800fede:	46bd      	mov	sp, r7
 800fee0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fee4:	4770      	bx	lr
	...

0800fee8 <_lv_style_list_add_trans_style>:
 * Allocate the transition style in a style list. If already exists simply return it.
 * @param list pointer to a style list
 * @return the transition style of a style list
 */
lv_style_t * _lv_style_list_add_trans_style(lv_style_list_t * list)
{
 800fee8:	b5b0      	push	{r4, r5, r7, lr}
 800feea:	b084      	sub	sp, #16
 800feec:	af00      	add	r7, sp, #0
 800feee:	6078      	str	r0, [r7, #4]
    LV_ASSERT_STYLE_LIST(list);
    if(list->has_trans) return _lv_style_list_get_transition_style(list);
 800fef0:	687b      	ldr	r3, [r7, #4]
 800fef2:	791b      	ldrb	r3, [r3, #4]
 800fef4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800fef8:	b2db      	uxtb	r3, r3
 800fefa:	2b00      	cmp	r3, #0
 800fefc:	d004      	beq.n	800ff08 <_lv_style_list_add_trans_style+0x20>
 800fefe:	6878      	ldr	r0, [r7, #4]
 800ff00:	f7ff ffdb 	bl	800feba <_lv_style_list_get_transition_style>
 800ff04:	4603      	mov	r3, r0
 800ff06:	e03e      	b.n	800ff86 <_lv_style_list_add_trans_style+0x9e>

    lv_style_t * trans_style = lv_mem_alloc(sizeof(lv_style_t));
 800ff08:	2004      	movs	r0, #4
 800ff0a:	f010 fe63 	bl	8020bd4 <lv_mem_alloc>
 800ff0e:	60f8      	str	r0, [r7, #12]
    LV_ASSERT_MEM(trans_style);
 800ff10:	68f8      	ldr	r0, [r7, #12]
 800ff12:	f010 f8ed 	bl	80200f0 <lv_debug_check_null>
 800ff16:	4603      	mov	r3, r0
 800ff18:	f083 0301 	eor.w	r3, r3, #1
 800ff1c:	b2db      	uxtb	r3, r3
 800ff1e:	2b00      	cmp	r3, #0
 800ff20:	d009      	beq.n	800ff36 <_lv_style_list_add_trans_style+0x4e>
 800ff22:	68fb      	ldr	r3, [r7, #12]
 800ff24:	2200      	movs	r2, #0
 800ff26:	461c      	mov	r4, r3
 800ff28:	4615      	mov	r5, r2
 800ff2a:	4622      	mov	r2, r4
 800ff2c:	462b      	mov	r3, r5
 800ff2e:	4818      	ldr	r0, [pc, #96]	; (800ff90 <_lv_style_list_add_trans_style+0xa8>)
 800ff30:	f010 f8ee 	bl	8020110 <lv_debug_log_error>
 800ff34:	e7fe      	b.n	800ff34 <_lv_style_list_add_trans_style+0x4c>
    if(trans_style == NULL) {
 800ff36:	68fb      	ldr	r3, [r7, #12]
 800ff38:	2b00      	cmp	r3, #0
 800ff3a:	d101      	bne.n	800ff40 <_lv_style_list_add_trans_style+0x58>
        LV_LOG_WARN("lv_style_list_add_trans_style: couldn't create transition style");
        return NULL;
 800ff3c:	2300      	movs	r3, #0
 800ff3e:	e022      	b.n	800ff86 <_lv_style_list_add_trans_style+0x9e>
    }

    lv_style_init(trans_style);
 800ff40:	68f8      	ldr	r0, [r7, #12]
 800ff42:	f7ff f906 	bl	800f152 <lv_style_init>

    _lv_style_list_add_style(list, trans_style);
 800ff46:	68f9      	ldr	r1, [r7, #12]
 800ff48:	6878      	ldr	r0, [r7, #4]
 800ff4a:	f7ff fa75 	bl	800f438 <_lv_style_list_add_style>
    list->has_trans = 1;
 800ff4e:	687a      	ldr	r2, [r7, #4]
 800ff50:	7913      	ldrb	r3, [r2, #4]
 800ff52:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800ff56:	7113      	strb	r3, [r2, #4]

    /*If the list has local style trans was added after it. But trans should be the first so swap them*/
    if(list->has_local) {
 800ff58:	687b      	ldr	r3, [r7, #4]
 800ff5a:	791b      	ldrb	r3, [r3, #4]
 800ff5c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ff60:	b2db      	uxtb	r3, r3
 800ff62:	2b00      	cmp	r3, #0
 800ff64:	d00e      	beq.n	800ff84 <_lv_style_list_add_trans_style+0x9c>
        lv_style_t * tmp = list->style_list[0];
 800ff66:	687b      	ldr	r3, [r7, #4]
 800ff68:	681b      	ldr	r3, [r3, #0]
 800ff6a:	681b      	ldr	r3, [r3, #0]
 800ff6c:	60bb      	str	r3, [r7, #8]
        list->style_list[0] = list->style_list[1];
 800ff6e:	687b      	ldr	r3, [r7, #4]
 800ff70:	681a      	ldr	r2, [r3, #0]
 800ff72:	687b      	ldr	r3, [r7, #4]
 800ff74:	681b      	ldr	r3, [r3, #0]
 800ff76:	6852      	ldr	r2, [r2, #4]
 800ff78:	601a      	str	r2, [r3, #0]
        list->style_list[1] = tmp;
 800ff7a:	687b      	ldr	r3, [r7, #4]
 800ff7c:	681b      	ldr	r3, [r3, #0]
 800ff7e:	3304      	adds	r3, #4
 800ff80:	68ba      	ldr	r2, [r7, #8]
 800ff82:	601a      	str	r2, [r3, #0]
    }
    return trans_style;
 800ff84:	68fb      	ldr	r3, [r7, #12]
}
 800ff86:	4618      	mov	r0, r3
 800ff88:	3710      	adds	r7, #16
 800ff8a:	46bd      	mov	sp, r7
 800ff8c:	bdb0      	pop	{r4, r5, r7, pc}
 800ff8e:	bf00      	nop
 800ff90:	0802e448 	.word	0x0802e448

0800ff94 <_lv_style_list_set_local_ptr>:
 * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`
 * @param value the value to set
 * @note for performance reasons it's not checked if the property really has pointer type
 */
void _lv_style_list_set_local_ptr(lv_style_list_t * list, lv_style_property_t prop, const void * value)
{
 800ff94:	b580      	push	{r7, lr}
 800ff96:	b086      	sub	sp, #24
 800ff98:	af00      	add	r7, sp, #0
 800ff9a:	60f8      	str	r0, [r7, #12]
 800ff9c:	460b      	mov	r3, r1
 800ff9e:	607a      	str	r2, [r7, #4]
 800ffa0:	817b      	strh	r3, [r7, #10]
    LV_ASSERT_STYLE_LIST(list);

    lv_style_t * local = get_alloc_local_style(list);
 800ffa2:	68f8      	ldr	r0, [r7, #12]
 800ffa4:	f000 fa58 	bl	8010458 <get_alloc_local_style>
 800ffa8:	6178      	str	r0, [r7, #20]
    _lv_style_set_ptr(local, prop, value);
 800ffaa:	897b      	ldrh	r3, [r7, #10]
 800ffac:	687a      	ldr	r2, [r7, #4]
 800ffae:	4619      	mov	r1, r3
 800ffb0:	6978      	ldr	r0, [r7, #20]
 800ffb2:	f7ff fdc1 	bl	800fb38 <_lv_style_set_ptr>
}
 800ffb6:	bf00      	nop
 800ffb8:	3718      	adds	r7, #24
 800ffba:	46bd      	mov	sp, r7
 800ffbc:	bd80      	pop	{r7, pc}

0800ffbe <_lv_style_list_get_int>:
 * @return LV_RES_OK: there was a matching property in the list
 *         LV_RES_INV: there was NO matching property in the list
 * @note for performance reasons it's not checked if the property really has integer type
 */
lv_res_t _lv_style_list_get_int(lv_style_list_t * list, lv_style_property_t prop, lv_style_int_t * res)
{
 800ffbe:	b580      	push	{r7, lr}
 800ffc0:	b088      	sub	sp, #32
 800ffc2:	af00      	add	r7, sp, #0
 800ffc4:	60f8      	str	r0, [r7, #12]
 800ffc6:	460b      	mov	r3, r1
 800ffc8:	607a      	str	r2, [r7, #4]
 800ffca:	817b      	strh	r3, [r7, #10]
    LV_ASSERT_STYLE_LIST(list);

    if(list == NULL) return LV_RES_INV;
 800ffcc:	68fb      	ldr	r3, [r7, #12]
 800ffce:	2b00      	cmp	r3, #0
 800ffd0:	d101      	bne.n	800ffd6 <_lv_style_list_get_int+0x18>
 800ffd2:	2300      	movs	r3, #0
 800ffd4:	e06d      	b.n	80100b2 <_lv_style_list_get_int+0xf4>
    if(list->style_list == NULL) return LV_RES_INV;
 800ffd6:	68fb      	ldr	r3, [r7, #12]
 800ffd8:	681b      	ldr	r3, [r3, #0]
 800ffda:	2b00      	cmp	r3, #0
 800ffdc:	d101      	bne.n	800ffe2 <_lv_style_list_get_int+0x24>
 800ffde:	2300      	movs	r3, #0
 800ffe0:	e067      	b.n	80100b2 <_lv_style_list_get_int+0xf4>

    lv_style_attr_t attr;
    attr = prop >> 8;
 800ffe2:	897b      	ldrh	r3, [r7, #10]
 800ffe4:	0a1b      	lsrs	r3, r3, #8
 800ffe6:	b29b      	uxth	r3, r3
 800ffe8:	76fb      	strb	r3, [r7, #27]
    int16_t weight_goal = attr;
 800ffea:	7efb      	ldrb	r3, [r7, #27]
 800ffec:	833b      	strh	r3, [r7, #24]

    int16_t weight = -1;
 800ffee:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800fff2:	83fb      	strh	r3, [r7, #30]

    lv_style_int_t value_act = 0;
 800fff4:	2300      	movs	r3, #0
 800fff6:	823b      	strh	r3, [r7, #16]

    int16_t ci;
    for(ci = 0; ci < list->style_cnt; ci++) {
 800fff8:	2300      	movs	r3, #0
 800fffa:	83bb      	strh	r3, [r7, #28]
 800fffc:	e049      	b.n	8010092 <_lv_style_list_get_int+0xd4>
        lv_style_t * class = lv_style_list_get_style(list, ci);
 800fffe:	8bbb      	ldrh	r3, [r7, #28]
 8010000:	b2db      	uxtb	r3, r3
 8010002:	4619      	mov	r1, r3
 8010004:	68f8      	ldr	r0, [r7, #12]
 8010006:	f7ff f86f 	bl	800f0e8 <lv_style_list_get_style>
 801000a:	6178      	str	r0, [r7, #20]
        int16_t weight_act = _lv_style_get_int(class, prop, &value_act);
 801000c:	f107 0210 	add.w	r2, r7, #16
 8010010:	897b      	ldrh	r3, [r7, #10]
 8010012:	4619      	mov	r1, r3
 8010014:	6978      	ldr	r0, [r7, #20]
 8010016:	f7ff fe1f 	bl	800fc58 <_lv_style_get_int>
 801001a:	4603      	mov	r3, r0
 801001c:	827b      	strh	r3, [r7, #18]

        /*On perfect match return the value immediately*/
        if(weight_act == weight_goal) {
 801001e:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 8010022:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8010026:	429a      	cmp	r2, r3
 8010028:	d105      	bne.n	8010036 <_lv_style_list_get_int+0x78>
            *res = value_act;
 801002a:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 801002e:	687b      	ldr	r3, [r7, #4]
 8010030:	801a      	strh	r2, [r3, #0]
            return LV_RES_OK;
 8010032:	2301      	movs	r3, #1
 8010034:	e03d      	b.n	80100b2 <_lv_style_list_get_int+0xf4>
        }
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
 8010036:	68fb      	ldr	r3, [r7, #12]
 8010038:	791b      	ldrb	r3, [r3, #4]
 801003a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801003e:	b2db      	uxtb	r3, r3
 8010040:	2b00      	cmp	r3, #0
 8010042:	d014      	beq.n	801006e <_lv_style_list_get_int+0xb0>
 8010044:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8010048:	2b00      	cmp	r3, #0
 801004a:	db10      	blt.n	801006e <_lv_style_list_get_int+0xb0>
 801004c:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8010050:	2b00      	cmp	r3, #0
 8010052:	d10c      	bne.n	801006e <_lv_style_list_get_int+0xb0>
 8010054:	68fb      	ldr	r3, [r7, #12]
 8010056:	795b      	ldrb	r3, [r3, #5]
 8010058:	f003 0301 	and.w	r3, r3, #1
 801005c:	b2db      	uxtb	r3, r3
 801005e:	2b00      	cmp	r3, #0
 8010060:	d105      	bne.n	801006e <_lv_style_list_get_int+0xb0>
            *res = value_act;
 8010062:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 8010066:	687b      	ldr	r3, [r7, #4]
 8010068:	801a      	strh	r2, [r3, #0]
            return LV_RES_OK;
 801006a:	2301      	movs	r3, #1
 801006c:	e021      	b.n	80100b2 <_lv_style_list_get_int+0xf4>
        }
        /*If the found ID is better the current candidate then use it*/
        else if(weight_act > weight) {
 801006e:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 8010072:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8010076:	429a      	cmp	r2, r3
 8010078:	dd05      	ble.n	8010086 <_lv_style_list_get_int+0xc8>
            weight =  weight_act;
 801007a:	8a7b      	ldrh	r3, [r7, #18]
 801007c:	83fb      	strh	r3, [r7, #30]
            *res = value_act;
 801007e:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 8010082:	687b      	ldr	r3, [r7, #4]
 8010084:	801a      	strh	r2, [r3, #0]
    for(ci = 0; ci < list->style_cnt; ci++) {
 8010086:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 801008a:	b29b      	uxth	r3, r3
 801008c:	3301      	adds	r3, #1
 801008e:	b29b      	uxth	r3, r3
 8010090:	83bb      	strh	r3, [r7, #28]
 8010092:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8010096:	68fa      	ldr	r2, [r7, #12]
 8010098:	7912      	ldrb	r2, [r2, #4]
 801009a:	f3c2 0205 	ubfx	r2, r2, #0, #6
 801009e:	b2d2      	uxtb	r2, r2
 80100a0:	4293      	cmp	r3, r2
 80100a2:	dbac      	blt.n	800fffe <_lv_style_list_get_int+0x40>
        }
    }

    if(weight >= 0) return LV_RES_OK;
 80100a4:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80100a8:	2b00      	cmp	r3, #0
 80100aa:	db01      	blt.n	80100b0 <_lv_style_list_get_int+0xf2>
 80100ac:	2301      	movs	r3, #1
 80100ae:	e000      	b.n	80100b2 <_lv_style_list_get_int+0xf4>
    else return LV_RES_INV;
 80100b0:	2300      	movs	r3, #0

}
 80100b2:	4618      	mov	r0, r3
 80100b4:	3720      	adds	r7, #32
 80100b6:	46bd      	mov	sp, r7
 80100b8:	bd80      	pop	{r7, pc}

080100ba <_lv_style_list_get_color>:
 * @return LV_RES_OK: there was a matching property in the list
 *         LV_RES_INV: there was NO matching property in the list
 * @note for performance reasons it's not checked if the property really has color type
 */
lv_res_t _lv_style_list_get_color(lv_style_list_t * list, lv_style_property_t prop, lv_color_t * res)
{
 80100ba:	b580      	push	{r7, lr}
 80100bc:	b088      	sub	sp, #32
 80100be:	af00      	add	r7, sp, #0
 80100c0:	60f8      	str	r0, [r7, #12]
 80100c2:	460b      	mov	r3, r1
 80100c4:	607a      	str	r2, [r7, #4]
 80100c6:	817b      	strh	r3, [r7, #10]
    LV_ASSERT_STYLE_LIST(list);

    if(list == NULL) return LV_RES_INV;
 80100c8:	68fb      	ldr	r3, [r7, #12]
 80100ca:	2b00      	cmp	r3, #0
 80100cc:	d101      	bne.n	80100d2 <_lv_style_list_get_color+0x18>
 80100ce:	2300      	movs	r3, #0
 80100d0:	e06a      	b.n	80101a8 <_lv_style_list_get_color+0xee>
    if(list->style_list == NULL) return LV_RES_INV;
 80100d2:	68fb      	ldr	r3, [r7, #12]
 80100d4:	681b      	ldr	r3, [r3, #0]
 80100d6:	2b00      	cmp	r3, #0
 80100d8:	d101      	bne.n	80100de <_lv_style_list_get_color+0x24>
 80100da:	2300      	movs	r3, #0
 80100dc:	e064      	b.n	80101a8 <_lv_style_list_get_color+0xee>

    lv_style_attr_t attr;
    attr = prop >> 8;
 80100de:	897b      	ldrh	r3, [r7, #10]
 80100e0:	0a1b      	lsrs	r3, r3, #8
 80100e2:	b29b      	uxth	r3, r3
 80100e4:	76fb      	strb	r3, [r7, #27]
    int16_t weight_goal = attr;
 80100e6:	7efb      	ldrb	r3, [r7, #27]
 80100e8:	833b      	strh	r3, [r7, #24]

    int16_t weight = -1;
 80100ea:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80100ee:	83fb      	strh	r3, [r7, #30]

    lv_color_t value_act;
    value_act.full = 0;
 80100f0:	2300      	movs	r3, #0
 80100f2:	823b      	strh	r3, [r7, #16]

    int16_t ci;
    for(ci = 0; ci < list->style_cnt; ci++) {
 80100f4:	2300      	movs	r3, #0
 80100f6:	83bb      	strh	r3, [r7, #28]
 80100f8:	e046      	b.n	8010188 <_lv_style_list_get_color+0xce>
        lv_style_t * class = lv_style_list_get_style(list, ci);
 80100fa:	8bbb      	ldrh	r3, [r7, #28]
 80100fc:	b2db      	uxtb	r3, r3
 80100fe:	4619      	mov	r1, r3
 8010100:	68f8      	ldr	r0, [r7, #12]
 8010102:	f7fe fff1 	bl	800f0e8 <lv_style_list_get_style>
 8010106:	6178      	str	r0, [r7, #20]
        int16_t weight_act = _lv_style_get_color(class, prop, &value_act);
 8010108:	f107 0210 	add.w	r2, r7, #16
 801010c:	897b      	ldrh	r3, [r7, #10]
 801010e:	4619      	mov	r1, r3
 8010110:	6978      	ldr	r0, [r7, #20]
 8010112:	f7ff fe29 	bl	800fd68 <_lv_style_get_color>
 8010116:	4603      	mov	r3, r0
 8010118:	827b      	strh	r3, [r7, #18]
        /*On perfect match return the value immediately*/
        if(weight_act == weight_goal) {
 801011a:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 801011e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8010122:	429a      	cmp	r2, r3
 8010124:	d104      	bne.n	8010130 <_lv_style_list_get_color+0x76>
            *res = value_act;
 8010126:	687b      	ldr	r3, [r7, #4]
 8010128:	8a3a      	ldrh	r2, [r7, #16]
 801012a:	801a      	strh	r2, [r3, #0]
            return LV_RES_OK;
 801012c:	2301      	movs	r3, #1
 801012e:	e03b      	b.n	80101a8 <_lv_style_list_get_color+0xee>
        }
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
 8010130:	68fb      	ldr	r3, [r7, #12]
 8010132:	791b      	ldrb	r3, [r3, #4]
 8010134:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8010138:	b2db      	uxtb	r3, r3
 801013a:	2b00      	cmp	r3, #0
 801013c:	d013      	beq.n	8010166 <_lv_style_list_get_color+0xac>
 801013e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8010142:	2b00      	cmp	r3, #0
 8010144:	db0f      	blt.n	8010166 <_lv_style_list_get_color+0xac>
 8010146:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 801014a:	2b00      	cmp	r3, #0
 801014c:	d10b      	bne.n	8010166 <_lv_style_list_get_color+0xac>
 801014e:	68fb      	ldr	r3, [r7, #12]
 8010150:	795b      	ldrb	r3, [r3, #5]
 8010152:	f003 0301 	and.w	r3, r3, #1
 8010156:	b2db      	uxtb	r3, r3
 8010158:	2b00      	cmp	r3, #0
 801015a:	d104      	bne.n	8010166 <_lv_style_list_get_color+0xac>
            *res = value_act;
 801015c:	687b      	ldr	r3, [r7, #4]
 801015e:	8a3a      	ldrh	r2, [r7, #16]
 8010160:	801a      	strh	r2, [r3, #0]
            return LV_RES_OK;
 8010162:	2301      	movs	r3, #1
 8010164:	e020      	b.n	80101a8 <_lv_style_list_get_color+0xee>
        }
        /*If the found ID is better the current candidate then use it*/
        else if(weight_act > weight) {
 8010166:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 801016a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801016e:	429a      	cmp	r2, r3
 8010170:	dd04      	ble.n	801017c <_lv_style_list_get_color+0xc2>
            weight =  weight_act;
 8010172:	8a7b      	ldrh	r3, [r7, #18]
 8010174:	83fb      	strh	r3, [r7, #30]
            *res = value_act;
 8010176:	687b      	ldr	r3, [r7, #4]
 8010178:	8a3a      	ldrh	r2, [r7, #16]
 801017a:	801a      	strh	r2, [r3, #0]
    for(ci = 0; ci < list->style_cnt; ci++) {
 801017c:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8010180:	b29b      	uxth	r3, r3
 8010182:	3301      	adds	r3, #1
 8010184:	b29b      	uxth	r3, r3
 8010186:	83bb      	strh	r3, [r7, #28]
 8010188:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 801018c:	68fa      	ldr	r2, [r7, #12]
 801018e:	7912      	ldrb	r2, [r2, #4]
 8010190:	f3c2 0205 	ubfx	r2, r2, #0, #6
 8010194:	b2d2      	uxtb	r2, r2
 8010196:	4293      	cmp	r3, r2
 8010198:	dbaf      	blt.n	80100fa <_lv_style_list_get_color+0x40>
        }
    }

    if(weight >= 0)  return LV_RES_OK;
 801019a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801019e:	2b00      	cmp	r3, #0
 80101a0:	db01      	blt.n	80101a6 <_lv_style_list_get_color+0xec>
 80101a2:	2301      	movs	r3, #1
 80101a4:	e000      	b.n	80101a8 <_lv_style_list_get_color+0xee>
    else return LV_RES_INV;
 80101a6:	2300      	movs	r3, #0
}
 80101a8:	4618      	mov	r0, r3
 80101aa:	3720      	adds	r7, #32
 80101ac:	46bd      	mov	sp, r7
 80101ae:	bd80      	pop	{r7, pc}

080101b0 <_lv_style_list_get_opa>:
 * @return LV_RES_OK: there was a matching property in the list
 *         LV_RES_INV: there was NO matching property in the list
 * @note for performance reasons it's not checked if the property really has opacity type
 */
lv_res_t _lv_style_list_get_opa(lv_style_list_t * list, lv_style_property_t prop, lv_opa_t * res)
{
 80101b0:	b580      	push	{r7, lr}
 80101b2:	b088      	sub	sp, #32
 80101b4:	af00      	add	r7, sp, #0
 80101b6:	60f8      	str	r0, [r7, #12]
 80101b8:	460b      	mov	r3, r1
 80101ba:	607a      	str	r2, [r7, #4]
 80101bc:	817b      	strh	r3, [r7, #10]
    LV_ASSERT_STYLE_LIST(list);

    if(list == NULL) return LV_RES_INV;
 80101be:	68fb      	ldr	r3, [r7, #12]
 80101c0:	2b00      	cmp	r3, #0
 80101c2:	d101      	bne.n	80101c8 <_lv_style_list_get_opa+0x18>
 80101c4:	2300      	movs	r3, #0
 80101c6:	e06a      	b.n	801029e <_lv_style_list_get_opa+0xee>
    if(list->style_list == NULL) return LV_RES_INV;
 80101c8:	68fb      	ldr	r3, [r7, #12]
 80101ca:	681b      	ldr	r3, [r3, #0]
 80101cc:	2b00      	cmp	r3, #0
 80101ce:	d101      	bne.n	80101d4 <_lv_style_list_get_opa+0x24>
 80101d0:	2300      	movs	r3, #0
 80101d2:	e064      	b.n	801029e <_lv_style_list_get_opa+0xee>

    lv_style_attr_t attr;
    attr = prop >> 8;
 80101d4:	897b      	ldrh	r3, [r7, #10]
 80101d6:	0a1b      	lsrs	r3, r3, #8
 80101d8:	b29b      	uxth	r3, r3
 80101da:	76fb      	strb	r3, [r7, #27]
    int16_t weight_goal = attr;
 80101dc:	7efb      	ldrb	r3, [r7, #27]
 80101de:	833b      	strh	r3, [r7, #24]

    int16_t weight = -1;
 80101e0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80101e4:	83fb      	strh	r3, [r7, #30]

    lv_opa_t value_act = LV_OPA_TRANSP;
 80101e6:	2300      	movs	r3, #0
 80101e8:	747b      	strb	r3, [r7, #17]

    int16_t ci;
    for(ci = 0; ci < list->style_cnt; ci++) {
 80101ea:	2300      	movs	r3, #0
 80101ec:	83bb      	strh	r3, [r7, #28]
 80101ee:	e046      	b.n	801027e <_lv_style_list_get_opa+0xce>
        lv_style_t * class = lv_style_list_get_style(list, ci);
 80101f0:	8bbb      	ldrh	r3, [r7, #28]
 80101f2:	b2db      	uxtb	r3, r3
 80101f4:	4619      	mov	r1, r3
 80101f6:	68f8      	ldr	r0, [r7, #12]
 80101f8:	f7fe ff76 	bl	800f0e8 <lv_style_list_get_style>
 80101fc:	6178      	str	r0, [r7, #20]
        int16_t weight_act = _lv_style_get_opa(class, prop, &value_act);
 80101fe:	f107 0211 	add.w	r2, r7, #17
 8010202:	897b      	ldrh	r3, [r7, #10]
 8010204:	4619      	mov	r1, r3
 8010206:	6978      	ldr	r0, [r7, #20]
 8010208:	f7ff fd6a 	bl	800fce0 <_lv_style_get_opa>
 801020c:	4603      	mov	r3, r0
 801020e:	827b      	strh	r3, [r7, #18]
        /*On perfect match return the value immediately*/
        if(weight_act == weight_goal) {
 8010210:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 8010214:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8010218:	429a      	cmp	r2, r3
 801021a:	d104      	bne.n	8010226 <_lv_style_list_get_opa+0x76>
            *res = value_act;
 801021c:	7c7a      	ldrb	r2, [r7, #17]
 801021e:	687b      	ldr	r3, [r7, #4]
 8010220:	701a      	strb	r2, [r3, #0]
            return LV_RES_OK;
 8010222:	2301      	movs	r3, #1
 8010224:	e03b      	b.n	801029e <_lv_style_list_get_opa+0xee>
        }
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
 8010226:	68fb      	ldr	r3, [r7, #12]
 8010228:	791b      	ldrb	r3, [r3, #4]
 801022a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801022e:	b2db      	uxtb	r3, r3
 8010230:	2b00      	cmp	r3, #0
 8010232:	d013      	beq.n	801025c <_lv_style_list_get_opa+0xac>
 8010234:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8010238:	2b00      	cmp	r3, #0
 801023a:	db0f      	blt.n	801025c <_lv_style_list_get_opa+0xac>
 801023c:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8010240:	2b00      	cmp	r3, #0
 8010242:	d10b      	bne.n	801025c <_lv_style_list_get_opa+0xac>
 8010244:	68fb      	ldr	r3, [r7, #12]
 8010246:	795b      	ldrb	r3, [r3, #5]
 8010248:	f003 0301 	and.w	r3, r3, #1
 801024c:	b2db      	uxtb	r3, r3
 801024e:	2b00      	cmp	r3, #0
 8010250:	d104      	bne.n	801025c <_lv_style_list_get_opa+0xac>
            *res = value_act;
 8010252:	7c7a      	ldrb	r2, [r7, #17]
 8010254:	687b      	ldr	r3, [r7, #4]
 8010256:	701a      	strb	r2, [r3, #0]
            return LV_RES_OK;
 8010258:	2301      	movs	r3, #1
 801025a:	e020      	b.n	801029e <_lv_style_list_get_opa+0xee>
        }
        /*If the found ID is better the current candidate then use it*/
        else if(weight_act > weight) {
 801025c:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 8010260:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8010264:	429a      	cmp	r2, r3
 8010266:	dd04      	ble.n	8010272 <_lv_style_list_get_opa+0xc2>
            weight =  weight_act;
 8010268:	8a7b      	ldrh	r3, [r7, #18]
 801026a:	83fb      	strh	r3, [r7, #30]
            *res = value_act;
 801026c:	7c7a      	ldrb	r2, [r7, #17]
 801026e:	687b      	ldr	r3, [r7, #4]
 8010270:	701a      	strb	r2, [r3, #0]
    for(ci = 0; ci < list->style_cnt; ci++) {
 8010272:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8010276:	b29b      	uxth	r3, r3
 8010278:	3301      	adds	r3, #1
 801027a:	b29b      	uxth	r3, r3
 801027c:	83bb      	strh	r3, [r7, #28]
 801027e:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8010282:	68fa      	ldr	r2, [r7, #12]
 8010284:	7912      	ldrb	r2, [r2, #4]
 8010286:	f3c2 0205 	ubfx	r2, r2, #0, #6
 801028a:	b2d2      	uxtb	r2, r2
 801028c:	4293      	cmp	r3, r2
 801028e:	dbaf      	blt.n	80101f0 <_lv_style_list_get_opa+0x40>
        }
    }

    if(weight >= 0)  return LV_RES_OK;
 8010290:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8010294:	2b00      	cmp	r3, #0
 8010296:	db01      	blt.n	801029c <_lv_style_list_get_opa+0xec>
 8010298:	2301      	movs	r3, #1
 801029a:	e000      	b.n	801029e <_lv_style_list_get_opa+0xee>
    else return LV_RES_INV;
 801029c:	2300      	movs	r3, #0
}
 801029e:	4618      	mov	r0, r3
 80102a0:	3720      	adds	r7, #32
 80102a2:	46bd      	mov	sp, r7
 80102a4:	bd80      	pop	{r7, pc}

080102a6 <_lv_style_list_get_ptr>:
 * @return LV_RES_OK: there was a matching property in the list
 *         LV_RES_INV: there was NO matching property in the list
 * @note for performance reasons it's not checked if the property really has pointer type
 */
lv_res_t _lv_style_list_get_ptr(lv_style_list_t * list, lv_style_property_t prop, const void ** res)
{
 80102a6:	b580      	push	{r7, lr}
 80102a8:	b08a      	sub	sp, #40	; 0x28
 80102aa:	af00      	add	r7, sp, #0
 80102ac:	60f8      	str	r0, [r7, #12]
 80102ae:	460b      	mov	r3, r1
 80102b0:	607a      	str	r2, [r7, #4]
 80102b2:	817b      	strh	r3, [r7, #10]
    LV_ASSERT_STYLE_LIST(list);

    if(list == NULL) return LV_RES_INV;
 80102b4:	68fb      	ldr	r3, [r7, #12]
 80102b6:	2b00      	cmp	r3, #0
 80102b8:	d101      	bne.n	80102be <_lv_style_list_get_ptr+0x18>
 80102ba:	2300      	movs	r3, #0
 80102bc:	e06a      	b.n	8010394 <_lv_style_list_get_ptr+0xee>
    if(list->style_list == NULL) return LV_RES_INV;
 80102be:	68fb      	ldr	r3, [r7, #12]
 80102c0:	681b      	ldr	r3, [r3, #0]
 80102c2:	2b00      	cmp	r3, #0
 80102c4:	d101      	bne.n	80102ca <_lv_style_list_get_ptr+0x24>
 80102c6:	2300      	movs	r3, #0
 80102c8:	e064      	b.n	8010394 <_lv_style_list_get_ptr+0xee>

    lv_style_attr_t attr;
    attr = prop >> 8;
 80102ca:	897b      	ldrh	r3, [r7, #10]
 80102cc:	0a1b      	lsrs	r3, r3, #8
 80102ce:	b29b      	uxth	r3, r3
 80102d0:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    int16_t weight_goal = attr;
 80102d4:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80102d8:	843b      	strh	r3, [r7, #32]

    int16_t weight = -1;
 80102da:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80102de:	84fb      	strh	r3, [r7, #38]	; 0x26

    const void * value_act;

    int16_t ci;
    for(ci = 0; ci < list->style_cnt; ci++) {
 80102e0:	2300      	movs	r3, #0
 80102e2:	84bb      	strh	r3, [r7, #36]	; 0x24
 80102e4:	e046      	b.n	8010374 <_lv_style_list_get_ptr+0xce>
        lv_style_t * class = lv_style_list_get_style(list, ci);
 80102e6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80102e8:	b2db      	uxtb	r3, r3
 80102ea:	4619      	mov	r1, r3
 80102ec:	68f8      	ldr	r0, [r7, #12]
 80102ee:	f7fe fefb 	bl	800f0e8 <lv_style_list_get_style>
 80102f2:	61f8      	str	r0, [r7, #28]
        int16_t weight_act = _lv_style_get_ptr(class, prop, &value_act);
 80102f4:	f107 0214 	add.w	r2, r7, #20
 80102f8:	897b      	ldrh	r3, [r7, #10]
 80102fa:	4619      	mov	r1, r3
 80102fc:	69f8      	ldr	r0, [r7, #28]
 80102fe:	f7ff fd77 	bl	800fdf0 <_lv_style_get_ptr>
 8010302:	4603      	mov	r3, r0
 8010304:	837b      	strh	r3, [r7, #26]
        /*On perfect match return the value immediately*/
        if(weight_act == weight_goal) {
 8010306:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 801030a:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801030e:	429a      	cmp	r2, r3
 8010310:	d104      	bne.n	801031c <_lv_style_list_get_ptr+0x76>
            *res = value_act;
 8010312:	697a      	ldr	r2, [r7, #20]
 8010314:	687b      	ldr	r3, [r7, #4]
 8010316:	601a      	str	r2, [r3, #0]
            return LV_RES_OK;
 8010318:	2301      	movs	r3, #1
 801031a:	e03b      	b.n	8010394 <_lv_style_list_get_ptr+0xee>
        }
        else if(list->has_trans && weight_act >= 0 && ci == 0 && !list->skip_trans) {
 801031c:	68fb      	ldr	r3, [r7, #12]
 801031e:	791b      	ldrb	r3, [r3, #4]
 8010320:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8010324:	b2db      	uxtb	r3, r3
 8010326:	2b00      	cmp	r3, #0
 8010328:	d013      	beq.n	8010352 <_lv_style_list_get_ptr+0xac>
 801032a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801032e:	2b00      	cmp	r3, #0
 8010330:	db0f      	blt.n	8010352 <_lv_style_list_get_ptr+0xac>
 8010332:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8010336:	2b00      	cmp	r3, #0
 8010338:	d10b      	bne.n	8010352 <_lv_style_list_get_ptr+0xac>
 801033a:	68fb      	ldr	r3, [r7, #12]
 801033c:	795b      	ldrb	r3, [r3, #5]
 801033e:	f003 0301 	and.w	r3, r3, #1
 8010342:	b2db      	uxtb	r3, r3
 8010344:	2b00      	cmp	r3, #0
 8010346:	d104      	bne.n	8010352 <_lv_style_list_get_ptr+0xac>
            *res = value_act;
 8010348:	697a      	ldr	r2, [r7, #20]
 801034a:	687b      	ldr	r3, [r7, #4]
 801034c:	601a      	str	r2, [r3, #0]
            return LV_RES_OK;
 801034e:	2301      	movs	r3, #1
 8010350:	e020      	b.n	8010394 <_lv_style_list_get_ptr+0xee>
        }
        /*If the found ID is better the current candidate then use it*/
        else if(weight_act > weight) {
 8010352:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 8010356:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801035a:	429a      	cmp	r2, r3
 801035c:	dd04      	ble.n	8010368 <_lv_style_list_get_ptr+0xc2>
            weight =  weight_act;
 801035e:	8b7b      	ldrh	r3, [r7, #26]
 8010360:	84fb      	strh	r3, [r7, #38]	; 0x26
            *res = value_act;
 8010362:	697a      	ldr	r2, [r7, #20]
 8010364:	687b      	ldr	r3, [r7, #4]
 8010366:	601a      	str	r2, [r3, #0]
    for(ci = 0; ci < list->style_cnt; ci++) {
 8010368:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 801036c:	b29b      	uxth	r3, r3
 801036e:	3301      	adds	r3, #1
 8010370:	b29b      	uxth	r3, r3
 8010372:	84bb      	strh	r3, [r7, #36]	; 0x24
 8010374:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8010378:	68fa      	ldr	r2, [r7, #12]
 801037a:	7912      	ldrb	r2, [r2, #4]
 801037c:	f3c2 0205 	ubfx	r2, r2, #0, #6
 8010380:	b2d2      	uxtb	r2, r2
 8010382:	4293      	cmp	r3, r2
 8010384:	dbaf      	blt.n	80102e6 <_lv_style_list_get_ptr+0x40>
        }
    }

    if(weight >= 0)  return LV_RES_OK;
 8010386:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801038a:	2b00      	cmp	r3, #0
 801038c:	db01      	blt.n	8010392 <_lv_style_list_get_ptr+0xec>
 801038e:	2301      	movs	r3, #1
 8010390:	e000      	b.n	8010394 <_lv_style_list_get_ptr+0xee>
    else return LV_RES_INV;
 8010392:	2300      	movs	r3, #0
}
 8010394:	4618      	mov	r0, r3
 8010396:	3728      	adds	r7, #40	; 0x28
 8010398:	46bd      	mov	sp, r7
 801039a:	bd80      	pop	{r7, pc}

0801039c <get_property_index>:
 * @param prop a style property ORed with a state.
 * E.g. `LV_STYLE_TEXT_FONT | (LV_STATE_PRESSED << LV_STYLE_STATE_POS)`
 * @return
 */
LV_ATTRIBUTE_FAST_MEM static inline int32_t get_property_index(const lv_style_t * style, lv_style_property_t prop)
{
 801039c:	b580      	push	{r7, lr}
 801039e:	b086      	sub	sp, #24
 80103a0:	af00      	add	r7, sp, #0
 80103a2:	6078      	str	r0, [r7, #4]
 80103a4:	460b      	mov	r3, r1
 80103a6:	807b      	strh	r3, [r7, #2]
    LV_ASSERT_STYLE(style);

    if(style->map == NULL) return -1;
 80103a8:	687b      	ldr	r3, [r7, #4]
 80103aa:	681b      	ldr	r3, [r3, #0]
 80103ac:	2b00      	cmp	r3, #0
 80103ae:	d102      	bne.n	80103b6 <get_property_index+0x1a>
 80103b0:	f04f 33ff 	mov.w	r3, #4294967295
 80103b4:	e04b      	b.n	801044e <get_property_index+0xb2>

    uint8_t id_to_find = prop & 0xFF;
 80103b6:	887b      	ldrh	r3, [r7, #2]
 80103b8:	73fb      	strb	r3, [r7, #15]
    lv_style_attr_t attr;
    attr = (prop >> 8) & 0xFF;
 80103ba:	887b      	ldrh	r3, [r7, #2]
 80103bc:	0a1b      	lsrs	r3, r3, #8
 80103be:	b29b      	uxth	r3, r3
 80103c0:	73bb      	strb	r3, [r7, #14]

    int16_t weight = -1;
 80103c2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80103c6:	82fb      	strh	r3, [r7, #22]
    int16_t id_guess = -1;
 80103c8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80103cc:	82bb      	strh	r3, [r7, #20]

    size_t i = 0;
 80103ce:	2300      	movs	r3, #0
 80103d0:	613b      	str	r3, [r7, #16]

    uint8_t prop_id;
    while((prop_id = get_style_prop_id(style, i)) != _LV_STYLE_CLOSEING_PROP) {
 80103d2:	e031      	b.n	8010438 <get_property_index+0x9c>
        if(prop_id == id_to_find) {
 80103d4:	7b7a      	ldrb	r2, [r7, #13]
 80103d6:	7bfb      	ldrb	r3, [r7, #15]
 80103d8:	429a      	cmp	r2, r3
 80103da:	d127      	bne.n	801042c <get_property_index+0x90>
            lv_style_attr_t attr_i;
            attr_i = get_style_prop_attr(style, i);
 80103dc:	6939      	ldr	r1, [r7, #16]
 80103de:	6878      	ldr	r0, [r7, #4]
 80103e0:	f000 f8be 	bl	8010560 <get_style_prop_attr>
 80103e4:	4603      	mov	r3, r0
 80103e6:	733b      	strb	r3, [r7, #12]

            /*If the state perfectly matches return this property*/
            if(LV_STYLE_ATTR_GET_STATE(attr_i) == LV_STYLE_ATTR_GET_STATE(attr)) {
 80103e8:	7b3a      	ldrb	r2, [r7, #12]
 80103ea:	7bbb      	ldrb	r3, [r7, #14]
 80103ec:	4053      	eors	r3, r2
 80103ee:	b2db      	uxtb	r3, r3
 80103f0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80103f4:	2b00      	cmp	r3, #0
 80103f6:	d101      	bne.n	80103fc <get_property_index+0x60>
                return i;
 80103f8:	693b      	ldr	r3, [r7, #16]
 80103fa:	e028      	b.n	801044e <get_property_index+0xb2>
            }
            /* Be sure the property not specifies other state than the requested.
             * E.g. For HOVER+PRESS, HOVER only is OK, but HOVER+FOCUS not*/
            else if((LV_STYLE_ATTR_GET_STATE(attr_i) & (~LV_STYLE_ATTR_GET_STATE(attr))) == 0) {
 80103fc:	7b3b      	ldrb	r3, [r7, #12]
 80103fe:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8010402:	7bbb      	ldrb	r3, [r7, #14]
 8010404:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8010408:	43db      	mvns	r3, r3
 801040a:	4013      	ands	r3, r2
 801040c:	2b00      	cmp	r3, #0
 801040e:	d10d      	bne.n	801042c <get_property_index+0x90>
                /* Use this property if it describes better the requested state than the current candidate.
                 * E.g. for HOVER+FOCUS+PRESS prefer HOVER+FOCUS over FOCUS*/
                if(LV_STYLE_ATTR_GET_STATE(attr_i) > weight) {
 8010410:	7b3b      	ldrb	r3, [r7, #12]
 8010412:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8010416:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801041a:	429a      	cmp	r2, r3
 801041c:	dd06      	ble.n	801042c <get_property_index+0x90>
                    weight = LV_STYLE_ATTR_GET_STATE(attr_i);
 801041e:	7b3b      	ldrb	r3, [r7, #12]
 8010420:	b21b      	sxth	r3, r3
 8010422:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8010426:	82fb      	strh	r3, [r7, #22]
                    id_guess = i;
 8010428:	693b      	ldr	r3, [r7, #16]
 801042a:	82bb      	strh	r3, [r7, #20]
                }
            }
        }

        i = get_next_prop_index(prop_id, i);
 801042c:	7b7b      	ldrb	r3, [r7, #13]
 801042e:	6939      	ldr	r1, [r7, #16]
 8010430:	4618      	mov	r0, r3
 8010432:	f000 f8d0 	bl	80105d6 <get_next_prop_index>
 8010436:	6138      	str	r0, [r7, #16]
    while((prop_id = get_style_prop_id(style, i)) != _LV_STYLE_CLOSEING_PROP) {
 8010438:	6939      	ldr	r1, [r7, #16]
 801043a:	6878      	ldr	r0, [r7, #4]
 801043c:	f000 f881 	bl	8010542 <get_style_prop_id>
 8010440:	4603      	mov	r3, r0
 8010442:	737b      	strb	r3, [r7, #13]
 8010444:	7b7b      	ldrb	r3, [r7, #13]
 8010446:	2bff      	cmp	r3, #255	; 0xff
 8010448:	d1c4      	bne.n	80103d4 <get_property_index+0x38>
    }

    return id_guess;
 801044a:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
}
 801044e:	4618      	mov	r0, r3
 8010450:	3718      	adds	r7, #24
 8010452:	46bd      	mov	sp, r7
 8010454:	bd80      	pop	{r7, pc}
	...

08010458 <get_alloc_local_style>:
 * Get he local style from a style list. Allocate it if not exists yet.
 * @param list pointer to a style list
 * @return pointer to the local style
 */
static lv_style_t * get_alloc_local_style(lv_style_list_t * list)
{
 8010458:	b5b0      	push	{r4, r5, r7, lr}
 801045a:	b084      	sub	sp, #16
 801045c:	af00      	add	r7, sp, #0
 801045e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_STYLE_LIST(list);

    if(list->has_local) return lv_style_list_get_style(list, list->has_trans ? 1 : 0);
 8010460:	687b      	ldr	r3, [r7, #4]
 8010462:	791b      	ldrb	r3, [r3, #4]
 8010464:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010468:	b2db      	uxtb	r3, r3
 801046a:	2b00      	cmp	r3, #0
 801046c:	d009      	beq.n	8010482 <get_alloc_local_style+0x2a>
 801046e:	687b      	ldr	r3, [r7, #4]
 8010470:	791b      	ldrb	r3, [r3, #4]
 8010472:	09db      	lsrs	r3, r3, #7
 8010474:	b2db      	uxtb	r3, r3
 8010476:	4619      	mov	r1, r3
 8010478:	6878      	ldr	r0, [r7, #4]
 801047a:	f7fe fe35 	bl	800f0e8 <lv_style_list_get_style>
 801047e:	4603      	mov	r3, r0
 8010480:	e028      	b.n	80104d4 <get_alloc_local_style+0x7c>

    lv_style_t * local_style = lv_mem_alloc(sizeof(lv_style_t));
 8010482:	2004      	movs	r0, #4
 8010484:	f010 fba6 	bl	8020bd4 <lv_mem_alloc>
 8010488:	60f8      	str	r0, [r7, #12]
    LV_ASSERT_MEM(local_style);
 801048a:	68f8      	ldr	r0, [r7, #12]
 801048c:	f00f fe30 	bl	80200f0 <lv_debug_check_null>
 8010490:	4603      	mov	r3, r0
 8010492:	f083 0301 	eor.w	r3, r3, #1
 8010496:	b2db      	uxtb	r3, r3
 8010498:	2b00      	cmp	r3, #0
 801049a:	d009      	beq.n	80104b0 <get_alloc_local_style+0x58>
 801049c:	68fb      	ldr	r3, [r7, #12]
 801049e:	2200      	movs	r2, #0
 80104a0:	461c      	mov	r4, r3
 80104a2:	4615      	mov	r5, r2
 80104a4:	4622      	mov	r2, r4
 80104a6:	462b      	mov	r3, r5
 80104a8:	480c      	ldr	r0, [pc, #48]	; (80104dc <get_alloc_local_style+0x84>)
 80104aa:	f00f fe31 	bl	8020110 <lv_debug_log_error>
 80104ae:	e7fe      	b.n	80104ae <get_alloc_local_style+0x56>
    if(local_style == NULL) {
 80104b0:	68fb      	ldr	r3, [r7, #12]
 80104b2:	2b00      	cmp	r3, #0
 80104b4:	d101      	bne.n	80104ba <get_alloc_local_style+0x62>
        LV_LOG_WARN("get_local_style: couldn't create local style");
        return NULL;
 80104b6:	2300      	movs	r3, #0
 80104b8:	e00c      	b.n	80104d4 <get_alloc_local_style+0x7c>
    }
    lv_style_init(local_style);
 80104ba:	68f8      	ldr	r0, [r7, #12]
 80104bc:	f7fe fe49 	bl	800f152 <lv_style_init>

    /*Add the local style to the first place*/
    _lv_style_list_add_style(list, local_style);
 80104c0:	68f9      	ldr	r1, [r7, #12]
 80104c2:	6878      	ldr	r0, [r7, #4]
 80104c4:	f7fe ffb8 	bl	800f438 <_lv_style_list_add_style>
    list->has_local = 1;
 80104c8:	687a      	ldr	r2, [r7, #4]
 80104ca:	7913      	ldrb	r3, [r2, #4]
 80104cc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80104d0:	7113      	strb	r3, [r2, #4]

    return local_style;
 80104d2:	68fb      	ldr	r3, [r7, #12]
}
 80104d4:	4618      	mov	r0, r3
 80104d6:	3710      	adds	r7, #16
 80104d8:	46bd      	mov	sp, r7
 80104da:	bdb0      	pop	{r4, r5, r7, pc}
 80104dc:	0802e448 	.word	0x0802e448

080104e0 <style_resize>:
 * Resizes a style map. Useful entry point for debugging.
 * @param style pointer to the style to be resized.
 * @param size new size
 */
static inline void style_resize(lv_style_t * style, size_t sz)
{
 80104e0:	b580      	push	{r7, lr}
 80104e2:	b082      	sub	sp, #8
 80104e4:	af00      	add	r7, sp, #0
 80104e6:	6078      	str	r0, [r7, #4]
 80104e8:	6039      	str	r1, [r7, #0]
    style->map = lv_mem_realloc(style->map, sz);
 80104ea:	687b      	ldr	r3, [r7, #4]
 80104ec:	681b      	ldr	r3, [r3, #0]
 80104ee:	6839      	ldr	r1, [r7, #0]
 80104f0:	4618      	mov	r0, r3
 80104f2:	f010 fc0f 	bl	8020d14 <lv_mem_realloc>
 80104f6:	4602      	mov	r2, r0
 80104f8:	687b      	ldr	r3, [r7, #4]
 80104fa:	601a      	str	r2, [r3, #0]
}
 80104fc:	bf00      	nop
 80104fe:	3708      	adds	r7, #8
 8010500:	46bd      	mov	sp, r7
 8010502:	bd80      	pop	{r7, pc}

08010504 <get_style_prop>:
 * @param style pointer to style.
 * @param idx index of the style in style->map
 * @return property in style->map + idx
 */
static inline lv_style_property_t get_style_prop(const lv_style_t * style, size_t idx)
{
 8010504:	b480      	push	{r7}
 8010506:	b085      	sub	sp, #20
 8010508:	af00      	add	r7, sp, #0
 801050a:	6078      	str	r0, [r7, #4]
 801050c:	6039      	str	r1, [r7, #0]
    lv_style_property_t prop;
    uint8_t * prop_p = (uint8_t *)&prop;
 801050e:	f107 030a 	add.w	r3, r7, #10
 8010512:	60fb      	str	r3, [r7, #12]
    prop_p[0] = style->map[idx];
 8010514:	687b      	ldr	r3, [r7, #4]
 8010516:	681a      	ldr	r2, [r3, #0]
 8010518:	683b      	ldr	r3, [r7, #0]
 801051a:	4413      	add	r3, r2
 801051c:	781a      	ldrb	r2, [r3, #0]
 801051e:	68fb      	ldr	r3, [r7, #12]
 8010520:	701a      	strb	r2, [r3, #0]
    prop_p[1] = style->map[idx + 1];
 8010522:	687b      	ldr	r3, [r7, #4]
 8010524:	681a      	ldr	r2, [r3, #0]
 8010526:	683b      	ldr	r3, [r7, #0]
 8010528:	3301      	adds	r3, #1
 801052a:	441a      	add	r2, r3
 801052c:	68fb      	ldr	r3, [r7, #12]
 801052e:	3301      	adds	r3, #1
 8010530:	7812      	ldrb	r2, [r2, #0]
 8010532:	701a      	strb	r2, [r3, #0]
    return prop;
 8010534:	897b      	ldrh	r3, [r7, #10]
}
 8010536:	4618      	mov	r0, r3
 8010538:	3714      	adds	r7, #20
 801053a:	46bd      	mov	sp, r7
 801053c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010540:	4770      	bx	lr

08010542 <get_style_prop_id>:
 * @param style pointer to style.
 * @param idx index of the style in style->map
 * @return id of property in style->map + idx
 */
static inline uint8_t get_style_prop_id(const lv_style_t * style, size_t idx)
{
 8010542:	b580      	push	{r7, lr}
 8010544:	b082      	sub	sp, #8
 8010546:	af00      	add	r7, sp, #0
 8010548:	6078      	str	r0, [r7, #4]
 801054a:	6039      	str	r1, [r7, #0]
    return get_style_prop(style, idx) & 0xFF;
 801054c:	6839      	ldr	r1, [r7, #0]
 801054e:	6878      	ldr	r0, [r7, #4]
 8010550:	f7ff ffd8 	bl	8010504 <get_style_prop>
 8010554:	4603      	mov	r3, r0
 8010556:	b2db      	uxtb	r3, r3
}
 8010558:	4618      	mov	r0, r3
 801055a:	3708      	adds	r7, #8
 801055c:	46bd      	mov	sp, r7
 801055e:	bd80      	pop	{r7, pc}

08010560 <get_style_prop_attr>:
 * @param style pointer to style.
 * @param idx index of the style in style->map
 * @return attribute of property in style->map + idx
 */
static inline uint8_t get_style_prop_attr(const lv_style_t * style, size_t idx)
{
 8010560:	b580      	push	{r7, lr}
 8010562:	b082      	sub	sp, #8
 8010564:	af00      	add	r7, sp, #0
 8010566:	6078      	str	r0, [r7, #4]
 8010568:	6039      	str	r1, [r7, #0]
    return ((get_style_prop(style, idx) >> 8) & 0xFFU);
 801056a:	6839      	ldr	r1, [r7, #0]
 801056c:	6878      	ldr	r0, [r7, #4]
 801056e:	f7ff ffc9 	bl	8010504 <get_style_prop>
 8010572:	4603      	mov	r3, r0
 8010574:	0a1b      	lsrs	r3, r3, #8
 8010576:	b29b      	uxth	r3, r3
 8010578:	b2db      	uxtb	r3, r3
}
 801057a:	4618      	mov	r0, r3
 801057c:	3708      	adds	r7, #8
 801057e:	46bd      	mov	sp, r7
 8010580:	bd80      	pop	{r7, pc}

08010582 <get_prop_size>:
 * @param prop_id property id.
 * @param idx index of the style in style->map
 * @return attribute of property in style->map + idx
 */
static inline size_t get_prop_size(uint8_t prop_id)
{
 8010582:	b480      	push	{r7}
 8010584:	b085      	sub	sp, #20
 8010586:	af00      	add	r7, sp, #0
 8010588:	4603      	mov	r3, r0
 801058a:	71fb      	strb	r3, [r7, #7]
    prop_id &= 0xF;
 801058c:	79fb      	ldrb	r3, [r7, #7]
 801058e:	f003 030f 	and.w	r3, r3, #15
 8010592:	71fb      	strb	r3, [r7, #7]
    size_t size = sizeof(lv_style_property_t);
 8010594:	2302      	movs	r3, #2
 8010596:	60fb      	str	r3, [r7, #12]
    if(prop_id < LV_STYLE_ID_COLOR) size += sizeof(lv_style_int_t);
 8010598:	79fb      	ldrb	r3, [r7, #7]
 801059a:	2b08      	cmp	r3, #8
 801059c:	d803      	bhi.n	80105a6 <get_prop_size+0x24>
 801059e:	68fb      	ldr	r3, [r7, #12]
 80105a0:	3302      	adds	r3, #2
 80105a2:	60fb      	str	r3, [r7, #12]
 80105a4:	e010      	b.n	80105c8 <get_prop_size+0x46>
    else if(prop_id < LV_STYLE_ID_OPA) size += sizeof(lv_color_t);
 80105a6:	79fb      	ldrb	r3, [r7, #7]
 80105a8:	2b0b      	cmp	r3, #11
 80105aa:	d803      	bhi.n	80105b4 <get_prop_size+0x32>
 80105ac:	68fb      	ldr	r3, [r7, #12]
 80105ae:	3302      	adds	r3, #2
 80105b0:	60fb      	str	r3, [r7, #12]
 80105b2:	e009      	b.n	80105c8 <get_prop_size+0x46>
    else if(prop_id < LV_STYLE_ID_PTR) size += sizeof(lv_opa_t);
 80105b4:	79fb      	ldrb	r3, [r7, #7]
 80105b6:	2b0d      	cmp	r3, #13
 80105b8:	d803      	bhi.n	80105c2 <get_prop_size+0x40>
 80105ba:	68fb      	ldr	r3, [r7, #12]
 80105bc:	3301      	adds	r3, #1
 80105be:	60fb      	str	r3, [r7, #12]
 80105c0:	e002      	b.n	80105c8 <get_prop_size+0x46>
    else size += sizeof(const void *);
 80105c2:	68fb      	ldr	r3, [r7, #12]
 80105c4:	3304      	adds	r3, #4
 80105c6:	60fb      	str	r3, [r7, #12]
    return size;
 80105c8:	68fb      	ldr	r3, [r7, #12]
}
 80105ca:	4618      	mov	r0, r3
 80105cc:	3714      	adds	r7, #20
 80105ce:	46bd      	mov	sp, r7
 80105d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80105d4:	4770      	bx	lr

080105d6 <get_next_prop_index>:
 * @param prop_id property id.
 * @param idx index of the style in style->map
 * @return index of next property in style->map
 */
static inline size_t get_next_prop_index(uint8_t prop_id, size_t idx)
{
 80105d6:	b580      	push	{r7, lr}
 80105d8:	b082      	sub	sp, #8
 80105da:	af00      	add	r7, sp, #0
 80105dc:	4603      	mov	r3, r0
 80105de:	6039      	str	r1, [r7, #0]
 80105e0:	71fb      	strb	r3, [r7, #7]
    return idx + get_prop_size(prop_id);
 80105e2:	79fb      	ldrb	r3, [r7, #7]
 80105e4:	4618      	mov	r0, r3
 80105e6:	f7ff ffcc 	bl	8010582 <get_prop_size>
 80105ea:	4602      	mov	r2, r0
 80105ec:	683b      	ldr	r3, [r7, #0]
 80105ee:	4413      	add	r3, r2
}
 80105f0:	4618      	mov	r0, r3
 80105f2:	3708      	adds	r7, #8
 80105f4:	46bd      	mov	sp, r7
 80105f6:	bd80      	pop	{r7, pc}

080105f8 <lv_color_mix>:
 * @param c2 the second color to mix (usually the background)
 * @param mix The ratio of the colors. 0: full `c2`, 255: full `c1`, 127: half `c1` and half`c2`
 * @return the mixed color
 */
LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
 80105f8:	b480      	push	{r7}
 80105fa:	b085      	sub	sp, #20
 80105fc:	af00      	add	r7, sp, #0
 80105fe:	80b8      	strh	r0, [r7, #4]
 8010600:	8039      	strh	r1, [r7, #0]
 8010602:	4613      	mov	r3, r2
 8010604:	70fb      	strb	r3, [r7, #3]
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
 8010606:	797b      	ldrb	r3, [r7, #5]
 8010608:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801060c:	b2db      	uxtb	r3, r3
 801060e:	461a      	mov	r2, r3
 8010610:	78fb      	ldrb	r3, [r7, #3]
 8010612:	fb03 f202 	mul.w	r2, r3, r2
 8010616:	787b      	ldrb	r3, [r7, #1]
 8010618:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801061c:	b2db      	uxtb	r3, r3
 801061e:	4619      	mov	r1, r3
 8010620:	78fb      	ldrb	r3, [r7, #3]
 8010622:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8010626:	fb01 f303 	mul.w	r3, r1, r3
 801062a:	4413      	add	r3, r2
 801062c:	3380      	adds	r3, #128	; 0x80
 801062e:	461a      	mov	r2, r3
 8010630:	4613      	mov	r3, r2
 8010632:	021b      	lsls	r3, r3, #8
 8010634:	4413      	add	r3, r2
 8010636:	01db      	lsls	r3, r3, #7
 8010638:	4413      	add	r3, r2
 801063a:	0ddb      	lsrs	r3, r3, #23
 801063c:	f003 031f 	and.w	r3, r3, #31
 8010640:	b2da      	uxtb	r2, r3
 8010642:	7b7b      	ldrb	r3, [r7, #13]
 8010644:	f362 03c7 	bfi	r3, r2, #3, #5
 8010648:	737b      	strb	r3, [r7, #13]
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
 801064a:	88bb      	ldrh	r3, [r7, #4]
 801064c:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8010650:	b2db      	uxtb	r3, r3
 8010652:	461a      	mov	r2, r3
 8010654:	78fb      	ldrb	r3, [r7, #3]
 8010656:	fb03 f202 	mul.w	r2, r3, r2
 801065a:	883b      	ldrh	r3, [r7, #0]
 801065c:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8010660:	b2db      	uxtb	r3, r3
 8010662:	4619      	mov	r1, r3
 8010664:	78fb      	ldrb	r3, [r7, #3]
 8010666:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801066a:	fb01 f303 	mul.w	r3, r1, r3
 801066e:	4413      	add	r3, r2
 8010670:	3380      	adds	r3, #128	; 0x80
 8010672:	461a      	mov	r2, r3
 8010674:	4613      	mov	r3, r2
 8010676:	021b      	lsls	r3, r3, #8
 8010678:	4413      	add	r3, r2
 801067a:	01db      	lsls	r3, r3, #7
 801067c:	4413      	add	r3, r2
 801067e:	0ddb      	lsrs	r3, r3, #23
 8010680:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8010684:	b2da      	uxtb	r2, r3
 8010686:	89bb      	ldrh	r3, [r7, #12]
 8010688:	f362 134a 	bfi	r3, r2, #5, #6
 801068c:	81bb      	strh	r3, [r7, #12]
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
 801068e:	793b      	ldrb	r3, [r7, #4]
 8010690:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8010694:	b2db      	uxtb	r3, r3
 8010696:	461a      	mov	r2, r3
 8010698:	78fb      	ldrb	r3, [r7, #3]
 801069a:	fb03 f202 	mul.w	r2, r3, r2
 801069e:	783b      	ldrb	r3, [r7, #0]
 80106a0:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80106a4:	b2db      	uxtb	r3, r3
 80106a6:	4619      	mov	r1, r3
 80106a8:	78fb      	ldrb	r3, [r7, #3]
 80106aa:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80106ae:	fb01 f303 	mul.w	r3, r1, r3
 80106b2:	4413      	add	r3, r2
 80106b4:	3380      	adds	r3, #128	; 0x80
 80106b6:	461a      	mov	r2, r3
 80106b8:	4613      	mov	r3, r2
 80106ba:	021b      	lsls	r3, r3, #8
 80106bc:	4413      	add	r3, r2
 80106be:	01db      	lsls	r3, r3, #7
 80106c0:	4413      	add	r3, r2
 80106c2:	0ddb      	lsrs	r3, r3, #23
 80106c4:	f003 031f 	and.w	r3, r3, #31
 80106c8:	b2da      	uxtb	r2, r3
 80106ca:	7b3b      	ldrb	r3, [r7, #12]
 80106cc:	f362 0304 	bfi	r3, r2, #0, #5
 80106d0:	733b      	strb	r3, [r7, #12]
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
 80106d2:	89bb      	ldrh	r3, [r7, #12]
}
 80106d4:	4618      	mov	r0, r3
 80106d6:	3714      	adds	r7, #20
 80106d8:	46bd      	mov	sp, r7
 80106da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80106de:	4770      	bx	lr

080106e0 <lv_color_premult>:

LV_ATTRIBUTE_FAST_MEM static inline void lv_color_premult(lv_color_t c, uint8_t mix, uint16_t * out)
{
 80106e0:	b480      	push	{r7}
 80106e2:	b083      	sub	sp, #12
 80106e4:	af00      	add	r7, sp, #0
 80106e6:	80b8      	strh	r0, [r7, #4]
 80106e8:	460b      	mov	r3, r1
 80106ea:	603a      	str	r2, [r7, #0]
 80106ec:	71fb      	strb	r3, [r7, #7]
#if LV_COLOR_DEPTH != 1
    out[0] = (uint16_t) LV_COLOR_GET_R(c) * mix;
 80106ee:	797b      	ldrb	r3, [r7, #5]
 80106f0:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80106f4:	b2db      	uxtb	r3, r3
 80106f6:	b29a      	uxth	r2, r3
 80106f8:	79fb      	ldrb	r3, [r7, #7]
 80106fa:	b29b      	uxth	r3, r3
 80106fc:	fb12 f303 	smulbb	r3, r2, r3
 8010700:	b29a      	uxth	r2, r3
 8010702:	683b      	ldr	r3, [r7, #0]
 8010704:	801a      	strh	r2, [r3, #0]
    out[1] = (uint16_t) LV_COLOR_GET_G(c) * mix;
 8010706:	88bb      	ldrh	r3, [r7, #4]
 8010708:	f3c3 1345 	ubfx	r3, r3, #5, #6
 801070c:	b2db      	uxtb	r3, r3
 801070e:	b299      	uxth	r1, r3
 8010710:	79fb      	ldrb	r3, [r7, #7]
 8010712:	b29a      	uxth	r2, r3
 8010714:	683b      	ldr	r3, [r7, #0]
 8010716:	3302      	adds	r3, #2
 8010718:	fb11 f202 	smulbb	r2, r1, r2
 801071c:	b292      	uxth	r2, r2
 801071e:	801a      	strh	r2, [r3, #0]
    out[2] = (uint16_t) LV_COLOR_GET_B(c) * mix;
 8010720:	793b      	ldrb	r3, [r7, #4]
 8010722:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8010726:	b2db      	uxtb	r3, r3
 8010728:	b299      	uxth	r1, r3
 801072a:	79fb      	ldrb	r3, [r7, #7]
 801072c:	b29a      	uxth	r2, r3
 801072e:	683b      	ldr	r3, [r7, #0]
 8010730:	3304      	adds	r3, #4
 8010732:	fb11 f202 	smulbb	r2, r1, r2
 8010736:	b292      	uxth	r2, r2
 8010738:	801a      	strh	r2, [r3, #0]
    out[0] = LV_COLOR_GET_R(c);
    out[1] = LV_COLOR_GET_G(c);
    out[2] = LV_COLOR_GET_B(c);
#endif

}
 801073a:	bf00      	nop
 801073c:	370c      	adds	r7, #12
 801073e:	46bd      	mov	sp, r7
 8010740:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010744:	4770      	bx	lr

08010746 <lv_color_mix_premult>:
 *            Should be modified like mix = `255 - mix`
 * @return the mixed color
 * @note 255 won't give clearly `c1`.
 */
LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix_premult(uint16_t * premult_c1, lv_color_t c2, uint8_t mix)
{
 8010746:	b480      	push	{r7}
 8010748:	b085      	sub	sp, #20
 801074a:	af00      	add	r7, sp, #0
 801074c:	6078      	str	r0, [r7, #4]
 801074e:	8039      	strh	r1, [r7, #0]
 8010750:	4613      	mov	r3, r2
 8010752:	70fb      	strb	r3, [r7, #3]
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
 8010754:	687b      	ldr	r3, [r7, #4]
 8010756:	881b      	ldrh	r3, [r3, #0]
 8010758:	461a      	mov	r2, r3
 801075a:	787b      	ldrb	r3, [r7, #1]
 801075c:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8010760:	b2db      	uxtb	r3, r3
 8010762:	4619      	mov	r1, r3
 8010764:	78fb      	ldrb	r3, [r7, #3]
 8010766:	fb01 f303 	mul.w	r3, r1, r3
 801076a:	4413      	add	r3, r2
 801076c:	3380      	adds	r3, #128	; 0x80
 801076e:	461a      	mov	r2, r3
 8010770:	4613      	mov	r3, r2
 8010772:	021b      	lsls	r3, r3, #8
 8010774:	4413      	add	r3, r2
 8010776:	01db      	lsls	r3, r3, #7
 8010778:	4413      	add	r3, r2
 801077a:	0ddb      	lsrs	r3, r3, #23
 801077c:	f003 031f 	and.w	r3, r3, #31
 8010780:	b2da      	uxtb	r2, r3
 8010782:	7b7b      	ldrb	r3, [r7, #13]
 8010784:	f362 03c7 	bfi	r3, r2, #3, #5
 8010788:	737b      	strb	r3, [r7, #13]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
 801078a:	687b      	ldr	r3, [r7, #4]
 801078c:	3302      	adds	r3, #2
 801078e:	881b      	ldrh	r3, [r3, #0]
 8010790:	461a      	mov	r2, r3
 8010792:	883b      	ldrh	r3, [r7, #0]
 8010794:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8010798:	b2db      	uxtb	r3, r3
 801079a:	4619      	mov	r1, r3
 801079c:	78fb      	ldrb	r3, [r7, #3]
 801079e:	fb01 f303 	mul.w	r3, r1, r3
 80107a2:	4413      	add	r3, r2
 80107a4:	3380      	adds	r3, #128	; 0x80
 80107a6:	461a      	mov	r2, r3
 80107a8:	4613      	mov	r3, r2
 80107aa:	021b      	lsls	r3, r3, #8
 80107ac:	4413      	add	r3, r2
 80107ae:	01db      	lsls	r3, r3, #7
 80107b0:	4413      	add	r3, r2
 80107b2:	0ddb      	lsrs	r3, r3, #23
 80107b4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80107b8:	b2da      	uxtb	r2, r3
 80107ba:	89bb      	ldrh	r3, [r7, #12]
 80107bc:	f362 134a 	bfi	r3, r2, #5, #6
 80107c0:	81bb      	strh	r3, [r7, #12]
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
 80107c2:	687b      	ldr	r3, [r7, #4]
 80107c4:	3304      	adds	r3, #4
 80107c6:	881b      	ldrh	r3, [r3, #0]
 80107c8:	461a      	mov	r2, r3
 80107ca:	783b      	ldrb	r3, [r7, #0]
 80107cc:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80107d0:	b2db      	uxtb	r3, r3
 80107d2:	4619      	mov	r1, r3
 80107d4:	78fb      	ldrb	r3, [r7, #3]
 80107d6:	fb01 f303 	mul.w	r3, r1, r3
 80107da:	4413      	add	r3, r2
 80107dc:	3380      	adds	r3, #128	; 0x80
 80107de:	461a      	mov	r2, r3
 80107e0:	4613      	mov	r3, r2
 80107e2:	021b      	lsls	r3, r3, #8
 80107e4:	4413      	add	r3, r2
 80107e6:	01db      	lsls	r3, r3, #7
 80107e8:	4413      	add	r3, r2
 80107ea:	0ddb      	lsrs	r3, r3, #23
 80107ec:	f003 031f 	and.w	r3, r3, #31
 80107f0:	b2da      	uxtb	r2, r3
 80107f2:	7b3b      	ldrb	r3, [r7, #12]
 80107f4:	f362 0304 	bfi	r3, r2, #0, #5
 80107f8:	733b      	strb	r3, [r7, #12]
    LV_COLOR_SET_G(c1, premult_c1[1]);
    LV_COLOR_SET_B(c1, premult_c1[2]);
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
 80107fa:	89bb      	ldrh	r3, [r7, #12]
}
 80107fc:	4618      	mov	r0, r3
 80107fe:	3714      	adds	r7, #20
 8010800:	46bd      	mov	sp, r7
 8010802:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010806:	4770      	bx	lr

08010808 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 8010808:	b480      	push	{r7}
 801080a:	b083      	sub	sp, #12
 801080c:	af00      	add	r7, sp, #0
 801080e:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 8010810:	687b      	ldr	r3, [r7, #4]
 8010812:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8010816:	b29a      	uxth	r2, r3
 8010818:	687b      	ldr	r3, [r7, #4]
 801081a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801081e:	b29b      	uxth	r3, r3
 8010820:	1ad3      	subs	r3, r2, r3
 8010822:	b29b      	uxth	r3, r3
 8010824:	3301      	adds	r3, #1
 8010826:	b29b      	uxth	r3, r3
 8010828:	b21b      	sxth	r3, r3
}
 801082a:	4618      	mov	r0, r3
 801082c:	370c      	adds	r7, #12
 801082e:	46bd      	mov	sp, r7
 8010830:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010834:	4770      	bx	lr

08010836 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 8010836:	b480      	push	{r7}
 8010838:	b083      	sub	sp, #12
 801083a:	af00      	add	r7, sp, #0
 801083c:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 801083e:	687b      	ldr	r3, [r7, #4]
 8010840:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8010844:	b29a      	uxth	r2, r3
 8010846:	687b      	ldr	r3, [r7, #4]
 8010848:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801084c:	b29b      	uxth	r3, r3
 801084e:	1ad3      	subs	r3, r2, r3
 8010850:	b29b      	uxth	r3, r3
 8010852:	3301      	adds	r3, #1
 8010854:	b29b      	uxth	r3, r3
 8010856:	b21b      	sxth	r3, r3
}
 8010858:	4618      	mov	r0, r3
 801085a:	370c      	adds	r7, #12
 801085c:	46bd      	mov	sp, r7
 801085e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010862:	4770      	bx	lr

08010864 <_lv_blend_fill>:
 * @param mode blend mode from `lv_blend_mode_t`
 */
LV_ATTRIBUTE_FAST_MEM void _lv_blend_fill(const lv_area_t * clip_area, const lv_area_t * fill_area,
                                          lv_color_t color, lv_opa_t * mask, lv_draw_mask_res_t mask_res, lv_opa_t opa,
                                          lv_blend_mode_t mode)
{
 8010864:	b580      	push	{r7, lr}
 8010866:	b092      	sub	sp, #72	; 0x48
 8010868:	af04      	add	r7, sp, #16
 801086a:	60f8      	str	r0, [r7, #12]
 801086c:	60b9      	str	r1, [r7, #8]
 801086e:	80ba      	strh	r2, [r7, #4]
 8010870:	603b      	str	r3, [r7, #0]
    /*Do not draw transparent things*/
    if(opa < LV_OPA_MIN) return;
 8010872:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 8010876:	2b01      	cmp	r3, #1
 8010878:	f240 80b4 	bls.w	80109e4 <_lv_blend_fill+0x180>
    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;
 801087c:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 8010880:	2b00      	cmp	r3, #0
 8010882:	f000 80b1 	beq.w	80109e8 <_lv_blend_fill+0x184>

    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
 8010886:	f7fd fdab 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 801088a:	6338      	str	r0, [r7, #48]	; 0x30
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 801088c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801088e:	f00e f9bd 	bl	801ec0c <lv_disp_get_buf>
 8010892:	62f8      	str	r0, [r7, #44]	; 0x2c
    const lv_area_t * disp_area = &vdb->area;
 8010894:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010896:	3310      	adds	r3, #16
 8010898:	62bb      	str	r3, [r7, #40]	; 0x28
    lv_color_t * disp_buf = vdb->buf_act;
 801089a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801089c:	689b      	ldr	r3, [r3, #8]
 801089e:	627b      	str	r3, [r7, #36]	; 0x24

    /* Get clipped fill area which is the real draw area.
     * It is always the same or inside `fill_area` */
    lv_area_t draw_area;
    bool is_common;
    is_common = _lv_area_intersect(&draw_area, clip_area, fill_area);
 80108a0:	f107 0314 	add.w	r3, r7, #20
 80108a4:	68ba      	ldr	r2, [r7, #8]
 80108a6:	68f9      	ldr	r1, [r7, #12]
 80108a8:	4618      	mov	r0, r3
 80108aa:	f00e fddf 	bl	801f46c <_lv_area_intersect>
 80108ae:	4603      	mov	r3, r0
 80108b0:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    if(!is_common) return;
 80108b4:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80108b8:	f083 0301 	eor.w	r3, r3, #1
 80108bc:	b2db      	uxtb	r3, r3
 80108be:	2b00      	cmp	r3, #0
 80108c0:	f040 8094 	bne.w	80109ec <_lv_blend_fill+0x188>

    /* Now `draw_area` has absolute coordinates.
     * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
    draw_area.x1 -= disp_area->x1;
 80108c4:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80108c8:	b29a      	uxth	r2, r3
 80108ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80108cc:	f9b3 3000 	ldrsh.w	r3, [r3]
 80108d0:	b29b      	uxth	r3, r3
 80108d2:	1ad3      	subs	r3, r2, r3
 80108d4:	b29b      	uxth	r3, r3
 80108d6:	b21b      	sxth	r3, r3
 80108d8:	82bb      	strh	r3, [r7, #20]
    draw_area.y1 -= disp_area->y1;
 80108da:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80108de:	b29a      	uxth	r2, r3
 80108e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80108e2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80108e6:	b29b      	uxth	r3, r3
 80108e8:	1ad3      	subs	r3, r2, r3
 80108ea:	b29b      	uxth	r3, r3
 80108ec:	b21b      	sxth	r3, r3
 80108ee:	82fb      	strh	r3, [r7, #22]
    draw_area.x2 -= disp_area->x1;
 80108f0:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80108f4:	b29a      	uxth	r2, r3
 80108f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80108f8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80108fc:	b29b      	uxth	r3, r3
 80108fe:	1ad3      	subs	r3, r2, r3
 8010900:	b29b      	uxth	r3, r3
 8010902:	b21b      	sxth	r3, r3
 8010904:	833b      	strh	r3, [r7, #24]
    draw_area.y2 -= disp_area->y1;
 8010906:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801090a:	b29a      	uxth	r2, r3
 801090c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801090e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8010912:	b29b      	uxth	r3, r3
 8010914:	1ad3      	subs	r3, r2, r3
 8010916:	b29b      	uxth	r3, r3
 8010918:	b21b      	sxth	r3, r3
 801091a:	837b      	strh	r3, [r7, #26]

    /*Round the values in the mask if anti-aliasing is disabled*/
#if LV_ANTIALIAS
    if(mask && disp->driver.antialiasing == 0)
 801091c:	683b      	ldr	r3, [r7, #0]
 801091e:	2b00      	cmp	r3, #0
 8010920:	d025      	beq.n	801096e <_lv_blend_fill+0x10a>
 8010922:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010924:	7a1b      	ldrb	r3, [r3, #8]
 8010926:	f003 0301 	and.w	r3, r3, #1
 801092a:	b2db      	uxtb	r3, r3
 801092c:	2b00      	cmp	r3, #0
 801092e:	d11e      	bne.n	801096e <_lv_blend_fill+0x10a>
#else
    if(mask)
#endif
    {
        int32_t mask_w = lv_area_get_width(&draw_area);
 8010930:	f107 0314 	add.w	r3, r7, #20
 8010934:	4618      	mov	r0, r3
 8010936:	f7ff ff67 	bl	8010808 <lv_area_get_width>
 801093a:	4603      	mov	r3, r0
 801093c:	61fb      	str	r3, [r7, #28]
        int32_t i;
        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;
 801093e:	2300      	movs	r3, #0
 8010940:	637b      	str	r3, [r7, #52]	; 0x34
 8010942:	e010      	b.n	8010966 <_lv_blend_fill+0x102>
 8010944:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010946:	683a      	ldr	r2, [r7, #0]
 8010948:	4413      	add	r3, r2
 801094a:	781b      	ldrb	r3, [r3, #0]
 801094c:	2b80      	cmp	r3, #128	; 0x80
 801094e:	d901      	bls.n	8010954 <_lv_blend_fill+0xf0>
 8010950:	21ff      	movs	r1, #255	; 0xff
 8010952:	e000      	b.n	8010956 <_lv_blend_fill+0xf2>
 8010954:	2100      	movs	r1, #0
 8010956:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010958:	683a      	ldr	r2, [r7, #0]
 801095a:	4413      	add	r3, r2
 801095c:	460a      	mov	r2, r1
 801095e:	701a      	strb	r2, [r3, #0]
 8010960:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010962:	3301      	adds	r3, #1
 8010964:	637b      	str	r3, [r7, #52]	; 0x34
 8010966:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8010968:	69fb      	ldr	r3, [r7, #28]
 801096a:	429a      	cmp	r2, r3
 801096c:	dbea      	blt.n	8010944 <_lv_blend_fill+0xe0>
    }

    if(disp->driver.set_px_cb) {
 801096e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010970:	695b      	ldr	r3, [r3, #20]
 8010972:	2b00      	cmp	r3, #0
 8010974:	d00f      	beq.n	8010996 <_lv_blend_fill+0x132>
        fill_set_px(disp_area, disp_buf, &draw_area, color, opa, mask, mask_res);
 8010976:	f107 0214 	add.w	r2, r7, #20
 801097a:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 801097e:	9302      	str	r3, [sp, #8]
 8010980:	683b      	ldr	r3, [r7, #0]
 8010982:	9301      	str	r3, [sp, #4]
 8010984:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 8010988:	9300      	str	r3, [sp, #0]
 801098a:	88bb      	ldrh	r3, [r7, #4]
 801098c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801098e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8010990:	f000 f8fe 	bl	8010b90 <fill_set_px>
 8010994:	e02b      	b.n	80109ee <_lv_blend_fill+0x18a>
    }
    else if(mode == LV_BLEND_MODE_NORMAL) {
 8010996:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 801099a:	2b00      	cmp	r3, #0
 801099c:	d10f      	bne.n	80109be <_lv_blend_fill+0x15a>
        fill_normal(disp_area, disp_buf, &draw_area, color, opa, mask, mask_res);
 801099e:	f107 0214 	add.w	r2, r7, #20
 80109a2:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 80109a6:	9302      	str	r3, [sp, #8]
 80109a8:	683b      	ldr	r3, [r7, #0]
 80109aa:	9301      	str	r3, [sp, #4]
 80109ac:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 80109b0:	9300      	str	r3, [sp, #0]
 80109b2:	88bb      	ldrh	r3, [r7, #4]
 80109b4:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80109b6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80109b8:	f000 f986 	bl	8010cc8 <fill_normal>
 80109bc:	e017      	b.n	80109ee <_lv_blend_fill+0x18a>
    }
#if LV_USE_BLEND_MODES
    else {
        fill_blended(disp_area, disp_buf, &draw_area, color, opa, mask, mask_res, mode);
 80109be:	f107 0214 	add.w	r2, r7, #20
 80109c2:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 80109c6:	9303      	str	r3, [sp, #12]
 80109c8:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 80109cc:	9302      	str	r3, [sp, #8]
 80109ce:	683b      	ldr	r3, [r7, #0]
 80109d0:	9301      	str	r3, [sp, #4]
 80109d2:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 80109d6:	9300      	str	r3, [sp, #0]
 80109d8:	88bb      	ldrh	r3, [r7, #4]
 80109da:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80109dc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80109de:	f000 fc39 	bl	8011254 <fill_blended>
 80109e2:	e004      	b.n	80109ee <_lv_blend_fill+0x18a>
    if(opa < LV_OPA_MIN) return;
 80109e4:	bf00      	nop
 80109e6:	e002      	b.n	80109ee <_lv_blend_fill+0x18a>
    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;
 80109e8:	bf00      	nop
 80109ea:	e000      	b.n	80109ee <_lv_blend_fill+0x18a>
    if(!is_common) return;
 80109ec:	bf00      	nop
    }
#endif
}
 80109ee:	3738      	adds	r7, #56	; 0x38
 80109f0:	46bd      	mov	sp, r7
 80109f2:	bd80      	pop	{r7, pc}

080109f4 <_lv_blend_map>:
 */
LV_ATTRIBUTE_FAST_MEM void _lv_blend_map(const lv_area_t * clip_area, const lv_area_t * map_area,
                                         const lv_color_t * map_buf,
                                         lv_opa_t * mask, lv_draw_mask_res_t mask_res,
                                         lv_opa_t opa, lv_blend_mode_t mode)
{
 80109f4:	b580      	push	{r7, lr}
 80109f6:	b094      	sub	sp, #80	; 0x50
 80109f8:	af06      	add	r7, sp, #24
 80109fa:	60f8      	str	r0, [r7, #12]
 80109fc:	60b9      	str	r1, [r7, #8]
 80109fe:	607a      	str	r2, [r7, #4]
 8010a00:	603b      	str	r3, [r7, #0]
    /*Do not draw transparent things*/
    if(opa < LV_OPA_MIN) return;
 8010a02:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 8010a06:	2b01      	cmp	r3, #1
 8010a08:	f240 80ba 	bls.w	8010b80 <_lv_blend_map+0x18c>
    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;
 8010a0c:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 8010a10:	2b00      	cmp	r3, #0
 8010a12:	f000 80b7 	beq.w	8010b84 <_lv_blend_map+0x190>

    /* Get clipped fill area which is the real draw area.
     * It is always the same or inside `fill_area` */
    lv_area_t draw_area;
    bool is_common;
    is_common = _lv_area_intersect(&draw_area, clip_area, map_area);
 8010a16:	f107 0314 	add.w	r3, r7, #20
 8010a1a:	68ba      	ldr	r2, [r7, #8]
 8010a1c:	68f9      	ldr	r1, [r7, #12]
 8010a1e:	4618      	mov	r0, r3
 8010a20:	f00e fd24 	bl	801f46c <_lv_area_intersect>
 8010a24:	4603      	mov	r3, r0
 8010a26:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    if(!is_common) return;
 8010a2a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8010a2e:	f083 0301 	eor.w	r3, r3, #1
 8010a32:	b2db      	uxtb	r3, r3
 8010a34:	2b00      	cmp	r3, #0
 8010a36:	f040 80a7 	bne.w	8010b88 <_lv_blend_map+0x194>

    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
 8010a3a:	f7fd fcd1 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 8010a3e:	62f8      	str	r0, [r7, #44]	; 0x2c
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8010a40:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8010a42:	f00e f8e3 	bl	801ec0c <lv_disp_get_buf>
 8010a46:	62b8      	str	r0, [r7, #40]	; 0x28
    const lv_area_t * disp_area = &vdb->area;
 8010a48:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010a4a:	3310      	adds	r3, #16
 8010a4c:	627b      	str	r3, [r7, #36]	; 0x24
    lv_color_t * disp_buf = vdb->buf_act;
 8010a4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010a50:	689b      	ldr	r3, [r3, #8]
 8010a52:	623b      	str	r3, [r7, #32]

    /* Now `draw_area` has absolute coordinates.
     * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
    draw_area.x1 -= disp_area->x1;
 8010a54:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8010a58:	b29a      	uxth	r2, r3
 8010a5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010a5c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010a60:	b29b      	uxth	r3, r3
 8010a62:	1ad3      	subs	r3, r2, r3
 8010a64:	b29b      	uxth	r3, r3
 8010a66:	b21b      	sxth	r3, r3
 8010a68:	82bb      	strh	r3, [r7, #20]
    draw_area.y1 -= disp_area->y1;
 8010a6a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8010a6e:	b29a      	uxth	r2, r3
 8010a70:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010a72:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8010a76:	b29b      	uxth	r3, r3
 8010a78:	1ad3      	subs	r3, r2, r3
 8010a7a:	b29b      	uxth	r3, r3
 8010a7c:	b21b      	sxth	r3, r3
 8010a7e:	82fb      	strh	r3, [r7, #22]
    draw_area.x2 -= disp_area->x1;
 8010a80:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8010a84:	b29a      	uxth	r2, r3
 8010a86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010a88:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010a8c:	b29b      	uxth	r3, r3
 8010a8e:	1ad3      	subs	r3, r2, r3
 8010a90:	b29b      	uxth	r3, r3
 8010a92:	b21b      	sxth	r3, r3
 8010a94:	833b      	strh	r3, [r7, #24]
    draw_area.y2 -= disp_area->y1;
 8010a96:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8010a9a:	b29a      	uxth	r2, r3
 8010a9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010a9e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8010aa2:	b29b      	uxth	r3, r3
 8010aa4:	1ad3      	subs	r3, r2, r3
 8010aa6:	b29b      	uxth	r3, r3
 8010aa8:	b21b      	sxth	r3, r3
 8010aaa:	837b      	strh	r3, [r7, #26]

    /*Round the values in the mask if anti-aliasing is disabled*/
#if LV_ANTIALIAS
    if(mask && disp->driver.antialiasing == 0)
 8010aac:	683b      	ldr	r3, [r7, #0]
 8010aae:	2b00      	cmp	r3, #0
 8010ab0:	d025      	beq.n	8010afe <_lv_blend_map+0x10a>
 8010ab2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010ab4:	7a1b      	ldrb	r3, [r3, #8]
 8010ab6:	f003 0301 	and.w	r3, r3, #1
 8010aba:	b2db      	uxtb	r3, r3
 8010abc:	2b00      	cmp	r3, #0
 8010abe:	d11e      	bne.n	8010afe <_lv_blend_map+0x10a>
#else
    if(mask)
#endif
    {
        int32_t mask_w = lv_area_get_width(&draw_area);
 8010ac0:	f107 0314 	add.w	r3, r7, #20
 8010ac4:	4618      	mov	r0, r3
 8010ac6:	f7ff fe9f 	bl	8010808 <lv_area_get_width>
 8010aca:	4603      	mov	r3, r0
 8010acc:	61fb      	str	r3, [r7, #28]
        int32_t i;
        for(i = 0; i < mask_w; i++)  mask[i] = mask[i] > 128 ? LV_OPA_COVER : LV_OPA_TRANSP;
 8010ace:	2300      	movs	r3, #0
 8010ad0:	637b      	str	r3, [r7, #52]	; 0x34
 8010ad2:	e010      	b.n	8010af6 <_lv_blend_map+0x102>
 8010ad4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010ad6:	683a      	ldr	r2, [r7, #0]
 8010ad8:	4413      	add	r3, r2
 8010ada:	781b      	ldrb	r3, [r3, #0]
 8010adc:	2b80      	cmp	r3, #128	; 0x80
 8010ade:	d901      	bls.n	8010ae4 <_lv_blend_map+0xf0>
 8010ae0:	21ff      	movs	r1, #255	; 0xff
 8010ae2:	e000      	b.n	8010ae6 <_lv_blend_map+0xf2>
 8010ae4:	2100      	movs	r1, #0
 8010ae6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010ae8:	683a      	ldr	r2, [r7, #0]
 8010aea:	4413      	add	r3, r2
 8010aec:	460a      	mov	r2, r1
 8010aee:	701a      	strb	r2, [r3, #0]
 8010af0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010af2:	3301      	adds	r3, #1
 8010af4:	637b      	str	r3, [r7, #52]	; 0x34
 8010af6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8010af8:	69fb      	ldr	r3, [r7, #28]
 8010afa:	429a      	cmp	r2, r3
 8010afc:	dbea      	blt.n	8010ad4 <_lv_blend_map+0xe0>
    }
    if(disp->driver.set_px_cb) {
 8010afe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010b00:	695b      	ldr	r3, [r3, #20]
 8010b02:	2b00      	cmp	r3, #0
 8010b04:	d011      	beq.n	8010b2a <_lv_blend_map+0x136>
        map_set_px(disp_area, disp_buf, &draw_area, map_area, map_buf, opa, mask, mask_res);
 8010b06:	f107 0214 	add.w	r2, r7, #20
 8010b0a:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 8010b0e:	9303      	str	r3, [sp, #12]
 8010b10:	683b      	ldr	r3, [r7, #0]
 8010b12:	9302      	str	r3, [sp, #8]
 8010b14:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 8010b18:	9301      	str	r3, [sp, #4]
 8010b1a:	687b      	ldr	r3, [r7, #4]
 8010b1c:	9300      	str	r3, [sp, #0]
 8010b1e:	68bb      	ldr	r3, [r7, #8]
 8010b20:	6a39      	ldr	r1, [r7, #32]
 8010b22:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010b24:	f000 fca4 	bl	8011470 <map_set_px>
 8010b28:	e02f      	b.n	8010b8a <_lv_blend_map+0x196>
    }
    else if(mode == LV_BLEND_MODE_NORMAL) {
 8010b2a:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 8010b2e:	2b00      	cmp	r3, #0
 8010b30:	d111      	bne.n	8010b56 <_lv_blend_map+0x162>
        map_normal(disp_area, disp_buf, &draw_area, map_area, map_buf, opa, mask, mask_res);
 8010b32:	f107 0214 	add.w	r2, r7, #20
 8010b36:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 8010b3a:	9303      	str	r3, [sp, #12]
 8010b3c:	683b      	ldr	r3, [r7, #0]
 8010b3e:	9302      	str	r3, [sp, #8]
 8010b40:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 8010b44:	9301      	str	r3, [sp, #4]
 8010b46:	687b      	ldr	r3, [r7, #4]
 8010b48:	9300      	str	r3, [sp, #0]
 8010b4a:	68bb      	ldr	r3, [r7, #8]
 8010b4c:	6a39      	ldr	r1, [r7, #32]
 8010b4e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010b50:	f000 fd6f 	bl	8011632 <map_normal>
 8010b54:	e019      	b.n	8010b8a <_lv_blend_map+0x196>
    }
#if LV_USE_BLEND_MODES
    else {
        map_blended(disp_area, disp_buf, &draw_area, map_area, map_buf, opa, mask, mask_res, mode);
 8010b56:	f107 0214 	add.w	r2, r7, #20
 8010b5a:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 8010b5e:	9304      	str	r3, [sp, #16]
 8010b60:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 8010b64:	9303      	str	r3, [sp, #12]
 8010b66:	683b      	ldr	r3, [r7, #0]
 8010b68:	9302      	str	r3, [sp, #8]
 8010b6a:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 8010b6e:	9301      	str	r3, [sp, #4]
 8010b70:	687b      	ldr	r3, [r7, #4]
 8010b72:	9300      	str	r3, [sp, #0]
 8010b74:	68bb      	ldr	r3, [r7, #8]
 8010b76:	6a39      	ldr	r1, [r7, #32]
 8010b78:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010b7a:	f001 f81d 	bl	8011bb8 <map_blended>
 8010b7e:	e004      	b.n	8010b8a <_lv_blend_map+0x196>
    if(opa < LV_OPA_MIN) return;
 8010b80:	bf00      	nop
 8010b82:	e002      	b.n	8010b8a <_lv_blend_map+0x196>
    if(mask_res == LV_DRAW_MASK_RES_TRANSP) return;
 8010b84:	bf00      	nop
 8010b86:	e000      	b.n	8010b8a <_lv_blend_map+0x196>
    if(!is_common) return;
 8010b88:	bf00      	nop
    }
#endif
}
 8010b8a:	3738      	adds	r7, #56	; 0x38
 8010b8c:	46bd      	mov	sp, r7
 8010b8e:	bd80      	pop	{r7, pc}

08010b90 <fill_set_px>:
 **********************/

static void fill_set_px(const lv_area_t * disp_area, lv_color_t * disp_buf,  const lv_area_t * draw_area,
                        lv_color_t color, lv_opa_t opa,
                        const lv_opa_t * mask, lv_draw_mask_res_t mask_res)
{
 8010b90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8010b92:	b08f      	sub	sp, #60	; 0x3c
 8010b94:	af04      	add	r7, sp, #16
 8010b96:	60f8      	str	r0, [r7, #12]
 8010b98:	60b9      	str	r1, [r7, #8]
 8010b9a:	607a      	str	r2, [r7, #4]
 8010b9c:	803b      	strh	r3, [r7, #0]

    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
 8010b9e:	f7fd fc1f 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 8010ba2:	61b8      	str	r0, [r7, #24]

    /*Get the width of the `disp_area` it will be used to go to the next line*/
    int32_t disp_w = lv_area_get_width(disp_area);
 8010ba4:	68f8      	ldr	r0, [r7, #12]
 8010ba6:	f7ff fe2f 	bl	8010808 <lv_area_get_width>
 8010baa:	4603      	mov	r3, r0
 8010bac:	617b      	str	r3, [r7, #20]

    int32_t x;
    int32_t y;

    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
 8010bae:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 8010bb2:	2b01      	cmp	r3, #1
 8010bb4:	d132      	bne.n	8010c1c <fill_set_px+0x8c>
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8010bb6:	687b      	ldr	r3, [r7, #4]
 8010bb8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8010bbc:	623b      	str	r3, [r7, #32]
 8010bbe:	e025      	b.n	8010c0c <fill_set_px+0x7c>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8010bc0:	687b      	ldr	r3, [r7, #4]
 8010bc2:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010bc6:	627b      	str	r3, [r7, #36]	; 0x24
 8010bc8:	e016      	b.n	8010bf8 <fill_set_px+0x68>
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color, opa);
 8010bca:	69bb      	ldr	r3, [r7, #24]
 8010bcc:	695c      	ldr	r4, [r3, #20]
 8010bce:	69b8      	ldr	r0, [r7, #24]
 8010bd0:	697b      	ldr	r3, [r7, #20]
 8010bd2:	b219      	sxth	r1, r3
 8010bd4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010bd6:	b21d      	sxth	r5, r3
 8010bd8:	6a3b      	ldr	r3, [r7, #32]
 8010bda:	b21b      	sxth	r3, r3
 8010bdc:	f897 2040 	ldrb.w	r2, [r7, #64]	; 0x40
 8010be0:	9202      	str	r2, [sp, #8]
 8010be2:	883a      	ldrh	r2, [r7, #0]
 8010be4:	f8ad 2004 	strh.w	r2, [sp, #4]
 8010be8:	9300      	str	r3, [sp, #0]
 8010bea:	462b      	mov	r3, r5
 8010bec:	460a      	mov	r2, r1
 8010bee:	68b9      	ldr	r1, [r7, #8]
 8010bf0:	47a0      	blx	r4
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8010bf2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010bf4:	3301      	adds	r3, #1
 8010bf6:	627b      	str	r3, [r7, #36]	; 0x24
 8010bf8:	687b      	ldr	r3, [r7, #4]
 8010bfa:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8010bfe:	461a      	mov	r2, r3
 8010c00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010c02:	4293      	cmp	r3, r2
 8010c04:	dde1      	ble.n	8010bca <fill_set_px+0x3a>
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8010c06:	6a3b      	ldr	r3, [r7, #32]
 8010c08:	3301      	adds	r3, #1
 8010c0a:	623b      	str	r3, [r7, #32]
 8010c0c:	687b      	ldr	r3, [r7, #4]
 8010c0e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8010c12:	461a      	mov	r2, r3
 8010c14:	6a3b      	ldr	r3, [r7, #32]
 8010c16:	4293      	cmp	r3, r2
 8010c18:	ddd2      	ble.n	8010bc0 <fill_set_px+0x30>
                }
            }
            mask_tmp += draw_area_w;
        }
    }
}
 8010c1a:	e051      	b.n	8010cc0 <fill_set_px+0x130>
        const lv_opa_t * mask_tmp = mask - draw_area->x1;
 8010c1c:	687b      	ldr	r3, [r7, #4]
 8010c1e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010c22:	425b      	negs	r3, r3
 8010c24:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8010c26:	4413      	add	r3, r2
 8010c28:	61fb      	str	r3, [r7, #28]
        int32_t draw_area_w = lv_area_get_width(draw_area);
 8010c2a:	6878      	ldr	r0, [r7, #4]
 8010c2c:	f7ff fdec 	bl	8010808 <lv_area_get_width>
 8010c30:	4603      	mov	r3, r0
 8010c32:	613b      	str	r3, [r7, #16]
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8010c34:	687b      	ldr	r3, [r7, #4]
 8010c36:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8010c3a:	623b      	str	r3, [r7, #32]
 8010c3c:	e039      	b.n	8010cb2 <fill_set_px+0x122>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8010c3e:	687b      	ldr	r3, [r7, #4]
 8010c40:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010c44:	627b      	str	r3, [r7, #36]	; 0x24
 8010c46:	e026      	b.n	8010c96 <fill_set_px+0x106>
                if(mask_tmp[x]) {
 8010c48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010c4a:	69fa      	ldr	r2, [r7, #28]
 8010c4c:	4413      	add	r3, r2
 8010c4e:	781b      	ldrb	r3, [r3, #0]
 8010c50:	2b00      	cmp	r3, #0
 8010c52:	d01d      	beq.n	8010c90 <fill_set_px+0x100>
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color,
 8010c54:	69bb      	ldr	r3, [r7, #24]
 8010c56:	695c      	ldr	r4, [r3, #20]
 8010c58:	69bd      	ldr	r5, [r7, #24]
 8010c5a:	697b      	ldr	r3, [r7, #20]
 8010c5c:	b21e      	sxth	r6, r3
 8010c5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010c60:	fa0f fc83 	sxth.w	ip, r3
 8010c64:	6a3b      	ldr	r3, [r7, #32]
 8010c66:	b21b      	sxth	r3, r3
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
 8010c68:	f897 2040 	ldrb.w	r2, [r7, #64]	; 0x40
 8010c6c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8010c6e:	69f8      	ldr	r0, [r7, #28]
 8010c70:	4401      	add	r1, r0
 8010c72:	7809      	ldrb	r1, [r1, #0]
 8010c74:	fb01 f202 	mul.w	r2, r1, r2
 8010c78:	0a12      	lsrs	r2, r2, #8
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, color,
 8010c7a:	b2d2      	uxtb	r2, r2
 8010c7c:	9202      	str	r2, [sp, #8]
 8010c7e:	883a      	ldrh	r2, [r7, #0]
 8010c80:	f8ad 2004 	strh.w	r2, [sp, #4]
 8010c84:	9300      	str	r3, [sp, #0]
 8010c86:	4663      	mov	r3, ip
 8010c88:	4632      	mov	r2, r6
 8010c8a:	68b9      	ldr	r1, [r7, #8]
 8010c8c:	4628      	mov	r0, r5
 8010c8e:	47a0      	blx	r4
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8010c90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010c92:	3301      	adds	r3, #1
 8010c94:	627b      	str	r3, [r7, #36]	; 0x24
 8010c96:	687b      	ldr	r3, [r7, #4]
 8010c98:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8010c9c:	461a      	mov	r2, r3
 8010c9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ca0:	4293      	cmp	r3, r2
 8010ca2:	ddd1      	ble.n	8010c48 <fill_set_px+0xb8>
            mask_tmp += draw_area_w;
 8010ca4:	693b      	ldr	r3, [r7, #16]
 8010ca6:	69fa      	ldr	r2, [r7, #28]
 8010ca8:	4413      	add	r3, r2
 8010caa:	61fb      	str	r3, [r7, #28]
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8010cac:	6a3b      	ldr	r3, [r7, #32]
 8010cae:	3301      	adds	r3, #1
 8010cb0:	623b      	str	r3, [r7, #32]
 8010cb2:	687b      	ldr	r3, [r7, #4]
 8010cb4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8010cb8:	461a      	mov	r2, r3
 8010cba:	6a3b      	ldr	r3, [r7, #32]
 8010cbc:	4293      	cmp	r3, r2
 8010cbe:	ddbe      	ble.n	8010c3e <fill_set_px+0xae>
}
 8010cc0:	bf00      	nop
 8010cc2:	372c      	adds	r7, #44	; 0x2c
 8010cc4:	46bd      	mov	sp, r7
 8010cc6:	bdf0      	pop	{r4, r5, r6, r7, pc}

08010cc8 <fill_normal>:
 */
LV_ATTRIBUTE_FAST_MEM static void fill_normal(const lv_area_t * disp_area, lv_color_t * disp_buf,
                                              const lv_area_t * draw_area,
                                              lv_color_t color, lv_opa_t opa,
                                              const lv_opa_t * mask, lv_draw_mask_res_t mask_res)
{
 8010cc8:	b590      	push	{r4, r7, lr}
 8010cca:	b09b      	sub	sp, #108	; 0x6c
 8010ccc:	af02      	add	r7, sp, #8
 8010cce:	60f8      	str	r0, [r7, #12]
 8010cd0:	60b9      	str	r1, [r7, #8]
 8010cd2:	607a      	str	r2, [r7, #4]
 8010cd4:	803b      	strh	r3, [r7, #0]

#if LV_USE_GPU || LV_COLOR_SCREEN_TRANSP
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
 8010cd6:	f7fd fb83 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 8010cda:	63f8      	str	r0, [r7, #60]	; 0x3c
#endif

    /*Get the width of the `disp_area` it will be used to go to the next line*/
    int32_t disp_w = lv_area_get_width(disp_area);
 8010cdc:	68f8      	ldr	r0, [r7, #12]
 8010cde:	f7ff fd93 	bl	8010808 <lv_area_get_width>
 8010ce2:	4603      	mov	r3, r0
 8010ce4:	63bb      	str	r3, [r7, #56]	; 0x38

    int32_t draw_area_w = lv_area_get_width(draw_area);
 8010ce6:	6878      	ldr	r0, [r7, #4]
 8010ce8:	f7ff fd8e 	bl	8010808 <lv_area_get_width>
 8010cec:	4603      	mov	r3, r0
 8010cee:	637b      	str	r3, [r7, #52]	; 0x34
    int32_t draw_area_h = lv_area_get_height(draw_area);
 8010cf0:	6878      	ldr	r0, [r7, #4]
 8010cf2:	f7ff fda0 	bl	8010836 <lv_area_get_height>
 8010cf6:	4603      	mov	r3, r0
 8010cf8:	633b      	str	r3, [r7, #48]	; 0x30

    /*Create a temp. disp_buf which always point to the first pixel of the destination area*/
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
 8010cfa:	687b      	ldr	r3, [r7, #4]
 8010cfc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8010d00:	461a      	mov	r2, r3
 8010d02:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010d04:	fb02 f303 	mul.w	r3, r2, r3
 8010d08:	461a      	mov	r2, r3
 8010d0a:	687b      	ldr	r3, [r7, #4]
 8010d0c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8010d10:	4413      	add	r3, r2
 8010d12:	005b      	lsls	r3, r3, #1
 8010d14:	68ba      	ldr	r2, [r7, #8]
 8010d16:	4413      	add	r3, r2
 8010d18:	65fb      	str	r3, [r7, #92]	; 0x5c

    int32_t x;
    int32_t y;

    /*Simple fill (maybe with opacity), no masking*/
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
 8010d1a:	f897 3078 	ldrb.w	r3, [r7, #120]	; 0x78
 8010d1e:	2b01      	cmp	r3, #1
 8010d20:	f040 80ca 	bne.w	8010eb8 <fill_normal+0x1f0>
        if(opa > LV_OPA_MAX) {
 8010d24:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
 8010d28:	2bfd      	cmp	r3, #253	; 0xfd
 8010d2a:	d92b      	bls.n	8010d84 <fill_normal+0xbc>
#if LV_USE_GPU
            if(disp->driver.gpu_fill_cb && lv_area_get_size(draw_area) > GPU_SIZE_LIMIT) {
 8010d2c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010d2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010d30:	2b00      	cmp	r3, #0
 8010d32:	d011      	beq.n	8010d58 <fill_normal+0x90>
 8010d34:	6878      	ldr	r0, [r7, #4]
 8010d36:	f00e fb78 	bl	801f42a <lv_area_get_size>
 8010d3a:	4603      	mov	r3, r0
 8010d3c:	2bf0      	cmp	r3, #240	; 0xf0
 8010d3e:	d90b      	bls.n	8010d58 <fill_normal+0x90>
                disp->driver.gpu_fill_cb(&disp->driver, disp_buf, disp_w, draw_area, color);
 8010d40:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010d42:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8010d44:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8010d46:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010d48:	b21a      	sxth	r2, r3
 8010d4a:	883b      	ldrh	r3, [r7, #0]
 8010d4c:	f8ad 3000 	strh.w	r3, [sp]
 8010d50:	687b      	ldr	r3, [r7, #4]
 8010d52:	68b9      	ldr	r1, [r7, #8]
 8010d54:	47a0      	blx	r4
                return;
 8010d56:	e27a      	b.n	801124e <fill_normal+0x586>
                lv_gpu_stm32_dma2d_fill(disp_buf_first, disp_w, color, draw_area_w, draw_area_h);
                return;
            }
#endif
            /*Software rendering*/
            for(y = 0; y < draw_area_h; y++) {
 8010d58:	2300      	movs	r3, #0
 8010d5a:	657b      	str	r3, [r7, #84]	; 0x54
 8010d5c:	e00d      	b.n	8010d7a <fill_normal+0xb2>
                lv_color_fill(disp_buf_first, color, draw_area_w);
 8010d5e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010d60:	461a      	mov	r2, r3
 8010d62:	8839      	ldrh	r1, [r7, #0]
 8010d64:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 8010d66:	f00f f92e 	bl	801ffc6 <lv_color_fill>
                disp_buf_first += disp_w;
 8010d6a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010d6c:	005b      	lsls	r3, r3, #1
 8010d6e:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010d70:	4413      	add	r3, r2
 8010d72:	65fb      	str	r3, [r7, #92]	; 0x5c
            for(y = 0; y < draw_area_h; y++) {
 8010d74:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010d76:	3301      	adds	r3, #1
 8010d78:	657b      	str	r3, [r7, #84]	; 0x54
 8010d7a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8010d7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010d7e:	429a      	cmp	r2, r3
 8010d80:	dbed      	blt.n	8010d5e <fill_normal+0x96>
 8010d82:	e264      	b.n	801124e <fill_normal+0x586>
            }
        }
        /*No mask with opacity*/
        else {
#if LV_USE_GPU
            if(disp->driver.gpu_blend_cb && lv_area_get_size(draw_area) > GPU_SIZE_LIMIT) {
 8010d84:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010d86:	6a1b      	ldr	r3, [r3, #32]
 8010d88:	2b00      	cmp	r3, #0
 8010d8a:	d034      	beq.n	8010df6 <fill_normal+0x12e>
 8010d8c:	6878      	ldr	r0, [r7, #4]
 8010d8e:	f00e fb4c 	bl	801f42a <lv_area_get_size>
 8010d92:	4603      	mov	r3, r0
 8010d94:	2bf0      	cmp	r3, #240	; 0xf0
 8010d96:	d92e      	bls.n	8010df6 <fill_normal+0x12e>
                for(x = 0; x < draw_area_w ; x++) blend_buf[x].full = color.full;
 8010d98:	2300      	movs	r3, #0
 8010d9a:	65bb      	str	r3, [r7, #88]	; 0x58
 8010d9c:	e007      	b.n	8010dae <fill_normal+0xe6>
 8010d9e:	8839      	ldrh	r1, [r7, #0]
 8010da0:	4a98      	ldr	r2, [pc, #608]	; (8011004 <fill_normal+0x33c>)
 8010da2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010da4:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
 8010da8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010daa:	3301      	adds	r3, #1
 8010dac:	65bb      	str	r3, [r7, #88]	; 0x58
 8010dae:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010db0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010db2:	429a      	cmp	r2, r3
 8010db4:	dbf3      	blt.n	8010d9e <fill_normal+0xd6>

                for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8010db6:	687b      	ldr	r3, [r7, #4]
 8010db8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8010dbc:	657b      	str	r3, [r7, #84]	; 0x54
 8010dbe:	e012      	b.n	8010de6 <fill_normal+0x11e>
                    disp->driver.gpu_blend_cb(&disp->driver, disp_buf_first, blend_buf, draw_area_w, opa);
 8010dc0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8010dc2:	6a1c      	ldr	r4, [r3, #32]
 8010dc4:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8010dc6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8010dc8:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
 8010dcc:	9300      	str	r3, [sp, #0]
 8010dce:	4613      	mov	r3, r2
 8010dd0:	4a8c      	ldr	r2, [pc, #560]	; (8011004 <fill_normal+0x33c>)
 8010dd2:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8010dd4:	47a0      	blx	r4
                    disp_buf_first += disp_w;
 8010dd6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010dd8:	005b      	lsls	r3, r3, #1
 8010dda:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010ddc:	4413      	add	r3, r2
 8010dde:	65fb      	str	r3, [r7, #92]	; 0x5c
                for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8010de0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010de2:	3301      	adds	r3, #1
 8010de4:	657b      	str	r3, [r7, #84]	; 0x54
 8010de6:	687b      	ldr	r3, [r7, #4]
 8010de8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8010dec:	461a      	mov	r2, r3
 8010dee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010df0:	4293      	cmp	r3, r2
 8010df2:	dde5      	ble.n	8010dc0 <fill_normal+0xf8>
                }
                return;
 8010df4:	e22b      	b.n	801124e <fill_normal+0x586>
                }

                return;
            }
#endif
            lv_color_t last_dest_color = LV_COLOR_BLACK;
 8010df6:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8010dfa:	f36f 0304 	bfc	r3, #0, #5
 8010dfe:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
 8010e02:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8010e04:	f36f 134a 	bfc	r3, #5, #6
 8010e08:	853b      	strh	r3, [r7, #40]	; 0x28
 8010e0a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8010e0e:	f36f 03c7 	bfc	r3, #3, #5
 8010e12:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
            lv_color_t last_res_color = lv_color_mix(color, last_dest_color, opa);
 8010e16:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
 8010e1a:	461a      	mov	r2, r3
 8010e1c:	8d39      	ldrh	r1, [r7, #40]	; 0x28
 8010e1e:	8838      	ldrh	r0, [r7, #0]
 8010e20:	f7ff fbea 	bl	80105f8 <lv_color_mix>
 8010e24:	4603      	mov	r3, r0
 8010e26:	84bb      	strh	r3, [r7, #36]	; 0x24

            uint16_t color_premult[3];
            lv_color_premult(color, opa, color_premult);
 8010e28:	f107 021c 	add.w	r2, r7, #28
 8010e2c:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
 8010e30:	4619      	mov	r1, r3
 8010e32:	8838      	ldrh	r0, [r7, #0]
 8010e34:	f7ff fc54 	bl	80106e0 <lv_color_premult>
            lv_opa_t opa_inv = 255 - opa;
 8010e38:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
 8010e3c:	43db      	mvns	r3, r3
 8010e3e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

            for(y = 0; y < draw_area_h; y++) {
 8010e42:	2300      	movs	r3, #0
 8010e44:	657b      	str	r3, [r7, #84]	; 0x54
 8010e46:	e032      	b.n	8010eae <fill_normal+0x1e6>
                for(x = 0; x < draw_area_w; x++) {
 8010e48:	2300      	movs	r3, #0
 8010e4a:	65bb      	str	r3, [r7, #88]	; 0x58
 8010e4c:	e023      	b.n	8010e96 <fill_normal+0x1ce>
                    if(last_dest_color.full != disp_buf_first[x].full) {
 8010e4e:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8010e50:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010e52:	005b      	lsls	r3, r3, #1
 8010e54:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8010e56:	440b      	add	r3, r1
 8010e58:	881b      	ldrh	r3, [r3, #0]
 8010e5a:	429a      	cmp	r2, r3
 8010e5c:	d012      	beq.n	8010e84 <fill_normal+0x1bc>
                        last_dest_color = disp_buf_first[x];
 8010e5e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010e60:	005b      	lsls	r3, r3, #1
 8010e62:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010e64:	4413      	add	r3, r2
 8010e66:	881b      	ldrh	r3, [r3, #0]
 8010e68:	853b      	strh	r3, [r7, #40]	; 0x28
                                                    &last_res_color.ch.alpha);
                        }
                        else
#endif
                        {
                            last_res_color = lv_color_mix_premult(color_premult, disp_buf_first[x], opa_inv);
 8010e6a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010e6c:	005b      	lsls	r3, r3, #1
 8010e6e:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010e70:	4413      	add	r3, r2
 8010e72:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
 8010e76:	f107 001c 	add.w	r0, r7, #28
 8010e7a:	8819      	ldrh	r1, [r3, #0]
 8010e7c:	f7ff fc63 	bl	8010746 <lv_color_mix_premult>
 8010e80:	4603      	mov	r3, r0
 8010e82:	84bb      	strh	r3, [r7, #36]	; 0x24
                        }
                    }
                    disp_buf_first[x] = last_res_color;
 8010e84:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010e86:	005b      	lsls	r3, r3, #1
 8010e88:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010e8a:	4413      	add	r3, r2
 8010e8c:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8010e8e:	801a      	strh	r2, [r3, #0]
                for(x = 0; x < draw_area_w; x++) {
 8010e90:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010e92:	3301      	adds	r3, #1
 8010e94:	65bb      	str	r3, [r7, #88]	; 0x58
 8010e96:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010e98:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010e9a:	429a      	cmp	r2, r3
 8010e9c:	dbd7      	blt.n	8010e4e <fill_normal+0x186>
                }
                disp_buf_first += disp_w;
 8010e9e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8010ea0:	005b      	lsls	r3, r3, #1
 8010ea2:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010ea4:	4413      	add	r3, r2
 8010ea6:	65fb      	str	r3, [r7, #92]	; 0x5c
            for(y = 0; y < draw_area_h; y++) {
 8010ea8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8010eaa:	3301      	adds	r3, #1
 8010eac:	657b      	str	r3, [r7, #84]	; 0x54
 8010eae:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8010eb0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8010eb2:	429a      	cmp	r2, r3
 8010eb4:	dbc8      	blt.n	8010e48 <fill_normal+0x180>
 8010eb6:	e1ca      	b.n	801124e <fill_normal+0x586>


        /*Buffer the result color to avoid recalculating the same color*/
        lv_color_t last_dest_color;
        lv_color_t last_res_color;
        lv_opa_t last_mask = LV_OPA_TRANSP;
 8010eb8:	2300      	movs	r3, #0
 8010eba:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
        last_dest_color.full = disp_buf_first[0].full;
 8010ebe:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010ec0:	881b      	ldrh	r3, [r3, #0]
 8010ec2:	833b      	strh	r3, [r7, #24]
        last_res_color.full = disp_buf_first[0].full;
 8010ec4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8010ec6:	881b      	ldrh	r3, [r3, #0]
 8010ec8:	82bb      	strh	r3, [r7, #20]

        int32_t x_end4 = draw_area_w - 4;
 8010eca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010ecc:	3b04      	subs	r3, #4
 8010ece:	62fb      	str	r3, [r7, #44]	; 0x2c

        /*Only the mask matters*/
        if(opa > LV_OPA_MAX) {
 8010ed0:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
 8010ed4:	2bfd      	cmp	r3, #253	; 0xfd
 8010ed6:	f240 8143 	bls.w	8011160 <fill_normal+0x498>
            for(y = 0; y < draw_area_h; y++) {
 8010eda:	2300      	movs	r3, #0
 8010edc:	657b      	str	r3, [r7, #84]	; 0x54
 8010ede:	e139      	b.n	8011154 <fill_normal+0x48c>
                const lv_opa_t * mask_tmp_x = mask;
 8010ee0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8010ee2:	64fb      	str	r3, [r7, #76]	; 0x4c
#else
                    FILL_NORMAL_MASK_PX(x, color)
#endif
                }
#else
                for(x = 0; x < draw_area_w && ((lv_uintptr_t)mask_tmp_x & 0x3); x++) {
 8010ee4:	2300      	movs	r3, #0
 8010ee6:	65bb      	str	r3, [r7, #88]	; 0x58
 8010ee8:	e025      	b.n	8010f36 <fill_normal+0x26e>
#if LV_COLOR_SCREEN_TRANSP
                    FILL_NORMAL_MASK_PX_SCR_TRANSP(x, color)
#else
                    FILL_NORMAL_MASK_PX(x, color)
 8010eea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010eec:	781b      	ldrb	r3, [r3, #0]
 8010eee:	2b00      	cmp	r3, #0
 8010ef0:	d01b      	beq.n	8010f2a <fill_normal+0x262>
 8010ef2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010ef4:	781b      	ldrb	r3, [r3, #0]
 8010ef6:	2bff      	cmp	r3, #255	; 0xff
 8010ef8:	d106      	bne.n	8010f08 <fill_normal+0x240>
 8010efa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010efc:	005b      	lsls	r3, r3, #1
 8010efe:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010f00:	4413      	add	r3, r2
 8010f02:	883a      	ldrh	r2, [r7, #0]
 8010f04:	801a      	strh	r2, [r3, #0]
 8010f06:	e010      	b.n	8010f2a <fill_normal+0x262>
 8010f08:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010f0a:	005b      	lsls	r3, r3, #1
 8010f0c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010f0e:	4413      	add	r3, r2
 8010f10:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010f12:	7810      	ldrb	r0, [r2, #0]
 8010f14:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010f16:	0052      	lsls	r2, r2, #1
 8010f18:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8010f1a:	188c      	adds	r4, r1, r2
 8010f1c:	4602      	mov	r2, r0
 8010f1e:	8819      	ldrh	r1, [r3, #0]
 8010f20:	8838      	ldrh	r0, [r7, #0]
 8010f22:	f7ff fb69 	bl	80105f8 <lv_color_mix>
 8010f26:	4603      	mov	r3, r0
 8010f28:	8023      	strh	r3, [r4, #0]
 8010f2a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010f2c:	3301      	adds	r3, #1
 8010f2e:	64fb      	str	r3, [r7, #76]	; 0x4c
                for(x = 0; x < draw_area_w && ((lv_uintptr_t)mask_tmp_x & 0x3); x++) {
 8010f30:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010f32:	3301      	adds	r3, #1
 8010f34:	65bb      	str	r3, [r7, #88]	; 0x58
 8010f36:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010f38:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8010f3a:	429a      	cmp	r2, r3
 8010f3c:	da04      	bge.n	8010f48 <fill_normal+0x280>
 8010f3e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010f40:	f003 0303 	and.w	r3, r3, #3
 8010f44:	2b00      	cmp	r3, #0
 8010f46:	d1d0      	bne.n	8010eea <fill_normal+0x222>
#endif
                }

                uint32_t * mask32 = (uint32_t *) mask_tmp_x;
 8010f48:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010f4a:	64bb      	str	r3, [r7, #72]	; 0x48
                for(; x <= x_end4; x += 4) {
 8010f4c:	e0c4      	b.n	80110d8 <fill_normal+0x410>
                    if(*mask32) {
 8010f4e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010f50:	681b      	ldr	r3, [r3, #0]
 8010f52:	2b00      	cmp	r3, #0
 8010f54:	f000 80ba 	beq.w	80110cc <fill_normal+0x404>
                        if((*mask32) == 0xFFFFFFFF) {
 8010f58:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010f5a:	681b      	ldr	r3, [r3, #0]
 8010f5c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8010f60:	d11b      	bne.n	8010f9a <fill_normal+0x2d2>
                            disp_buf_first[x] = color;
 8010f62:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010f64:	005b      	lsls	r3, r3, #1
 8010f66:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010f68:	4413      	add	r3, r2
 8010f6a:	883a      	ldrh	r2, [r7, #0]
 8010f6c:	801a      	strh	r2, [r3, #0]
                            disp_buf_first[x + 1] = color;
 8010f6e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010f70:	3301      	adds	r3, #1
 8010f72:	005b      	lsls	r3, r3, #1
 8010f74:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010f76:	4413      	add	r3, r2
 8010f78:	883a      	ldrh	r2, [r7, #0]
 8010f7a:	801a      	strh	r2, [r3, #0]
                            disp_buf_first[x + 2] = color;
 8010f7c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010f7e:	3302      	adds	r3, #2
 8010f80:	005b      	lsls	r3, r3, #1
 8010f82:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010f84:	4413      	add	r3, r2
 8010f86:	883a      	ldrh	r2, [r7, #0]
 8010f88:	801a      	strh	r2, [r3, #0]
                            disp_buf_first[x + 3] = color;
 8010f8a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010f8c:	3303      	adds	r3, #3
 8010f8e:	005b      	lsls	r3, r3, #1
 8010f90:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010f92:	4413      	add	r3, r2
 8010f94:	883a      	ldrh	r2, [r7, #0]
 8010f96:	801a      	strh	r2, [r3, #0]
 8010f98:	e098      	b.n	80110cc <fill_normal+0x404>
                        }
                        else {
                            mask_tmp_x = (const lv_opa_t *)mask32;
 8010f9a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8010f9c:	64fb      	str	r3, [r7, #76]	; 0x4c
                            FILL_NORMAL_MASK_PX_SCR_TRANSP(x, color)
                            FILL_NORMAL_MASK_PX_SCR_TRANSP(x + 1, color)
                            FILL_NORMAL_MASK_PX_SCR_TRANSP(x + 2, color)
                            FILL_NORMAL_MASK_PX_SCR_TRANSP(x + 3, color)
#else
                            FILL_NORMAL_MASK_PX(x, color)
 8010f9e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010fa0:	781b      	ldrb	r3, [r3, #0]
 8010fa2:	2b00      	cmp	r3, #0
 8010fa4:	d01b      	beq.n	8010fde <fill_normal+0x316>
 8010fa6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010fa8:	781b      	ldrb	r3, [r3, #0]
 8010faa:	2bff      	cmp	r3, #255	; 0xff
 8010fac:	d106      	bne.n	8010fbc <fill_normal+0x2f4>
 8010fae:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010fb0:	005b      	lsls	r3, r3, #1
 8010fb2:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010fb4:	4413      	add	r3, r2
 8010fb6:	883a      	ldrh	r2, [r7, #0]
 8010fb8:	801a      	strh	r2, [r3, #0]
 8010fba:	e010      	b.n	8010fde <fill_normal+0x316>
 8010fbc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010fbe:	005b      	lsls	r3, r3, #1
 8010fc0:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010fc2:	4413      	add	r3, r2
 8010fc4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8010fc6:	7810      	ldrb	r0, [r2, #0]
 8010fc8:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8010fca:	0052      	lsls	r2, r2, #1
 8010fcc:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8010fce:	188c      	adds	r4, r1, r2
 8010fd0:	4602      	mov	r2, r0
 8010fd2:	8819      	ldrh	r1, [r3, #0]
 8010fd4:	8838      	ldrh	r0, [r7, #0]
 8010fd6:	f7ff fb0f 	bl	80105f8 <lv_color_mix>
 8010fda:	4603      	mov	r3, r0
 8010fdc:	8023      	strh	r3, [r4, #0]
 8010fde:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010fe0:	3301      	adds	r3, #1
 8010fe2:	64fb      	str	r3, [r7, #76]	; 0x4c
                            FILL_NORMAL_MASK_PX(x + 1, color)
 8010fe4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010fe6:	781b      	ldrb	r3, [r3, #0]
 8010fe8:	2b00      	cmp	r3, #0
 8010fea:	d020      	beq.n	801102e <fill_normal+0x366>
 8010fec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8010fee:	781b      	ldrb	r3, [r3, #0]
 8010ff0:	2bff      	cmp	r3, #255	; 0xff
 8010ff2:	d109      	bne.n	8011008 <fill_normal+0x340>
 8010ff4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8010ff6:	3301      	adds	r3, #1
 8010ff8:	005b      	lsls	r3, r3, #1
 8010ffa:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8010ffc:	4413      	add	r3, r2
 8010ffe:	883a      	ldrh	r2, [r7, #0]
 8011000:	801a      	strh	r2, [r3, #0]
 8011002:	e014      	b.n	801102e <fill_normal+0x366>
 8011004:	20009a00 	.word	0x20009a00
 8011008:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801100a:	3301      	adds	r3, #1
 801100c:	005b      	lsls	r3, r3, #1
 801100e:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8011010:	4413      	add	r3, r2
 8011012:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8011014:	7810      	ldrb	r0, [r2, #0]
 8011016:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8011018:	3201      	adds	r2, #1
 801101a:	0052      	lsls	r2, r2, #1
 801101c:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 801101e:	188c      	adds	r4, r1, r2
 8011020:	4602      	mov	r2, r0
 8011022:	8819      	ldrh	r1, [r3, #0]
 8011024:	8838      	ldrh	r0, [r7, #0]
 8011026:	f7ff fae7 	bl	80105f8 <lv_color_mix>
 801102a:	4603      	mov	r3, r0
 801102c:	8023      	strh	r3, [r4, #0]
 801102e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011030:	3301      	adds	r3, #1
 8011032:	64fb      	str	r3, [r7, #76]	; 0x4c
                            FILL_NORMAL_MASK_PX(x + 2, color)
 8011034:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011036:	781b      	ldrb	r3, [r3, #0]
 8011038:	2b00      	cmp	r3, #0
 801103a:	d01e      	beq.n	801107a <fill_normal+0x3b2>
 801103c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801103e:	781b      	ldrb	r3, [r3, #0]
 8011040:	2bff      	cmp	r3, #255	; 0xff
 8011042:	d107      	bne.n	8011054 <fill_normal+0x38c>
 8011044:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011046:	3302      	adds	r3, #2
 8011048:	005b      	lsls	r3, r3, #1
 801104a:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801104c:	4413      	add	r3, r2
 801104e:	883a      	ldrh	r2, [r7, #0]
 8011050:	801a      	strh	r2, [r3, #0]
 8011052:	e012      	b.n	801107a <fill_normal+0x3b2>
 8011054:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011056:	3302      	adds	r3, #2
 8011058:	005b      	lsls	r3, r3, #1
 801105a:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801105c:	4413      	add	r3, r2
 801105e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8011060:	7810      	ldrb	r0, [r2, #0]
 8011062:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8011064:	3202      	adds	r2, #2
 8011066:	0052      	lsls	r2, r2, #1
 8011068:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 801106a:	188c      	adds	r4, r1, r2
 801106c:	4602      	mov	r2, r0
 801106e:	8819      	ldrh	r1, [r3, #0]
 8011070:	8838      	ldrh	r0, [r7, #0]
 8011072:	f7ff fac1 	bl	80105f8 <lv_color_mix>
 8011076:	4603      	mov	r3, r0
 8011078:	8023      	strh	r3, [r4, #0]
 801107a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801107c:	3301      	adds	r3, #1
 801107e:	64fb      	str	r3, [r7, #76]	; 0x4c
                            FILL_NORMAL_MASK_PX(x + 3, color)
 8011080:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8011082:	781b      	ldrb	r3, [r3, #0]
 8011084:	2b00      	cmp	r3, #0
 8011086:	d01e      	beq.n	80110c6 <fill_normal+0x3fe>
 8011088:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801108a:	781b      	ldrb	r3, [r3, #0]
 801108c:	2bff      	cmp	r3, #255	; 0xff
 801108e:	d107      	bne.n	80110a0 <fill_normal+0x3d8>
 8011090:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011092:	3303      	adds	r3, #3
 8011094:	005b      	lsls	r3, r3, #1
 8011096:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8011098:	4413      	add	r3, r2
 801109a:	883a      	ldrh	r2, [r7, #0]
 801109c:	801a      	strh	r2, [r3, #0]
 801109e:	e012      	b.n	80110c6 <fill_normal+0x3fe>
 80110a0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80110a2:	3303      	adds	r3, #3
 80110a4:	005b      	lsls	r3, r3, #1
 80110a6:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80110a8:	4413      	add	r3, r2
 80110aa:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80110ac:	7810      	ldrb	r0, [r2, #0]
 80110ae:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80110b0:	3203      	adds	r2, #3
 80110b2:	0052      	lsls	r2, r2, #1
 80110b4:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 80110b6:	188c      	adds	r4, r1, r2
 80110b8:	4602      	mov	r2, r0
 80110ba:	8819      	ldrh	r1, [r3, #0]
 80110bc:	8838      	ldrh	r0, [r7, #0]
 80110be:	f7ff fa9b 	bl	80105f8 <lv_color_mix>
 80110c2:	4603      	mov	r3, r0
 80110c4:	8023      	strh	r3, [r4, #0]
 80110c6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80110c8:	3301      	adds	r3, #1
 80110ca:	64fb      	str	r3, [r7, #76]	; 0x4c
#endif
                        }
                    }
                    mask32++;
 80110cc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80110ce:	3304      	adds	r3, #4
 80110d0:	64bb      	str	r3, [r7, #72]	; 0x48
                for(; x <= x_end4; x += 4) {
 80110d2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80110d4:	3304      	adds	r3, #4
 80110d6:	65bb      	str	r3, [r7, #88]	; 0x58
 80110d8:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80110da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80110dc:	429a      	cmp	r2, r3
 80110de:	f77f af36 	ble.w	8010f4e <fill_normal+0x286>
                }

                mask_tmp_x = (const lv_opa_t *)mask32;
 80110e2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80110e4:	64fb      	str	r3, [r7, #76]	; 0x4c
                for(; x < draw_area_w ; x++) {
 80110e6:	e025      	b.n	8011134 <fill_normal+0x46c>
#if LV_COLOR_SCREEN_TRANSP
                    FILL_NORMAL_MASK_PX_SCR_TRANSP(x, color)
#else
                    FILL_NORMAL_MASK_PX(x, color)
 80110e8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80110ea:	781b      	ldrb	r3, [r3, #0]
 80110ec:	2b00      	cmp	r3, #0
 80110ee:	d01b      	beq.n	8011128 <fill_normal+0x460>
 80110f0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80110f2:	781b      	ldrb	r3, [r3, #0]
 80110f4:	2bff      	cmp	r3, #255	; 0xff
 80110f6:	d106      	bne.n	8011106 <fill_normal+0x43e>
 80110f8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80110fa:	005b      	lsls	r3, r3, #1
 80110fc:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80110fe:	4413      	add	r3, r2
 8011100:	883a      	ldrh	r2, [r7, #0]
 8011102:	801a      	strh	r2, [r3, #0]
 8011104:	e010      	b.n	8011128 <fill_normal+0x460>
 8011106:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011108:	005b      	lsls	r3, r3, #1
 801110a:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801110c:	4413      	add	r3, r2
 801110e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8011110:	7810      	ldrb	r0, [r2, #0]
 8011112:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8011114:	0052      	lsls	r2, r2, #1
 8011116:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 8011118:	188c      	adds	r4, r1, r2
 801111a:	4602      	mov	r2, r0
 801111c:	8819      	ldrh	r1, [r3, #0]
 801111e:	8838      	ldrh	r0, [r7, #0]
 8011120:	f7ff fa6a 	bl	80105f8 <lv_color_mix>
 8011124:	4603      	mov	r3, r0
 8011126:	8023      	strh	r3, [r4, #0]
 8011128:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801112a:	3301      	adds	r3, #1
 801112c:	64fb      	str	r3, [r7, #76]	; 0x4c
                for(; x < draw_area_w ; x++) {
 801112e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8011130:	3301      	adds	r3, #1
 8011132:	65bb      	str	r3, [r7, #88]	; 0x58
 8011134:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8011136:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011138:	429a      	cmp	r2, r3
 801113a:	dbd5      	blt.n	80110e8 <fill_normal+0x420>
#endif
                }
#endif
                disp_buf_first += disp_w;
 801113c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801113e:	005b      	lsls	r3, r3, #1
 8011140:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8011142:	4413      	add	r3, r2
 8011144:	65fb      	str	r3, [r7, #92]	; 0x5c
                mask += draw_area_w;
 8011146:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011148:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801114a:	4413      	add	r3, r2
 801114c:	677b      	str	r3, [r7, #116]	; 0x74
            for(y = 0; y < draw_area_h; y++) {
 801114e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8011150:	3301      	adds	r3, #1
 8011152:	657b      	str	r3, [r7, #84]	; 0x54
 8011154:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8011156:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011158:	429a      	cmp	r2, r3
 801115a:	f6ff aec1 	blt.w	8010ee0 <fill_normal+0x218>
 801115e:	e076      	b.n	801124e <fill_normal+0x586>
            }
        }
        /*Handle opa and mask values too*/
        else {
            lv_opa_t opa_tmp = LV_OPA_TRANSP;
 8011160:	2300      	movs	r3, #0
 8011162:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8011166:	687b      	ldr	r3, [r7, #4]
 8011168:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801116c:	657b      	str	r3, [r7, #84]	; 0x54
 801116e:	e067      	b.n	8011240 <fill_normal+0x578>
                const lv_opa_t * mask_tmp_x = mask;
 8011170:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8011172:	643b      	str	r3, [r7, #64]	; 0x40
                for(x = 0; x < draw_area_w; x++) {
 8011174:	2300      	movs	r3, #0
 8011176:	65bb      	str	r3, [r7, #88]	; 0x58
 8011178:	e052      	b.n	8011220 <fill_normal+0x558>
                    if(*mask_tmp_x) {
 801117a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801117c:	781b      	ldrb	r3, [r3, #0]
 801117e:	2b00      	cmp	r3, #0
 8011180:	d048      	beq.n	8011214 <fill_normal+0x54c>
                        if(*mask_tmp_x != last_mask) opa_tmp = *mask_tmp_x == LV_OPA_COVER ? opa :
 8011182:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011184:	781b      	ldrb	r3, [r3, #0]
 8011186:	f897 2053 	ldrb.w	r2, [r7, #83]	; 0x53
 801118a:	429a      	cmp	r2, r3
 801118c:	d011      	beq.n	80111b2 <fill_normal+0x4ea>
 801118e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011190:	781b      	ldrb	r3, [r3, #0]
 8011192:	2bff      	cmp	r3, #255	; 0xff
 8011194:	d009      	beq.n	80111aa <fill_normal+0x4e2>
                                                                   (uint32_t)((uint32_t)(*mask_tmp_x) * opa) >> 8;
 8011196:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011198:	781b      	ldrb	r3, [r3, #0]
 801119a:	461a      	mov	r2, r3
 801119c:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
 80111a0:	fb02 f303 	mul.w	r3, r2, r3
 80111a4:	0a1b      	lsrs	r3, r3, #8
                        if(*mask_tmp_x != last_mask) opa_tmp = *mask_tmp_x == LV_OPA_COVER ? opa :
 80111a6:	b2db      	uxtb	r3, r3
 80111a8:	e001      	b.n	80111ae <fill_normal+0x4e6>
 80111aa:	f897 3070 	ldrb.w	r3, [r7, #112]	; 0x70
 80111ae:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
                        if(*mask_tmp_x != last_mask || last_dest_color.full != disp_buf_first[x].full) {
 80111b2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80111b4:	781b      	ldrb	r3, [r3, #0]
 80111b6:	f897 2053 	ldrb.w	r2, [r7, #83]	; 0x53
 80111ba:	429a      	cmp	r2, r3
 80111bc:	d107      	bne.n	80111ce <fill_normal+0x506>
 80111be:	8b3a      	ldrh	r2, [r7, #24]
 80111c0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80111c2:	005b      	lsls	r3, r3, #1
 80111c4:	6df9      	ldr	r1, [r7, #92]	; 0x5c
 80111c6:	440b      	add	r3, r1
 80111c8:	881b      	ldrh	r3, [r3, #0]
 80111ca:	429a      	cmp	r2, r3
 80111cc:	d01c      	beq.n	8011208 <fill_normal+0x540>
                                                        &last_res_color.ch.alpha);
                            }
                            else
#endif
                            {
                                if(opa_tmp == LV_OPA_COVER) last_res_color = color;
 80111ce:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80111d2:	2bff      	cmp	r3, #255	; 0xff
 80111d4:	d102      	bne.n	80111dc <fill_normal+0x514>
 80111d6:	883b      	ldrh	r3, [r7, #0]
 80111d8:	82bb      	strh	r3, [r7, #20]
 80111da:	e00b      	b.n	80111f4 <fill_normal+0x52c>
                                else last_res_color = lv_color_mix(color, disp_buf_first[x], opa_tmp);
 80111dc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80111de:	005b      	lsls	r3, r3, #1
 80111e0:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80111e2:	4413      	add	r3, r2
 80111e4:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 80111e8:	8819      	ldrh	r1, [r3, #0]
 80111ea:	8838      	ldrh	r0, [r7, #0]
 80111ec:	f7ff fa04 	bl	80105f8 <lv_color_mix>
 80111f0:	4603      	mov	r3, r0
 80111f2:	82bb      	strh	r3, [r7, #20]
                            }
                            last_mask = *mask_tmp_x;
 80111f4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80111f6:	781b      	ldrb	r3, [r3, #0]
 80111f8:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
                            last_dest_color.full = disp_buf_first[x].full;
 80111fc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80111fe:	005b      	lsls	r3, r3, #1
 8011200:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8011202:	4413      	add	r3, r2
 8011204:	881b      	ldrh	r3, [r3, #0]
 8011206:	833b      	strh	r3, [r7, #24]
                        }
                        disp_buf_first[x] = last_res_color;
 8011208:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801120a:	005b      	lsls	r3, r3, #1
 801120c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801120e:	4413      	add	r3, r2
 8011210:	8aba      	ldrh	r2, [r7, #20]
 8011212:	801a      	strh	r2, [r3, #0]
                    }
                    mask_tmp_x++;
 8011214:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011216:	3301      	adds	r3, #1
 8011218:	643b      	str	r3, [r7, #64]	; 0x40
                for(x = 0; x < draw_area_w; x++) {
 801121a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801121c:	3301      	adds	r3, #1
 801121e:	65bb      	str	r3, [r7, #88]	; 0x58
 8011220:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8011222:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011224:	429a      	cmp	r2, r3
 8011226:	dba8      	blt.n	801117a <fill_normal+0x4b2>
                }
                disp_buf_first += disp_w;
 8011228:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801122a:	005b      	lsls	r3, r3, #1
 801122c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801122e:	4413      	add	r3, r2
 8011230:	65fb      	str	r3, [r7, #92]	; 0x5c
                mask += draw_area_w;
 8011232:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011234:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 8011236:	4413      	add	r3, r2
 8011238:	677b      	str	r3, [r7, #116]	; 0x74
            for(y = draw_area->y1; y <= draw_area->y2; y++) {
 801123a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801123c:	3301      	adds	r3, #1
 801123e:	657b      	str	r3, [r7, #84]	; 0x54
 8011240:	687b      	ldr	r3, [r7, #4]
 8011242:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8011246:	461a      	mov	r2, r3
 8011248:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801124a:	4293      	cmp	r3, r2
 801124c:	dd90      	ble.n	8011170 <fill_normal+0x4a8>
            }
        }
    }
}
 801124e:	3764      	adds	r7, #100	; 0x64
 8011250:	46bd      	mov	sp, r7
 8011252:	bd90      	pop	{r4, r7, pc}

08011254 <fill_blended>:
 * @param mode blend mode from `lv_blend_mode_t`
 */
static void fill_blended(const lv_area_t * disp_area, lv_color_t * disp_buf,  const lv_area_t * draw_area,
                         lv_color_t color, lv_opa_t opa,
                         const lv_opa_t * mask, lv_draw_mask_res_t mask_res, lv_blend_mode_t mode)
{
 8011254:	b580      	push	{r7, lr}
 8011256:	b090      	sub	sp, #64	; 0x40
 8011258:	af00      	add	r7, sp, #0
 801125a:	60f8      	str	r0, [r7, #12]
 801125c:	60b9      	str	r1, [r7, #8]
 801125e:	607a      	str	r2, [r7, #4]
 8011260:	803b      	strh	r3, [r7, #0]
    /*Get the width of the `disp_area` it will be used to go to the next line*/
    int32_t disp_w = lv_area_get_width(disp_area);
 8011262:	68f8      	ldr	r0, [r7, #12]
 8011264:	f7ff fad0 	bl	8010808 <lv_area_get_width>
 8011268:	4603      	mov	r3, r0
 801126a:	627b      	str	r3, [r7, #36]	; 0x24

    /*Create a temp. disp_buf which always point to current line to draw*/
    lv_color_t * disp_buf_tmp = disp_buf + disp_w * draw_area->y1;
 801126c:	687b      	ldr	r3, [r7, #4]
 801126e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8011272:	461a      	mov	r2, r3
 8011274:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011276:	fb02 f303 	mul.w	r3, r2, r3
 801127a:	005b      	lsls	r3, r3, #1
 801127c:	68ba      	ldr	r2, [r7, #8]
 801127e:	4413      	add	r3, r2
 8011280:	63fb      	str	r3, [r7, #60]	; 0x3c


    lv_color_t (*blend_fp)(lv_color_t, lv_color_t, lv_opa_t);
    switch(mode) {
 8011282:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 8011286:	2b01      	cmp	r3, #1
 8011288:	d002      	beq.n	8011290 <fill_blended+0x3c>
 801128a:	2b02      	cmp	r3, #2
 801128c:	d003      	beq.n	8011296 <fill_blended+0x42>
        case LV_BLEND_MODE_SUBTRACTIVE:
            blend_fp = color_blend_true_color_subtractive;
            break;
        default:
            LV_LOG_WARN("fill_blended: unsupported blend mode");
            return;
 801128e:	e0e8      	b.n	8011462 <fill_blended+0x20e>
            blend_fp = color_blend_true_color_additive;
 8011290:	4b75      	ldr	r3, [pc, #468]	; (8011468 <fill_blended+0x214>)
 8011292:	63bb      	str	r3, [r7, #56]	; 0x38
            break;
 8011294:	e002      	b.n	801129c <fill_blended+0x48>
            blend_fp = color_blend_true_color_subtractive;
 8011296:	4b75      	ldr	r3, [pc, #468]	; (801146c <fill_blended+0x218>)
 8011298:	63bb      	str	r3, [r7, #56]	; 0x38
            break;
 801129a:	bf00      	nop

    int32_t x;
    int32_t y;

    /*Simple fill (maybe with opacity), no masking*/
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
 801129c:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 80112a0:	2b01      	cmp	r3, #1
 80112a2:	d158      	bne.n	8011356 <fill_blended+0x102>
        lv_color_t last_dest_color = LV_COLOR_BLACK;
 80112a4:	7f3b      	ldrb	r3, [r7, #28]
 80112a6:	f36f 0304 	bfc	r3, #0, #5
 80112aa:	773b      	strb	r3, [r7, #28]
 80112ac:	8bbb      	ldrh	r3, [r7, #28]
 80112ae:	f36f 134a 	bfc	r3, #5, #6
 80112b2:	83bb      	strh	r3, [r7, #28]
 80112b4:	7f7b      	ldrb	r3, [r7, #29]
 80112b6:	f36f 03c7 	bfc	r3, #3, #5
 80112ba:	777b      	strb	r3, [r7, #29]
        lv_color_t last_res_color = lv_color_mix(color, last_dest_color, opa);
 80112bc:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 80112c0:	461a      	mov	r2, r3
 80112c2:	8bb9      	ldrh	r1, [r7, #28]
 80112c4:	8838      	ldrh	r0, [r7, #0]
 80112c6:	f7ff f997 	bl	80105f8 <lv_color_mix>
 80112ca:	4603      	mov	r3, r0
 80112cc:	833b      	strh	r3, [r7, #24]
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 80112ce:	687b      	ldr	r3, [r7, #4]
 80112d0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80112d4:	633b      	str	r3, [r7, #48]	; 0x30
 80112d6:	e036      	b.n	8011346 <fill_blended+0xf2>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 80112d8:	687b      	ldr	r3, [r7, #4]
 80112da:	f9b3 3000 	ldrsh.w	r3, [r3]
 80112de:	637b      	str	r3, [r7, #52]	; 0x34
 80112e0:	e022      	b.n	8011328 <fill_blended+0xd4>
                if(last_dest_color.full != disp_buf_tmp[x].full) {
 80112e2:	8bba      	ldrh	r2, [r7, #28]
 80112e4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80112e6:	005b      	lsls	r3, r3, #1
 80112e8:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 80112ea:	440b      	add	r3, r1
 80112ec:	881b      	ldrh	r3, [r3, #0]
 80112ee:	429a      	cmp	r2, r3
 80112f0:	d011      	beq.n	8011316 <fill_blended+0xc2>
                    last_dest_color = disp_buf_tmp[x];
 80112f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80112f4:	005b      	lsls	r3, r3, #1
 80112f6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80112f8:	4413      	add	r3, r2
 80112fa:	881b      	ldrh	r3, [r3, #0]
 80112fc:	83bb      	strh	r3, [r7, #28]
                    last_res_color = blend_fp(color, disp_buf_tmp[x], opa);
 80112fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011300:	005b      	lsls	r3, r3, #1
 8011302:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011304:	18d1      	adds	r1, r2, r3
 8011306:	f897 2048 	ldrb.w	r2, [r7, #72]	; 0x48
 801130a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801130c:	8809      	ldrh	r1, [r1, #0]
 801130e:	8838      	ldrh	r0, [r7, #0]
 8011310:	4798      	blx	r3
 8011312:	4603      	mov	r3, r0
 8011314:	833b      	strh	r3, [r7, #24]
                }
                disp_buf_tmp[x] = last_res_color;
 8011316:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011318:	005b      	lsls	r3, r3, #1
 801131a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801131c:	4413      	add	r3, r2
 801131e:	8b3a      	ldrh	r2, [r7, #24]
 8011320:	801a      	strh	r2, [r3, #0]
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8011322:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011324:	3301      	adds	r3, #1
 8011326:	637b      	str	r3, [r7, #52]	; 0x34
 8011328:	687b      	ldr	r3, [r7, #4]
 801132a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801132e:	461a      	mov	r2, r3
 8011330:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011332:	4293      	cmp	r3, r2
 8011334:	ddd5      	ble.n	80112e2 <fill_blended+0x8e>
            }
            disp_buf_tmp += disp_w;
 8011336:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011338:	005b      	lsls	r3, r3, #1
 801133a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801133c:	4413      	add	r3, r2
 801133e:	63fb      	str	r3, [r7, #60]	; 0x3c
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8011340:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011342:	3301      	adds	r3, #1
 8011344:	633b      	str	r3, [r7, #48]	; 0x30
 8011346:	687b      	ldr	r3, [r7, #4]
 8011348:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801134c:	461a      	mov	r2, r3
 801134e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011350:	4293      	cmp	r3, r2
 8011352:	ddc1      	ble.n	80112d8 <fill_blended+0x84>
 8011354:	e085      	b.n	8011462 <fill_blended+0x20e>
        }
    }
    /*Masked*/
    else {
        /*Get the width of the `draw_area` it will be used to go to the next line of the mask*/
        int32_t draw_area_w = lv_area_get_width(draw_area);
 8011356:	6878      	ldr	r0, [r7, #4]
 8011358:	f7ff fa56 	bl	8010808 <lv_area_get_width>
 801135c:	4603      	mov	r3, r0
 801135e:	623b      	str	r3, [r7, #32]

        /* The mask is relative to the clipped area.
         * In the cycles below mask will be indexed from `draw_area.x1`
         * but it corresponds to zero index. So prepare `mask_tmp` accordingly. */
        const lv_opa_t * mask_tmp = mask - draw_area->x1;
 8011360:	687b      	ldr	r3, [r7, #4]
 8011362:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011366:	425b      	negs	r3, r3
 8011368:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801136a:	4413      	add	r3, r2
 801136c:	62fb      	str	r3, [r7, #44]	; 0x2c

        /*Buffer the result color to avoid recalculating the same color*/
        lv_color_t last_dest_color;
        lv_color_t last_res_color;
        lv_opa_t last_mask = LV_OPA_TRANSP;
 801136e:	2300      	movs	r3, #0
 8011370:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        last_dest_color.full = disp_buf_tmp[0].full;
 8011374:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011376:	881b      	ldrh	r3, [r3, #0]
 8011378:	82bb      	strh	r3, [r7, #20]
        last_res_color.full = disp_buf_tmp[0].full;
 801137a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801137c:	881b      	ldrh	r3, [r3, #0]
 801137e:	823b      	strh	r3, [r7, #16]

        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8011380:	687b      	ldr	r3, [r7, #4]
 8011382:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8011386:	633b      	str	r3, [r7, #48]	; 0x30
 8011388:	e064      	b.n	8011454 <fill_blended+0x200>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 801138a:	687b      	ldr	r3, [r7, #4]
 801138c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011390:	637b      	str	r3, [r7, #52]	; 0x34
 8011392:	e04c      	b.n	801142e <fill_blended+0x1da>
                if(mask_tmp[x] == 0) continue;
 8011394:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011396:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011398:	4413      	add	r3, r2
 801139a:	781b      	ldrb	r3, [r3, #0]
 801139c:	2b00      	cmp	r3, #0
 801139e:	d042      	beq.n	8011426 <fill_blended+0x1d2>
                if(mask_tmp[x] != last_mask || last_dest_color.full != disp_buf_tmp[x].full) {
 80113a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80113a2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80113a4:	4413      	add	r3, r2
 80113a6:	781b      	ldrb	r3, [r3, #0]
 80113a8:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
 80113ac:	429a      	cmp	r2, r3
 80113ae:	d107      	bne.n	80113c0 <fill_blended+0x16c>
 80113b0:	8aba      	ldrh	r2, [r7, #20]
 80113b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80113b4:	005b      	lsls	r3, r3, #1
 80113b6:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 80113b8:	440b      	add	r3, r1
 80113ba:	881b      	ldrh	r3, [r3, #0]
 80113bc:	429a      	cmp	r2, r3
 80113be:	d02b      	beq.n	8011418 <fill_blended+0x1c4>
                    lv_opa_t opa_tmp = mask_tmp[x] >= LV_OPA_MAX ? opa : (uint32_t)((uint32_t)mask_tmp[x] * opa) >> 8;
 80113c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80113c2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80113c4:	4413      	add	r3, r2
 80113c6:	781b      	ldrb	r3, [r3, #0]
 80113c8:	2bfc      	cmp	r3, #252	; 0xfc
 80113ca:	d80b      	bhi.n	80113e4 <fill_blended+0x190>
 80113cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80113ce:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80113d0:	4413      	add	r3, r2
 80113d2:	781b      	ldrb	r3, [r3, #0]
 80113d4:	461a      	mov	r2, r3
 80113d6:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 80113da:	fb02 f303 	mul.w	r3, r2, r3
 80113de:	0a1b      	lsrs	r3, r3, #8
 80113e0:	b2db      	uxtb	r3, r3
 80113e2:	e001      	b.n	80113e8 <fill_blended+0x194>
 80113e4:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 80113e8:	77fb      	strb	r3, [r7, #31]

                    last_res_color = blend_fp(color, disp_buf_tmp[x], opa_tmp);
 80113ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80113ec:	005b      	lsls	r3, r3, #1
 80113ee:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80113f0:	18d1      	adds	r1, r2, r3
 80113f2:	7ffa      	ldrb	r2, [r7, #31]
 80113f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80113f6:	8809      	ldrh	r1, [r1, #0]
 80113f8:	8838      	ldrh	r0, [r7, #0]
 80113fa:	4798      	blx	r3
 80113fc:	4603      	mov	r3, r0
 80113fe:	823b      	strh	r3, [r7, #16]
                    last_mask = mask_tmp[x];
 8011400:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011402:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011404:	4413      	add	r3, r2
 8011406:	781b      	ldrb	r3, [r3, #0]
 8011408:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
                    last_dest_color.full = disp_buf_tmp[x].full;
 801140c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801140e:	005b      	lsls	r3, r3, #1
 8011410:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011412:	4413      	add	r3, r2
 8011414:	881b      	ldrh	r3, [r3, #0]
 8011416:	82bb      	strh	r3, [r7, #20]
                }
                disp_buf_tmp[x] = last_res_color;
 8011418:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801141a:	005b      	lsls	r3, r3, #1
 801141c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801141e:	4413      	add	r3, r2
 8011420:	8a3a      	ldrh	r2, [r7, #16]
 8011422:	801a      	strh	r2, [r3, #0]
 8011424:	e000      	b.n	8011428 <fill_blended+0x1d4>
                if(mask_tmp[x] == 0) continue;
 8011426:	bf00      	nop
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8011428:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801142a:	3301      	adds	r3, #1
 801142c:	637b      	str	r3, [r7, #52]	; 0x34
 801142e:	687b      	ldr	r3, [r7, #4]
 8011430:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8011434:	461a      	mov	r2, r3
 8011436:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011438:	4293      	cmp	r3, r2
 801143a:	ddab      	ble.n	8011394 <fill_blended+0x140>
            }
            disp_buf_tmp += disp_w;
 801143c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801143e:	005b      	lsls	r3, r3, #1
 8011440:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011442:	4413      	add	r3, r2
 8011444:	63fb      	str	r3, [r7, #60]	; 0x3c
            mask_tmp += draw_area_w;
 8011446:	6a3b      	ldr	r3, [r7, #32]
 8011448:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801144a:	4413      	add	r3, r2
 801144c:	62fb      	str	r3, [r7, #44]	; 0x2c
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 801144e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011450:	3301      	adds	r3, #1
 8011452:	633b      	str	r3, [r7, #48]	; 0x30
 8011454:	687b      	ldr	r3, [r7, #4]
 8011456:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801145a:	461a      	mov	r2, r3
 801145c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801145e:	4293      	cmp	r3, r2
 8011460:	dd93      	ble.n	801138a <fill_blended+0x136>
        }
    }
}
 8011462:	3740      	adds	r7, #64	; 0x40
 8011464:	46bd      	mov	sp, r7
 8011466:	bd80      	pop	{r7, pc}
 8011468:	08011dd5 	.word	0x08011dd5
 801146c:	08011e91 	.word	0x08011e91

08011470 <map_set_px>:

static void map_set_px(const lv_area_t * disp_area, lv_color_t * disp_buf,  const lv_area_t * draw_area,
                       const lv_area_t * map_area, const lv_color_t * map_buf, lv_opa_t opa,
                       const lv_opa_t * mask, lv_draw_mask_res_t mask_res)

{
 8011470:	b5f0      	push	{r4, r5, r6, r7, lr}
 8011472:	b091      	sub	sp, #68	; 0x44
 8011474:	af04      	add	r7, sp, #16
 8011476:	60f8      	str	r0, [r7, #12]
 8011478:	60b9      	str	r1, [r7, #8]
 801147a:	607a      	str	r2, [r7, #4]
 801147c:	603b      	str	r3, [r7, #0]
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
 801147e:	f7fc ffaf 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 8011482:	61f8      	str	r0, [r7, #28]

    /*Get the width of the `disp_area` it will be used to go to the next line*/
    int32_t disp_w = lv_area_get_width(disp_area);
 8011484:	68f8      	ldr	r0, [r7, #12]
 8011486:	f7ff f9bf 	bl	8010808 <lv_area_get_width>
 801148a:	4603      	mov	r3, r0
 801148c:	61bb      	str	r3, [r7, #24]

    /*Get the width of the `draw_area` it will be used to go to the next line of the mask*/
    int32_t draw_area_w = lv_area_get_width(draw_area);
 801148e:	6878      	ldr	r0, [r7, #4]
 8011490:	f7ff f9ba 	bl	8010808 <lv_area_get_width>
 8011494:	4603      	mov	r3, r0
 8011496:	617b      	str	r3, [r7, #20]

    /*Get the width of the `mask_area` it will be used to go to the next line*/
    int32_t map_w = lv_area_get_width(map_area);
 8011498:	6838      	ldr	r0, [r7, #0]
 801149a:	f7ff f9b5 	bl	8010808 <lv_area_get_width>
 801149e:	4603      	mov	r3, r0
 80114a0:	613b      	str	r3, [r7, #16]

    /*Create a temp. map_buf which always point to current line to draw*/
    const lv_color_t * map_buf_tmp = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
 80114a2:	687b      	ldr	r3, [r7, #4]
 80114a4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80114a8:	461a      	mov	r2, r3
 80114aa:	683b      	ldr	r3, [r7, #0]
 80114ac:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80114b0:	4619      	mov	r1, r3
 80114b2:	68fb      	ldr	r3, [r7, #12]
 80114b4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80114b8:	1acb      	subs	r3, r1, r3
 80114ba:	1ad3      	subs	r3, r2, r3
 80114bc:	693a      	ldr	r2, [r7, #16]
 80114be:	fb02 f303 	mul.w	r3, r2, r3
 80114c2:	005b      	lsls	r3, r3, #1
 80114c4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80114c6:	4413      	add	r3, r2
 80114c8:	62fb      	str	r3, [r7, #44]	; 0x2c

    map_buf_tmp += (draw_area->x1 - (map_area->x1 - disp_area->x1));
 80114ca:	687b      	ldr	r3, [r7, #4]
 80114cc:	f9b3 3000 	ldrsh.w	r3, [r3]
 80114d0:	461a      	mov	r2, r3
 80114d2:	683b      	ldr	r3, [r7, #0]
 80114d4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80114d8:	4619      	mov	r1, r3
 80114da:	68fb      	ldr	r3, [r7, #12]
 80114dc:	f9b3 3000 	ldrsh.w	r3, [r3]
 80114e0:	1acb      	subs	r3, r1, r3
 80114e2:	1ad3      	subs	r3, r2, r3
 80114e4:	005b      	lsls	r3, r3, #1
 80114e6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80114e8:	4413      	add	r3, r2
 80114ea:	62fb      	str	r3, [r7, #44]	; 0x2c
    map_buf_tmp -= draw_area->x1;
 80114ec:	687b      	ldr	r3, [r7, #4]
 80114ee:	f9b3 3000 	ldrsh.w	r3, [r3]
 80114f2:	005b      	lsls	r3, r3, #1
 80114f4:	425b      	negs	r3, r3
 80114f6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80114f8:	4413      	add	r3, r2
 80114fa:	62fb      	str	r3, [r7, #44]	; 0x2c
    int32_t x;
    int32_t y;

    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
 80114fc:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 8011500:	2b01      	cmp	r3, #1
 8011502:	d13b      	bne.n	801157c <map_set_px+0x10c>
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8011504:	687b      	ldr	r3, [r7, #4]
 8011506:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801150a:	627b      	str	r3, [r7, #36]	; 0x24
 801150c:	e02e      	b.n	801156c <map_set_px+0xfc>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 801150e:	687b      	ldr	r3, [r7, #4]
 8011510:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011514:	62bb      	str	r3, [r7, #40]	; 0x28
 8011516:	e01a      	b.n	801154e <map_set_px+0xde>
                disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x], opa);
 8011518:	69fb      	ldr	r3, [r7, #28]
 801151a:	695c      	ldr	r4, [r3, #20]
 801151c:	69f8      	ldr	r0, [r7, #28]
 801151e:	69bb      	ldr	r3, [r7, #24]
 8011520:	b21d      	sxth	r5, r3
 8011522:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011524:	b21e      	sxth	r6, r3
 8011526:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011528:	b21b      	sxth	r3, r3
 801152a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801152c:	0052      	lsls	r2, r2, #1
 801152e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8011530:	440a      	add	r2, r1
 8011532:	f897 104c 	ldrb.w	r1, [r7, #76]	; 0x4c
 8011536:	9102      	str	r1, [sp, #8]
 8011538:	8812      	ldrh	r2, [r2, #0]
 801153a:	f8ad 2004 	strh.w	r2, [sp, #4]
 801153e:	9300      	str	r3, [sp, #0]
 8011540:	4633      	mov	r3, r6
 8011542:	462a      	mov	r2, r5
 8011544:	68b9      	ldr	r1, [r7, #8]
 8011546:	47a0      	blx	r4
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8011548:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801154a:	3301      	adds	r3, #1
 801154c:	62bb      	str	r3, [r7, #40]	; 0x28
 801154e:	687b      	ldr	r3, [r7, #4]
 8011550:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8011554:	461a      	mov	r2, r3
 8011556:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011558:	4293      	cmp	r3, r2
 801155a:	dddd      	ble.n	8011518 <map_set_px+0xa8>
            }
            map_buf_tmp += map_w;
 801155c:	693b      	ldr	r3, [r7, #16]
 801155e:	005b      	lsls	r3, r3, #1
 8011560:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011562:	4413      	add	r3, r2
 8011564:	62fb      	str	r3, [r7, #44]	; 0x2c
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8011566:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011568:	3301      	adds	r3, #1
 801156a:	627b      	str	r3, [r7, #36]	; 0x24
 801156c:	687b      	ldr	r3, [r7, #4]
 801156e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8011572:	461a      	mov	r2, r3
 8011574:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011576:	4293      	cmp	r3, r2
 8011578:	ddc9      	ble.n	801150e <map_set_px+0x9e>
            }
            mask_tmp += draw_area_w;
            map_buf_tmp += map_w;
        }
    }
}
 801157a:	e056      	b.n	801162a <map_set_px+0x1ba>
        const lv_opa_t * mask_tmp = mask - draw_area->x1;
 801157c:	687b      	ldr	r3, [r7, #4]
 801157e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011582:	425b      	negs	r3, r3
 8011584:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011586:	4413      	add	r3, r2
 8011588:	623b      	str	r3, [r7, #32]
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 801158a:	687b      	ldr	r3, [r7, #4]
 801158c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8011590:	627b      	str	r3, [r7, #36]	; 0x24
 8011592:	e043      	b.n	801161c <map_set_px+0x1ac>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8011594:	687b      	ldr	r3, [r7, #4]
 8011596:	f9b3 3000 	ldrsh.w	r3, [r3]
 801159a:	62bb      	str	r3, [r7, #40]	; 0x28
 801159c:	e02b      	b.n	80115f6 <map_set_px+0x186>
                if(mask_tmp[x]) {
 801159e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80115a0:	6a3a      	ldr	r2, [r7, #32]
 80115a2:	4413      	add	r3, r2
 80115a4:	781b      	ldrb	r3, [r3, #0]
 80115a6:	2b00      	cmp	r3, #0
 80115a8:	d022      	beq.n	80115f0 <map_set_px+0x180>
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x],
 80115aa:	69fb      	ldr	r3, [r7, #28]
 80115ac:	695c      	ldr	r4, [r3, #20]
 80115ae:	69fe      	ldr	r6, [r7, #28]
 80115b0:	69bb      	ldr	r3, [r7, #24]
 80115b2:	fa0f fc83 	sxth.w	ip, r3
 80115b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80115b8:	fa0f fe83 	sxth.w	lr, r3
 80115bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80115be:	b21b      	sxth	r3, r3
 80115c0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80115c2:	0052      	lsls	r2, r2, #1
 80115c4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80115c6:	440a      	add	r2, r1
                                           (uint32_t)((uint32_t)opa * mask_tmp[x]) >> 8);
 80115c8:	f897 104c 	ldrb.w	r1, [r7, #76]	; 0x4c
 80115cc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80115ce:	6a3d      	ldr	r5, [r7, #32]
 80115d0:	4428      	add	r0, r5
 80115d2:	7800      	ldrb	r0, [r0, #0]
 80115d4:	fb00 f101 	mul.w	r1, r0, r1
 80115d8:	0a09      	lsrs	r1, r1, #8
                    disp->driver.set_px_cb(&disp->driver, (void *)disp_buf, disp_w, x, y, map_buf_tmp[x],
 80115da:	b2c9      	uxtb	r1, r1
 80115dc:	9102      	str	r1, [sp, #8]
 80115de:	8812      	ldrh	r2, [r2, #0]
 80115e0:	f8ad 2004 	strh.w	r2, [sp, #4]
 80115e4:	9300      	str	r3, [sp, #0]
 80115e6:	4673      	mov	r3, lr
 80115e8:	4662      	mov	r2, ip
 80115ea:	68b9      	ldr	r1, [r7, #8]
 80115ec:	4630      	mov	r0, r6
 80115ee:	47a0      	blx	r4
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 80115f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80115f2:	3301      	adds	r3, #1
 80115f4:	62bb      	str	r3, [r7, #40]	; 0x28
 80115f6:	687b      	ldr	r3, [r7, #4]
 80115f8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80115fc:	461a      	mov	r2, r3
 80115fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011600:	4293      	cmp	r3, r2
 8011602:	ddcc      	ble.n	801159e <map_set_px+0x12e>
            mask_tmp += draw_area_w;
 8011604:	697b      	ldr	r3, [r7, #20]
 8011606:	6a3a      	ldr	r2, [r7, #32]
 8011608:	4413      	add	r3, r2
 801160a:	623b      	str	r3, [r7, #32]
            map_buf_tmp += map_w;
 801160c:	693b      	ldr	r3, [r7, #16]
 801160e:	005b      	lsls	r3, r3, #1
 8011610:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8011612:	4413      	add	r3, r2
 8011614:	62fb      	str	r3, [r7, #44]	; 0x2c
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8011616:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011618:	3301      	adds	r3, #1
 801161a:	627b      	str	r3, [r7, #36]	; 0x24
 801161c:	687b      	ldr	r3, [r7, #4]
 801161e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8011622:	461a      	mov	r2, r3
 8011624:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011626:	4293      	cmp	r3, r2
 8011628:	ddb4      	ble.n	8011594 <map_set_px+0x124>
}
 801162a:	bf00      	nop
 801162c:	3734      	adds	r7, #52	; 0x34
 801162e:	46bd      	mov	sp, r7
 8011630:	bdf0      	pop	{r4, r5, r6, r7, pc}

08011632 <map_normal>:
 */
LV_ATTRIBUTE_FAST_MEM static void map_normal(const lv_area_t * disp_area, lv_color_t * disp_buf,
                                             const lv_area_t * draw_area,
                                             const lv_area_t * map_area, const lv_color_t * map_buf, lv_opa_t opa,
                                             const lv_opa_t * mask, lv_draw_mask_res_t mask_res)
{
 8011632:	b5b0      	push	{r4, r5, r7, lr}
 8011634:	b094      	sub	sp, #80	; 0x50
 8011636:	af02      	add	r7, sp, #8
 8011638:	60f8      	str	r0, [r7, #12]
 801163a:	60b9      	str	r1, [r7, #8]
 801163c:	607a      	str	r2, [r7, #4]
 801163e:	603b      	str	r3, [r7, #0]

    /*Get the width of the `disp_area` it will be used to go to the next line*/
    int32_t disp_w = lv_area_get_width(disp_area);
 8011640:	68f8      	ldr	r0, [r7, #12]
 8011642:	f7ff f8e1 	bl	8010808 <lv_area_get_width>
 8011646:	4603      	mov	r3, r0
 8011648:	62fb      	str	r3, [r7, #44]	; 0x2c

    int32_t draw_area_w = lv_area_get_width(draw_area);
 801164a:	6878      	ldr	r0, [r7, #4]
 801164c:	f7ff f8dc 	bl	8010808 <lv_area_get_width>
 8011650:	4603      	mov	r3, r0
 8011652:	62bb      	str	r3, [r7, #40]	; 0x28
    int32_t draw_area_h = lv_area_get_height(draw_area);
 8011654:	6878      	ldr	r0, [r7, #4]
 8011656:	f7ff f8ee 	bl	8010836 <lv_area_get_height>
 801165a:	4603      	mov	r3, r0
 801165c:	627b      	str	r3, [r7, #36]	; 0x24

    /*Get the width of the `mask_area` it will be used to go to the next line*/
    int32_t map_w = lv_area_get_width(map_area);
 801165e:	6838      	ldr	r0, [r7, #0]
 8011660:	f7ff f8d2 	bl	8010808 <lv_area_get_width>
 8011664:	4603      	mov	r3, r0
 8011666:	623b      	str	r3, [r7, #32]

    /*Create a temp. disp_buf which always point to first pixel to draw*/
    lv_color_t * disp_buf_first = disp_buf + disp_w * draw_area->y1 + draw_area->x1;
 8011668:	687b      	ldr	r3, [r7, #4]
 801166a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801166e:	461a      	mov	r2, r3
 8011670:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011672:	fb02 f303 	mul.w	r3, r2, r3
 8011676:	461a      	mov	r2, r3
 8011678:	687b      	ldr	r3, [r7, #4]
 801167a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801167e:	4413      	add	r3, r2
 8011680:	005b      	lsls	r3, r3, #1
 8011682:	68ba      	ldr	r2, [r7, #8]
 8011684:	4413      	add	r3, r2
 8011686:	647b      	str	r3, [r7, #68]	; 0x44

    /*Create a temp. map_buf which always point to first pixel to draw from the map*/
    const lv_color_t * map_buf_first = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
 8011688:	687b      	ldr	r3, [r7, #4]
 801168a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801168e:	461a      	mov	r2, r3
 8011690:	683b      	ldr	r3, [r7, #0]
 8011692:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8011696:	4619      	mov	r1, r3
 8011698:	68fb      	ldr	r3, [r7, #12]
 801169a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801169e:	1acb      	subs	r3, r1, r3
 80116a0:	1ad3      	subs	r3, r2, r3
 80116a2:	6a3a      	ldr	r2, [r7, #32]
 80116a4:	fb02 f303 	mul.w	r3, r2, r3
 80116a8:	005b      	lsls	r3, r3, #1
 80116aa:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80116ac:	4413      	add	r3, r2
 80116ae:	643b      	str	r3, [r7, #64]	; 0x40
    map_buf_first += (draw_area->x1 - (map_area->x1 - disp_area->x1));
 80116b0:	687b      	ldr	r3, [r7, #4]
 80116b2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80116b6:	461a      	mov	r2, r3
 80116b8:	683b      	ldr	r3, [r7, #0]
 80116ba:	f9b3 3000 	ldrsh.w	r3, [r3]
 80116be:	4619      	mov	r1, r3
 80116c0:	68fb      	ldr	r3, [r7, #12]
 80116c2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80116c6:	1acb      	subs	r3, r1, r3
 80116c8:	1ad3      	subs	r3, r2, r3
 80116ca:	005b      	lsls	r3, r3, #1
 80116cc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80116ce:	4413      	add	r3, r2
 80116d0:	643b      	str	r3, [r7, #64]	; 0x40

#if LV_COLOR_SCREEN_TRANSP || LV_USE_GPU
    lv_disp_t * disp = _lv_refr_get_disp_refreshing();
 80116d2:	f7fc fe85 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 80116d6:	61f8      	str	r0, [r7, #28]

    int32_t x;
    int32_t y;

    /*Simple fill (maybe with opacity), no masking*/
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
 80116d8:	f897 3064 	ldrb.w	r3, [r7, #100]	; 0x64
 80116dc:	2b01      	cmp	r3, #1
 80116de:	f040 8082 	bne.w	80117e6 <map_normal+0x1b4>
#if LV_USE_GPU
        if(disp->driver.gpu_blend_cb && (lv_area_get_size(draw_area) > GPU_SIZE_LIMIT)) {
 80116e2:	69fb      	ldr	r3, [r7, #28]
 80116e4:	6a1b      	ldr	r3, [r3, #32]
 80116e6:	2b00      	cmp	r3, #0
 80116e8:	d02a      	beq.n	8011740 <map_normal+0x10e>
 80116ea:	6878      	ldr	r0, [r7, #4]
 80116ec:	f00d fe9d 	bl	801f42a <lv_area_get_size>
 80116f0:	4603      	mov	r3, r0
 80116f2:	2bf0      	cmp	r3, #240	; 0xf0
 80116f4:	d924      	bls.n	8011740 <map_normal+0x10e>
            for(y = draw_area->y1; y <= draw_area->y2; y++) {
 80116f6:	687b      	ldr	r3, [r7, #4]
 80116f8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80116fc:	63bb      	str	r3, [r7, #56]	; 0x38
 80116fe:	e017      	b.n	8011730 <map_normal+0xfe>
                disp->driver.gpu_blend_cb(&disp->driver, disp_buf_first, map_buf_first, draw_area_w, opa);
 8011700:	69fb      	ldr	r3, [r7, #28]
 8011702:	6a1c      	ldr	r4, [r3, #32]
 8011704:	69f8      	ldr	r0, [r7, #28]
 8011706:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011708:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 801170c:	9300      	str	r3, [sp, #0]
 801170e:	4613      	mov	r3, r2
 8011710:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011712:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8011714:	47a0      	blx	r4
                disp_buf_first += disp_w;
 8011716:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011718:	005b      	lsls	r3, r3, #1
 801171a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801171c:	4413      	add	r3, r2
 801171e:	647b      	str	r3, [r7, #68]	; 0x44
                map_buf_first += map_w;
 8011720:	6a3b      	ldr	r3, [r7, #32]
 8011722:	005b      	lsls	r3, r3, #1
 8011724:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011726:	4413      	add	r3, r2
 8011728:	643b      	str	r3, [r7, #64]	; 0x40
            for(y = draw_area->y1; y <= draw_area->y2; y++) {
 801172a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801172c:	3301      	adds	r3, #1
 801172e:	63bb      	str	r3, [r7, #56]	; 0x38
 8011730:	687b      	ldr	r3, [r7, #4]
 8011732:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8011736:	461a      	mov	r2, r3
 8011738:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801173a:	4293      	cmp	r3, r2
 801173c:	dde0      	ble.n	8011700 <map_normal+0xce>
            }
            return;
 801173e:	e238      	b.n	8011bb2 <map_normal+0x580>
        }
#endif

        if(opa > LV_OPA_MAX) {
 8011740:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8011744:	2bfd      	cmp	r3, #253	; 0xfd
 8011746:	d91b      	bls.n	8011780 <map_normal+0x14e>
                return;
            }
#endif

            /*Software rendering*/
            for(y = 0; y < draw_area_h; y++) {
 8011748:	2300      	movs	r3, #0
 801174a:	63bb      	str	r3, [r7, #56]	; 0x38
 801174c:	e013      	b.n	8011776 <map_normal+0x144>
                _lv_memcpy(disp_buf_first, map_buf_first, draw_area_w * sizeof(lv_color_t));
 801174e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011750:	005b      	lsls	r3, r3, #1
 8011752:	461a      	mov	r2, r3
 8011754:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8011756:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011758:	f00f fd00 	bl	802115c <_lv_memcpy>
                disp_buf_first += disp_w;
 801175c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801175e:	005b      	lsls	r3, r3, #1
 8011760:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8011762:	4413      	add	r3, r2
 8011764:	647b      	str	r3, [r7, #68]	; 0x44
                map_buf_first += map_w;
 8011766:	6a3b      	ldr	r3, [r7, #32]
 8011768:	005b      	lsls	r3, r3, #1
 801176a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801176c:	4413      	add	r3, r2
 801176e:	643b      	str	r3, [r7, #64]	; 0x40
            for(y = 0; y < draw_area_h; y++) {
 8011770:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011772:	3301      	adds	r3, #1
 8011774:	63bb      	str	r3, [r7, #56]	; 0x38
 8011776:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8011778:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801177a:	429a      	cmp	r2, r3
 801177c:	dbe7      	blt.n	801174e <map_normal+0x11c>
 801177e:	e218      	b.n	8011bb2 <map_normal+0x580>
            }
#endif

            /*Software rendering*/

            for(y = 0; y < draw_area_h; y++) {
 8011780:	2300      	movs	r3, #0
 8011782:	63bb      	str	r3, [r7, #56]	; 0x38
 8011784:	e02a      	b.n	80117dc <map_normal+0x1aa>
                for(x = 0; x < draw_area_w; x++) {
 8011786:	2300      	movs	r3, #0
 8011788:	63fb      	str	r3, [r7, #60]	; 0x3c
 801178a:	e016      	b.n	80117ba <map_normal+0x188>
                                                &disp_buf_first[x].ch.alpha);
                    }
                    else
#endif
                    {
                        disp_buf_first[x] = lv_color_mix(map_buf_first[x], disp_buf_first[x], opa);
 801178c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801178e:	005b      	lsls	r3, r3, #1
 8011790:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011792:	4413      	add	r3, r2
 8011794:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011796:	0052      	lsls	r2, r2, #1
 8011798:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801179a:	4411      	add	r1, r2
 801179c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801179e:	0052      	lsls	r2, r2, #1
 80117a0:	6c78      	ldr	r0, [r7, #68]	; 0x44
 80117a2:	1884      	adds	r4, r0, r2
 80117a4:	f897 205c 	ldrb.w	r2, [r7, #92]	; 0x5c
 80117a8:	8809      	ldrh	r1, [r1, #0]
 80117aa:	8818      	ldrh	r0, [r3, #0]
 80117ac:	f7fe ff24 	bl	80105f8 <lv_color_mix>
 80117b0:	4603      	mov	r3, r0
 80117b2:	8023      	strh	r3, [r4, #0]
                for(x = 0; x < draw_area_w; x++) {
 80117b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80117b6:	3301      	adds	r3, #1
 80117b8:	63fb      	str	r3, [r7, #60]	; 0x3c
 80117ba:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80117bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80117be:	429a      	cmp	r2, r3
 80117c0:	dbe4      	blt.n	801178c <map_normal+0x15a>
                    }
                }
                disp_buf_first += disp_w;
 80117c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80117c4:	005b      	lsls	r3, r3, #1
 80117c6:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80117c8:	4413      	add	r3, r2
 80117ca:	647b      	str	r3, [r7, #68]	; 0x44
                map_buf_first += map_w;
 80117cc:	6a3b      	ldr	r3, [r7, #32]
 80117ce:	005b      	lsls	r3, r3, #1
 80117d0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80117d2:	4413      	add	r3, r2
 80117d4:	643b      	str	r3, [r7, #64]	; 0x40
            for(y = 0; y < draw_area_h; y++) {
 80117d6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80117d8:	3301      	adds	r3, #1
 80117da:	63bb      	str	r3, [r7, #56]	; 0x38
 80117dc:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80117de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80117e0:	429a      	cmp	r2, r3
 80117e2:	dbd0      	blt.n	8011786 <map_normal+0x154>
 80117e4:	e1e5      	b.n	8011bb2 <map_normal+0x580>
        }
    }
    /*Masked*/
    else {
        /*Only the mask matters*/
        if(opa > LV_OPA_MAX) {
 80117e6:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 80117ea:	2bfd      	cmp	r3, #253	; 0xfd
 80117ec:	f240 8192 	bls.w	8011b14 <map_normal+0x4e2>
            /*Go to the first pixel of the row */

            int32_t x_end4 = draw_area_w - 4;
 80117f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80117f2:	3b04      	subs	r3, #4
 80117f4:	617b      	str	r3, [r7, #20]

            for(y = 0; y < draw_area_h; y++) {
 80117f6:	2300      	movs	r3, #0
 80117f8:	63bb      	str	r3, [r7, #56]	; 0x38
 80117fa:	e185      	b.n	8011b08 <map_normal+0x4d6>
                const lv_opa_t * mask_tmp_x = mask;
 80117fc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80117fe:	637b      	str	r3, [r7, #52]	; 0x34
#if 0
                for(x = 0; x < draw_area_w; x++) {
                    MAP_NORMAL_MASK_PX(x);
                }
#else
                for(x = 0; x < draw_area_w && ((lv_uintptr_t)mask_tmp_x & 0x3); x++) {
 8011800:	2300      	movs	r3, #0
 8011802:	63fb      	str	r3, [r7, #60]	; 0x3c
 8011804:	e02d      	b.n	8011862 <map_normal+0x230>
#if LV_COLOR_SCREEN_TRANSP
                    MAP_NORMAL_MASK_PX_SCR_TRANSP(x)
#else
                    MAP_NORMAL_MASK_PX(x)
 8011806:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011808:	781b      	ldrb	r3, [r3, #0]
 801180a:	2b00      	cmp	r3, #0
 801180c:	d023      	beq.n	8011856 <map_normal+0x224>
 801180e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011810:	781b      	ldrb	r3, [r3, #0]
 8011812:	2bff      	cmp	r3, #255	; 0xff
 8011814:	d10a      	bne.n	801182c <map_normal+0x1fa>
 8011816:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011818:	005b      	lsls	r3, r3, #1
 801181a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801181c:	441a      	add	r2, r3
 801181e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011820:	005b      	lsls	r3, r3, #1
 8011822:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8011824:	440b      	add	r3, r1
 8011826:	8812      	ldrh	r2, [r2, #0]
 8011828:	801a      	strh	r2, [r3, #0]
 801182a:	e014      	b.n	8011856 <map_normal+0x224>
 801182c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801182e:	005b      	lsls	r3, r3, #1
 8011830:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011832:	4413      	add	r3, r2
 8011834:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011836:	0052      	lsls	r2, r2, #1
 8011838:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801183a:	4411      	add	r1, r2
 801183c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801183e:	7815      	ldrb	r5, [r2, #0]
 8011840:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011842:	0052      	lsls	r2, r2, #1
 8011844:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011846:	1884      	adds	r4, r0, r2
 8011848:	462a      	mov	r2, r5
 801184a:	8809      	ldrh	r1, [r1, #0]
 801184c:	8818      	ldrh	r0, [r3, #0]
 801184e:	f7fe fed3 	bl	80105f8 <lv_color_mix>
 8011852:	4603      	mov	r3, r0
 8011854:	8023      	strh	r3, [r4, #0]
 8011856:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011858:	3301      	adds	r3, #1
 801185a:	637b      	str	r3, [r7, #52]	; 0x34
                for(x = 0; x < draw_area_w && ((lv_uintptr_t)mask_tmp_x & 0x3); x++) {
 801185c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801185e:	3301      	adds	r3, #1
 8011860:	63fb      	str	r3, [r7, #60]	; 0x3c
 8011862:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011864:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011866:	429a      	cmp	r2, r3
 8011868:	da04      	bge.n	8011874 <map_normal+0x242>
 801186a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801186c:	f003 0303 	and.w	r3, r3, #3
 8011870:	2b00      	cmp	r3, #0
 8011872:	d1c8      	bne.n	8011806 <map_normal+0x1d4>
#endif
                }

                uint32_t * mask32 = (uint32_t *) mask_tmp_x;
 8011874:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011876:	633b      	str	r3, [r7, #48]	; 0x30
                for(; x < x_end4; x += 4) {
 8011878:	e0fb      	b.n	8011a72 <map_normal+0x440>
                    if(*mask32) {
 801187a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801187c:	681b      	ldr	r3, [r3, #0]
 801187e:	2b00      	cmp	r3, #0
 8011880:	f000 80f1 	beq.w	8011a66 <map_normal+0x434>
                        if((*mask32) == 0xFFFFFFFF) {
 8011884:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011886:	681b      	ldr	r3, [r3, #0]
 8011888:	f1b3 3fff 	cmp.w	r3, #4294967295
 801188c:	d12e      	bne.n	80118ec <map_normal+0x2ba>
                            disp_buf_first[x] = map_buf_first[x];
 801188e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011890:	005b      	lsls	r3, r3, #1
 8011892:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011894:	441a      	add	r2, r3
 8011896:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011898:	005b      	lsls	r3, r3, #1
 801189a:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801189c:	440b      	add	r3, r1
 801189e:	8812      	ldrh	r2, [r2, #0]
 80118a0:	801a      	strh	r2, [r3, #0]
                            disp_buf_first[x + 1] = map_buf_first[x + 1];
 80118a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80118a4:	3301      	adds	r3, #1
 80118a6:	005b      	lsls	r3, r3, #1
 80118a8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80118aa:	441a      	add	r2, r3
 80118ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80118ae:	3301      	adds	r3, #1
 80118b0:	005b      	lsls	r3, r3, #1
 80118b2:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80118b4:	440b      	add	r3, r1
 80118b6:	8812      	ldrh	r2, [r2, #0]
 80118b8:	801a      	strh	r2, [r3, #0]
                            disp_buf_first[x + 2] = map_buf_first[x + 2];
 80118ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80118bc:	3302      	adds	r3, #2
 80118be:	005b      	lsls	r3, r3, #1
 80118c0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80118c2:	441a      	add	r2, r3
 80118c4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80118c6:	3302      	adds	r3, #2
 80118c8:	005b      	lsls	r3, r3, #1
 80118ca:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80118cc:	440b      	add	r3, r1
 80118ce:	8812      	ldrh	r2, [r2, #0]
 80118d0:	801a      	strh	r2, [r3, #0]
                            disp_buf_first[x + 3] = map_buf_first[x + 3];
 80118d2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80118d4:	3303      	adds	r3, #3
 80118d6:	005b      	lsls	r3, r3, #1
 80118d8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80118da:	441a      	add	r2, r3
 80118dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80118de:	3303      	adds	r3, #3
 80118e0:	005b      	lsls	r3, r3, #1
 80118e2:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80118e4:	440b      	add	r3, r1
 80118e6:	8812      	ldrh	r2, [r2, #0]
 80118e8:	801a      	strh	r2, [r3, #0]
 80118ea:	e0bc      	b.n	8011a66 <map_normal+0x434>
                        }
                        else {
                            mask_tmp_x = (const lv_opa_t *)mask32;
 80118ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80118ee:	637b      	str	r3, [r7, #52]	; 0x34
                            MAP_NORMAL_MASK_PX_SCR_TRANSP(x)
                            MAP_NORMAL_MASK_PX_SCR_TRANSP(x + 1)
                            MAP_NORMAL_MASK_PX_SCR_TRANSP(x + 2)
                            MAP_NORMAL_MASK_PX_SCR_TRANSP(x + 3)
#else
                            MAP_NORMAL_MASK_PX(x)
 80118f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80118f2:	781b      	ldrb	r3, [r3, #0]
 80118f4:	2b00      	cmp	r3, #0
 80118f6:	d023      	beq.n	8011940 <map_normal+0x30e>
 80118f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80118fa:	781b      	ldrb	r3, [r3, #0]
 80118fc:	2bff      	cmp	r3, #255	; 0xff
 80118fe:	d10a      	bne.n	8011916 <map_normal+0x2e4>
 8011900:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011902:	005b      	lsls	r3, r3, #1
 8011904:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011906:	441a      	add	r2, r3
 8011908:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801190a:	005b      	lsls	r3, r3, #1
 801190c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801190e:	440b      	add	r3, r1
 8011910:	8812      	ldrh	r2, [r2, #0]
 8011912:	801a      	strh	r2, [r3, #0]
 8011914:	e014      	b.n	8011940 <map_normal+0x30e>
 8011916:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011918:	005b      	lsls	r3, r3, #1
 801191a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801191c:	4413      	add	r3, r2
 801191e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011920:	0052      	lsls	r2, r2, #1
 8011922:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8011924:	4411      	add	r1, r2
 8011926:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011928:	7815      	ldrb	r5, [r2, #0]
 801192a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801192c:	0052      	lsls	r2, r2, #1
 801192e:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011930:	1884      	adds	r4, r0, r2
 8011932:	462a      	mov	r2, r5
 8011934:	8809      	ldrh	r1, [r1, #0]
 8011936:	8818      	ldrh	r0, [r3, #0]
 8011938:	f7fe fe5e 	bl	80105f8 <lv_color_mix>
 801193c:	4603      	mov	r3, r0
 801193e:	8023      	strh	r3, [r4, #0]
 8011940:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011942:	3301      	adds	r3, #1
 8011944:	637b      	str	r3, [r7, #52]	; 0x34
                            MAP_NORMAL_MASK_PX(x + 1)
 8011946:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011948:	781b      	ldrb	r3, [r3, #0]
 801194a:	2b00      	cmp	r3, #0
 801194c:	d028      	beq.n	80119a0 <map_normal+0x36e>
 801194e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011950:	781b      	ldrb	r3, [r3, #0]
 8011952:	2bff      	cmp	r3, #255	; 0xff
 8011954:	d10c      	bne.n	8011970 <map_normal+0x33e>
 8011956:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011958:	3301      	adds	r3, #1
 801195a:	005b      	lsls	r3, r3, #1
 801195c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801195e:	441a      	add	r2, r3
 8011960:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011962:	3301      	adds	r3, #1
 8011964:	005b      	lsls	r3, r3, #1
 8011966:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8011968:	440b      	add	r3, r1
 801196a:	8812      	ldrh	r2, [r2, #0]
 801196c:	801a      	strh	r2, [r3, #0]
 801196e:	e017      	b.n	80119a0 <map_normal+0x36e>
 8011970:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011972:	3301      	adds	r3, #1
 8011974:	005b      	lsls	r3, r3, #1
 8011976:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011978:	4413      	add	r3, r2
 801197a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801197c:	3201      	adds	r2, #1
 801197e:	0052      	lsls	r2, r2, #1
 8011980:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8011982:	4411      	add	r1, r2
 8011984:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011986:	7815      	ldrb	r5, [r2, #0]
 8011988:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801198a:	3201      	adds	r2, #1
 801198c:	0052      	lsls	r2, r2, #1
 801198e:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011990:	1884      	adds	r4, r0, r2
 8011992:	462a      	mov	r2, r5
 8011994:	8809      	ldrh	r1, [r1, #0]
 8011996:	8818      	ldrh	r0, [r3, #0]
 8011998:	f7fe fe2e 	bl	80105f8 <lv_color_mix>
 801199c:	4603      	mov	r3, r0
 801199e:	8023      	strh	r3, [r4, #0]
 80119a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80119a2:	3301      	adds	r3, #1
 80119a4:	637b      	str	r3, [r7, #52]	; 0x34
                            MAP_NORMAL_MASK_PX(x + 2)
 80119a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80119a8:	781b      	ldrb	r3, [r3, #0]
 80119aa:	2b00      	cmp	r3, #0
 80119ac:	d028      	beq.n	8011a00 <map_normal+0x3ce>
 80119ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80119b0:	781b      	ldrb	r3, [r3, #0]
 80119b2:	2bff      	cmp	r3, #255	; 0xff
 80119b4:	d10c      	bne.n	80119d0 <map_normal+0x39e>
 80119b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80119b8:	3302      	adds	r3, #2
 80119ba:	005b      	lsls	r3, r3, #1
 80119bc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80119be:	441a      	add	r2, r3
 80119c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80119c2:	3302      	adds	r3, #2
 80119c4:	005b      	lsls	r3, r3, #1
 80119c6:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80119c8:	440b      	add	r3, r1
 80119ca:	8812      	ldrh	r2, [r2, #0]
 80119cc:	801a      	strh	r2, [r3, #0]
 80119ce:	e017      	b.n	8011a00 <map_normal+0x3ce>
 80119d0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80119d2:	3302      	adds	r3, #2
 80119d4:	005b      	lsls	r3, r3, #1
 80119d6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80119d8:	4413      	add	r3, r2
 80119da:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80119dc:	3202      	adds	r2, #2
 80119de:	0052      	lsls	r2, r2, #1
 80119e0:	6c79      	ldr	r1, [r7, #68]	; 0x44
 80119e2:	4411      	add	r1, r2
 80119e4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80119e6:	7815      	ldrb	r5, [r2, #0]
 80119e8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80119ea:	3202      	adds	r2, #2
 80119ec:	0052      	lsls	r2, r2, #1
 80119ee:	6c78      	ldr	r0, [r7, #68]	; 0x44
 80119f0:	1884      	adds	r4, r0, r2
 80119f2:	462a      	mov	r2, r5
 80119f4:	8809      	ldrh	r1, [r1, #0]
 80119f6:	8818      	ldrh	r0, [r3, #0]
 80119f8:	f7fe fdfe 	bl	80105f8 <lv_color_mix>
 80119fc:	4603      	mov	r3, r0
 80119fe:	8023      	strh	r3, [r4, #0]
 8011a00:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011a02:	3301      	adds	r3, #1
 8011a04:	637b      	str	r3, [r7, #52]	; 0x34
                            MAP_NORMAL_MASK_PX(x + 3)
 8011a06:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011a08:	781b      	ldrb	r3, [r3, #0]
 8011a0a:	2b00      	cmp	r3, #0
 8011a0c:	d028      	beq.n	8011a60 <map_normal+0x42e>
 8011a0e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011a10:	781b      	ldrb	r3, [r3, #0]
 8011a12:	2bff      	cmp	r3, #255	; 0xff
 8011a14:	d10c      	bne.n	8011a30 <map_normal+0x3fe>
 8011a16:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011a18:	3303      	adds	r3, #3
 8011a1a:	005b      	lsls	r3, r3, #1
 8011a1c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011a1e:	441a      	add	r2, r3
 8011a20:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011a22:	3303      	adds	r3, #3
 8011a24:	005b      	lsls	r3, r3, #1
 8011a26:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8011a28:	440b      	add	r3, r1
 8011a2a:	8812      	ldrh	r2, [r2, #0]
 8011a2c:	801a      	strh	r2, [r3, #0]
 8011a2e:	e017      	b.n	8011a60 <map_normal+0x42e>
 8011a30:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011a32:	3303      	adds	r3, #3
 8011a34:	005b      	lsls	r3, r3, #1
 8011a36:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011a38:	4413      	add	r3, r2
 8011a3a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011a3c:	3203      	adds	r2, #3
 8011a3e:	0052      	lsls	r2, r2, #1
 8011a40:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8011a42:	4411      	add	r1, r2
 8011a44:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011a46:	7815      	ldrb	r5, [r2, #0]
 8011a48:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011a4a:	3203      	adds	r2, #3
 8011a4c:	0052      	lsls	r2, r2, #1
 8011a4e:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011a50:	1884      	adds	r4, r0, r2
 8011a52:	462a      	mov	r2, r5
 8011a54:	8809      	ldrh	r1, [r1, #0]
 8011a56:	8818      	ldrh	r0, [r3, #0]
 8011a58:	f7fe fdce 	bl	80105f8 <lv_color_mix>
 8011a5c:	4603      	mov	r3, r0
 8011a5e:	8023      	strh	r3, [r4, #0]
 8011a60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011a62:	3301      	adds	r3, #1
 8011a64:	637b      	str	r3, [r7, #52]	; 0x34
#endif
                        }
                    }
                    mask32++;
 8011a66:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011a68:	3304      	adds	r3, #4
 8011a6a:	633b      	str	r3, [r7, #48]	; 0x30
                for(; x < x_end4; x += 4) {
 8011a6c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011a6e:	3304      	adds	r3, #4
 8011a70:	63fb      	str	r3, [r7, #60]	; 0x3c
 8011a72:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011a74:	697b      	ldr	r3, [r7, #20]
 8011a76:	429a      	cmp	r2, r3
 8011a78:	f6ff aeff 	blt.w	801187a <map_normal+0x248>
                }

                mask_tmp_x = (const lv_opa_t *)mask32;
 8011a7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011a7e:	637b      	str	r3, [r7, #52]	; 0x34
                for(; x < draw_area_w ; x++) {
 8011a80:	e02d      	b.n	8011ade <map_normal+0x4ac>
#if LV_COLOR_SCREEN_TRANSP
                    MAP_NORMAL_MASK_PX_SCR_TRANSP(x)
#else
                    MAP_NORMAL_MASK_PX(x)
 8011a82:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011a84:	781b      	ldrb	r3, [r3, #0]
 8011a86:	2b00      	cmp	r3, #0
 8011a88:	d023      	beq.n	8011ad2 <map_normal+0x4a0>
 8011a8a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011a8c:	781b      	ldrb	r3, [r3, #0]
 8011a8e:	2bff      	cmp	r3, #255	; 0xff
 8011a90:	d10a      	bne.n	8011aa8 <map_normal+0x476>
 8011a92:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011a94:	005b      	lsls	r3, r3, #1
 8011a96:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011a98:	441a      	add	r2, r3
 8011a9a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011a9c:	005b      	lsls	r3, r3, #1
 8011a9e:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8011aa0:	440b      	add	r3, r1
 8011aa2:	8812      	ldrh	r2, [r2, #0]
 8011aa4:	801a      	strh	r2, [r3, #0]
 8011aa6:	e014      	b.n	8011ad2 <map_normal+0x4a0>
 8011aa8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011aaa:	005b      	lsls	r3, r3, #1
 8011aac:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011aae:	4413      	add	r3, r2
 8011ab0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011ab2:	0052      	lsls	r2, r2, #1
 8011ab4:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8011ab6:	4411      	add	r1, r2
 8011ab8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011aba:	7815      	ldrb	r5, [r2, #0]
 8011abc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011abe:	0052      	lsls	r2, r2, #1
 8011ac0:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011ac2:	1884      	adds	r4, r0, r2
 8011ac4:	462a      	mov	r2, r5
 8011ac6:	8809      	ldrh	r1, [r1, #0]
 8011ac8:	8818      	ldrh	r0, [r3, #0]
 8011aca:	f7fe fd95 	bl	80105f8 <lv_color_mix>
 8011ace:	4603      	mov	r3, r0
 8011ad0:	8023      	strh	r3, [r4, #0]
 8011ad2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011ad4:	3301      	adds	r3, #1
 8011ad6:	637b      	str	r3, [r7, #52]	; 0x34
                for(; x < draw_area_w ; x++) {
 8011ad8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011ada:	3301      	adds	r3, #1
 8011adc:	63fb      	str	r3, [r7, #60]	; 0x3c
 8011ade:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011ae0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011ae2:	429a      	cmp	r2, r3
 8011ae4:	dbcd      	blt.n	8011a82 <map_normal+0x450>
#endif
                }
#endif
                disp_buf_first += disp_w;
 8011ae6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011ae8:	005b      	lsls	r3, r3, #1
 8011aea:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8011aec:	4413      	add	r3, r2
 8011aee:	647b      	str	r3, [r7, #68]	; 0x44
                mask += draw_area_w;
 8011af0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011af2:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8011af4:	4413      	add	r3, r2
 8011af6:	663b      	str	r3, [r7, #96]	; 0x60
                map_buf_first += map_w;
 8011af8:	6a3b      	ldr	r3, [r7, #32]
 8011afa:	005b      	lsls	r3, r3, #1
 8011afc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011afe:	4413      	add	r3, r2
 8011b00:	643b      	str	r3, [r7, #64]	; 0x40
            for(y = 0; y < draw_area_h; y++) {
 8011b02:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011b04:	3301      	adds	r3, #1
 8011b06:	63bb      	str	r3, [r7, #56]	; 0x38
 8011b08:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8011b0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011b0c:	429a      	cmp	r2, r3
 8011b0e:	f6ff ae75 	blt.w	80117fc <map_normal+0x1ca>
 8011b12:	e04e      	b.n	8011bb2 <map_normal+0x580>
            }
        }
        /*Handle opa and mask values too*/
        else {
            for(y = 0; y < draw_area_h; y++) {
 8011b14:	2300      	movs	r3, #0
 8011b16:	63bb      	str	r3, [r7, #56]	; 0x38
 8011b18:	e047      	b.n	8011baa <map_normal+0x578>
                for(x = 0; x < draw_area_w; x++) {
 8011b1a:	2300      	movs	r3, #0
 8011b1c:	63fb      	str	r3, [r7, #60]	; 0x3c
 8011b1e:	e02f      	b.n	8011b80 <map_normal+0x54e>
                    if(mask[x]) {
 8011b20:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011b22:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8011b24:	4413      	add	r3, r2
 8011b26:	781b      	ldrb	r3, [r3, #0]
 8011b28:	2b00      	cmp	r3, #0
 8011b2a:	d026      	beq.n	8011b7a <map_normal+0x548>
                        lv_opa_t opa_tmp = mask[x] >= LV_OPA_MAX ? opa : ((opa * mask[x]) >> 8);
 8011b2c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011b2e:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8011b30:	4413      	add	r3, r2
 8011b32:	781b      	ldrb	r3, [r3, #0]
 8011b34:	2bfc      	cmp	r3, #252	; 0xfc
 8011b36:	d80a      	bhi.n	8011b4e <map_normal+0x51c>
 8011b38:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8011b3c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011b3e:	6e39      	ldr	r1, [r7, #96]	; 0x60
 8011b40:	440a      	add	r2, r1
 8011b42:	7812      	ldrb	r2, [r2, #0]
 8011b44:	fb02 f303 	mul.w	r3, r2, r3
 8011b48:	121b      	asrs	r3, r3, #8
 8011b4a:	b2db      	uxtb	r3, r3
 8011b4c:	e001      	b.n	8011b52 <map_normal+0x520>
 8011b4e:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8011b52:	76fb      	strb	r3, [r7, #27]
                                                    &disp_buf_first[x].ch.alpha);
                        }
                        else
#endif
                        {
                            disp_buf_first[x] = lv_color_mix(map_buf_first[x], disp_buf_first[x], opa_tmp);
 8011b54:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011b56:	005b      	lsls	r3, r3, #1
 8011b58:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011b5a:	4413      	add	r3, r2
 8011b5c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011b5e:	0052      	lsls	r2, r2, #1
 8011b60:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8011b62:	4411      	add	r1, r2
 8011b64:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011b66:	0052      	lsls	r2, r2, #1
 8011b68:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8011b6a:	1884      	adds	r4, r0, r2
 8011b6c:	7efa      	ldrb	r2, [r7, #27]
 8011b6e:	8809      	ldrh	r1, [r1, #0]
 8011b70:	8818      	ldrh	r0, [r3, #0]
 8011b72:	f7fe fd41 	bl	80105f8 <lv_color_mix>
 8011b76:	4603      	mov	r3, r0
 8011b78:	8023      	strh	r3, [r4, #0]
                for(x = 0; x < draw_area_w; x++) {
 8011b7a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011b7c:	3301      	adds	r3, #1
 8011b7e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8011b80:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8011b82:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011b84:	429a      	cmp	r2, r3
 8011b86:	dbcb      	blt.n	8011b20 <map_normal+0x4ee>
                        }
                    }
                }
                disp_buf_first += disp_w;
 8011b88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011b8a:	005b      	lsls	r3, r3, #1
 8011b8c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8011b8e:	4413      	add	r3, r2
 8011b90:	647b      	str	r3, [r7, #68]	; 0x44
                mask += draw_area_w;
 8011b92:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011b94:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8011b96:	4413      	add	r3, r2
 8011b98:	663b      	str	r3, [r7, #96]	; 0x60
                map_buf_first += map_w;
 8011b9a:	6a3b      	ldr	r3, [r7, #32]
 8011b9c:	005b      	lsls	r3, r3, #1
 8011b9e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011ba0:	4413      	add	r3, r2
 8011ba2:	643b      	str	r3, [r7, #64]	; 0x40
            for(y = 0; y < draw_area_h; y++) {
 8011ba4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011ba6:	3301      	adds	r3, #1
 8011ba8:	63bb      	str	r3, [r7, #56]	; 0x38
 8011baa:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8011bac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011bae:	429a      	cmp	r2, r3
 8011bb0:	dbb3      	blt.n	8011b1a <map_normal+0x4e8>
            }
        }
    }
}
 8011bb2:	3748      	adds	r7, #72	; 0x48
 8011bb4:	46bd      	mov	sp, r7
 8011bb6:	bdb0      	pop	{r4, r5, r7, pc}

08011bb8 <map_blended>:
#if LV_USE_BLEND_MODES
static void map_blended(const lv_area_t * disp_area, lv_color_t * disp_buf,  const lv_area_t * draw_area,
                        const lv_area_t * map_area, const lv_color_t * map_buf, lv_opa_t opa,
                        const lv_opa_t * mask, lv_draw_mask_res_t mask_res, lv_blend_mode_t mode)
{
 8011bb8:	b590      	push	{r4, r7, lr}
 8011bba:	b08f      	sub	sp, #60	; 0x3c
 8011bbc:	af00      	add	r7, sp, #0
 8011bbe:	60f8      	str	r0, [r7, #12]
 8011bc0:	60b9      	str	r1, [r7, #8]
 8011bc2:	607a      	str	r2, [r7, #4]
 8011bc4:	603b      	str	r3, [r7, #0]

    /*Get the width of the `disp_area` it will be used to go to the next line*/
    int32_t disp_w = lv_area_get_width(disp_area);
 8011bc6:	68f8      	ldr	r0, [r7, #12]
 8011bc8:	f7fe fe1e 	bl	8010808 <lv_area_get_width>
 8011bcc:	4603      	mov	r3, r0
 8011bce:	61fb      	str	r3, [r7, #28]

    /*Get the width of the `draw_area` it will be used to go to the next line of the mask*/
    int32_t draw_area_w = lv_area_get_width(draw_area);
 8011bd0:	6878      	ldr	r0, [r7, #4]
 8011bd2:	f7fe fe19 	bl	8010808 <lv_area_get_width>
 8011bd6:	4603      	mov	r3, r0
 8011bd8:	61bb      	str	r3, [r7, #24]

    /*Get the width of the `mask_area` it will be used to go to the next line*/
    int32_t map_w = lv_area_get_width(map_area);
 8011bda:	6838      	ldr	r0, [r7, #0]
 8011bdc:	f7fe fe14 	bl	8010808 <lv_area_get_width>
 8011be0:	4603      	mov	r3, r0
 8011be2:	617b      	str	r3, [r7, #20]

    /*Create a temp. disp_buf which always point to current line to draw*/
    lv_color_t * disp_buf_tmp = disp_buf + disp_w * draw_area->y1;
 8011be4:	687b      	ldr	r3, [r7, #4]
 8011be6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8011bea:	461a      	mov	r2, r3
 8011bec:	69fb      	ldr	r3, [r7, #28]
 8011bee:	fb02 f303 	mul.w	r3, r2, r3
 8011bf2:	005b      	lsls	r3, r3, #1
 8011bf4:	68ba      	ldr	r2, [r7, #8]
 8011bf6:	4413      	add	r3, r2
 8011bf8:	637b      	str	r3, [r7, #52]	; 0x34

    /*Create a temp. map_buf which always point to current line to draw*/
    const lv_color_t * map_buf_tmp = map_buf + map_w * (draw_area->y1 - (map_area->y1 - disp_area->y1));
 8011bfa:	687b      	ldr	r3, [r7, #4]
 8011bfc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8011c00:	461a      	mov	r2, r3
 8011c02:	683b      	ldr	r3, [r7, #0]
 8011c04:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8011c08:	4619      	mov	r1, r3
 8011c0a:	68fb      	ldr	r3, [r7, #12]
 8011c0c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8011c10:	1acb      	subs	r3, r1, r3
 8011c12:	1ad3      	subs	r3, r2, r3
 8011c14:	697a      	ldr	r2, [r7, #20]
 8011c16:	fb02 f303 	mul.w	r3, r2, r3
 8011c1a:	005b      	lsls	r3, r3, #1
 8011c1c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8011c1e:	4413      	add	r3, r2
 8011c20:	633b      	str	r3, [r7, #48]	; 0x30

    lv_color_t (*blend_fp)(lv_color_t, lv_color_t, lv_opa_t);
    switch(mode) {
 8011c22:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
 8011c26:	2b01      	cmp	r3, #1
 8011c28:	d002      	beq.n	8011c30 <map_blended+0x78>
 8011c2a:	2b02      	cmp	r3, #2
 8011c2c:	d003      	beq.n	8011c36 <map_blended+0x7e>
        case LV_BLEND_MODE_SUBTRACTIVE:
            blend_fp = color_blend_true_color_subtractive;
            break;
        default:
            LV_LOG_WARN("fill_blended: unsupported blend mode");
            return;
 8011c2e:	e0c9      	b.n	8011dc4 <map_blended+0x20c>
            blend_fp = color_blend_true_color_additive;
 8011c30:	4b66      	ldr	r3, [pc, #408]	; (8011dcc <map_blended+0x214>)
 8011c32:	62fb      	str	r3, [r7, #44]	; 0x2c
            break;
 8011c34:	e002      	b.n	8011c3c <map_blended+0x84>
            blend_fp = color_blend_true_color_subtractive;
 8011c36:	4b66      	ldr	r3, [pc, #408]	; (8011dd0 <map_blended+0x218>)
 8011c38:	62fb      	str	r3, [r7, #44]	; 0x2c
            break;
 8011c3a:	bf00      	nop

    int32_t x;
    int32_t y;

    /*Simple fill (maybe with opacity), no masking*/
    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) {
 8011c3c:	f897 3054 	ldrb.w	r3, [r7, #84]	; 0x54
 8011c40:	2b01      	cmp	r3, #1
 8011c42:	d155      	bne.n	8011cf0 <map_blended+0x138>
        /*Go to the first px of the row*/
        map_buf_tmp += (draw_area->x1 - (map_area->x1 - disp_area->x1));
 8011c44:	687b      	ldr	r3, [r7, #4]
 8011c46:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011c4a:	461a      	mov	r2, r3
 8011c4c:	683b      	ldr	r3, [r7, #0]
 8011c4e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011c52:	4619      	mov	r1, r3
 8011c54:	68fb      	ldr	r3, [r7, #12]
 8011c56:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011c5a:	1acb      	subs	r3, r1, r3
 8011c5c:	1ad3      	subs	r3, r2, r3
 8011c5e:	005b      	lsls	r3, r3, #1
 8011c60:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011c62:	4413      	add	r3, r2
 8011c64:	633b      	str	r3, [r7, #48]	; 0x30

        /*The map will be indexed from `draw_area->x1` so compensate it.*/
        map_buf_tmp -= draw_area->x1;
 8011c66:	687b      	ldr	r3, [r7, #4]
 8011c68:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011c6c:	005b      	lsls	r3, r3, #1
 8011c6e:	425b      	negs	r3, r3
 8011c70:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011c72:	4413      	add	r3, r2
 8011c74:	633b      	str	r3, [r7, #48]	; 0x30

        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8011c76:	687b      	ldr	r3, [r7, #4]
 8011c78:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8011c7c:	627b      	str	r3, [r7, #36]	; 0x24
 8011c7e:	e02f      	b.n	8011ce0 <map_blended+0x128>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8011c80:	687b      	ldr	r3, [r7, #4]
 8011c82:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011c86:	62bb      	str	r3, [r7, #40]	; 0x28
 8011c88:	e016      	b.n	8011cb8 <map_blended+0x100>
                disp_buf_tmp[x] = blend_fp(map_buf_tmp[x], disp_buf_tmp[x], opa);
 8011c8a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011c8c:	005b      	lsls	r3, r3, #1
 8011c8e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011c90:	18d0      	adds	r0, r2, r3
 8011c92:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011c94:	005b      	lsls	r3, r3, #1
 8011c96:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011c98:	18d1      	adds	r1, r2, r3
 8011c9a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011c9c:	005b      	lsls	r3, r3, #1
 8011c9e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011ca0:	18d4      	adds	r4, r2, r3
 8011ca2:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 8011ca6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011ca8:	8809      	ldrh	r1, [r1, #0]
 8011caa:	8800      	ldrh	r0, [r0, #0]
 8011cac:	4798      	blx	r3
 8011cae:	4603      	mov	r3, r0
 8011cb0:	8023      	strh	r3, [r4, #0]
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8011cb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011cb4:	3301      	adds	r3, #1
 8011cb6:	62bb      	str	r3, [r7, #40]	; 0x28
 8011cb8:	687b      	ldr	r3, [r7, #4]
 8011cba:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8011cbe:	461a      	mov	r2, r3
 8011cc0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011cc2:	4293      	cmp	r3, r2
 8011cc4:	dde1      	ble.n	8011c8a <map_blended+0xd2>
            }
            disp_buf_tmp += disp_w;
 8011cc6:	69fb      	ldr	r3, [r7, #28]
 8011cc8:	005b      	lsls	r3, r3, #1
 8011cca:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011ccc:	4413      	add	r3, r2
 8011cce:	637b      	str	r3, [r7, #52]	; 0x34
            map_buf_tmp += map_w;
 8011cd0:	697b      	ldr	r3, [r7, #20]
 8011cd2:	005b      	lsls	r3, r3, #1
 8011cd4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011cd6:	4413      	add	r3, r2
 8011cd8:	633b      	str	r3, [r7, #48]	; 0x30
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8011cda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011cdc:	3301      	adds	r3, #1
 8011cde:	627b      	str	r3, [r7, #36]	; 0x24
 8011ce0:	687b      	ldr	r3, [r7, #4]
 8011ce2:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8011ce6:	461a      	mov	r2, r3
 8011ce8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011cea:	4293      	cmp	r3, r2
 8011cec:	ddc8      	ble.n	8011c80 <map_blended+0xc8>
 8011cee:	e069      	b.n	8011dc4 <map_blended+0x20c>
    /*Masked*/
    else {
        /* The mask is relative to the clipped area.
         * In the cycles below mask will be indexed from `draw_area.x1`
         * but it corresponds to zero index. So prepare `mask_tmp` accordingly. */
        const lv_opa_t * mask_tmp = mask - draw_area->x1;
 8011cf0:	687b      	ldr	r3, [r7, #4]
 8011cf2:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011cf6:	425b      	negs	r3, r3
 8011cf8:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8011cfa:	4413      	add	r3, r2
 8011cfc:	623b      	str	r3, [r7, #32]

        map_buf_tmp -= draw_area->x1;
 8011cfe:	687b      	ldr	r3, [r7, #4]
 8011d00:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011d04:	005b      	lsls	r3, r3, #1
 8011d06:	425b      	negs	r3, r3
 8011d08:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011d0a:	4413      	add	r3, r2
 8011d0c:	633b      	str	r3, [r7, #48]	; 0x30
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8011d0e:	687b      	ldr	r3, [r7, #4]
 8011d10:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8011d14:	627b      	str	r3, [r7, #36]	; 0x24
 8011d16:	e04e      	b.n	8011db6 <map_blended+0x1fe>
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8011d18:	687b      	ldr	r3, [r7, #4]
 8011d1a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8011d1e:	62bb      	str	r3, [r7, #40]	; 0x28
 8011d20:	e031      	b.n	8011d86 <map_blended+0x1ce>
                if(mask_tmp[x] == 0) continue;
 8011d22:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011d24:	6a3a      	ldr	r2, [r7, #32]
 8011d26:	4413      	add	r3, r2
 8011d28:	781b      	ldrb	r3, [r3, #0]
 8011d2a:	2b00      	cmp	r3, #0
 8011d2c:	d027      	beq.n	8011d7e <map_blended+0x1c6>
                lv_opa_t opa_tmp = mask_tmp[x] >= LV_OPA_MAX ? opa : ((opa * mask_tmp[x]) >> 8);
 8011d2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011d30:	6a3a      	ldr	r2, [r7, #32]
 8011d32:	4413      	add	r3, r2
 8011d34:	781b      	ldrb	r3, [r3, #0]
 8011d36:	2bfc      	cmp	r3, #252	; 0xfc
 8011d38:	d80a      	bhi.n	8011d50 <map_blended+0x198>
 8011d3a:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 8011d3e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8011d40:	6a39      	ldr	r1, [r7, #32]
 8011d42:	440a      	add	r2, r1
 8011d44:	7812      	ldrb	r2, [r2, #0]
 8011d46:	fb02 f303 	mul.w	r3, r2, r3
 8011d4a:	121b      	asrs	r3, r3, #8
 8011d4c:	b2db      	uxtb	r3, r3
 8011d4e:	e001      	b.n	8011d54 <map_blended+0x19c>
 8011d50:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 8011d54:	74fb      	strb	r3, [r7, #19]
                disp_buf_tmp[x] = blend_fp(map_buf_tmp[x], disp_buf_tmp[x], opa_tmp);
 8011d56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011d58:	005b      	lsls	r3, r3, #1
 8011d5a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011d5c:	18d0      	adds	r0, r2, r3
 8011d5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011d60:	005b      	lsls	r3, r3, #1
 8011d62:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011d64:	18d1      	adds	r1, r2, r3
 8011d66:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011d68:	005b      	lsls	r3, r3, #1
 8011d6a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011d6c:	18d4      	adds	r4, r2, r3
 8011d6e:	7cfa      	ldrb	r2, [r7, #19]
 8011d70:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011d72:	8809      	ldrh	r1, [r1, #0]
 8011d74:	8800      	ldrh	r0, [r0, #0]
 8011d76:	4798      	blx	r3
 8011d78:	4603      	mov	r3, r0
 8011d7a:	8023      	strh	r3, [r4, #0]
 8011d7c:	e000      	b.n	8011d80 <map_blended+0x1c8>
                if(mask_tmp[x] == 0) continue;
 8011d7e:	bf00      	nop
            for(x = draw_area->x1; x <= draw_area->x2; x++) {
 8011d80:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011d82:	3301      	adds	r3, #1
 8011d84:	62bb      	str	r3, [r7, #40]	; 0x28
 8011d86:	687b      	ldr	r3, [r7, #4]
 8011d88:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8011d8c:	461a      	mov	r2, r3
 8011d8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011d90:	4293      	cmp	r3, r2
 8011d92:	ddc6      	ble.n	8011d22 <map_blended+0x16a>
            }
            disp_buf_tmp += disp_w;
 8011d94:	69fb      	ldr	r3, [r7, #28]
 8011d96:	005b      	lsls	r3, r3, #1
 8011d98:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8011d9a:	4413      	add	r3, r2
 8011d9c:	637b      	str	r3, [r7, #52]	; 0x34
            mask_tmp += draw_area_w;
 8011d9e:	69bb      	ldr	r3, [r7, #24]
 8011da0:	6a3a      	ldr	r2, [r7, #32]
 8011da2:	4413      	add	r3, r2
 8011da4:	623b      	str	r3, [r7, #32]
            map_buf_tmp += map_w;
 8011da6:	697b      	ldr	r3, [r7, #20]
 8011da8:	005b      	lsls	r3, r3, #1
 8011daa:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011dac:	4413      	add	r3, r2
 8011dae:	633b      	str	r3, [r7, #48]	; 0x30
        for(y = draw_area->y1; y <= draw_area->y2; y++) {
 8011db0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011db2:	3301      	adds	r3, #1
 8011db4:	627b      	str	r3, [r7, #36]	; 0x24
 8011db6:	687b      	ldr	r3, [r7, #4]
 8011db8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8011dbc:	461a      	mov	r2, r3
 8011dbe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011dc0:	4293      	cmp	r3, r2
 8011dc2:	dda9      	ble.n	8011d18 <map_blended+0x160>
        }
    }
}
 8011dc4:	373c      	adds	r7, #60	; 0x3c
 8011dc6:	46bd      	mov	sp, r7
 8011dc8:	bd90      	pop	{r4, r7, pc}
 8011dca:	bf00      	nop
 8011dcc:	08011dd5 	.word	0x08011dd5
 8011dd0:	08011e91 	.word	0x08011e91

08011dd4 <color_blend_true_color_additive>:

static inline lv_color_t color_blend_true_color_additive(lv_color_t fg, lv_color_t bg, lv_opa_t opa)
{
 8011dd4:	b580      	push	{r7, lr}
 8011dd6:	b084      	sub	sp, #16
 8011dd8:	af00      	add	r7, sp, #0
 8011dda:	80b8      	strh	r0, [r7, #4]
 8011ddc:	8039      	strh	r1, [r7, #0]
 8011dde:	4613      	mov	r3, r2
 8011de0:	70fb      	strb	r3, [r7, #3]

    if(opa <= LV_OPA_MIN) return bg;
 8011de2:	78fb      	ldrb	r3, [r7, #3]
 8011de4:	2b02      	cmp	r3, #2
 8011de6:	d801      	bhi.n	8011dec <color_blend_true_color_additive+0x18>
 8011de8:	883b      	ldrh	r3, [r7, #0]
 8011dea:	e04d      	b.n	8011e88 <color_blend_true_color_additive+0xb4>
    uint32_t tmp;
#if LV_COLOR_DEPTH == 1
    tmp = bg.full + fg.full;
    fg.full = LV_MATH_MIN(tmp, 1);
#else
    tmp = bg.ch.red + fg.ch.red;
 8011dec:	787b      	ldrb	r3, [r7, #1]
 8011dee:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8011df2:	b2db      	uxtb	r3, r3
 8011df4:	461a      	mov	r2, r3
 8011df6:	797b      	ldrb	r3, [r7, #5]
 8011df8:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8011dfc:	b2db      	uxtb	r3, r3
 8011dfe:	4413      	add	r3, r2
 8011e00:	60fb      	str	r3, [r7, #12]
#if LV_COLOR_DEPTH == 8
    fg.ch.red = LV_MATH_MIN(tmp, 7);
#elif LV_COLOR_DEPTH == 16
    fg.ch.red = LV_MATH_MIN(tmp, 31);
 8011e02:	68fb      	ldr	r3, [r7, #12]
 8011e04:	2b1f      	cmp	r3, #31
 8011e06:	bf28      	it	cs
 8011e08:	231f      	movcs	r3, #31
 8011e0a:	f003 031f 	and.w	r3, r3, #31
 8011e0e:	b2da      	uxtb	r2, r3
 8011e10:	797b      	ldrb	r3, [r7, #5]
 8011e12:	f362 03c7 	bfi	r3, r2, #3, #5
 8011e16:	717b      	strb	r3, [r7, #5]

#if LV_COLOR_DEPTH == 8
    fg.ch.green = LV_MATH_MIN(tmp, 7);
#elif LV_COLOR_DEPTH == 16
#if LV_COLOR_16_SWAP == 0
    tmp = bg.ch.green + fg.ch.green;
 8011e18:	883b      	ldrh	r3, [r7, #0]
 8011e1a:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011e1e:	b2db      	uxtb	r3, r3
 8011e20:	461a      	mov	r2, r3
 8011e22:	88bb      	ldrh	r3, [r7, #4]
 8011e24:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011e28:	b2db      	uxtb	r3, r3
 8011e2a:	4413      	add	r3, r2
 8011e2c:	60fb      	str	r3, [r7, #12]
    fg.ch.green = LV_MATH_MIN(tmp, 63);
 8011e2e:	68fb      	ldr	r3, [r7, #12]
 8011e30:	2b3f      	cmp	r3, #63	; 0x3f
 8011e32:	bf28      	it	cs
 8011e34:	233f      	movcs	r3, #63	; 0x3f
 8011e36:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8011e3a:	b2da      	uxtb	r2, r3
 8011e3c:	88bb      	ldrh	r3, [r7, #4]
 8011e3e:	f362 134a 	bfi	r3, r2, #5, #6
 8011e42:	80bb      	strh	r3, [r7, #4]

#elif LV_COLOR_DEPTH == 32
    fg.ch.green = LV_MATH_MIN(tmp, 255);
#endif

    tmp = bg.ch.blue + fg.ch.blue;
 8011e44:	783b      	ldrb	r3, [r7, #0]
 8011e46:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8011e4a:	b2db      	uxtb	r3, r3
 8011e4c:	461a      	mov	r2, r3
 8011e4e:	793b      	ldrb	r3, [r7, #4]
 8011e50:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8011e54:	b2db      	uxtb	r3, r3
 8011e56:	4413      	add	r3, r2
 8011e58:	60fb      	str	r3, [r7, #12]
#if LV_COLOR_DEPTH == 8
    fg.ch.blue = LV_MATH_MIN(tmp, 4);
#elif LV_COLOR_DEPTH == 16
    fg.ch.blue = LV_MATH_MIN(tmp, 31);
 8011e5a:	68fb      	ldr	r3, [r7, #12]
 8011e5c:	2b1f      	cmp	r3, #31
 8011e5e:	bf28      	it	cs
 8011e60:	231f      	movcs	r3, #31
 8011e62:	f003 031f 	and.w	r3, r3, #31
 8011e66:	b2da      	uxtb	r2, r3
 8011e68:	793b      	ldrb	r3, [r7, #4]
 8011e6a:	f362 0304 	bfi	r3, r2, #0, #5
 8011e6e:	713b      	strb	r3, [r7, #4]
#elif LV_COLOR_DEPTH == 32
    fg.ch.blue = LV_MATH_MIN(tmp, 255);
#endif
#endif

    if(opa == LV_OPA_COVER) return fg;
 8011e70:	78fb      	ldrb	r3, [r7, #3]
 8011e72:	2bff      	cmp	r3, #255	; 0xff
 8011e74:	d101      	bne.n	8011e7a <color_blend_true_color_additive+0xa6>
 8011e76:	88bb      	ldrh	r3, [r7, #4]
 8011e78:	e006      	b.n	8011e88 <color_blend_true_color_additive+0xb4>

    return lv_color_mix(fg, bg, opa);
 8011e7a:	78fb      	ldrb	r3, [r7, #3]
 8011e7c:	461a      	mov	r2, r3
 8011e7e:	8839      	ldrh	r1, [r7, #0]
 8011e80:	88b8      	ldrh	r0, [r7, #4]
 8011e82:	f7fe fbb9 	bl	80105f8 <lv_color_mix>
 8011e86:	4603      	mov	r3, r0
}
 8011e88:	4618      	mov	r0, r3
 8011e8a:	3710      	adds	r7, #16
 8011e8c:	46bd      	mov	sp, r7
 8011e8e:	bd80      	pop	{r7, pc}

08011e90 <color_blend_true_color_subtractive>:

static inline lv_color_t color_blend_true_color_subtractive(lv_color_t fg, lv_color_t bg, lv_opa_t opa)
{
 8011e90:	b580      	push	{r7, lr}
 8011e92:	b084      	sub	sp, #16
 8011e94:	af00      	add	r7, sp, #0
 8011e96:	80b8      	strh	r0, [r7, #4]
 8011e98:	8039      	strh	r1, [r7, #0]
 8011e9a:	4613      	mov	r3, r2
 8011e9c:	70fb      	strb	r3, [r7, #3]

    if(opa <= LV_OPA_MIN) return bg;
 8011e9e:	78fb      	ldrb	r3, [r7, #3]
 8011ea0:	2b02      	cmp	r3, #2
 8011ea2:	d801      	bhi.n	8011ea8 <color_blend_true_color_subtractive+0x18>
 8011ea4:	883b      	ldrh	r3, [r7, #0]
 8011ea6:	e04a      	b.n	8011f3e <color_blend_true_color_subtractive+0xae>

    int32_t tmp;
    tmp = bg.ch.red - fg.ch.red;
 8011ea8:	787b      	ldrb	r3, [r7, #1]
 8011eaa:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8011eae:	b2db      	uxtb	r3, r3
 8011eb0:	461a      	mov	r2, r3
 8011eb2:	797b      	ldrb	r3, [r7, #5]
 8011eb4:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8011eb8:	b2db      	uxtb	r3, r3
 8011eba:	1ad3      	subs	r3, r2, r3
 8011ebc:	60fb      	str	r3, [r7, #12]
    fg.ch.red = LV_MATH_MAX(tmp, 0);
 8011ebe:	68fb      	ldr	r3, [r7, #12]
 8011ec0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8011ec4:	f003 031f 	and.w	r3, r3, #31
 8011ec8:	b2da      	uxtb	r2, r3
 8011eca:	797b      	ldrb	r3, [r7, #5]
 8011ecc:	f362 03c7 	bfi	r3, r2, #3, #5
 8011ed0:	717b      	strb	r3, [r7, #5]

#if LV_COLOR_16_SWAP == 0
    tmp = bg.ch.green - fg.ch.green;
 8011ed2:	883b      	ldrh	r3, [r7, #0]
 8011ed4:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011ed8:	b2db      	uxtb	r3, r3
 8011eda:	461a      	mov	r2, r3
 8011edc:	88bb      	ldrh	r3, [r7, #4]
 8011ede:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011ee2:	b2db      	uxtb	r3, r3
 8011ee4:	1ad3      	subs	r3, r2, r3
 8011ee6:	60fb      	str	r3, [r7, #12]
    fg.ch.green = LV_MATH_MAX(tmp, 0);
 8011ee8:	68fb      	ldr	r3, [r7, #12]
 8011eea:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8011eee:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8011ef2:	b2da      	uxtb	r2, r3
 8011ef4:	88bb      	ldrh	r3, [r7, #4]
 8011ef6:	f362 134a 	bfi	r3, r2, #5, #6
 8011efa:	80bb      	strh	r3, [r7, #4]
    tmp = LV_MATH_MAX(tmp, 0);
    fg.ch.green_h = tmp >> 3;
    fg.ch.green_l = tmp & 0x7;
#endif

    tmp = bg.ch.blue - fg.ch.blue;
 8011efc:	783b      	ldrb	r3, [r7, #0]
 8011efe:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8011f02:	b2db      	uxtb	r3, r3
 8011f04:	461a      	mov	r2, r3
 8011f06:	793b      	ldrb	r3, [r7, #4]
 8011f08:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8011f0c:	b2db      	uxtb	r3, r3
 8011f0e:	1ad3      	subs	r3, r2, r3
 8011f10:	60fb      	str	r3, [r7, #12]
    fg.ch.blue = LV_MATH_MAX(tmp, 0);
 8011f12:	68fb      	ldr	r3, [r7, #12]
 8011f14:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8011f18:	f003 031f 	and.w	r3, r3, #31
 8011f1c:	b2da      	uxtb	r2, r3
 8011f1e:	793b      	ldrb	r3, [r7, #4]
 8011f20:	f362 0304 	bfi	r3, r2, #0, #5
 8011f24:	713b      	strb	r3, [r7, #4]

    if(opa == LV_OPA_COVER) return fg;
 8011f26:	78fb      	ldrb	r3, [r7, #3]
 8011f28:	2bff      	cmp	r3, #255	; 0xff
 8011f2a:	d101      	bne.n	8011f30 <color_blend_true_color_subtractive+0xa0>
 8011f2c:	88bb      	ldrh	r3, [r7, #4]
 8011f2e:	e006      	b.n	8011f3e <color_blend_true_color_subtractive+0xae>

    return lv_color_mix(fg, bg, opa);
 8011f30:	78fb      	ldrb	r3, [r7, #3]
 8011f32:	461a      	mov	r2, r3
 8011f34:	8839      	ldrh	r1, [r7, #0]
 8011f36:	88b8      	ldrh	r0, [r7, #4]
 8011f38:	f7fe fb5e 	bl	80105f8 <lv_color_mix>
 8011f3c:	4603      	mov	r3, r0
}
 8011f3e:	4618      	mov	r0, r3
 8011f40:	3710      	adds	r7, #16
 8011f42:	46bd      	mov	sp, r7
 8011f44:	bd80      	pop	{r7, pc}

08011f46 <lv_color_premult>:
{
 8011f46:	b480      	push	{r7}
 8011f48:	b083      	sub	sp, #12
 8011f4a:	af00      	add	r7, sp, #0
 8011f4c:	80b8      	strh	r0, [r7, #4]
 8011f4e:	460b      	mov	r3, r1
 8011f50:	603a      	str	r2, [r7, #0]
 8011f52:	71fb      	strb	r3, [r7, #7]
    out[0] = (uint16_t) LV_COLOR_GET_R(c) * mix;
 8011f54:	797b      	ldrb	r3, [r7, #5]
 8011f56:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8011f5a:	b2db      	uxtb	r3, r3
 8011f5c:	b29a      	uxth	r2, r3
 8011f5e:	79fb      	ldrb	r3, [r7, #7]
 8011f60:	b29b      	uxth	r3, r3
 8011f62:	fb12 f303 	smulbb	r3, r2, r3
 8011f66:	b29a      	uxth	r2, r3
 8011f68:	683b      	ldr	r3, [r7, #0]
 8011f6a:	801a      	strh	r2, [r3, #0]
    out[1] = (uint16_t) LV_COLOR_GET_G(c) * mix;
 8011f6c:	88bb      	ldrh	r3, [r7, #4]
 8011f6e:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011f72:	b2db      	uxtb	r3, r3
 8011f74:	b299      	uxth	r1, r3
 8011f76:	79fb      	ldrb	r3, [r7, #7]
 8011f78:	b29a      	uxth	r2, r3
 8011f7a:	683b      	ldr	r3, [r7, #0]
 8011f7c:	3302      	adds	r3, #2
 8011f7e:	fb11 f202 	smulbb	r2, r1, r2
 8011f82:	b292      	uxth	r2, r2
 8011f84:	801a      	strh	r2, [r3, #0]
    out[2] = (uint16_t) LV_COLOR_GET_B(c) * mix;
 8011f86:	793b      	ldrb	r3, [r7, #4]
 8011f88:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8011f8c:	b2db      	uxtb	r3, r3
 8011f8e:	b299      	uxth	r1, r3
 8011f90:	79fb      	ldrb	r3, [r7, #7]
 8011f92:	b29a      	uxth	r2, r3
 8011f94:	683b      	ldr	r3, [r7, #0]
 8011f96:	3304      	adds	r3, #4
 8011f98:	fb11 f202 	smulbb	r2, r1, r2
 8011f9c:	b292      	uxth	r2, r2
 8011f9e:	801a      	strh	r2, [r3, #0]
}
 8011fa0:	bf00      	nop
 8011fa2:	370c      	adds	r7, #12
 8011fa4:	46bd      	mov	sp, r7
 8011fa6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011faa:	4770      	bx	lr

08011fac <lv_color_mix_premult>:
{
 8011fac:	b480      	push	{r7}
 8011fae:	b085      	sub	sp, #20
 8011fb0:	af00      	add	r7, sp, #0
 8011fb2:	6078      	str	r0, [r7, #4]
 8011fb4:	8039      	strh	r1, [r7, #0]
 8011fb6:	4613      	mov	r3, r2
 8011fb8:	70fb      	strb	r3, [r7, #3]
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) premult_c1[0] + LV_COLOR_GET_R(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
 8011fba:	687b      	ldr	r3, [r7, #4]
 8011fbc:	881b      	ldrh	r3, [r3, #0]
 8011fbe:	461a      	mov	r2, r3
 8011fc0:	787b      	ldrb	r3, [r7, #1]
 8011fc2:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8011fc6:	b2db      	uxtb	r3, r3
 8011fc8:	4619      	mov	r1, r3
 8011fca:	78fb      	ldrb	r3, [r7, #3]
 8011fcc:	fb01 f303 	mul.w	r3, r1, r3
 8011fd0:	4413      	add	r3, r2
 8011fd2:	3380      	adds	r3, #128	; 0x80
 8011fd4:	461a      	mov	r2, r3
 8011fd6:	4613      	mov	r3, r2
 8011fd8:	021b      	lsls	r3, r3, #8
 8011fda:	4413      	add	r3, r2
 8011fdc:	01db      	lsls	r3, r3, #7
 8011fde:	4413      	add	r3, r2
 8011fe0:	0ddb      	lsrs	r3, r3, #23
 8011fe2:	f003 031f 	and.w	r3, r3, #31
 8011fe6:	b2da      	uxtb	r2, r3
 8011fe8:	7b7b      	ldrb	r3, [r7, #13]
 8011fea:	f362 03c7 	bfi	r3, r2, #3, #5
 8011fee:	737b      	strb	r3, [r7, #13]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) premult_c1[1] + LV_COLOR_GET_G(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
 8011ff0:	687b      	ldr	r3, [r7, #4]
 8011ff2:	3302      	adds	r3, #2
 8011ff4:	881b      	ldrh	r3, [r3, #0]
 8011ff6:	461a      	mov	r2, r3
 8011ff8:	883b      	ldrh	r3, [r7, #0]
 8011ffa:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8011ffe:	b2db      	uxtb	r3, r3
 8012000:	4619      	mov	r1, r3
 8012002:	78fb      	ldrb	r3, [r7, #3]
 8012004:	fb01 f303 	mul.w	r3, r1, r3
 8012008:	4413      	add	r3, r2
 801200a:	3380      	adds	r3, #128	; 0x80
 801200c:	461a      	mov	r2, r3
 801200e:	4613      	mov	r3, r2
 8012010:	021b      	lsls	r3, r3, #8
 8012012:	4413      	add	r3, r2
 8012014:	01db      	lsls	r3, r3, #7
 8012016:	4413      	add	r3, r2
 8012018:	0ddb      	lsrs	r3, r3, #23
 801201a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801201e:	b2da      	uxtb	r2, r3
 8012020:	89bb      	ldrh	r3, [r7, #12]
 8012022:	f362 134a 	bfi	r3, r2, #5, #6
 8012026:	81bb      	strh	r3, [r7, #12]
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) premult_c1[2] + LV_COLOR_GET_B(c2) * mix + LV_COLOR_MIX_ROUND_OFS));
 8012028:	687b      	ldr	r3, [r7, #4]
 801202a:	3304      	adds	r3, #4
 801202c:	881b      	ldrh	r3, [r3, #0]
 801202e:	461a      	mov	r2, r3
 8012030:	783b      	ldrb	r3, [r7, #0]
 8012032:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8012036:	b2db      	uxtb	r3, r3
 8012038:	4619      	mov	r1, r3
 801203a:	78fb      	ldrb	r3, [r7, #3]
 801203c:	fb01 f303 	mul.w	r3, r1, r3
 8012040:	4413      	add	r3, r2
 8012042:	3380      	adds	r3, #128	; 0x80
 8012044:	461a      	mov	r2, r3
 8012046:	4613      	mov	r3, r2
 8012048:	021b      	lsls	r3, r3, #8
 801204a:	4413      	add	r3, r2
 801204c:	01db      	lsls	r3, r3, #7
 801204e:	4413      	add	r3, r2
 8012050:	0ddb      	lsrs	r3, r3, #23
 8012052:	f003 031f 	and.w	r3, r3, #31
 8012056:	b2da      	uxtb	r2, r3
 8012058:	7b3b      	ldrb	r3, [r7, #12]
 801205a:	f362 0304 	bfi	r3, r2, #0, #5
 801205e:	733b      	strb	r3, [r7, #12]
    return ret;
 8012060:	89bb      	ldrh	r3, [r7, #12]
}
 8012062:	4618      	mov	r0, r3
 8012064:	3714      	adds	r7, #20
 8012066:	46bd      	mov	sp, r7
 8012068:	f85d 7b04 	ldr.w	r7, [sp], #4
 801206c:	4770      	bx	lr

0801206e <_lv_memcpy_small>:
 * @param dst pointer to the destination buffer
 * @param src pointer to the source buffer
 * @param len number of byte to copy
 */
LV_ATTRIBUTE_FAST_MEM static inline void * _lv_memcpy_small(void * dst, const void * src, size_t len)
{
 801206e:	b480      	push	{r7}
 8012070:	b087      	sub	sp, #28
 8012072:	af00      	add	r7, sp, #0
 8012074:	60f8      	str	r0, [r7, #12]
 8012076:	60b9      	str	r1, [r7, #8]
 8012078:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 801207a:	68fb      	ldr	r3, [r7, #12]
 801207c:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 801207e:	68bb      	ldr	r3, [r7, #8]
 8012080:	613b      	str	r3, [r7, #16]

    while(len) {
 8012082:	e00c      	b.n	801209e <_lv_memcpy_small+0x30>
        *d8 = *s8;
 8012084:	693b      	ldr	r3, [r7, #16]
 8012086:	781a      	ldrb	r2, [r3, #0]
 8012088:	697b      	ldr	r3, [r7, #20]
 801208a:	701a      	strb	r2, [r3, #0]
        d8++;
 801208c:	697b      	ldr	r3, [r7, #20]
 801208e:	3301      	adds	r3, #1
 8012090:	617b      	str	r3, [r7, #20]
        s8++;
 8012092:	693b      	ldr	r3, [r7, #16]
 8012094:	3301      	adds	r3, #1
 8012096:	613b      	str	r3, [r7, #16]
        len--;
 8012098:	687b      	ldr	r3, [r7, #4]
 801209a:	3b01      	subs	r3, #1
 801209c:	607b      	str	r3, [r7, #4]
    while(len) {
 801209e:	687b      	ldr	r3, [r7, #4]
 80120a0:	2b00      	cmp	r3, #0
 80120a2:	d1ef      	bne.n	8012084 <_lv_memcpy_small+0x16>
    }

    return dst;
 80120a4:	68fb      	ldr	r3, [r7, #12]
}
 80120a6:	4618      	mov	r0, r3
 80120a8:	371c      	adds	r7, #28
 80120aa:	46bd      	mov	sp, r7
 80120ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80120b0:	4770      	bx	lr

080120b2 <lv_area_copy>:
{
 80120b2:	b580      	push	{r7, lr}
 80120b4:	b082      	sub	sp, #8
 80120b6:	af00      	add	r7, sp, #0
 80120b8:	6078      	str	r0, [r7, #4]
 80120ba:	6039      	str	r1, [r7, #0]
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
 80120bc:	2208      	movs	r2, #8
 80120be:	6839      	ldr	r1, [r7, #0]
 80120c0:	6878      	ldr	r0, [r7, #4]
 80120c2:	f7ff ffd4 	bl	801206e <_lv_memcpy_small>
}
 80120c6:	bf00      	nop
 80120c8:	3708      	adds	r7, #8
 80120ca:	46bd      	mov	sp, r7
 80120cc:	bd80      	pop	{r7, pc}

080120ce <lv_area_get_width>:
{
 80120ce:	b480      	push	{r7}
 80120d0:	b083      	sub	sp, #12
 80120d2:	af00      	add	r7, sp, #0
 80120d4:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 80120d6:	687b      	ldr	r3, [r7, #4]
 80120d8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80120dc:	b29a      	uxth	r2, r3
 80120de:	687b      	ldr	r3, [r7, #4]
 80120e0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80120e4:	b29b      	uxth	r3, r3
 80120e6:	1ad3      	subs	r3, r2, r3
 80120e8:	b29b      	uxth	r3, r3
 80120ea:	3301      	adds	r3, #1
 80120ec:	b29b      	uxth	r3, r3
 80120ee:	b21b      	sxth	r3, r3
}
 80120f0:	4618      	mov	r0, r3
 80120f2:	370c      	adds	r7, #12
 80120f4:	46bd      	mov	sp, r7
 80120f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80120fa:	4770      	bx	lr

080120fc <lv_area_get_height>:
{
 80120fc:	b480      	push	{r7}
 80120fe:	b083      	sub	sp, #12
 8012100:	af00      	add	r7, sp, #0
 8012102:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 8012104:	687b      	ldr	r3, [r7, #4]
 8012106:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801210a:	b29a      	uxth	r2, r3
 801210c:	687b      	ldr	r3, [r7, #4]
 801210e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8012112:	b29b      	uxth	r3, r3
 8012114:	1ad3      	subs	r3, r2, r3
 8012116:	b29b      	uxth	r3, r3
 8012118:	3301      	adds	r3, #1
 801211a:	b29b      	uxth	r3, r3
 801211c:	b21b      	sxth	r3, r3
}
 801211e:	4618      	mov	r0, r3
 8012120:	370c      	adds	r7, #12
 8012122:	46bd      	mov	sp, r7
 8012124:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012128:	4770      	bx	lr

0801212a <_lv_img_buf_transform>:
 * @param y the coordinate which color and opa should be get
 * @return true: there is valid pixel on these x/y coordinates; false: the rotated pixel was out of the image
 * @note the result is written back to `dsc->res_color` and `dsc->res_opa`
 */
static inline bool _lv_img_buf_transform(lv_img_transform_dsc_t * dsc, lv_coord_t x, lv_coord_t y)
{
 801212a:	b590      	push	{r4, r7, lr}
 801212c:	b08d      	sub	sp, #52	; 0x34
 801212e:	af00      	add	r7, sp, #0
 8012130:	6078      	str	r0, [r7, #4]
 8012132:	460b      	mov	r3, r1
 8012134:	807b      	strh	r3, [r7, #2]
 8012136:	4613      	mov	r3, r2
 8012138:	803b      	strh	r3, [r7, #0]
    const uint8_t * src_u8 = (const uint8_t *)dsc->cfg.src;
 801213a:	687b      	ldr	r3, [r7, #4]
 801213c:	681b      	ldr	r3, [r3, #0]
 801213e:	61fb      	str	r3, [r7, #28]

    /*Get the target point relative coordinates to the pivot*/
    int32_t xt = x - dsc->cfg.pivot_x;
 8012140:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8012144:	687a      	ldr	r2, [r7, #4]
 8012146:	f9b2 2008 	ldrsh.w	r2, [r2, #8]
 801214a:	1a9b      	subs	r3, r3, r2
 801214c:	61bb      	str	r3, [r7, #24]
    int32_t yt = y - dsc->cfg.pivot_y;
 801214e:	f9b7 3000 	ldrsh.w	r3, [r7]
 8012152:	687a      	ldr	r2, [r7, #4]
 8012154:	f9b2 200a 	ldrsh.w	r2, [r2, #10]
 8012158:	1a9b      	subs	r3, r3, r2
 801215a:	617b      	str	r3, [r7, #20]

    int32_t xs;
    int32_t ys;
    if(dsc->cfg.zoom == LV_IMG_ZOOM_NONE) {
 801215c:	687b      	ldr	r3, [r7, #4]
 801215e:	89db      	ldrh	r3, [r3, #14]
 8012160:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8012164:	d120      	bne.n	80121a8 <_lv_img_buf_transform+0x7e>
        /*Get the source pixel from the upscaled image*/
        xs = ((dsc->tmp.cosma * xt - dsc->tmp.sinma * yt) >> (_LV_TRANSFORM_TRIGO_SHIFT - 8)) + dsc->tmp.pivot_x_256;
 8012166:	687b      	ldr	r3, [r7, #4]
 8012168:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801216a:	69ba      	ldr	r2, [r7, #24]
 801216c:	fb03 f202 	mul.w	r2, r3, r2
 8012170:	687b      	ldr	r3, [r7, #4]
 8012172:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012174:	6979      	ldr	r1, [r7, #20]
 8012176:	fb01 f303 	mul.w	r3, r1, r3
 801217a:	1ad3      	subs	r3, r2, r3
 801217c:	109a      	asrs	r2, r3, #2
 801217e:	687b      	ldr	r3, [r7, #4]
 8012180:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012182:	4413      	add	r3, r2
 8012184:	62fb      	str	r3, [r7, #44]	; 0x2c
        ys = ((dsc->tmp.sinma * xt + dsc->tmp.cosma * yt) >> (_LV_TRANSFORM_TRIGO_SHIFT - 8)) + dsc->tmp.pivot_y_256;
 8012186:	687b      	ldr	r3, [r7, #4]
 8012188:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801218a:	69ba      	ldr	r2, [r7, #24]
 801218c:	fb03 f202 	mul.w	r2, r3, r2
 8012190:	687b      	ldr	r3, [r7, #4]
 8012192:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012194:	6979      	ldr	r1, [r7, #20]
 8012196:	fb01 f303 	mul.w	r3, r1, r3
 801219a:	4413      	add	r3, r2
 801219c:	109a      	asrs	r2, r3, #2
 801219e:	687b      	ldr	r3, [r7, #4]
 80121a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80121a2:	4413      	add	r3, r2
 80121a4:	62bb      	str	r3, [r7, #40]	; 0x28
 80121a6:	e04b      	b.n	8012240 <_lv_img_buf_transform+0x116>
    }
    else if(dsc->cfg.angle == 0) {
 80121a8:	687b      	ldr	r3, [r7, #4]
 80121aa:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 80121ae:	2b00      	cmp	r3, #0
 80121b0:	d118      	bne.n	80121e4 <_lv_img_buf_transform+0xba>
        xt = (int32_t)((int32_t)xt * dsc->tmp.zoom_inv) >> _LV_ZOOM_INV_UPSCALE;
 80121b2:	687b      	ldr	r3, [r7, #4]
 80121b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80121b6:	69ba      	ldr	r2, [r7, #24]
 80121b8:	fb02 f303 	mul.w	r3, r2, r3
 80121bc:	115b      	asrs	r3, r3, #5
 80121be:	61bb      	str	r3, [r7, #24]
        yt = (int32_t)((int32_t)yt * dsc->tmp.zoom_inv) >> _LV_ZOOM_INV_UPSCALE;
 80121c0:	687b      	ldr	r3, [r7, #4]
 80121c2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80121c4:	697a      	ldr	r2, [r7, #20]
 80121c6:	fb02 f303 	mul.w	r3, r2, r3
 80121ca:	115b      	asrs	r3, r3, #5
 80121cc:	617b      	str	r3, [r7, #20]
        xs = xt + dsc->tmp.pivot_x_256;
 80121ce:	687b      	ldr	r3, [r7, #4]
 80121d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80121d2:	69ba      	ldr	r2, [r7, #24]
 80121d4:	4413      	add	r3, r2
 80121d6:	62fb      	str	r3, [r7, #44]	; 0x2c
        ys = yt + dsc->tmp.pivot_y_256;
 80121d8:	687b      	ldr	r3, [r7, #4]
 80121da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80121dc:	697a      	ldr	r2, [r7, #20]
 80121de:	4413      	add	r3, r2
 80121e0:	62bb      	str	r3, [r7, #40]	; 0x28
 80121e2:	e02d      	b.n	8012240 <_lv_img_buf_transform+0x116>
    }
    else {
        xt = (int32_t)((int32_t)xt * dsc->tmp.zoom_inv) >> _LV_ZOOM_INV_UPSCALE;
 80121e4:	687b      	ldr	r3, [r7, #4]
 80121e6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80121e8:	69ba      	ldr	r2, [r7, #24]
 80121ea:	fb02 f303 	mul.w	r3, r2, r3
 80121ee:	115b      	asrs	r3, r3, #5
 80121f0:	61bb      	str	r3, [r7, #24]
        yt = (int32_t)((int32_t)yt * dsc->tmp.zoom_inv) >> _LV_ZOOM_INV_UPSCALE;
 80121f2:	687b      	ldr	r3, [r7, #4]
 80121f4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80121f6:	697a      	ldr	r2, [r7, #20]
 80121f8:	fb02 f303 	mul.w	r3, r2, r3
 80121fc:	115b      	asrs	r3, r3, #5
 80121fe:	617b      	str	r3, [r7, #20]
        xs = ((dsc->tmp.cosma * xt - dsc->tmp.sinma * yt) >> (_LV_TRANSFORM_TRIGO_SHIFT)) + dsc->tmp.pivot_x_256;
 8012200:	687b      	ldr	r3, [r7, #4]
 8012202:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8012204:	69ba      	ldr	r2, [r7, #24]
 8012206:	fb03 f202 	mul.w	r2, r3, r2
 801220a:	687b      	ldr	r3, [r7, #4]
 801220c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801220e:	6979      	ldr	r1, [r7, #20]
 8012210:	fb01 f303 	mul.w	r3, r1, r3
 8012214:	1ad3      	subs	r3, r2, r3
 8012216:	129a      	asrs	r2, r3, #10
 8012218:	687b      	ldr	r3, [r7, #4]
 801221a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801221c:	4413      	add	r3, r2
 801221e:	62fb      	str	r3, [r7, #44]	; 0x2c
        ys = ((dsc->tmp.sinma * xt + dsc->tmp.cosma * yt) >> (_LV_TRANSFORM_TRIGO_SHIFT)) + dsc->tmp.pivot_y_256;
 8012220:	687b      	ldr	r3, [r7, #4]
 8012222:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012224:	69ba      	ldr	r2, [r7, #24]
 8012226:	fb03 f202 	mul.w	r2, r3, r2
 801222a:	687b      	ldr	r3, [r7, #4]
 801222c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801222e:	6979      	ldr	r1, [r7, #20]
 8012230:	fb01 f303 	mul.w	r3, r1, r3
 8012234:	4413      	add	r3, r2
 8012236:	129a      	asrs	r2, r3, #10
 8012238:	687b      	ldr	r3, [r7, #4]
 801223a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801223c:	4413      	add	r3, r2
 801223e:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    /*Get the integer part of the source pixel*/
    int32_t xs_int = xs >> 8;
 8012240:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012242:	121b      	asrs	r3, r3, #8
 8012244:	613b      	str	r3, [r7, #16]
    int32_t ys_int = ys >> 8;
 8012246:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8012248:	121b      	asrs	r3, r3, #8
 801224a:	60fb      	str	r3, [r7, #12]

    if(xs_int >= dsc->cfg.src_w) return false;
 801224c:	687b      	ldr	r3, [r7, #4]
 801224e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8012252:	461a      	mov	r2, r3
 8012254:	693b      	ldr	r3, [r7, #16]
 8012256:	4293      	cmp	r3, r2
 8012258:	db01      	blt.n	801225e <_lv_img_buf_transform+0x134>
 801225a:	2300      	movs	r3, #0
 801225c:	e0d2      	b.n	8012404 <_lv_img_buf_transform+0x2da>
    else if(xs_int < 0) return false;
 801225e:	693b      	ldr	r3, [r7, #16]
 8012260:	2b00      	cmp	r3, #0
 8012262:	da01      	bge.n	8012268 <_lv_img_buf_transform+0x13e>
 8012264:	2300      	movs	r3, #0
 8012266:	e0cd      	b.n	8012404 <_lv_img_buf_transform+0x2da>

    if(ys_int >= dsc->cfg.src_h) return false;
 8012268:	687b      	ldr	r3, [r7, #4]
 801226a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801226e:	461a      	mov	r2, r3
 8012270:	68fb      	ldr	r3, [r7, #12]
 8012272:	4293      	cmp	r3, r2
 8012274:	db01      	blt.n	801227a <_lv_img_buf_transform+0x150>
 8012276:	2300      	movs	r3, #0
 8012278:	e0c4      	b.n	8012404 <_lv_img_buf_transform+0x2da>
    else if(ys_int < 0) return false;
 801227a:	68fb      	ldr	r3, [r7, #12]
 801227c:	2b00      	cmp	r3, #0
 801227e:	da01      	bge.n	8012284 <_lv_img_buf_transform+0x15a>
 8012280:	2300      	movs	r3, #0
 8012282:	e0bf      	b.n	8012404 <_lv_img_buf_transform+0x2da>

    uint8_t px_size;
    uint32_t pxi;
    if(dsc->tmp.native_color) {
 8012284:	687b      	ldr	r3, [r7, #4]
 8012286:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801228a:	f003 0304 	and.w	r3, r3, #4
 801228e:	b2db      	uxtb	r3, r3
 8012290:	2b00      	cmp	r3, #0
 8012292:	d054      	beq.n	801233e <_lv_img_buf_transform+0x214>
        if(dsc->tmp.has_alpha == 0) {
 8012294:	687b      	ldr	r3, [r7, #4]
 8012296:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801229a:	f003 0302 	and.w	r3, r3, #2
 801229e:	b2db      	uxtb	r3, r3
 80122a0:	2b00      	cmp	r3, #0
 80122a2:	d120      	bne.n	80122e6 <_lv_img_buf_transform+0x1bc>
            px_size = LV_COLOR_SIZE >> 3;
 80122a4:	2302      	movs	r3, #2
 80122a6:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

            pxi     = dsc->cfg.src_w * ys_int * px_size + xs_int * px_size;
 80122aa:	687b      	ldr	r3, [r7, #4]
 80122ac:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80122b0:	461a      	mov	r2, r3
 80122b2:	68fb      	ldr	r3, [r7, #12]
 80122b4:	fb02 f303 	mul.w	r3, r2, r3
 80122b8:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 80122bc:	fb03 f202 	mul.w	r2, r3, r2
 80122c0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 80122c4:	6939      	ldr	r1, [r7, #16]
 80122c6:	fb01 f303 	mul.w	r3, r1, r3
 80122ca:	4413      	add	r3, r2
 80122cc:	623b      	str	r3, [r7, #32]
            _lv_memcpy_small(&dsc->res.color, &src_u8[pxi], px_size);
 80122ce:	687b      	ldr	r3, [r7, #4]
 80122d0:	f103 0014 	add.w	r0, r3, #20
 80122d4:	69fa      	ldr	r2, [r7, #28]
 80122d6:	6a3b      	ldr	r3, [r7, #32]
 80122d8:	4413      	add	r3, r2
 80122da:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 80122de:	4619      	mov	r1, r3
 80122e0:	f7ff fec5 	bl	801206e <_lv_memcpy_small>
 80122e4:	e04a      	b.n	801237c <_lv_img_buf_transform+0x252>
        }
        else {
            px_size = LV_IMG_PX_SIZE_ALPHA_BYTE;
 80122e6:	2303      	movs	r3, #3
 80122e8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
            pxi     = dsc->cfg.src_w * ys_int * px_size + xs_int * px_size;
 80122ec:	687b      	ldr	r3, [r7, #4]
 80122ee:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80122f2:	461a      	mov	r2, r3
 80122f4:	68fb      	ldr	r3, [r7, #12]
 80122f6:	fb02 f303 	mul.w	r3, r2, r3
 80122fa:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 80122fe:	fb03 f202 	mul.w	r2, r3, r2
 8012302:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8012306:	6939      	ldr	r1, [r7, #16]
 8012308:	fb01 f303 	mul.w	r3, r1, r3
 801230c:	4413      	add	r3, r2
 801230e:	623b      	str	r3, [r7, #32]
            _lv_memcpy_small(&dsc->res.color, &src_u8[pxi], px_size - 1);
 8012310:	687b      	ldr	r3, [r7, #4]
 8012312:	f103 0014 	add.w	r0, r3, #20
 8012316:	69fa      	ldr	r2, [r7, #28]
 8012318:	6a3b      	ldr	r3, [r7, #32]
 801231a:	18d1      	adds	r1, r2, r3
 801231c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8012320:	3b01      	subs	r3, #1
 8012322:	461a      	mov	r2, r3
 8012324:	f7ff fea3 	bl	801206e <_lv_memcpy_small>
            dsc->res.opa = src_u8[pxi + px_size - 1];
 8012328:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 801232c:	6a3b      	ldr	r3, [r7, #32]
 801232e:	4413      	add	r3, r2
 8012330:	3b01      	subs	r3, #1
 8012332:	69fa      	ldr	r2, [r7, #28]
 8012334:	4413      	add	r3, r2
 8012336:	781a      	ldrb	r2, [r3, #0]
 8012338:	687b      	ldr	r3, [r7, #4]
 801233a:	759a      	strb	r2, [r3, #22]
 801233c:	e01e      	b.n	801237c <_lv_img_buf_transform+0x252>
        }
    }
    else {
        pxi = 0; /*unused*/
 801233e:	2300      	movs	r3, #0
 8012340:	623b      	str	r3, [r7, #32]
        px_size = 0;    /*unused*/
 8012342:	2300      	movs	r3, #0
 8012344:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        dsc->res.color = lv_img_buf_get_px_color(&dsc->tmp.img_dsc, xs_int, ys_int, dsc->cfg.color);
 8012348:	687b      	ldr	r3, [r7, #4]
 801234a:	f103 0018 	add.w	r0, r3, #24
 801234e:	693b      	ldr	r3, [r7, #16]
 8012350:	b219      	sxth	r1, r3
 8012352:	68fb      	ldr	r3, [r7, #12]
 8012354:	b21a      	sxth	r2, r3
 8012356:	687c      	ldr	r4, [r7, #4]
 8012358:	687b      	ldr	r3, [r7, #4]
 801235a:	8a1b      	ldrh	r3, [r3, #16]
 801235c:	f009 f8e0 	bl	801b520 <lv_img_buf_get_px_color>
 8012360:	82a0      	strh	r0, [r4, #20]
        dsc->res.opa = lv_img_buf_get_px_alpha(&dsc->tmp.img_dsc, xs_int, ys_int);
 8012362:	687b      	ldr	r3, [r7, #4]
 8012364:	3318      	adds	r3, #24
 8012366:	693a      	ldr	r2, [r7, #16]
 8012368:	b211      	sxth	r1, r2
 801236a:	68fa      	ldr	r2, [r7, #12]
 801236c:	b212      	sxth	r2, r2
 801236e:	4618      	mov	r0, r3
 8012370:	f009 fa22 	bl	801b7b8 <lv_img_buf_get_px_alpha>
 8012374:	4603      	mov	r3, r0
 8012376:	461a      	mov	r2, r3
 8012378:	687b      	ldr	r3, [r7, #4]
 801237a:	759a      	strb	r2, [r3, #22]
    }

    if(dsc->tmp.chroma_keyed) {
 801237c:	687b      	ldr	r3, [r7, #4]
 801237e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8012382:	f003 0301 	and.w	r3, r3, #1
 8012386:	b2db      	uxtb	r3, r3
 8012388:	2b00      	cmp	r3, #0
 801238a:	d012      	beq.n	80123b2 <_lv_img_buf_transform+0x288>
        lv_color_t ct = LV_COLOR_TRANSP;
 801238c:	7a3b      	ldrb	r3, [r7, #8]
 801238e:	f36f 0304 	bfc	r3, #0, #5
 8012392:	723b      	strb	r3, [r7, #8]
 8012394:	893b      	ldrh	r3, [r7, #8]
 8012396:	f443 63fc 	orr.w	r3, r3, #2016	; 0x7e0
 801239a:	813b      	strh	r3, [r7, #8]
 801239c:	7a7b      	ldrb	r3, [r7, #9]
 801239e:	f36f 03c7 	bfc	r3, #3, #5
 80123a2:	727b      	strb	r3, [r7, #9]
        if(dsc->res.color.full == ct.full) return false;
 80123a4:	687b      	ldr	r3, [r7, #4]
 80123a6:	8a9a      	ldrh	r2, [r3, #20]
 80123a8:	893b      	ldrh	r3, [r7, #8]
 80123aa:	429a      	cmp	r2, r3
 80123ac:	d101      	bne.n	80123b2 <_lv_img_buf_transform+0x288>
 80123ae:	2300      	movs	r3, #0
 80123b0:	e028      	b.n	8012404 <_lv_img_buf_transform+0x2da>
    }

    if(dsc->cfg.antialias == false) return true;
 80123b2:	687b      	ldr	r3, [r7, #4]
 80123b4:	7cdb      	ldrb	r3, [r3, #19]
 80123b6:	f083 0301 	eor.w	r3, r3, #1
 80123ba:	b2db      	uxtb	r3, r3
 80123bc:	2b00      	cmp	r3, #0
 80123be:	d001      	beq.n	80123c4 <_lv_img_buf_transform+0x29a>
 80123c0:	2301      	movs	r3, #1
 80123c2:	e01f      	b.n	8012404 <_lv_img_buf_transform+0x2da>

    dsc->tmp.xs = xs;
 80123c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80123c6:	b21a      	sxth	r2, r3
 80123c8:	687b      	ldr	r3, [r7, #4]
 80123ca:	879a      	strh	r2, [r3, #60]	; 0x3c
    dsc->tmp.ys = ys;
 80123cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80123ce:	b21a      	sxth	r2, r3
 80123d0:	687b      	ldr	r3, [r7, #4]
 80123d2:	87da      	strh	r2, [r3, #62]	; 0x3e
    dsc->tmp.xs_int = xs_int;
 80123d4:	693b      	ldr	r3, [r7, #16]
 80123d6:	b21a      	sxth	r2, r3
 80123d8:	687b      	ldr	r3, [r7, #4]
 80123da:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    dsc->tmp.ys_int = ys_int;
 80123de:	68fb      	ldr	r3, [r7, #12]
 80123e0:	b21a      	sxth	r2, r3
 80123e2:	687b      	ldr	r3, [r7, #4]
 80123e4:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
    dsc->tmp.pxi = pxi;
 80123e8:	687b      	ldr	r3, [r7, #4]
 80123ea:	6a3a      	ldr	r2, [r7, #32]
 80123ec:	645a      	str	r2, [r3, #68]	; 0x44
    dsc->tmp.px_size = px_size;
 80123ee:	687b      	ldr	r3, [r7, #4]
 80123f0:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 80123f4:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

    bool ret;
    ret = _lv_img_buf_transform_anti_alias(dsc);
 80123f8:	6878      	ldr	r0, [r7, #4]
 80123fa:	f009 fe11 	bl	801c020 <_lv_img_buf_transform_anti_alias>
 80123fe:	4603      	mov	r3, r0
 8012400:	72fb      	strb	r3, [r7, #11]

    return ret;
 8012402:	7afb      	ldrb	r3, [r7, #11]
}
 8012404:	4618      	mov	r0, r3
 8012406:	3734      	adds	r7, #52	; 0x34
 8012408:	46bd      	mov	sp, r7
 801240a:	bd90      	pop	{r4, r7, pc}

0801240c <lv_draw_img_dsc_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

void lv_draw_img_dsc_init(lv_draw_img_dsc_t * dsc)
{
 801240c:	b580      	push	{r7, lr}
 801240e:	b082      	sub	sp, #8
 8012410:	af00      	add	r7, sp, #0
 8012412:	6078      	str	r0, [r7, #4]
    _lv_memset_00(dsc, sizeof(lv_draw_img_dsc_t));
 8012414:	2110      	movs	r1, #16
 8012416:	6878      	ldr	r0, [r7, #4]
 8012418:	f00f f946 	bl	80216a8 <_lv_memset_00>
    dsc->recolor = LV_COLOR_BLACK;
 801241c:	687a      	ldr	r2, [r7, #4]
 801241e:	7b13      	ldrb	r3, [r2, #12]
 8012420:	f36f 0304 	bfc	r3, #0, #5
 8012424:	7313      	strb	r3, [r2, #12]
 8012426:	687a      	ldr	r2, [r7, #4]
 8012428:	8993      	ldrh	r3, [r2, #12]
 801242a:	f36f 134a 	bfc	r3, #5, #6
 801242e:	8193      	strh	r3, [r2, #12]
 8012430:	687a      	ldr	r2, [r7, #4]
 8012432:	7b53      	ldrb	r3, [r2, #13]
 8012434:	f36f 03c7 	bfc	r3, #3, #5
 8012438:	7353      	strb	r3, [r2, #13]
    dsc->opa = LV_OPA_COVER;
 801243a:	687b      	ldr	r3, [r7, #4]
 801243c:	22ff      	movs	r2, #255	; 0xff
 801243e:	701a      	strb	r2, [r3, #0]
    dsc->zoom = LV_IMG_ZOOM_NONE;
 8012440:	687b      	ldr	r3, [r7, #4]
 8012442:	f44f 7280 	mov.w	r2, #256	; 0x100
 8012446:	811a      	strh	r2, [r3, #8]
    dsc->antialias = LV_ANTIALIAS;
 8012448:	687a      	ldr	r2, [r7, #4]
 801244a:	7bd3      	ldrb	r3, [r2, #15]
 801244c:	f043 0301 	orr.w	r3, r3, #1
 8012450:	73d3      	strb	r3, [r2, #15]

}
 8012452:	bf00      	nop
 8012454:	3708      	adds	r7, #8
 8012456:	46bd      	mov	sp, r7
 8012458:	bd80      	pop	{r7, pc}
	...

0801245c <lv_draw_img>:
 * @param mask the image will be drawn only in this area
 * @param src pointer to a lv_color_t array which contains the pixels of the image
 * @param dsc pointer to an initialized `lv_draw_img_dsc_t` variable
 */
void lv_draw_img(const lv_area_t * coords, const lv_area_t * mask, const void * src, const lv_draw_img_dsc_t * dsc)
{
 801245c:	b580      	push	{r7, lr}
 801245e:	b086      	sub	sp, #24
 8012460:	af00      	add	r7, sp, #0
 8012462:	60f8      	str	r0, [r7, #12]
 8012464:	60b9      	str	r1, [r7, #8]
 8012466:	607a      	str	r2, [r7, #4]
 8012468:	603b      	str	r3, [r7, #0]
    if(src == NULL) {
 801246a:	687b      	ldr	r3, [r7, #4]
 801246c:	2b00      	cmp	r3, #0
 801246e:	d105      	bne.n	801247c <lv_draw_img+0x20>
        LV_LOG_WARN("Image draw: src is NULL");
        show_error(coords, mask, "No\ndata");
 8012470:	4a0f      	ldr	r2, [pc, #60]	; (80124b0 <lv_draw_img+0x54>)
 8012472:	68b9      	ldr	r1, [r7, #8]
 8012474:	68f8      	ldr	r0, [r7, #12]
 8012476:	f000 fed5 	bl	8013224 <show_error>
        return;
 801247a:	e015      	b.n	80124a8 <lv_draw_img+0x4c>
    }

    if(dsc->opa <= LV_OPA_MIN) return;
 801247c:	683b      	ldr	r3, [r7, #0]
 801247e:	781b      	ldrb	r3, [r3, #0]
 8012480:	2b02      	cmp	r3, #2
 8012482:	d910      	bls.n	80124a6 <lv_draw_img+0x4a>

    lv_res_t res;
    res = lv_img_draw_core(coords, mask, src, dsc);
 8012484:	683b      	ldr	r3, [r7, #0]
 8012486:	687a      	ldr	r2, [r7, #4]
 8012488:	68b9      	ldr	r1, [r7, #8]
 801248a:	68f8      	ldr	r0, [r7, #12]
 801248c:	f000 f8cd 	bl	801262a <lv_img_draw_core>
 8012490:	4603      	mov	r3, r0
 8012492:	75fb      	strb	r3, [r7, #23]

    if(res == LV_RES_INV) {
 8012494:	7dfb      	ldrb	r3, [r7, #23]
 8012496:	2b00      	cmp	r3, #0
 8012498:	d106      	bne.n	80124a8 <lv_draw_img+0x4c>
        LV_LOG_WARN("Image draw error");
        show_error(coords, mask, "No\ndata");
 801249a:	4a05      	ldr	r2, [pc, #20]	; (80124b0 <lv_draw_img+0x54>)
 801249c:	68b9      	ldr	r1, [r7, #8]
 801249e:	68f8      	ldr	r0, [r7, #12]
 80124a0:	f000 fec0 	bl	8013224 <show_error>
        return;
 80124a4:	e000      	b.n	80124a8 <lv_draw_img+0x4c>
    if(dsc->opa <= LV_OPA_MIN) return;
 80124a6:	bf00      	nop
    }
}
 80124a8:	3718      	adds	r7, #24
 80124aa:	46bd      	mov	sp, r7
 80124ac:	bd80      	pop	{r7, pc}
 80124ae:	bf00      	nop
 80124b0:	0802e458 	.word	0x0802e458

080124b4 <lv_img_cf_get_px_size>:
 * Get the pixel size of a color format in bits
 * @param cf a color format (`LV_IMG_CF_...`)
 * @return the pixel size in bits
 */
uint8_t lv_img_cf_get_px_size(lv_img_cf_t cf)
{
 80124b4:	b480      	push	{r7}
 80124b6:	b085      	sub	sp, #20
 80124b8:	af00      	add	r7, sp, #0
 80124ba:	4603      	mov	r3, r0
 80124bc:	71fb      	strb	r3, [r7, #7]
    uint8_t px_size = 0;
 80124be:	2300      	movs	r3, #0
 80124c0:	73fb      	strb	r3, [r7, #15]

    switch(cf) {
 80124c2:	79fb      	ldrb	r3, [r7, #7]
 80124c4:	2b0e      	cmp	r3, #14
 80124c6:	d836      	bhi.n	8012536 <lv_img_cf_get_px_size+0x82>
 80124c8:	a201      	add	r2, pc, #4	; (adr r2, 80124d0 <lv_img_cf_get_px_size+0x1c>)
 80124ca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80124ce:	bf00      	nop
 80124d0:	0801250d 	.word	0x0801250d
 80124d4:	0801250d 	.word	0x0801250d
 80124d8:	08012537 	.word	0x08012537
 80124dc:	08012537 	.word	0x08012537
 80124e0:	08012513 	.word	0x08012513
 80124e4:	08012519 	.word	0x08012519
 80124e8:	08012513 	.word	0x08012513
 80124ec:	0801251f 	.word	0x0801251f
 80124f0:	08012525 	.word	0x08012525
 80124f4:	0801252b 	.word	0x0801252b
 80124f8:	08012531 	.word	0x08012531
 80124fc:	0801251f 	.word	0x0801251f
 8012500:	08012525 	.word	0x08012525
 8012504:	0801252b 	.word	0x0801252b
 8012508:	08012531 	.word	0x08012531
        case LV_IMG_CF_UNKNOWN:
        case LV_IMG_CF_RAW:
            px_size = 0;
 801250c:	2300      	movs	r3, #0
 801250e:	73fb      	strb	r3, [r7, #15]
            break;
 8012510:	e014      	b.n	801253c <lv_img_cf_get_px_size+0x88>
        case LV_IMG_CF_TRUE_COLOR:
        case LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED:
            px_size = LV_COLOR_SIZE;
 8012512:	2310      	movs	r3, #16
 8012514:	73fb      	strb	r3, [r7, #15]
            break;
 8012516:	e011      	b.n	801253c <lv_img_cf_get_px_size+0x88>
        case LV_IMG_CF_TRUE_COLOR_ALPHA:
            px_size = LV_IMG_PX_SIZE_ALPHA_BYTE << 3;
 8012518:	2318      	movs	r3, #24
 801251a:	73fb      	strb	r3, [r7, #15]
            break;
 801251c:	e00e      	b.n	801253c <lv_img_cf_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_1BIT:
        case LV_IMG_CF_ALPHA_1BIT:
            px_size = 1;
 801251e:	2301      	movs	r3, #1
 8012520:	73fb      	strb	r3, [r7, #15]
            break;
 8012522:	e00b      	b.n	801253c <lv_img_cf_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_2BIT:
        case LV_IMG_CF_ALPHA_2BIT:
            px_size = 2;
 8012524:	2302      	movs	r3, #2
 8012526:	73fb      	strb	r3, [r7, #15]
            break;
 8012528:	e008      	b.n	801253c <lv_img_cf_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_4BIT:
        case LV_IMG_CF_ALPHA_4BIT:
            px_size = 4;
 801252a:	2304      	movs	r3, #4
 801252c:	73fb      	strb	r3, [r7, #15]
            break;
 801252e:	e005      	b.n	801253c <lv_img_cf_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_8BIT:
        case LV_IMG_CF_ALPHA_8BIT:
            px_size = 8;
 8012530:	2308      	movs	r3, #8
 8012532:	73fb      	strb	r3, [r7, #15]
            break;
 8012534:	e002      	b.n	801253c <lv_img_cf_get_px_size+0x88>
        default:
            px_size = 0;
 8012536:	2300      	movs	r3, #0
 8012538:	73fb      	strb	r3, [r7, #15]
            break;
 801253a:	bf00      	nop
    }

    return px_size;
 801253c:	7bfb      	ldrb	r3, [r7, #15]
}
 801253e:	4618      	mov	r0, r3
 8012540:	3714      	adds	r7, #20
 8012542:	46bd      	mov	sp, r7
 8012544:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012548:	4770      	bx	lr
 801254a:	bf00      	nop

0801254c <lv_img_cf_is_chroma_keyed>:
 * Check if a color format is chroma keyed or not
 * @param cf a color format (`LV_IMG_CF_...`)
 * @return true: chroma keyed; false: not chroma keyed
 */
bool lv_img_cf_is_chroma_keyed(lv_img_cf_t cf)
{
 801254c:	b480      	push	{r7}
 801254e:	b085      	sub	sp, #20
 8012550:	af00      	add	r7, sp, #0
 8012552:	4603      	mov	r3, r0
 8012554:	71fb      	strb	r3, [r7, #7]
    bool is_chroma_keyed = false;
 8012556:	2300      	movs	r3, #0
 8012558:	73fb      	strb	r3, [r7, #15]

    switch(cf) {
 801255a:	79fb      	ldrb	r3, [r7, #7]
 801255c:	2b03      	cmp	r3, #3
 801255e:	d004      	beq.n	801256a <lv_img_cf_is_chroma_keyed+0x1e>
 8012560:	2b03      	cmp	r3, #3
 8012562:	db05      	blt.n	8012570 <lv_img_cf_is_chroma_keyed+0x24>
 8012564:	3b06      	subs	r3, #6
 8012566:	2b04      	cmp	r3, #4
 8012568:	d802      	bhi.n	8012570 <lv_img_cf_is_chroma_keyed+0x24>
        case LV_IMG_CF_RAW_CHROMA_KEYED:
        case LV_IMG_CF_INDEXED_1BIT:
        case LV_IMG_CF_INDEXED_2BIT:
        case LV_IMG_CF_INDEXED_4BIT:
        case LV_IMG_CF_INDEXED_8BIT:
            is_chroma_keyed = true;
 801256a:	2301      	movs	r3, #1
 801256c:	73fb      	strb	r3, [r7, #15]
            break;
 801256e:	e002      	b.n	8012576 <lv_img_cf_is_chroma_keyed+0x2a>

        default:
            is_chroma_keyed = false;
 8012570:	2300      	movs	r3, #0
 8012572:	73fb      	strb	r3, [r7, #15]
            break;
 8012574:	bf00      	nop
    }

    return is_chroma_keyed;
 8012576:	7bfb      	ldrb	r3, [r7, #15]
}
 8012578:	4618      	mov	r0, r3
 801257a:	3714      	adds	r7, #20
 801257c:	46bd      	mov	sp, r7
 801257e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012582:	4770      	bx	lr

08012584 <lv_img_cf_has_alpha>:
 * Check if a color format has alpha channel or not
 * @param cf a color format (`LV_IMG_CF_...`)
 * @return true: has alpha channel; false: doesn't have alpha channel
 */
bool lv_img_cf_has_alpha(lv_img_cf_t cf)
{
 8012584:	b480      	push	{r7}
 8012586:	b085      	sub	sp, #20
 8012588:	af00      	add	r7, sp, #0
 801258a:	4603      	mov	r3, r0
 801258c:	71fb      	strb	r3, [r7, #7]
    bool has_alpha = false;
 801258e:	2300      	movs	r3, #0
 8012590:	73fb      	strb	r3, [r7, #15]

    switch(cf) {
 8012592:	79fb      	ldrb	r3, [r7, #7]
 8012594:	2b0e      	cmp	r3, #14
 8012596:	bf8c      	ite	hi
 8012598:	2201      	movhi	r2, #1
 801259a:	2200      	movls	r2, #0
 801259c:	b2d2      	uxtb	r2, r2
 801259e:	2a00      	cmp	r2, #0
 80125a0:	d10f      	bne.n	80125c2 <lv_img_cf_has_alpha+0x3e>
 80125a2:	f647 72a4 	movw	r2, #32676	; 0x7fa4
 80125a6:	fa22 f303 	lsr.w	r3, r2, r3
 80125aa:	f003 0301 	and.w	r3, r3, #1
 80125ae:	2b00      	cmp	r3, #0
 80125b0:	bf14      	ite	ne
 80125b2:	2301      	movne	r3, #1
 80125b4:	2300      	moveq	r3, #0
 80125b6:	b2db      	uxtb	r3, r3
 80125b8:	2b00      	cmp	r3, #0
 80125ba:	d002      	beq.n	80125c2 <lv_img_cf_has_alpha+0x3e>
        case LV_IMG_CF_INDEXED_8BIT:
        case LV_IMG_CF_ALPHA_1BIT:
        case LV_IMG_CF_ALPHA_2BIT:
        case LV_IMG_CF_ALPHA_4BIT:
        case LV_IMG_CF_ALPHA_8BIT:
            has_alpha = true;
 80125bc:	2301      	movs	r3, #1
 80125be:	73fb      	strb	r3, [r7, #15]
            break;
 80125c0:	e002      	b.n	80125c8 <lv_img_cf_has_alpha+0x44>
        default:
            has_alpha = false;
 80125c2:	2300      	movs	r3, #0
 80125c4:	73fb      	strb	r3, [r7, #15]
            break;
 80125c6:	bf00      	nop
    }

    return has_alpha;
 80125c8:	7bfb      	ldrb	r3, [r7, #15]
}
 80125ca:	4618      	mov	r0, r3
 80125cc:	3714      	adds	r7, #20
 80125ce:	46bd      	mov	sp, r7
 80125d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80125d4:	4770      	bx	lr

080125d6 <lv_img_src_get_type>:
 *  - a path to a file (e.g. "S:/folder/image.bin")
 *  - or a symbol (e.g. LV_SYMBOL_CLOSE)
 * @return type of the image source LV_IMG_SRC_VARIABLE/FILE/SYMBOL/UNKNOWN
 */
lv_img_src_t lv_img_src_get_type(const void * src)
{
 80125d6:	b480      	push	{r7}
 80125d8:	b085      	sub	sp, #20
 80125da:	af00      	add	r7, sp, #0
 80125dc:	6078      	str	r0, [r7, #4]
    lv_img_src_t img_src_type = LV_IMG_SRC_UNKNOWN;
 80125de:	2303      	movs	r3, #3
 80125e0:	73fb      	strb	r3, [r7, #15]

    if(src == NULL) return img_src_type;
 80125e2:	687b      	ldr	r3, [r7, #4]
 80125e4:	2b00      	cmp	r3, #0
 80125e6:	d101      	bne.n	80125ec <lv_img_src_get_type+0x16>
 80125e8:	7bfb      	ldrb	r3, [r7, #15]
 80125ea:	e018      	b.n	801261e <lv_img_src_get_type+0x48>
    const uint8_t * u8_p = src;
 80125ec:	687b      	ldr	r3, [r7, #4]
 80125ee:	60bb      	str	r3, [r7, #8]

    /*The first byte shows the type of the image source*/
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
 80125f0:	68bb      	ldr	r3, [r7, #8]
 80125f2:	781b      	ldrb	r3, [r3, #0]
 80125f4:	2b1f      	cmp	r3, #31
 80125f6:	d907      	bls.n	8012608 <lv_img_src_get_type+0x32>
 80125f8:	68bb      	ldr	r3, [r7, #8]
 80125fa:	781b      	ldrb	r3, [r3, #0]
 80125fc:	b25b      	sxtb	r3, r3
 80125fe:	2b00      	cmp	r3, #0
 8012600:	db02      	blt.n	8012608 <lv_img_src_get_type+0x32>
        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/
 8012602:	2301      	movs	r3, #1
 8012604:	73fb      	strb	r3, [r7, #15]
 8012606:	e009      	b.n	801261c <lv_img_src_get_type+0x46>
    }
    else if(u8_p[0] >= 0x80) {
 8012608:	68bb      	ldr	r3, [r7, #8]
 801260a:	781b      	ldrb	r3, [r3, #0]
 801260c:	b25b      	sxtb	r3, r3
 801260e:	2b00      	cmp	r3, #0
 8012610:	da02      	bge.n	8012618 <lv_img_src_get_type+0x42>
        img_src_type = LV_IMG_SRC_SYMBOL; /*Symbols begins after 0x7F*/
 8012612:	2302      	movs	r3, #2
 8012614:	73fb      	strb	r3, [r7, #15]
 8012616:	e001      	b.n	801261c <lv_img_src_get_type+0x46>
    }
    else {
        img_src_type = LV_IMG_SRC_VARIABLE; /*`lv_img_dsc_t` is design to the first byte < 0x20*/
 8012618:	2300      	movs	r3, #0
 801261a:	73fb      	strb	r3, [r7, #15]

    if(LV_IMG_SRC_UNKNOWN == img_src_type) {
        LV_LOG_WARN("lv_img_src_get_type: unknown image type");
    }

    return img_src_type;
 801261c:	7bfb      	ldrb	r3, [r7, #15]
}
 801261e:	4618      	mov	r0, r3
 8012620:	3714      	adds	r7, #20
 8012622:	46bd      	mov	sp, r7
 8012624:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012628:	4770      	bx	lr

0801262a <lv_img_draw_core>:
 **********************/

LV_ATTRIBUTE_FAST_MEM static lv_res_t lv_img_draw_core(const lv_area_t * coords, const lv_area_t * clip_area,
                                                       const void * src,
                                                       const lv_draw_img_dsc_t * draw_dsc)
{
 801262a:	b5b0      	push	{r4, r5, r7, lr}
 801262c:	b09c      	sub	sp, #112	; 0x70
 801262e:	af02      	add	r7, sp, #8
 8012630:	60f8      	str	r0, [r7, #12]
 8012632:	60b9      	str	r1, [r7, #8]
 8012634:	607a      	str	r2, [r7, #4]
 8012636:	603b      	str	r3, [r7, #0]
    if(draw_dsc->opa <= LV_OPA_MIN) return LV_RES_OK;
 8012638:	683b      	ldr	r3, [r7, #0]
 801263a:	781b      	ldrb	r3, [r3, #0]
 801263c:	2b02      	cmp	r3, #2
 801263e:	d801      	bhi.n	8012644 <lv_img_draw_core+0x1a>
 8012640:	2301      	movs	r3, #1
 8012642:	e151      	b.n	80128e8 <lv_img_draw_core+0x2be>

    lv_img_cache_entry_t * cdsc = _lv_img_cache_open(src, draw_dsc->recolor);
 8012644:	683b      	ldr	r3, [r7, #0]
 8012646:	8999      	ldrh	r1, [r3, #12]
 8012648:	6878      	ldr	r0, [r7, #4]
 801264a:	f009 ff85 	bl	801c558 <_lv_img_cache_open>
 801264e:	65f8      	str	r0, [r7, #92]	; 0x5c

    if(cdsc == NULL) return LV_RES_INV;
 8012650:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012652:	2b00      	cmp	r3, #0
 8012654:	d101      	bne.n	801265a <lv_img_draw_core+0x30>
 8012656:	2300      	movs	r3, #0
 8012658:	e146      	b.n	80128e8 <lv_img_draw_core+0x2be>

    bool chroma_keyed = lv_img_cf_is_chroma_keyed(cdsc->dec_dsc.header.cf);
 801265a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801265c:	7b1b      	ldrb	r3, [r3, #12]
 801265e:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8012662:	b2db      	uxtb	r3, r3
 8012664:	4618      	mov	r0, r3
 8012666:	f7ff ff71 	bl	801254c <lv_img_cf_is_chroma_keyed>
 801266a:	4603      	mov	r3, r0
 801266c:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
    bool alpha_byte   = lv_img_cf_has_alpha(cdsc->dec_dsc.header.cf);
 8012670:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012672:	7b1b      	ldrb	r3, [r3, #12]
 8012674:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8012678:	b2db      	uxtb	r3, r3
 801267a:	4618      	mov	r0, r3
 801267c:	f7ff ff82 	bl	8012584 <lv_img_cf_has_alpha>
 8012680:	4603      	mov	r3, r0
 8012682:	f887 305a 	strb.w	r3, [r7, #90]	; 0x5a

    if(cdsc->dec_dsc.error_msg != NULL) {
 8012686:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012688:	699b      	ldr	r3, [r3, #24]
 801268a:	2b00      	cmp	r3, #0
 801268c:	d007      	beq.n	801269e <lv_img_draw_core+0x74>
        LV_LOG_WARN("Image draw error");

        show_error(coords, clip_area, cdsc->dec_dsc.error_msg);
 801268e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012690:	699b      	ldr	r3, [r3, #24]
 8012692:	461a      	mov	r2, r3
 8012694:	68b9      	ldr	r1, [r7, #8]
 8012696:	68f8      	ldr	r0, [r7, #12]
 8012698:	f000 fdc4 	bl	8013224 <show_error>
 801269c:	e123      	b.n	80128e6 <lv_img_draw_core+0x2bc>
    }
    /* The decoder could open the image and gave the entire uncompressed image.
     * Just draw it!*/
    else if(cdsc->dec_dsc.img_data) {
 801269e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80126a0:	691b      	ldr	r3, [r3, #16]
 80126a2:	2b00      	cmp	r3, #0
 80126a4:	d07a      	beq.n	801279c <lv_img_draw_core+0x172>
        lv_area_t map_area_rot;
        lv_area_copy(&map_area_rot, coords);
 80126a6:	f107 0334 	add.w	r3, r7, #52	; 0x34
 80126aa:	68f9      	ldr	r1, [r7, #12]
 80126ac:	4618      	mov	r0, r3
 80126ae:	f7ff fd00 	bl	80120b2 <lv_area_copy>
        if(draw_dsc->angle || draw_dsc->zoom != LV_IMG_ZOOM_NONE) {
 80126b2:	683b      	ldr	r3, [r7, #0]
 80126b4:	885b      	ldrh	r3, [r3, #2]
 80126b6:	2b00      	cmp	r3, #0
 80126b8:	d104      	bne.n	80126c4 <lv_img_draw_core+0x9a>
 80126ba:	683b      	ldr	r3, [r7, #0]
 80126bc:	891b      	ldrh	r3, [r3, #8]
 80126be:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80126c2:	d048      	beq.n	8012756 <lv_img_draw_core+0x12c>
            int32_t w = lv_area_get_width(coords);
 80126c4:	68f8      	ldr	r0, [r7, #12]
 80126c6:	f7ff fd02 	bl	80120ce <lv_area_get_width>
 80126ca:	4603      	mov	r3, r0
 80126cc:	647b      	str	r3, [r7, #68]	; 0x44
            int32_t h = lv_area_get_height(coords);
 80126ce:	68f8      	ldr	r0, [r7, #12]
 80126d0:	f7ff fd14 	bl	80120fc <lv_area_get_height>
 80126d4:	4603      	mov	r3, r0
 80126d6:	643b      	str	r3, [r7, #64]	; 0x40

            _lv_img_buf_get_transformed_area(&map_area_rot, w, h, draw_dsc->angle, draw_dsc->zoom, &draw_dsc->pivot);
 80126d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80126da:	b219      	sxth	r1, r3
 80126dc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80126de:	b21c      	sxth	r4, r3
 80126e0:	683b      	ldr	r3, [r7, #0]
 80126e2:	885b      	ldrh	r3, [r3, #2]
 80126e4:	b21d      	sxth	r5, r3
 80126e6:	683b      	ldr	r3, [r7, #0]
 80126e8:	891b      	ldrh	r3, [r3, #8]
 80126ea:	683a      	ldr	r2, [r7, #0]
 80126ec:	3204      	adds	r2, #4
 80126ee:	f107 0034 	add.w	r0, r7, #52	; 0x34
 80126f2:	9201      	str	r2, [sp, #4]
 80126f4:	9300      	str	r3, [sp, #0]
 80126f6:	462b      	mov	r3, r5
 80126f8:	4622      	mov	r2, r4
 80126fa:	f009 fa6d 	bl	801bbd8 <_lv_img_buf_get_transformed_area>

            map_area_rot.x1 += coords->x1;
 80126fe:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8012702:	b29a      	uxth	r2, r3
 8012704:	68fb      	ldr	r3, [r7, #12]
 8012706:	f9b3 3000 	ldrsh.w	r3, [r3]
 801270a:	b29b      	uxth	r3, r3
 801270c:	4413      	add	r3, r2
 801270e:	b29b      	uxth	r3, r3
 8012710:	b21b      	sxth	r3, r3
 8012712:	86bb      	strh	r3, [r7, #52]	; 0x34
            map_area_rot.y1 += coords->y1;
 8012714:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8012718:	b29a      	uxth	r2, r3
 801271a:	68fb      	ldr	r3, [r7, #12]
 801271c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8012720:	b29b      	uxth	r3, r3
 8012722:	4413      	add	r3, r2
 8012724:	b29b      	uxth	r3, r3
 8012726:	b21b      	sxth	r3, r3
 8012728:	86fb      	strh	r3, [r7, #54]	; 0x36
            map_area_rot.x2 += coords->x1;
 801272a:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801272e:	b29a      	uxth	r2, r3
 8012730:	68fb      	ldr	r3, [r7, #12]
 8012732:	f9b3 3000 	ldrsh.w	r3, [r3]
 8012736:	b29b      	uxth	r3, r3
 8012738:	4413      	add	r3, r2
 801273a:	b29b      	uxth	r3, r3
 801273c:	b21b      	sxth	r3, r3
 801273e:	873b      	strh	r3, [r7, #56]	; 0x38
            map_area_rot.y2 += coords->y1;
 8012740:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8012744:	b29a      	uxth	r2, r3
 8012746:	68fb      	ldr	r3, [r7, #12]
 8012748:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801274c:	b29b      	uxth	r3, r3
 801274e:	4413      	add	r3, r2
 8012750:	b29b      	uxth	r3, r3
 8012752:	b21b      	sxth	r3, r3
 8012754:	877b      	strh	r3, [r7, #58]	; 0x3a
        }

        lv_area_t mask_com; /*Common area of mask and coords*/
        bool union_ok;
        union_ok = _lv_area_intersect(&mask_com, clip_area, &map_area_rot);
 8012756:	f107 0234 	add.w	r2, r7, #52	; 0x34
 801275a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801275e:	68b9      	ldr	r1, [r7, #8]
 8012760:	4618      	mov	r0, r3
 8012762:	f00c fe83 	bl	801f46c <_lv_area_intersect>
 8012766:	4603      	mov	r3, r0
 8012768:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
        if(union_ok == false) {
 801276c:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8012770:	f083 0301 	eor.w	r3, r3, #1
 8012774:	b2db      	uxtb	r3, r3
 8012776:	2b00      	cmp	r3, #0
 8012778:	d001      	beq.n	801277e <lv_img_draw_core+0x154>
            return LV_RES_OK; /*Out of mask. There is nothing to draw so the image is drawn
 801277a:	2301      	movs	r3, #1
 801277c:	e0b4      	b.n	80128e8 <lv_img_draw_core+0x2be>
                                 successfully.*/
        }

        lv_draw_map(coords, &mask_com, cdsc->dec_dsc.img_data, draw_dsc, chroma_keyed, alpha_byte);
 801277e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8012780:	691a      	ldr	r2, [r3, #16]
 8012782:	f107 012c 	add.w	r1, r7, #44	; 0x2c
 8012786:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801278a:	9301      	str	r3, [sp, #4]
 801278c:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8012790:	9300      	str	r3, [sp, #0]
 8012792:	683b      	ldr	r3, [r7, #0]
 8012794:	68f8      	ldr	r0, [r7, #12]
 8012796:	f000 f8ab 	bl	80128f0 <lv_draw_map>
 801279a:	e0a4      	b.n	80128e6 <lv_img_draw_core+0x2bc>
    }
    /* The whole uncompressed image is not available. Try to read it line-by-line*/
    else {
        lv_area_t mask_com; /*Common area of mask and coords*/
        bool union_ok;
        union_ok = _lv_area_intersect(&mask_com, clip_area, coords);
 801279c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80127a0:	68fa      	ldr	r2, [r7, #12]
 80127a2:	68b9      	ldr	r1, [r7, #8]
 80127a4:	4618      	mov	r0, r3
 80127a6:	f00c fe61 	bl	801f46c <_lv_area_intersect>
 80127aa:	4603      	mov	r3, r0
 80127ac:	f887 3059 	strb.w	r3, [r7, #89]	; 0x59
        if(union_ok == false) {
 80127b0:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 80127b4:	f083 0301 	eor.w	r3, r3, #1
 80127b8:	b2db      	uxtb	r3, r3
 80127ba:	2b00      	cmp	r3, #0
 80127bc:	d001      	beq.n	80127c2 <lv_img_draw_core+0x198>
            return LV_RES_OK; /*Out of mask. There is nothing to draw so the image is drawn
 80127be:	2301      	movs	r3, #1
 80127c0:	e092      	b.n	80128e8 <lv_img_draw_core+0x2be>
                                 successfully.*/
        }

        int32_t width = lv_area_get_width(&mask_com);
 80127c2:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80127c6:	4618      	mov	r0, r3
 80127c8:	f7ff fc81 	bl	80120ce <lv_area_get_width>
 80127cc:	4603      	mov	r3, r0
 80127ce:	657b      	str	r3, [r7, #84]	; 0x54

        uint8_t  * buf = _lv_mem_buf_get(lv_area_get_width(&mask_com) *
 80127d0:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80127d4:	4618      	mov	r0, r3
 80127d6:	f7ff fc7a 	bl	80120ce <lv_area_get_width>
 80127da:	4603      	mov	r3, r0
 80127dc:	461a      	mov	r2, r3
 80127de:	4613      	mov	r3, r2
 80127e0:	005b      	lsls	r3, r3, #1
 80127e2:	4413      	add	r3, r2
 80127e4:	4618      	mov	r0, r3
 80127e6:	f00e fb53 	bl	8020e90 <_lv_mem_buf_get>
 80127ea:	6538      	str	r0, [r7, #80]	; 0x50
                                         LV_IMG_PX_SIZE_ALPHA_BYTE);  /*+1 because of the possible alpha byte*/

        lv_area_t line;
        lv_area_copy(&line, &mask_com);
 80127ec:	f107 0224 	add.w	r2, r7, #36	; 0x24
 80127f0:	f107 031c 	add.w	r3, r7, #28
 80127f4:	4611      	mov	r1, r2
 80127f6:	4618      	mov	r0, r3
 80127f8:	f7ff fc5b 	bl	80120b2 <lv_area_copy>
        lv_area_set_height(&line, 1);
 80127fc:	f107 031c 	add.w	r3, r7, #28
 8012800:	2101      	movs	r1, #1
 8012802:	4618      	mov	r0, r3
 8012804:	f00c fdf9 	bl	801f3fa <lv_area_set_height>
        int32_t x = mask_com.x1 - coords->x1;
 8012808:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 801280c:	461a      	mov	r2, r3
 801280e:	68fb      	ldr	r3, [r7, #12]
 8012810:	f9b3 3000 	ldrsh.w	r3, [r3]
 8012814:	1ad3      	subs	r3, r2, r3
 8012816:	64fb      	str	r3, [r7, #76]	; 0x4c
        int32_t y = mask_com.y1 - coords->y1;
 8012818:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801281c:	461a      	mov	r2, r3
 801281e:	68fb      	ldr	r3, [r7, #12]
 8012820:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8012824:	1ad3      	subs	r3, r2, r3
 8012826:	667b      	str	r3, [r7, #100]	; 0x64
        int32_t row;
        lv_res_t read_res;
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
 8012828:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801282c:	663b      	str	r3, [r7, #96]	; 0x60
 801282e:	e051      	b.n	80128d4 <lv_img_draw_core+0x2aa>
            lv_area_t mask_line;
            union_ok = _lv_area_intersect(&mask_line, clip_area, &line);
 8012830:	f107 021c 	add.w	r2, r7, #28
 8012834:	f107 0314 	add.w	r3, r7, #20
 8012838:	68b9      	ldr	r1, [r7, #8]
 801283a:	4618      	mov	r0, r3
 801283c:	f00c fe16 	bl	801f46c <_lv_area_intersect>
 8012840:	4603      	mov	r3, r0
 8012842:	f887 3059 	strb.w	r3, [r7, #89]	; 0x59
            if(union_ok == false) continue;
 8012846:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 801284a:	f083 0301 	eor.w	r3, r3, #1
 801284e:	b2db      	uxtb	r3, r3
 8012850:	2b00      	cmp	r3, #0
 8012852:	d13b      	bne.n	80128cc <lv_img_draw_core+0x2a2>

            read_res = lv_img_decoder_read_line(&cdsc->dec_dsc, x, y, width, buf);
 8012854:	6df8      	ldr	r0, [r7, #92]	; 0x5c
 8012856:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8012858:	b219      	sxth	r1, r3
 801285a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801285c:	b21a      	sxth	r2, r3
 801285e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8012860:	b21c      	sxth	r4, r3
 8012862:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8012864:	9300      	str	r3, [sp, #0]
 8012866:	4623      	mov	r3, r4
 8012868:	f00a f992 	bl	801cb90 <lv_img_decoder_read_line>
 801286c:	4603      	mov	r3, r0
 801286e:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
            if(read_res != LV_RES_OK) {
 8012872:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 8012876:	2b01      	cmp	r3, #1
 8012878:	d008      	beq.n	801288c <lv_img_draw_core+0x262>
                lv_img_decoder_close(&cdsc->dec_dsc);
 801287a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801287c:	4618      	mov	r0, r3
 801287e:	f00a f9b3 	bl	801cbe8 <lv_img_decoder_close>
                LV_LOG_WARN("Image draw can't read the line");
                _lv_mem_buf_release(buf);
 8012882:	6d38      	ldr	r0, [r7, #80]	; 0x50
 8012884:	f00e fbe4 	bl	8021050 <_lv_mem_buf_release>
                return LV_RES_INV;
 8012888:	2300      	movs	r3, #0
            return LV_RES_OK; /*Out of mask. There is nothing to draw so the image is drawn
 801288a:	e02d      	b.n	80128e8 <lv_img_draw_core+0x2be>
            }


            lv_draw_map(&line, &mask_line, buf, draw_dsc, chroma_keyed, alpha_byte);
 801288c:	f107 0114 	add.w	r1, r7, #20
 8012890:	f107 001c 	add.w	r0, r7, #28
 8012894:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8012898:	9301      	str	r3, [sp, #4]
 801289a:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 801289e:	9300      	str	r3, [sp, #0]
 80128a0:	683b      	ldr	r3, [r7, #0]
 80128a2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80128a4:	f000 f824 	bl	80128f0 <lv_draw_map>
            line.y1++;
 80128a8:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80128ac:	b29b      	uxth	r3, r3
 80128ae:	3301      	adds	r3, #1
 80128b0:	b29b      	uxth	r3, r3
 80128b2:	b21b      	sxth	r3, r3
 80128b4:	83fb      	strh	r3, [r7, #30]
            line.y2++;
 80128b6:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 80128ba:	b29b      	uxth	r3, r3
 80128bc:	3301      	adds	r3, #1
 80128be:	b29b      	uxth	r3, r3
 80128c0:	b21b      	sxth	r3, r3
 80128c2:	847b      	strh	r3, [r7, #34]	; 0x22
            y++;
 80128c4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80128c6:	3301      	adds	r3, #1
 80128c8:	667b      	str	r3, [r7, #100]	; 0x64
 80128ca:	e000      	b.n	80128ce <lv_img_draw_core+0x2a4>
            if(union_ok == false) continue;
 80128cc:	bf00      	nop
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
 80128ce:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80128d0:	3301      	adds	r3, #1
 80128d2:	663b      	str	r3, [r7, #96]	; 0x60
 80128d4:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80128d8:	461a      	mov	r2, r3
 80128da:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80128dc:	4293      	cmp	r3, r2
 80128de:	dda7      	ble.n	8012830 <lv_img_draw_core+0x206>
        }
        _lv_mem_buf_release(buf);
 80128e0:	6d38      	ldr	r0, [r7, #80]	; 0x50
 80128e2:	f00e fbb5 	bl	8021050 <_lv_mem_buf_release>
    }

    return LV_RES_OK;
 80128e6:	2301      	movs	r3, #1
}
 80128e8:	4618      	mov	r0, r3
 80128ea:	3768      	adds	r7, #104	; 0x68
 80128ec:	46bd      	mov	sp, r7
 80128ee:	bdb0      	pop	{r4, r5, r7, pc}

080128f0 <lv_draw_map>:
 */
LV_ATTRIBUTE_FAST_MEM static void lv_draw_map(const lv_area_t * map_area, const lv_area_t * clip_area,
                                              const uint8_t * map_p,
                                              const lv_draw_img_dsc_t * draw_dsc,
                                              bool chroma_key, bool alpha_byte)
{
 80128f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80128f2:	b0bf      	sub	sp, #252	; 0xfc
 80128f4:	af04      	add	r7, sp, #16
 80128f6:	60f8      	str	r0, [r7, #12]
 80128f8:	60b9      	str	r1, [r7, #8]
 80128fa:	607a      	str	r2, [r7, #4]
 80128fc:	603b      	str	r3, [r7, #0]
    /* Use the clip area as draw area*/
    lv_area_t draw_area;
    lv_area_copy(&draw_area, clip_area);
 80128fe:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8012902:	68b9      	ldr	r1, [r7, #8]
 8012904:	4618      	mov	r0, r3
 8012906:	f7ff fbd4 	bl	80120b2 <lv_area_copy>

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
 801290a:	f7fb fd69 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 801290e:	f8c7 00c4 	str.w	r0, [r7, #196]	; 0xc4
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8012912:	f8d7 00c4 	ldr.w	r0, [r7, #196]	; 0xc4
 8012916:	f00c f979 	bl	801ec0c <lv_disp_get_buf>
 801291a:	f8c7 00c0 	str.w	r0, [r7, #192]	; 0xc0
    const lv_area_t * disp_area = &vdb->area;
 801291e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8012922:	3310      	adds	r3, #16
 8012924:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

    /* Now `draw_area` has absolute coordinates.
     * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
    draw_area.x1 -= disp_area->x1;
 8012928:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 801292c:	b29a      	uxth	r2, r3
 801292e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8012932:	f9b3 3000 	ldrsh.w	r3, [r3]
 8012936:	b29b      	uxth	r3, r3
 8012938:	1ad3      	subs	r3, r2, r3
 801293a:	b29b      	uxth	r3, r3
 801293c:	b21b      	sxth	r3, r3
 801293e:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
    draw_area.y1 -= disp_area->y1;
 8012942:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8012946:	b29a      	uxth	r2, r3
 8012948:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801294c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8012950:	b29b      	uxth	r3, r3
 8012952:	1ad3      	subs	r3, r2, r3
 8012954:	b29b      	uxth	r3, r3
 8012956:	b21b      	sxth	r3, r3
 8012958:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
    draw_area.x2 -= disp_area->x1;
 801295c:	f9b7 3078 	ldrsh.w	r3, [r7, #120]	; 0x78
 8012960:	b29a      	uxth	r2, r3
 8012962:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8012966:	f9b3 3000 	ldrsh.w	r3, [r3]
 801296a:	b29b      	uxth	r3, r3
 801296c:	1ad3      	subs	r3, r2, r3
 801296e:	b29b      	uxth	r3, r3
 8012970:	b21b      	sxth	r3, r3
 8012972:	f8a7 3078 	strh.w	r3, [r7, #120]	; 0x78
    draw_area.y2 -= disp_area->y1;
 8012976:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 801297a:	b29a      	uxth	r2, r3
 801297c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8012980:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8012984:	b29b      	uxth	r3, r3
 8012986:	1ad3      	subs	r3, r2, r3
 8012988:	b29b      	uxth	r3, r3
 801298a:	b21b      	sxth	r3, r3
 801298c:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a

    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
 8012990:	f003 fbac 	bl	80160ec <lv_draw_mask_get_cnt>
 8012994:	4603      	mov	r3, r0
 8012996:	f887 30bb 	strb.w	r3, [r7, #187]	; 0xbb

    /*The simplest case just copy the pixels into the VDB*/
    if(other_mask_cnt == 0 && draw_dsc->angle == 0 && draw_dsc->zoom == LV_IMG_ZOOM_NONE &&
 801299a:	f897 30bb 	ldrb.w	r3, [r7, #187]	; 0xbb
 801299e:	2b00      	cmp	r3, #0
 80129a0:	d12a      	bne.n	80129f8 <lv_draw_map+0x108>
 80129a2:	683b      	ldr	r3, [r7, #0]
 80129a4:	885b      	ldrh	r3, [r3, #2]
 80129a6:	2b00      	cmp	r3, #0
 80129a8:	d126      	bne.n	80129f8 <lv_draw_map+0x108>
 80129aa:	683b      	ldr	r3, [r7, #0]
 80129ac:	891b      	ldrh	r3, [r3, #8]
 80129ae:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80129b2:	d121      	bne.n	80129f8 <lv_draw_map+0x108>
       chroma_key == false && alpha_byte == false && draw_dsc->recolor_opa == LV_OPA_TRANSP) {
 80129b4:	f897 3100 	ldrb.w	r3, [r7, #256]	; 0x100
 80129b8:	f083 0301 	eor.w	r3, r3, #1
 80129bc:	b2db      	uxtb	r3, r3
    if(other_mask_cnt == 0 && draw_dsc->angle == 0 && draw_dsc->zoom == LV_IMG_ZOOM_NONE &&
 80129be:	2b00      	cmp	r3, #0
 80129c0:	d01a      	beq.n	80129f8 <lv_draw_map+0x108>
       chroma_key == false && alpha_byte == false && draw_dsc->recolor_opa == LV_OPA_TRANSP) {
 80129c2:	f897 3104 	ldrb.w	r3, [r7, #260]	; 0x104
 80129c6:	f083 0301 	eor.w	r3, r3, #1
 80129ca:	b2db      	uxtb	r3, r3
 80129cc:	2b00      	cmp	r3, #0
 80129ce:	d013      	beq.n	80129f8 <lv_draw_map+0x108>
 80129d0:	683b      	ldr	r3, [r7, #0]
 80129d2:	7a9b      	ldrb	r3, [r3, #10]
 80129d4:	2b00      	cmp	r3, #0
 80129d6:	d10f      	bne.n	80129f8 <lv_draw_map+0x108>
        _lv_blend_map(clip_area, map_area, (lv_color_t *)map_p, NULL, LV_DRAW_MASK_RES_FULL_COVER, draw_dsc->opa,
 80129d8:	683b      	ldr	r3, [r7, #0]
 80129da:	781b      	ldrb	r3, [r3, #0]
                      draw_dsc->blend_mode);
 80129dc:	683a      	ldr	r2, [r7, #0]
 80129de:	7b92      	ldrb	r2, [r2, #14]
        _lv_blend_map(clip_area, map_area, (lv_color_t *)map_p, NULL, LV_DRAW_MASK_RES_FULL_COVER, draw_dsc->opa,
 80129e0:	9202      	str	r2, [sp, #8]
 80129e2:	9301      	str	r3, [sp, #4]
 80129e4:	2301      	movs	r3, #1
 80129e6:	9300      	str	r3, [sp, #0]
 80129e8:	2300      	movs	r3, #0
 80129ea:	687a      	ldr	r2, [r7, #4]
 80129ec:	68f9      	ldr	r1, [r7, #12]
 80129ee:	68b8      	ldr	r0, [r7, #8]
 80129f0:	f7fe f800 	bl	80109f4 <_lv_blend_map>
 80129f4:	f000 bc11 	b.w	801321a <lv_draw_map+0x92a>
    }
    /*In the other cases every pixel need to be checked one-by-one*/
    else {
        /*The pixel size in byte is different if an alpha byte is added too*/
        uint8_t px_size_byte = alpha_byte ? LV_IMG_PX_SIZE_ALPHA_BYTE : sizeof(lv_color_t);
 80129f8:	f897 3104 	ldrb.w	r3, [r7, #260]	; 0x104
 80129fc:	2b00      	cmp	r3, #0
 80129fe:	d001      	beq.n	8012a04 <lv_draw_map+0x114>
 8012a00:	2303      	movs	r3, #3
 8012a02:	e000      	b.n	8012a06 <lv_draw_map+0x116>
 8012a04:	2302      	movs	r3, #2
 8012a06:	f887 30ba 	strb.w	r3, [r7, #186]	; 0xba

        /*Go to the first displayed pixel of the map*/
        int32_t map_w = lv_area_get_width(map_area);
 8012a0a:	68f8      	ldr	r0, [r7, #12]
 8012a0c:	f7ff fb5f 	bl	80120ce <lv_area_get_width>
 8012a10:	4603      	mov	r3, r0
 8012a12:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
        const uint8_t * map_buf_tmp = map_p;
 8012a16:	687b      	ldr	r3, [r7, #4]
 8012a18:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
        map_buf_tmp += map_w * (draw_area.y1 - (map_area->y1 - disp_area->y1)) * px_size_byte;
 8012a1c:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8012a20:	461a      	mov	r2, r3
 8012a22:	68fb      	ldr	r3, [r7, #12]
 8012a24:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8012a28:	4619      	mov	r1, r3
 8012a2a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8012a2e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8012a32:	1acb      	subs	r3, r1, r3
 8012a34:	1ad3      	subs	r3, r2, r3
 8012a36:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8012a3a:	fb02 f303 	mul.w	r3, r2, r3
 8012a3e:	f897 20ba 	ldrb.w	r2, [r7, #186]	; 0xba
 8012a42:	fb02 f303 	mul.w	r3, r2, r3
 8012a46:	461a      	mov	r2, r3
 8012a48:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8012a4c:	4413      	add	r3, r2
 8012a4e:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
        map_buf_tmp += (draw_area.x1 - (map_area->x1 - disp_area->x1)) * px_size_byte;
 8012a52:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8012a56:	461a      	mov	r2, r3
 8012a58:	68fb      	ldr	r3, [r7, #12]
 8012a5a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8012a5e:	4619      	mov	r1, r3
 8012a60:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8012a64:	f9b3 3000 	ldrsh.w	r3, [r3]
 8012a68:	1acb      	subs	r3, r1, r3
 8012a6a:	1ad3      	subs	r3, r2, r3
 8012a6c:	f897 20ba 	ldrb.w	r2, [r7, #186]	; 0xba
 8012a70:	fb02 f303 	mul.w	r3, r2, r3
 8012a74:	461a      	mov	r2, r3
 8012a76:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8012a7a:	4413      	add	r3, r2
 8012a7c:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4

        lv_color_t c;
        lv_color_t chroma_keyed_color = LV_COLOR_TRANSP;
 8012a80:	f897 306c 	ldrb.w	r3, [r7, #108]	; 0x6c
 8012a84:	f36f 0304 	bfc	r3, #0, #5
 8012a88:	f887 306c 	strb.w	r3, [r7, #108]	; 0x6c
 8012a8c:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 8012a90:	f443 63fc 	orr.w	r3, r3, #2016	; 0x7e0
 8012a94:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
 8012a98:	f897 306d 	ldrb.w	r3, [r7, #109]	; 0x6d
 8012a9c:	f36f 03c7 	bfc	r3, #3, #5
 8012aa0:	f887 306d 	strb.w	r3, [r7, #109]	; 0x6d
        uint32_t px_i = 0;
 8012aa4:	2300      	movs	r3, #0
 8012aa6:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

        const uint8_t * map_px;

        lv_area_t blend_area;
        blend_area.x1 = draw_area.x1 + disp_area->x1;
 8012aaa:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8012aae:	b29a      	uxth	r2, r3
 8012ab0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8012ab4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8012ab8:	b29b      	uxth	r3, r3
 8012aba:	4413      	add	r3, r2
 8012abc:	b29b      	uxth	r3, r3
 8012abe:	b21b      	sxth	r3, r3
 8012ac0:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
        blend_area.x2 = blend_area.x1 + lv_area_get_width(&draw_area) - 1;
 8012ac4:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 8012ac8:	b29c      	uxth	r4, r3
 8012aca:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8012ace:	4618      	mov	r0, r3
 8012ad0:	f7ff fafd 	bl	80120ce <lv_area_get_width>
 8012ad4:	4603      	mov	r3, r0
 8012ad6:	b29b      	uxth	r3, r3
 8012ad8:	4423      	add	r3, r4
 8012ada:	b29b      	uxth	r3, r3
 8012adc:	3b01      	subs	r3, #1
 8012ade:	b29b      	uxth	r3, r3
 8012ae0:	b21b      	sxth	r3, r3
 8012ae2:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
        blend_area.y1 = disp_area->y1 + draw_area.y1;
 8012ae6:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8012aea:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8012aee:	b29a      	uxth	r2, r3
 8012af0:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8012af4:	b29b      	uxth	r3, r3
 8012af6:	4413      	add	r3, r2
 8012af8:	b29b      	uxth	r3, r3
 8012afa:	b21b      	sxth	r3, r3
 8012afc:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
        blend_area.y2 = blend_area.y1;
 8012b00:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 8012b04:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a

        lv_coord_t draw_area_h = lv_area_get_height(&draw_area);
 8012b08:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8012b0c:	4618      	mov	r0, r3
 8012b0e:	f7ff faf5 	bl	80120fc <lv_area_get_height>
 8012b12:	4603      	mov	r3, r0
 8012b14:	f8a7 30b2 	strh.w	r3, [r7, #178]	; 0xb2
        lv_coord_t draw_area_w = lv_area_get_width(&draw_area);
 8012b18:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8012b1c:	4618      	mov	r0, r3
 8012b1e:	f7ff fad6 	bl	80120ce <lv_area_get_width>
 8012b22:	4603      	mov	r3, r0
 8012b24:	f8a7 30b0 	strh.w	r3, [r7, #176]	; 0xb0

#if LV_USE_IMG_TRANSFORM
        bool transform = draw_dsc->angle != 0 || draw_dsc->zoom != LV_IMG_ZOOM_NONE ? true : false;
 8012b28:	683b      	ldr	r3, [r7, #0]
 8012b2a:	885b      	ldrh	r3, [r3, #2]
 8012b2c:	2b00      	cmp	r3, #0
 8012b2e:	d104      	bne.n	8012b3a <lv_draw_map+0x24a>
 8012b30:	683b      	ldr	r3, [r7, #0]
 8012b32:	891b      	ldrh	r3, [r3, #8]
 8012b34:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8012b38:	d001      	beq.n	8012b3e <lv_draw_map+0x24e>
 8012b3a:	2301      	movs	r3, #1
 8012b3c:	e000      	b.n	8012b40 <lv_draw_map+0x250>
 8012b3e:	2300      	movs	r3, #0
 8012b40:	f887 30af 	strb.w	r3, [r7, #175]	; 0xaf
 8012b44:	f897 30af 	ldrb.w	r3, [r7, #175]	; 0xaf
 8012b48:	f003 0301 	and.w	r3, r3, #1
 8012b4c:	f887 30af 	strb.w	r3, [r7, #175]	; 0xaf
#else
        bool transform = false;
#endif
        /*Simple ARGB image. Handle it as special case because it's very common*/
        if(other_mask_cnt == 0 && !transform && !chroma_key && draw_dsc->recolor_opa == LV_OPA_TRANSP && alpha_byte) {
 8012b50:	f897 30bb 	ldrb.w	r3, [r7, #187]	; 0xbb
 8012b54:	2b00      	cmp	r3, #0
 8012b56:	f040 80fc 	bne.w	8012d52 <lv_draw_map+0x462>
 8012b5a:	f897 30af 	ldrb.w	r3, [r7, #175]	; 0xaf
 8012b5e:	f083 0301 	eor.w	r3, r3, #1
 8012b62:	b2db      	uxtb	r3, r3
 8012b64:	2b00      	cmp	r3, #0
 8012b66:	f000 80f4 	beq.w	8012d52 <lv_draw_map+0x462>
 8012b6a:	f897 3100 	ldrb.w	r3, [r7, #256]	; 0x100
 8012b6e:	f083 0301 	eor.w	r3, r3, #1
 8012b72:	b2db      	uxtb	r3, r3
 8012b74:	2b00      	cmp	r3, #0
 8012b76:	f000 80ec 	beq.w	8012d52 <lv_draw_map+0x462>
 8012b7a:	683b      	ldr	r3, [r7, #0]
 8012b7c:	7a9b      	ldrb	r3, [r3, #10]
 8012b7e:	2b00      	cmp	r3, #0
 8012b80:	f040 80e7 	bne.w	8012d52 <lv_draw_map+0x462>
 8012b84:	f897 3104 	ldrb.w	r3, [r7, #260]	; 0x104
 8012b88:	2b00      	cmp	r3, #0
 8012b8a:	f000 80e2 	beq.w	8012d52 <lv_draw_map+0x462>
                lv_gpu_stm32_dma2d_blend(disp_buf_first, disp_w, (const lv_color_t *)map_buf_tmp, draw_dsc->opa, map_w, draw_area_w,
                                         draw_area_h);
                return;
            }
#endif
            uint32_t mask_buf_size = lv_area_get_size(&draw_area) > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : lv_area_get_size(&draw_area);
 8012b8e:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8012b92:	4618      	mov	r0, r3
 8012b94:	f00c fc49 	bl	801f42a <lv_area_get_size>
 8012b98:	4603      	mov	r3, r0
 8012b9a:	f5b3 7f48 	cmp.w	r3, #800	; 0x320
 8012b9e:	d806      	bhi.n	8012bae <lv_draw_map+0x2be>
 8012ba0:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8012ba4:	4618      	mov	r0, r3
 8012ba6:	f00c fc40 	bl	801f42a <lv_area_get_size>
 8012baa:	4603      	mov	r3, r0
 8012bac:	e001      	b.n	8012bb2 <lv_draw_map+0x2c2>
 8012bae:	f44f 7348 	mov.w	r3, #800	; 0x320
 8012bb2:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
            lv_color_t * map2 = _lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));
 8012bb6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8012bba:	005b      	lsls	r3, r3, #1
 8012bbc:	4618      	mov	r0, r3
 8012bbe:	f00e f967 	bl	8020e90 <_lv_mem_buf_get>
 8012bc2:	f8c7 00a4 	str.w	r0, [r7, #164]	; 0xa4
            lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
 8012bc6:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 8012bca:	f00e f961 	bl	8020e90 <_lv_mem_buf_get>
 8012bce:	f8c7 00a0 	str.w	r0, [r7, #160]	; 0xa0

            int32_t x;
            int32_t y;
            for(y = 0; y < draw_area_h; y++) {
 8012bd2:	2300      	movs	r3, #0
 8012bd4:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 8012bd8:	e08c      	b.n	8012cf4 <lv_draw_map+0x404>
                map_px = map_buf_tmp;
 8012bda:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8012bde:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {
 8012be2:	2300      	movs	r3, #0
 8012be4:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 8012be8:	e036      	b.n	8012c58 <lv_draw_map+0x368>
                    lv_opa_t px_opa = map_px[LV_IMG_PX_SIZE_ALPHA_BYTE - 1];
 8012bea:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8012bee:	3302      	adds	r3, #2
 8012bf0:	781b      	ldrb	r3, [r3, #0]
 8012bf2:	f887 309f 	strb.w	r3, [r7, #159]	; 0x9f
                    mask_buf[px_i] = px_opa;
 8012bf6:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 8012bfa:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8012bfe:	4413      	add	r3, r2
 8012c00:	f897 209f 	ldrb.w	r2, [r7, #159]	; 0x9f
 8012c04:	701a      	strb	r2, [r3, #0]
                    if(px_opa) {
 8012c06:	f897 309f 	ldrb.w	r3, [r7, #159]	; 0x9f
 8012c0a:	2b00      	cmp	r3, #0
 8012c0c:	d013      	beq.n	8012c36 <lv_draw_map+0x346>
#if LV_COLOR_DEPTH == 8 || LV_COLOR_DEPTH == 1
                        map2[px_i].full =  map_px[0];
#elif LV_COLOR_DEPTH == 16
                        map2[px_i].full =  map_px[0] + (map_px[1] << 8);
 8012c0e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8012c12:	781b      	ldrb	r3, [r3, #0]
 8012c14:	b299      	uxth	r1, r3
 8012c16:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8012c1a:	3301      	adds	r3, #1
 8012c1c:	781b      	ldrb	r3, [r3, #0]
 8012c1e:	b29b      	uxth	r3, r3
 8012c20:	021b      	lsls	r3, r3, #8
 8012c22:	b29a      	uxth	r2, r3
 8012c24:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8012c28:	005b      	lsls	r3, r3, #1
 8012c2a:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8012c2e:	4403      	add	r3, r0
 8012c30:	440a      	add	r2, r1
 8012c32:	b292      	uxth	r2, r2
 8012c34:	801a      	strh	r2, [r3, #0]
                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {
 8012c36:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8012c3a:	3301      	adds	r3, #1
 8012c3c:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
 8012c40:	f897 30ba 	ldrb.w	r3, [r7, #186]	; 0xba
 8012c44:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8012c48:	4413      	add	r3, r2
 8012c4a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8012c4e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8012c52:	3301      	adds	r3, #1
 8012c54:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8012c58:	f9b7 30b0 	ldrsh.w	r3, [r7, #176]	; 0xb0
 8012c5c:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 8012c60:	429a      	cmp	r2, r3
 8012c62:	dbc2      	blt.n	8012bea <lv_draw_map+0x2fa>
#if LV_COLOR_DEPTH == 32
                    map2[px_i].ch.alpha = 0xFF;
#endif
                }

                map_buf_tmp += map_w * px_size_byte;
 8012c64:	f897 30ba 	ldrb.w	r3, [r7, #186]	; 0xba
 8012c68:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8012c6c:	fb02 f303 	mul.w	r3, r2, r3
 8012c70:	461a      	mov	r2, r3
 8012c72:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8012c76:	4413      	add	r3, r2
 8012c78:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
                if(px_i + lv_area_get_width(&draw_area) < mask_buf_size) {
 8012c7c:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8012c80:	4618      	mov	r0, r3
 8012c82:	f7ff fa24 	bl	80120ce <lv_area_get_width>
 8012c86:	4603      	mov	r3, r0
 8012c88:	461a      	mov	r2, r3
 8012c8a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8012c8e:	4413      	add	r3, r2
 8012c90:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8012c94:	429a      	cmp	r2, r3
 8012c96:	d908      	bls.n	8012caa <lv_draw_map+0x3ba>
                    blend_area.y2 ++;
 8012c98:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8012c9c:	b29b      	uxth	r3, r3
 8012c9e:	3301      	adds	r3, #1
 8012ca0:	b29b      	uxth	r3, r3
 8012ca2:	b21b      	sxth	r3, r3
 8012ca4:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 8012ca8:	e01f      	b.n	8012cea <lv_draw_map+0x3fa>
                }
                else {
                    _lv_blend_map(clip_area, &blend_area, map2, mask_buf, LV_DRAW_MASK_RES_CHANGED, draw_dsc->opa, draw_dsc->blend_mode);
 8012caa:	683b      	ldr	r3, [r7, #0]
 8012cac:	781b      	ldrb	r3, [r3, #0]
 8012cae:	683a      	ldr	r2, [r7, #0]
 8012cb0:	7b92      	ldrb	r2, [r2, #14]
 8012cb2:	f107 0164 	add.w	r1, r7, #100	; 0x64
 8012cb6:	9202      	str	r2, [sp, #8]
 8012cb8:	9301      	str	r3, [sp, #4]
 8012cba:	2302      	movs	r3, #2
 8012cbc:	9300      	str	r3, [sp, #0]
 8012cbe:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8012cc2:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8012cc6:	68b8      	ldr	r0, [r7, #8]
 8012cc8:	f7fd fe94 	bl	80109f4 <_lv_blend_map>

                    blend_area.y1 = blend_area.y2 + 1;
 8012ccc:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8012cd0:	b29b      	uxth	r3, r3
 8012cd2:	3301      	adds	r3, #1
 8012cd4:	b29b      	uxth	r3, r3
 8012cd6:	b21b      	sxth	r3, r3
 8012cd8:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
                    blend_area.y2 = blend_area.y1;
 8012cdc:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 8012ce0:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a

                    px_i = 0;
 8012ce4:	2300      	movs	r3, #0
 8012ce6:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
            for(y = 0; y < draw_area_h; y++) {
 8012cea:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8012cee:	3301      	adds	r3, #1
 8012cf0:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
 8012cf4:	f9b7 30b2 	ldrsh.w	r3, [r7, #178]	; 0xb2
 8012cf8:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
 8012cfc:	429a      	cmp	r2, r3
 8012cfe:	f6ff af6c 	blt.w	8012bda <lv_draw_map+0x2ea>
                }
            }
            /*Flush the last part*/
            if(blend_area.y1 != blend_area.y2) {
 8012d02:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 8012d06:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8012d0a:	429a      	cmp	r2, r3
 8012d0c:	d018      	beq.n	8012d40 <lv_draw_map+0x450>
                blend_area.y2--;
 8012d0e:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8012d12:	b29b      	uxth	r3, r3
 8012d14:	3b01      	subs	r3, #1
 8012d16:	b29b      	uxth	r3, r3
 8012d18:	b21b      	sxth	r3, r3
 8012d1a:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
                _lv_blend_map(clip_area, &blend_area, map2, mask_buf, LV_DRAW_MASK_RES_CHANGED, draw_dsc->opa, draw_dsc->blend_mode);
 8012d1e:	683b      	ldr	r3, [r7, #0]
 8012d20:	781b      	ldrb	r3, [r3, #0]
 8012d22:	683a      	ldr	r2, [r7, #0]
 8012d24:	7b92      	ldrb	r2, [r2, #14]
 8012d26:	f107 0164 	add.w	r1, r7, #100	; 0x64
 8012d2a:	9202      	str	r2, [sp, #8]
 8012d2c:	9301      	str	r3, [sp, #4]
 8012d2e:	2302      	movs	r3, #2
 8012d30:	9300      	str	r3, [sp, #0]
 8012d32:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8012d36:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8012d3a:	68b8      	ldr	r0, [r7, #8]
 8012d3c:	f7fd fe5a 	bl	80109f4 <_lv_blend_map>
            }

            _lv_mem_buf_release(mask_buf);
 8012d40:	f8d7 00a0 	ldr.w	r0, [r7, #160]	; 0xa0
 8012d44:	f00e f984 	bl	8021050 <_lv_mem_buf_release>
            _lv_mem_buf_release(map2);
 8012d48:	f8d7 00a4 	ldr.w	r0, [r7, #164]	; 0xa4
 8012d4c:	f00e f980 	bl	8021050 <_lv_mem_buf_release>
        if(other_mask_cnt == 0 && !transform && !chroma_key && draw_dsc->recolor_opa == LV_OPA_TRANSP && alpha_byte) {
 8012d50:	e263      	b.n	801321a <lv_draw_map+0x92a>
        }
        /*Most complicated case: transform or other mask or chroma keyed*/
        else {
            /*Build the image and a mask line-by-line*/
            uint32_t mask_buf_size = lv_area_get_size(&draw_area) > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : lv_area_get_size(&draw_area);
 8012d52:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8012d56:	4618      	mov	r0, r3
 8012d58:	f00c fb67 	bl	801f42a <lv_area_get_size>
 8012d5c:	4603      	mov	r3, r0
 8012d5e:	f5b3 7f48 	cmp.w	r3, #800	; 0x320
 8012d62:	d806      	bhi.n	8012d72 <lv_draw_map+0x482>
 8012d64:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8012d68:	4618      	mov	r0, r3
 8012d6a:	f00c fb5e 	bl	801f42a <lv_area_get_size>
 8012d6e:	4603      	mov	r3, r0
 8012d70:	e001      	b.n	8012d76 <lv_draw_map+0x486>
 8012d72:	f44f 7348 	mov.w	r3, #800	; 0x320
 8012d76:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
            lv_color_t * map2 = _lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));
 8012d7a:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8012d7e:	005b      	lsls	r3, r3, #1
 8012d80:	4618      	mov	r0, r3
 8012d82:	f00e f885 	bl	8020e90 <_lv_mem_buf_get>
 8012d86:	f8c7 0094 	str.w	r0, [r7, #148]	; 0x94
            lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
 8012d8a:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
 8012d8e:	f00e f87f 	bl	8020e90 <_lv_mem_buf_get>
 8012d92:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90

#if LV_USE_IMG_TRANSFORM
            lv_img_transform_dsc_t trans_dsc;
            _lv_memset_00(&trans_dsc, sizeof(lv_img_transform_dsc_t));
 8012d96:	f107 0310 	add.w	r3, r7, #16
 8012d9a:	214c      	movs	r1, #76	; 0x4c
 8012d9c:	4618      	mov	r0, r3
 8012d9e:	f00e fc83 	bl	80216a8 <_lv_memset_00>
            if(transform) {
 8012da2:	f897 30af 	ldrb.w	r3, [r7, #175]	; 0xaf
 8012da6:	2b00      	cmp	r3, #0
 8012da8:	d043      	beq.n	8012e32 <lv_draw_map+0x542>
                lv_img_cf_t cf = LV_IMG_CF_TRUE_COLOR;
 8012daa:	2304      	movs	r3, #4
 8012dac:	f887 30d3 	strb.w	r3, [r7, #211]	; 0xd3
                if(alpha_byte) cf = LV_IMG_CF_TRUE_COLOR_ALPHA;
 8012db0:	f897 3104 	ldrb.w	r3, [r7, #260]	; 0x104
 8012db4:	2b00      	cmp	r3, #0
 8012db6:	d003      	beq.n	8012dc0 <lv_draw_map+0x4d0>
 8012db8:	2305      	movs	r3, #5
 8012dba:	f887 30d3 	strb.w	r3, [r7, #211]	; 0xd3
 8012dbe:	e006      	b.n	8012dce <lv_draw_map+0x4de>
                else if(chroma_key) cf = LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED;
 8012dc0:	f897 3100 	ldrb.w	r3, [r7, #256]	; 0x100
 8012dc4:	2b00      	cmp	r3, #0
 8012dc6:	d002      	beq.n	8012dce <lv_draw_map+0x4de>
 8012dc8:	2306      	movs	r3, #6
 8012dca:	f887 30d3 	strb.w	r3, [r7, #211]	; 0xd3

                trans_dsc.cfg.angle = draw_dsc->angle;
 8012dce:	683b      	ldr	r3, [r7, #0]
 8012dd0:	885b      	ldrh	r3, [r3, #2]
 8012dd2:	b21b      	sxth	r3, r3
 8012dd4:	83bb      	strh	r3, [r7, #28]
                trans_dsc.cfg.zoom = draw_dsc->zoom;
 8012dd6:	683b      	ldr	r3, [r7, #0]
 8012dd8:	891b      	ldrh	r3, [r3, #8]
 8012dda:	83fb      	strh	r3, [r7, #30]
                trans_dsc.cfg.src = map_p;
 8012ddc:	687b      	ldr	r3, [r7, #4]
 8012dde:	613b      	str	r3, [r7, #16]
                trans_dsc.cfg.src_w = map_w;
 8012de0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8012de4:	b21b      	sxth	r3, r3
 8012de6:	82bb      	strh	r3, [r7, #20]
                trans_dsc.cfg.src_h = lv_area_get_height(map_area);;
 8012de8:	68f8      	ldr	r0, [r7, #12]
 8012dea:	f7ff f987 	bl	80120fc <lv_area_get_height>
 8012dee:	4603      	mov	r3, r0
 8012df0:	82fb      	strh	r3, [r7, #22]
                trans_dsc.cfg.cf = cf;
 8012df2:	f897 30d3 	ldrb.w	r3, [r7, #211]	; 0xd3
 8012df6:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
                trans_dsc.cfg.pivot_x = draw_dsc->pivot.x;
 8012dfa:	683b      	ldr	r3, [r7, #0]
 8012dfc:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8012e00:	833b      	strh	r3, [r7, #24]
                trans_dsc.cfg.pivot_y = draw_dsc->pivot.y;
 8012e02:	683b      	ldr	r3, [r7, #0]
 8012e04:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8012e08:	837b      	strh	r3, [r7, #26]
                trans_dsc.cfg.color = draw_dsc->recolor;
 8012e0a:	683b      	ldr	r3, [r7, #0]
 8012e0c:	899b      	ldrh	r3, [r3, #12]
 8012e0e:	843b      	strh	r3, [r7, #32]
                trans_dsc.cfg.antialias = draw_dsc->antialias;
 8012e10:	683b      	ldr	r3, [r7, #0]
 8012e12:	7bdb      	ldrb	r3, [r3, #15]
 8012e14:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8012e18:	b2db      	uxtb	r3, r3
 8012e1a:	2b00      	cmp	r3, #0
 8012e1c:	bf14      	ite	ne
 8012e1e:	2301      	movne	r3, #1
 8012e20:	2300      	moveq	r3, #0
 8012e22:	b2db      	uxtb	r3, r3
 8012e24:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

                _lv_img_buf_transform_init(&trans_dsc);
 8012e28:	f107 0310 	add.w	r3, r7, #16
 8012e2c:	4618      	mov	r0, r3
 8012e2e:	f008 fdd5 	bl	801b9dc <_lv_img_buf_transform_init>
            }
#endif
            uint16_t recolor_premult[3] = {0};
 8012e32:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8012e36:	2200      	movs	r2, #0
 8012e38:	601a      	str	r2, [r3, #0]
 8012e3a:	809a      	strh	r2, [r3, #4]
            lv_opa_t recolor_opa_inv = 255 - draw_dsc->recolor_opa;
 8012e3c:	683b      	ldr	r3, [r7, #0]
 8012e3e:	7a9b      	ldrb	r3, [r3, #10]
 8012e40:	43db      	mvns	r3, r3
 8012e42:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
            if(draw_dsc->recolor_opa != 0) {
 8012e46:	683b      	ldr	r3, [r7, #0]
 8012e48:	7a9b      	ldrb	r3, [r3, #10]
 8012e4a:	2b00      	cmp	r3, #0
 8012e4c:	d007      	beq.n	8012e5e <lv_draw_map+0x56e>
                lv_color_premult(draw_dsc->recolor, draw_dsc->recolor_opa, recolor_premult);
 8012e4e:	683b      	ldr	r3, [r7, #0]
 8012e50:	7a99      	ldrb	r1, [r3, #10]
 8012e52:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 8012e56:	683b      	ldr	r3, [r7, #0]
 8012e58:	8998      	ldrh	r0, [r3, #12]
 8012e5a:	f7ff f874 	bl	8011f46 <lv_color_premult>
            }

            lv_draw_mask_res_t mask_res;
            mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
 8012e5e:	f897 3104 	ldrb.w	r3, [r7, #260]	; 0x104
 8012e62:	2b00      	cmp	r3, #0
 8012e64:	d10c      	bne.n	8012e80 <lv_draw_map+0x590>
 8012e66:	f897 3100 	ldrb.w	r3, [r7, #256]	; 0x100
 8012e6a:	2b00      	cmp	r3, #0
 8012e6c:	d108      	bne.n	8012e80 <lv_draw_map+0x590>
 8012e6e:	683b      	ldr	r3, [r7, #0]
 8012e70:	885b      	ldrh	r3, [r3, #2]
 8012e72:	2b00      	cmp	r3, #0
 8012e74:	d104      	bne.n	8012e80 <lv_draw_map+0x590>
                        draw_dsc->zoom != LV_IMG_ZOOM_NONE) ? LV_DRAW_MASK_RES_CHANGED : LV_DRAW_MASK_RES_FULL_COVER;
 8012e76:	683b      	ldr	r3, [r7, #0]
 8012e78:	891b      	ldrh	r3, [r3, #8]
            mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
 8012e7a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8012e7e:	d001      	beq.n	8012e84 <lv_draw_map+0x594>
 8012e80:	2302      	movs	r3, #2
 8012e82:	e000      	b.n	8012e86 <lv_draw_map+0x596>
 8012e84:	2301      	movs	r3, #1
 8012e86:	f887 30d2 	strb.w	r3, [r7, #210]	; 0xd2


            /*Prepare the `mask_buf`if there are other masks*/
            if(other_mask_cnt) {
 8012e8a:	f897 30bb 	ldrb.w	r3, [r7, #187]	; 0xbb
 8012e8e:	2b00      	cmp	r3, #0
 8012e90:	d005      	beq.n	8012e9e <lv_draw_map+0x5ae>
                _lv_memset_ff(mask_buf, mask_buf_size);
 8012e92:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
 8012e96:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 8012e9a:	f00e fc86 	bl	80217aa <_lv_memset_ff>
            }

            int32_t x;
            int32_t y;
#if LV_USE_IMG_TRANSFORM
            int32_t rot_y = disp_area->y1 + draw_area.y1 - map_area->y1;
 8012e9e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8012ea2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8012ea6:	461a      	mov	r2, r3
 8012ea8:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8012eac:	4413      	add	r3, r2
 8012eae:	68fa      	ldr	r2, [r7, #12]
 8012eb0:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 8012eb4:	1a9b      	subs	r3, r3, r2
 8012eb6:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
#endif
            for(y = 0; y < draw_area_h; y++) {
 8012eba:	2300      	movs	r3, #0
 8012ebc:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 8012ec0:	e17b      	b.n	80131ba <lv_draw_map+0x8ca>
                map_px = map_buf_tmp;
 8012ec2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8012ec6:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
                uint32_t px_i_start = px_i;
 8012eca:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8012ece:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

#if LV_USE_IMG_TRANSFORM
                int32_t rot_x = disp_area->x1 + draw_area.x1 - map_area->x1;
 8012ed2:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8012ed6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8012eda:	461a      	mov	r2, r3
 8012edc:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8012ee0:	4413      	add	r3, r2
 8012ee2:	68fa      	ldr	r2, [r7, #12]
 8012ee4:	f9b2 2000 	ldrsh.w	r2, [r2]
 8012ee8:	1a9b      	subs	r3, r3, r2
 8012eea:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
#endif
                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {
 8012eee:	2300      	movs	r3, #0
 8012ef0:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 8012ef4:	e0a1      	b.n	801303a <lv_draw_map+0x74a>


#if LV_USE_IMG_TRANSFORM
                    if(transform) {
 8012ef6:	f897 30af 	ldrb.w	r3, [r7, #175]	; 0xaf
 8012efa:	2b00      	cmp	r3, #0
 8012efc:	d034      	beq.n	8012f68 <lv_draw_map+0x678>

                        /*Transform*/
                        bool ret;
                        ret = _lv_img_buf_transform(&trans_dsc, rot_x + x, rot_y + y);
 8012efe:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8012f02:	b29a      	uxth	r2, r3
 8012f04:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8012f08:	b29b      	uxth	r3, r3
 8012f0a:	4413      	add	r3, r2
 8012f0c:	b29b      	uxth	r3, r3
 8012f0e:	b219      	sxth	r1, r3
 8012f10:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8012f14:	b29a      	uxth	r2, r3
 8012f16:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8012f1a:	b29b      	uxth	r3, r3
 8012f1c:	4413      	add	r3, r2
 8012f1e:	b29b      	uxth	r3, r3
 8012f20:	b21a      	sxth	r2, r3
 8012f22:	f107 0310 	add.w	r3, r7, #16
 8012f26:	4618      	mov	r0, r3
 8012f28:	f7ff f8ff 	bl	801212a <_lv_img_buf_transform>
 8012f2c:	4603      	mov	r3, r0
 8012f2e:	f887 307d 	strb.w	r3, [r7, #125]	; 0x7d
                        if(ret == false) {
 8012f32:	f897 307d 	ldrb.w	r3, [r7, #125]	; 0x7d
 8012f36:	f083 0301 	eor.w	r3, r3, #1
 8012f3a:	b2db      	uxtb	r3, r3
 8012f3c:	2b00      	cmp	r3, #0
 8012f3e:	d007      	beq.n	8012f50 <lv_draw_map+0x660>
                            mask_buf[px_i] = LV_OPA_TRANSP;
 8012f40:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8012f44:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8012f48:	4413      	add	r3, r2
 8012f4a:	2200      	movs	r2, #0
 8012f4c:	701a      	strb	r2, [r3, #0]
                            continue;
 8012f4e:	e063      	b.n	8013018 <lv_draw_map+0x728>
                        }
                        else {
                            mask_buf[px_i] = trans_dsc.res.opa;
 8012f50:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8012f54:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8012f58:	4413      	add	r3, r2
 8012f5a:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 8012f5e:	701a      	strb	r2, [r3, #0]
                            c.full = trans_dsc.res.color.full;
 8012f60:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8012f62:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
 8012f66:	e03e      	b.n	8012fe6 <lv_draw_map+0x6f6>
                    }
                    /*No transform*/
                    else
#endif
                    {
                        if(alpha_byte) {
 8012f68:	f897 3104 	ldrb.w	r3, [r7, #260]	; 0x104
 8012f6c:	2b00      	cmp	r3, #0
 8012f6e:	d012      	beq.n	8012f96 <lv_draw_map+0x6a6>
                            lv_opa_t px_opa = map_px[LV_IMG_PX_SIZE_ALPHA_BYTE - 1];
 8012f70:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8012f74:	3302      	adds	r3, #2
 8012f76:	781b      	ldrb	r3, [r3, #0]
 8012f78:	f887 307e 	strb.w	r3, [r7, #126]	; 0x7e
                            mask_buf[px_i] = px_opa;
 8012f7c:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8012f80:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8012f84:	4413      	add	r3, r2
 8012f86:	f897 207e 	ldrb.w	r2, [r7, #126]	; 0x7e
 8012f8a:	701a      	strb	r2, [r3, #0]
                            if(px_opa == 0) {
 8012f8c:	f897 307e 	ldrb.w	r3, [r7, #126]	; 0x7e
 8012f90:	2b00      	cmp	r3, #0
 8012f92:	d107      	bne.n	8012fa4 <lv_draw_map+0x6b4>
#if  LV_COLOR_DEPTH == 32
                                map2[px_i].full = 0;
#endif
                                continue;
 8012f94:	e040      	b.n	8013018 <lv_draw_map+0x728>
                            }
                        }
                        else {
                            mask_buf[px_i] = 0xFF;
 8012f96:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8012f9a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8012f9e:	4413      	add	r3, r2
 8012fa0:	22ff      	movs	r2, #255	; 0xff
 8012fa2:	701a      	strb	r2, [r3, #0]
#if LV_COLOR_DEPTH == 1
                        c.full = map_px[0];
#elif LV_COLOR_DEPTH == 8
                        c.full =  map_px[0];
#elif LV_COLOR_DEPTH == 16
                        c.full =  map_px[0] + (map_px[1] << 8);
 8012fa4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8012fa8:	781b      	ldrb	r3, [r3, #0]
 8012faa:	b29a      	uxth	r2, r3
 8012fac:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8012fb0:	3301      	adds	r3, #1
 8012fb2:	781b      	ldrb	r3, [r3, #0]
 8012fb4:	b29b      	uxth	r3, r3
 8012fb6:	021b      	lsls	r3, r3, #8
 8012fb8:	b29b      	uxth	r3, r3
 8012fba:	4413      	add	r3, r2
 8012fbc:	b29b      	uxth	r3, r3
 8012fbe:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
#elif LV_COLOR_DEPTH == 32
                        c.full =  *((uint32_t *)map_px);
                        c.ch.alpha = 0xFF;
#endif
                        if(chroma_key) {
 8012fc2:	f897 3100 	ldrb.w	r3, [r7, #256]	; 0x100
 8012fc6:	2b00      	cmp	r3, #0
 8012fc8:	d00d      	beq.n	8012fe6 <lv_draw_map+0x6f6>
                            if(c.full == chroma_keyed_color.full) {
 8012fca:	f8b7 2070 	ldrh.w	r2, [r7, #112]	; 0x70
 8012fce:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 8012fd2:	429a      	cmp	r2, r3
 8012fd4:	d107      	bne.n	8012fe6 <lv_draw_map+0x6f6>
                                mask_buf[px_i] = LV_OPA_TRANSP;
 8012fd6:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8012fda:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8012fde:	4413      	add	r3, r2
 8012fe0:	2200      	movs	r2, #0
 8012fe2:	701a      	strb	r2, [r3, #0]
#if  LV_COLOR_DEPTH == 32
                                map2[px_i].full = 0;
#endif
                                continue;
 8012fe4:	e018      	b.n	8013018 <lv_draw_map+0x728>
                            }
                        }
                    }

                    if(draw_dsc->recolor_opa != 0) {
 8012fe6:	683b      	ldr	r3, [r7, #0]
 8012fe8:	7a9b      	ldrb	r3, [r3, #10]
 8012fea:	2b00      	cmp	r3, #0
 8012fec:	d00b      	beq.n	8013006 <lv_draw_map+0x716>
                        c = lv_color_mix_premult(recolor_premult, c, recolor_opa_inv);
 8012fee:	f897 208f 	ldrb.w	r2, [r7, #143]	; 0x8f
 8012ff2:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8012ff6:	f8b7 1070 	ldrh.w	r1, [r7, #112]	; 0x70
 8012ffa:	4618      	mov	r0, r3
 8012ffc:	f7fe ffd6 	bl	8011fac <lv_color_mix_premult>
 8013000:	4603      	mov	r3, r0
 8013002:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
                    }

                    map2[px_i].full = c.full;
 8013006:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 801300a:	005b      	lsls	r3, r3, #1
 801300c:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8013010:	4413      	add	r3, r2
 8013012:	f8b7 2070 	ldrh.w	r2, [r7, #112]	; 0x70
 8013016:	801a      	strh	r2, [r3, #0]
                for(x = 0; x < draw_area_w; x++, map_px += px_size_byte, px_i++) {
 8013018:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 801301c:	3301      	adds	r3, #1
 801301e:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
 8013022:	f897 30ba 	ldrb.w	r3, [r7, #186]	; 0xba
 8013026:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 801302a:	4413      	add	r3, r2
 801302c:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
 8013030:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8013034:	3301      	adds	r3, #1
 8013036:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 801303a:	f9b7 30b0 	ldrsh.w	r3, [r7, #176]	; 0xb0
 801303e:	f8d7 20cc 	ldr.w	r2, [r7, #204]	; 0xcc
 8013042:	429a      	cmp	r2, r3
 8013044:	f6ff af57 	blt.w	8012ef6 <lv_draw_map+0x606>
                }

                /*Apply the masks if any*/
                if(other_mask_cnt) {
 8013048:	f897 30bb 	ldrb.w	r3, [r7, #187]	; 0xbb
 801304c:	2b00      	cmp	r3, #0
 801304e:	d04b      	beq.n	80130e8 <lv_draw_map+0x7f8>
                    lv_draw_mask_res_t mask_res_sub;
                    mask_res_sub = lv_draw_mask_apply(mask_buf + px_i_start, draw_area.x1 + vdb->area.x1, y + draw_area.y1 + vdb->area.y1,
 8013050:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8013054:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8013058:	18d4      	adds	r4, r2, r3
 801305a:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 801305e:	b29a      	uxth	r2, r3
 8013060:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8013064:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8013068:	b29b      	uxth	r3, r3
 801306a:	4413      	add	r3, r2
 801306c:	b29b      	uxth	r3, r3
 801306e:	b21d      	sxth	r5, r3
 8013070:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8013074:	b29a      	uxth	r2, r3
 8013076:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 801307a:	b29b      	uxth	r3, r3
 801307c:	4413      	add	r3, r2
 801307e:	b29a      	uxth	r2, r3
 8013080:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8013084:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8013088:	b29b      	uxth	r3, r3
 801308a:	4413      	add	r3, r2
 801308c:	b29b      	uxth	r3, r3
 801308e:	b21e      	sxth	r6, r3
 8013090:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8013094:	4618      	mov	r0, r3
 8013096:	f7ff f81a 	bl	80120ce <lv_area_get_width>
 801309a:	4603      	mov	r3, r0
 801309c:	4632      	mov	r2, r6
 801309e:	4629      	mov	r1, r5
 80130a0:	4620      	mov	r0, r4
 80130a2:	f002 ff87 	bl	8015fb4 <lv_draw_mask_apply>
 80130a6:	4603      	mov	r3, r0
 80130a8:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
                                                      lv_area_get_width(&draw_area));
                    if(mask_res_sub == LV_DRAW_MASK_RES_TRANSP) {
 80130ac:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
 80130b0:	2b00      	cmp	r3, #0
 80130b2:	d112      	bne.n	80130da <lv_draw_map+0x7ea>
                        _lv_memset_00(mask_buf + px_i_start, lv_area_get_width(&draw_area));
 80130b4:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 80130b8:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80130bc:	18d4      	adds	r4, r2, r3
 80130be:	f107 0374 	add.w	r3, r7, #116	; 0x74
 80130c2:	4618      	mov	r0, r3
 80130c4:	f7ff f803 	bl	80120ce <lv_area_get_width>
 80130c8:	4603      	mov	r3, r0
 80130ca:	4619      	mov	r1, r3
 80130cc:	4620      	mov	r0, r4
 80130ce:	f00e faeb 	bl	80216a8 <_lv_memset_00>
                        mask_res = LV_DRAW_MASK_RES_CHANGED;
 80130d2:	2302      	movs	r3, #2
 80130d4:	f887 30d2 	strb.w	r3, [r7, #210]	; 0xd2
 80130d8:	e006      	b.n	80130e8 <lv_draw_map+0x7f8>
                    }
                    else if(mask_res_sub == LV_DRAW_MASK_RES_CHANGED) {
 80130da:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
 80130de:	2b02      	cmp	r3, #2
 80130e0:	d102      	bne.n	80130e8 <lv_draw_map+0x7f8>
                        mask_res = LV_DRAW_MASK_RES_CHANGED;
 80130e2:	2302      	movs	r3, #2
 80130e4:	f887 30d2 	strb.w	r3, [r7, #210]	; 0xd2
                    }
                }

                map_buf_tmp += map_w * px_size_byte;
 80130e8:	f897 30ba 	ldrb.w	r3, [r7, #186]	; 0xba
 80130ec:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 80130f0:	fb02 f303 	mul.w	r3, r2, r3
 80130f4:	461a      	mov	r2, r3
 80130f6:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 80130fa:	4413      	add	r3, r2
 80130fc:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
                if(px_i + lv_area_get_width(&draw_area) < mask_buf_size) {
 8013100:	f107 0374 	add.w	r3, r7, #116	; 0x74
 8013104:	4618      	mov	r0, r3
 8013106:	f7fe ffe2 	bl	80120ce <lv_area_get_width>
 801310a:	4603      	mov	r3, r0
 801310c:	461a      	mov	r2, r3
 801310e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8013112:	4413      	add	r3, r2
 8013114:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8013118:	429a      	cmp	r2, r3
 801311a:	d908      	bls.n	801312e <lv_draw_map+0x83e>
                    blend_area.y2 ++;
 801311c:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8013120:	b29b      	uxth	r3, r3
 8013122:	3301      	adds	r3, #1
 8013124:	b29b      	uxth	r3, r3
 8013126:	b21b      	sxth	r3, r3
 8013128:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 801312c:	e040      	b.n	80131b0 <lv_draw_map+0x8c0>
                }
                else {

                    _lv_blend_map(clip_area, &blend_area, map2, mask_buf, mask_res, draw_dsc->opa, draw_dsc->blend_mode);
 801312e:	683b      	ldr	r3, [r7, #0]
 8013130:	781b      	ldrb	r3, [r3, #0]
 8013132:	683a      	ldr	r2, [r7, #0]
 8013134:	7b92      	ldrb	r2, [r2, #14]
 8013136:	f107 0164 	add.w	r1, r7, #100	; 0x64
 801313a:	9202      	str	r2, [sp, #8]
 801313c:	9301      	str	r3, [sp, #4]
 801313e:	f897 30d2 	ldrb.w	r3, [r7, #210]	; 0xd2
 8013142:	9300      	str	r3, [sp, #0]
 8013144:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8013148:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 801314c:	68b8      	ldr	r0, [r7, #8]
 801314e:	f7fd fc51 	bl	80109f4 <_lv_blend_map>

                    blend_area.y1 = blend_area.y2 + 1;
 8013152:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8013156:	b29b      	uxth	r3, r3
 8013158:	3301      	adds	r3, #1
 801315a:	b29b      	uxth	r3, r3
 801315c:	b21b      	sxth	r3, r3
 801315e:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
                    blend_area.y2 = blend_area.y1;
 8013162:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 8013166:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a

                    px_i = 0;
 801316a:	2300      	movs	r3, #0
 801316c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
                    mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
 8013170:	f897 3104 	ldrb.w	r3, [r7, #260]	; 0x104
 8013174:	2b00      	cmp	r3, #0
 8013176:	d10c      	bne.n	8013192 <lv_draw_map+0x8a2>
 8013178:	f897 3100 	ldrb.w	r3, [r7, #256]	; 0x100
 801317c:	2b00      	cmp	r3, #0
 801317e:	d108      	bne.n	8013192 <lv_draw_map+0x8a2>
 8013180:	683b      	ldr	r3, [r7, #0]
 8013182:	885b      	ldrh	r3, [r3, #2]
 8013184:	2b00      	cmp	r3, #0
 8013186:	d104      	bne.n	8013192 <lv_draw_map+0x8a2>
                                draw_dsc->zoom != LV_IMG_ZOOM_NONE) ? LV_DRAW_MASK_RES_CHANGED : LV_DRAW_MASK_RES_FULL_COVER;
 8013188:	683b      	ldr	r3, [r7, #0]
 801318a:	891b      	ldrh	r3, [r3, #8]
                    mask_res = (alpha_byte || chroma_key || draw_dsc->angle ||
 801318c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8013190:	d001      	beq.n	8013196 <lv_draw_map+0x8a6>
 8013192:	2302      	movs	r3, #2
 8013194:	e000      	b.n	8013198 <lv_draw_map+0x8a8>
 8013196:	2301      	movs	r3, #1
 8013198:	f887 30d2 	strb.w	r3, [r7, #210]	; 0xd2

                    /*Prepare the `mask_buf`if there are other masks*/
                    if(other_mask_cnt) {
 801319c:	f897 30bb 	ldrb.w	r3, [r7, #187]	; 0xbb
 80131a0:	2b00      	cmp	r3, #0
 80131a2:	d005      	beq.n	80131b0 <lv_draw_map+0x8c0>
                        _lv_memset_ff(mask_buf, mask_buf_size);
 80131a4:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
 80131a8:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 80131ac:	f00e fafd 	bl	80217aa <_lv_memset_ff>
            for(y = 0; y < draw_area_h; y++) {
 80131b0:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80131b4:	3301      	adds	r3, #1
 80131b6:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 80131ba:	f9b7 30b2 	ldrsh.w	r3, [r7, #178]	; 0xb2
 80131be:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 80131c2:	429a      	cmp	r2, r3
 80131c4:	f6ff ae7d 	blt.w	8012ec2 <lv_draw_map+0x5d2>
                    }
                }
            }

            /*Flush the last part*/
            if(blend_area.y1 != blend_area.y2) {
 80131c8:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 80131cc:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 80131d0:	429a      	cmp	r2, r3
 80131d2:	d019      	beq.n	8013208 <lv_draw_map+0x918>
                blend_area.y2--;
 80131d4:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 80131d8:	b29b      	uxth	r3, r3
 80131da:	3b01      	subs	r3, #1
 80131dc:	b29b      	uxth	r3, r3
 80131de:	b21b      	sxth	r3, r3
 80131e0:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
                _lv_blend_map(clip_area, &blend_area, map2, mask_buf, mask_res, draw_dsc->opa, draw_dsc->blend_mode);
 80131e4:	683b      	ldr	r3, [r7, #0]
 80131e6:	781b      	ldrb	r3, [r3, #0]
 80131e8:	683a      	ldr	r2, [r7, #0]
 80131ea:	7b92      	ldrb	r2, [r2, #14]
 80131ec:	f107 0164 	add.w	r1, r7, #100	; 0x64
 80131f0:	9202      	str	r2, [sp, #8]
 80131f2:	9301      	str	r3, [sp, #4]
 80131f4:	f897 30d2 	ldrb.w	r3, [r7, #210]	; 0xd2
 80131f8:	9300      	str	r3, [sp, #0]
 80131fa:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80131fe:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8013202:	68b8      	ldr	r0, [r7, #8]
 8013204:	f7fd fbf6 	bl	80109f4 <_lv_blend_map>
            }

            _lv_mem_buf_release(mask_buf);
 8013208:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 801320c:	f00d ff20 	bl	8021050 <_lv_mem_buf_release>
            _lv_mem_buf_release(map2);
 8013210:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
 8013214:	f00d ff1c 	bl	8021050 <_lv_mem_buf_release>
        }
    }
}
 8013218:	bf00      	nop
 801321a:	bf00      	nop
 801321c:	37ec      	adds	r7, #236	; 0xec
 801321e:	46bd      	mov	sp, r7
 8013220:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08013224 <show_error>:

static void show_error(const lv_area_t * coords, const lv_area_t * clip_area, const char * msg)
{
 8013224:	b580      	push	{r7, lr}
 8013226:	b0a4      	sub	sp, #144	; 0x90
 8013228:	af02      	add	r7, sp, #8
 801322a:	60f8      	str	r0, [r7, #12]
 801322c:	60b9      	str	r1, [r7, #8]
 801322e:	607a      	str	r2, [r7, #4]
    lv_draw_rect_dsc_t rect_dsc;
    lv_draw_rect_dsc_init(&rect_dsc);
 8013230:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8013234:	4618      	mov	r0, r3
 8013236:	f004 fae5 	bl	8017804 <lv_draw_rect_dsc_init>
    rect_dsc.bg_color = LV_COLOR_WHITE;
 801323a:	4b0e      	ldr	r3, [pc, #56]	; (8013274 <show_error+0x50>)
 801323c:	881b      	ldrh	r3, [r3, #0]
 801323e:	86fb      	strh	r3, [r7, #54]	; 0x36
    lv_draw_rect(coords, clip_area, &rect_dsc);
 8013240:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8013244:	461a      	mov	r2, r3
 8013246:	68b9      	ldr	r1, [r7, #8]
 8013248:	68f8      	ldr	r0, [r7, #12]
 801324a:	f004 fb69 	bl	8017920 <lv_draw_rect>

    lv_draw_label_dsc_t label_dsc;
    lv_draw_label_dsc_init(&label_dsc);
 801324e:	f107 0314 	add.w	r3, r7, #20
 8013252:	4618      	mov	r0, r3
 8013254:	f000 f880 	bl	8013358 <lv_draw_label_dsc_init>
    lv_draw_label(coords, clip_area, &label_dsc, msg, NULL);
 8013258:	f107 0214 	add.w	r2, r7, #20
 801325c:	2300      	movs	r3, #0
 801325e:	9300      	str	r3, [sp, #0]
 8013260:	687b      	ldr	r3, [r7, #4]
 8013262:	68b9      	ldr	r1, [r7, #8]
 8013264:	68f8      	ldr	r0, [r7, #12]
 8013266:	f000 f8b5 	bl	80133d4 <lv_draw_label>
}
 801326a:	bf00      	nop
 801326c:	3788      	adds	r7, #136	; 0x88
 801326e:	46bd      	mov	sp, r7
 8013270:	bd80      	pop	{r7, pc}
 8013272:	bf00      	nop
 8013274:	0802e460 	.word	0x0802e460

08013278 <_lv_memcpy_small>:
{
 8013278:	b480      	push	{r7}
 801327a:	b087      	sub	sp, #28
 801327c:	af00      	add	r7, sp, #0
 801327e:	60f8      	str	r0, [r7, #12]
 8013280:	60b9      	str	r1, [r7, #8]
 8013282:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 8013284:	68fb      	ldr	r3, [r7, #12]
 8013286:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 8013288:	68bb      	ldr	r3, [r7, #8]
 801328a:	613b      	str	r3, [r7, #16]
    while(len) {
 801328c:	e00c      	b.n	80132a8 <_lv_memcpy_small+0x30>
        *d8 = *s8;
 801328e:	693b      	ldr	r3, [r7, #16]
 8013290:	781a      	ldrb	r2, [r3, #0]
 8013292:	697b      	ldr	r3, [r7, #20]
 8013294:	701a      	strb	r2, [r3, #0]
        d8++;
 8013296:	697b      	ldr	r3, [r7, #20]
 8013298:	3301      	adds	r3, #1
 801329a:	617b      	str	r3, [r7, #20]
        s8++;
 801329c:	693b      	ldr	r3, [r7, #16]
 801329e:	3301      	adds	r3, #1
 80132a0:	613b      	str	r3, [r7, #16]
        len--;
 80132a2:	687b      	ldr	r3, [r7, #4]
 80132a4:	3b01      	subs	r3, #1
 80132a6:	607b      	str	r3, [r7, #4]
    while(len) {
 80132a8:	687b      	ldr	r3, [r7, #4]
 80132aa:	2b00      	cmp	r3, #0
 80132ac:	d1ef      	bne.n	801328e <_lv_memcpy_small+0x16>
    return dst;
 80132ae:	68fb      	ldr	r3, [r7, #12]
}
 80132b0:	4618      	mov	r0, r3
 80132b2:	371c      	adds	r7, #28
 80132b4:	46bd      	mov	sp, r7
 80132b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80132ba:	4770      	bx	lr

080132bc <lv_area_get_width>:
{
 80132bc:	b480      	push	{r7}
 80132be:	b083      	sub	sp, #12
 80132c0:	af00      	add	r7, sp, #0
 80132c2:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 80132c4:	687b      	ldr	r3, [r7, #4]
 80132c6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80132ca:	b29a      	uxth	r2, r3
 80132cc:	687b      	ldr	r3, [r7, #4]
 80132ce:	f9b3 3000 	ldrsh.w	r3, [r3]
 80132d2:	b29b      	uxth	r3, r3
 80132d4:	1ad3      	subs	r3, r2, r3
 80132d6:	b29b      	uxth	r3, r3
 80132d8:	3301      	adds	r3, #1
 80132da:	b29b      	uxth	r3, r3
 80132dc:	b21b      	sxth	r3, r3
}
 80132de:	4618      	mov	r0, r3
 80132e0:	370c      	adds	r7, #12
 80132e2:	46bd      	mov	sp, r7
 80132e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80132e8:	4770      	bx	lr

080132ea <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline lv_coord_t lv_font_get_line_height(const lv_font_t * font_p)
{
 80132ea:	b480      	push	{r7}
 80132ec:	b083      	sub	sp, #12
 80132ee:	af00      	add	r7, sp, #0
 80132f0:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 80132f2:	687b      	ldr	r3, [r7, #4]
 80132f4:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
}
 80132f8:	4618      	mov	r0, r3
 80132fa:	370c      	adds	r7, #12
 80132fc:	46bd      	mov	sp, r7
 80132fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013302:	4770      	bx	lr

08013304 <lv_color_make>:
#elif LV_COLOR_DEPTH == 32
#define LV_COLOR_MAKE(r8, g8, b8) (_LV_COLOR_MAKE_TYPE_HELPER{{b8, g8, r8, 0xff}}) /*Fix 0xff alpha*/
#endif

static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
 8013304:	b490      	push	{r4, r7}
 8013306:	b082      	sub	sp, #8
 8013308:	af00      	add	r7, sp, #0
 801330a:	4604      	mov	r4, r0
 801330c:	4608      	mov	r0, r1
 801330e:	4611      	mov	r1, r2
 8013310:	4622      	mov	r2, r4
 8013312:	71fa      	strb	r2, [r7, #7]
 8013314:	4602      	mov	r2, r0
 8013316:	71ba      	strb	r2, [r7, #6]
 8013318:	460a      	mov	r2, r1
 801331a:	717a      	strb	r2, [r7, #5]
    return LV_COLOR_MAKE(r, g, b);
 801331c:	797a      	ldrb	r2, [r7, #5]
 801331e:	08d2      	lsrs	r2, r2, #3
 8013320:	b2d2      	uxtb	r2, r2
 8013322:	f002 021f 	and.w	r2, r2, #31
 8013326:	b2d0      	uxtb	r0, r2
 8013328:	79ba      	ldrb	r2, [r7, #6]
 801332a:	0892      	lsrs	r2, r2, #2
 801332c:	b2d2      	uxtb	r2, r2
 801332e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8013332:	b2d1      	uxtb	r1, r2
 8013334:	79fa      	ldrb	r2, [r7, #7]
 8013336:	08d2      	lsrs	r2, r2, #3
 8013338:	b2d2      	uxtb	r2, r2
 801333a:	f002 021f 	and.w	r2, r2, #31
 801333e:	b2d2      	uxtb	r2, r2
 8013340:	f360 0304 	bfi	r3, r0, #0, #5
 8013344:	f361 134a 	bfi	r3, r1, #5, #6
 8013348:	f362 23cf 	bfi	r3, r2, #11, #5
}
 801334c:	4618      	mov	r0, r3
 801334e:	3708      	adds	r7, #8
 8013350:	46bd      	mov	sp, r7
 8013352:	bc90      	pop	{r4, r7}
 8013354:	4770      	bx	lr
	...

08013358 <lv_draw_label_dsc_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

LV_ATTRIBUTE_FAST_MEM void lv_draw_label_dsc_init(lv_draw_label_dsc_t * dsc)
{
 8013358:	b580      	push	{r7, lr}
 801335a:	b082      	sub	sp, #8
 801335c:	af00      	add	r7, sp, #0
 801335e:	6078      	str	r0, [r7, #4]
    _lv_memset_00(dsc, sizeof(lv_draw_label_dsc_t));
 8013360:	2120      	movs	r1, #32
 8013362:	6878      	ldr	r0, [r7, #4]
 8013364:	f00e f9a0 	bl	80216a8 <_lv_memset_00>
    dsc->opa = LV_OPA_COVER;
 8013368:	687b      	ldr	r3, [r7, #4]
 801336a:	22ff      	movs	r2, #255	; 0xff
 801336c:	721a      	strb	r2, [r3, #8]
    dsc->color = LV_COLOR_BLACK;
 801336e:	687a      	ldr	r2, [r7, #4]
 8013370:	7813      	ldrb	r3, [r2, #0]
 8013372:	f36f 0304 	bfc	r3, #0, #5
 8013376:	7013      	strb	r3, [r2, #0]
 8013378:	687a      	ldr	r2, [r7, #4]
 801337a:	8813      	ldrh	r3, [r2, #0]
 801337c:	f36f 134a 	bfc	r3, #5, #6
 8013380:	8013      	strh	r3, [r2, #0]
 8013382:	687a      	ldr	r2, [r7, #4]
 8013384:	7853      	ldrb	r3, [r2, #1]
 8013386:	f36f 03c7 	bfc	r3, #3, #5
 801338a:	7053      	strb	r3, [r2, #1]
    dsc->font = LV_THEME_DEFAULT_FONT_NORMAL;
 801338c:	687b      	ldr	r3, [r7, #4]
 801338e:	4a10      	ldr	r2, [pc, #64]	; (80133d0 <lv_draw_label_dsc_init+0x78>)
 8013390:	605a      	str	r2, [r3, #4]
    dsc->sel_start = LV_DRAW_LABEL_NO_TXT_SEL;
 8013392:	687b      	ldr	r3, [r7, #4]
 8013394:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013398:	611a      	str	r2, [r3, #16]
    dsc->sel_end = LV_DRAW_LABEL_NO_TXT_SEL;
 801339a:	687b      	ldr	r3, [r7, #4]
 801339c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80133a0:	615a      	str	r2, [r3, #20]
    dsc->sel_color = LV_COLOR_BLUE;
 80133a2:	687a      	ldr	r2, [r7, #4]
 80133a4:	7893      	ldrb	r3, [r2, #2]
 80133a6:	f043 031f 	orr.w	r3, r3, #31
 80133aa:	7093      	strb	r3, [r2, #2]
 80133ac:	687a      	ldr	r2, [r7, #4]
 80133ae:	8853      	ldrh	r3, [r2, #2]
 80133b0:	f36f 134a 	bfc	r3, #5, #6
 80133b4:	8053      	strh	r3, [r2, #2]
 80133b6:	687a      	ldr	r2, [r7, #4]
 80133b8:	78d3      	ldrb	r3, [r2, #3]
 80133ba:	f36f 03c7 	bfc	r3, #3, #5
 80133be:	70d3      	strb	r3, [r2, #3]
    dsc->bidi_dir = LV_BIDI_DIR_LTR;
 80133c0:	687b      	ldr	r3, [r7, #4]
 80133c2:	2200      	movs	r2, #0
 80133c4:	771a      	strb	r2, [r3, #28]
}
 80133c6:	bf00      	nop
 80133c8:	3708      	adds	r7, #8
 80133ca:	46bd      	mov	sp, r7
 80133cc:	bd80      	pop	{r7, pc}
 80133ce:	bf00      	nop
 80133d0:	200001a8 	.word	0x200001a8

080133d4 <lv_draw_label>:
 */
LV_ATTRIBUTE_FAST_MEM void lv_draw_label(const lv_area_t * coords, const lv_area_t * mask,
                                         const lv_draw_label_dsc_t * dsc,
                                         const char * txt,
                                         lv_draw_label_hint_t * hint)
{
 80133d4:	b5b0      	push	{r4, r5, r7, lr}
 80133d6:	b0ca      	sub	sp, #296	; 0x128
 80133d8:	af04      	add	r7, sp, #16
 80133da:	f507 748c 	add.w	r4, r7, #280	; 0x118
 80133de:	f5a4 7486 	sub.w	r4, r4, #268	; 0x10c
 80133e2:	6020      	str	r0, [r4, #0]
 80133e4:	f507 708c 	add.w	r0, r7, #280	; 0x118
 80133e8:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
 80133ec:	6001      	str	r1, [r0, #0]
 80133ee:	f507 718c 	add.w	r1, r7, #280	; 0x118
 80133f2:	f5a1 718a 	sub.w	r1, r1, #276	; 0x114
 80133f6:	600a      	str	r2, [r1, #0]
 80133f8:	f507 728c 	add.w	r2, r7, #280	; 0x118
 80133fc:	f5a2 728c 	sub.w	r2, r2, #280	; 0x118
 8013400:	6013      	str	r3, [r2, #0]

    if(dsc->opa <= LV_OPA_MIN) return;
 8013402:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013406:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 801340a:	681b      	ldr	r3, [r3, #0]
 801340c:	7a1b      	ldrb	r3, [r3, #8]
 801340e:	2b02      	cmp	r3, #2
 8013410:	f240 85cd 	bls.w	8013fae <lv_draw_label+0xbda>
    const lv_font_t * font = dsc->font;
 8013414:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013418:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 801341c:	681b      	ldr	r3, [r3, #0]
 801341e:	685b      	ldr	r3, [r3, #4]
 8013420:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    int32_t w;

    /*No need to waste processor time if string is empty*/
    if(txt[0] == '\0')  return;
 8013424:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013428:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 801342c:	681b      	ldr	r3, [r3, #0]
 801342e:	781b      	ldrb	r3, [r3, #0]
 8013430:	2b00      	cmp	r3, #0
 8013432:	f000 85be 	beq.w	8013fb2 <lv_draw_label+0xbde>

    lv_area_t clipped_area;
    bool clip_ok = _lv_area_intersect(&clipped_area, coords, mask);
 8013436:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801343a:	f5a3 7288 	sub.w	r2, r3, #272	; 0x110
 801343e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013442:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8013446:	f107 00a8 	add.w	r0, r7, #168	; 0xa8
 801344a:	6812      	ldr	r2, [r2, #0]
 801344c:	6819      	ldr	r1, [r3, #0]
 801344e:	f00c f80d 	bl	801f46c <_lv_area_intersect>
 8013452:	4603      	mov	r3, r0
 8013454:	f887 30ef 	strb.w	r3, [r7, #239]	; 0xef
    if(!clip_ok) return;
 8013458:	f897 30ef 	ldrb.w	r3, [r7, #239]	; 0xef
 801345c:	f083 0301 	eor.w	r3, r3, #1
 8013460:	b2db      	uxtb	r3, r3
 8013462:	2b00      	cmp	r3, #0
 8013464:	f040 85a7 	bne.w	8013fb6 <lv_draw_label+0xbe2>


    if((dsc->flag & LV_TXT_FLAG_EXPAND) == 0) {
 8013468:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801346c:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013470:	681b      	ldr	r3, [r3, #0]
 8013472:	7f5b      	ldrb	r3, [r3, #29]
 8013474:	f003 0302 	and.w	r3, r3, #2
 8013478:	2b00      	cmp	r3, #0
 801347a:	d10a      	bne.n	8013492 <lv_draw_label+0xbe>
        /*Normally use the label's width as width*/
        w = lv_area_get_width(coords);
 801347c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013480:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8013484:	6818      	ldr	r0, [r3, #0]
 8013486:	f7ff ff19 	bl	80132bc <lv_area_get_width>
 801348a:	4603      	mov	r3, r0
 801348c:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
 8013490:	e02d      	b.n	80134ee <lv_draw_label+0x11a>
    }
    else {
        /*If EXAPND is enabled then not limit the text's width to the object's width*/
        lv_point_t p;
        _lv_txt_get_size(&p, txt, dsc->font, dsc->letter_space, dsc->line_space, LV_COORD_MAX,
 8013492:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013496:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 801349a:	681b      	ldr	r3, [r3, #0]
 801349c:	685c      	ldr	r4, [r3, #4]
 801349e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80134a2:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80134a6:	681b      	ldr	r3, [r3, #0]
 80134a8:	f9b3 500c 	ldrsh.w	r5, [r3, #12]
 80134ac:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80134b0:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80134b4:	681b      	ldr	r3, [r3, #0]
 80134b6:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
                         dsc->flag);
 80134ba:	f507 728c 	add.w	r2, r7, #280	; 0x118
 80134be:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 80134c2:	6812      	ldr	r2, [r2, #0]
 80134c4:	7f52      	ldrb	r2, [r2, #29]
        _lv_txt_get_size(&p, txt, dsc->font, dsc->letter_space, dsc->line_space, LV_COORD_MAX,
 80134c6:	f507 718c 	add.w	r1, r7, #280	; 0x118
 80134ca:	f5a1 718c 	sub.w	r1, r1, #280	; 0x118
 80134ce:	f107 0038 	add.w	r0, r7, #56	; 0x38
 80134d2:	9202      	str	r2, [sp, #8]
 80134d4:	f647 4218 	movw	r2, #31768	; 0x7c18
 80134d8:	9201      	str	r2, [sp, #4]
 80134da:	9300      	str	r3, [sp, #0]
 80134dc:	462b      	mov	r3, r5
 80134de:	4622      	mov	r2, r4
 80134e0:	6809      	ldr	r1, [r1, #0]
 80134e2:	f00e fdd3 	bl	802208c <_lv_txt_get_size>
        w = p.x;
 80134e6:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80134ea:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    }

    int32_t line_height_font = lv_font_get_line_height(font);
 80134ee:	f8d7 00f0 	ldr.w	r0, [r7, #240]	; 0xf0
 80134f2:	f7ff fefa 	bl	80132ea <lv_font_get_line_height>
 80134f6:	4603      	mov	r3, r0
 80134f8:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    int32_t line_height = line_height_font + dsc->line_space;
 80134fc:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013500:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013504:	681b      	ldr	r3, [r3, #0]
 8013506:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801350a:	461a      	mov	r2, r3
 801350c:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8013510:	4413      	add	r3, r2
 8013512:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4

    /*Init variables for the first line*/
    int32_t line_width = 0;
 8013516:	2300      	movs	r3, #0
 8013518:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    lv_point_t pos;
    pos.x = coords->x1;
 801351c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013520:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8013524:	681b      	ldr	r3, [r3, #0]
 8013526:	f9b3 3000 	ldrsh.w	r3, [r3]
 801352a:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
    pos.y = coords->y1;
 801352e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013532:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8013536:	681b      	ldr	r3, [r3, #0]
 8013538:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801353c:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6

    int32_t x_ofs = 0;
 8013540:	2300      	movs	r3, #0
 8013542:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    int32_t y_ofs = 0;
 8013546:	2300      	movs	r3, #0
 8013548:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    x_ofs = dsc->ofs_x;
 801354c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013550:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013554:	681b      	ldr	r3, [r3, #0]
 8013556:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 801355a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    y_ofs = dsc->ofs_y;
 801355e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013562:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013566:	681b      	ldr	r3, [r3, #0]
 8013568:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801356c:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
    pos.y += y_ofs;
 8013570:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 8013574:	b29a      	uxth	r2, r3
 8013576:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801357a:	b29b      	uxth	r3, r3
 801357c:	4413      	add	r3, r2
 801357e:	b29b      	uxth	r3, r3
 8013580:	b21b      	sxth	r3, r3
 8013582:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6

    uint32_t line_start     = 0;
 8013586:	2300      	movs	r3, #0
 8013588:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    int32_t last_line_start = -1;
 801358c:	f04f 33ff 	mov.w	r3, #4294967295
 8013590:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c

    /*Check the hint to use the cached info*/
    if(hint && y_ofs == 0 && coords->y1 < 0) {
 8013594:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8013598:	2b00      	cmp	r3, #0
 801359a:	d02c      	beq.n	80135f6 <lv_draw_label+0x222>
 801359c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 80135a0:	2b00      	cmp	r3, #0
 80135a2:	d128      	bne.n	80135f6 <lv_draw_label+0x222>
 80135a4:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80135a8:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 80135ac:	681b      	ldr	r3, [r3, #0]
 80135ae:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80135b2:	2b00      	cmp	r3, #0
 80135b4:	da1f      	bge.n	80135f6 <lv_draw_label+0x222>
        /*If the label changed too much recalculate the hint.*/
        if(LV_MATH_ABS(hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {
 80135b6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80135ba:	689b      	ldr	r3, [r3, #8]
 80135bc:	f507 728c 	add.w	r2, r7, #280	; 0x118
 80135c0:	f5a2 7286 	sub.w	r2, r2, #268	; 0x10c
 80135c4:	6812      	ldr	r2, [r2, #0]
 80135c6:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 80135ca:	1a9b      	subs	r3, r3, r2
 80135cc:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80135d0:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 80135d4:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 80135d8:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
 80135dc:	005b      	lsls	r3, r3, #1
 80135de:	429a      	cmp	r2, r3
 80135e0:	dd04      	ble.n	80135ec <lv_draw_label+0x218>
            hint->line_start = -1;
 80135e2:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80135e6:	f04f 32ff 	mov.w	r2, #4294967295
 80135ea:	601a      	str	r2, [r3, #0]
        }
        last_line_start = hint->line_start;
 80135ec:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80135f0:	681b      	ldr	r3, [r3, #0]
 80135f2:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    }

    /*Use the hint if it's valid*/
    if(hint && last_line_start >= 0) {
 80135f6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80135fa:	2b00      	cmp	r3, #0
 80135fc:	d013      	beq.n	8013626 <lv_draw_label+0x252>
 80135fe:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8013602:	2b00      	cmp	r3, #0
 8013604:	db0f      	blt.n	8013626 <lv_draw_label+0x252>
        line_start = last_line_start;
 8013606:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 801360a:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
        pos.y += hint->y;
 801360e:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 8013612:	b29a      	uxth	r2, r3
 8013614:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8013618:	685b      	ldr	r3, [r3, #4]
 801361a:	b29b      	uxth	r3, r3
 801361c:	4413      	add	r3, r2
 801361e:	b29b      	uxth	r3, r3
 8013620:	b21b      	sxth	r3, r3
 8013622:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6
    }

    uint32_t line_end = line_start + _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
 8013626:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801362a:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 801362e:	681a      	ldr	r2, [r3, #0]
 8013630:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013634:	18d0      	adds	r0, r2, r3
 8013636:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801363a:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 801363e:	681b      	ldr	r3, [r3, #0]
 8013640:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 8013644:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8013648:	b219      	sxth	r1, r3
 801364a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801364e:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013652:	681b      	ldr	r3, [r3, #0]
 8013654:	7f5b      	ldrb	r3, [r3, #29]
 8013656:	9300      	str	r3, [sp, #0]
 8013658:	460b      	mov	r3, r1
 801365a:	f8d7 10f0 	ldr.w	r1, [r7, #240]	; 0xf0
 801365e:	f00e feaf 	bl	80223c0 <_lv_txt_get_next_line>
 8013662:	4602      	mov	r2, r0
 8013664:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013668:	4413      	add	r3, r2
 801366a:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108

    /*Go the first visible line*/
    while(pos.y + line_height_font < mask->y1) {
 801366e:	e06a      	b.n	8013746 <lv_draw_label+0x372>
        /*Go to next line*/
        line_start = line_end;
 8013670:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8013674:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
 8013678:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801367c:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8013680:	681a      	ldr	r2, [r3, #0]
 8013682:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013686:	18d0      	adds	r0, r2, r3
 8013688:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801368c:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013690:	681b      	ldr	r3, [r3, #0]
 8013692:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 8013696:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 801369a:	b219      	sxth	r1, r3
 801369c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80136a0:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80136a4:	681b      	ldr	r3, [r3, #0]
 80136a6:	7f5b      	ldrb	r3, [r3, #29]
 80136a8:	9300      	str	r3, [sp, #0]
 80136aa:	460b      	mov	r3, r1
 80136ac:	f8d7 10f0 	ldr.w	r1, [r7, #240]	; 0xf0
 80136b0:	f00e fe86 	bl	80223c0 <_lv_txt_get_next_line>
 80136b4:	4602      	mov	r2, r0
 80136b6:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80136ba:	4413      	add	r3, r2
 80136bc:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
        pos.y += line_height;
 80136c0:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 80136c4:	b29a      	uxth	r2, r3
 80136c6:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 80136ca:	b29b      	uxth	r3, r3
 80136cc:	4413      	add	r3, r2
 80136ce:	b29b      	uxth	r3, r3
 80136d0:	b21b      	sxth	r3, r3
 80136d2:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6

        /*Save at the threshold coordinate*/
        if(hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && hint->line_start < 0) {
 80136d6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80136da:	2b00      	cmp	r3, #0
 80136dc:	d027      	beq.n	801372e <lv_draw_label+0x35a>
 80136de:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 80136e2:	f513 6f80 	cmn.w	r3, #1024	; 0x400
 80136e6:	db22      	blt.n	801372e <lv_draw_label+0x35a>
 80136e8:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80136ec:	681b      	ldr	r3, [r3, #0]
 80136ee:	2b00      	cmp	r3, #0
 80136f0:	da1d      	bge.n	801372e <lv_draw_label+0x35a>
            hint->line_start = line_start;
 80136f2:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 80136f6:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 80136fa:	601a      	str	r2, [r3, #0]
            hint->y          = pos.y - coords->y1;
 80136fc:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 8013700:	461a      	mov	r2, r3
 8013702:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013706:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 801370a:	681b      	ldr	r3, [r3, #0]
 801370c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8013710:	1ad2      	subs	r2, r2, r3
 8013712:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8013716:	605a      	str	r2, [r3, #4]
            hint->coord_y    = coords->y1;
 8013718:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801371c:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8013720:	681b      	ldr	r3, [r3, #0]
 8013722:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8013726:	461a      	mov	r2, r3
 8013728:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 801372c:	609a      	str	r2, [r3, #8]
        }

        if(txt[line_start] == '\0') return;
 801372e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013732:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8013736:	681a      	ldr	r2, [r3, #0]
 8013738:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 801373c:	4413      	add	r3, r2
 801373e:	781b      	ldrb	r3, [r3, #0]
 8013740:	2b00      	cmp	r3, #0
 8013742:	f000 843a 	beq.w	8013fba <lv_draw_label+0xbe6>
    while(pos.y + line_height_font < mask->y1) {
 8013746:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 801374a:	461a      	mov	r2, r3
 801374c:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8013750:	4413      	add	r3, r2
 8013752:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8013756:	f5a2 7288 	sub.w	r2, r2, #272	; 0x110
 801375a:	6812      	ldr	r2, [r2, #0]
 801375c:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 8013760:	4293      	cmp	r3, r2
 8013762:	db85      	blt.n	8013670 <lv_draw_label+0x29c>
    }

    /*Align to middle*/
    if(dsc->flag & LV_TXT_FLAG_CENTER) {
 8013764:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013768:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 801376c:	681b      	ldr	r3, [r3, #0]
 801376e:	7f5b      	ldrb	r3, [r3, #29]
 8013770:	f003 0304 	and.w	r3, r3, #4
 8013774:	2b00      	cmp	r3, #0
 8013776:	d03c      	beq.n	80137f2 <lv_draw_label+0x41e>
        line_width = _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
 8013778:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801377c:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8013780:	681a      	ldr	r2, [r3, #0]
 8013782:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013786:	18d0      	adds	r0, r2, r3
 8013788:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 801378c:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013790:	1ad1      	subs	r1, r2, r3
 8013792:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013796:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 801379a:	681b      	ldr	r3, [r3, #0]
 801379c:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 80137a0:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80137a4:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80137a8:	681b      	ldr	r3, [r3, #0]
 80137aa:	7f5b      	ldrb	r3, [r3, #29]
 80137ac:	9300      	str	r3, [sp, #0]
 80137ae:	4613      	mov	r3, r2
 80137b0:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
 80137b4:	f00e fec2 	bl	802253c <_lv_txt_get_width>
 80137b8:	4603      	mov	r3, r0
 80137ba:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

        pos.x += (lv_area_get_width(coords) - line_width) / 2;
 80137be:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80137c2:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 80137c6:	6818      	ldr	r0, [r3, #0]
 80137c8:	f7ff fd78 	bl	80132bc <lv_area_get_width>
 80137cc:	4603      	mov	r3, r0
 80137ce:	461a      	mov	r2, r3
 80137d0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 80137d4:	1ad3      	subs	r3, r2, r3
 80137d6:	0fda      	lsrs	r2, r3, #31
 80137d8:	4413      	add	r3, r2
 80137da:	105b      	asrs	r3, r3, #1
 80137dc:	4619      	mov	r1, r3
 80137de:	f9b7 30a4 	ldrsh.w	r3, [r7, #164]	; 0xa4
 80137e2:	b29a      	uxth	r2, r3
 80137e4:	b28b      	uxth	r3, r1
 80137e6:	4413      	add	r3, r2
 80137e8:	b29b      	uxth	r3, r3
 80137ea:	b21b      	sxth	r3, r3
 80137ec:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
 80137f0:	e041      	b.n	8013876 <lv_draw_label+0x4a2>

    }
    /*Align to the right*/
    else if(dsc->flag & LV_TXT_FLAG_RIGHT) {
 80137f2:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80137f6:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80137fa:	681b      	ldr	r3, [r3, #0]
 80137fc:	7f5b      	ldrb	r3, [r3, #29]
 80137fe:	f003 0308 	and.w	r3, r3, #8
 8013802:	2b00      	cmp	r3, #0
 8013804:	d037      	beq.n	8013876 <lv_draw_label+0x4a2>
        line_width = _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
 8013806:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801380a:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 801380e:	681a      	ldr	r2, [r3, #0]
 8013810:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013814:	18d0      	adds	r0, r2, r3
 8013816:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 801381a:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 801381e:	1ad1      	subs	r1, r2, r3
 8013820:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013824:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013828:	681b      	ldr	r3, [r3, #0]
 801382a:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 801382e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013832:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013836:	681b      	ldr	r3, [r3, #0]
 8013838:	7f5b      	ldrb	r3, [r3, #29]
 801383a:	9300      	str	r3, [sp, #0]
 801383c:	4613      	mov	r3, r2
 801383e:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
 8013842:	f00e fe7b 	bl	802253c <_lv_txt_get_width>
 8013846:	4603      	mov	r3, r0
 8013848:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
        pos.x += lv_area_get_width(coords) - line_width;
 801384c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013850:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8013854:	6818      	ldr	r0, [r3, #0]
 8013856:	f7ff fd31 	bl	80132bc <lv_area_get_width>
 801385a:	4603      	mov	r3, r0
 801385c:	461a      	mov	r2, r3
 801385e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8013862:	1ad3      	subs	r3, r2, r3
 8013864:	f9b7 20a4 	ldrsh.w	r2, [r7, #164]	; 0xa4
 8013868:	b292      	uxth	r2, r2
 801386a:	b29b      	uxth	r3, r3
 801386c:	4413      	add	r3, r2
 801386e:	b29b      	uxth	r3, r3
 8013870:	b21b      	sxth	r3, r3
 8013872:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
    }

    lv_opa_t opa = dsc->opa;
 8013876:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801387a:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 801387e:	681b      	ldr	r3, [r3, #0]
 8013880:	7a1b      	ldrb	r3, [r3, #8]
 8013882:	f887 30d7 	strb.w	r3, [r7, #215]	; 0xd7

    uint32_t sel_start = dsc->sel_start;
 8013886:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801388a:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 801388e:	681b      	ldr	r3, [r3, #0]
 8013890:	691b      	ldr	r3, [r3, #16]
 8013892:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    uint32_t sel_end = dsc->sel_end;
 8013896:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801389a:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 801389e:	681b      	ldr	r3, [r3, #0]
 80138a0:	695b      	ldr	r3, [r3, #20]
 80138a2:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    if(sel_start > sel_end) {
 80138a6:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 80138aa:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 80138ae:	429a      	cmp	r2, r3
 80138b0:	d90b      	bls.n	80138ca <lv_draw_label+0x4f6>
        uint32_t tmp = sel_start;
 80138b2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80138b6:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
        sel_start = sel_end;
 80138ba:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 80138be:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
        sel_end = tmp;
 80138c2:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80138c6:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    }
    lv_draw_line_dsc_t line_dsc;

    if((dsc->decor & LV_TEXT_DECOR_UNDERLINE) || (dsc->decor & LV_TEXT_DECOR_STRIKETHROUGH)) {
 80138ca:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80138ce:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80138d2:	681b      	ldr	r3, [r3, #0]
 80138d4:	7f9b      	ldrb	r3, [r3, #30]
 80138d6:	f003 0301 	and.w	r3, r3, #1
 80138da:	2b00      	cmp	r3, #0
 80138dc:	d109      	bne.n	80138f2 <lv_draw_label+0x51e>
 80138de:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80138e2:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80138e6:	681b      	ldr	r3, [r3, #0]
 80138e8:	7f9b      	ldrb	r3, [r3, #30]
 80138ea:	f003 0302 	and.w	r3, r3, #2
 80138ee:	2b00      	cmp	r3, #0
 80138f0:	d044      	beq.n	801397c <lv_draw_label+0x5a8>
        lv_draw_line_dsc_init(&line_dsc);
 80138f2:	f107 0398 	add.w	r3, r7, #152	; 0x98
 80138f6:	4618      	mov	r0, r3
 80138f8:	f001 f997 	bl	8014c2a <lv_draw_line_dsc_init>
        line_dsc.color = dsc->color;
 80138fc:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013900:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013904:	681b      	ldr	r3, [r3, #0]
 8013906:	881b      	ldrh	r3, [r3, #0]
 8013908:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98
        line_dsc.width = font->underline_thickness ? font->underline_thickness : LV_MATH_MAX(font->line_height / 10, 1);
 801390c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8013910:	f993 300e 	ldrsb.w	r3, [r3, #14]
 8013914:	2b00      	cmp	r3, #0
 8013916:	d005      	beq.n	8013924 <lv_draw_label+0x550>
 8013918:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 801391c:	f993 300e 	ldrsb.w	r3, [r3, #14]
 8013920:	b21b      	sxth	r3, r3
 8013922:	e012      	b.n	801394a <lv_draw_label+0x576>
 8013924:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8013928:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 801392c:	2b13      	cmp	r3, #19
 801392e:	dd0b      	ble.n	8013948 <lv_draw_label+0x574>
 8013930:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8013934:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8013938:	4a8f      	ldr	r2, [pc, #572]	; (8013b78 <lv_draw_label+0x7a4>)
 801393a:	fb82 1203 	smull	r1, r2, r2, r3
 801393e:	1092      	asrs	r2, r2, #2
 8013940:	17db      	asrs	r3, r3, #31
 8013942:	1ad3      	subs	r3, r2, r3
 8013944:	b21b      	sxth	r3, r3
 8013946:	e000      	b.n	801394a <lv_draw_label+0x576>
 8013948:	2301      	movs	r3, #1
 801394a:	f8a7 309a 	strh.w	r3, [r7, #154]	; 0x9a
        line_dsc.opa = dsc->opa;
 801394e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013952:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013956:	681b      	ldr	r3, [r3, #0]
 8013958:	7a1b      	ldrb	r3, [r3, #8]
 801395a:	f887 30a0 	strb.w	r3, [r7, #160]	; 0xa0
        line_dsc.blend_mode = dsc->blend_mode;
 801395e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013962:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013966:	681b      	ldr	r3, [r3, #0]
 8013968:	7fdb      	ldrb	r3, [r3, #31]
 801396a:	f003 0303 	and.w	r3, r3, #3
 801396e:	b2da      	uxtb	r2, r3
 8013970:	f897 30a1 	ldrb.w	r3, [r7, #161]	; 0xa1
 8013974:	f362 0301 	bfi	r3, r2, #0, #2
 8013978:	f887 30a1 	strb.w	r3, [r7, #161]	; 0xa1
    }

    cmd_state_t cmd_state = CMD_STATE_WAIT;
 801397c:	2300      	movs	r3, #0
 801397e:	f887 30ff 	strb.w	r3, [r7, #255]	; 0xff
    uint32_t i;
    uint32_t par_start = 0;
 8013982:	2300      	movs	r3, #0
 8013984:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
    lv_color_t recolor;
    int32_t letter_w;


    lv_draw_rect_dsc_t draw_dsc_sel;
    lv_draw_rect_dsc_init(&draw_dsc_sel);
 8013988:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801398c:	4618      	mov	r0, r3
 801398e:	f003 ff39 	bl	8017804 <lv_draw_rect_dsc_init>
    draw_dsc_sel.bg_color = dsc->sel_color;
 8013992:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013996:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 801399a:	681b      	ldr	r3, [r3, #0]
 801399c:	885b      	ldrh	r3, [r3, #2]
 801399e:	87fb      	strh	r3, [r7, #62]	; 0x3e

    int32_t pos_x_start = pos.x;
 80139a0:	f9b7 30a4 	ldrsh.w	r3, [r7, #164]	; 0xa4
 80139a4:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
    /*Write out all lines*/
    while(txt[line_start] != '\0') {
 80139a8:	e2f4      	b.n	8013f94 <lv_draw_label+0xbc0>
        pos.x += x_ofs;
 80139aa:	f9b7 30a4 	ldrsh.w	r3, [r7, #164]	; 0xa4
 80139ae:	b29a      	uxth	r2, r3
 80139b0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80139b4:	b29b      	uxth	r3, r3
 80139b6:	4413      	add	r3, r2
 80139b8:	b29b      	uxth	r3, r3
 80139ba:	b21b      	sxth	r3, r3
 80139bc:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4

        /*Write all letter of a line*/
        cmd_state = CMD_STATE_WAIT;
 80139c0:	2300      	movs	r3, #0
 80139c2:	f887 30ff 	strb.w	r3, [r7, #255]	; 0xff
        i         = 0;
 80139c6:	2300      	movs	r3, #0
 80139c8:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
#if LV_USE_BIDI
        char * bidi_txt = _lv_mem_buf_get(line_end - line_start + 1);
        _lv_bidi_process_paragraph(txt + line_start, bidi_txt, line_end - line_start, dsc->bidi_dir, NULL, 0);
#else
        const char * bidi_txt = txt + line_start;
 80139cc:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80139d0:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 80139d4:	681a      	ldr	r2, [r3, #0]
 80139d6:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 80139da:	4413      	add	r3, r2
 80139dc:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
#endif

        while(i < line_end - line_start) {
 80139e0:	e169      	b.n	8013cb6 <lv_draw_label+0x8e2>
            uint32_t logical_char_pos = 0;
 80139e2:	2300      	movs	r3, #0
 80139e4:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
 80139e8:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80139ec:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80139f0:	4293      	cmp	r3, r2
 80139f2:	d014      	beq.n	8013a1e <lv_draw_label+0x64a>
 80139f4:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 80139f8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80139fc:	4293      	cmp	r3, r2
 80139fe:	d00e      	beq.n	8013a1e <lv_draw_label+0x64a>
#if LV_USE_BIDI
                logical_char_pos = _lv_txt_encoded_get_char_id(txt, line_start);
                uint32_t t = _lv_txt_encoded_get_char_id(bidi_txt, i);
                logical_char_pos += _lv_bidi_get_logical_pos(bidi_txt, NULL, line_end - line_start, dsc->bidi_dir, t, NULL);
#else
                logical_char_pos = _lv_txt_encoded_get_char_id(txt, line_start + i);
 8013a00:	4b5e      	ldr	r3, [pc, #376]	; (8013b7c <lv_draw_label+0x7a8>)
 8013a02:	681b      	ldr	r3, [r3, #0]
 8013a04:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 8013a08:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 8013a0c:	4411      	add	r1, r2
 8013a0e:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8013a12:	f5a2 728c 	sub.w	r2, r2, #280	; 0x118
 8013a16:	6810      	ldr	r0, [r2, #0]
 8013a18:	4798      	blx	r3
 8013a1a:	f8c7 00f4 	str.w	r0, [r7, #244]	; 0xf4
#endif
            }

            uint32_t letter      = _lv_txt_encoded_next(bidi_txt, &i);
 8013a1e:	4b58      	ldr	r3, [pc, #352]	; (8013b80 <lv_draw_label+0x7ac>)
 8013a20:	681b      	ldr	r3, [r3, #0]
 8013a22:	f107 0294 	add.w	r2, r7, #148	; 0x94
 8013a26:	4611      	mov	r1, r2
 8013a28:	f8d7 00c8 	ldr.w	r0, [r7, #200]	; 0xc8
 8013a2c:	4798      	blx	r3
 8013a2e:	f8c7 00c4 	str.w	r0, [r7, #196]	; 0xc4
            uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[i], NULL);
 8013a32:	4b53      	ldr	r3, [pc, #332]	; (8013b80 <lv_draw_label+0x7ac>)
 8013a34:	681b      	ldr	r3, [r3, #0]
 8013a36:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8013a3a:	f8d7 10c8 	ldr.w	r1, [r7, #200]	; 0xc8
 8013a3e:	440a      	add	r2, r1
 8013a40:	2100      	movs	r1, #0
 8013a42:	4610      	mov	r0, r2
 8013a44:	4798      	blx	r3
 8013a46:	f8c7 00c0 	str.w	r0, [r7, #192]	; 0xc0

            /*Handle the re-color command*/
            if((dsc->flag & LV_TXT_FLAG_RECOLOR) != 0) {
 8013a4a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013a4e:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013a52:	681b      	ldr	r3, [r3, #0]
 8013a54:	7f5b      	ldrb	r3, [r3, #29]
 8013a56:	f003 0301 	and.w	r3, r3, #1
 8013a5a:	2b00      	cmp	r3, #0
 8013a5c:	f000 8092 	beq.w	8013b84 <lv_draw_label+0x7b0>
                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {
 8013a60:	2323      	movs	r3, #35	; 0x23
 8013a62:	461a      	mov	r2, r3
 8013a64:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8013a68:	4293      	cmp	r3, r2
 8013a6a:	d11b      	bne.n	8013aa4 <lv_draw_label+0x6d0>
                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/
 8013a6c:	f897 30ff 	ldrb.w	r3, [r7, #255]	; 0xff
 8013a70:	2b00      	cmp	r3, #0
 8013a72:	d107      	bne.n	8013a84 <lv_draw_label+0x6b0>
                        par_start = i;
 8013a74:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8013a78:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
                        cmd_state = CMD_STATE_PAR;
 8013a7c:	2301      	movs	r3, #1
 8013a7e:	f887 30ff 	strb.w	r3, [r7, #255]	; 0xff
                        continue;
 8013a82:	e118      	b.n	8013cb6 <lv_draw_label+0x8e2>
                    }
                    else if(cmd_state == CMD_STATE_PAR) {   /*Other start char in parameter escaped cmd. char */
 8013a84:	f897 30ff 	ldrb.w	r3, [r7, #255]	; 0xff
 8013a88:	2b01      	cmp	r3, #1
 8013a8a:	d103      	bne.n	8013a94 <lv_draw_label+0x6c0>
                        cmd_state = CMD_STATE_WAIT;
 8013a8c:	2300      	movs	r3, #0
 8013a8e:	f887 30ff 	strb.w	r3, [r7, #255]	; 0xff
 8013a92:	e007      	b.n	8013aa4 <lv_draw_label+0x6d0>
                    }
                    else if(cmd_state == CMD_STATE_IN) {   /*Command end */
 8013a94:	f897 30ff 	ldrb.w	r3, [r7, #255]	; 0xff
 8013a98:	2b02      	cmp	r3, #2
 8013a9a:	d103      	bne.n	8013aa4 <lv_draw_label+0x6d0>
                        cmd_state = CMD_STATE_WAIT;
 8013a9c:	2300      	movs	r3, #0
 8013a9e:	f887 30ff 	strb.w	r3, [r7, #255]	; 0xff
                        continue;
 8013aa2:	e108      	b.n	8013cb6 <lv_draw_label+0x8e2>
                    }
                }

                /*Skip the color parameter and wait the space after it*/
                if(cmd_state == CMD_STATE_PAR) {
 8013aa4:	f897 30ff 	ldrb.w	r3, [r7, #255]	; 0xff
 8013aa8:	2b01      	cmp	r3, #1
 8013aaa:	d16b      	bne.n	8013b84 <lv_draw_label+0x7b0>
                    if(letter == ' ') {
 8013aac:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8013ab0:	2b20      	cmp	r3, #32
 8013ab2:	f040 80ff 	bne.w	8013cb4 <lv_draw_label+0x8e0>
                        /*Get the parameter*/
                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {
 8013ab6:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8013aba:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8013abe:	1ad3      	subs	r3, r2, r3
 8013ac0:	2b07      	cmp	r3, #7
 8013ac2:	d14d      	bne.n	8013b60 <lv_draw_label+0x78c>
                            char buf[LABEL_RECOLOR_PAR_LENGTH + 1];
                            _lv_memcpy_small(buf, &bidi_txt[par_start], LABEL_RECOLOR_PAR_LENGTH);
 8013ac4:	f8d7 20c8 	ldr.w	r2, [r7, #200]	; 0xc8
 8013ac8:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8013acc:	18d1      	adds	r1, r2, r3
 8013ace:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8013ad2:	2206      	movs	r2, #6
 8013ad4:	4618      	mov	r0, r3
 8013ad6:	f7ff fbcf 	bl	8013278 <_lv_memcpy_small>
                            buf[LABEL_RECOLOR_PAR_LENGTH] = '\0';
 8013ada:	2300      	movs	r3, #0
 8013adc:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
                            int r, g, b;
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
 8013ae0:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8013ae4:	4618      	mov	r0, r3
 8013ae6:	f001 f843 	bl	8014b70 <hex_char_to_num>
 8013aea:	4603      	mov	r3, r0
 8013aec:	011c      	lsls	r4, r3, #4
 8013aee:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
 8013af2:	4618      	mov	r0, r3
 8013af4:	f001 f83c 	bl	8014b70 <hex_char_to_num>
 8013af8:	4603      	mov	r3, r0
 8013afa:	4423      	add	r3, r4
 8013afc:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
 8013b00:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8013b04:	4618      	mov	r0, r3
 8013b06:	f001 f833 	bl	8014b70 <hex_char_to_num>
 8013b0a:	4603      	mov	r3, r0
 8013b0c:	011c      	lsls	r4, r3, #4
 8013b0e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8013b12:	4618      	mov	r0, r3
 8013b14:	f001 f82c 	bl	8014b70 <hex_char_to_num>
 8013b18:	4603      	mov	r3, r0
 8013b1a:	4423      	add	r3, r4
 8013b1c:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);
 8013b20:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8013b24:	4618      	mov	r0, r3
 8013b26:	f001 f823 	bl	8014b70 <hex_char_to_num>
 8013b2a:	4603      	mov	r3, r0
 8013b2c:	011c      	lsls	r4, r3, #4
 8013b2e:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 8013b32:	4618      	mov	r0, r3
 8013b34:	f001 f81c 	bl	8014b70 <hex_char_to_num>
 8013b38:	4603      	mov	r3, r0
 8013b3a:	4423      	add	r3, r4
 8013b3c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
                            recolor = lv_color_make(r, g, b);
 8013b40:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 8013b44:	b2db      	uxtb	r3, r3
 8013b46:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 8013b4a:	b2d1      	uxtb	r1, r2
 8013b4c:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8013b50:	b2d2      	uxtb	r2, r2
 8013b52:	4618      	mov	r0, r3
 8013b54:	f7ff fbd6 	bl	8013304 <lv_color_make>
 8013b58:	4603      	mov	r3, r0
 8013b5a:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
 8013b5e:	e007      	b.n	8013b70 <lv_draw_label+0x79c>
                        }
                        else {
                            recolor.full = dsc->color.full;
 8013b60:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013b64:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013b68:	681b      	ldr	r3, [r3, #0]
 8013b6a:	881b      	ldrh	r3, [r3, #0]
 8013b6c:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
                        }
                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/
 8013b70:	2302      	movs	r3, #2
 8013b72:	f887 30ff 	strb.w	r3, [r7, #255]	; 0xff
                    }
                    continue;
 8013b76:	e09d      	b.n	8013cb4 <lv_draw_label+0x8e0>
 8013b78:	66666667 	.word	0x66666667
 8013b7c:	20000210 	.word	0x20000210
 8013b80:	20000204 	.word	0x20000204
                }
            }

            lv_color_t color = dsc->color;
 8013b84:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013b88:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013b8c:	681b      	ldr	r3, [r3, #0]
 8013b8e:	881b      	ldrh	r3, [r3, #0]
 8013b90:	86bb      	strh	r3, [r7, #52]	; 0x34

            if(cmd_state == CMD_STATE_IN) color = recolor;
 8013b92:	f897 30ff 	ldrb.w	r3, [r7, #255]	; 0xff
 8013b96:	2b02      	cmp	r3, #2
 8013b98:	d102      	bne.n	8013ba0 <lv_draw_label+0x7cc>
 8013b9a:	f8b7 3090 	ldrh.w	r3, [r7, #144]	; 0x90
 8013b9e:	86bb      	strh	r3, [r7, #52]	; 0x34

            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
 8013ba0:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8013ba4:	f8d7 10c4 	ldr.w	r1, [r7, #196]	; 0xc4
 8013ba8:	f8d7 00f0 	ldr.w	r0, [r7, #240]	; 0xf0
 8013bac:	f009 ff8e 	bl	801dacc <lv_font_get_glyph_width>
 8013bb0:	4603      	mov	r3, r0
 8013bb2:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
 8013bb6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8013bba:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013bbe:	4293      	cmp	r3, r2
 8013bc0:	d044      	beq.n	8013c4c <lv_draw_label+0x878>
 8013bc2:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8013bc6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013bca:	4293      	cmp	r3, r2
 8013bcc:	d03e      	beq.n	8013c4c <lv_draw_label+0x878>
                if(logical_char_pos >= sel_start && logical_char_pos < sel_end) {
 8013bce:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 8013bd2:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8013bd6:	429a      	cmp	r2, r3
 8013bd8:	d338      	bcc.n	8013c4c <lv_draw_label+0x878>
 8013bda:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 8013bde:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8013be2:	429a      	cmp	r2, r3
 8013be4:	d232      	bcs.n	8013c4c <lv_draw_label+0x878>
                    lv_area_t sel_coords;
                    sel_coords.x1 = pos.x;
 8013be6:	f9b7 30a4 	ldrsh.w	r3, [r7, #164]	; 0xa4
 8013bea:	84bb      	strh	r3, [r7, #36]	; 0x24
                    sel_coords.y1 = pos.y;
 8013bec:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 8013bf0:	84fb      	strh	r3, [r7, #38]	; 0x26
                    sel_coords.x2 = pos.x + letter_w + dsc->letter_space - 1;
 8013bf2:	f9b7 30a4 	ldrsh.w	r3, [r7, #164]	; 0xa4
 8013bf6:	b29a      	uxth	r2, r3
 8013bf8:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8013bfc:	b29b      	uxth	r3, r3
 8013bfe:	4413      	add	r3, r2
 8013c00:	b29a      	uxth	r2, r3
 8013c02:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013c06:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013c0a:	681b      	ldr	r3, [r3, #0]
 8013c0c:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8013c10:	b29b      	uxth	r3, r3
 8013c12:	4413      	add	r3, r2
 8013c14:	b29b      	uxth	r3, r3
 8013c16:	3b01      	subs	r3, #1
 8013c18:	b29b      	uxth	r3, r3
 8013c1a:	b21b      	sxth	r3, r3
 8013c1c:	853b      	strh	r3, [r7, #40]	; 0x28
                    sel_coords.y2 = pos.y + line_height - 1;
 8013c1e:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 8013c22:	b29a      	uxth	r2, r3
 8013c24:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8013c28:	b29b      	uxth	r3, r3
 8013c2a:	4413      	add	r3, r2
 8013c2c:	b29b      	uxth	r3, r3
 8013c2e:	3b01      	subs	r3, #1
 8013c30:	b29b      	uxth	r3, r3
 8013c32:	b21b      	sxth	r3, r3
 8013c34:	857b      	strh	r3, [r7, #42]	; 0x2a
                    lv_draw_rect(&sel_coords, mask, &draw_dsc_sel);
 8013c36:	f107 023c 	add.w	r2, r7, #60	; 0x3c
 8013c3a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013c3e:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 8013c42:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8013c46:	6819      	ldr	r1, [r3, #0]
 8013c48:	f003 fe6a 	bl	8017920 <lv_draw_rect>
                }
            }

            lv_draw_letter(&pos, mask, font, letter, color, opa, dsc->blend_mode);
 8013c4c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013c50:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013c54:	681b      	ldr	r3, [r3, #0]
 8013c56:	7fdb      	ldrb	r3, [r3, #31]
 8013c58:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8013c5c:	f5a2 7188 	sub.w	r1, r2, #272	; 0x110
 8013c60:	f107 00a4 	add.w	r0, r7, #164	; 0xa4
 8013c64:	9302      	str	r3, [sp, #8]
 8013c66:	f897 30d7 	ldrb.w	r3, [r7, #215]	; 0xd7
 8013c6a:	9301      	str	r3, [sp, #4]
 8013c6c:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8013c6e:	f8ad 3000 	strh.w	r3, [sp]
 8013c72:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8013c76:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
 8013c7a:	6809      	ldr	r1, [r1, #0]
 8013c7c:	f000 f9a4 	bl	8013fc8 <lv_draw_letter>

            if(letter_w > 0) {
 8013c80:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8013c84:	2b00      	cmp	r3, #0
 8013c86:	dd16      	ble.n	8013cb6 <lv_draw_label+0x8e2>
                pos.x += letter_w + dsc->letter_space;
 8013c88:	f9b7 30a4 	ldrsh.w	r3, [r7, #164]	; 0xa4
 8013c8c:	b29a      	uxth	r2, r3
 8013c8e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013c92:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013c96:	681b      	ldr	r3, [r3, #0]
 8013c98:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8013c9c:	b299      	uxth	r1, r3
 8013c9e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8013ca2:	b29b      	uxth	r3, r3
 8013ca4:	440b      	add	r3, r1
 8013ca6:	b29b      	uxth	r3, r3
 8013ca8:	4413      	add	r3, r2
 8013caa:	b29b      	uxth	r3, r3
 8013cac:	b21b      	sxth	r3, r3
 8013cae:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
 8013cb2:	e000      	b.n	8013cb6 <lv_draw_label+0x8e2>
                    continue;
 8013cb4:	bf00      	nop
        while(i < line_end - line_start) {
 8013cb6:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 8013cba:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013cbe:	1ad2      	subs	r2, r2, r3
 8013cc0:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8013cc4:	429a      	cmp	r2, r3
 8013cc6:	f63f ae8c 	bhi.w	80139e2 <lv_draw_label+0x60e>
            }
        }

        if(dsc->decor & LV_TEXT_DECOR_STRIKETHROUGH) {
 8013cca:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013cce:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013cd2:	681b      	ldr	r3, [r3, #0]
 8013cd4:	7f9b      	ldrb	r3, [r3, #30]
 8013cd6:	f003 0302 	and.w	r3, r3, #2
 8013cda:	2b00      	cmp	r3, #0
 8013cdc:	d033      	beq.n	8013d46 <lv_draw_label+0x972>
            lv_point_t p1;
            lv_point_t p2;
            p1.x = pos_x_start;
 8013cde:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8013ce2:	b21b      	sxth	r3, r3
 8013ce4:	843b      	strh	r3, [r7, #32]
            p1.y = pos.y + (dsc->font->line_height / 2)  + line_dsc.width / 2;
 8013ce6:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 8013cea:	b29a      	uxth	r2, r3
 8013cec:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013cf0:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013cf4:	681b      	ldr	r3, [r3, #0]
 8013cf6:	685b      	ldr	r3, [r3, #4]
 8013cf8:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8013cfc:	0fd9      	lsrs	r1, r3, #31
 8013cfe:	440b      	add	r3, r1
 8013d00:	105b      	asrs	r3, r3, #1
 8013d02:	b21b      	sxth	r3, r3
 8013d04:	b29b      	uxth	r3, r3
 8013d06:	4413      	add	r3, r2
 8013d08:	b29a      	uxth	r2, r3
 8013d0a:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 8013d0e:	0fd9      	lsrs	r1, r3, #31
 8013d10:	440b      	add	r3, r1
 8013d12:	105b      	asrs	r3, r3, #1
 8013d14:	b21b      	sxth	r3, r3
 8013d16:	b29b      	uxth	r3, r3
 8013d18:	4413      	add	r3, r2
 8013d1a:	b29b      	uxth	r3, r3
 8013d1c:	b21b      	sxth	r3, r3
 8013d1e:	847b      	strh	r3, [r7, #34]	; 0x22
            p2.x = pos.x;
 8013d20:	f9b7 30a4 	ldrsh.w	r3, [r7, #164]	; 0xa4
 8013d24:	83bb      	strh	r3, [r7, #28]
            p2.y = p1.y;
 8013d26:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8013d2a:	83fb      	strh	r3, [r7, #30]
            lv_draw_line(&p1, &p2, mask, &line_dsc);
 8013d2c:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8013d30:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8013d34:	f5a2 7288 	sub.w	r2, r2, #272	; 0x110
 8013d38:	f107 011c 	add.w	r1, r7, #28
 8013d3c:	f107 0020 	add.w	r0, r7, #32
 8013d40:	6812      	ldr	r2, [r2, #0]
 8013d42:	f000 ff93 	bl	8014c6c <lv_draw_line>
        }

        if(dsc->decor  & LV_TEXT_DECOR_UNDERLINE) {
 8013d46:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013d4a:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013d4e:	681b      	ldr	r3, [r3, #0]
 8013d50:	7f9b      	ldrb	r3, [r3, #30]
 8013d52:	f003 0301 	and.w	r3, r3, #1
 8013d56:	2b00      	cmp	r3, #0
 8013d58:	d04c      	beq.n	8013df4 <lv_draw_label+0xa20>
            lv_point_t p1;
            lv_point_t p2;
            p1.x = pos_x_start;
 8013d5a:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8013d5e:	b21a      	sxth	r2, r3
 8013d60:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013d64:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8013d68:	801a      	strh	r2, [r3, #0]
            p1.y = pos.y + dsc->font->line_height - dsc->font->base_line - font->underline_position;
 8013d6a:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 8013d6e:	b29a      	uxth	r2, r3
 8013d70:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013d74:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013d78:	681b      	ldr	r3, [r3, #0]
 8013d7a:	685b      	ldr	r3, [r3, #4]
 8013d7c:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8013d80:	b29b      	uxth	r3, r3
 8013d82:	4413      	add	r3, r2
 8013d84:	b29a      	uxth	r2, r3
 8013d86:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013d8a:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013d8e:	681b      	ldr	r3, [r3, #0]
 8013d90:	685b      	ldr	r3, [r3, #4]
 8013d92:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8013d96:	b29b      	uxth	r3, r3
 8013d98:	1ad3      	subs	r3, r2, r3
 8013d9a:	b29a      	uxth	r2, r3
 8013d9c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8013da0:	f993 300d 	ldrsb.w	r3, [r3, #13]
 8013da4:	b29b      	uxth	r3, r3
 8013da6:	1ad3      	subs	r3, r2, r3
 8013da8:	b29b      	uxth	r3, r3
 8013daa:	b21a      	sxth	r2, r3
 8013dac:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013db0:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8013db4:	805a      	strh	r2, [r3, #2]
            p2.x = pos.x;
 8013db6:	f9b7 20a4 	ldrsh.w	r2, [r7, #164]	; 0xa4
 8013dba:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013dbe:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8013dc2:	801a      	strh	r2, [r3, #0]
            p2.y = p1.y;
 8013dc4:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013dc8:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8013dcc:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8013dd0:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013dd4:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
 8013dd8:	805a      	strh	r2, [r3, #2]
            lv_draw_line(&p1, &p2, mask, &line_dsc);
 8013dda:	f107 0398 	add.w	r3, r7, #152	; 0x98
 8013dde:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8013de2:	f5a2 7288 	sub.w	r2, r2, #272	; 0x110
 8013de6:	f107 0114 	add.w	r1, r7, #20
 8013dea:	f107 0018 	add.w	r0, r7, #24
 8013dee:	6812      	ldr	r2, [r2, #0]
 8013df0:	f000 ff3c 	bl	8014c6c <lv_draw_line>
#if LV_USE_BIDI
        _lv_mem_buf_release(bidi_txt);
        bidi_txt = NULL;
#endif
        /*Go to next line*/
        line_start = line_end;
 8013df4:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8013df8:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
        line_end += _lv_txt_get_next_line(&txt[line_start], font, dsc->letter_space, w, dsc->flag);
 8013dfc:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013e00:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8013e04:	681a      	ldr	r2, [r3, #0]
 8013e06:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013e0a:	18d0      	adds	r0, r2, r3
 8013e0c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013e10:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013e14:	681b      	ldr	r3, [r3, #0]
 8013e16:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 8013e1a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8013e1e:	b219      	sxth	r1, r3
 8013e20:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013e24:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013e28:	681b      	ldr	r3, [r3, #0]
 8013e2a:	7f5b      	ldrb	r3, [r3, #29]
 8013e2c:	9300      	str	r3, [sp, #0]
 8013e2e:	460b      	mov	r3, r1
 8013e30:	f8d7 10f0 	ldr.w	r1, [r7, #240]	; 0xf0
 8013e34:	f00e fac4 	bl	80223c0 <_lv_txt_get_next_line>
 8013e38:	4602      	mov	r2, r0
 8013e3a:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8013e3e:	4413      	add	r3, r2
 8013e40:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108

        pos.x = coords->x1;
 8013e44:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013e48:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8013e4c:	681b      	ldr	r3, [r3, #0]
 8013e4e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8013e52:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
        /*Align to middle*/
        if(dsc->flag & LV_TXT_FLAG_CENTER) {
 8013e56:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013e5a:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013e5e:	681b      	ldr	r3, [r3, #0]
 8013e60:	7f5b      	ldrb	r3, [r3, #29]
 8013e62:	f003 0304 	and.w	r3, r3, #4
 8013e66:	2b00      	cmp	r3, #0
 8013e68:	d03c      	beq.n	8013ee4 <lv_draw_label+0xb10>
            line_width =
                _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
 8013e6a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013e6e:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8013e72:	681a      	ldr	r2, [r3, #0]
 8013e74:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013e78:	18d0      	adds	r0, r2, r3
 8013e7a:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 8013e7e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013e82:	1ad1      	subs	r1, r2, r3
 8013e84:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013e88:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013e8c:	681b      	ldr	r3, [r3, #0]
 8013e8e:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 8013e92:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013e96:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013e9a:	681b      	ldr	r3, [r3, #0]
 8013e9c:	7f5b      	ldrb	r3, [r3, #29]
 8013e9e:	9300      	str	r3, [sp, #0]
 8013ea0:	4613      	mov	r3, r2
 8013ea2:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
 8013ea6:	f00e fb49 	bl	802253c <_lv_txt_get_width>
 8013eaa:	4603      	mov	r3, r0
            line_width =
 8013eac:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

            pos.x += (lv_area_get_width(coords) - line_width) / 2;
 8013eb0:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013eb4:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8013eb8:	6818      	ldr	r0, [r3, #0]
 8013eba:	f7ff f9ff 	bl	80132bc <lv_area_get_width>
 8013ebe:	4603      	mov	r3, r0
 8013ec0:	461a      	mov	r2, r3
 8013ec2:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8013ec6:	1ad3      	subs	r3, r2, r3
 8013ec8:	0fda      	lsrs	r2, r3, #31
 8013eca:	4413      	add	r3, r2
 8013ecc:	105b      	asrs	r3, r3, #1
 8013ece:	4619      	mov	r1, r3
 8013ed0:	f9b7 30a4 	ldrsh.w	r3, [r7, #164]	; 0xa4
 8013ed4:	b29a      	uxth	r2, r3
 8013ed6:	b28b      	uxth	r3, r1
 8013ed8:	4413      	add	r3, r2
 8013eda:	b29b      	uxth	r3, r3
 8013edc:	b21b      	sxth	r3, r3
 8013ede:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
 8013ee2:	e041      	b.n	8013f68 <lv_draw_label+0xb94>

        }
        /*Align to the right*/
        else if(dsc->flag & LV_TXT_FLAG_RIGHT) {
 8013ee4:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013ee8:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013eec:	681b      	ldr	r3, [r3, #0]
 8013eee:	7f5b      	ldrb	r3, [r3, #29]
 8013ef0:	f003 0308 	and.w	r3, r3, #8
 8013ef4:	2b00      	cmp	r3, #0
 8013ef6:	d037      	beq.n	8013f68 <lv_draw_label+0xb94>
            line_width =
                _lv_txt_get_width(&txt[line_start], line_end - line_start, font, dsc->letter_space, dsc->flag);
 8013ef8:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013efc:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8013f00:	681a      	ldr	r2, [r3, #0]
 8013f02:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013f06:	18d0      	adds	r0, r2, r3
 8013f08:	f8d7 2108 	ldr.w	r2, [r7, #264]	; 0x108
 8013f0c:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013f10:	1ad1      	subs	r1, r2, r3
 8013f12:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013f16:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013f1a:	681b      	ldr	r3, [r3, #0]
 8013f1c:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 8013f20:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013f24:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8013f28:	681b      	ldr	r3, [r3, #0]
 8013f2a:	7f5b      	ldrb	r3, [r3, #29]
 8013f2c:	9300      	str	r3, [sp, #0]
 8013f2e:	4613      	mov	r3, r2
 8013f30:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
 8013f34:	f00e fb02 	bl	802253c <_lv_txt_get_width>
 8013f38:	4603      	mov	r3, r0
            line_width =
 8013f3a:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
            pos.x += lv_area_get_width(coords) - line_width;
 8013f3e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013f42:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8013f46:	6818      	ldr	r0, [r3, #0]
 8013f48:	f7ff f9b8 	bl	80132bc <lv_area_get_width>
 8013f4c:	4603      	mov	r3, r0
 8013f4e:	461a      	mov	r2, r3
 8013f50:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8013f54:	1ad3      	subs	r3, r2, r3
 8013f56:	f9b7 20a4 	ldrsh.w	r2, [r7, #164]	; 0xa4
 8013f5a:	b292      	uxth	r2, r2
 8013f5c:	b29b      	uxth	r3, r3
 8013f5e:	4413      	add	r3, r2
 8013f60:	b29b      	uxth	r3, r3
 8013f62:	b21b      	sxth	r3, r3
 8013f64:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
        }

        /*Go the next line position*/
        pos.y += line_height;
 8013f68:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 8013f6c:	b29a      	uxth	r2, r3
 8013f6e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8013f72:	b29b      	uxth	r3, r3
 8013f74:	4413      	add	r3, r2
 8013f76:	b29b      	uxth	r3, r3
 8013f78:	b21b      	sxth	r3, r3
 8013f7a:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6

        if(pos.y > mask->y2) return;
 8013f7e:	f9b7 20a6 	ldrsh.w	r2, [r7, #166]	; 0xa6
 8013f82:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013f86:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 8013f8a:	681b      	ldr	r3, [r3, #0]
 8013f8c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8013f90:	429a      	cmp	r2, r3
 8013f92:	dc14      	bgt.n	8013fbe <lv_draw_label+0xbea>
    while(txt[line_start] != '\0') {
 8013f94:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8013f98:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8013f9c:	681a      	ldr	r2, [r3, #0]
 8013f9e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8013fa2:	4413      	add	r3, r2
 8013fa4:	781b      	ldrb	r3, [r3, #0]
 8013fa6:	2b00      	cmp	r3, #0
 8013fa8:	f47f acff 	bne.w	80139aa <lv_draw_label+0x5d6>
 8013fac:	e008      	b.n	8013fc0 <lv_draw_label+0xbec>
    if(dsc->opa <= LV_OPA_MIN) return;
 8013fae:	bf00      	nop
 8013fb0:	e006      	b.n	8013fc0 <lv_draw_label+0xbec>
    if(txt[0] == '\0')  return;
 8013fb2:	bf00      	nop
 8013fb4:	e004      	b.n	8013fc0 <lv_draw_label+0xbec>
    if(!clip_ok) return;
 8013fb6:	bf00      	nop
 8013fb8:	e002      	b.n	8013fc0 <lv_draw_label+0xbec>
        if(txt[line_start] == '\0') return;
 8013fba:	bf00      	nop
 8013fbc:	e000      	b.n	8013fc0 <lv_draw_label+0xbec>
        if(pos.y > mask->y2) return;
 8013fbe:	bf00      	nop
    }

    LV_ASSERT_MEM_INTEGRITY();
}
 8013fc0:	f507 778c 	add.w	r7, r7, #280	; 0x118
 8013fc4:	46bd      	mov	sp, r7
 8013fc6:	bdb0      	pop	{r4, r5, r7, pc}

08013fc8 <lv_draw_letter>:
 */
LV_ATTRIBUTE_FAST_MEM static void lv_draw_letter(const lv_point_t * pos_p, const lv_area_t * clip_area,
                                                 const lv_font_t * font_p,
                                                 uint32_t letter,
                                                 lv_color_t color, lv_opa_t opa, lv_blend_mode_t blend_mode)
{
 8013fc8:	b580      	push	{r7, lr}
 8013fca:	b090      	sub	sp, #64	; 0x40
 8013fcc:	af04      	add	r7, sp, #16
 8013fce:	60f8      	str	r0, [r7, #12]
 8013fd0:	60b9      	str	r1, [r7, #8]
 8013fd2:	607a      	str	r2, [r7, #4]
 8013fd4:	603b      	str	r3, [r7, #0]
    if(opa < LV_OPA_MIN) return;
 8013fd6:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 8013fda:	2b01      	cmp	r3, #1
 8013fdc:	f240 8096 	bls.w	801410c <lv_draw_letter+0x144>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 8013fe0:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 8013fe4:	2bfd      	cmp	r3, #253	; 0xfd
 8013fe6:	d902      	bls.n	8013fee <lv_draw_letter+0x26>
 8013fe8:	23ff      	movs	r3, #255	; 0xff
 8013fea:	f887 303c 	strb.w	r3, [r7, #60]	; 0x3c

    if(font_p == NULL) {
 8013fee:	687b      	ldr	r3, [r7, #4]
 8013ff0:	2b00      	cmp	r3, #0
 8013ff2:	f000 808d 	beq.w	8014110 <lv_draw_letter+0x148>
        LV_LOG_WARN("lv_draw_letter: font is NULL");
        return;
    }

    lv_font_glyph_dsc_t g;
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
 8013ff6:	f107 0114 	add.w	r1, r7, #20
 8013ffa:	2300      	movs	r3, #0
 8013ffc:	683a      	ldr	r2, [r7, #0]
 8013ffe:	6878      	ldr	r0, [r7, #4]
 8014000:	f009 fd51 	bl	801daa6 <lv_font_get_glyph_dsc>
 8014004:	4603      	mov	r3, r0
 8014006:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    if(g_ret == false)  {
 801400a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801400e:	f083 0301 	eor.w	r3, r3, #1
 8014012:	b2db      	uxtb	r3, r3
 8014014:	2b00      	cmp	r3, #0
 8014016:	d17d      	bne.n	8014114 <lv_draw_letter+0x14c>
        }
        return;
    }

    /* Don't draw anything if the character is empty. E.g. space */
    if((g.box_h == 0) || (g.box_w == 0)) return;
 8014018:	8b3b      	ldrh	r3, [r7, #24]
 801401a:	2b00      	cmp	r3, #0
 801401c:	d07c      	beq.n	8014118 <lv_draw_letter+0x150>
 801401e:	8afb      	ldrh	r3, [r7, #22]
 8014020:	2b00      	cmp	r3, #0
 8014022:	d079      	beq.n	8014118 <lv_draw_letter+0x150>

    int32_t pos_x = pos_p->x + g.ofs_x;
 8014024:	68fb      	ldr	r3, [r7, #12]
 8014026:	f9b3 3000 	ldrsh.w	r3, [r3]
 801402a:	461a      	mov	r2, r3
 801402c:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8014030:	4413      	add	r3, r2
 8014032:	62bb      	str	r3, [r7, #40]	; 0x28
    int32_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
 8014034:	68fb      	ldr	r3, [r7, #12]
 8014036:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801403a:	461a      	mov	r2, r3
 801403c:	687b      	ldr	r3, [r7, #4]
 801403e:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8014042:	4619      	mov	r1, r3
 8014044:	687b      	ldr	r3, [r7, #4]
 8014046:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801404a:	1acb      	subs	r3, r1, r3
 801404c:	4413      	add	r3, r2
 801404e:	8b3a      	ldrh	r2, [r7, #24]
 8014050:	1a9b      	subs	r3, r3, r2
 8014052:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 8014056:	1a9b      	subs	r3, r3, r2
 8014058:	627b      	str	r3, [r7, #36]	; 0x24

    /*If the letter is completely out of mask don't draw it */
    if(pos_x + g.box_w < clip_area->x1 ||
 801405a:	8afb      	ldrh	r3, [r7, #22]
 801405c:	461a      	mov	r2, r3
 801405e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014060:	4413      	add	r3, r2
 8014062:	68ba      	ldr	r2, [r7, #8]
 8014064:	f9b2 2000 	ldrsh.w	r2, [r2]
 8014068:	4293      	cmp	r3, r2
 801406a:	db57      	blt.n	801411c <lv_draw_letter+0x154>
       pos_x > clip_area->x2 ||
 801406c:	68bb      	ldr	r3, [r7, #8]
 801406e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8014072:	461a      	mov	r2, r3
    if(pos_x + g.box_w < clip_area->x1 ||
 8014074:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014076:	4293      	cmp	r3, r2
 8014078:	dc50      	bgt.n	801411c <lv_draw_letter+0x154>
       pos_y + g.box_h < clip_area->y1 ||
 801407a:	8b3b      	ldrh	r3, [r7, #24]
 801407c:	461a      	mov	r2, r3
 801407e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014080:	4413      	add	r3, r2
 8014082:	68ba      	ldr	r2, [r7, #8]
 8014084:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
       pos_x > clip_area->x2 ||
 8014088:	4293      	cmp	r3, r2
 801408a:	db47      	blt.n	801411c <lv_draw_letter+0x154>
       pos_y > clip_area->y2)  {
 801408c:	68bb      	ldr	r3, [r7, #8]
 801408e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014092:	461a      	mov	r2, r3
       pos_y + g.box_h < clip_area->y1 ||
 8014094:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014096:	4293      	cmp	r3, r2
 8014098:	dc40      	bgt.n	801411c <lv_draw_letter+0x154>
        return;
    }


    const uint8_t * map_p = lv_font_get_glyph_bitmap(font_p, letter);
 801409a:	6839      	ldr	r1, [r7, #0]
 801409c:	6878      	ldr	r0, [r7, #4]
 801409e:	f009 fcf3 	bl	801da88 <lv_font_get_glyph_bitmap>
 80140a2:	6238      	str	r0, [r7, #32]
    if(map_p == NULL) {
 80140a4:	6a3b      	ldr	r3, [r7, #32]
 80140a6:	2b00      	cmp	r3, #0
 80140a8:	d03a      	beq.n	8014120 <lv_draw_letter+0x158>
        LV_LOG_WARN("lv_draw_letter: character's bitmap not found");
        return;
    }

    if(font_p->subpx) {
 80140aa:	687b      	ldr	r3, [r7, #4]
 80140ac:	7b1b      	ldrb	r3, [r3, #12]
 80140ae:	f003 0303 	and.w	r3, r3, #3
 80140b2:	b2db      	uxtb	r3, r3
 80140b4:	2b00      	cmp	r3, #0
 80140b6:	d014      	beq.n	80140e2 <lv_draw_letter+0x11a>
        draw_letter_subpx(pos_x, pos_y, &g, clip_area, map_p, color, opa, blend_mode);
 80140b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80140ba:	b218      	sxth	r0, r3
 80140bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80140be:	b219      	sxth	r1, r3
 80140c0:	f107 0214 	add.w	r2, r7, #20
 80140c4:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 80140c8:	9303      	str	r3, [sp, #12]
 80140ca:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 80140ce:	9302      	str	r3, [sp, #8]
 80140d0:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 80140d2:	f8ad 3004 	strh.w	r3, [sp, #4]
 80140d6:	6a3b      	ldr	r3, [r7, #32]
 80140d8:	9300      	str	r3, [sp, #0]
 80140da:	68bb      	ldr	r3, [r7, #8]
 80140dc:	f000 fa38 	bl	8014550 <draw_letter_subpx>
 80140e0:	e01f      	b.n	8014122 <lv_draw_letter+0x15a>
    }
    else {
        draw_letter_normal(pos_x, pos_y, &g, clip_area, map_p, color, opa, blend_mode);
 80140e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80140e4:	b218      	sxth	r0, r3
 80140e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80140e8:	b219      	sxth	r1, r3
 80140ea:	f107 0214 	add.w	r2, r7, #20
 80140ee:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 80140f2:	9303      	str	r3, [sp, #12]
 80140f4:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
 80140f8:	9302      	str	r3, [sp, #8]
 80140fa:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 80140fc:	f8ad 3004 	strh.w	r3, [sp, #4]
 8014100:	6a3b      	ldr	r3, [r7, #32]
 8014102:	9300      	str	r3, [sp, #0]
 8014104:	68bb      	ldr	r3, [r7, #8]
 8014106:	f000 f80f 	bl	8014128 <draw_letter_normal>
 801410a:	e00a      	b.n	8014122 <lv_draw_letter+0x15a>
    if(opa < LV_OPA_MIN) return;
 801410c:	bf00      	nop
 801410e:	e008      	b.n	8014122 <lv_draw_letter+0x15a>
        return;
 8014110:	bf00      	nop
 8014112:	e006      	b.n	8014122 <lv_draw_letter+0x15a>
        return;
 8014114:	bf00      	nop
 8014116:	e004      	b.n	8014122 <lv_draw_letter+0x15a>
    if((g.box_h == 0) || (g.box_w == 0)) return;
 8014118:	bf00      	nop
 801411a:	e002      	b.n	8014122 <lv_draw_letter+0x15a>
        return;
 801411c:	bf00      	nop
 801411e:	e000      	b.n	8014122 <lv_draw_letter+0x15a>
        return;
 8014120:	bf00      	nop
    }
}
 8014122:	3730      	adds	r7, #48	; 0x30
 8014124:	46bd      	mov	sp, r7
 8014126:	bd80      	pop	{r7, pc}

08014128 <draw_letter_normal>:


LV_ATTRIBUTE_FAST_MEM static void draw_letter_normal(lv_coord_t pos_x, lv_coord_t pos_y, lv_font_glyph_dsc_t * g,
                                                     const lv_area_t * clip_area,
                                                     const uint8_t * map_p, lv_color_t color, lv_opa_t opa, lv_blend_mode_t blend_mode)
{
 8014128:	b5f0      	push	{r4, r5, r6, r7, lr}
 801412a:	b0a5      	sub	sp, #148	; 0x94
 801412c:	af04      	add	r7, sp, #16
 801412e:	60ba      	str	r2, [r7, #8]
 8014130:	607b      	str	r3, [r7, #4]
 8014132:	4603      	mov	r3, r0
 8014134:	81fb      	strh	r3, [r7, #14]
 8014136:	460b      	mov	r3, r1
 8014138:	81bb      	strh	r3, [r7, #12]
    const uint8_t * bpp_opa_table_p;
    uint32_t bitmask_init;
    uint32_t bitmask;
    uint32_t bpp = g->bpp;
 801413a:	68bb      	ldr	r3, [r7, #8]
 801413c:	7a9b      	ldrb	r3, [r3, #10]
 801413e:	673b      	str	r3, [r7, #112]	; 0x70
    uint32_t shades;
    if(bpp == 3) bpp = 4;
 8014140:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8014142:	2b03      	cmp	r3, #3
 8014144:	d101      	bne.n	801414a <draw_letter_normal+0x22>
 8014146:	2304      	movs	r3, #4
 8014148:	673b      	str	r3, [r7, #112]	; 0x70

    switch(bpp) {
 801414a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801414c:	3b01      	subs	r3, #1
 801414e:	2b07      	cmp	r3, #7
 8014150:	f200 81fa 	bhi.w	8014548 <draw_letter_normal+0x420>
 8014154:	a201      	add	r2, pc, #4	; (adr r2, 801415c <draw_letter_normal+0x34>)
 8014156:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801415a:	bf00      	nop
 801415c:	0801417d 	.word	0x0801417d
 8014160:	0801418b 	.word	0x0801418b
 8014164:	08014549 	.word	0x08014549
 8014168:	08014199 	.word	0x08014199
 801416c:	08014549 	.word	0x08014549
 8014170:	08014549 	.word	0x08014549
 8014174:	08014549 	.word	0x08014549
 8014178:	080141a7 	.word	0x080141a7
        case 1:
            bpp_opa_table_p = _lv_bpp1_opa_table;
 801417c:	4b9b      	ldr	r3, [pc, #620]	; (80143ec <draw_letter_normal+0x2c4>)
 801417e:	67fb      	str	r3, [r7, #124]	; 0x7c
            bitmask_init  = 0x80;
 8014180:	2380      	movs	r3, #128	; 0x80
 8014182:	67bb      	str	r3, [r7, #120]	; 0x78
            shades = 2;
 8014184:	2302      	movs	r3, #2
 8014186:	66fb      	str	r3, [r7, #108]	; 0x6c
            break;
 8014188:	e015      	b.n	80141b6 <draw_letter_normal+0x8e>
        case 2:
            bpp_opa_table_p = _lv_bpp2_opa_table;
 801418a:	4b99      	ldr	r3, [pc, #612]	; (80143f0 <draw_letter_normal+0x2c8>)
 801418c:	67fb      	str	r3, [r7, #124]	; 0x7c
            bitmask_init  = 0xC0;
 801418e:	23c0      	movs	r3, #192	; 0xc0
 8014190:	67bb      	str	r3, [r7, #120]	; 0x78
            shades = 4;
 8014192:	2304      	movs	r3, #4
 8014194:	66fb      	str	r3, [r7, #108]	; 0x6c
            break;
 8014196:	e00e      	b.n	80141b6 <draw_letter_normal+0x8e>
        case 4:
            bpp_opa_table_p = _lv_bpp4_opa_table;
 8014198:	4b96      	ldr	r3, [pc, #600]	; (80143f4 <draw_letter_normal+0x2cc>)
 801419a:	67fb      	str	r3, [r7, #124]	; 0x7c
            bitmask_init  = 0xF0;
 801419c:	23f0      	movs	r3, #240	; 0xf0
 801419e:	67bb      	str	r3, [r7, #120]	; 0x78
            shades = 16;
 80141a0:	2310      	movs	r3, #16
 80141a2:	66fb      	str	r3, [r7, #108]	; 0x6c
            break;
 80141a4:	e007      	b.n	80141b6 <draw_letter_normal+0x8e>
        case 8:
            bpp_opa_table_p = _lv_bpp8_opa_table;
 80141a6:	4b94      	ldr	r3, [pc, #592]	; (80143f8 <draw_letter_normal+0x2d0>)
 80141a8:	67fb      	str	r3, [r7, #124]	; 0x7c
            bitmask_init  = 0xFF;
 80141aa:	23ff      	movs	r3, #255	; 0xff
 80141ac:	67bb      	str	r3, [r7, #120]	; 0x78
            shades = 256;
 80141ae:	f44f 7380 	mov.w	r3, #256	; 0x100
 80141b2:	66fb      	str	r3, [r7, #108]	; 0x6c
            break;       /*No opa table, pixel value will be used directly*/
 80141b4:	bf00      	nop
    }

    static lv_opa_t opa_table[256];
    static lv_opa_t prev_opa = LV_OPA_TRANSP;
    static uint32_t prev_bpp = 0;
    if(opa < LV_OPA_MAX) {
 80141b6:	f897 30a0 	ldrb.w	r3, [r7, #160]	; 0xa0
 80141ba:	2bfc      	cmp	r3, #252	; 0xfc
 80141bc:	d835      	bhi.n	801422a <draw_letter_normal+0x102>
        if(prev_opa != opa || prev_bpp != bpp) {
 80141be:	4b8f      	ldr	r3, [pc, #572]	; (80143fc <draw_letter_normal+0x2d4>)
 80141c0:	781b      	ldrb	r3, [r3, #0]
 80141c2:	f897 20a0 	ldrb.w	r2, [r7, #160]	; 0xa0
 80141c6:	429a      	cmp	r2, r3
 80141c8:	d104      	bne.n	80141d4 <draw_letter_normal+0xac>
 80141ca:	4b8d      	ldr	r3, [pc, #564]	; (8014400 <draw_letter_normal+0x2d8>)
 80141cc:	681b      	ldr	r3, [r3, #0]
 80141ce:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80141d0:	429a      	cmp	r2, r3
 80141d2:	d021      	beq.n	8014218 <draw_letter_normal+0xf0>
            uint32_t i;
            for(i = 0; i < shades; i++) {
 80141d4:	2300      	movs	r3, #0
 80141d6:	66bb      	str	r3, [r7, #104]	; 0x68
 80141d8:	e01a      	b.n	8014210 <draw_letter_normal+0xe8>
                opa_table[i] = bpp_opa_table_p[i] == LV_OPA_COVER ? opa : ((bpp_opa_table_p[i] * opa) >> 8);
 80141da:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80141dc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80141de:	4413      	add	r3, r2
 80141e0:	781b      	ldrb	r3, [r3, #0]
 80141e2:	2bff      	cmp	r3, #255	; 0xff
 80141e4:	d00b      	beq.n	80141fe <draw_letter_normal+0xd6>
 80141e6:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80141e8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80141ea:	4413      	add	r3, r2
 80141ec:	781b      	ldrb	r3, [r3, #0]
 80141ee:	461a      	mov	r2, r3
 80141f0:	f897 30a0 	ldrb.w	r3, [r7, #160]	; 0xa0
 80141f4:	fb02 f303 	mul.w	r3, r2, r3
 80141f8:	121b      	asrs	r3, r3, #8
 80141fa:	b2db      	uxtb	r3, r3
 80141fc:	e001      	b.n	8014202 <draw_letter_normal+0xda>
 80141fe:	f897 30a0 	ldrb.w	r3, [r7, #160]	; 0xa0
 8014202:	4980      	ldr	r1, [pc, #512]	; (8014404 <draw_letter_normal+0x2dc>)
 8014204:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8014206:	440a      	add	r2, r1
 8014208:	7013      	strb	r3, [r2, #0]
            for(i = 0; i < shades; i++) {
 801420a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801420c:	3301      	adds	r3, #1
 801420e:	66bb      	str	r3, [r7, #104]	; 0x68
 8014210:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8014212:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8014214:	429a      	cmp	r2, r3
 8014216:	d3e0      	bcc.n	80141da <draw_letter_normal+0xb2>
            }
        }
        bpp_opa_table_p = opa_table;
 8014218:	4b7a      	ldr	r3, [pc, #488]	; (8014404 <draw_letter_normal+0x2dc>)
 801421a:	67fb      	str	r3, [r7, #124]	; 0x7c
        prev_opa = opa;
 801421c:	4a77      	ldr	r2, [pc, #476]	; (80143fc <draw_letter_normal+0x2d4>)
 801421e:	f897 30a0 	ldrb.w	r3, [r7, #160]	; 0xa0
 8014222:	7013      	strb	r3, [r2, #0]
        prev_bpp = bpp;
 8014224:	4a76      	ldr	r2, [pc, #472]	; (8014400 <draw_letter_normal+0x2d8>)
 8014226:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8014228:	6013      	str	r3, [r2, #0]
    }

    int32_t col, row;
    int32_t box_w = g->box_w;
 801422a:	68bb      	ldr	r3, [r7, #8]
 801422c:	885b      	ldrh	r3, [r3, #2]
 801422e:	657b      	str	r3, [r7, #84]	; 0x54
    int32_t box_h = g->box_h;
 8014230:	68bb      	ldr	r3, [r7, #8]
 8014232:	889b      	ldrh	r3, [r3, #4]
 8014234:	653b      	str	r3, [r7, #80]	; 0x50
    int32_t width_bit = box_w * bpp; /*Letter width in bits*/
 8014236:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014238:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 801423a:	fb02 f303 	mul.w	r3, r2, r3
 801423e:	64fb      	str	r3, [r7, #76]	; 0x4c

    /* Calculate the col/row start/end on the map*/
    int32_t col_start = pos_x >= clip_area->x1 ? 0 : clip_area->x1 - pos_x;
 8014240:	687b      	ldr	r3, [r7, #4]
 8014242:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014246:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 801424a:	429a      	cmp	r2, r3
 801424c:	da07      	bge.n	801425e <draw_letter_normal+0x136>
 801424e:	687b      	ldr	r3, [r7, #4]
 8014250:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014254:	461a      	mov	r2, r3
 8014256:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 801425a:	1ad3      	subs	r3, r2, r3
 801425c:	e000      	b.n	8014260 <draw_letter_normal+0x138>
 801425e:	2300      	movs	r3, #0
 8014260:	64bb      	str	r3, [r7, #72]	; 0x48
    int32_t col_end   = pos_x + box_w <= clip_area->x2 ? box_w : clip_area->x2 - pos_x + 1;
 8014262:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8014266:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014268:	4413      	add	r3, r2
 801426a:	687a      	ldr	r2, [r7, #4]
 801426c:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
 8014270:	4293      	cmp	r3, r2
 8014272:	dd08      	ble.n	8014286 <draw_letter_normal+0x15e>
 8014274:	687b      	ldr	r3, [r7, #4]
 8014276:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801427a:	461a      	mov	r2, r3
 801427c:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8014280:	1ad3      	subs	r3, r2, r3
 8014282:	3301      	adds	r3, #1
 8014284:	e000      	b.n	8014288 <draw_letter_normal+0x160>
 8014286:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014288:	647b      	str	r3, [r7, #68]	; 0x44
    int32_t row_start = pos_y >= clip_area->y1 ? 0 : clip_area->y1 - pos_y;
 801428a:	687b      	ldr	r3, [r7, #4]
 801428c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014290:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8014294:	429a      	cmp	r2, r3
 8014296:	da07      	bge.n	80142a8 <draw_letter_normal+0x180>
 8014298:	687b      	ldr	r3, [r7, #4]
 801429a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801429e:	461a      	mov	r2, r3
 80142a0:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80142a4:	1ad3      	subs	r3, r2, r3
 80142a6:	e000      	b.n	80142aa <draw_letter_normal+0x182>
 80142a8:	2300      	movs	r3, #0
 80142aa:	643b      	str	r3, [r7, #64]	; 0x40
    int32_t row_end   = pos_y + box_h <= clip_area->y2 ? box_h : clip_area->y2 - pos_y + 1;
 80142ac:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 80142b0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80142b2:	4413      	add	r3, r2
 80142b4:	687a      	ldr	r2, [r7, #4]
 80142b6:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 80142ba:	4293      	cmp	r3, r2
 80142bc:	dd08      	ble.n	80142d0 <draw_letter_normal+0x1a8>
 80142be:	687b      	ldr	r3, [r7, #4]
 80142c0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80142c4:	461a      	mov	r2, r3
 80142c6:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80142ca:	1ad3      	subs	r3, r2, r3
 80142cc:	3301      	adds	r3, #1
 80142ce:	e000      	b.n	80142d2 <draw_letter_normal+0x1aa>
 80142d0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80142d2:	63fb      	str	r3, [r7, #60]	; 0x3c

    /*Move on the map too*/
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * bpp);
 80142d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80142d6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80142d8:	fb02 f303 	mul.w	r3, r2, r3
 80142dc:	4619      	mov	r1, r3
 80142de:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80142e0:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80142e2:	fb02 f303 	mul.w	r3, r2, r3
 80142e6:	440b      	add	r3, r1
 80142e8:	63bb      	str	r3, [r7, #56]	; 0x38
    map_p += bit_ofs >> 3;
 80142ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80142ec:	08db      	lsrs	r3, r3, #3
 80142ee:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80142f2:	4413      	add	r3, r2
 80142f4:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

    uint8_t letter_px;
    uint32_t col_bit;
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */
 80142f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80142fa:	f003 0307 	and.w	r3, r3, #7
 80142fe:	65fb      	str	r3, [r7, #92]	; 0x5c

    uint32_t mask_buf_size = box_w * box_h > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : box_w * box_h;
 8014300:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014302:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8014304:	fb02 f303 	mul.w	r3, r2, r3
 8014308:	f5b3 7f48 	cmp.w	r3, #800	; 0x320
 801430c:	bfa8      	it	ge
 801430e:	f44f 7348 	movge.w	r3, #800	; 0x320
 8014312:	637b      	str	r3, [r7, #52]	; 0x34
    lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
 8014314:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8014316:	f00c fdbb 	bl	8020e90 <_lv_mem_buf_get>
 801431a:	6338      	str	r0, [r7, #48]	; 0x30
    int32_t mask_p = 0;
 801431c:	2300      	movs	r3, #0
 801431e:	65bb      	str	r3, [r7, #88]	; 0x58

    lv_area_t fill_area;
    fill_area.x1 = col_start + pos_x;
 8014320:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8014322:	b29a      	uxth	r2, r3
 8014324:	89fb      	ldrh	r3, [r7, #14]
 8014326:	4413      	add	r3, r2
 8014328:	b29b      	uxth	r3, r3
 801432a:	b21b      	sxth	r3, r3
 801432c:	82bb      	strh	r3, [r7, #20]
    fill_area.x2 = col_end  + pos_x - 1;
 801432e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8014330:	b29a      	uxth	r2, r3
 8014332:	89fb      	ldrh	r3, [r7, #14]
 8014334:	4413      	add	r3, r2
 8014336:	b29b      	uxth	r3, r3
 8014338:	3b01      	subs	r3, #1
 801433a:	b29b      	uxth	r3, r3
 801433c:	b21b      	sxth	r3, r3
 801433e:	833b      	strh	r3, [r7, #24]
    fill_area.y1 = row_start + pos_y;
 8014340:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014342:	b29a      	uxth	r2, r3
 8014344:	89bb      	ldrh	r3, [r7, #12]
 8014346:	4413      	add	r3, r2
 8014348:	b29b      	uxth	r3, r3
 801434a:	b21b      	sxth	r3, r3
 801434c:	82fb      	strh	r3, [r7, #22]
    fill_area.y2 = fill_area.y1;
 801434e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8014352:	837b      	strh	r3, [r7, #26]

    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
 8014354:	f001 feca 	bl	80160ec <lv_draw_mask_get_cnt>
 8014358:	4603      	mov	r3, r0
 801435a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    uint32_t col_bit_max = 8 - bpp;
 801435e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8014360:	f1c3 0308 	rsb	r3, r3, #8
 8014364:	62bb      	str	r3, [r7, #40]	; 0x28
    uint32_t col_bit_row_ofs = (box_w + col_start - col_end) * bpp;
 8014366:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 8014368:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801436a:	441a      	add	r2, r3
 801436c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801436e:	1ad3      	subs	r3, r2, r3
 8014370:	461a      	mov	r2, r3
 8014372:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8014374:	fb02 f303 	mul.w	r3, r2, r3
 8014378:	627b      	str	r3, [r7, #36]	; 0x24

    for(row = row_start ; row < row_end; row++) {
 801437a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801437c:	663b      	str	r3, [r7, #96]	; 0x60
 801437e:	e0bc      	b.n	80144fa <draw_letter_normal+0x3d2>
        int32_t mask_p_start = mask_p;
 8014380:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014382:	623b      	str	r3, [r7, #32]

        bitmask = bitmask_init >> col_bit;
 8014384:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8014386:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8014388:	fa22 f303 	lsr.w	r3, r2, r3
 801438c:	677b      	str	r3, [r7, #116]	; 0x74
        for(col = col_start; col < col_end; col++) {
 801438e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8014390:	667b      	str	r3, [r7, #100]	; 0x64
 8014392:	e048      	b.n	8014426 <draw_letter_normal+0x2fe>
            /*Load the pixel's opacity into the mask*/
            letter_px = (*map_p & bitmask) >> (col_bit_max - col_bit);
 8014394:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8014398:	781b      	ldrb	r3, [r3, #0]
 801439a:	461a      	mov	r2, r3
 801439c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801439e:	401a      	ands	r2, r3
 80143a0:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80143a2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80143a4:	1acb      	subs	r3, r1, r3
 80143a6:	fa22 f303 	lsr.w	r3, r2, r3
 80143aa:	77bb      	strb	r3, [r7, #30]
            if(letter_px) {
 80143ac:	7fbb      	ldrb	r3, [r7, #30]
 80143ae:	2b00      	cmp	r3, #0
 80143b0:	d008      	beq.n	80143c4 <draw_letter_normal+0x29c>
                mask_buf[mask_p] = bpp_opa_table_p[letter_px];
 80143b2:	7fbb      	ldrb	r3, [r7, #30]
 80143b4:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80143b6:	441a      	add	r2, r3
 80143b8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80143ba:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80143bc:	440b      	add	r3, r1
 80143be:	7812      	ldrb	r2, [r2, #0]
 80143c0:	701a      	strb	r2, [r3, #0]
 80143c2:	e004      	b.n	80143ce <draw_letter_normal+0x2a6>
            }
            else {
                mask_buf[mask_p] = 0;
 80143c4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80143c6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80143c8:	4413      	add	r3, r2
 80143ca:	2200      	movs	r2, #0
 80143cc:	701a      	strb	r2, [r3, #0]
            }

            /*Go to the next column*/
            if(col_bit < col_bit_max) {
 80143ce:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80143d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80143d2:	429a      	cmp	r2, r3
 80143d4:	d218      	bcs.n	8014408 <draw_letter_normal+0x2e0>
                col_bit += bpp;
 80143d6:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80143d8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80143da:	4413      	add	r3, r2
 80143dc:	65fb      	str	r3, [r7, #92]	; 0x5c
                bitmask = bitmask >> bpp;
 80143de:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 80143e0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80143e2:	fa22 f303 	lsr.w	r3, r2, r3
 80143e6:	677b      	str	r3, [r7, #116]	; 0x74
 80143e8:	e017      	b.n	801441a <draw_letter_normal+0x2f2>
 80143ea:	bf00      	nop
 80143ec:	080e5fd4 	.word	0x080e5fd4
 80143f0:	080e5fd8 	.word	0x080e5fd8
 80143f4:	080e5fdc 	.word	0x080e5fdc
 80143f8:	080e5fec 	.word	0x080e5fec
 80143fc:	2000a040 	.word	0x2000a040
 8014400:	2000a044 	.word	0x2000a044
 8014404:	2000a048 	.word	0x2000a048
            }
            else {
                col_bit = 0;
 8014408:	2300      	movs	r3, #0
 801440a:	65fb      	str	r3, [r7, #92]	; 0x5c
                bitmask = bitmask_init;
 801440c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 801440e:	677b      	str	r3, [r7, #116]	; 0x74
                map_p++;
 8014410:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8014414:	3301      	adds	r3, #1
 8014416:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
            }

            /*Next mask byte*/
            mask_p++;
 801441a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801441c:	3301      	adds	r3, #1
 801441e:	65bb      	str	r3, [r7, #88]	; 0x58
        for(col = col_start; col < col_end; col++) {
 8014420:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8014422:	3301      	adds	r3, #1
 8014424:	667b      	str	r3, [r7, #100]	; 0x64
 8014426:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8014428:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801442a:	429a      	cmp	r2, r3
 801442c:	dbb2      	blt.n	8014394 <draw_letter_normal+0x26c>
        }


        /*Apply masks if any*/
        if(other_mask_cnt) {
 801442e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8014432:	2b00      	cmp	r3, #0
 8014434:	d023      	beq.n	801447e <draw_letter_normal+0x356>
            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf + mask_p_start, fill_area.x1, fill_area.y2,
 8014436:	6a3b      	ldr	r3, [r7, #32]
 8014438:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801443a:	18d4      	adds	r4, r2, r3
 801443c:	f9b7 5014 	ldrsh.w	r5, [r7, #20]
 8014440:	f9b7 601a 	ldrsh.w	r6, [r7, #26]
 8014444:	f107 0314 	add.w	r3, r7, #20
 8014448:	4618      	mov	r0, r3
 801444a:	f7fe ff37 	bl	80132bc <lv_area_get_width>
 801444e:	4603      	mov	r3, r0
 8014450:	4632      	mov	r2, r6
 8014452:	4629      	mov	r1, r5
 8014454:	4620      	mov	r0, r4
 8014456:	f001 fdad 	bl	8015fb4 <lv_draw_mask_apply>
 801445a:	4603      	mov	r3, r0
 801445c:	77fb      	strb	r3, [r7, #31]
                                                             lv_area_get_width(&fill_area));
            if(mask_res == LV_DRAW_MASK_RES_TRANSP) {
 801445e:	7ffb      	ldrb	r3, [r7, #31]
 8014460:	2b00      	cmp	r3, #0
 8014462:	d10c      	bne.n	801447e <draw_letter_normal+0x356>
                _lv_memset_00(mask_buf + mask_p_start, lv_area_get_width(&fill_area));
 8014464:	6a3b      	ldr	r3, [r7, #32]
 8014466:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8014468:	18d4      	adds	r4, r2, r3
 801446a:	f107 0314 	add.w	r3, r7, #20
 801446e:	4618      	mov	r0, r3
 8014470:	f7fe ff24 	bl	80132bc <lv_area_get_width>
 8014474:	4603      	mov	r3, r0
 8014476:	4619      	mov	r1, r3
 8014478:	4620      	mov	r0, r4
 801447a:	f00d f915 	bl	80216a8 <_lv_memset_00>
            }
        }

        if((uint32_t) mask_p + (col_end - col_start) < mask_buf_size) {
 801447e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8014480:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8014482:	1ad3      	subs	r3, r2, r3
 8014484:	461a      	mov	r2, r3
 8014486:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014488:	4413      	add	r3, r2
 801448a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801448c:	429a      	cmp	r2, r3
 801448e:	d907      	bls.n	80144a0 <draw_letter_normal+0x378>
            fill_area.y2 ++;
 8014490:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8014494:	b29b      	uxth	r3, r3
 8014496:	3301      	adds	r3, #1
 8014498:	b29b      	uxth	r3, r3
 801449a:	b21b      	sxth	r3, r3
 801449c:	837b      	strh	r3, [r7, #26]
 801449e:	e01a      	b.n	80144d6 <draw_letter_normal+0x3ae>
        }
        else {
            _lv_blend_fill(clip_area, &fill_area,
 80144a0:	f107 0114 	add.w	r1, r7, #20
 80144a4:	f897 30a4 	ldrb.w	r3, [r7, #164]	; 0xa4
 80144a8:	9302      	str	r3, [sp, #8]
 80144aa:	23ff      	movs	r3, #255	; 0xff
 80144ac:	9301      	str	r3, [sp, #4]
 80144ae:	2302      	movs	r3, #2
 80144b0:	9300      	str	r3, [sp, #0]
 80144b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80144b4:	f8b7 209c 	ldrh.w	r2, [r7, #156]	; 0x9c
 80144b8:	6878      	ldr	r0, [r7, #4]
 80144ba:	f7fc f9d3 	bl	8010864 <_lv_blend_fill>
                           color, mask_buf, LV_DRAW_MASK_RES_CHANGED, LV_OPA_COVER,
                           blend_mode);

            fill_area.y1 = fill_area.y2 + 1;
 80144be:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80144c2:	b29b      	uxth	r3, r3
 80144c4:	3301      	adds	r3, #1
 80144c6:	b29b      	uxth	r3, r3
 80144c8:	b21b      	sxth	r3, r3
 80144ca:	82fb      	strh	r3, [r7, #22]
            fill_area.y2 = fill_area.y1;
 80144cc:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80144d0:	837b      	strh	r3, [r7, #26]
            mask_p = 0;
 80144d2:	2300      	movs	r3, #0
 80144d4:	65bb      	str	r3, [r7, #88]	; 0x58
        }

        col_bit += col_bit_row_ofs;
 80144d6:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80144d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80144da:	4413      	add	r3, r2
 80144dc:	65fb      	str	r3, [r7, #92]	; 0x5c
        map_p += (col_bit >> 3);
 80144de:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80144e0:	08db      	lsrs	r3, r3, #3
 80144e2:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80144e6:	4413      	add	r3, r2
 80144e8:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
        col_bit = col_bit & 0x7;
 80144ec:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80144ee:	f003 0307 	and.w	r3, r3, #7
 80144f2:	65fb      	str	r3, [r7, #92]	; 0x5c
    for(row = row_start ; row < row_end; row++) {
 80144f4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80144f6:	3301      	adds	r3, #1
 80144f8:	663b      	str	r3, [r7, #96]	; 0x60
 80144fa:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80144fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80144fe:	429a      	cmp	r2, r3
 8014500:	f6ff af3e 	blt.w	8014380 <draw_letter_normal+0x258>
    }

    /*Flush the last part*/
    if(fill_area.y1 != fill_area.y2) {
 8014504:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8014508:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801450c:	429a      	cmp	r2, r3
 801450e:	d017      	beq.n	8014540 <draw_letter_normal+0x418>
        fill_area.y2--;
 8014510:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8014514:	b29b      	uxth	r3, r3
 8014516:	3b01      	subs	r3, #1
 8014518:	b29b      	uxth	r3, r3
 801451a:	b21b      	sxth	r3, r3
 801451c:	837b      	strh	r3, [r7, #26]
        _lv_blend_fill(clip_area, &fill_area,
 801451e:	f107 0114 	add.w	r1, r7, #20
 8014522:	f897 30a4 	ldrb.w	r3, [r7, #164]	; 0xa4
 8014526:	9302      	str	r3, [sp, #8]
 8014528:	23ff      	movs	r3, #255	; 0xff
 801452a:	9301      	str	r3, [sp, #4]
 801452c:	2302      	movs	r3, #2
 801452e:	9300      	str	r3, [sp, #0]
 8014530:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8014532:	f8b7 209c 	ldrh.w	r2, [r7, #156]	; 0x9c
 8014536:	6878      	ldr	r0, [r7, #4]
 8014538:	f7fc f994 	bl	8010864 <_lv_blend_fill>
                       color, mask_buf, LV_DRAW_MASK_RES_CHANGED, LV_OPA_COVER,
                       blend_mode);
        mask_p = 0;
 801453c:	2300      	movs	r3, #0
 801453e:	65bb      	str	r3, [r7, #88]	; 0x58
    }

    _lv_mem_buf_release(mask_buf);
 8014540:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8014542:	f00c fd85 	bl	8021050 <_lv_mem_buf_release>
 8014546:	e000      	b.n	801454a <draw_letter_normal+0x422>
            return; /*Invalid bpp. Can't render the letter*/
 8014548:	bf00      	nop
}
 801454a:	3784      	adds	r7, #132	; 0x84
 801454c:	46bd      	mov	sp, r7
 801454e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08014550 <draw_letter_subpx>:

static void draw_letter_subpx(lv_coord_t pos_x, lv_coord_t pos_y, lv_font_glyph_dsc_t * g, const lv_area_t * clip_area,
                              const uint8_t * map_p, lv_color_t color, lv_opa_t opa, lv_blend_mode_t blend_mode)
{
 8014550:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014552:	b0ab      	sub	sp, #172	; 0xac
 8014554:	af04      	add	r7, sp, #16
 8014556:	60ba      	str	r2, [r7, #8]
 8014558:	607b      	str	r3, [r7, #4]
 801455a:	4603      	mov	r3, r0
 801455c:	81fb      	strh	r3, [r7, #14]
 801455e:	460b      	mov	r3, r1
 8014560:	81bb      	strh	r3, [r7, #12]
#if LV_USE_FONT_SUBPX
    const uint8_t * bpp_opa_table;
    uint32_t bitmask_init;
    uint32_t bitmask;
    uint32_t bpp = g->bpp;
 8014562:	68bb      	ldr	r3, [r7, #8]
 8014564:	7a9b      	ldrb	r3, [r3, #10]
 8014566:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
    if(bpp == 3) bpp = 4;
 801456a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801456e:	2b03      	cmp	r3, #3
 8014570:	d102      	bne.n	8014578 <draw_letter_subpx+0x28>
 8014572:	2304      	movs	r3, #4
 8014574:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88

    switch(bpp) {
 8014578:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801457c:	3b01      	subs	r3, #1
 801457e:	2b07      	cmp	r3, #7
 8014580:	f200 82f0 	bhi.w	8014b64 <draw_letter_subpx+0x614>
 8014584:	a201      	add	r2, pc, #4	; (adr r2, 801458c <draw_letter_subpx+0x3c>)
 8014586:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801458a:	bf00      	nop
 801458c:	080145ad 	.word	0x080145ad
 8014590:	080145bb 	.word	0x080145bb
 8014594:	08014b65 	.word	0x08014b65
 8014598:	080145c9 	.word	0x080145c9
 801459c:	08014b65 	.word	0x08014b65
 80145a0:	08014b65 	.word	0x08014b65
 80145a4:	08014b65 	.word	0x08014b65
 80145a8:	080145d7 	.word	0x080145d7
        case 1:
            bpp_opa_table = _lv_bpp1_opa_table;
 80145ac:	4bb5      	ldr	r3, [pc, #724]	; (8014884 <draw_letter_subpx+0x334>)
 80145ae:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
            bitmask_init  = 0x80;
 80145b2:	2380      	movs	r3, #128	; 0x80
 80145b4:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
            break;
 80145b8:	e014      	b.n	80145e4 <draw_letter_subpx+0x94>
        case 2:
            bpp_opa_table = _lv_bpp2_opa_table;
 80145ba:	4bb3      	ldr	r3, [pc, #716]	; (8014888 <draw_letter_subpx+0x338>)
 80145bc:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
            bitmask_init  = 0xC0;
 80145c0:	23c0      	movs	r3, #192	; 0xc0
 80145c2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
            break;
 80145c6:	e00d      	b.n	80145e4 <draw_letter_subpx+0x94>
        case 4:
            bpp_opa_table = _lv_bpp4_opa_table;
 80145c8:	4bb0      	ldr	r3, [pc, #704]	; (801488c <draw_letter_subpx+0x33c>)
 80145ca:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
            bitmask_init  = 0xF0;
 80145ce:	23f0      	movs	r3, #240	; 0xf0
 80145d0:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
            break;
 80145d4:	e006      	b.n	80145e4 <draw_letter_subpx+0x94>
        case 8:
            bpp_opa_table = _lv_bpp8_opa_table;
 80145d6:	4bae      	ldr	r3, [pc, #696]	; (8014890 <draw_letter_subpx+0x340>)
 80145d8:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
            bitmask_init  = 0xFF;
 80145dc:	23ff      	movs	r3, #255	; 0xff
 80145de:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
            break;       /*No opa table, pixel value will be used directly*/
 80145e2:	bf00      	nop
            return; /*Invalid bpp. Can't render the letter*/
    }

    int32_t col, row;

    int32_t box_w = g->box_w;
 80145e4:	68bb      	ldr	r3, [r7, #8]
 80145e6:	885b      	ldrh	r3, [r3, #2]
 80145e8:	66bb      	str	r3, [r7, #104]	; 0x68
    int32_t box_h = g->box_h;
 80145ea:	68bb      	ldr	r3, [r7, #8]
 80145ec:	889b      	ldrh	r3, [r3, #4]
 80145ee:	667b      	str	r3, [r7, #100]	; 0x64
    int32_t width_bit = box_w * bpp; /*Letter width in bits*/
 80145f0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80145f2:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 80145f6:	fb02 f303 	mul.w	r3, r2, r3
 80145fa:	663b      	str	r3, [r7, #96]	; 0x60


    /* Calculate the col/row start/end on the map*/
    int32_t col_start = pos_x >= clip_area->x1 ? 0 : (clip_area->x1 - pos_x) * 3;
 80145fc:	687b      	ldr	r3, [r7, #4]
 80145fe:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014602:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8014606:	429a      	cmp	r2, r3
 8014608:	da0a      	bge.n	8014620 <draw_letter_subpx+0xd0>
 801460a:	687b      	ldr	r3, [r7, #4]
 801460c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014610:	461a      	mov	r2, r3
 8014612:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8014616:	1ad2      	subs	r2, r2, r3
 8014618:	4613      	mov	r3, r2
 801461a:	005b      	lsls	r3, r3, #1
 801461c:	4413      	add	r3, r2
 801461e:	e000      	b.n	8014622 <draw_letter_subpx+0xd2>
 8014620:	2300      	movs	r3, #0
 8014622:	65fb      	str	r3, [r7, #92]	; 0x5c
    int32_t col_end   = pos_x + box_w / 3 <= clip_area->x2 ? box_w : (clip_area->x2 - pos_x + 1) * 3;
 8014624:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8014628:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801462a:	499a      	ldr	r1, [pc, #616]	; (8014894 <draw_letter_subpx+0x344>)
 801462c:	fb81 0103 	smull	r0, r1, r1, r3
 8014630:	17db      	asrs	r3, r3, #31
 8014632:	1acb      	subs	r3, r1, r3
 8014634:	4413      	add	r3, r2
 8014636:	687a      	ldr	r2, [r7, #4]
 8014638:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
 801463c:	4293      	cmp	r3, r2
 801463e:	dd0b      	ble.n	8014658 <draw_letter_subpx+0x108>
 8014640:	687b      	ldr	r3, [r7, #4]
 8014642:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8014646:	461a      	mov	r2, r3
 8014648:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 801464c:	1ad3      	subs	r3, r2, r3
 801464e:	1c5a      	adds	r2, r3, #1
 8014650:	4613      	mov	r3, r2
 8014652:	005b      	lsls	r3, r3, #1
 8014654:	4413      	add	r3, r2
 8014656:	e000      	b.n	801465a <draw_letter_subpx+0x10a>
 8014658:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801465a:	65bb      	str	r3, [r7, #88]	; 0x58
    int32_t row_start = pos_y >= clip_area->y1 ? 0 : clip_area->y1 - pos_y;
 801465c:	687b      	ldr	r3, [r7, #4]
 801465e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014662:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8014666:	429a      	cmp	r2, r3
 8014668:	da07      	bge.n	801467a <draw_letter_subpx+0x12a>
 801466a:	687b      	ldr	r3, [r7, #4]
 801466c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014670:	461a      	mov	r2, r3
 8014672:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8014676:	1ad3      	subs	r3, r2, r3
 8014678:	e000      	b.n	801467c <draw_letter_subpx+0x12c>
 801467a:	2300      	movs	r3, #0
 801467c:	657b      	str	r3, [r7, #84]	; 0x54
    int32_t row_end   = pos_y + box_h <= clip_area->y2 ? box_h : clip_area->y2 - pos_y + 1;
 801467e:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8014682:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8014684:	4413      	add	r3, r2
 8014686:	687a      	ldr	r2, [r7, #4]
 8014688:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 801468c:	4293      	cmp	r3, r2
 801468e:	dd08      	ble.n	80146a2 <draw_letter_subpx+0x152>
 8014690:	687b      	ldr	r3, [r7, #4]
 8014692:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014696:	461a      	mov	r2, r3
 8014698:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 801469c:	1ad3      	subs	r3, r2, r3
 801469e:	3301      	adds	r3, #1
 80146a0:	e000      	b.n	80146a4 <draw_letter_subpx+0x154>
 80146a2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80146a4:	653b      	str	r3, [r7, #80]	; 0x50

    /*Move on the map too*/
    int32_t bit_ofs = (row_start * width_bit) + (col_start * bpp);
 80146a6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80146a8:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80146aa:	fb02 f303 	mul.w	r3, r2, r3
 80146ae:	4619      	mov	r1, r3
 80146b0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 80146b2:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 80146b6:	fb02 f303 	mul.w	r3, r2, r3
 80146ba:	440b      	add	r3, r1
 80146bc:	64fb      	str	r3, [r7, #76]	; 0x4c
    map_p += bit_ofs >> 3;
 80146be:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80146c0:	10db      	asrs	r3, r3, #3
 80146c2:	461a      	mov	r2, r3
 80146c4:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80146c8:	4413      	add	r3, r2
 80146ca:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0

    uint8_t letter_px;
    lv_opa_t px_opa;
    int32_t col_bit;
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */
 80146ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80146d0:	f003 0307 	and.w	r3, r3, #7
 80146d4:	67bb      	str	r3, [r7, #120]	; 0x78

    int32_t mask_buf_size = box_w * box_h > LV_HOR_RES_MAX ? LV_HOR_RES_MAX : g->box_w * g->box_h;
 80146d6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80146d8:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80146da:	fb02 f303 	mul.w	r3, r2, r3
 80146de:	f5b3 7f48 	cmp.w	r3, #800	; 0x320
 80146e2:	dc07      	bgt.n	80146f4 <draw_letter_subpx+0x1a4>
 80146e4:	68bb      	ldr	r3, [r7, #8]
 80146e6:	885b      	ldrh	r3, [r3, #2]
 80146e8:	461a      	mov	r2, r3
 80146ea:	68bb      	ldr	r3, [r7, #8]
 80146ec:	889b      	ldrh	r3, [r3, #4]
 80146ee:	fb02 f303 	mul.w	r3, r2, r3
 80146f2:	e001      	b.n	80146f8 <draw_letter_subpx+0x1a8>
 80146f4:	f44f 7348 	mov.w	r3, #800	; 0x320
 80146f8:	64bb      	str	r3, [r7, #72]	; 0x48
    lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
 80146fa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80146fc:	4618      	mov	r0, r3
 80146fe:	f00c fbc7 	bl	8020e90 <_lv_mem_buf_get>
 8014702:	6478      	str	r0, [r7, #68]	; 0x44
    int32_t mask_p = 0;
 8014704:	2300      	movs	r3, #0
 8014706:	677b      	str	r3, [r7, #116]	; 0x74

    lv_color_t * color_buf = _lv_mem_buf_get(mask_buf_size * sizeof(lv_color_t));
 8014708:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801470a:	005b      	lsls	r3, r3, #1
 801470c:	4618      	mov	r0, r3
 801470e:	f00c fbbf 	bl	8020e90 <_lv_mem_buf_get>
 8014712:	6438      	str	r0, [r7, #64]	; 0x40

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
 8014714:	f7f9 fe64 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 8014718:	63f8      	str	r0, [r7, #60]	; 0x3c
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 801471a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801471c:	f00a fa76 	bl	801ec0c <lv_disp_get_buf>
 8014720:	63b8      	str	r0, [r7, #56]	; 0x38

    int32_t vdb_width     = lv_area_get_width(&vdb->area);
 8014722:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8014724:	3310      	adds	r3, #16
 8014726:	4618      	mov	r0, r3
 8014728:	f7fe fdc8 	bl	80132bc <lv_area_get_width>
 801472c:	4603      	mov	r3, r0
 801472e:	637b      	str	r3, [r7, #52]	; 0x34
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
 8014730:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8014732:	689b      	ldr	r3, [r3, #8]
 8014734:	673b      	str	r3, [r7, #112]	; 0x70

    /*Set a pointer on VDB to the first pixel of the letter*/
    vdb_buf_tmp += ((pos_y - vdb->area.y1) * vdb_width) + pos_x - vdb->area.x1;
 8014736:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 801473a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801473c:	f9b2 2012 	ldrsh.w	r2, [r2, #18]
 8014740:	1a9b      	subs	r3, r3, r2
 8014742:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8014744:	fb03 f202 	mul.w	r2, r3, r2
 8014748:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 801474c:	4413      	add	r3, r2
 801474e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8014750:	f9b2 2010 	ldrsh.w	r2, [r2, #16]
 8014754:	1a9b      	subs	r3, r3, r2
 8014756:	005b      	lsls	r3, r3, #1
 8014758:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 801475a:	4413      	add	r3, r2
 801475c:	673b      	str	r3, [r7, #112]	; 0x70

    /*If the letter is partially out of mask the move there on VDB*/
    vdb_buf_tmp += (row_start * vdb_width) + col_start / 3;
 801475e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8014760:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8014762:	fb03 f202 	mul.w	r2, r3, r2
 8014766:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8014768:	494a      	ldr	r1, [pc, #296]	; (8014894 <draw_letter_subpx+0x344>)
 801476a:	fb81 0103 	smull	r0, r1, r1, r3
 801476e:	17db      	asrs	r3, r3, #31
 8014770:	1acb      	subs	r3, r1, r3
 8014772:	4413      	add	r3, r2
 8014774:	005b      	lsls	r3, r3, #1
 8014776:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8014778:	4413      	add	r3, r2
 801477a:	673b      	str	r3, [r7, #112]	; 0x70

    lv_area_t map_area;
    map_area.x1 = col_start / 3 + pos_x;
 801477c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801477e:	4a45      	ldr	r2, [pc, #276]	; (8014894 <draw_letter_subpx+0x344>)
 8014780:	fb82 1203 	smull	r1, r2, r2, r3
 8014784:	17db      	asrs	r3, r3, #31
 8014786:	1ad3      	subs	r3, r2, r3
 8014788:	b29a      	uxth	r2, r3
 801478a:	89fb      	ldrh	r3, [r7, #14]
 801478c:	4413      	add	r3, r2
 801478e:	b29b      	uxth	r3, r3
 8014790:	b21b      	sxth	r3, r3
 8014792:	843b      	strh	r3, [r7, #32]
    map_area.x2 = col_end / 3  + pos_x - 1;
 8014794:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014796:	4a3f      	ldr	r2, [pc, #252]	; (8014894 <draw_letter_subpx+0x344>)
 8014798:	fb82 1203 	smull	r1, r2, r2, r3
 801479c:	17db      	asrs	r3, r3, #31
 801479e:	1ad3      	subs	r3, r2, r3
 80147a0:	b29a      	uxth	r2, r3
 80147a2:	89fb      	ldrh	r3, [r7, #14]
 80147a4:	4413      	add	r3, r2
 80147a6:	b29b      	uxth	r3, r3
 80147a8:	3b01      	subs	r3, #1
 80147aa:	b29b      	uxth	r3, r3
 80147ac:	b21b      	sxth	r3, r3
 80147ae:	84bb      	strh	r3, [r7, #36]	; 0x24
    map_area.y1 = row_start + pos_y;
 80147b0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80147b2:	b29a      	uxth	r2, r3
 80147b4:	89bb      	ldrh	r3, [r7, #12]
 80147b6:	4413      	add	r3, r2
 80147b8:	b29b      	uxth	r3, r3
 80147ba:	b21b      	sxth	r3, r3
 80147bc:	847b      	strh	r3, [r7, #34]	; 0x22
    map_area.y2 = map_area.y1;
 80147be:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 80147c2:	84fb      	strh	r3, [r7, #38]	; 0x26

    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
 80147c4:	f001 fc92 	bl	80160ec <lv_draw_mask_get_cnt>
 80147c8:	4603      	mov	r3, r0
 80147ca:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

    uint8_t font_rgb[3];

#if LV_COLOR_16_SWAP == 0
    uint8_t txt_rgb[3] = {color.ch.red, color.ch.green, color.ch.blue};
 80147ce:	f897 30b5 	ldrb.w	r3, [r7, #181]	; 0xb5
 80147d2:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80147d6:	b2db      	uxtb	r3, r3
 80147d8:	763b      	strb	r3, [r7, #24]
 80147da:	f8b7 30b4 	ldrh.w	r3, [r7, #180]	; 0xb4
 80147de:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80147e2:	b2db      	uxtb	r3, r3
 80147e4:	767b      	strb	r3, [r7, #25]
 80147e6:	f897 30b4 	ldrb.w	r3, [r7, #180]	; 0xb4
 80147ea:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80147ee:	b2db      	uxtb	r3, r3
 80147f0:	76bb      	strb	r3, [r7, #26]
#else
    uint8_t txt_rgb[3] = {color.ch.red, (color.ch.green_h << 3) + color.ch.green_l, color.ch.blue};
#endif

    for(row = row_start ; row < row_end; row++) {
 80147f2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80147f4:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 80147f8:	e18b      	b.n	8014b12 <draw_letter_subpx+0x5c2>
        uint32_t subpx_cnt = 0;
 80147fa:	2300      	movs	r3, #0
 80147fc:	66fb      	str	r3, [r7, #108]	; 0x6c
        bitmask = bitmask_init >> col_bit;
 80147fe:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8014802:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014804:	fa22 f303 	lsr.w	r3, r2, r3
 8014808:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
        int32_t mask_p_start = mask_p;
 801480c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801480e:	62fb      	str	r3, [r7, #44]	; 0x2c

        for(col = col_start; col < col_end; col++) {
 8014810:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8014812:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8014816:	e0f5      	b.n	8014a04 <draw_letter_subpx+0x4b4>
            /*Load the pixel's opacity into the mask*/
            letter_px = (*map_p & bitmask) >> (8 - col_bit - bpp);
 8014818:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 801481c:	781b      	ldrb	r3, [r3, #0]
 801481e:	461a      	mov	r2, r3
 8014820:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8014824:	401a      	ands	r2, r3
 8014826:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 8014828:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801482c:	440b      	add	r3, r1
 801482e:	f1c3 0308 	rsb	r3, r3, #8
 8014832:	fa22 f303 	lsr.w	r3, r2, r3
 8014836:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
            if(letter_px != 0) {
 801483a:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 801483e:	2b00      	cmp	r3, #0
 8014840:	d03a      	beq.n	80148b8 <draw_letter_subpx+0x368>
                if(opa == LV_OPA_COVER) {
 8014842:	f897 30b8 	ldrb.w	r3, [r7, #184]	; 0xb8
 8014846:	2bff      	cmp	r3, #255	; 0xff
 8014848:	d10f      	bne.n	801486a <draw_letter_subpx+0x31a>
                    px_opa = bpp == 8 ? letter_px : bpp_opa_table[letter_px];
 801484a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801484e:	2b08      	cmp	r3, #8
 8014850:	d006      	beq.n	8014860 <draw_letter_subpx+0x310>
 8014852:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 8014856:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 801485a:	4413      	add	r3, r2
 801485c:	781b      	ldrb	r3, [r3, #0]
 801485e:	e001      	b.n	8014864 <draw_letter_subpx+0x314>
 8014860:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 8014864:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
 8014868:	e029      	b.n	80148be <draw_letter_subpx+0x36e>
                }
                else {
                    px_opa = bpp == 8 ? (uint32_t)((uint32_t)letter_px * opa) >> 8
 801486a:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801486e:	2b08      	cmp	r3, #8
 8014870:	d112      	bne.n	8014898 <draw_letter_subpx+0x348>
 8014872:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 8014876:	f897 20b8 	ldrb.w	r2, [r7, #184]	; 0xb8
 801487a:	fb02 f303 	mul.w	r3, r2, r3
 801487e:	0a1b      	lsrs	r3, r3, #8
 8014880:	b2db      	uxtb	r3, r3
 8014882:	e016      	b.n	80148b2 <draw_letter_subpx+0x362>
 8014884:	080e5fd4 	.word	0x080e5fd4
 8014888:	080e5fd8 	.word	0x080e5fd8
 801488c:	080e5fdc 	.word	0x080e5fdc
 8014890:	080e5fec 	.word	0x080e5fec
 8014894:	55555556 	.word	0x55555556
                             : (uint32_t)((uint32_t)bpp_opa_table[letter_px] * opa) >> 8;
 8014898:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 801489c:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 80148a0:	4413      	add	r3, r2
 80148a2:	781b      	ldrb	r3, [r3, #0]
 80148a4:	461a      	mov	r2, r3
 80148a6:	f897 30b8 	ldrb.w	r3, [r7, #184]	; 0xb8
 80148aa:	fb02 f303 	mul.w	r3, r2, r3
 80148ae:	0a1b      	lsrs	r3, r3, #8
                    px_opa = bpp == 8 ? (uint32_t)((uint32_t)letter_px * opa) >> 8
 80148b0:	b2db      	uxtb	r3, r3
 80148b2:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
 80148b6:	e002      	b.n	80148be <draw_letter_subpx+0x36e>
                }
            }
            else {
                px_opa = 0;
 80148b8:	2300      	movs	r3, #0
 80148ba:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
            }

            font_rgb[subpx_cnt] = px_opa;
 80148be:	f107 021c 	add.w	r2, r7, #28
 80148c2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80148c4:	4413      	add	r3, r2
 80148c6:	f897 207f 	ldrb.w	r2, [r7, #127]	; 0x7f
 80148ca:	701a      	strb	r2, [r3, #0]

            subpx_cnt ++;
 80148cc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80148ce:	3301      	adds	r3, #1
 80148d0:	66fb      	str	r3, [r7, #108]	; 0x6c
            if(subpx_cnt == 3) {
 80148d2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 80148d4:	2b03      	cmp	r3, #3
 80148d6:	d16f      	bne.n	80149b8 <draw_letter_subpx+0x468>
                subpx_cnt = 0;
 80148d8:	2300      	movs	r3, #0
 80148da:	66fb      	str	r3, [r7, #108]	; 0x6c

                lv_color_t res_color;
#if LV_COLOR_16_SWAP == 0
                uint8_t bg_rgb[3] = {vdb_buf_tmp->ch.red, vdb_buf_tmp->ch.green, vdb_buf_tmp->ch.blue};
 80148dc:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80148de:	785b      	ldrb	r3, [r3, #1]
 80148e0:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80148e4:	b2db      	uxtb	r3, r3
 80148e6:	743b      	strb	r3, [r7, #16]
 80148e8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80148ea:	881b      	ldrh	r3, [r3, #0]
 80148ec:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80148f0:	b2db      	uxtb	r3, r3
 80148f2:	747b      	strb	r3, [r7, #17]
 80148f4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80148f6:	781b      	ldrb	r3, [r3, #0]
 80148f8:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80148fc:	b2db      	uxtb	r3, r3
 80148fe:	74bb      	strb	r3, [r7, #18]

#if LV_FONT_SUBPX_BGR
                res_color.ch.blue = (uint32_t)((uint32_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8;
                res_color.ch.red = (uint32_t)((uint32_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8;
#else
                res_color.ch.red = (uint32_t)((uint16_t)txt_rgb[0] * font_rgb[0] + (bg_rgb[0] * (255 - font_rgb[0]))) >> 8;
 8014900:	7e3b      	ldrb	r3, [r7, #24]
 8014902:	7f3a      	ldrb	r2, [r7, #28]
 8014904:	fb03 f202 	mul.w	r2, r3, r2
 8014908:	7c3b      	ldrb	r3, [r7, #16]
 801490a:	4619      	mov	r1, r3
 801490c:	7f3b      	ldrb	r3, [r7, #28]
 801490e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8014912:	fb01 f303 	mul.w	r3, r1, r3
 8014916:	4413      	add	r3, r2
 8014918:	0a1b      	lsrs	r3, r3, #8
 801491a:	f003 031f 	and.w	r3, r3, #31
 801491e:	b2da      	uxtb	r2, r3
 8014920:	7d7b      	ldrb	r3, [r7, #21]
 8014922:	f362 03c7 	bfi	r3, r2, #3, #5
 8014926:	757b      	strb	r3, [r7, #21]
                res_color.ch.blue = (uint32_t)((uint16_t)txt_rgb[2] * font_rgb[2] + (bg_rgb[2] * (255 - font_rgb[2]))) >> 8;
 8014928:	7ebb      	ldrb	r3, [r7, #26]
 801492a:	7fba      	ldrb	r2, [r7, #30]
 801492c:	fb03 f202 	mul.w	r2, r3, r2
 8014930:	7cbb      	ldrb	r3, [r7, #18]
 8014932:	4619      	mov	r1, r3
 8014934:	7fbb      	ldrb	r3, [r7, #30]
 8014936:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801493a:	fb01 f303 	mul.w	r3, r1, r3
 801493e:	4413      	add	r3, r2
 8014940:	0a1b      	lsrs	r3, r3, #8
 8014942:	f003 031f 	and.w	r3, r3, #31
 8014946:	b2da      	uxtb	r2, r3
 8014948:	7d3b      	ldrb	r3, [r7, #20]
 801494a:	f362 0304 	bfi	r3, r2, #0, #5
 801494e:	753b      	strb	r3, [r7, #20]
#endif

#if LV_COLOR_16_SWAP == 0
                res_color.ch.green = (uint32_t)((uint32_t)txt_rgb[1] * font_rgb[1] + (bg_rgb[1] * (255 - font_rgb[1]))) >> 8;
 8014950:	7e7b      	ldrb	r3, [r7, #25]
 8014952:	7f7a      	ldrb	r2, [r7, #29]
 8014954:	fb02 f303 	mul.w	r3, r2, r3
 8014958:	7c7a      	ldrb	r2, [r7, #17]
 801495a:	4611      	mov	r1, r2
 801495c:	7f7a      	ldrb	r2, [r7, #29]
 801495e:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
 8014962:	fb01 f202 	mul.w	r2, r1, r2
 8014966:	4413      	add	r3, r2
 8014968:	0a1b      	lsrs	r3, r3, #8
 801496a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801496e:	b2da      	uxtb	r2, r3
 8014970:	8abb      	ldrh	r3, [r7, #20]
 8014972:	f362 134a 	bfi	r3, r2, #5, #6
 8014976:	82bb      	strh	r3, [r7, #20]

#if LV_COLOR_DEPTH == 32
                res_color.ch.alpha =  0xff;
#endif

                if(font_rgb[0] == 0 && font_rgb[1] == 0 && font_rgb[2] == 0) mask_buf[mask_p] = LV_OPA_TRANSP;
 8014978:	7f3b      	ldrb	r3, [r7, #28]
 801497a:	2b00      	cmp	r3, #0
 801497c:	d10b      	bne.n	8014996 <draw_letter_subpx+0x446>
 801497e:	7f7b      	ldrb	r3, [r7, #29]
 8014980:	2b00      	cmp	r3, #0
 8014982:	d108      	bne.n	8014996 <draw_letter_subpx+0x446>
 8014984:	7fbb      	ldrb	r3, [r7, #30]
 8014986:	2b00      	cmp	r3, #0
 8014988:	d105      	bne.n	8014996 <draw_letter_subpx+0x446>
 801498a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801498c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801498e:	4413      	add	r3, r2
 8014990:	2200      	movs	r2, #0
 8014992:	701a      	strb	r2, [r3, #0]
 8014994:	e004      	b.n	80149a0 <draw_letter_subpx+0x450>
                else mask_buf[mask_p] = LV_OPA_COVER;
 8014996:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014998:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801499a:	4413      	add	r3, r2
 801499c:	22ff      	movs	r2, #255	; 0xff
 801499e:	701a      	strb	r2, [r3, #0]
                color_buf[mask_p] = res_color;
 80149a0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80149a2:	005b      	lsls	r3, r3, #1
 80149a4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80149a6:	4413      	add	r3, r2
 80149a8:	8aba      	ldrh	r2, [r7, #20]
 80149aa:	801a      	strh	r2, [r3, #0]

                /*Next mask byte*/
                mask_p++;
 80149ac:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80149ae:	3301      	adds	r3, #1
 80149b0:	677b      	str	r3, [r7, #116]	; 0x74
                vdb_buf_tmp++;
 80149b2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80149b4:	3302      	adds	r3, #2
 80149b6:	673b      	str	r3, [r7, #112]	; 0x70
            }

            /*Go to the next column*/
            if(col_bit < (int32_t)(8 - bpp)) {
 80149b8:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80149bc:	f1c3 0308 	rsb	r3, r3, #8
 80149c0:	461a      	mov	r2, r3
 80149c2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80149c4:	4293      	cmp	r3, r2
 80149c6:	da0d      	bge.n	80149e4 <draw_letter_subpx+0x494>
                col_bit += bpp;
 80149c8:	6fba      	ldr	r2, [r7, #120]	; 0x78
 80149ca:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80149ce:	4413      	add	r3, r2
 80149d0:	67bb      	str	r3, [r7, #120]	; 0x78
                bitmask = bitmask >> bpp;
 80149d2:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 80149d6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80149da:	fa22 f303 	lsr.w	r3, r2, r3
 80149de:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
 80149e2:	e00a      	b.n	80149fa <draw_letter_subpx+0x4aa>
            }
            else {
                col_bit = 0;
 80149e4:	2300      	movs	r3, #0
 80149e6:	67bb      	str	r3, [r7, #120]	; 0x78
                bitmask = bitmask_init;
 80149e8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 80149ec:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                map_p++;
 80149f0:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 80149f4:	3301      	adds	r3, #1
 80149f6:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
        for(col = col_start; col < col_end; col++) {
 80149fa:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80149fe:	3301      	adds	r3, #1
 8014a00:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8014a04:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8014a08:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014a0a:	429a      	cmp	r2, r3
 8014a0c:	f6ff af04 	blt.w	8014818 <draw_letter_subpx+0x2c8>
            }
        }

        /*Apply masks if any*/
        if(other_mask_cnt) {
 8014a10:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8014a14:	2b00      	cmp	r3, #0
 8014a16:	d025      	beq.n	8014a64 <draw_letter_subpx+0x514>
            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf + mask_p_start, map_area.x1, map_area.y2,
 8014a18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014a1a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8014a1c:	18d4      	adds	r4, r2, r3
 8014a1e:	f9b7 5020 	ldrsh.w	r5, [r7, #32]
 8014a22:	f9b7 6026 	ldrsh.w	r6, [r7, #38]	; 0x26
 8014a26:	f107 0320 	add.w	r3, r7, #32
 8014a2a:	4618      	mov	r0, r3
 8014a2c:	f7fe fc46 	bl	80132bc <lv_area_get_width>
 8014a30:	4603      	mov	r3, r0
 8014a32:	4632      	mov	r2, r6
 8014a34:	4629      	mov	r1, r5
 8014a36:	4620      	mov	r0, r4
 8014a38:	f001 fabc 	bl	8015fb4 <lv_draw_mask_apply>
 8014a3c:	4603      	mov	r3, r0
 8014a3e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
                                                             lv_area_get_width(&map_area));
            if(mask_res == LV_DRAW_MASK_RES_TRANSP) {
 8014a42:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8014a46:	2b00      	cmp	r3, #0
 8014a48:	d10c      	bne.n	8014a64 <draw_letter_subpx+0x514>
                _lv_memset_00(mask_buf + mask_p_start, lv_area_get_width(&map_area));
 8014a4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014a4c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8014a4e:	18d4      	adds	r4, r2, r3
 8014a50:	f107 0320 	add.w	r3, r7, #32
 8014a54:	4618      	mov	r0, r3
 8014a56:	f7fe fc31 	bl	80132bc <lv_area_get_width>
 8014a5a:	4603      	mov	r3, r0
 8014a5c:	4619      	mov	r1, r3
 8014a5e:	4620      	mov	r0, r4
 8014a60:	f00c fe22 	bl	80216a8 <_lv_memset_00>
            }
        }

        if((int32_t) mask_p + (col_end - col_start) < mask_buf_size) {
 8014a64:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8014a66:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8014a68:	1ad2      	subs	r2, r2, r3
 8014a6a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014a6c:	4413      	add	r3, r2
 8014a6e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8014a70:	429a      	cmp	r2, r3
 8014a72:	dd07      	ble.n	8014a84 <draw_letter_subpx+0x534>
            map_area.y2 ++;
 8014a74:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8014a78:	b29b      	uxth	r3, r3
 8014a7a:	3301      	adds	r3, #1
 8014a7c:	b29b      	uxth	r3, r3
 8014a7e:	b21b      	sxth	r3, r3
 8014a80:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014a82:	e01a      	b.n	8014aba <draw_letter_subpx+0x56a>
        }
        else {
            _lv_blend_map(clip_area, &map_area, color_buf, mask_buf, LV_DRAW_MASK_RES_CHANGED, opa, blend_mode);
 8014a84:	f107 0120 	add.w	r1, r7, #32
 8014a88:	f897 30bc 	ldrb.w	r3, [r7, #188]	; 0xbc
 8014a8c:	9302      	str	r3, [sp, #8]
 8014a8e:	f897 30b8 	ldrb.w	r3, [r7, #184]	; 0xb8
 8014a92:	9301      	str	r3, [sp, #4]
 8014a94:	2302      	movs	r3, #2
 8014a96:	9300      	str	r3, [sp, #0]
 8014a98:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8014a9a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8014a9c:	6878      	ldr	r0, [r7, #4]
 8014a9e:	f7fb ffa9 	bl	80109f4 <_lv_blend_map>

            map_area.y1 = map_area.y2 + 1;
 8014aa2:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8014aa6:	b29b      	uxth	r3, r3
 8014aa8:	3301      	adds	r3, #1
 8014aaa:	b29b      	uxth	r3, r3
 8014aac:	b21b      	sxth	r3, r3
 8014aae:	847b      	strh	r3, [r7, #34]	; 0x22
            map_area.y2 = map_area.y1;
 8014ab0:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8014ab4:	84fb      	strh	r3, [r7, #38]	; 0x26
            mask_p = 0;
 8014ab6:	2300      	movs	r3, #0
 8014ab8:	677b      	str	r3, [r7, #116]	; 0x74
        }

        col_bit += ((box_w - col_end) + col_start) * bpp;
 8014aba:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8014abc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8014abe:	1ad2      	subs	r2, r2, r3
 8014ac0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8014ac2:	4413      	add	r3, r2
 8014ac4:	461a      	mov	r2, r3
 8014ac6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8014aca:	fb03 f202 	mul.w	r2, r3, r2
 8014ace:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014ad0:	4413      	add	r3, r2
 8014ad2:	67bb      	str	r3, [r7, #120]	; 0x78

        map_p += (col_bit >> 3);
 8014ad4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014ad6:	10db      	asrs	r3, r3, #3
 8014ad8:	461a      	mov	r2, r3
 8014ada:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8014ade:	4413      	add	r3, r2
 8014ae0:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
        col_bit = col_bit & 0x7;
 8014ae4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014ae6:	f003 0307 	and.w	r3, r3, #7
 8014aea:	67bb      	str	r3, [r7, #120]	; 0x78

        /*Next row in VDB*/
        vdb_buf_tmp += vdb_width - (col_end - col_start) / 3;
 8014aec:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8014aee:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8014af0:	1ad3      	subs	r3, r2, r3
 8014af2:	4a1e      	ldr	r2, [pc, #120]	; (8014b6c <draw_letter_subpx+0x61c>)
 8014af4:	fb82 1203 	smull	r1, r2, r2, r3
 8014af8:	17db      	asrs	r3, r3, #31
 8014afa:	1a9a      	subs	r2, r3, r2
 8014afc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014afe:	4413      	add	r3, r2
 8014b00:	005b      	lsls	r3, r3, #1
 8014b02:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8014b04:	4413      	add	r3, r2
 8014b06:	673b      	str	r3, [r7, #112]	; 0x70
    for(row = row_start ; row < row_end; row++) {
 8014b08:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8014b0c:	3301      	adds	r3, #1
 8014b0e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
 8014b12:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8014b16:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8014b18:	429a      	cmp	r2, r3
 8014b1a:	f6ff ae6e 	blt.w	80147fa <draw_letter_subpx+0x2aa>
    }

    /*Flush the last part*/
    if(map_area.y1 != map_area.y2) {
 8014b1e:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 8014b22:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8014b26:	429a      	cmp	r2, r3
 8014b28:	d015      	beq.n	8014b56 <draw_letter_subpx+0x606>
        map_area.y2--;
 8014b2a:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8014b2e:	b29b      	uxth	r3, r3
 8014b30:	3b01      	subs	r3, #1
 8014b32:	b29b      	uxth	r3, r3
 8014b34:	b21b      	sxth	r3, r3
 8014b36:	84fb      	strh	r3, [r7, #38]	; 0x26
        _lv_blend_map(clip_area, &map_area, color_buf, mask_buf, LV_DRAW_MASK_RES_CHANGED, opa, blend_mode);
 8014b38:	f107 0120 	add.w	r1, r7, #32
 8014b3c:	f897 30bc 	ldrb.w	r3, [r7, #188]	; 0xbc
 8014b40:	9302      	str	r3, [sp, #8]
 8014b42:	f897 30b8 	ldrb.w	r3, [r7, #184]	; 0xb8
 8014b46:	9301      	str	r3, [sp, #4]
 8014b48:	2302      	movs	r3, #2
 8014b4a:	9300      	str	r3, [sp, #0]
 8014b4c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8014b4e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8014b50:	6878      	ldr	r0, [r7, #4]
 8014b52:	f7fb ff4f 	bl	80109f4 <_lv_blend_map>
    }

    _lv_mem_buf_release(mask_buf);
 8014b56:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8014b58:	f00c fa7a 	bl	8021050 <_lv_mem_buf_release>
    _lv_mem_buf_release(color_buf);
 8014b5c:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8014b5e:	f00c fa77 	bl	8021050 <_lv_mem_buf_release>
 8014b62:	e000      	b.n	8014b66 <draw_letter_subpx+0x616>
            return; /*Invalid bpp. Can't render the letter*/
 8014b64:	bf00      	nop
#else
    LV_LOG_WARN("Can't draw sub-pixel rendered letter because LV_USE_FONT_SUBPX == 0 in lv_conf.h");
#endif
}
 8014b66:	379c      	adds	r7, #156	; 0x9c
 8014b68:	46bd      	mov	sp, r7
 8014b6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8014b6c:	55555556 	.word	0x55555556

08014b70 <hex_char_to_num>:
 * Convert a hexadecimal characters to a number (0..15)
 * @param hex Pointer to a hexadecimal character (0..9, A..F)
 * @return the numerical value of `hex` or 0 on error
 */
static uint8_t hex_char_to_num(char hex)
{
 8014b70:	b480      	push	{r7}
 8014b72:	b085      	sub	sp, #20
 8014b74:	af00      	add	r7, sp, #0
 8014b76:	4603      	mov	r3, r0
 8014b78:	71fb      	strb	r3, [r7, #7]
    uint8_t result = 0;
 8014b7a:	2300      	movs	r3, #0
 8014b7c:	73fb      	strb	r3, [r7, #15]

    if(hex >= '0' && hex <= '9') {
 8014b7e:	79fb      	ldrb	r3, [r7, #7]
 8014b80:	2b2f      	cmp	r3, #47	; 0x2f
 8014b82:	d906      	bls.n	8014b92 <hex_char_to_num+0x22>
 8014b84:	79fb      	ldrb	r3, [r7, #7]
 8014b86:	2b39      	cmp	r3, #57	; 0x39
 8014b88:	d803      	bhi.n	8014b92 <hex_char_to_num+0x22>
        result = hex - '0';
 8014b8a:	79fb      	ldrb	r3, [r7, #7]
 8014b8c:	3b30      	subs	r3, #48	; 0x30
 8014b8e:	73fb      	strb	r3, [r7, #15]
 8014b90:	e02d      	b.n	8014bee <hex_char_to_num+0x7e>
    }
    else {
        if(hex >= 'a') hex -= 'a' - 'A'; /*Convert to upper case*/
 8014b92:	79fb      	ldrb	r3, [r7, #7]
 8014b94:	2b60      	cmp	r3, #96	; 0x60
 8014b96:	d902      	bls.n	8014b9e <hex_char_to_num+0x2e>
 8014b98:	79fb      	ldrb	r3, [r7, #7]
 8014b9a:	3b20      	subs	r3, #32
 8014b9c:	71fb      	strb	r3, [r7, #7]

        switch(hex) {
 8014b9e:	79fb      	ldrb	r3, [r7, #7]
 8014ba0:	3b41      	subs	r3, #65	; 0x41
 8014ba2:	2b05      	cmp	r3, #5
 8014ba4:	d820      	bhi.n	8014be8 <hex_char_to_num+0x78>
 8014ba6:	a201      	add	r2, pc, #4	; (adr r2, 8014bac <hex_char_to_num+0x3c>)
 8014ba8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014bac:	08014bc5 	.word	0x08014bc5
 8014bb0:	08014bcb 	.word	0x08014bcb
 8014bb4:	08014bd1 	.word	0x08014bd1
 8014bb8:	08014bd7 	.word	0x08014bd7
 8014bbc:	08014bdd 	.word	0x08014bdd
 8014bc0:	08014be3 	.word	0x08014be3
            case 'A':
                result = 10;
 8014bc4:	230a      	movs	r3, #10
 8014bc6:	73fb      	strb	r3, [r7, #15]
                break;
 8014bc8:	e011      	b.n	8014bee <hex_char_to_num+0x7e>
            case 'B':
                result = 11;
 8014bca:	230b      	movs	r3, #11
 8014bcc:	73fb      	strb	r3, [r7, #15]
                break;
 8014bce:	e00e      	b.n	8014bee <hex_char_to_num+0x7e>
            case 'C':
                result = 12;
 8014bd0:	230c      	movs	r3, #12
 8014bd2:	73fb      	strb	r3, [r7, #15]
                break;
 8014bd4:	e00b      	b.n	8014bee <hex_char_to_num+0x7e>
            case 'D':
                result = 13;
 8014bd6:	230d      	movs	r3, #13
 8014bd8:	73fb      	strb	r3, [r7, #15]
                break;
 8014bda:	e008      	b.n	8014bee <hex_char_to_num+0x7e>
            case 'E':
                result = 14;
 8014bdc:	230e      	movs	r3, #14
 8014bde:	73fb      	strb	r3, [r7, #15]
                break;
 8014be0:	e005      	b.n	8014bee <hex_char_to_num+0x7e>
            case 'F':
                result = 15;
 8014be2:	230f      	movs	r3, #15
 8014be4:	73fb      	strb	r3, [r7, #15]
                break;
 8014be6:	e002      	b.n	8014bee <hex_char_to_num+0x7e>
            default:
                result = 0;
 8014be8:	2300      	movs	r3, #0
 8014bea:	73fb      	strb	r3, [r7, #15]
                break;
 8014bec:	bf00      	nop
        }
    }

    return result;
 8014bee:	7bfb      	ldrb	r3, [r7, #15]
}
 8014bf0:	4618      	mov	r0, r3
 8014bf2:	3714      	adds	r7, #20
 8014bf4:	46bd      	mov	sp, r7
 8014bf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014bfa:	4770      	bx	lr

08014bfc <lv_area_get_width>:
{
 8014bfc:	b480      	push	{r7}
 8014bfe:	b083      	sub	sp, #12
 8014c00:	af00      	add	r7, sp, #0
 8014c02:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 8014c04:	687b      	ldr	r3, [r7, #4]
 8014c06:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8014c0a:	b29a      	uxth	r2, r3
 8014c0c:	687b      	ldr	r3, [r7, #4]
 8014c0e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014c12:	b29b      	uxth	r3, r3
 8014c14:	1ad3      	subs	r3, r2, r3
 8014c16:	b29b      	uxth	r3, r3
 8014c18:	3301      	adds	r3, #1
 8014c1a:	b29b      	uxth	r3, r3
 8014c1c:	b21b      	sxth	r3, r3
}
 8014c1e:	4618      	mov	r0, r3
 8014c20:	370c      	adds	r7, #12
 8014c22:	46bd      	mov	sp, r7
 8014c24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014c28:	4770      	bx	lr

08014c2a <lv_draw_line_dsc_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

LV_ATTRIBUTE_FAST_MEM void lv_draw_line_dsc_init(lv_draw_line_dsc_t * dsc)
{
 8014c2a:	b580      	push	{r7, lr}
 8014c2c:	b082      	sub	sp, #8
 8014c2e:	af00      	add	r7, sp, #0
 8014c30:	6078      	str	r0, [r7, #4]
    _lv_memset_00(dsc, sizeof(lv_draw_line_dsc_t));
 8014c32:	210a      	movs	r1, #10
 8014c34:	6878      	ldr	r0, [r7, #4]
 8014c36:	f00c fd37 	bl	80216a8 <_lv_memset_00>
    dsc->width = 1;
 8014c3a:	687b      	ldr	r3, [r7, #4]
 8014c3c:	2201      	movs	r2, #1
 8014c3e:	805a      	strh	r2, [r3, #2]
    dsc->opa = LV_OPA_COVER;
 8014c40:	687b      	ldr	r3, [r7, #4]
 8014c42:	22ff      	movs	r2, #255	; 0xff
 8014c44:	721a      	strb	r2, [r3, #8]
    dsc->color = LV_COLOR_BLACK;
 8014c46:	687a      	ldr	r2, [r7, #4]
 8014c48:	7813      	ldrb	r3, [r2, #0]
 8014c4a:	f36f 0304 	bfc	r3, #0, #5
 8014c4e:	7013      	strb	r3, [r2, #0]
 8014c50:	687a      	ldr	r2, [r7, #4]
 8014c52:	8813      	ldrh	r3, [r2, #0]
 8014c54:	f36f 134a 	bfc	r3, #5, #6
 8014c58:	8013      	strh	r3, [r2, #0]
 8014c5a:	687a      	ldr	r2, [r7, #4]
 8014c5c:	7853      	ldrb	r3, [r2, #1]
 8014c5e:	f36f 03c7 	bfc	r3, #3, #5
 8014c62:	7053      	strb	r3, [r2, #1]
}
 8014c64:	bf00      	nop
 8014c66:	3708      	adds	r7, #8
 8014c68:	46bd      	mov	sp, r7
 8014c6a:	bd80      	pop	{r7, pc}

08014c6c <lv_draw_line>:
 * @param clip the line will be drawn only in this area
 * @param dsc pointer to an initialized `lv_draw_line_dsc_t` variable
 */
LV_ATTRIBUTE_FAST_MEM void lv_draw_line(const lv_point_t * point1, const lv_point_t * point2, const lv_area_t * clip,
                                        const lv_draw_line_dsc_t * dsc)
{
 8014c6c:	b580      	push	{r7, lr}
 8014c6e:	b0a0      	sub	sp, #128	; 0x80
 8014c70:	af00      	add	r7, sp, #0
 8014c72:	60f8      	str	r0, [r7, #12]
 8014c74:	60b9      	str	r1, [r7, #8]
 8014c76:	607a      	str	r2, [r7, #4]
 8014c78:	603b      	str	r3, [r7, #0]
    if(dsc->width == 0) return;
 8014c7a:	683b      	ldr	r3, [r7, #0]
 8014c7c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014c80:	2b00      	cmp	r3, #0
 8014c82:	f000 8166 	beq.w	8014f52 <lv_draw_line+0x2e6>
    if(dsc->opa <= LV_OPA_MIN) return;
 8014c86:	683b      	ldr	r3, [r7, #0]
 8014c88:	7a1b      	ldrb	r3, [r3, #8]
 8014c8a:	2b02      	cmp	r3, #2
 8014c8c:	f240 8163 	bls.w	8014f56 <lv_draw_line+0x2ea>

    if(point1->x == point2->x && point1->y == point2->y) return;
 8014c90:	68fb      	ldr	r3, [r7, #12]
 8014c92:	f9b3 2000 	ldrsh.w	r2, [r3]
 8014c96:	68bb      	ldr	r3, [r7, #8]
 8014c98:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014c9c:	429a      	cmp	r2, r3
 8014c9e:	d108      	bne.n	8014cb2 <lv_draw_line+0x46>
 8014ca0:	68fb      	ldr	r3, [r7, #12]
 8014ca2:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8014ca6:	68bb      	ldr	r3, [r7, #8]
 8014ca8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014cac:	429a      	cmp	r2, r3
 8014cae:	f000 8154 	beq.w	8014f5a <lv_draw_line+0x2ee>

    lv_area_t clip_line;
    clip_line.x1 = LV_MATH_MIN(point1->x, point2->x) - dsc->width / 2;
 8014cb2:	68bb      	ldr	r3, [r7, #8]
 8014cb4:	f9b3 2000 	ldrsh.w	r2, [r3]
 8014cb8:	68fb      	ldr	r3, [r7, #12]
 8014cba:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014cbe:	4293      	cmp	r3, r2
 8014cc0:	bfa8      	it	ge
 8014cc2:	4613      	movge	r3, r2
 8014cc4:	b21b      	sxth	r3, r3
 8014cc6:	b29a      	uxth	r2, r3
 8014cc8:	683b      	ldr	r3, [r7, #0]
 8014cca:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014cce:	0fd9      	lsrs	r1, r3, #31
 8014cd0:	440b      	add	r3, r1
 8014cd2:	105b      	asrs	r3, r3, #1
 8014cd4:	b21b      	sxth	r3, r3
 8014cd6:	b29b      	uxth	r3, r3
 8014cd8:	1ad3      	subs	r3, r2, r3
 8014cda:	b29b      	uxth	r3, r3
 8014cdc:	b21b      	sxth	r3, r3
 8014cde:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
    clip_line.x2 = LV_MATH_MAX(point1->x, point2->x) + dsc->width / 2;
 8014ce2:	68bb      	ldr	r3, [r7, #8]
 8014ce4:	f9b3 2000 	ldrsh.w	r2, [r3]
 8014ce8:	68fb      	ldr	r3, [r7, #12]
 8014cea:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014cee:	4293      	cmp	r3, r2
 8014cf0:	bfb8      	it	lt
 8014cf2:	4613      	movlt	r3, r2
 8014cf4:	b21b      	sxth	r3, r3
 8014cf6:	b29a      	uxth	r2, r3
 8014cf8:	683b      	ldr	r3, [r7, #0]
 8014cfa:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014cfe:	0fd9      	lsrs	r1, r3, #31
 8014d00:	440b      	add	r3, r1
 8014d02:	105b      	asrs	r3, r3, #1
 8014d04:	b21b      	sxth	r3, r3
 8014d06:	b29b      	uxth	r3, r3
 8014d08:	4413      	add	r3, r2
 8014d0a:	b29b      	uxth	r3, r3
 8014d0c:	b21b      	sxth	r3, r3
 8014d0e:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
    clip_line.y1 = LV_MATH_MIN(point1->y, point2->y) - dsc->width / 2;
 8014d12:	68bb      	ldr	r3, [r7, #8]
 8014d14:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8014d18:	68fb      	ldr	r3, [r7, #12]
 8014d1a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014d1e:	4293      	cmp	r3, r2
 8014d20:	bfa8      	it	ge
 8014d22:	4613      	movge	r3, r2
 8014d24:	b21b      	sxth	r3, r3
 8014d26:	b29a      	uxth	r2, r3
 8014d28:	683b      	ldr	r3, [r7, #0]
 8014d2a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014d2e:	0fd9      	lsrs	r1, r3, #31
 8014d30:	440b      	add	r3, r1
 8014d32:	105b      	asrs	r3, r3, #1
 8014d34:	b21b      	sxth	r3, r3
 8014d36:	b29b      	uxth	r3, r3
 8014d38:	1ad3      	subs	r3, r2, r3
 8014d3a:	b29b      	uxth	r3, r3
 8014d3c:	b21b      	sxth	r3, r3
 8014d3e:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
    clip_line.y2 = LV_MATH_MAX(point1->y, point2->y) + dsc->width / 2;
 8014d42:	68bb      	ldr	r3, [r7, #8]
 8014d44:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8014d48:	68fb      	ldr	r3, [r7, #12]
 8014d4a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014d4e:	4293      	cmp	r3, r2
 8014d50:	bfb8      	it	lt
 8014d52:	4613      	movlt	r3, r2
 8014d54:	b21b      	sxth	r3, r3
 8014d56:	b29a      	uxth	r2, r3
 8014d58:	683b      	ldr	r3, [r7, #0]
 8014d5a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014d5e:	0fd9      	lsrs	r1, r3, #31
 8014d60:	440b      	add	r3, r1
 8014d62:	105b      	asrs	r3, r3, #1
 8014d64:	b21b      	sxth	r3, r3
 8014d66:	b29b      	uxth	r3, r3
 8014d68:	4413      	add	r3, r2
 8014d6a:	b29b      	uxth	r3, r3
 8014d6c:	b21b      	sxth	r3, r3
 8014d6e:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

    bool is_common;
    is_common = _lv_area_intersect(&clip_line, &clip_line, clip);
 8014d72:	f107 016c 	add.w	r1, r7, #108	; 0x6c
 8014d76:	f107 036c 	add.w	r3, r7, #108	; 0x6c
 8014d7a:	687a      	ldr	r2, [r7, #4]
 8014d7c:	4618      	mov	r0, r3
 8014d7e:	f00a fb75 	bl	801f46c <_lv_area_intersect>
 8014d82:	4603      	mov	r3, r0
 8014d84:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
    if(!is_common) return;
 8014d88:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
 8014d8c:	f083 0301 	eor.w	r3, r3, #1
 8014d90:	b2db      	uxtb	r3, r3
 8014d92:	2b00      	cmp	r3, #0
 8014d94:	f040 80e3 	bne.w	8014f5e <lv_draw_line+0x2f2>

    if(point1->y == point2->y) draw_line_hor(point1, point2, &clip_line, dsc);
 8014d98:	68fb      	ldr	r3, [r7, #12]
 8014d9a:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8014d9e:	68bb      	ldr	r3, [r7, #8]
 8014da0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014da4:	429a      	cmp	r2, r3
 8014da6:	d107      	bne.n	8014db8 <lv_draw_line+0x14c>
 8014da8:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 8014dac:	683b      	ldr	r3, [r7, #0]
 8014dae:	68b9      	ldr	r1, [r7, #8]
 8014db0:	68f8      	ldr	r0, [r7, #12]
 8014db2:	f000 f8d8 	bl	8014f66 <draw_line_hor>
 8014db6:	e016      	b.n	8014de6 <lv_draw_line+0x17a>
    else if(point1->x == point2->x) draw_line_ver(point1, point2, &clip_line, dsc);
 8014db8:	68fb      	ldr	r3, [r7, #12]
 8014dba:	f9b3 2000 	ldrsh.w	r2, [r3]
 8014dbe:	68bb      	ldr	r3, [r7, #8]
 8014dc0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014dc4:	429a      	cmp	r2, r3
 8014dc6:	d107      	bne.n	8014dd8 <lv_draw_line+0x16c>
 8014dc8:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 8014dcc:	683b      	ldr	r3, [r7, #0]
 8014dce:	68b9      	ldr	r1, [r7, #8]
 8014dd0:	68f8      	ldr	r0, [r7, #12]
 8014dd2:	f000 fa97 	bl	8015304 <draw_line_ver>
 8014dd6:	e006      	b.n	8014de6 <lv_draw_line+0x17a>
    else draw_line_skew(point1, point2, &clip_line, dsc);
 8014dd8:	f107 026c 	add.w	r2, r7, #108	; 0x6c
 8014ddc:	683b      	ldr	r3, [r7, #0]
 8014dde:	68b9      	ldr	r1, [r7, #8]
 8014de0:	68f8      	ldr	r0, [r7, #12]
 8014de2:	f000 fc29 	bl	8015638 <draw_line_skew>


    if(dsc->round_end || dsc->round_start) {
 8014de6:	683b      	ldr	r3, [r7, #0]
 8014de8:	7a5b      	ldrb	r3, [r3, #9]
 8014dea:	f003 0308 	and.w	r3, r3, #8
 8014dee:	b2db      	uxtb	r3, r3
 8014df0:	2b00      	cmp	r3, #0
 8014df2:	d107      	bne.n	8014e04 <lv_draw_line+0x198>
 8014df4:	683b      	ldr	r3, [r7, #0]
 8014df6:	7a5b      	ldrb	r3, [r3, #9]
 8014df8:	f003 0304 	and.w	r3, r3, #4
 8014dfc:	b2db      	uxtb	r3, r3
 8014dfe:	2b00      	cmp	r3, #0
 8014e00:	f000 80ae 	beq.w	8014f60 <lv_draw_line+0x2f4>
        lv_draw_rect_dsc_t cir_dsc;
        lv_draw_rect_dsc_init(&cir_dsc);
 8014e04:	f107 0310 	add.w	r3, r7, #16
 8014e08:	4618      	mov	r0, r3
 8014e0a:	f002 fcfb 	bl	8017804 <lv_draw_rect_dsc_init>
        cir_dsc.bg_color = dsc->color;
 8014e0e:	683b      	ldr	r3, [r7, #0]
 8014e10:	881b      	ldrh	r3, [r3, #0]
 8014e12:	827b      	strh	r3, [r7, #18]
        cir_dsc.radius = LV_RADIUS_CIRCLE;
 8014e14:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8014e18:	823b      	strh	r3, [r7, #16]
        cir_dsc.bg_opa = dsc->opa;
 8014e1a:	683b      	ldr	r3, [r7, #0]
 8014e1c:	7a1b      	ldrb	r3, [r3, #8]
 8014e1e:	773b      	strb	r3, [r7, #28]

        int32_t r = (dsc->width >> 1);
 8014e20:	683b      	ldr	r3, [r7, #0]
 8014e22:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014e26:	105b      	asrs	r3, r3, #1
 8014e28:	b21b      	sxth	r3, r3
 8014e2a:	67bb      	str	r3, [r7, #120]	; 0x78
        int32_t r_corr = (dsc->width & 1) ? 0 : 1;
 8014e2c:	683b      	ldr	r3, [r7, #0]
 8014e2e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014e32:	b29b      	uxth	r3, r3
 8014e34:	f003 0301 	and.w	r3, r3, #1
 8014e38:	2b00      	cmp	r3, #0
 8014e3a:	bf0c      	ite	eq
 8014e3c:	2301      	moveq	r3, #1
 8014e3e:	2300      	movne	r3, #0
 8014e40:	b2db      	uxtb	r3, r3
 8014e42:	677b      	str	r3, [r7, #116]	; 0x74
        lv_area_t cir_area;

        if(dsc->round_start) {
 8014e44:	683b      	ldr	r3, [r7, #0]
 8014e46:	7a5b      	ldrb	r3, [r3, #9]
 8014e48:	f003 0304 	and.w	r3, r3, #4
 8014e4c:	b2db      	uxtb	r3, r3
 8014e4e:	2b00      	cmp	r3, #0
 8014e50:	d03b      	beq.n	8014eca <lv_draw_line+0x25e>
            cir_area.x1 = point1->x - r;
 8014e52:	68fb      	ldr	r3, [r7, #12]
 8014e54:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014e58:	b29a      	uxth	r2, r3
 8014e5a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014e5c:	b29b      	uxth	r3, r3
 8014e5e:	1ad3      	subs	r3, r2, r3
 8014e60:	b29b      	uxth	r3, r3
 8014e62:	b21b      	sxth	r3, r3
 8014e64:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
            cir_area.y1 = point1->y - r;
 8014e68:	68fb      	ldr	r3, [r7, #12]
 8014e6a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014e6e:	b29a      	uxth	r2, r3
 8014e70:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014e72:	b29b      	uxth	r3, r3
 8014e74:	1ad3      	subs	r3, r2, r3
 8014e76:	b29b      	uxth	r3, r3
 8014e78:	b21b      	sxth	r3, r3
 8014e7a:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
            cir_area.x2 = point1->x + r - r_corr;
 8014e7e:	68fb      	ldr	r3, [r7, #12]
 8014e80:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014e84:	b29a      	uxth	r2, r3
 8014e86:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014e88:	b29b      	uxth	r3, r3
 8014e8a:	4413      	add	r3, r2
 8014e8c:	b29a      	uxth	r2, r3
 8014e8e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014e90:	b29b      	uxth	r3, r3
 8014e92:	1ad3      	subs	r3, r2, r3
 8014e94:	b29b      	uxth	r3, r3
 8014e96:	b21b      	sxth	r3, r3
 8014e98:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
            cir_area.y2 = point1->y + r - r_corr ;
 8014e9c:	68fb      	ldr	r3, [r7, #12]
 8014e9e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014ea2:	b29a      	uxth	r2, r3
 8014ea4:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014ea6:	b29b      	uxth	r3, r3
 8014ea8:	4413      	add	r3, r2
 8014eaa:	b29a      	uxth	r2, r3
 8014eac:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014eae:	b29b      	uxth	r3, r3
 8014eb0:	1ad3      	subs	r3, r2, r3
 8014eb2:	b29b      	uxth	r3, r3
 8014eb4:	b21b      	sxth	r3, r3
 8014eb6:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
            lv_draw_rect(&cir_area, clip, &cir_dsc);
 8014eba:	f107 0210 	add.w	r2, r7, #16
 8014ebe:	f107 0364 	add.w	r3, r7, #100	; 0x64
 8014ec2:	6879      	ldr	r1, [r7, #4]
 8014ec4:	4618      	mov	r0, r3
 8014ec6:	f002 fd2b 	bl	8017920 <lv_draw_rect>
        }

        if(dsc->round_end) {
 8014eca:	683b      	ldr	r3, [r7, #0]
 8014ecc:	7a5b      	ldrb	r3, [r3, #9]
 8014ece:	f003 0308 	and.w	r3, r3, #8
 8014ed2:	b2db      	uxtb	r3, r3
 8014ed4:	2b00      	cmp	r3, #0
 8014ed6:	d043      	beq.n	8014f60 <lv_draw_line+0x2f4>
            cir_area.x1 = point2->x - r;
 8014ed8:	68bb      	ldr	r3, [r7, #8]
 8014eda:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014ede:	b29a      	uxth	r2, r3
 8014ee0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014ee2:	b29b      	uxth	r3, r3
 8014ee4:	1ad3      	subs	r3, r2, r3
 8014ee6:	b29b      	uxth	r3, r3
 8014ee8:	b21b      	sxth	r3, r3
 8014eea:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
            cir_area.y1 = point2->y - r;
 8014eee:	68bb      	ldr	r3, [r7, #8]
 8014ef0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014ef4:	b29a      	uxth	r2, r3
 8014ef6:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014ef8:	b29b      	uxth	r3, r3
 8014efa:	1ad3      	subs	r3, r2, r3
 8014efc:	b29b      	uxth	r3, r3
 8014efe:	b21b      	sxth	r3, r3
 8014f00:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
            cir_area.x2 = point2->x + r - r_corr;
 8014f04:	68bb      	ldr	r3, [r7, #8]
 8014f06:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014f0a:	b29a      	uxth	r2, r3
 8014f0c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014f0e:	b29b      	uxth	r3, r3
 8014f10:	4413      	add	r3, r2
 8014f12:	b29a      	uxth	r2, r3
 8014f14:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014f16:	b29b      	uxth	r3, r3
 8014f18:	1ad3      	subs	r3, r2, r3
 8014f1a:	b29b      	uxth	r3, r3
 8014f1c:	b21b      	sxth	r3, r3
 8014f1e:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
            cir_area.y2 = point2->y + r - r_corr ;
 8014f22:	68bb      	ldr	r3, [r7, #8]
 8014f24:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014f28:	b29a      	uxth	r2, r3
 8014f2a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8014f2c:	b29b      	uxth	r3, r3
 8014f2e:	4413      	add	r3, r2
 8014f30:	b29a      	uxth	r2, r3
 8014f32:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8014f34:	b29b      	uxth	r3, r3
 8014f36:	1ad3      	subs	r3, r2, r3
 8014f38:	b29b      	uxth	r3, r3
 8014f3a:	b21b      	sxth	r3, r3
 8014f3c:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
            lv_draw_rect(&cir_area, clip, &cir_dsc);
 8014f40:	f107 0210 	add.w	r2, r7, #16
 8014f44:	f107 0364 	add.w	r3, r7, #100	; 0x64
 8014f48:	6879      	ldr	r1, [r7, #4]
 8014f4a:	4618      	mov	r0, r3
 8014f4c:	f002 fce8 	bl	8017920 <lv_draw_rect>
 8014f50:	e006      	b.n	8014f60 <lv_draw_line+0x2f4>
    if(dsc->width == 0) return;
 8014f52:	bf00      	nop
 8014f54:	e004      	b.n	8014f60 <lv_draw_line+0x2f4>
    if(dsc->opa <= LV_OPA_MIN) return;
 8014f56:	bf00      	nop
 8014f58:	e002      	b.n	8014f60 <lv_draw_line+0x2f4>
    if(point1->x == point2->x && point1->y == point2->y) return;
 8014f5a:	bf00      	nop
 8014f5c:	e000      	b.n	8014f60 <lv_draw_line+0x2f4>
    if(!is_common) return;
 8014f5e:	bf00      	nop
        }
    }
}
 8014f60:	3780      	adds	r7, #128	; 0x80
 8014f62:	46bd      	mov	sp, r7
 8014f64:	bd80      	pop	{r7, pc}

08014f66 <draw_line_hor>:
 **********************/

LV_ATTRIBUTE_FAST_MEM static void draw_line_hor(const lv_point_t * point1, const lv_point_t * point2,
                                                const lv_area_t * clip,
                                                const lv_draw_line_dsc_t * dsc)
{
 8014f66:	b580      	push	{r7, lr}
 8014f68:	b09a      	sub	sp, #104	; 0x68
 8014f6a:	af04      	add	r7, sp, #16
 8014f6c:	60f8      	str	r0, [r7, #12]
 8014f6e:	60b9      	str	r1, [r7, #8]
 8014f70:	607a      	str	r2, [r7, #4]
 8014f72:	603b      	str	r3, [r7, #0]
    lv_opa_t opa = dsc->opa;
 8014f74:	683b      	ldr	r3, [r7, #0]
 8014f76:	7a1b      	ldrb	r3, [r3, #8]
 8014f78:	f887 3049 	strb.w	r3, [r7, #73]	; 0x49

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
 8014f7c:	f7f9 fa30 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 8014f80:	6478      	str	r0, [r7, #68]	; 0x44
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8014f82:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8014f84:	f009 fe42 	bl	801ec0c <lv_disp_get_buf>
 8014f88:	6438      	str	r0, [r7, #64]	; 0x40

    const lv_area_t * disp_area = &vdb->area;
 8014f8a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8014f8c:	3310      	adds	r3, #16
 8014f8e:	63fb      	str	r3, [r7, #60]	; 0x3c

    int32_t w = dsc->width - 1;
 8014f90:	683b      	ldr	r3, [r7, #0]
 8014f92:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014f96:	3b01      	subs	r3, #1
 8014f98:	63bb      	str	r3, [r7, #56]	; 0x38
    int32_t w_half0 = w >> 1;
 8014f9a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8014f9c:	105b      	asrs	r3, r3, #1
 8014f9e:	637b      	str	r3, [r7, #52]	; 0x34
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
 8014fa0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8014fa2:	f003 0301 	and.w	r3, r3, #1
 8014fa6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8014fa8:	4413      	add	r3, r2
 8014faa:	633b      	str	r3, [r7, #48]	; 0x30

    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;
 8014fac:	683b      	ldr	r3, [r7, #0]
 8014fae:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014fb2:	2b00      	cmp	r3, #0
 8014fb4:	d006      	beq.n	8014fc4 <draw_line_hor+0x5e>
 8014fb6:	683b      	ldr	r3, [r7, #0]
 8014fb8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8014fbc:	2b00      	cmp	r3, #0
 8014fbe:	d001      	beq.n	8014fc4 <draw_line_hor+0x5e>
 8014fc0:	2301      	movs	r3, #1
 8014fc2:	e000      	b.n	8014fc6 <draw_line_hor+0x60>
 8014fc4:	2300      	movs	r3, #0
 8014fc6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8014fca:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8014fce:	f003 0301 	and.w	r3, r3, #1
 8014fd2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    bool simple_mode = true;
 8014fd6:	2301      	movs	r3, #1
 8014fd8:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
    if(lv_draw_mask_get_cnt()) simple_mode = false;
 8014fdc:	f001 f886 	bl	80160ec <lv_draw_mask_get_cnt>
 8014fe0:	4603      	mov	r3, r0
 8014fe2:	2b00      	cmp	r3, #0
 8014fe4:	d003      	beq.n	8014fee <draw_line_hor+0x88>
 8014fe6:	2300      	movs	r3, #0
 8014fe8:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
 8014fec:	e006      	b.n	8014ffc <draw_line_hor+0x96>
    else if(dashed) simple_mode = false;
 8014fee:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8014ff2:	2b00      	cmp	r3, #0
 8014ff4:	d002      	beq.n	8014ffc <draw_line_hor+0x96>
 8014ff6:	2300      	movs	r3, #0
 8014ff8:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

    lv_area_t draw_area;
    draw_area.x1 = LV_MATH_MIN(point1->x, point2->x);
 8014ffc:	68bb      	ldr	r3, [r7, #8]
 8014ffe:	f9b3 2000 	ldrsh.w	r2, [r3]
 8015002:	68fb      	ldr	r3, [r7, #12]
 8015004:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015008:	4293      	cmp	r3, r2
 801500a:	bfa8      	it	ge
 801500c:	4613      	movge	r3, r2
 801500e:	b21b      	sxth	r3, r3
 8015010:	833b      	strh	r3, [r7, #24]
    draw_area.x2 = LV_MATH_MAX(point1->x, point2->x)  - 1;
 8015012:	68bb      	ldr	r3, [r7, #8]
 8015014:	f9b3 2000 	ldrsh.w	r2, [r3]
 8015018:	68fb      	ldr	r3, [r7, #12]
 801501a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801501e:	4293      	cmp	r3, r2
 8015020:	bfb8      	it	lt
 8015022:	4613      	movlt	r3, r2
 8015024:	b21b      	sxth	r3, r3
 8015026:	b29b      	uxth	r3, r3
 8015028:	3b01      	subs	r3, #1
 801502a:	b29b      	uxth	r3, r3
 801502c:	b21b      	sxth	r3, r3
 801502e:	83bb      	strh	r3, [r7, #28]
    draw_area.y1 = point1->y - w_half1;
 8015030:	68fb      	ldr	r3, [r7, #12]
 8015032:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015036:	b29a      	uxth	r2, r3
 8015038:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801503a:	b29b      	uxth	r3, r3
 801503c:	1ad3      	subs	r3, r2, r3
 801503e:	b29b      	uxth	r3, r3
 8015040:	b21b      	sxth	r3, r3
 8015042:	837b      	strh	r3, [r7, #26]
    draw_area.y2 = point1->y + w_half0;
 8015044:	68fb      	ldr	r3, [r7, #12]
 8015046:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801504a:	b29a      	uxth	r2, r3
 801504c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801504e:	b29b      	uxth	r3, r3
 8015050:	4413      	add	r3, r2
 8015052:	b29b      	uxth	r3, r3
 8015054:	b21b      	sxth	r3, r3
 8015056:	83fb      	strh	r3, [r7, #30]

    /*If there is no mask then simply draw a rectangle*/
    if(simple_mode) {
 8015058:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801505c:	2b00      	cmp	r3, #0
 801505e:	d013      	beq.n	8015088 <draw_line_hor+0x122>
        _lv_blend_fill(clip, &draw_area,
                       dsc->color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa,
                       dsc->blend_mode);
 8015060:	683b      	ldr	r3, [r7, #0]
 8015062:	7a5b      	ldrb	r3, [r3, #9]
 8015064:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8015068:	b2db      	uxtb	r3, r3
        _lv_blend_fill(clip, &draw_area,
 801506a:	683a      	ldr	r2, [r7, #0]
 801506c:	f107 0118 	add.w	r1, r7, #24
 8015070:	9302      	str	r3, [sp, #8]
 8015072:	f897 3049 	ldrb.w	r3, [r7, #73]	; 0x49
 8015076:	9301      	str	r3, [sp, #4]
 8015078:	2301      	movs	r3, #1
 801507a:	9300      	str	r3, [sp, #0]
 801507c:	2300      	movs	r3, #0
 801507e:	8812      	ldrh	r2, [r2, #0]
 8015080:	6878      	ldr	r0, [r7, #4]
 8015082:	f7fb fbef 	bl	8010864 <_lv_blend_fill>
 8015086:	e13a      	b.n	80152fe <draw_line_hor+0x398>
    /*If there other mask apply it*/
    else {
        /* Get clipped fill area which is the real draw area.
         * It is always the same or inside `fill_area` */
        bool is_common;
        is_common = _lv_area_intersect(&draw_area, clip, &draw_area);
 8015088:	f107 0218 	add.w	r2, r7, #24
 801508c:	f107 0318 	add.w	r3, r7, #24
 8015090:	6879      	ldr	r1, [r7, #4]
 8015092:	4618      	mov	r0, r3
 8015094:	f00a f9ea 	bl	801f46c <_lv_area_intersect>
 8015098:	4603      	mov	r3, r0
 801509a:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
        if(!is_common) return;
 801509e:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 80150a2:	f083 0301 	eor.w	r3, r3, #1
 80150a6:	b2db      	uxtb	r3, r3
 80150a8:	2b00      	cmp	r3, #0
 80150aa:	f040 8128 	bne.w	80152fe <draw_line_hor+0x398>

        /* Now `draw_area` has absolute coordinates.
         * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
        draw_area.x1 -= disp_area->x1;
 80150ae:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80150b2:	b29a      	uxth	r2, r3
 80150b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80150b6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80150ba:	b29b      	uxth	r3, r3
 80150bc:	1ad3      	subs	r3, r2, r3
 80150be:	b29b      	uxth	r3, r3
 80150c0:	b21b      	sxth	r3, r3
 80150c2:	833b      	strh	r3, [r7, #24]
        draw_area.y1 -= disp_area->y1;
 80150c4:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80150c8:	b29a      	uxth	r2, r3
 80150ca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80150cc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80150d0:	b29b      	uxth	r3, r3
 80150d2:	1ad3      	subs	r3, r2, r3
 80150d4:	b29b      	uxth	r3, r3
 80150d6:	b21b      	sxth	r3, r3
 80150d8:	837b      	strh	r3, [r7, #26]
        draw_area.x2 -= disp_area->x1;
 80150da:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 80150de:	b29a      	uxth	r2, r3
 80150e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80150e2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80150e6:	b29b      	uxth	r3, r3
 80150e8:	1ad3      	subs	r3, r2, r3
 80150ea:	b29b      	uxth	r3, r3
 80150ec:	b21b      	sxth	r3, r3
 80150ee:	83bb      	strh	r3, [r7, #28]
        draw_area.y2 -= disp_area->y1;
 80150f0:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80150f4:	b29a      	uxth	r2, r3
 80150f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80150f8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80150fc:	b29b      	uxth	r3, r3
 80150fe:	1ad3      	subs	r3, r2, r3
 8015100:	b29b      	uxth	r3, r3
 8015102:	b21b      	sxth	r3, r3
 8015104:	83fb      	strh	r3, [r7, #30]

        int32_t draw_area_w = lv_area_get_width(&draw_area);
 8015106:	f107 0318 	add.w	r3, r7, #24
 801510a:	4618      	mov	r0, r3
 801510c:	f7ff fd76 	bl	8014bfc <lv_area_get_width>
 8015110:	4603      	mov	r3, r0
 8015112:	62bb      	str	r3, [r7, #40]	; 0x28

        lv_area_t fill_area;
        fill_area.x1 = draw_area.x1 + disp_area->x1;
 8015114:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8015118:	b29a      	uxth	r2, r3
 801511a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801511c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015120:	b29b      	uxth	r3, r3
 8015122:	4413      	add	r3, r2
 8015124:	b29b      	uxth	r3, r3
 8015126:	b21b      	sxth	r3, r3
 8015128:	823b      	strh	r3, [r7, #16]
        fill_area.x2 = draw_area.x2 + disp_area->x1;
 801512a:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 801512e:	b29a      	uxth	r2, r3
 8015130:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015132:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015136:	b29b      	uxth	r3, r3
 8015138:	4413      	add	r3, r2
 801513a:	b29b      	uxth	r3, r3
 801513c:	b21b      	sxth	r3, r3
 801513e:	82bb      	strh	r3, [r7, #20]
        fill_area.y1 = draw_area.y1 + disp_area->y1;
 8015140:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8015144:	b29a      	uxth	r2, r3
 8015146:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8015148:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801514c:	b29b      	uxth	r3, r3
 801514e:	4413      	add	r3, r2
 8015150:	b29b      	uxth	r3, r3
 8015152:	b21b      	sxth	r3, r3
 8015154:	827b      	strh	r3, [r7, #18]
        fill_area.y2 = fill_area.y1;
 8015156:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801515a:	82fb      	strh	r3, [r7, #22]

        lv_style_int_t dash_start = 0;
 801515c:	2300      	movs	r3, #0
 801515e:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
        if(dashed) {
 8015162:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8015166:	2b00      	cmp	r3, #0
 8015168:	d015      	beq.n	8015196 <draw_line_hor+0x230>
            dash_start = (vdb->area.x1 + draw_area.x1) % (dsc->dash_gap + dsc->dash_width);
 801516a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801516c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8015170:	461a      	mov	r2, r3
 8015172:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8015176:	4413      	add	r3, r2
 8015178:	683a      	ldr	r2, [r7, #0]
 801517a:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 801517e:	4611      	mov	r1, r2
 8015180:	683a      	ldr	r2, [r7, #0]
 8015182:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
 8015186:	440a      	add	r2, r1
 8015188:	fb93 f1f2 	sdiv	r1, r3, r2
 801518c:	fb01 f202 	mul.w	r2, r1, r2
 8015190:	1a9b      	subs	r3, r3, r2
 8015192:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
        }

        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
 8015196:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015198:	4618      	mov	r0, r3
 801519a:	f00b fe79 	bl	8020e90 <_lv_mem_buf_get>
 801519e:	6278      	str	r0, [r7, #36]	; 0x24
        int32_t h;
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
 80151a0:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80151a4:	653b      	str	r3, [r7, #80]	; 0x50
 80151a6:	e0a0      	b.n	80152ea <draw_line_hor+0x384>
            _lv_memset_ff(mask_buf, draw_area_w);
 80151a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80151aa:	4619      	mov	r1, r3
 80151ac:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80151ae:	f00c fafc 	bl	80217aa <_lv_memset_ff>
            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
 80151b2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80151b4:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80151b8:	b29a      	uxth	r2, r3
 80151ba:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80151be:	b29b      	uxth	r3, r3
 80151c0:	4413      	add	r3, r2
 80151c2:	b29b      	uxth	r3, r3
 80151c4:	b219      	sxth	r1, r3
 80151c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80151c8:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80151cc:	b29a      	uxth	r2, r3
 80151ce:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80151d0:	b29b      	uxth	r3, r3
 80151d2:	4413      	add	r3, r2
 80151d4:	b29b      	uxth	r3, r3
 80151d6:	b21a      	sxth	r2, r3
 80151d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80151da:	b21b      	sxth	r3, r3
 80151dc:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80151de:	f000 fee9 	bl	8015fb4 <lv_draw_mask_apply>
 80151e2:	4603      	mov	r3, r0
 80151e4:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f

            if(dashed) {
 80151e8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80151ec:	2b00      	cmp	r3, #0
 80151ee:	d056      	beq.n	801529e <draw_line_hor+0x338>
                if(mask_res != LV_DRAW_MASK_RES_TRANSP) {
 80151f0:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 80151f4:	2b00      	cmp	r3, #0
 80151f6:	d052      	beq.n	801529e <draw_line_hor+0x338>
                    lv_style_int_t dash_cnt = dash_start;
 80151f8:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 80151fc:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
                    lv_coord_t i;
                    for(i = 0; i < draw_area_w; i++, dash_cnt++) {
 8015200:	2300      	movs	r3, #0
 8015202:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
 8015206:	e042      	b.n	801528e <draw_line_hor+0x328>
                        if(dash_cnt <= dsc->dash_width) {
 8015208:	683b      	ldr	r3, [r7, #0]
 801520a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801520e:	f9b7 204c 	ldrsh.w	r2, [r7, #76]	; 0x4c
 8015212:	429a      	cmp	r2, r3
 8015214:	dc17      	bgt.n	8015246 <draw_line_hor+0x2e0>
                            int16_t diff = dsc->dash_width - dash_cnt;
 8015216:	683b      	ldr	r3, [r7, #0]
 8015218:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801521c:	b29a      	uxth	r2, r3
 801521e:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8015222:	1ad3      	subs	r3, r2, r3
 8015224:	b29b      	uxth	r3, r3
 8015226:	847b      	strh	r3, [r7, #34]	; 0x22
                            i += diff;
 8015228:	f8b7 204a 	ldrh.w	r2, [r7, #74]	; 0x4a
 801522c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801522e:	4413      	add	r3, r2
 8015230:	b29b      	uxth	r3, r3
 8015232:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
                            dash_cnt += diff;
 8015236:	f8b7 204c 	ldrh.w	r2, [r7, #76]	; 0x4c
 801523a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801523c:	4413      	add	r3, r2
 801523e:	b29b      	uxth	r3, r3
 8015240:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
 8015244:	e015      	b.n	8015272 <draw_line_hor+0x30c>
                        }
                        else if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {
 8015246:	f9b7 204c 	ldrsh.w	r2, [r7, #76]	; 0x4c
 801524a:	683b      	ldr	r3, [r7, #0]
 801524c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015250:	4619      	mov	r1, r3
 8015252:	683b      	ldr	r3, [r7, #0]
 8015254:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8015258:	440b      	add	r3, r1
 801525a:	429a      	cmp	r2, r3
 801525c:	db03      	blt.n	8015266 <draw_line_hor+0x300>
                            dash_cnt = 0;
 801525e:	2300      	movs	r3, #0
 8015260:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
 8015264:	e005      	b.n	8015272 <draw_line_hor+0x30c>
                        }
                        else {
                            mask_buf[i] = 0x00;
 8015266:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 801526a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801526c:	4413      	add	r3, r2
 801526e:	2200      	movs	r2, #0
 8015270:	701a      	strb	r2, [r3, #0]
                    for(i = 0; i < draw_area_w; i++, dash_cnt++) {
 8015272:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 8015276:	b29b      	uxth	r3, r3
 8015278:	3301      	adds	r3, #1
 801527a:	b29b      	uxth	r3, r3
 801527c:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
 8015280:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8015284:	b29b      	uxth	r3, r3
 8015286:	3301      	adds	r3, #1
 8015288:	b29b      	uxth	r3, r3
 801528a:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
 801528e:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 8015292:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8015294:	429a      	cmp	r2, r3
 8015296:	dcb7      	bgt.n	8015208 <draw_line_hor+0x2a2>
                        }
                    }

                    mask_res = LV_DRAW_MASK_RES_CHANGED;
 8015298:	2302      	movs	r3, #2
 801529a:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
                }
            }

            _lv_blend_fill(clip, &fill_area,
                           dsc->color, mask_buf, mask_res, dsc->opa,
 801529e:	683b      	ldr	r3, [r7, #0]
 80152a0:	7a1b      	ldrb	r3, [r3, #8]
                           dsc->blend_mode);
 80152a2:	683a      	ldr	r2, [r7, #0]
 80152a4:	7a52      	ldrb	r2, [r2, #9]
 80152a6:	f3c2 0201 	ubfx	r2, r2, #0, #2
 80152aa:	b2d2      	uxtb	r2, r2
            _lv_blend_fill(clip, &fill_area,
 80152ac:	4610      	mov	r0, r2
 80152ae:	683a      	ldr	r2, [r7, #0]
 80152b0:	f107 0110 	add.w	r1, r7, #16
 80152b4:	9002      	str	r0, [sp, #8]
 80152b6:	9301      	str	r3, [sp, #4]
 80152b8:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 80152bc:	9300      	str	r3, [sp, #0]
 80152be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80152c0:	8812      	ldrh	r2, [r2, #0]
 80152c2:	6878      	ldr	r0, [r7, #4]
 80152c4:	f7fb face 	bl	8010864 <_lv_blend_fill>

            fill_area.y1++;
 80152c8:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80152cc:	b29b      	uxth	r3, r3
 80152ce:	3301      	adds	r3, #1
 80152d0:	b29b      	uxth	r3, r3
 80152d2:	b21b      	sxth	r3, r3
 80152d4:	827b      	strh	r3, [r7, #18]
            fill_area.y2++;
 80152d6:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80152da:	b29b      	uxth	r3, r3
 80152dc:	3301      	adds	r3, #1
 80152de:	b29b      	uxth	r3, r3
 80152e0:	b21b      	sxth	r3, r3
 80152e2:	82fb      	strh	r3, [r7, #22]
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
 80152e4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80152e6:	3301      	adds	r3, #1
 80152e8:	653b      	str	r3, [r7, #80]	; 0x50
 80152ea:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80152ee:	461a      	mov	r2, r3
 80152f0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80152f2:	4293      	cmp	r3, r2
 80152f4:	f77f af58 	ble.w	80151a8 <draw_line_hor+0x242>
        }
        _lv_mem_buf_release(mask_buf);
 80152f8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80152fa:	f00b fea9 	bl	8021050 <_lv_mem_buf_release>
    }
}
 80152fe:	3758      	adds	r7, #88	; 0x58
 8015300:	46bd      	mov	sp, r7
 8015302:	bd80      	pop	{r7, pc}

08015304 <draw_line_ver>:


LV_ATTRIBUTE_FAST_MEM static void draw_line_ver(const lv_point_t * point1, const lv_point_t * point2,
                                                const lv_area_t * clip,
                                                const lv_draw_line_dsc_t * dsc)
{
 8015304:	b580      	push	{r7, lr}
 8015306:	b09a      	sub	sp, #104	; 0x68
 8015308:	af04      	add	r7, sp, #16
 801530a:	60f8      	str	r0, [r7, #12]
 801530c:	60b9      	str	r1, [r7, #8]
 801530e:	607a      	str	r2, [r7, #4]
 8015310:	603b      	str	r3, [r7, #0]
    lv_opa_t opa = dsc->opa;
 8015312:	683b      	ldr	r3, [r7, #0]
 8015314:	7a1b      	ldrb	r3, [r3, #8]
 8015316:	f887 304a 	strb.w	r3, [r7, #74]	; 0x4a

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
 801531a:	f7f9 f861 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 801531e:	6478      	str	r0, [r7, #68]	; 0x44
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8015320:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8015322:	f009 fc73 	bl	801ec0c <lv_disp_get_buf>
 8015326:	6438      	str	r0, [r7, #64]	; 0x40

    const lv_area_t * disp_area = &vdb->area;
 8015328:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801532a:	3310      	adds	r3, #16
 801532c:	63fb      	str	r3, [r7, #60]	; 0x3c

    int32_t w = dsc->width - 1;
 801532e:	683b      	ldr	r3, [r7, #0]
 8015330:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015334:	3b01      	subs	r3, #1
 8015336:	63bb      	str	r3, [r7, #56]	; 0x38
    int32_t w_half0 = w >> 1;
 8015338:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801533a:	105b      	asrs	r3, r3, #1
 801533c:	637b      	str	r3, [r7, #52]	; 0x34
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
 801533e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8015340:	f003 0301 	and.w	r3, r3, #1
 8015344:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8015346:	4413      	add	r3, r2
 8015348:	633b      	str	r3, [r7, #48]	; 0x30

    bool dashed = dsc->dash_gap && dsc->dash_width ? true : false;
 801534a:	683b      	ldr	r3, [r7, #0]
 801534c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015350:	2b00      	cmp	r3, #0
 8015352:	d006      	beq.n	8015362 <draw_line_ver+0x5e>
 8015354:	683b      	ldr	r3, [r7, #0]
 8015356:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801535a:	2b00      	cmp	r3, #0
 801535c:	d001      	beq.n	8015362 <draw_line_ver+0x5e>
 801535e:	2301      	movs	r3, #1
 8015360:	e000      	b.n	8015364 <draw_line_ver+0x60>
 8015362:	2300      	movs	r3, #0
 8015364:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8015368:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801536c:	f003 0301 	and.w	r3, r3, #1
 8015370:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    bool simple_mode = true;
 8015374:	2301      	movs	r3, #1
 8015376:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
    if(lv_draw_mask_get_cnt()) simple_mode = false;
 801537a:	f000 feb7 	bl	80160ec <lv_draw_mask_get_cnt>
 801537e:	4603      	mov	r3, r0
 8015380:	2b00      	cmp	r3, #0
 8015382:	d003      	beq.n	801538c <draw_line_ver+0x88>
 8015384:	2300      	movs	r3, #0
 8015386:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
 801538a:	e006      	b.n	801539a <draw_line_ver+0x96>
    else if(dashed) simple_mode = false;
 801538c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8015390:	2b00      	cmp	r3, #0
 8015392:	d002      	beq.n	801539a <draw_line_ver+0x96>
 8015394:	2300      	movs	r3, #0
 8015396:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

    lv_area_t draw_area;
    draw_area.x1 = point1->x - w_half1;
 801539a:	68fb      	ldr	r3, [r7, #12]
 801539c:	f9b3 3000 	ldrsh.w	r3, [r3]
 80153a0:	b29a      	uxth	r2, r3
 80153a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80153a4:	b29b      	uxth	r3, r3
 80153a6:	1ad3      	subs	r3, r2, r3
 80153a8:	b29b      	uxth	r3, r3
 80153aa:	b21b      	sxth	r3, r3
 80153ac:	83bb      	strh	r3, [r7, #28]
    draw_area.x2 = point1->x + w_half0;
 80153ae:	68fb      	ldr	r3, [r7, #12]
 80153b0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80153b4:	b29a      	uxth	r2, r3
 80153b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80153b8:	b29b      	uxth	r3, r3
 80153ba:	4413      	add	r3, r2
 80153bc:	b29b      	uxth	r3, r3
 80153be:	b21b      	sxth	r3, r3
 80153c0:	843b      	strh	r3, [r7, #32]
    draw_area.y1 = LV_MATH_MIN(point1->y, point2->y);
 80153c2:	68bb      	ldr	r3, [r7, #8]
 80153c4:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 80153c8:	68fb      	ldr	r3, [r7, #12]
 80153ca:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80153ce:	4293      	cmp	r3, r2
 80153d0:	bfa8      	it	ge
 80153d2:	4613      	movge	r3, r2
 80153d4:	b21b      	sxth	r3, r3
 80153d6:	83fb      	strh	r3, [r7, #30]
    draw_area.y2 = LV_MATH_MAX(point1->y, point2->y) - 1;
 80153d8:	68bb      	ldr	r3, [r7, #8]
 80153da:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 80153de:	68fb      	ldr	r3, [r7, #12]
 80153e0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80153e4:	4293      	cmp	r3, r2
 80153e6:	bfb8      	it	lt
 80153e8:	4613      	movlt	r3, r2
 80153ea:	b21b      	sxth	r3, r3
 80153ec:	b29b      	uxth	r3, r3
 80153ee:	3b01      	subs	r3, #1
 80153f0:	b29b      	uxth	r3, r3
 80153f2:	b21b      	sxth	r3, r3
 80153f4:	847b      	strh	r3, [r7, #34]	; 0x22

    /*If there is no mask then simply draw a rectangle*/
    if(simple_mode) {
 80153f6:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80153fa:	2b00      	cmp	r3, #0
 80153fc:	d013      	beq.n	8015426 <draw_line_ver+0x122>
        _lv_blend_fill(clip, &draw_area,
                       dsc->color,  NULL, LV_DRAW_MASK_RES_FULL_COVER, opa,
                       dsc->blend_mode);
 80153fe:	683b      	ldr	r3, [r7, #0]
 8015400:	7a5b      	ldrb	r3, [r3, #9]
 8015402:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8015406:	b2db      	uxtb	r3, r3
        _lv_blend_fill(clip, &draw_area,
 8015408:	683a      	ldr	r2, [r7, #0]
 801540a:	f107 011c 	add.w	r1, r7, #28
 801540e:	9302      	str	r3, [sp, #8]
 8015410:	f897 304a 	ldrb.w	r3, [r7, #74]	; 0x4a
 8015414:	9301      	str	r3, [sp, #4]
 8015416:	2301      	movs	r3, #1
 8015418:	9300      	str	r3, [sp, #0]
 801541a:	2300      	movs	r3, #0
 801541c:	8812      	ldrh	r2, [r2, #0]
 801541e:	6878      	ldr	r0, [r7, #4]
 8015420:	f7fb fa20 	bl	8010864 <_lv_blend_fill>
 8015424:	e105      	b.n	8015632 <draw_line_ver+0x32e>
    /*If there other mask apply it*/
    else {
        /* Get clipped fill area which is the real draw area.
         * It is always the same or inside `fill_area` */
        bool is_common;
        is_common = _lv_area_intersect(&draw_area, clip, &draw_area);
 8015426:	f107 021c 	add.w	r2, r7, #28
 801542a:	f107 031c 	add.w	r3, r7, #28
 801542e:	6879      	ldr	r1, [r7, #4]
 8015430:	4618      	mov	r0, r3
 8015432:	f00a f81b 	bl	801f46c <_lv_area_intersect>
 8015436:	4603      	mov	r3, r0
 8015438:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
        if(!is_common) return;
 801543c:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8015440:	f083 0301 	eor.w	r3, r3, #1
 8015444:	b2db      	uxtb	r3, r3
 8015446:	2b00      	cmp	r3, #0
 8015448:	f040 80f3 	bne.w	8015632 <draw_line_ver+0x32e>

        /* Now `draw_area` has absolute coordinates.
         * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
        draw_area.x1 -= vdb->area.x1;
 801544c:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8015450:	b29a      	uxth	r2, r3
 8015452:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015454:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8015458:	b29b      	uxth	r3, r3
 801545a:	1ad3      	subs	r3, r2, r3
 801545c:	b29b      	uxth	r3, r3
 801545e:	b21b      	sxth	r3, r3
 8015460:	83bb      	strh	r3, [r7, #28]
        draw_area.y1 -= vdb->area.y1;
 8015462:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8015466:	b29a      	uxth	r2, r3
 8015468:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801546a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801546e:	b29b      	uxth	r3, r3
 8015470:	1ad3      	subs	r3, r2, r3
 8015472:	b29b      	uxth	r3, r3
 8015474:	b21b      	sxth	r3, r3
 8015476:	83fb      	strh	r3, [r7, #30]
        draw_area.x2 -= vdb->area.x1;
 8015478:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801547c:	b29a      	uxth	r2, r3
 801547e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015480:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8015484:	b29b      	uxth	r3, r3
 8015486:	1ad3      	subs	r3, r2, r3
 8015488:	b29b      	uxth	r3, r3
 801548a:	b21b      	sxth	r3, r3
 801548c:	843b      	strh	r3, [r7, #32]
        draw_area.y2 -= vdb->area.y1;
 801548e:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8015492:	b29a      	uxth	r2, r3
 8015494:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015496:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801549a:	b29b      	uxth	r3, r3
 801549c:	1ad3      	subs	r3, r2, r3
 801549e:	b29b      	uxth	r3, r3
 80154a0:	b21b      	sxth	r3, r3
 80154a2:	847b      	strh	r3, [r7, #34]	; 0x22

        int32_t draw_area_w = lv_area_get_width(&draw_area);
 80154a4:	f107 031c 	add.w	r3, r7, #28
 80154a8:	4618      	mov	r0, r3
 80154aa:	f7ff fba7 	bl	8014bfc <lv_area_get_width>
 80154ae:	4603      	mov	r3, r0
 80154b0:	62bb      	str	r3, [r7, #40]	; 0x28

        lv_area_t fill_area;
        fill_area.x1 = draw_area.x1 + disp_area->x1;
 80154b2:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 80154b6:	b29a      	uxth	r2, r3
 80154b8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80154ba:	f9b3 3000 	ldrsh.w	r3, [r3]
 80154be:	b29b      	uxth	r3, r3
 80154c0:	4413      	add	r3, r2
 80154c2:	b29b      	uxth	r3, r3
 80154c4:	b21b      	sxth	r3, r3
 80154c6:	82bb      	strh	r3, [r7, #20]
        fill_area.x2 = draw_area.x2 + disp_area->x1;
 80154c8:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 80154cc:	b29a      	uxth	r2, r3
 80154ce:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80154d0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80154d4:	b29b      	uxth	r3, r3
 80154d6:	4413      	add	r3, r2
 80154d8:	b29b      	uxth	r3, r3
 80154da:	b21b      	sxth	r3, r3
 80154dc:	833b      	strh	r3, [r7, #24]
        fill_area.y1 = draw_area.y1 + disp_area->y1;
 80154de:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80154e2:	b29a      	uxth	r2, r3
 80154e4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80154e6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80154ea:	b29b      	uxth	r3, r3
 80154ec:	4413      	add	r3, r2
 80154ee:	b29b      	uxth	r3, r3
 80154f0:	b21b      	sxth	r3, r3
 80154f2:	82fb      	strh	r3, [r7, #22]
        fill_area.y2 = fill_area.y1;
 80154f4:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80154f8:	837b      	strh	r3, [r7, #26]

        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
 80154fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80154fc:	4618      	mov	r0, r3
 80154fe:	f00b fcc7 	bl	8020e90 <_lv_mem_buf_get>
 8015502:	6278      	str	r0, [r7, #36]	; 0x24

        lv_style_int_t dash_start = 0;
 8015504:	2300      	movs	r3, #0
 8015506:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
        if(dashed) {
 801550a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801550e:	2b00      	cmp	r3, #0
 8015510:	d015      	beq.n	801553e <draw_line_ver+0x23a>
            dash_start = (vdb->area.y1 + draw_area.y1) % (dsc->dash_gap + dsc->dash_width);
 8015512:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015514:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8015518:	461a      	mov	r2, r3
 801551a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801551e:	4413      	add	r3, r2
 8015520:	683a      	ldr	r2, [r7, #0]
 8015522:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 8015526:	4611      	mov	r1, r2
 8015528:	683a      	ldr	r2, [r7, #0]
 801552a:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
 801552e:	440a      	add	r2, r1
 8015530:	fb93 f1f2 	sdiv	r1, r3, r2
 8015534:	fb01 f202 	mul.w	r2, r1, r2
 8015538:	1a9b      	subs	r3, r3, r2
 801553a:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
        }

        lv_style_int_t dash_cnt = dash_start;
 801553e:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8015542:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

        int32_t h;
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
 8015546:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801554a:	64fb      	str	r3, [r7, #76]	; 0x4c
 801554c:	e068      	b.n	8015620 <draw_line_ver+0x31c>
            _lv_memset_ff(mask_buf, draw_area_w);
 801554e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015550:	4619      	mov	r1, r3
 8015552:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8015554:	f00c f929 	bl	80217aa <_lv_memset_ff>
            lv_draw_mask_res_t mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
 8015558:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801555a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801555e:	b29a      	uxth	r2, r3
 8015560:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8015564:	b29b      	uxth	r3, r3
 8015566:	4413      	add	r3, r2
 8015568:	b29b      	uxth	r3, r3
 801556a:	b219      	sxth	r1, r3
 801556c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801556e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8015572:	b29a      	uxth	r2, r3
 8015574:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015576:	b29b      	uxth	r3, r3
 8015578:	4413      	add	r3, r2
 801557a:	b29b      	uxth	r3, r3
 801557c:	b21a      	sxth	r2, r3
 801557e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8015580:	b21b      	sxth	r3, r3
 8015582:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8015584:	f000 fd16 	bl	8015fb4 <lv_draw_mask_apply>
 8015588:	4603      	mov	r3, r0
 801558a:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b

            if(dashed) {
 801558e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8015592:	2b00      	cmp	r3, #0
 8015594:	d023      	beq.n	80155de <draw_line_ver+0x2da>
                if(mask_res != LV_DRAW_MASK_RES_TRANSP) {
 8015596:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 801559a:	2b00      	cmp	r3, #0
 801559c:	d018      	beq.n	80155d0 <draw_line_ver+0x2cc>
                    if(dash_cnt > dsc->dash_width) {
 801559e:	683b      	ldr	r3, [r7, #0]
 80155a0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80155a4:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 80155a8:	429a      	cmp	r2, r3
 80155aa:	dd02      	ble.n	80155b2 <draw_line_ver+0x2ae>
                        mask_res = LV_DRAW_MASK_RES_TRANSP;
 80155ac:	2300      	movs	r3, #0
 80155ae:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
                    }

                    if(dash_cnt >= dsc->dash_gap + dsc->dash_width) {
 80155b2:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 80155b6:	683b      	ldr	r3, [r7, #0]
 80155b8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80155bc:	4619      	mov	r1, r3
 80155be:	683b      	ldr	r3, [r7, #0]
 80155c0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80155c4:	440b      	add	r3, r1
 80155c6:	429a      	cmp	r2, r3
 80155c8:	db02      	blt.n	80155d0 <draw_line_ver+0x2cc>
                        dash_cnt = 0;
 80155ca:	2300      	movs	r3, #0
 80155cc:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                    }
                }
                dash_cnt ++;
 80155d0:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80155d4:	b29b      	uxth	r3, r3
 80155d6:	3301      	adds	r3, #1
 80155d8:	b29b      	uxth	r3, r3
 80155da:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            }

            _lv_blend_fill(clip, &fill_area,
                           dsc->color, mask_buf, mask_res, dsc->opa,
 80155de:	683b      	ldr	r3, [r7, #0]
 80155e0:	7a1b      	ldrb	r3, [r3, #8]
            _lv_blend_fill(clip, &fill_area,
 80155e2:	683a      	ldr	r2, [r7, #0]
 80155e4:	f107 0114 	add.w	r1, r7, #20
 80155e8:	2000      	movs	r0, #0
 80155ea:	9002      	str	r0, [sp, #8]
 80155ec:	9301      	str	r3, [sp, #4]
 80155ee:	f897 304b 	ldrb.w	r3, [r7, #75]	; 0x4b
 80155f2:	9300      	str	r3, [sp, #0]
 80155f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80155f6:	8812      	ldrh	r2, [r2, #0]
 80155f8:	6878      	ldr	r0, [r7, #4]
 80155fa:	f7fb f933 	bl	8010864 <_lv_blend_fill>
                           LV_BLEND_MODE_NORMAL);

            fill_area.y1++;
 80155fe:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8015602:	b29b      	uxth	r3, r3
 8015604:	3301      	adds	r3, #1
 8015606:	b29b      	uxth	r3, r3
 8015608:	b21b      	sxth	r3, r3
 801560a:	82fb      	strh	r3, [r7, #22]
            fill_area.y2++;
 801560c:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8015610:	b29b      	uxth	r3, r3
 8015612:	3301      	adds	r3, #1
 8015614:	b29b      	uxth	r3, r3
 8015616:	b21b      	sxth	r3, r3
 8015618:	837b      	strh	r3, [r7, #26]
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
 801561a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801561c:	3301      	adds	r3, #1
 801561e:	64fb      	str	r3, [r7, #76]	; 0x4c
 8015620:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8015624:	461a      	mov	r2, r3
 8015626:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8015628:	4293      	cmp	r3, r2
 801562a:	dd90      	ble.n	801554e <draw_line_ver+0x24a>
        }
        _lv_mem_buf_release(mask_buf);
 801562c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801562e:	f00b fd0f 	bl	8021050 <_lv_mem_buf_release>
    }
}
 8015632:	3758      	adds	r7, #88	; 0x58
 8015634:	46bd      	mov	sp, r7
 8015636:	bd80      	pop	{r7, pc}

08015638 <draw_line_skew>:


LV_ATTRIBUTE_FAST_MEM static void draw_line_skew(const lv_point_t * point1, const lv_point_t * point2,
                                                 const lv_area_t * clip,
                                                 const lv_draw_line_dsc_t * dsc)
{
 8015638:	b5b0      	push	{r4, r5, r7, lr}
 801563a:	b0ce      	sub	sp, #312	; 0x138
 801563c:	af04      	add	r7, sp, #16
 801563e:	f507 7494 	add.w	r4, r7, #296	; 0x128
 8015642:	f5a4 748e 	sub.w	r4, r4, #284	; 0x11c
 8015646:	6020      	str	r0, [r4, #0]
 8015648:	f507 7094 	add.w	r0, r7, #296	; 0x128
 801564c:	f5a0 7090 	sub.w	r0, r0, #288	; 0x120
 8015650:	6001      	str	r1, [r0, #0]
 8015652:	f507 7194 	add.w	r1, r7, #296	; 0x128
 8015656:	f5a1 7192 	sub.w	r1, r1, #292	; 0x124
 801565a:	600a      	str	r2, [r1, #0]
 801565c:	f507 7294 	add.w	r2, r7, #296	; 0x128
 8015660:	f5a2 7294 	sub.w	r2, r2, #296	; 0x128
 8015664:	6013      	str	r3, [r2, #0]
    /*Keep the great y in p1*/
    lv_point_t p1;
    lv_point_t p2;
    if(point1->y < point2->y) {
 8015666:	f507 7394 	add.w	r3, r7, #296	; 0x128
 801566a:	f5a3 738e 	sub.w	r3, r3, #284	; 0x11c
 801566e:	681b      	ldr	r3, [r3, #0]
 8015670:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8015674:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015678:	f5a3 7390 	sub.w	r3, r3, #288	; 0x120
 801567c:	681b      	ldr	r3, [r3, #0]
 801567e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015682:	429a      	cmp	r2, r3
 8015684:	da24      	bge.n	80156d0 <draw_line_skew+0x98>
        p1.y = point1->y;
 8015686:	f507 7394 	add.w	r3, r7, #296	; 0x128
 801568a:	f5a3 738e 	sub.w	r3, r3, #284	; 0x11c
 801568e:	681b      	ldr	r3, [r3, #0]
 8015690:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015694:	f8a7 30d6 	strh.w	r3, [r7, #214]	; 0xd6
        p2.y = point2->y;
 8015698:	f507 7394 	add.w	r3, r7, #296	; 0x128
 801569c:	f5a3 7390 	sub.w	r3, r3, #288	; 0x120
 80156a0:	681b      	ldr	r3, [r3, #0]
 80156a2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80156a6:	f8a7 30d2 	strh.w	r3, [r7, #210]	; 0xd2
        p1.x = point1->x;
 80156aa:	f507 7394 	add.w	r3, r7, #296	; 0x128
 80156ae:	f5a3 738e 	sub.w	r3, r3, #284	; 0x11c
 80156b2:	681b      	ldr	r3, [r3, #0]
 80156b4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80156b8:	f8a7 30d4 	strh.w	r3, [r7, #212]	; 0xd4
        p2.x = point2->x;
 80156bc:	f507 7394 	add.w	r3, r7, #296	; 0x128
 80156c0:	f5a3 7390 	sub.w	r3, r3, #288	; 0x120
 80156c4:	681b      	ldr	r3, [r3, #0]
 80156c6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80156ca:	f8a7 30d0 	strh.w	r3, [r7, #208]	; 0xd0
 80156ce:	e023      	b.n	8015718 <draw_line_skew+0xe0>
    }
    else {
        p1.y = point2->y;
 80156d0:	f507 7394 	add.w	r3, r7, #296	; 0x128
 80156d4:	f5a3 7390 	sub.w	r3, r3, #288	; 0x120
 80156d8:	681b      	ldr	r3, [r3, #0]
 80156da:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80156de:	f8a7 30d6 	strh.w	r3, [r7, #214]	; 0xd6
        p2.y = point1->y;
 80156e2:	f507 7394 	add.w	r3, r7, #296	; 0x128
 80156e6:	f5a3 738e 	sub.w	r3, r3, #284	; 0x11c
 80156ea:	681b      	ldr	r3, [r3, #0]
 80156ec:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80156f0:	f8a7 30d2 	strh.w	r3, [r7, #210]	; 0xd2
        p1.x = point2->x;
 80156f4:	f507 7394 	add.w	r3, r7, #296	; 0x128
 80156f8:	f5a3 7390 	sub.w	r3, r3, #288	; 0x120
 80156fc:	681b      	ldr	r3, [r3, #0]
 80156fe:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015702:	f8a7 30d4 	strh.w	r3, [r7, #212]	; 0xd4
        p2.x = point1->x;
 8015706:	f507 7394 	add.w	r3, r7, #296	; 0x128
 801570a:	f5a3 738e 	sub.w	r3, r3, #284	; 0x11c
 801570e:	681b      	ldr	r3, [r3, #0]
 8015710:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015714:	f8a7 30d0 	strh.w	r3, [r7, #208]	; 0xd0
    }

    int32_t xdiff = p2.x - p1.x;
 8015718:	f9b7 30d0 	ldrsh.w	r3, [r7, #208]	; 0xd0
 801571c:	461a      	mov	r2, r3
 801571e:	f9b7 30d4 	ldrsh.w	r3, [r7, #212]	; 0xd4
 8015722:	1ad3      	subs	r3, r2, r3
 8015724:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    int32_t ydiff = p2.y - p1.y;
 8015728:	f9b7 30d2 	ldrsh.w	r3, [r7, #210]	; 0xd2
 801572c:	461a      	mov	r2, r3
 801572e:	f9b7 30d6 	ldrsh.w	r3, [r7, #214]	; 0xd6
 8015732:	1ad3      	subs	r3, r2, r3
 8015734:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    bool flat = LV_MATH_ABS(xdiff) > LV_MATH_ABS(ydiff) ? true : false;
 8015738:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 801573c:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8015740:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 8015744:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8015748:	2b00      	cmp	r3, #0
 801574a:	bfb8      	it	lt
 801574c:	425b      	neglt	r3, r3
 801574e:	429a      	cmp	r2, r3
 8015750:	bfcc      	ite	gt
 8015752:	2301      	movgt	r3, #1
 8015754:	2300      	movle	r3, #0
 8015756:	f887 310f 	strb.w	r3, [r7, #271]	; 0x10f
        143, 145, 147, 149, 151, 153, 155, 158,
        160, 162, 165, 167, 170, 173, 175, 178,
        181,
    };

    int32_t w = dsc->width;
 801575a:	f507 7394 	add.w	r3, r7, #296	; 0x128
 801575e:	f5a3 7394 	sub.w	r3, r3, #296	; 0x128
 8015762:	681b      	ldr	r3, [r3, #0]
 8015764:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015768:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    int32_t wcorr_i = 0;
 801576c:	2300      	movs	r3, #0
 801576e:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    if(flat) wcorr_i = (LV_MATH_ABS(ydiff) << 5) / LV_MATH_ABS(xdiff);
 8015772:	f897 310f 	ldrb.w	r3, [r7, #271]	; 0x10f
 8015776:	2b00      	cmp	r3, #0
 8015778:	d00f      	beq.n	801579a <draw_line_skew+0x162>
 801577a:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 801577e:	2b00      	cmp	r3, #0
 8015780:	bfb8      	it	lt
 8015782:	425b      	neglt	r3, r3
 8015784:	015a      	lsls	r2, r3, #5
 8015786:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 801578a:	2b00      	cmp	r3, #0
 801578c:	bfb8      	it	lt
 801578e:	425b      	neglt	r3, r3
 8015790:	fb92 f3f3 	sdiv	r3, r2, r3
 8015794:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 8015798:	e00e      	b.n	80157b8 <draw_line_skew+0x180>
    else wcorr_i = (LV_MATH_ABS(xdiff) << 5) / LV_MATH_ABS(ydiff);
 801579a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 801579e:	2b00      	cmp	r3, #0
 80157a0:	bfb8      	it	lt
 80157a2:	425b      	neglt	r3, r3
 80157a4:	015a      	lsls	r2, r3, #5
 80157a6:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 80157aa:	2b00      	cmp	r3, #0
 80157ac:	bfb8      	it	lt
 80157ae:	425b      	neglt	r3, r3
 80157b0:	fb92 f3f3 	sdiv	r3, r2, r3
 80157b4:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124

    w = (w * wcorr[wcorr_i] + 63) >> 7;     /*+ 63 for rounding*/
 80157b8:	4a7e      	ldr	r2, [pc, #504]	; (80159b4 <draw_line_skew+0x37c>)
 80157ba:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 80157be:	4413      	add	r3, r2
 80157c0:	781b      	ldrb	r3, [r3, #0]
 80157c2:	461a      	mov	r2, r3
 80157c4:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80157c8:	fb02 f303 	mul.w	r3, r2, r3
 80157cc:	333f      	adds	r3, #63	; 0x3f
 80157ce:	11db      	asrs	r3, r3, #7
 80157d0:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    int32_t w_half0 = w >> 1;
 80157d4:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80157d8:	105b      	asrs	r3, r3, #1
 80157da:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    int32_t w_half1 = w_half0 + (w & 0x1); /*Compensate rounding error*/
 80157de:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 80157e2:	f003 0301 	and.w	r3, r3, #1
 80157e6:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 80157ea:	4413      	add	r3, r2
 80157ec:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

    lv_area_t draw_area;
    draw_area.x1 = LV_MATH_MIN(p1.x, p2.x) - w;
 80157f0:	f9b7 20d0 	ldrsh.w	r2, [r7, #208]	; 0xd0
 80157f4:	f9b7 30d4 	ldrsh.w	r3, [r7, #212]	; 0xd4
 80157f8:	4293      	cmp	r3, r2
 80157fa:	bfa8      	it	ge
 80157fc:	4613      	movge	r3, r2
 80157fe:	b21b      	sxth	r3, r3
 8015800:	b29a      	uxth	r2, r3
 8015802:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8015806:	b29b      	uxth	r3, r3
 8015808:	1ad3      	subs	r3, r2, r3
 801580a:	b29b      	uxth	r3, r3
 801580c:	b21b      	sxth	r3, r3
 801580e:	f8a7 30c8 	strh.w	r3, [r7, #200]	; 0xc8
    draw_area.x2 = LV_MATH_MAX(p1.x, p2.x) + w;
 8015812:	f9b7 20d0 	ldrsh.w	r2, [r7, #208]	; 0xd0
 8015816:	f9b7 30d4 	ldrsh.w	r3, [r7, #212]	; 0xd4
 801581a:	4293      	cmp	r3, r2
 801581c:	bfb8      	it	lt
 801581e:	4613      	movlt	r3, r2
 8015820:	b21b      	sxth	r3, r3
 8015822:	b29a      	uxth	r2, r3
 8015824:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8015828:	b29b      	uxth	r3, r3
 801582a:	4413      	add	r3, r2
 801582c:	b29b      	uxth	r3, r3
 801582e:	b21b      	sxth	r3, r3
 8015830:	f8a7 30cc 	strh.w	r3, [r7, #204]	; 0xcc
    draw_area.y1 = LV_MATH_MIN(p1.y, p2.y) - w;
 8015834:	f9b7 20d2 	ldrsh.w	r2, [r7, #210]	; 0xd2
 8015838:	f9b7 30d6 	ldrsh.w	r3, [r7, #214]	; 0xd6
 801583c:	4293      	cmp	r3, r2
 801583e:	bfa8      	it	ge
 8015840:	4613      	movge	r3, r2
 8015842:	b21b      	sxth	r3, r3
 8015844:	b29a      	uxth	r2, r3
 8015846:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 801584a:	b29b      	uxth	r3, r3
 801584c:	1ad3      	subs	r3, r2, r3
 801584e:	b29b      	uxth	r3, r3
 8015850:	b21b      	sxth	r3, r3
 8015852:	f8a7 30ca 	strh.w	r3, [r7, #202]	; 0xca
    draw_area.y2 = LV_MATH_MAX(p1.y, p2.y) + w;
 8015856:	f9b7 20d2 	ldrsh.w	r2, [r7, #210]	; 0xd2
 801585a:	f9b7 30d6 	ldrsh.w	r3, [r7, #214]	; 0xd6
 801585e:	4293      	cmp	r3, r2
 8015860:	bfb8      	it	lt
 8015862:	4613      	movlt	r3, r2
 8015864:	b21b      	sxth	r3, r3
 8015866:	b29a      	uxth	r2, r3
 8015868:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 801586c:	b29b      	uxth	r3, r3
 801586e:	4413      	add	r3, r2
 8015870:	b29b      	uxth	r3, r3
 8015872:	b21b      	sxth	r3, r3
 8015874:	f8a7 30ce 	strh.w	r3, [r7, #206]	; 0xce

    /* Get the union of `coords` and `clip`*/
    /* `clip` is already truncated to the `vdb` size
     * in 'lv_refr_area' function */
    bool is_common = _lv_area_intersect(&draw_area, &draw_area, clip);
 8015878:	f507 7394 	add.w	r3, r7, #296	; 0x128
 801587c:	f5a3 7392 	sub.w	r3, r3, #292	; 0x124
 8015880:	f107 01c8 	add.w	r1, r7, #200	; 0xc8
 8015884:	f107 00c8 	add.w	r0, r7, #200	; 0xc8
 8015888:	681a      	ldr	r2, [r3, #0]
 801588a:	f009 fdef 	bl	801f46c <_lv_area_intersect>
 801588e:	4603      	mov	r3, r0
 8015890:	f887 30ff 	strb.w	r3, [r7, #255]	; 0xff
    if(is_common == false) return;
 8015894:	f897 30ff 	ldrb.w	r3, [r7, #255]	; 0xff
 8015898:	f083 0301 	eor.w	r3, r3, #1
 801589c:	b2db      	uxtb	r3, r3
 801589e:	2b00      	cmp	r3, #0
 80158a0:	f040 82f2 	bne.w	8015e88 <draw_line_skew+0x850>
    lv_draw_mask_line_param_t mask_left_param;
    lv_draw_mask_line_param_t mask_right_param;
    lv_draw_mask_line_param_t mask_top_param;
    lv_draw_mask_line_param_t mask_bottom_param;

    if(flat) {
 80158a4:	f897 310f 	ldrb.w	r3, [r7, #271]	; 0x10f
 80158a8:	2b00      	cmp	r3, #0
 80158aa:	f000 8085 	beq.w	80159b8 <draw_line_skew+0x380>
        if(xdiff > 0) {
 80158ae:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 80158b2:	2b00      	cmp	r3, #0
 80158b4:	dd3e      	ble.n	8015934 <draw_line_skew+0x2fc>
            lv_draw_mask_line_points_init(&mask_left_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,
 80158b6:	f9b7 10d4 	ldrsh.w	r1, [r7, #212]	; 0xd4
 80158ba:	f9b7 30d6 	ldrsh.w	r3, [r7, #214]	; 0xd6
 80158be:	b29a      	uxth	r2, r3
 80158c0:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80158c4:	b29b      	uxth	r3, r3
 80158c6:	1ad3      	subs	r3, r2, r3
 80158c8:	b29b      	uxth	r3, r3
 80158ca:	b21c      	sxth	r4, r3
 80158cc:	f9b7 50d0 	ldrsh.w	r5, [r7, #208]	; 0xd0
 80158d0:	f9b7 30d2 	ldrsh.w	r3, [r7, #210]	; 0xd2
 80158d4:	b29a      	uxth	r2, r3
 80158d6:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 80158da:	b29b      	uxth	r3, r3
 80158dc:	1ad3      	subs	r3, r2, r3
 80158de:	b29b      	uxth	r3, r3
 80158e0:	b21b      	sxth	r3, r3
 80158e2:	f107 009c 	add.w	r0, r7, #156	; 0x9c
 80158e6:	2200      	movs	r2, #0
 80158e8:	9201      	str	r2, [sp, #4]
 80158ea:	9300      	str	r3, [sp, #0]
 80158ec:	462b      	mov	r3, r5
 80158ee:	4622      	mov	r2, r4
 80158f0:	f000 fc1c 	bl	801612c <lv_draw_mask_line_points_init>
                                          LV_DRAW_MASK_LINE_SIDE_LEFT);
            lv_draw_mask_line_points_init(&mask_right_param, p1.x, p1.y + w_half1, p2.x, p2.y + w_half1,
 80158f4:	f9b7 10d4 	ldrsh.w	r1, [r7, #212]	; 0xd4
 80158f8:	f9b7 30d6 	ldrsh.w	r3, [r7, #214]	; 0xd6
 80158fc:	b29a      	uxth	r2, r3
 80158fe:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8015902:	b29b      	uxth	r3, r3
 8015904:	4413      	add	r3, r2
 8015906:	b29b      	uxth	r3, r3
 8015908:	b21c      	sxth	r4, r3
 801590a:	f9b7 50d0 	ldrsh.w	r5, [r7, #208]	; 0xd0
 801590e:	f9b7 30d2 	ldrsh.w	r3, [r7, #210]	; 0xd2
 8015912:	b29a      	uxth	r2, r3
 8015914:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8015918:	b29b      	uxth	r3, r3
 801591a:	4413      	add	r3, r2
 801591c:	b29b      	uxth	r3, r3
 801591e:	b21b      	sxth	r3, r3
 8015920:	f107 0070 	add.w	r0, r7, #112	; 0x70
 8015924:	2201      	movs	r2, #1
 8015926:	9201      	str	r2, [sp, #4]
 8015928:	9300      	str	r3, [sp, #0]
 801592a:	462b      	mov	r3, r5
 801592c:	4622      	mov	r2, r4
 801592e:	f000 fbfd 	bl	801612c <lv_draw_mask_line_points_init>
 8015932:	e07f      	b.n	8015a34 <draw_line_skew+0x3fc>
                                          LV_DRAW_MASK_LINE_SIDE_RIGHT);
        }
        else {
            lv_draw_mask_line_points_init(&mask_left_param, p1.x, p1.y + w_half1, p2.x, p2.y + w_half1,
 8015934:	f9b7 10d4 	ldrsh.w	r1, [r7, #212]	; 0xd4
 8015938:	f9b7 30d6 	ldrsh.w	r3, [r7, #214]	; 0xd6
 801593c:	b29a      	uxth	r2, r3
 801593e:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8015942:	b29b      	uxth	r3, r3
 8015944:	4413      	add	r3, r2
 8015946:	b29b      	uxth	r3, r3
 8015948:	b21c      	sxth	r4, r3
 801594a:	f9b7 50d0 	ldrsh.w	r5, [r7, #208]	; 0xd0
 801594e:	f9b7 30d2 	ldrsh.w	r3, [r7, #210]	; 0xd2
 8015952:	b29a      	uxth	r2, r3
 8015954:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8015958:	b29b      	uxth	r3, r3
 801595a:	4413      	add	r3, r2
 801595c:	b29b      	uxth	r3, r3
 801595e:	b21b      	sxth	r3, r3
 8015960:	f107 009c 	add.w	r0, r7, #156	; 0x9c
 8015964:	2200      	movs	r2, #0
 8015966:	9201      	str	r2, [sp, #4]
 8015968:	9300      	str	r3, [sp, #0]
 801596a:	462b      	mov	r3, r5
 801596c:	4622      	mov	r2, r4
 801596e:	f000 fbdd 	bl	801612c <lv_draw_mask_line_points_init>
                                          LV_DRAW_MASK_LINE_SIDE_LEFT);
            lv_draw_mask_line_points_init(&mask_right_param, p1.x, p1.y - w_half0, p2.x, p2.y - w_half0,
 8015972:	f9b7 10d4 	ldrsh.w	r1, [r7, #212]	; 0xd4
 8015976:	f9b7 30d6 	ldrsh.w	r3, [r7, #214]	; 0xd6
 801597a:	b29a      	uxth	r2, r3
 801597c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8015980:	b29b      	uxth	r3, r3
 8015982:	1ad3      	subs	r3, r2, r3
 8015984:	b29b      	uxth	r3, r3
 8015986:	b21c      	sxth	r4, r3
 8015988:	f9b7 50d0 	ldrsh.w	r5, [r7, #208]	; 0xd0
 801598c:	f9b7 30d2 	ldrsh.w	r3, [r7, #210]	; 0xd2
 8015990:	b29a      	uxth	r2, r3
 8015992:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8015996:	b29b      	uxth	r3, r3
 8015998:	1ad3      	subs	r3, r2, r3
 801599a:	b29b      	uxth	r3, r3
 801599c:	b21b      	sxth	r3, r3
 801599e:	f107 0070 	add.w	r0, r7, #112	; 0x70
 80159a2:	2201      	movs	r2, #1
 80159a4:	9201      	str	r2, [sp, #4]
 80159a6:	9300      	str	r3, [sp, #0]
 80159a8:	462b      	mov	r3, r5
 80159aa:	4622      	mov	r2, r4
 80159ac:	f000 fbbe 	bl	801612c <lv_draw_mask_line_points_init>
 80159b0:	e040      	b.n	8015a34 <draw_line_skew+0x3fc>
 80159b2:	bf00      	nop
 80159b4:	080e60ec 	.word	0x080e60ec
                                          LV_DRAW_MASK_LINE_SIDE_RIGHT);
        }
    }
    else {
        lv_draw_mask_line_points_init(&mask_left_param, p1.x + w_half1, p1.y, p2.x + w_half1, p2.y,
 80159b8:	f9b7 30d4 	ldrsh.w	r3, [r7, #212]	; 0xd4
 80159bc:	b29a      	uxth	r2, r3
 80159be:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 80159c2:	b29b      	uxth	r3, r3
 80159c4:	4413      	add	r3, r2
 80159c6:	b29b      	uxth	r3, r3
 80159c8:	b219      	sxth	r1, r3
 80159ca:	f9b7 40d6 	ldrsh.w	r4, [r7, #214]	; 0xd6
 80159ce:	f9b7 30d0 	ldrsh.w	r3, [r7, #208]	; 0xd0
 80159d2:	b29a      	uxth	r2, r3
 80159d4:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 80159d8:	b29b      	uxth	r3, r3
 80159da:	4413      	add	r3, r2
 80159dc:	b29b      	uxth	r3, r3
 80159de:	b21a      	sxth	r2, r3
 80159e0:	f9b7 30d2 	ldrsh.w	r3, [r7, #210]	; 0xd2
 80159e4:	f107 009c 	add.w	r0, r7, #156	; 0x9c
 80159e8:	2500      	movs	r5, #0
 80159ea:	9501      	str	r5, [sp, #4]
 80159ec:	9300      	str	r3, [sp, #0]
 80159ee:	4613      	mov	r3, r2
 80159f0:	4622      	mov	r2, r4
 80159f2:	f000 fb9b 	bl	801612c <lv_draw_mask_line_points_init>
                                      LV_DRAW_MASK_LINE_SIDE_LEFT);
        lv_draw_mask_line_points_init(&mask_right_param, p1.x - w_half0, p1.y, p2.x - w_half0, p2.y,
 80159f6:	f9b7 30d4 	ldrsh.w	r3, [r7, #212]	; 0xd4
 80159fa:	b29a      	uxth	r2, r3
 80159fc:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8015a00:	b29b      	uxth	r3, r3
 8015a02:	1ad3      	subs	r3, r2, r3
 8015a04:	b29b      	uxth	r3, r3
 8015a06:	b219      	sxth	r1, r3
 8015a08:	f9b7 40d6 	ldrsh.w	r4, [r7, #214]	; 0xd6
 8015a0c:	f9b7 30d0 	ldrsh.w	r3, [r7, #208]	; 0xd0
 8015a10:	b29a      	uxth	r2, r3
 8015a12:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8015a16:	b29b      	uxth	r3, r3
 8015a18:	1ad3      	subs	r3, r2, r3
 8015a1a:	b29b      	uxth	r3, r3
 8015a1c:	b21a      	sxth	r2, r3
 8015a1e:	f9b7 30d2 	ldrsh.w	r3, [r7, #210]	; 0xd2
 8015a22:	f107 0070 	add.w	r0, r7, #112	; 0x70
 8015a26:	2501      	movs	r5, #1
 8015a28:	9501      	str	r5, [sp, #4]
 8015a2a:	9300      	str	r3, [sp, #0]
 8015a2c:	4613      	mov	r3, r2
 8015a2e:	4622      	mov	r2, r4
 8015a30:	f000 fb7c 	bl	801612c <lv_draw_mask_line_points_init>
                                      LV_DRAW_MASK_LINE_SIDE_RIGHT);
    }

    /*Use the normal vector for the endings*/

    int16_t mask_left_id = lv_draw_mask_add(&mask_left_param, NULL);
 8015a34:	f107 039c 	add.w	r3, r7, #156	; 0x9c
 8015a38:	2100      	movs	r1, #0
 8015a3a:	4618      	mov	r0, r3
 8015a3c:	f000 fa88 	bl	8015f50 <lv_draw_mask_add>
 8015a40:	4603      	mov	r3, r0
 8015a42:	f8a7 30fc 	strh.w	r3, [r7, #252]	; 0xfc
    int16_t mask_right_id = lv_draw_mask_add(&mask_right_param, NULL);
 8015a46:	f107 0370 	add.w	r3, r7, #112	; 0x70
 8015a4a:	2100      	movs	r1, #0
 8015a4c:	4618      	mov	r0, r3
 8015a4e:	f000 fa7f 	bl	8015f50 <lv_draw_mask_add>
 8015a52:	4603      	mov	r3, r0
 8015a54:	f8a7 30fa 	strh.w	r3, [r7, #250]	; 0xfa
    int16_t mask_top_id = LV_MASK_ID_INV;
 8015a58:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8015a5c:	f8a7 3122 	strh.w	r3, [r7, #290]	; 0x122
    int16_t mask_bottom_id = LV_MASK_ID_INV;
 8015a60:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8015a64:	f8a7 3120 	strh.w	r3, [r7, #288]	; 0x120

    if(!dsc->raw_end) {
 8015a68:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015a6c:	f5a3 7394 	sub.w	r3, r3, #296	; 0x128
 8015a70:	681b      	ldr	r3, [r3, #0]
 8015a72:	7a5b      	ldrb	r3, [r3, #9]
 8015a74:	f003 0310 	and.w	r3, r3, #16
 8015a78:	b2db      	uxtb	r3, r3
 8015a7a:	2b00      	cmp	r3, #0
 8015a7c:	d14f      	bne.n	8015b1e <draw_line_skew+0x4e6>
        lv_draw_mask_line_points_init(&mask_top_param, p1.x, p1.y, p1.x - ydiff, p1.y + xdiff, LV_DRAW_MASK_LINE_SIDE_BOTTOM);
 8015a7e:	f9b7 10d4 	ldrsh.w	r1, [r7, #212]	; 0xd4
 8015a82:	f9b7 40d6 	ldrsh.w	r4, [r7, #214]	; 0xd6
 8015a86:	f9b7 30d4 	ldrsh.w	r3, [r7, #212]	; 0xd4
 8015a8a:	b29a      	uxth	r2, r3
 8015a8c:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8015a90:	b29b      	uxth	r3, r3
 8015a92:	1ad3      	subs	r3, r2, r3
 8015a94:	b29b      	uxth	r3, r3
 8015a96:	b21d      	sxth	r5, r3
 8015a98:	f9b7 30d6 	ldrsh.w	r3, [r7, #214]	; 0xd6
 8015a9c:	b29a      	uxth	r2, r3
 8015a9e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8015aa2:	b29b      	uxth	r3, r3
 8015aa4:	4413      	add	r3, r2
 8015aa6:	b29b      	uxth	r3, r3
 8015aa8:	b21b      	sxth	r3, r3
 8015aaa:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8015aae:	2203      	movs	r2, #3
 8015ab0:	9201      	str	r2, [sp, #4]
 8015ab2:	9300      	str	r3, [sp, #0]
 8015ab4:	462b      	mov	r3, r5
 8015ab6:	4622      	mov	r2, r4
 8015ab8:	f000 fb38 	bl	801612c <lv_draw_mask_line_points_init>
        lv_draw_mask_line_points_init(&mask_bottom_param, p2.x, p2.y, p2.x - ydiff, p2.y + xdiff,  LV_DRAW_MASK_LINE_SIDE_TOP);
 8015abc:	f9b7 10d0 	ldrsh.w	r1, [r7, #208]	; 0xd0
 8015ac0:	f9b7 40d2 	ldrsh.w	r4, [r7, #210]	; 0xd2
 8015ac4:	f9b7 30d0 	ldrsh.w	r3, [r7, #208]	; 0xd0
 8015ac8:	b29a      	uxth	r2, r3
 8015aca:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8015ace:	b29b      	uxth	r3, r3
 8015ad0:	1ad3      	subs	r3, r2, r3
 8015ad2:	b29b      	uxth	r3, r3
 8015ad4:	b21d      	sxth	r5, r3
 8015ad6:	f9b7 30d2 	ldrsh.w	r3, [r7, #210]	; 0xd2
 8015ada:	b29a      	uxth	r2, r3
 8015adc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8015ae0:	b29b      	uxth	r3, r3
 8015ae2:	4413      	add	r3, r2
 8015ae4:	b29b      	uxth	r3, r3
 8015ae6:	b21b      	sxth	r3, r3
 8015ae8:	f107 0018 	add.w	r0, r7, #24
 8015aec:	2202      	movs	r2, #2
 8015aee:	9201      	str	r2, [sp, #4]
 8015af0:	9300      	str	r3, [sp, #0]
 8015af2:	462b      	mov	r3, r5
 8015af4:	4622      	mov	r2, r4
 8015af6:	f000 fb19 	bl	801612c <lv_draw_mask_line_points_init>
        mask_top_id = lv_draw_mask_add(&mask_top_param, NULL);
 8015afa:	f107 0344 	add.w	r3, r7, #68	; 0x44
 8015afe:	2100      	movs	r1, #0
 8015b00:	4618      	mov	r0, r3
 8015b02:	f000 fa25 	bl	8015f50 <lv_draw_mask_add>
 8015b06:	4603      	mov	r3, r0
 8015b08:	f8a7 3122 	strh.w	r3, [r7, #290]	; 0x122
        mask_bottom_id = lv_draw_mask_add(&mask_bottom_param, NULL);
 8015b0c:	f107 0318 	add.w	r3, r7, #24
 8015b10:	2100      	movs	r1, #0
 8015b12:	4618      	mov	r0, r3
 8015b14:	f000 fa1c 	bl	8015f50 <lv_draw_mask_add>
 8015b18:	4603      	mov	r3, r0
 8015b1a:	f8a7 3120 	strh.w	r3, [r7, #288]	; 0x120
    }

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
 8015b1e:	f7f8 fc5f 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 8015b22:	f8c7 00f4 	str.w	r0, [r7, #244]	; 0xf4
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8015b26:	f8d7 00f4 	ldr.w	r0, [r7, #244]	; 0xf4
 8015b2a:	f009 f86f 	bl	801ec0c <lv_disp_get_buf>
 8015b2e:	f8c7 00f0 	str.w	r0, [r7, #240]	; 0xf0

    const lv_area_t * disp_area = &vdb->area;
 8015b32:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8015b36:	3310      	adds	r3, #16
 8015b38:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec

    /*Store the coordinates of the `draw_a` relative to the VDB */
    draw_area.x1 -= disp_area->x1;
 8015b3c:	f9b7 30c8 	ldrsh.w	r3, [r7, #200]	; 0xc8
 8015b40:	b29a      	uxth	r2, r3
 8015b42:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8015b46:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015b4a:	b29b      	uxth	r3, r3
 8015b4c:	1ad3      	subs	r3, r2, r3
 8015b4e:	b29b      	uxth	r3, r3
 8015b50:	b21b      	sxth	r3, r3
 8015b52:	f8a7 30c8 	strh.w	r3, [r7, #200]	; 0xc8
    draw_area.y1 -= disp_area->y1;
 8015b56:	f9b7 30ca 	ldrsh.w	r3, [r7, #202]	; 0xca
 8015b5a:	b29a      	uxth	r2, r3
 8015b5c:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8015b60:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015b64:	b29b      	uxth	r3, r3
 8015b66:	1ad3      	subs	r3, r2, r3
 8015b68:	b29b      	uxth	r3, r3
 8015b6a:	b21b      	sxth	r3, r3
 8015b6c:	f8a7 30ca 	strh.w	r3, [r7, #202]	; 0xca
    draw_area.x2 -= disp_area->x1;
 8015b70:	f9b7 30cc 	ldrsh.w	r3, [r7, #204]	; 0xcc
 8015b74:	b29a      	uxth	r2, r3
 8015b76:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8015b7a:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015b7e:	b29b      	uxth	r3, r3
 8015b80:	1ad3      	subs	r3, r2, r3
 8015b82:	b29b      	uxth	r3, r3
 8015b84:	b21b      	sxth	r3, r3
 8015b86:	f8a7 30cc 	strh.w	r3, [r7, #204]	; 0xcc
    draw_area.y2 -= disp_area->y1;
 8015b8a:	f9b7 30ce 	ldrsh.w	r3, [r7, #206]	; 0xce
 8015b8e:	b29a      	uxth	r2, r3
 8015b90:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8015b94:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015b98:	b29b      	uxth	r3, r3
 8015b9a:	1ad3      	subs	r3, r2, r3
 8015b9c:	b29b      	uxth	r3, r3
 8015b9e:	b21b      	sxth	r3, r3
 8015ba0:	f8a7 30ce 	strh.w	r3, [r7, #206]	; 0xce

    /* The real draw area is around the line.
     * It's easy to calculate with steep lines, but the area can be very wide with very flat lines.
     * So deal with it only with steep lines. */
    int32_t draw_area_w = lv_area_get_width(&draw_area);
 8015ba4:	f107 03c8 	add.w	r3, r7, #200	; 0xc8
 8015ba8:	4618      	mov	r0, r3
 8015baa:	f7ff f827 	bl	8014bfc <lv_area_get_width>
 8015bae:	4603      	mov	r3, r0
 8015bb0:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8

    /*Draw the background line by line*/
    int32_t h;
    size_t mask_buf_size = LV_MATH_MIN(lv_area_get_size(&draw_area), LV_HOR_RES_MAX);
 8015bb4:	f107 03c8 	add.w	r3, r7, #200	; 0xc8
 8015bb8:	4618      	mov	r0, r3
 8015bba:	f009 fc36 	bl	801f42a <lv_area_get_size>
 8015bbe:	4603      	mov	r3, r0
 8015bc0:	f5b3 7f48 	cmp.w	r3, #800	; 0x320
 8015bc4:	d206      	bcs.n	8015bd4 <draw_line_skew+0x59c>
 8015bc6:	f107 03c8 	add.w	r3, r7, #200	; 0xc8
 8015bca:	4618      	mov	r0, r3
 8015bcc:	f009 fc2d 	bl	801f42a <lv_area_get_size>
 8015bd0:	4603      	mov	r3, r0
 8015bd2:	e001      	b.n	8015bd8 <draw_line_skew+0x5a0>
 8015bd4:	f44f 7348 	mov.w	r3, #800	; 0x320
 8015bd8:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    lv_opa_t * mask_buf = _lv_mem_buf_get(mask_buf_size);
 8015bdc:	f8d7 00e4 	ldr.w	r0, [r7, #228]	; 0xe4
 8015be0:	f00b f956 	bl	8020e90 <_lv_mem_buf_get>
 8015be4:	f8c7 00e0 	str.w	r0, [r7, #224]	; 0xe0

    lv_area_t fill_area;
    fill_area.x1 = draw_area.x1 + disp_area->x1;
 8015be8:	f9b7 30c8 	ldrsh.w	r3, [r7, #200]	; 0xc8
 8015bec:	b29a      	uxth	r2, r3
 8015bee:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8015bf2:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015bf6:	b29b      	uxth	r3, r3
 8015bf8:	4413      	add	r3, r2
 8015bfa:	b29b      	uxth	r3, r3
 8015bfc:	b21a      	sxth	r2, r3
 8015bfe:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015c02:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015c06:	801a      	strh	r2, [r3, #0]
    fill_area.x2 = draw_area.x2 + disp_area->x1;
 8015c08:	f9b7 30cc 	ldrsh.w	r3, [r7, #204]	; 0xcc
 8015c0c:	b29a      	uxth	r2, r3
 8015c0e:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8015c12:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015c16:	b29b      	uxth	r3, r3
 8015c18:	4413      	add	r3, r2
 8015c1a:	b29b      	uxth	r3, r3
 8015c1c:	b21a      	sxth	r2, r3
 8015c1e:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015c22:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015c26:	809a      	strh	r2, [r3, #4]
    fill_area.y1 = draw_area.y1 + disp_area->y1;
 8015c28:	f9b7 30ca 	ldrsh.w	r3, [r7, #202]	; 0xca
 8015c2c:	b29a      	uxth	r2, r3
 8015c2e:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8015c32:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015c36:	b29b      	uxth	r3, r3
 8015c38:	4413      	add	r3, r2
 8015c3a:	b29b      	uxth	r3, r3
 8015c3c:	b21a      	sxth	r2, r3
 8015c3e:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015c42:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015c46:	805a      	strh	r2, [r3, #2]
    fill_area.y2 = fill_area.y1;
 8015c48:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015c4c:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015c50:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8015c54:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015c58:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015c5c:	80da      	strh	r2, [r3, #6]

    int32_t x = vdb->area.x1 + draw_area.x1;
 8015c5e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8015c62:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8015c66:	461a      	mov	r2, r3
 8015c68:	f9b7 30c8 	ldrsh.w	r3, [r7, #200]	; 0xc8
 8015c6c:	4413      	add	r3, r2
 8015c6e:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc

    uint32_t mask_p = 0;
 8015c72:	2300      	movs	r3, #0
 8015c74:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118

    _lv_memset_ff(mask_buf, mask_buf_size);
 8015c78:	f8d7 10e4 	ldr.w	r1, [r7, #228]	; 0xe4
 8015c7c:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
 8015c80:	f00b fd93 	bl	80217aa <_lv_memset_ff>
    /*Fill the first row with 'color'*/
    for(h = draw_area.y1 + disp_area->y1; h <= draw_area.y2 + disp_area->y1; h++) {
 8015c84:	f9b7 30ca 	ldrsh.w	r3, [r7, #202]	; 0xca
 8015c88:	461a      	mov	r2, r3
 8015c8a:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8015c8e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015c92:	4413      	add	r3, r2
 8015c94:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 8015c98:	e08e      	b.n	8015db8 <draw_line_skew+0x780>

        lv_draw_mask_res_t mask_res = lv_draw_mask_apply(&mask_buf[mask_p], x, h, draw_area_w);
 8015c9a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 8015c9e:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8015ca2:	18d0      	adds	r0, r2, r3
 8015ca4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8015ca8:	b219      	sxth	r1, r3
 8015caa:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8015cae:	b21a      	sxth	r2, r3
 8015cb0:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8015cb4:	b21b      	sxth	r3, r3
 8015cb6:	f000 f97d 	bl	8015fb4 <lv_draw_mask_apply>
 8015cba:	4603      	mov	r3, r0
 8015cbc:	f887 30db 	strb.w	r3, [r7, #219]	; 0xdb
        if(mask_res == LV_DRAW_MASK_RES_TRANSP) {
 8015cc0:	f897 30db 	ldrb.w	r3, [r7, #219]	; 0xdb
 8015cc4:	2b00      	cmp	r3, #0
 8015cc6:	d10a      	bne.n	8015cde <draw_line_skew+0x6a6>
            _lv_memset_00(&mask_buf[mask_p], draw_area_w);
 8015cc8:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 8015ccc:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8015cd0:	4413      	add	r3, r2
 8015cd2:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 8015cd6:	4611      	mov	r1, r2
 8015cd8:	4618      	mov	r0, r3
 8015cda:	f00b fce5 	bl	80216a8 <_lv_memset_00>
        }

        mask_p += draw_area_w;
 8015cde:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8015ce2:	f8d7 2118 	ldr.w	r2, [r7, #280]	; 0x118
 8015ce6:	4413      	add	r3, r2
 8015ce8:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
        if((uint32_t) mask_p + draw_area_w < mask_buf_size) {
 8015cec:	f8d7 20e8 	ldr.w	r2, [r7, #232]	; 0xe8
 8015cf0:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8015cf4:	4413      	add	r3, r2
 8015cf6:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 8015cfa:	429a      	cmp	r2, r3
 8015cfc:	d90f      	bls.n	8015d1e <draw_line_skew+0x6e6>
            fill_area.y2 ++;
 8015cfe:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015d02:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015d06:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015d0a:	b29b      	uxth	r3, r3
 8015d0c:	3301      	adds	r3, #1
 8015d0e:	b29b      	uxth	r3, r3
 8015d10:	b21a      	sxth	r2, r3
 8015d12:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015d16:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015d1a:	80da      	strh	r2, [r3, #6]
 8015d1c:	e047      	b.n	8015dae <draw_line_skew+0x776>
        }
        else {
            _lv_blend_fill(&fill_area, clip,
                           dsc->color, mask_buf, LV_DRAW_MASK_RES_CHANGED, dsc->opa,
 8015d1e:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015d22:	f5a3 7394 	sub.w	r3, r3, #296	; 0x128
 8015d26:	681b      	ldr	r3, [r3, #0]
 8015d28:	7a1b      	ldrb	r3, [r3, #8]
                           dsc->blend_mode);
 8015d2a:	f507 7294 	add.w	r2, r7, #296	; 0x128
 8015d2e:	f5a2 7294 	sub.w	r2, r2, #296	; 0x128
 8015d32:	6812      	ldr	r2, [r2, #0]
 8015d34:	7a52      	ldrb	r2, [r2, #9]
 8015d36:	f3c2 0201 	ubfx	r2, r2, #0, #2
 8015d3a:	b2d2      	uxtb	r2, r2
            _lv_blend_fill(&fill_area, clip,
 8015d3c:	4614      	mov	r4, r2
 8015d3e:	f507 7294 	add.w	r2, r7, #296	; 0x128
 8015d42:	f5a2 7294 	sub.w	r2, r2, #296	; 0x128
 8015d46:	6812      	ldr	r2, [r2, #0]
 8015d48:	f507 7194 	add.w	r1, r7, #296	; 0x128
 8015d4c:	f5a1 7192 	sub.w	r1, r1, #292	; 0x124
 8015d50:	f107 0010 	add.w	r0, r7, #16
 8015d54:	9402      	str	r4, [sp, #8]
 8015d56:	9301      	str	r3, [sp, #4]
 8015d58:	2302      	movs	r3, #2
 8015d5a:	9300      	str	r3, [sp, #0]
 8015d5c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8015d60:	8812      	ldrh	r2, [r2, #0]
 8015d62:	6809      	ldr	r1, [r1, #0]
 8015d64:	f7fa fd7e 	bl	8010864 <_lv_blend_fill>

            fill_area.y1 = fill_area.y2 + 1;
 8015d68:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015d6c:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015d70:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015d74:	b29b      	uxth	r3, r3
 8015d76:	3301      	adds	r3, #1
 8015d78:	b29b      	uxth	r3, r3
 8015d7a:	b21a      	sxth	r2, r3
 8015d7c:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015d80:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015d84:	805a      	strh	r2, [r3, #2]
            fill_area.y2 = fill_area.y1;
 8015d86:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015d8a:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015d8e:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8015d92:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015d96:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015d9a:	80da      	strh	r2, [r3, #6]
            mask_p = 0;
 8015d9c:	2300      	movs	r3, #0
 8015d9e:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
            _lv_memset_ff(mask_buf, mask_buf_size);
 8015da2:	f8d7 10e4 	ldr.w	r1, [r7, #228]	; 0xe4
 8015da6:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
 8015daa:	f00b fcfe 	bl	80217aa <_lv_memset_ff>
    for(h = draw_area.y1 + disp_area->y1; h <= draw_area.y2 + disp_area->y1; h++) {
 8015dae:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8015db2:	3301      	adds	r3, #1
 8015db4:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 8015db8:	f9b7 30ce 	ldrsh.w	r3, [r7, #206]	; 0xce
 8015dbc:	461a      	mov	r2, r3
 8015dbe:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8015dc2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015dc6:	4413      	add	r3, r2
 8015dc8:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8015dcc:	429a      	cmp	r2, r3
 8015dce:	f77f af64 	ble.w	8015c9a <draw_line_skew+0x662>
        }
    }

    /*Flush the last part*/
    if(fill_area.y1 != fill_area.y2) {
 8015dd2:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015dd6:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015dda:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8015dde:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015de2:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015de6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015dea:	429a      	cmp	r2, r3
 8015dec:	d033      	beq.n	8015e56 <draw_line_skew+0x81e>
        fill_area.y2--;
 8015dee:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015df2:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015df6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015dfa:	b29b      	uxth	r3, r3
 8015dfc:	3b01      	subs	r3, #1
 8015dfe:	b29b      	uxth	r3, r3
 8015e00:	b21a      	sxth	r2, r3
 8015e02:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015e06:	f5a3 738c 	sub.w	r3, r3, #280	; 0x118
 8015e0a:	80da      	strh	r2, [r3, #6]
        _lv_blend_fill(&fill_area, clip,
                       dsc->color, mask_buf, LV_DRAW_MASK_RES_CHANGED, dsc->opa,
 8015e0c:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8015e10:	f5a3 7394 	sub.w	r3, r3, #296	; 0x128
 8015e14:	681b      	ldr	r3, [r3, #0]
 8015e16:	7a1b      	ldrb	r3, [r3, #8]
                       dsc->blend_mode);
 8015e18:	f507 7294 	add.w	r2, r7, #296	; 0x128
 8015e1c:	f5a2 7294 	sub.w	r2, r2, #296	; 0x128
 8015e20:	6812      	ldr	r2, [r2, #0]
 8015e22:	7a52      	ldrb	r2, [r2, #9]
 8015e24:	f3c2 0201 	ubfx	r2, r2, #0, #2
 8015e28:	b2d2      	uxtb	r2, r2
        _lv_blend_fill(&fill_area, clip,
 8015e2a:	4614      	mov	r4, r2
 8015e2c:	f507 7294 	add.w	r2, r7, #296	; 0x128
 8015e30:	f5a2 7294 	sub.w	r2, r2, #296	; 0x128
 8015e34:	6812      	ldr	r2, [r2, #0]
 8015e36:	f507 7194 	add.w	r1, r7, #296	; 0x128
 8015e3a:	f5a1 7192 	sub.w	r1, r1, #292	; 0x124
 8015e3e:	f107 0010 	add.w	r0, r7, #16
 8015e42:	9402      	str	r4, [sp, #8]
 8015e44:	9301      	str	r3, [sp, #4]
 8015e46:	2302      	movs	r3, #2
 8015e48:	9300      	str	r3, [sp, #0]
 8015e4a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8015e4e:	8812      	ldrh	r2, [r2, #0]
 8015e50:	6809      	ldr	r1, [r1, #0]
 8015e52:	f7fa fd07 	bl	8010864 <_lv_blend_fill>

    }

    _lv_mem_buf_release(mask_buf);
 8015e56:	f8d7 00e0 	ldr.w	r0, [r7, #224]	; 0xe0
 8015e5a:	f00b f8f9 	bl	8021050 <_lv_mem_buf_release>

    lv_draw_mask_remove_id(mask_left_id);
 8015e5e:	f9b7 30fc 	ldrsh.w	r3, [r7, #252]	; 0xfc
 8015e62:	4618      	mov	r0, r3
 8015e64:	f000 f8ea 	bl	801603c <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_right_id);
 8015e68:	f9b7 30fa 	ldrsh.w	r3, [r7, #250]	; 0xfa
 8015e6c:	4618      	mov	r0, r3
 8015e6e:	f000 f8e5 	bl	801603c <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_top_id);
 8015e72:	f9b7 3122 	ldrsh.w	r3, [r7, #290]	; 0x122
 8015e76:	4618      	mov	r0, r3
 8015e78:	f000 f8e0 	bl	801603c <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_bottom_id);
 8015e7c:	f9b7 3120 	ldrsh.w	r3, [r7, #288]	; 0x120
 8015e80:	4618      	mov	r0, r3
 8015e82:	f000 f8db 	bl	801603c <lv_draw_mask_remove_id>
 8015e86:	e000      	b.n	8015e8a <draw_line_skew+0x852>
    if(is_common == false) return;
 8015e88:	bf00      	nop
}
 8015e8a:	f507 7794 	add.w	r7, r7, #296	; 0x128
 8015e8e:	46bd      	mov	sp, r7
 8015e90:	bdb0      	pop	{r4, r5, r7, pc}
 8015e92:	bf00      	nop

08015e94 <_lv_memcpy_small>:
{
 8015e94:	b480      	push	{r7}
 8015e96:	b087      	sub	sp, #28
 8015e98:	af00      	add	r7, sp, #0
 8015e9a:	60f8      	str	r0, [r7, #12]
 8015e9c:	60b9      	str	r1, [r7, #8]
 8015e9e:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 8015ea0:	68fb      	ldr	r3, [r7, #12]
 8015ea2:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 8015ea4:	68bb      	ldr	r3, [r7, #8]
 8015ea6:	613b      	str	r3, [r7, #16]
    while(len) {
 8015ea8:	e00c      	b.n	8015ec4 <_lv_memcpy_small+0x30>
        *d8 = *s8;
 8015eaa:	693b      	ldr	r3, [r7, #16]
 8015eac:	781a      	ldrb	r2, [r3, #0]
 8015eae:	697b      	ldr	r3, [r7, #20]
 8015eb0:	701a      	strb	r2, [r3, #0]
        d8++;
 8015eb2:	697b      	ldr	r3, [r7, #20]
 8015eb4:	3301      	adds	r3, #1
 8015eb6:	617b      	str	r3, [r7, #20]
        s8++;
 8015eb8:	693b      	ldr	r3, [r7, #16]
 8015eba:	3301      	adds	r3, #1
 8015ebc:	613b      	str	r3, [r7, #16]
        len--;
 8015ebe:	687b      	ldr	r3, [r7, #4]
 8015ec0:	3b01      	subs	r3, #1
 8015ec2:	607b      	str	r3, [r7, #4]
    while(len) {
 8015ec4:	687b      	ldr	r3, [r7, #4]
 8015ec6:	2b00      	cmp	r3, #0
 8015ec8:	d1ef      	bne.n	8015eaa <_lv_memcpy_small+0x16>
    return dst;
 8015eca:	68fb      	ldr	r3, [r7, #12]
}
 8015ecc:	4618      	mov	r0, r3
 8015ece:	371c      	adds	r7, #28
 8015ed0:	46bd      	mov	sp, r7
 8015ed2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015ed6:	4770      	bx	lr

08015ed8 <lv_area_copy>:
{
 8015ed8:	b580      	push	{r7, lr}
 8015eda:	b082      	sub	sp, #8
 8015edc:	af00      	add	r7, sp, #0
 8015ede:	6078      	str	r0, [r7, #4]
 8015ee0:	6039      	str	r1, [r7, #0]
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
 8015ee2:	2208      	movs	r2, #8
 8015ee4:	6839      	ldr	r1, [r7, #0]
 8015ee6:	6878      	ldr	r0, [r7, #4]
 8015ee8:	f7ff ffd4 	bl	8015e94 <_lv_memcpy_small>
}
 8015eec:	bf00      	nop
 8015eee:	3708      	adds	r7, #8
 8015ef0:	46bd      	mov	sp, r7
 8015ef2:	bd80      	pop	{r7, pc}

08015ef4 <lv_area_get_width>:
{
 8015ef4:	b480      	push	{r7}
 8015ef6:	b083      	sub	sp, #12
 8015ef8:	af00      	add	r7, sp, #0
 8015efa:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 8015efc:	687b      	ldr	r3, [r7, #4]
 8015efe:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8015f02:	b29a      	uxth	r2, r3
 8015f04:	687b      	ldr	r3, [r7, #4]
 8015f06:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015f0a:	b29b      	uxth	r3, r3
 8015f0c:	1ad3      	subs	r3, r2, r3
 8015f0e:	b29b      	uxth	r3, r3
 8015f10:	3301      	adds	r3, #1
 8015f12:	b29b      	uxth	r3, r3
 8015f14:	b21b      	sxth	r3, r3
}
 8015f16:	4618      	mov	r0, r3
 8015f18:	370c      	adds	r7, #12
 8015f1a:	46bd      	mov	sp, r7
 8015f1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015f20:	4770      	bx	lr

08015f22 <lv_area_get_height>:
{
 8015f22:	b480      	push	{r7}
 8015f24:	b083      	sub	sp, #12
 8015f26:	af00      	add	r7, sp, #0
 8015f28:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 8015f2a:	687b      	ldr	r3, [r7, #4]
 8015f2c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015f30:	b29a      	uxth	r2, r3
 8015f32:	687b      	ldr	r3, [r7, #4]
 8015f34:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015f38:	b29b      	uxth	r3, r3
 8015f3a:	1ad3      	subs	r3, r2, r3
 8015f3c:	b29b      	uxth	r3, r3
 8015f3e:	3301      	adds	r3, #1
 8015f40:	b29b      	uxth	r3, r3
 8015f42:	b21b      	sxth	r3, r3
}
 8015f44:	4618      	mov	r0, r3
 8015f46:	370c      	adds	r7, #12
 8015f48:	46bd      	mov	sp, r7
 8015f4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015f4e:	4770      	bx	lr

08015f50 <lv_draw_mask_add>:
 * @param param an initialized mask parameter. Only the pointer is saved.
 * @param custom_id a custom pointer to identify the mask. Used in `lv_draw_mask_remove_custom`.
 * @return the an integer, the ID of the mask. Can be used in `lv_draw_mask_remove_id`.
 */
int16_t lv_draw_mask_add(void * param, void * custom_id)
{
 8015f50:	b480      	push	{r7}
 8015f52:	b085      	sub	sp, #20
 8015f54:	af00      	add	r7, sp, #0
 8015f56:	6078      	str	r0, [r7, #4]
 8015f58:	6039      	str	r1, [r7, #0]
    /*Look for a free entry*/
    uint8_t i;
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
 8015f5a:	2300      	movs	r3, #0
 8015f5c:	73fb      	strb	r3, [r7, #15]
 8015f5e:	e008      	b.n	8015f72 <lv_draw_mask_add+0x22>
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).param == NULL) break;
 8015f60:	7bfb      	ldrb	r3, [r7, #15]
 8015f62:	4a13      	ldr	r2, [pc, #76]	; (8015fb0 <lv_draw_mask_add+0x60>)
 8015f64:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8015f68:	2b00      	cmp	r3, #0
 8015f6a:	d006      	beq.n	8015f7a <lv_draw_mask_add+0x2a>
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
 8015f6c:	7bfb      	ldrb	r3, [r7, #15]
 8015f6e:	3301      	adds	r3, #1
 8015f70:	73fb      	strb	r3, [r7, #15]
 8015f72:	7bfb      	ldrb	r3, [r7, #15]
 8015f74:	2b0f      	cmp	r3, #15
 8015f76:	d9f3      	bls.n	8015f60 <lv_draw_mask_add+0x10>
 8015f78:	e000      	b.n	8015f7c <lv_draw_mask_add+0x2c>
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).param == NULL) break;
 8015f7a:	bf00      	nop
    }

    if(i >= _LV_MASK_MAX_NUM) {
 8015f7c:	7bfb      	ldrb	r3, [r7, #15]
 8015f7e:	2b0f      	cmp	r3, #15
 8015f80:	d902      	bls.n	8015f88 <lv_draw_mask_add+0x38>
        LV_LOG_WARN("lv_mask_add: no place to add the mask");
        return LV_MASK_ID_INV;
 8015f82:	f04f 33ff 	mov.w	r3, #4294967295
 8015f86:	e00c      	b.n	8015fa2 <lv_draw_mask_add+0x52>
    }

    LV_GC_ROOT(_lv_draw_mask_list[i]).param = param;
 8015f88:	7bfb      	ldrb	r3, [r7, #15]
 8015f8a:	4909      	ldr	r1, [pc, #36]	; (8015fb0 <lv_draw_mask_add+0x60>)
 8015f8c:	687a      	ldr	r2, [r7, #4]
 8015f8e:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
    LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id = custom_id;
 8015f92:	7bfb      	ldrb	r3, [r7, #15]
 8015f94:	4a06      	ldr	r2, [pc, #24]	; (8015fb0 <lv_draw_mask_add+0x60>)
 8015f96:	00db      	lsls	r3, r3, #3
 8015f98:	4413      	add	r3, r2
 8015f9a:	683a      	ldr	r2, [r7, #0]
 8015f9c:	605a      	str	r2, [r3, #4]

    return i;
 8015f9e:	7bfb      	ldrb	r3, [r7, #15]
 8015fa0:	b21b      	sxth	r3, r3
}
 8015fa2:	4618      	mov	r0, r3
 8015fa4:	3714      	adds	r7, #20
 8015fa6:	46bd      	mov	sp, r7
 8015fa8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015fac:	4770      	bx	lr
 8015fae:	bf00      	nop
 8015fb0:	2000a25c 	.word	0x2000a25c

08015fb4 <lv_draw_mask_apply>:
 * - `LV_DRAW_MASK_RES_FULL_COVER`: the whole line is fully visible. `mask_buf` is unchanged
 * - `LV_DRAW_MASK_RES_CHANGED`: `mask_buf` has changed, it shows the desired opacity of each pixel in the given line
 */
LV_ATTRIBUTE_FAST_MEM lv_draw_mask_res_t lv_draw_mask_apply(lv_opa_t * mask_buf, lv_coord_t abs_x, lv_coord_t abs_y,
                                                            lv_coord_t len)
{
 8015fb4:	b590      	push	{r4, r7, lr}
 8015fb6:	b08b      	sub	sp, #44	; 0x2c
 8015fb8:	af02      	add	r7, sp, #8
 8015fba:	60f8      	str	r0, [r7, #12]
 8015fbc:	4608      	mov	r0, r1
 8015fbe:	4611      	mov	r1, r2
 8015fc0:	461a      	mov	r2, r3
 8015fc2:	4603      	mov	r3, r0
 8015fc4:	817b      	strh	r3, [r7, #10]
 8015fc6:	460b      	mov	r3, r1
 8015fc8:	813b      	strh	r3, [r7, #8]
 8015fca:	4613      	mov	r3, r2
 8015fcc:	80fb      	strh	r3, [r7, #6]
    bool changed = false;
 8015fce:	2300      	movs	r3, #0
 8015fd0:	77fb      	strb	r3, [r7, #31]
    lv_draw_mask_common_dsc_t * dsc;

    _lv_draw_mask_saved_t * m = LV_GC_ROOT(_lv_draw_mask_list);
 8015fd2:	4b19      	ldr	r3, [pc, #100]	; (8016038 <lv_draw_mask_apply+0x84>)
 8015fd4:	61bb      	str	r3, [r7, #24]

    while(m->param) {
 8015fd6:	e021      	b.n	801601c <lv_draw_mask_apply+0x68>
        dsc = m->param;
 8015fd8:	69bb      	ldr	r3, [r7, #24]
 8015fda:	681b      	ldr	r3, [r3, #0]
 8015fdc:	617b      	str	r3, [r7, #20]
        lv_draw_mask_res_t res = LV_DRAW_MASK_RES_FULL_COVER;
 8015fde:	2301      	movs	r3, #1
 8015fe0:	74fb      	strb	r3, [r7, #19]
        res = dsc->cb(mask_buf, abs_x, abs_y, len, (void *)m->param);
 8015fe2:	697b      	ldr	r3, [r7, #20]
 8015fe4:	681c      	ldr	r4, [r3, #0]
 8015fe6:	69bb      	ldr	r3, [r7, #24]
 8015fe8:	681b      	ldr	r3, [r3, #0]
 8015fea:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
 8015fee:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8015ff2:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 8015ff6:	9300      	str	r3, [sp, #0]
 8015ff8:	4603      	mov	r3, r0
 8015ffa:	68f8      	ldr	r0, [r7, #12]
 8015ffc:	47a0      	blx	r4
 8015ffe:	4603      	mov	r3, r0
 8016000:	74fb      	strb	r3, [r7, #19]
        if(res == LV_DRAW_MASK_RES_TRANSP) return LV_DRAW_MASK_RES_TRANSP;
 8016002:	7cfb      	ldrb	r3, [r7, #19]
 8016004:	2b00      	cmp	r3, #0
 8016006:	d101      	bne.n	801600c <lv_draw_mask_apply+0x58>
 8016008:	2300      	movs	r3, #0
 801600a:	e011      	b.n	8016030 <lv_draw_mask_apply+0x7c>
        else if(res == LV_DRAW_MASK_RES_CHANGED) changed = true;
 801600c:	7cfb      	ldrb	r3, [r7, #19]
 801600e:	2b02      	cmp	r3, #2
 8016010:	d101      	bne.n	8016016 <lv_draw_mask_apply+0x62>
 8016012:	2301      	movs	r3, #1
 8016014:	77fb      	strb	r3, [r7, #31]

        m++;
 8016016:	69bb      	ldr	r3, [r7, #24]
 8016018:	3308      	adds	r3, #8
 801601a:	61bb      	str	r3, [r7, #24]
    while(m->param) {
 801601c:	69bb      	ldr	r3, [r7, #24]
 801601e:	681b      	ldr	r3, [r3, #0]
 8016020:	2b00      	cmp	r3, #0
 8016022:	d1d9      	bne.n	8015fd8 <lv_draw_mask_apply+0x24>
    }

    return changed ? LV_DRAW_MASK_RES_CHANGED : LV_DRAW_MASK_RES_FULL_COVER;
 8016024:	7ffb      	ldrb	r3, [r7, #31]
 8016026:	2b00      	cmp	r3, #0
 8016028:	d001      	beq.n	801602e <lv_draw_mask_apply+0x7a>
 801602a:	2302      	movs	r3, #2
 801602c:	e000      	b.n	8016030 <lv_draw_mask_apply+0x7c>
 801602e:	2301      	movs	r3, #1
}
 8016030:	4618      	mov	r0, r3
 8016032:	3724      	adds	r7, #36	; 0x24
 8016034:	46bd      	mov	sp, r7
 8016036:	bd90      	pop	{r4, r7, pc}
 8016038:	2000a25c 	.word	0x2000a25c

0801603c <lv_draw_mask_remove_id>:
 * @param id the ID of the mask.  Returned by `lv_draw_mask_add`
 * @return the parameter of the removed mask.
 * If more masks have `custom_id` ID then the last mask's parameter will be returned
 */
void * lv_draw_mask_remove_id(int16_t id)
{
 801603c:	b480      	push	{r7}
 801603e:	b085      	sub	sp, #20
 8016040:	af00      	add	r7, sp, #0
 8016042:	4603      	mov	r3, r0
 8016044:	80fb      	strh	r3, [r7, #6]
    void * p = NULL;
 8016046:	2300      	movs	r3, #0
 8016048:	60fb      	str	r3, [r7, #12]

    if(id != LV_MASK_ID_INV) {
 801604a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801604e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8016052:	d012      	beq.n	801607a <lv_draw_mask_remove_id+0x3e>
        p = LV_GC_ROOT(_lv_draw_mask_list[id]).param;
 8016054:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016058:	4a0b      	ldr	r2, [pc, #44]	; (8016088 <lv_draw_mask_remove_id+0x4c>)
 801605a:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 801605e:	60fb      	str	r3, [r7, #12]
        LV_GC_ROOT(_lv_draw_mask_list[id]).param = NULL;
 8016060:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016064:	4a08      	ldr	r2, [pc, #32]	; (8016088 <lv_draw_mask_remove_id+0x4c>)
 8016066:	2100      	movs	r1, #0
 8016068:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
        LV_GC_ROOT(_lv_draw_mask_list[id]).custom_id = NULL;
 801606c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016070:	4a05      	ldr	r2, [pc, #20]	; (8016088 <lv_draw_mask_remove_id+0x4c>)
 8016072:	00db      	lsls	r3, r3, #3
 8016074:	4413      	add	r3, r2
 8016076:	2200      	movs	r2, #0
 8016078:	605a      	str	r2, [r3, #4]
    }

    return p;
 801607a:	68fb      	ldr	r3, [r7, #12]
}
 801607c:	4618      	mov	r0, r3
 801607e:	3714      	adds	r7, #20
 8016080:	46bd      	mov	sp, r7
 8016082:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016086:	4770      	bx	lr
 8016088:	2000a25c 	.word	0x2000a25c

0801608c <lv_draw_mask_remove_custom>:
 * @param custom_id a pointer used in `lv_draw_mask_add`
 * @return return the parameter of the removed mask.
 * If more masks have `custom_id` ID then the last mask's parameter will be returned
 */
void * lv_draw_mask_remove_custom(void * custom_id)
{
 801608c:	b480      	push	{r7}
 801608e:	b085      	sub	sp, #20
 8016090:	af00      	add	r7, sp, #0
 8016092:	6078      	str	r0, [r7, #4]
    void * p = NULL;
 8016094:	2300      	movs	r3, #0
 8016096:	60fb      	str	r3, [r7, #12]
    uint8_t i;
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
 8016098:	2300      	movs	r3, #0
 801609a:	72fb      	strb	r3, [r7, #11]
 801609c:	e01a      	b.n	80160d4 <lv_draw_mask_remove_custom+0x48>
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id == custom_id) {
 801609e:	7afb      	ldrb	r3, [r7, #11]
 80160a0:	4a11      	ldr	r2, [pc, #68]	; (80160e8 <lv_draw_mask_remove_custom+0x5c>)
 80160a2:	00db      	lsls	r3, r3, #3
 80160a4:	4413      	add	r3, r2
 80160a6:	685b      	ldr	r3, [r3, #4]
 80160a8:	687a      	ldr	r2, [r7, #4]
 80160aa:	429a      	cmp	r2, r3
 80160ac:	d10f      	bne.n	80160ce <lv_draw_mask_remove_custom+0x42>
            p = LV_GC_ROOT(_lv_draw_mask_list[i]).param;
 80160ae:	7afb      	ldrb	r3, [r7, #11]
 80160b0:	4a0d      	ldr	r2, [pc, #52]	; (80160e8 <lv_draw_mask_remove_custom+0x5c>)
 80160b2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 80160b6:	60fb      	str	r3, [r7, #12]
            LV_GC_ROOT(_lv_draw_mask_list[i]).param = NULL;
 80160b8:	7afb      	ldrb	r3, [r7, #11]
 80160ba:	4a0b      	ldr	r2, [pc, #44]	; (80160e8 <lv_draw_mask_remove_custom+0x5c>)
 80160bc:	2100      	movs	r1, #0
 80160be:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
            LV_GC_ROOT(_lv_draw_mask_list[i]).custom_id = NULL;
 80160c2:	7afb      	ldrb	r3, [r7, #11]
 80160c4:	4a08      	ldr	r2, [pc, #32]	; (80160e8 <lv_draw_mask_remove_custom+0x5c>)
 80160c6:	00db      	lsls	r3, r3, #3
 80160c8:	4413      	add	r3, r2
 80160ca:	2200      	movs	r2, #0
 80160cc:	605a      	str	r2, [r3, #4]
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
 80160ce:	7afb      	ldrb	r3, [r7, #11]
 80160d0:	3301      	adds	r3, #1
 80160d2:	72fb      	strb	r3, [r7, #11]
 80160d4:	7afb      	ldrb	r3, [r7, #11]
 80160d6:	2b0f      	cmp	r3, #15
 80160d8:	d9e1      	bls.n	801609e <lv_draw_mask_remove_custom+0x12>
        }
    }
    return p;
 80160da:	68fb      	ldr	r3, [r7, #12]
}
 80160dc:	4618      	mov	r0, r3
 80160de:	3714      	adds	r7, #20
 80160e0:	46bd      	mov	sp, r7
 80160e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80160e6:	4770      	bx	lr
 80160e8:	2000a25c 	.word	0x2000a25c

080160ec <lv_draw_mask_get_cnt>:
/**
 * Count the currently added masks
 * @return number of active masks
 */
LV_ATTRIBUTE_FAST_MEM uint8_t lv_draw_mask_get_cnt(void)
{
 80160ec:	b480      	push	{r7}
 80160ee:	b083      	sub	sp, #12
 80160f0:	af00      	add	r7, sp, #0
    uint8_t cnt = 0;
 80160f2:	2300      	movs	r3, #0
 80160f4:	71fb      	strb	r3, [r7, #7]
    uint8_t i;
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
 80160f6:	2300      	movs	r3, #0
 80160f8:	71bb      	strb	r3, [r7, #6]
 80160fa:	e00b      	b.n	8016114 <lv_draw_mask_get_cnt+0x28>
        if(LV_GC_ROOT(_lv_draw_mask_list[i]).param) cnt++;
 80160fc:	79bb      	ldrb	r3, [r7, #6]
 80160fe:	4a0a      	ldr	r2, [pc, #40]	; (8016128 <lv_draw_mask_get_cnt+0x3c>)
 8016100:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8016104:	2b00      	cmp	r3, #0
 8016106:	d002      	beq.n	801610e <lv_draw_mask_get_cnt+0x22>
 8016108:	79fb      	ldrb	r3, [r7, #7]
 801610a:	3301      	adds	r3, #1
 801610c:	71fb      	strb	r3, [r7, #7]
    for(i = 0; i < _LV_MASK_MAX_NUM; i++) {
 801610e:	79bb      	ldrb	r3, [r7, #6]
 8016110:	3301      	adds	r3, #1
 8016112:	71bb      	strb	r3, [r7, #6]
 8016114:	79bb      	ldrb	r3, [r7, #6]
 8016116:	2b0f      	cmp	r3, #15
 8016118:	d9f0      	bls.n	80160fc <lv_draw_mask_get_cnt+0x10>
    }
    return cnt;
 801611a:	79fb      	ldrb	r3, [r7, #7]
}
 801611c:	4618      	mov	r0, r3
 801611e:	370c      	adds	r7, #12
 8016120:	46bd      	mov	sp, r7
 8016122:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016126:	4770      	bx	lr
 8016128:	2000a25c 	.word	0x2000a25c

0801612c <lv_draw_mask_line_points_init>:
 * With `LV_DRAW_MASK_LINE_SIDE_LEFT/RIGHT` and horizontal line all pixels are kept
 * With `LV_DRAW_MASK_LINE_SIDE_TOP/BOTTOM` and vertical line all pixels are kept
 */
void lv_draw_mask_line_points_init(lv_draw_mask_line_param_t * param, lv_coord_t p1x, lv_coord_t p1y, lv_coord_t p2x,
                                   lv_coord_t p2y, lv_draw_mask_line_side_t side)
{
 801612c:	b580      	push	{r7, lr}
 801612e:	b08a      	sub	sp, #40	; 0x28
 8016130:	af00      	add	r7, sp, #0
 8016132:	60f8      	str	r0, [r7, #12]
 8016134:	4608      	mov	r0, r1
 8016136:	4611      	mov	r1, r2
 8016138:	461a      	mov	r2, r3
 801613a:	4603      	mov	r3, r0
 801613c:	817b      	strh	r3, [r7, #10]
 801613e:	460b      	mov	r3, r1
 8016140:	813b      	strh	r3, [r7, #8]
 8016142:	4613      	mov	r3, r2
 8016144:	80fb      	strh	r3, [r7, #6]
    _lv_memset_00(param, sizeof(lv_draw_mask_line_param_t));
 8016146:	212c      	movs	r1, #44	; 0x2c
 8016148:	68f8      	ldr	r0, [r7, #12]
 801614a:	f00b faad 	bl	80216a8 <_lv_memset_00>

    if(p1y > p2y) {
 801614e:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8016152:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8016156:	429a      	cmp	r2, r3
 8016158:	dd0b      	ble.n	8016172 <lv_draw_mask_line_points_init+0x46>
        lv_coord_t t;
        t = p2x;
 801615a:	88fb      	ldrh	r3, [r7, #6]
 801615c:	84fb      	strh	r3, [r7, #38]	; 0x26
        p2x = p1x;
 801615e:	897b      	ldrh	r3, [r7, #10]
 8016160:	80fb      	strh	r3, [r7, #6]
        p1x = t;
 8016162:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8016164:	817b      	strh	r3, [r7, #10]

        t = p2y;
 8016166:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8016168:	84fb      	strh	r3, [r7, #38]	; 0x26
        p2y = p1y;
 801616a:	893b      	ldrh	r3, [r7, #8]
 801616c:	863b      	strh	r3, [r7, #48]	; 0x30
        p1y = t;
 801616e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8016170:	813b      	strh	r3, [r7, #8]
    }

    param->cfg.p1.x = p1x;
 8016172:	68fb      	ldr	r3, [r7, #12]
 8016174:	897a      	ldrh	r2, [r7, #10]
 8016176:	811a      	strh	r2, [r3, #8]
    param->cfg.p1.y = p1y;
 8016178:	68fb      	ldr	r3, [r7, #12]
 801617a:	893a      	ldrh	r2, [r7, #8]
 801617c:	815a      	strh	r2, [r3, #10]
    param->cfg.p2.x = p2x;
 801617e:	68fb      	ldr	r3, [r7, #12]
 8016180:	88fa      	ldrh	r2, [r7, #6]
 8016182:	819a      	strh	r2, [r3, #12]
    param->cfg.p2.y = p2y;
 8016184:	68fb      	ldr	r3, [r7, #12]
 8016186:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 8016188:	81da      	strh	r2, [r3, #14]
    param->cfg.side = side;
 801618a:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 801618e:	f003 0303 	and.w	r3, r3, #3
 8016192:	b2d9      	uxtb	r1, r3
 8016194:	68fa      	ldr	r2, [r7, #12]
 8016196:	7c13      	ldrb	r3, [r2, #16]
 8016198:	f361 0301 	bfi	r3, r1, #0, #2
 801619c:	7413      	strb	r3, [r2, #16]

    param->origo.x = p1x;
 801619e:	68fb      	ldr	r3, [r7, #12]
 80161a0:	897a      	ldrh	r2, [r7, #10]
 80161a2:	825a      	strh	r2, [r3, #18]
    param->origo.y = p1y;
 80161a4:	68fb      	ldr	r3, [r7, #12]
 80161a6:	893a      	ldrh	r2, [r7, #8]
 80161a8:	829a      	strh	r2, [r3, #20]
    param->flat = (LV_MATH_ABS(p2x - p1x) > LV_MATH_ABS(p2y - p1y)) ? 1 : 0;
 80161aa:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 80161ae:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 80161b2:	1ad3      	subs	r3, r2, r3
 80161b4:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80161b8:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 80161bc:	f9b7 1030 	ldrsh.w	r1, [r7, #48]	; 0x30
 80161c0:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80161c4:	1acb      	subs	r3, r1, r3
 80161c6:	2b00      	cmp	r3, #0
 80161c8:	bfb8      	it	lt
 80161ca:	425b      	neglt	r3, r3
 80161cc:	429a      	cmp	r2, r3
 80161ce:	bfcc      	ite	gt
 80161d0:	2301      	movgt	r3, #1
 80161d2:	2300      	movle	r3, #0
 80161d4:	b2d9      	uxtb	r1, r3
 80161d6:	68fa      	ldr	r2, [r7, #12]
 80161d8:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 80161dc:	f361 0300 	bfi	r3, r1, #0, #1
 80161e0:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    param->yx_steep = 0;
 80161e4:	68fb      	ldr	r3, [r7, #12]
 80161e6:	2200      	movs	r2, #0
 80161e8:	61da      	str	r2, [r3, #28]
    param->xy_steep = 0;
 80161ea:	68fb      	ldr	r3, [r7, #12]
 80161ec:	2200      	movs	r2, #0
 80161ee:	619a      	str	r2, [r3, #24]
    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_line;
 80161f0:	68fb      	ldr	r3, [r7, #12]
 80161f2:	4a63      	ldr	r2, [pc, #396]	; (8016380 <lv_draw_mask_line_points_init+0x254>)
 80161f4:	601a      	str	r2, [r3, #0]
    param->dsc.type = LV_DRAW_MASK_TYPE_LINE;
 80161f6:	68fb      	ldr	r3, [r7, #12]
 80161f8:	2200      	movs	r2, #0
 80161fa:	711a      	strb	r2, [r3, #4]

    int32_t dx = p2x - p1x;
 80161fc:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8016200:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016204:	1ad3      	subs	r3, r2, r3
 8016206:	623b      	str	r3, [r7, #32]
    int32_t dy = p2y - p1y;
 8016208:	f9b7 2030 	ldrsh.w	r2, [r7, #48]	; 0x30
 801620c:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8016210:	1ad3      	subs	r3, r2, r3
 8016212:	61fb      	str	r3, [r7, #28]

    if(param->flat) {
 8016214:	68fb      	ldr	r3, [r7, #12]
 8016216:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 801621a:	f003 0301 	and.w	r3, r3, #1
 801621e:	b2db      	uxtb	r3, r3
 8016220:	2b00      	cmp	r3, #0
 8016222:	d024      	beq.n	801626e <lv_draw_mask_line_points_init+0x142>
        /*Normalize the steep. Delta x should be relative to delta x = 1024*/
        int32_t m;

        if(dx) {
 8016224:	6a3b      	ldr	r3, [r7, #32]
 8016226:	2b00      	cmp	r3, #0
 8016228:	d00c      	beq.n	8016244 <lv_draw_mask_line_points_init+0x118>
            m = (1 << 20) / dx;  /*m is multiplier to normalize y (upscaled by 1024)*/
 801622a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 801622e:	6a3b      	ldr	r3, [r7, #32]
 8016230:	fb92 f3f3 	sdiv	r3, r2, r3
 8016234:	617b      	str	r3, [r7, #20]
            param->yx_steep = (m * dy) >> 10;
 8016236:	697b      	ldr	r3, [r7, #20]
 8016238:	69fa      	ldr	r2, [r7, #28]
 801623a:	fb02 f303 	mul.w	r3, r2, r3
 801623e:	129a      	asrs	r2, r3, #10
 8016240:	68fb      	ldr	r3, [r7, #12]
 8016242:	61da      	str	r2, [r3, #28]
        }

        if(dy) {
 8016244:	69fb      	ldr	r3, [r7, #28]
 8016246:	2b00      	cmp	r3, #0
 8016248:	d00c      	beq.n	8016264 <lv_draw_mask_line_points_init+0x138>
            m = (1 << 20) / dy;  /*m is multiplier to normalize x (upscaled by 1024)*/
 801624a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 801624e:	69fb      	ldr	r3, [r7, #28]
 8016250:	fb92 f3f3 	sdiv	r3, r2, r3
 8016254:	617b      	str	r3, [r7, #20]
            param->xy_steep = (m * dx) >> 10;
 8016256:	697b      	ldr	r3, [r7, #20]
 8016258:	6a3a      	ldr	r2, [r7, #32]
 801625a:	fb02 f303 	mul.w	r3, r2, r3
 801625e:	129a      	asrs	r2, r3, #10
 8016260:	68fb      	ldr	r3, [r7, #12]
 8016262:	619a      	str	r2, [r3, #24]
        }
        param->steep = param->yx_steep;
 8016264:	68fb      	ldr	r3, [r7, #12]
 8016266:	69da      	ldr	r2, [r3, #28]
 8016268:	68fb      	ldr	r3, [r7, #12]
 801626a:	621a      	str	r2, [r3, #32]
 801626c:	e023      	b.n	80162b6 <lv_draw_mask_line_points_init+0x18a>
    }
    else {
        /*Normalize the steep. Delta y should be relative to delta x = 1024*/
        int32_t m;

        if(dy) {
 801626e:	69fb      	ldr	r3, [r7, #28]
 8016270:	2b00      	cmp	r3, #0
 8016272:	d00c      	beq.n	801628e <lv_draw_mask_line_points_init+0x162>
            m = (1 << 20) / dy;  /*m is multiplier to normalize x (upscaled by 1024)*/
 8016274:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8016278:	69fb      	ldr	r3, [r7, #28]
 801627a:	fb92 f3f3 	sdiv	r3, r2, r3
 801627e:	61bb      	str	r3, [r7, #24]
            param->xy_steep = (m * dx) >> 10;
 8016280:	69bb      	ldr	r3, [r7, #24]
 8016282:	6a3a      	ldr	r2, [r7, #32]
 8016284:	fb02 f303 	mul.w	r3, r2, r3
 8016288:	129a      	asrs	r2, r3, #10
 801628a:	68fb      	ldr	r3, [r7, #12]
 801628c:	619a      	str	r2, [r3, #24]
        }

        if(dx) {
 801628e:	6a3b      	ldr	r3, [r7, #32]
 8016290:	2b00      	cmp	r3, #0
 8016292:	d00c      	beq.n	80162ae <lv_draw_mask_line_points_init+0x182>
            m = (1 << 20) / dx;  /*m is multiplier to normalize x (upscaled by 1024)*/
 8016294:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8016298:	6a3b      	ldr	r3, [r7, #32]
 801629a:	fb92 f3f3 	sdiv	r3, r2, r3
 801629e:	61bb      	str	r3, [r7, #24]
            param->yx_steep = (m * dy) >> 10;
 80162a0:	69bb      	ldr	r3, [r7, #24]
 80162a2:	69fa      	ldr	r2, [r7, #28]
 80162a4:	fb02 f303 	mul.w	r3, r2, r3
 80162a8:	129a      	asrs	r2, r3, #10
 80162aa:	68fb      	ldr	r3, [r7, #12]
 80162ac:	61da      	str	r2, [r3, #28]
        }
        param->steep = param->xy_steep;
 80162ae:	68fb      	ldr	r3, [r7, #12]
 80162b0:	699a      	ldr	r2, [r3, #24]
 80162b2:	68fb      	ldr	r3, [r7, #12]
 80162b4:	621a      	str	r2, [r3, #32]
    }

    if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT) param->inv = 0;
 80162b6:	68fb      	ldr	r3, [r7, #12]
 80162b8:	7c1b      	ldrb	r3, [r3, #16]
 80162ba:	f003 0303 	and.w	r3, r3, #3
 80162be:	b2db      	uxtb	r3, r3
 80162c0:	2b00      	cmp	r3, #0
 80162c2:	d107      	bne.n	80162d4 <lv_draw_mask_line_points_init+0x1a8>
 80162c4:	68fa      	ldr	r2, [r7, #12]
 80162c6:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 80162ca:	f36f 0341 	bfc	r3, #1, #1
 80162ce:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 80162d2:	e043      	b.n	801635c <lv_draw_mask_line_points_init+0x230>
    else if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) param->inv = 1;
 80162d4:	68fb      	ldr	r3, [r7, #12]
 80162d6:	7c1b      	ldrb	r3, [r3, #16]
 80162d8:	f003 0303 	and.w	r3, r3, #3
 80162dc:	b2db      	uxtb	r3, r3
 80162de:	2b01      	cmp	r3, #1
 80162e0:	d107      	bne.n	80162f2 <lv_draw_mask_line_points_init+0x1c6>
 80162e2:	68fa      	ldr	r2, [r7, #12]
 80162e4:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 80162e8:	f043 0302 	orr.w	r3, r3, #2
 80162ec:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 80162f0:	e034      	b.n	801635c <lv_draw_mask_line_points_init+0x230>
    else if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP) {
 80162f2:	68fb      	ldr	r3, [r7, #12]
 80162f4:	7c1b      	ldrb	r3, [r3, #16]
 80162f6:	f003 0303 	and.w	r3, r3, #3
 80162fa:	b2db      	uxtb	r3, r3
 80162fc:	2b02      	cmp	r3, #2
 80162fe:	d113      	bne.n	8016328 <lv_draw_mask_line_points_init+0x1fc>
        if(param->steep > 0) param->inv = 1;
 8016300:	68fb      	ldr	r3, [r7, #12]
 8016302:	6a1b      	ldr	r3, [r3, #32]
 8016304:	2b00      	cmp	r3, #0
 8016306:	dd07      	ble.n	8016318 <lv_draw_mask_line_points_init+0x1ec>
 8016308:	68fa      	ldr	r2, [r7, #12]
 801630a:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 801630e:	f043 0302 	orr.w	r3, r3, #2
 8016312:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 8016316:	e021      	b.n	801635c <lv_draw_mask_line_points_init+0x230>
        else param->inv = 0;
 8016318:	68fa      	ldr	r2, [r7, #12]
 801631a:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 801631e:	f36f 0341 	bfc	r3, #1, #1
 8016322:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 8016326:	e019      	b.n	801635c <lv_draw_mask_line_points_init+0x230>
    }
    else if(param->cfg.side == LV_DRAW_MASK_LINE_SIDE_BOTTOM) {
 8016328:	68fb      	ldr	r3, [r7, #12]
 801632a:	7c1b      	ldrb	r3, [r3, #16]
 801632c:	f003 0303 	and.w	r3, r3, #3
 8016330:	b2db      	uxtb	r3, r3
 8016332:	2b03      	cmp	r3, #3
 8016334:	d112      	bne.n	801635c <lv_draw_mask_line_points_init+0x230>
        if(param->steep > 0) param->inv = 0;
 8016336:	68fb      	ldr	r3, [r7, #12]
 8016338:	6a1b      	ldr	r3, [r3, #32]
 801633a:	2b00      	cmp	r3, #0
 801633c:	dd07      	ble.n	801634e <lv_draw_mask_line_points_init+0x222>
 801633e:	68fa      	ldr	r2, [r7, #12]
 8016340:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8016344:	f36f 0341 	bfc	r3, #1, #1
 8016348:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 801634c:	e006      	b.n	801635c <lv_draw_mask_line_points_init+0x230>
        else param->inv = 1;
 801634e:	68fa      	ldr	r2, [r7, #12]
 8016350:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8016354:	f043 0302 	orr.w	r3, r3, #2
 8016358:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    }

    param->spx = param->steep >> 2;
 801635c:	68fb      	ldr	r3, [r7, #12]
 801635e:	6a1b      	ldr	r3, [r3, #32]
 8016360:	109a      	asrs	r2, r3, #2
 8016362:	68fb      	ldr	r3, [r7, #12]
 8016364:	625a      	str	r2, [r3, #36]	; 0x24
    if(param->steep < 0) param->spx = -param->spx;
 8016366:	68fb      	ldr	r3, [r7, #12]
 8016368:	6a1b      	ldr	r3, [r3, #32]
 801636a:	2b00      	cmp	r3, #0
 801636c:	da04      	bge.n	8016378 <lv_draw_mask_line_points_init+0x24c>
 801636e:	68fb      	ldr	r3, [r7, #12]
 8016370:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016372:	425a      	negs	r2, r3
 8016374:	68fb      	ldr	r3, [r7, #12]
 8016376:	625a      	str	r2, [r3, #36]	; 0x24
}
 8016378:	bf00      	nop
 801637a:	3728      	adds	r7, #40	; 0x28
 801637c:	46bd      	mov	sp, r7
 801637e:	bd80      	pop	{r7, pc}
 8016380:	0801641d 	.word	0x0801641d

08016384 <lv_draw_mask_radius_init>:
 * @param rect coordinates of the rectangle to affect (absolute coordinates)
 * @param radius radius of the rectangle
 * @param inv: true: keep the pixels inside the rectangle; keep the pixels outside of the rectangle
 */
void lv_draw_mask_radius_init(lv_draw_mask_radius_param_t * param, const lv_area_t * rect, lv_coord_t radius, bool inv)
{
 8016384:	b580      	push	{r7, lr}
 8016386:	b086      	sub	sp, #24
 8016388:	af00      	add	r7, sp, #0
 801638a:	60f8      	str	r0, [r7, #12]
 801638c:	60b9      	str	r1, [r7, #8]
 801638e:	4611      	mov	r1, r2
 8016390:	461a      	mov	r2, r3
 8016392:	460b      	mov	r3, r1
 8016394:	80fb      	strh	r3, [r7, #6]
 8016396:	4613      	mov	r3, r2
 8016398:	717b      	strb	r3, [r7, #5]
    lv_coord_t w = lv_area_get_width(rect);
 801639a:	68b8      	ldr	r0, [r7, #8]
 801639c:	f7ff fdaa 	bl	8015ef4 <lv_area_get_width>
 80163a0:	4603      	mov	r3, r0
 80163a2:	82fb      	strh	r3, [r7, #22]
    lv_coord_t h = lv_area_get_height(rect);
 80163a4:	68b8      	ldr	r0, [r7, #8]
 80163a6:	f7ff fdbc 	bl	8015f22 <lv_area_get_height>
 80163aa:	4603      	mov	r3, r0
 80163ac:	82bb      	strh	r3, [r7, #20]
    int32_t short_side = LV_MATH_MIN(w, h);
 80163ae:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 80163b2:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80163b6:	4293      	cmp	r3, r2
 80163b8:	bfa8      	it	ge
 80163ba:	4613      	movge	r3, r2
 80163bc:	b21b      	sxth	r3, r3
 80163be:	613b      	str	r3, [r7, #16]
    if(radius > short_side >> 1) radius = short_side >> 1;
 80163c0:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 80163c4:	693b      	ldr	r3, [r7, #16]
 80163c6:	105b      	asrs	r3, r3, #1
 80163c8:	429a      	cmp	r2, r3
 80163ca:	dd02      	ble.n	80163d2 <lv_draw_mask_radius_init+0x4e>
 80163cc:	693b      	ldr	r3, [r7, #16]
 80163ce:	105b      	asrs	r3, r3, #1
 80163d0:	80fb      	strh	r3, [r7, #6]

    lv_area_copy(&param->cfg.rect, rect);
 80163d2:	68fb      	ldr	r3, [r7, #12]
 80163d4:	3308      	adds	r3, #8
 80163d6:	68b9      	ldr	r1, [r7, #8]
 80163d8:	4618      	mov	r0, r3
 80163da:	f7ff fd7d 	bl	8015ed8 <lv_area_copy>
    param->cfg.radius = radius;
 80163de:	68fb      	ldr	r3, [r7, #12]
 80163e0:	88fa      	ldrh	r2, [r7, #6]
 80163e2:	821a      	strh	r2, [r3, #16]
    param->cfg.outer = inv ? 1 : 0;
 80163e4:	7979      	ldrb	r1, [r7, #5]
 80163e6:	68fa      	ldr	r2, [r7, #12]
 80163e8:	7c93      	ldrb	r3, [r2, #18]
 80163ea:	f361 0300 	bfi	r3, r1, #0, #1
 80163ee:	7493      	strb	r3, [r2, #18]
    param->dsc.cb = (lv_draw_mask_xcb_t)lv_draw_mask_radius;
 80163f0:	68fb      	ldr	r3, [r7, #12]
 80163f2:	4a09      	ldr	r2, [pc, #36]	; (8016418 <lv_draw_mask_radius_init+0x94>)
 80163f4:	601a      	str	r2, [r3, #0]
    param->dsc.type = LV_DRAW_MASK_TYPE_RADIUS;
 80163f6:	68fb      	ldr	r3, [r7, #12]
 80163f8:	2202      	movs	r2, #2
 80163fa:	711a      	strb	r2, [r3, #4]
    param->y_prev = INT32_MIN;
 80163fc:	68fb      	ldr	r3, [r7, #12]
 80163fe:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8016402:	615a      	str	r2, [r3, #20]
    param->y_prev_x.f = 0;
 8016404:	68fb      	ldr	r3, [r7, #12]
 8016406:	2200      	movs	r2, #0
 8016408:	835a      	strh	r2, [r3, #26]
    param->y_prev_x.i = 0;
 801640a:	68fb      	ldr	r3, [r7, #12]
 801640c:	2200      	movs	r2, #0
 801640e:	831a      	strh	r2, [r3, #24]
}
 8016410:	bf00      	nop
 8016412:	3718      	adds	r7, #24
 8016414:	46bd      	mov	sp, r7
 8016416:	bd80      	pop	{r7, pc}
 8016418:	08016d9d 	.word	0x08016d9d

0801641c <lv_draw_mask_line>:
 **********************/

LV_ATTRIBUTE_FAST_MEM static lv_draw_mask_res_t lv_draw_mask_line(lv_opa_t * mask_buf, lv_coord_t abs_x,
                                                                  lv_coord_t abs_y, lv_coord_t len,
                                                                  lv_draw_mask_line_param_t * p)
{
 801641c:	b580      	push	{r7, lr}
 801641e:	b08a      	sub	sp, #40	; 0x28
 8016420:	af02      	add	r7, sp, #8
 8016422:	60f8      	str	r0, [r7, #12]
 8016424:	4608      	mov	r0, r1
 8016426:	4611      	mov	r1, r2
 8016428:	461a      	mov	r2, r3
 801642a:	4603      	mov	r3, r0
 801642c:	817b      	strh	r3, [r7, #10]
 801642e:	460b      	mov	r3, r1
 8016430:	813b      	strh	r3, [r7, #8]
 8016432:	4613      	mov	r3, r2
 8016434:	80fb      	strh	r3, [r7, #6]
    /*Make to points relative to the vertex*/
    abs_y -= p->origo.y;
 8016436:	893a      	ldrh	r2, [r7, #8]
 8016438:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801643a:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 801643e:	b29b      	uxth	r3, r3
 8016440:	1ad3      	subs	r3, r2, r3
 8016442:	b29b      	uxth	r3, r3
 8016444:	813b      	strh	r3, [r7, #8]
    abs_x -= p->origo.x;
 8016446:	897a      	ldrh	r2, [r7, #10]
 8016448:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801644a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801644e:	b29b      	uxth	r3, r3
 8016450:	1ad3      	subs	r3, r2, r3
 8016452:	b29b      	uxth	r3, r3
 8016454:	817b      	strh	r3, [r7, #10]

    /*Handle special cases*/
    if(p->steep == 0) {
 8016456:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016458:	6a1b      	ldr	r3, [r3, #32]
 801645a:	2b00      	cmp	r3, #0
 801645c:	f040 80a7 	bne.w	80165ae <lv_draw_mask_line+0x192>
        /*Horizontal*/
        if(p->flat) {
 8016460:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016462:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016466:	f003 0301 	and.w	r3, r3, #1
 801646a:	b2db      	uxtb	r3, r3
 801646c:	2b00      	cmp	r3, #0
 801646e:	d02c      	beq.n	80164ca <lv_draw_mask_line+0xae>
            /*Non sense: Can't be on the right/left of a horizontal line*/
            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT ||
 8016470:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016472:	7c1b      	ldrb	r3, [r3, #16]
 8016474:	f003 0303 	and.w	r3, r3, #3
 8016478:	b2db      	uxtb	r3, r3
 801647a:	2b00      	cmp	r3, #0
 801647c:	d006      	beq.n	801648c <lv_draw_mask_line+0x70>
               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_MASK_RES_FULL_COVER;
 801647e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016480:	7c1b      	ldrb	r3, [r3, #16]
 8016482:	f003 0303 	and.w	r3, r3, #3
 8016486:	b2db      	uxtb	r3, r3
            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT ||
 8016488:	2b01      	cmp	r3, #1
 801648a:	d101      	bne.n	8016490 <lv_draw_mask_line+0x74>
               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT) return LV_DRAW_MASK_RES_FULL_COVER;
 801648c:	2301      	movs	r3, #1
 801648e:	e0b4      	b.n	80165fa <lv_draw_mask_line+0x1de>
            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP && abs_y + 1 < 0) return LV_DRAW_MASK_RES_FULL_COVER;
 8016490:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016492:	7c1b      	ldrb	r3, [r3, #16]
 8016494:	f003 0303 	and.w	r3, r3, #3
 8016498:	b2db      	uxtb	r3, r3
 801649a:	2b02      	cmp	r3, #2
 801649c:	d106      	bne.n	80164ac <lv_draw_mask_line+0x90>
 801649e:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80164a2:	f1b3 3fff 	cmp.w	r3, #4294967295
 80164a6:	da01      	bge.n	80164ac <lv_draw_mask_line+0x90>
 80164a8:	2301      	movs	r3, #1
 80164aa:	e0a6      	b.n	80165fa <lv_draw_mask_line+0x1de>
            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_BOTTOM && abs_y > 0) return LV_DRAW_MASK_RES_FULL_COVER;
 80164ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80164ae:	7c1b      	ldrb	r3, [r3, #16]
 80164b0:	f003 0303 	and.w	r3, r3, #3
 80164b4:	b2db      	uxtb	r3, r3
 80164b6:	2b03      	cmp	r3, #3
 80164b8:	d105      	bne.n	80164c6 <lv_draw_mask_line+0xaa>
 80164ba:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80164be:	2b00      	cmp	r3, #0
 80164c0:	dd01      	ble.n	80164c6 <lv_draw_mask_line+0xaa>
 80164c2:	2301      	movs	r3, #1
 80164c4:	e099      	b.n	80165fa <lv_draw_mask_line+0x1de>
            else {
                return LV_DRAW_MASK_RES_TRANSP;
 80164c6:	2300      	movs	r3, #0
 80164c8:	e097      	b.n	80165fa <lv_draw_mask_line+0x1de>
            }
        }
        /*Vertical*/
        else {
            /*Non sense: Can't be on the top/bottom of a vertical line*/
            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP ||
 80164ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80164cc:	7c1b      	ldrb	r3, [r3, #16]
 80164ce:	f003 0303 	and.w	r3, r3, #3
 80164d2:	b2db      	uxtb	r3, r3
 80164d4:	2b02      	cmp	r3, #2
 80164d6:	d006      	beq.n	80164e6 <lv_draw_mask_line+0xca>
               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_BOTTOM) return LV_DRAW_MASK_RES_FULL_COVER;
 80164d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80164da:	7c1b      	ldrb	r3, [r3, #16]
 80164dc:	f003 0303 	and.w	r3, r3, #3
 80164e0:	b2db      	uxtb	r3, r3
            if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_TOP ||
 80164e2:	2b03      	cmp	r3, #3
 80164e4:	d101      	bne.n	80164ea <lv_draw_mask_line+0xce>
               p->cfg.side == LV_DRAW_MASK_LINE_SIDE_BOTTOM) return LV_DRAW_MASK_RES_FULL_COVER;
 80164e6:	2301      	movs	r3, #1
 80164e8:	e087      	b.n	80165fa <lv_draw_mask_line+0x1de>
            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_RIGHT && abs_x > 0) return LV_DRAW_MASK_RES_FULL_COVER;
 80164ea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80164ec:	7c1b      	ldrb	r3, [r3, #16]
 80164ee:	f003 0303 	and.w	r3, r3, #3
 80164f2:	b2db      	uxtb	r3, r3
 80164f4:	2b01      	cmp	r3, #1
 80164f6:	d105      	bne.n	8016504 <lv_draw_mask_line+0xe8>
 80164f8:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 80164fc:	2b00      	cmp	r3, #0
 80164fe:	dd01      	ble.n	8016504 <lv_draw_mask_line+0xe8>
 8016500:	2301      	movs	r3, #1
 8016502:	e07a      	b.n	80165fa <lv_draw_mask_line+0x1de>
            else if(p->cfg.side == LV_DRAW_MASK_LINE_SIDE_LEFT) {
 8016504:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016506:	7c1b      	ldrb	r3, [r3, #16]
 8016508:	f003 0303 	and.w	r3, r3, #3
 801650c:	b2db      	uxtb	r3, r3
 801650e:	2b00      	cmp	r3, #0
 8016510:	d125      	bne.n	801655e <lv_draw_mask_line+0x142>
                if(abs_x + len < 0) return LV_DRAW_MASK_RES_FULL_COVER;
 8016512:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8016516:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801651a:	4413      	add	r3, r2
 801651c:	2b00      	cmp	r3, #0
 801651e:	da01      	bge.n	8016524 <lv_draw_mask_line+0x108>
 8016520:	2301      	movs	r3, #1
 8016522:	e06a      	b.n	80165fa <lv_draw_mask_line+0x1de>
                else {
                    int32_t k = - abs_x;
 8016524:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016528:	425b      	negs	r3, r3
 801652a:	617b      	str	r3, [r7, #20]
                    if(k < 0) return LV_DRAW_MASK_RES_TRANSP;
 801652c:	697b      	ldr	r3, [r7, #20]
 801652e:	2b00      	cmp	r3, #0
 8016530:	da01      	bge.n	8016536 <lv_draw_mask_line+0x11a>
 8016532:	2300      	movs	r3, #0
 8016534:	e061      	b.n	80165fa <lv_draw_mask_line+0x1de>
                    if(k >= 0 && k < len) _lv_memset_00(&mask_buf[k], len - k);
 8016536:	697b      	ldr	r3, [r7, #20]
 8016538:	2b00      	cmp	r3, #0
 801653a:	db0e      	blt.n	801655a <lv_draw_mask_line+0x13e>
 801653c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016540:	697a      	ldr	r2, [r7, #20]
 8016542:	429a      	cmp	r2, r3
 8016544:	da09      	bge.n	801655a <lv_draw_mask_line+0x13e>
 8016546:	697b      	ldr	r3, [r7, #20]
 8016548:	68fa      	ldr	r2, [r7, #12]
 801654a:	18d0      	adds	r0, r2, r3
 801654c:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8016550:	697b      	ldr	r3, [r7, #20]
 8016552:	1ad3      	subs	r3, r2, r3
 8016554:	4619      	mov	r1, r3
 8016556:	f00b f8a7 	bl	80216a8 <_lv_memset_00>
                    return  LV_DRAW_MASK_RES_CHANGED;
 801655a:	2302      	movs	r3, #2
 801655c:	e04d      	b.n	80165fa <lv_draw_mask_line+0x1de>
                }
            }
            else {
                if(abs_x + len < 0) return LV_DRAW_MASK_RES_TRANSP;
 801655e:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8016562:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016566:	4413      	add	r3, r2
 8016568:	2b00      	cmp	r3, #0
 801656a:	da01      	bge.n	8016570 <lv_draw_mask_line+0x154>
 801656c:	2300      	movs	r3, #0
 801656e:	e044      	b.n	80165fa <lv_draw_mask_line+0x1de>
                else {
                    int32_t k = - abs_x;
 8016570:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016574:	425b      	negs	r3, r3
 8016576:	61fb      	str	r3, [r7, #28]
                    if(k < 0) k = 0;
 8016578:	69fb      	ldr	r3, [r7, #28]
 801657a:	2b00      	cmp	r3, #0
 801657c:	da01      	bge.n	8016582 <lv_draw_mask_line+0x166>
 801657e:	2300      	movs	r3, #0
 8016580:	61fb      	str	r3, [r7, #28]
                    if(k >= len) return LV_DRAW_MASK_RES_TRANSP;
 8016582:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016586:	69fa      	ldr	r2, [r7, #28]
 8016588:	429a      	cmp	r2, r3
 801658a:	db01      	blt.n	8016590 <lv_draw_mask_line+0x174>
 801658c:	2300      	movs	r3, #0
 801658e:	e034      	b.n	80165fa <lv_draw_mask_line+0x1de>
                    else if(k >= 0 && k < len) _lv_memset_00(&mask_buf[0], k);
 8016590:	69fb      	ldr	r3, [r7, #28]
 8016592:	2b00      	cmp	r3, #0
 8016594:	db09      	blt.n	80165aa <lv_draw_mask_line+0x18e>
 8016596:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801659a:	69fa      	ldr	r2, [r7, #28]
 801659c:	429a      	cmp	r2, r3
 801659e:	da04      	bge.n	80165aa <lv_draw_mask_line+0x18e>
 80165a0:	69fb      	ldr	r3, [r7, #28]
 80165a2:	4619      	mov	r1, r3
 80165a4:	68f8      	ldr	r0, [r7, #12]
 80165a6:	f00b f87f 	bl	80216a8 <_lv_memset_00>
                    return  LV_DRAW_MASK_RES_CHANGED;
 80165aa:	2302      	movs	r3, #2
 80165ac:	e025      	b.n	80165fa <lv_draw_mask_line+0x1de>
            }
        }
    }

    lv_draw_mask_res_t res;
    if(p->flat) {
 80165ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80165b0:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80165b4:	f003 0301 	and.w	r3, r3, #1
 80165b8:	b2db      	uxtb	r3, r3
 80165ba:	2b00      	cmp	r3, #0
 80165bc:	d00e      	beq.n	80165dc <lv_draw_mask_line+0x1c0>
        res = line_mask_flat(mask_buf, abs_x, abs_y, len, p);
 80165be:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
 80165c2:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 80165c6:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 80165ca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80165cc:	9300      	str	r3, [sp, #0]
 80165ce:	4603      	mov	r3, r0
 80165d0:	68f8      	ldr	r0, [r7, #12]
 80165d2:	f000 f816 	bl	8016602 <line_mask_flat>
 80165d6:	4603      	mov	r3, r0
 80165d8:	76fb      	strb	r3, [r7, #27]
 80165da:	e00d      	b.n	80165f8 <lv_draw_mask_line+0x1dc>
    }
    else {
        res = line_mask_steep(mask_buf, abs_x, abs_y, len, p);
 80165dc:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
 80165e0:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 80165e4:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 80165e8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80165ea:	9300      	str	r3, [sp, #0]
 80165ec:	4603      	mov	r3, r0
 80165ee:	68f8      	ldr	r0, [r7, #12]
 80165f0:	f000 f991 	bl	8016916 <line_mask_steep>
 80165f4:	4603      	mov	r3, r0
 80165f6:	76fb      	strb	r3, [r7, #27]
    }

    return res;
 80165f8:	7efb      	ldrb	r3, [r7, #27]
}
 80165fa:	4618      	mov	r0, r3
 80165fc:	3720      	adds	r7, #32
 80165fe:	46bd      	mov	sp, r7
 8016600:	bd80      	pop	{r7, pc}

08016602 <line_mask_flat>:

LV_ATTRIBUTE_FAST_MEM static lv_draw_mask_res_t line_mask_flat(lv_opa_t * mask_buf, lv_coord_t abs_x, lv_coord_t abs_y,
                                                               lv_coord_t len,
                                                               lv_draw_mask_line_param_t * p)
{
 8016602:	b590      	push	{r4, r7, lr}
 8016604:	b08d      	sub	sp, #52	; 0x34
 8016606:	af00      	add	r7, sp, #0
 8016608:	60f8      	str	r0, [r7, #12]
 801660a:	4608      	mov	r0, r1
 801660c:	4611      	mov	r1, r2
 801660e:	461a      	mov	r2, r3
 8016610:	4603      	mov	r3, r0
 8016612:	817b      	strh	r3, [r7, #10]
 8016614:	460b      	mov	r3, r1
 8016616:	813b      	strh	r3, [r7, #8]
 8016618:	4613      	mov	r3, r2
 801661a:	80fb      	strh	r3, [r7, #6]
    int32_t y_at_x;
    y_at_x = (int32_t)((int32_t)p->yx_steep * abs_x) >> 10;
 801661c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801661e:	69db      	ldr	r3, [r3, #28]
 8016620:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8016624:	fb02 f303 	mul.w	r3, r2, r3
 8016628:	129b      	asrs	r3, r3, #10
 801662a:	61fb      	str	r3, [r7, #28]

    if(p->yx_steep > 0) {
 801662c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801662e:	69db      	ldr	r3, [r3, #28]
 8016630:	2b00      	cmp	r3, #0
 8016632:	dd10      	ble.n	8016656 <line_mask_flat+0x54>
        if(y_at_x > abs_y) {
 8016634:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8016638:	69fa      	ldr	r2, [r7, #28]
 801663a:	429a      	cmp	r2, r3
 801663c:	dd1c      	ble.n	8016678 <line_mask_flat+0x76>
            if(p->inv) {
 801663e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016640:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016644:	f003 0302 	and.w	r3, r3, #2
 8016648:	b2db      	uxtb	r3, r3
 801664a:	2b00      	cmp	r3, #0
 801664c:	d001      	beq.n	8016652 <line_mask_flat+0x50>
                return LV_DRAW_MASK_RES_FULL_COVER;
 801664e:	2301      	movs	r3, #1
 8016650:	e15d      	b.n	801690e <line_mask_flat+0x30c>
            }
            else {
                return LV_DRAW_MASK_RES_TRANSP;
 8016652:	2300      	movs	r3, #0
 8016654:	e15b      	b.n	801690e <line_mask_flat+0x30c>
            }
        }
    }
    else {
        if(y_at_x < abs_y) {
 8016656:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 801665a:	69fa      	ldr	r2, [r7, #28]
 801665c:	429a      	cmp	r2, r3
 801665e:	da0b      	bge.n	8016678 <line_mask_flat+0x76>
            if(p->inv) {
 8016660:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016662:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016666:	f003 0302 	and.w	r3, r3, #2
 801666a:	b2db      	uxtb	r3, r3
 801666c:	2b00      	cmp	r3, #0
 801666e:	d001      	beq.n	8016674 <line_mask_flat+0x72>
                return LV_DRAW_MASK_RES_FULL_COVER;
 8016670:	2301      	movs	r3, #1
 8016672:	e14c      	b.n	801690e <line_mask_flat+0x30c>
            }
            else {
                return LV_DRAW_MASK_RES_TRANSP;
 8016674:	2300      	movs	r3, #0
 8016676:	e14a      	b.n	801690e <line_mask_flat+0x30c>
        }
    }

    /* At the end of the mask if the limit line is smaller then the mask's y.
     * Then the mask is in the "good" area*/
    y_at_x = (int32_t)((int32_t)p->yx_steep * (abs_x + len)) >> 10;
 8016678:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801667a:	69db      	ldr	r3, [r3, #28]
 801667c:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 8016680:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8016684:	440a      	add	r2, r1
 8016686:	fb02 f303 	mul.w	r3, r2, r3
 801668a:	129b      	asrs	r3, r3, #10
 801668c:	61fb      	str	r3, [r7, #28]
    if(p->yx_steep > 0) {
 801668e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016690:	69db      	ldr	r3, [r3, #28]
 8016692:	2b00      	cmp	r3, #0
 8016694:	dd10      	ble.n	80166b8 <line_mask_flat+0xb6>
        if(y_at_x < abs_y) {
 8016696:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 801669a:	69fa      	ldr	r2, [r7, #28]
 801669c:	429a      	cmp	r2, r3
 801669e:	da1c      	bge.n	80166da <line_mask_flat+0xd8>
            if(p->inv) {
 80166a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80166a2:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80166a6:	f003 0302 	and.w	r3, r3, #2
 80166aa:	b2db      	uxtb	r3, r3
 80166ac:	2b00      	cmp	r3, #0
 80166ae:	d001      	beq.n	80166b4 <line_mask_flat+0xb2>
                return LV_DRAW_MASK_RES_TRANSP;
 80166b0:	2300      	movs	r3, #0
 80166b2:	e12c      	b.n	801690e <line_mask_flat+0x30c>
            }
            else {
                return LV_DRAW_MASK_RES_FULL_COVER;
 80166b4:	2301      	movs	r3, #1
 80166b6:	e12a      	b.n	801690e <line_mask_flat+0x30c>
            }
        }
    }
    else {
        if(y_at_x > abs_y) {
 80166b8:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80166bc:	69fa      	ldr	r2, [r7, #28]
 80166be:	429a      	cmp	r2, r3
 80166c0:	dd0b      	ble.n	80166da <line_mask_flat+0xd8>
            if(p->inv) {
 80166c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80166c4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80166c8:	f003 0302 	and.w	r3, r3, #2
 80166cc:	b2db      	uxtb	r3, r3
 80166ce:	2b00      	cmp	r3, #0
 80166d0:	d001      	beq.n	80166d6 <line_mask_flat+0xd4>
                return LV_DRAW_MASK_RES_TRANSP;
 80166d2:	2300      	movs	r3, #0
 80166d4:	e11b      	b.n	801690e <line_mask_flat+0x30c>
            }
            else {
                return LV_DRAW_MASK_RES_FULL_COVER;
 80166d6:	2301      	movs	r3, #1
 80166d8:	e119      	b.n	801690e <line_mask_flat+0x30c>
            }
        }
    }

    int32_t xe;
    if(p->yx_steep > 0) xe = ((abs_y << 8) * p->xy_steep) >> 10;
 80166da:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80166dc:	69db      	ldr	r3, [r3, #28]
 80166de:	2b00      	cmp	r3, #0
 80166e0:	dd09      	ble.n	80166f6 <line_mask_flat+0xf4>
 80166e2:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80166e6:	021b      	lsls	r3, r3, #8
 80166e8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80166ea:	6992      	ldr	r2, [r2, #24]
 80166ec:	fb02 f303 	mul.w	r3, r2, r3
 80166f0:	129b      	asrs	r3, r3, #10
 80166f2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80166f4:	e009      	b.n	801670a <line_mask_flat+0x108>
    else xe = (((abs_y + 1) << 8) * p->xy_steep) >> 10;
 80166f6:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80166fa:	3301      	adds	r3, #1
 80166fc:	021b      	lsls	r3, r3, #8
 80166fe:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8016700:	6992      	ldr	r2, [r2, #24]
 8016702:	fb02 f303 	mul.w	r3, r2, r3
 8016706:	129b      	asrs	r3, r3, #10
 8016708:	62fb      	str	r3, [r7, #44]	; 0x2c

    int32_t xei = xe >> 8;
 801670a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801670c:	121b      	asrs	r3, r3, #8
 801670e:	61bb      	str	r3, [r7, #24]
    int32_t xef = xe & 0xFF;
 8016710:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016712:	b2db      	uxtb	r3, r3
 8016714:	617b      	str	r3, [r7, #20]

    int32_t px_h;
    if(xef == 0) px_h = 255;
 8016716:	697b      	ldr	r3, [r7, #20]
 8016718:	2b00      	cmp	r3, #0
 801671a:	d102      	bne.n	8016722 <line_mask_flat+0x120>
 801671c:	23ff      	movs	r3, #255	; 0xff
 801671e:	62bb      	str	r3, [r7, #40]	; 0x28
 8016720:	e00a      	b.n	8016738 <line_mask_flat+0x136>
    else px_h = 255 - (((255 - xef) * p->spx) >> 8);
 8016722:	697b      	ldr	r3, [r7, #20]
 8016724:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8016728:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801672a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 801672c:	fb02 f303 	mul.w	r3, r2, r3
 8016730:	121b      	asrs	r3, r3, #8
 8016732:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8016736:	62bb      	str	r3, [r7, #40]	; 0x28
    int32_t k = xei - abs_x;
 8016738:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801673c:	69ba      	ldr	r2, [r7, #24]
 801673e:	1ad3      	subs	r3, r2, r3
 8016740:	627b      	str	r3, [r7, #36]	; 0x24
    lv_opa_t m;

    if(xef) {
 8016742:	697b      	ldr	r3, [r7, #20]
 8016744:	2b00      	cmp	r3, #0
 8016746:	d06c      	beq.n	8016822 <line_mask_flat+0x220>
        if(k >= 0 && k < len) {
 8016748:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801674a:	2b00      	cmp	r3, #0
 801674c:	db2c      	blt.n	80167a8 <line_mask_flat+0x1a6>
 801674e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016752:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016754:	429a      	cmp	r2, r3
 8016756:	da27      	bge.n	80167a8 <line_mask_flat+0x1a6>
            m = 255 - (((255 - xef) * (255 - px_h)) >> 9);
 8016758:	697b      	ldr	r3, [r7, #20]
 801675a:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801675e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016760:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
 8016764:	fb02 f303 	mul.w	r3, r2, r3
 8016768:	125b      	asrs	r3, r3, #9
 801676a:	b2db      	uxtb	r3, r3
 801676c:	43db      	mvns	r3, r3
 801676e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            if(p->inv) m = 255 - m;
 8016772:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016774:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016778:	f003 0302 	and.w	r3, r3, #2
 801677c:	b2db      	uxtb	r3, r3
 801677e:	2b00      	cmp	r3, #0
 8016780:	d004      	beq.n	801678c <line_mask_flat+0x18a>
 8016782:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8016786:	43db      	mvns	r3, r3
 8016788:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            mask_buf[k] = mask_mix(mask_buf[k], m);
 801678c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801678e:	68fa      	ldr	r2, [r7, #12]
 8016790:	4413      	add	r3, r2
 8016792:	7818      	ldrb	r0, [r3, #0]
 8016794:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016796:	68fa      	ldr	r2, [r7, #12]
 8016798:	18d4      	adds	r4, r2, r3
 801679a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801679e:	4619      	mov	r1, r3
 80167a0:	f000 ff04 	bl	80175ac <mask_mix>
 80167a4:	4603      	mov	r3, r0
 80167a6:	7023      	strb	r3, [r4, #0]
        }
        k++;
 80167a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80167aa:	3301      	adds	r3, #1
 80167ac:	627b      	str	r3, [r7, #36]	; 0x24
    }

    while(px_h > p->spx) {
 80167ae:	e038      	b.n	8016822 <line_mask_flat+0x220>
        if(k >= 0 && k < len) {
 80167b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80167b2:	2b00      	cmp	r3, #0
 80167b4:	db28      	blt.n	8016808 <line_mask_flat+0x206>
 80167b6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80167ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80167bc:	429a      	cmp	r2, r3
 80167be:	da23      	bge.n	8016808 <line_mask_flat+0x206>
            m = px_h - (p->spx >> 1);
 80167c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80167c2:	b2da      	uxtb	r2, r3
 80167c4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80167c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80167c8:	105b      	asrs	r3, r3, #1
 80167ca:	b2db      	uxtb	r3, r3
 80167cc:	1ad3      	subs	r3, r2, r3
 80167ce:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            if(p->inv) m = 255 - m;
 80167d2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80167d4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80167d8:	f003 0302 	and.w	r3, r3, #2
 80167dc:	b2db      	uxtb	r3, r3
 80167de:	2b00      	cmp	r3, #0
 80167e0:	d004      	beq.n	80167ec <line_mask_flat+0x1ea>
 80167e2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80167e6:	43db      	mvns	r3, r3
 80167e8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            mask_buf[k] = mask_mix(mask_buf[k], m);
 80167ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80167ee:	68fa      	ldr	r2, [r7, #12]
 80167f0:	4413      	add	r3, r2
 80167f2:	7818      	ldrb	r0, [r3, #0]
 80167f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80167f6:	68fa      	ldr	r2, [r7, #12]
 80167f8:	18d4      	adds	r4, r2, r3
 80167fa:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80167fe:	4619      	mov	r1, r3
 8016800:	f000 fed4 	bl	80175ac <mask_mix>
 8016804:	4603      	mov	r3, r0
 8016806:	7023      	strb	r3, [r4, #0]
        }
        px_h -= p->spx;
 8016808:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801680a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801680c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801680e:	1ad3      	subs	r3, r2, r3
 8016810:	62bb      	str	r3, [r7, #40]	; 0x28
        k++;
 8016812:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016814:	3301      	adds	r3, #1
 8016816:	627b      	str	r3, [r7, #36]	; 0x24
        if(k >= len) break;
 8016818:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801681c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801681e:	429a      	cmp	r2, r3
 8016820:	da05      	bge.n	801682e <line_mask_flat+0x22c>
    while(px_h > p->spx) {
 8016822:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016824:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8016826:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016828:	429a      	cmp	r2, r3
 801682a:	dcc1      	bgt.n	80167b0 <line_mask_flat+0x1ae>
 801682c:	e000      	b.n	8016830 <line_mask_flat+0x22e>
        if(k >= len) break;
 801682e:	bf00      	nop
    }


    if(k < len && k >= 0) {
 8016830:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016834:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8016836:	429a      	cmp	r2, r3
 8016838:	da34      	bge.n	80168a4 <line_mask_flat+0x2a2>
 801683a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801683c:	2b00      	cmp	r3, #0
 801683e:	db31      	blt.n	80168a4 <line_mask_flat+0x2a2>
        int32_t x_inters = (px_h * p->xy_steep) >> 10;
 8016840:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016842:	699b      	ldr	r3, [r3, #24]
 8016844:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016846:	fb02 f303 	mul.w	r3, r2, r3
 801684a:	129b      	asrs	r3, r3, #10
 801684c:	613b      	str	r3, [r7, #16]
        m = (x_inters * px_h) >> 9;
 801684e:	693b      	ldr	r3, [r7, #16]
 8016850:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016852:	fb02 f303 	mul.w	r3, r2, r3
 8016856:	125b      	asrs	r3, r3, #9
 8016858:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        if(p->yx_steep < 0) m = 255 - m;
 801685c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801685e:	69db      	ldr	r3, [r3, #28]
 8016860:	2b00      	cmp	r3, #0
 8016862:	da04      	bge.n	801686e <line_mask_flat+0x26c>
 8016864:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8016868:	43db      	mvns	r3, r3
 801686a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        if(p->inv) m = 255 - m;
 801686e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8016870:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016874:	f003 0302 	and.w	r3, r3, #2
 8016878:	b2db      	uxtb	r3, r3
 801687a:	2b00      	cmp	r3, #0
 801687c:	d004      	beq.n	8016888 <line_mask_flat+0x286>
 801687e:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8016882:	43db      	mvns	r3, r3
 8016884:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        mask_buf[k] = mask_mix(mask_buf[k], m);
 8016888:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801688a:	68fa      	ldr	r2, [r7, #12]
 801688c:	4413      	add	r3, r2
 801688e:	7818      	ldrb	r0, [r3, #0]
 8016890:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016892:	68fa      	ldr	r2, [r7, #12]
 8016894:	18d4      	adds	r4, r2, r3
 8016896:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801689a:	4619      	mov	r1, r3
 801689c:	f000 fe86 	bl	80175ac <mask_mix>
 80168a0:	4603      	mov	r3, r0
 80168a2:	7023      	strb	r3, [r4, #0]
    }


    if(p->inv) {
 80168a4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80168a6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80168aa:	f003 0302 	and.w	r3, r3, #2
 80168ae:	b2db      	uxtb	r3, r3
 80168b0:	2b00      	cmp	r3, #0
 80168b2:	d014      	beq.n	80168de <line_mask_flat+0x2dc>
        k = xei - abs_x;
 80168b4:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 80168b8:	69ba      	ldr	r2, [r7, #24]
 80168ba:	1ad3      	subs	r3, r2, r3
 80168bc:	627b      	str	r3, [r7, #36]	; 0x24
        if(k > len) {
 80168be:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80168c2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80168c4:	429a      	cmp	r2, r3
 80168c6:	dd01      	ble.n	80168cc <line_mask_flat+0x2ca>
            return LV_DRAW_MASK_RES_TRANSP;
 80168c8:	2300      	movs	r3, #0
 80168ca:	e020      	b.n	801690e <line_mask_flat+0x30c>
        }
        if(k >= 0) {
 80168cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80168ce:	2b00      	cmp	r3, #0
 80168d0:	db1c      	blt.n	801690c <line_mask_flat+0x30a>
            _lv_memset_00(&mask_buf[0], k);
 80168d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80168d4:	4619      	mov	r1, r3
 80168d6:	68f8      	ldr	r0, [r7, #12]
 80168d8:	f00a fee6 	bl	80216a8 <_lv_memset_00>
 80168dc:	e016      	b.n	801690c <line_mask_flat+0x30a>
        }
    }
    else {
        k++;
 80168de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80168e0:	3301      	adds	r3, #1
 80168e2:	627b      	str	r3, [r7, #36]	; 0x24
        if(k < 0) {
 80168e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80168e6:	2b00      	cmp	r3, #0
 80168e8:	da01      	bge.n	80168ee <line_mask_flat+0x2ec>
            return LV_DRAW_MASK_RES_TRANSP;
 80168ea:	2300      	movs	r3, #0
 80168ec:	e00f      	b.n	801690e <line_mask_flat+0x30c>
        }
        if(k <= len) {
 80168ee:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80168f2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80168f4:	429a      	cmp	r2, r3
 80168f6:	dc09      	bgt.n	801690c <line_mask_flat+0x30a>
            _lv_memset_00(&mask_buf[k], len - k);
 80168f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80168fa:	68fa      	ldr	r2, [r7, #12]
 80168fc:	18d0      	adds	r0, r2, r3
 80168fe:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8016902:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8016904:	1ad3      	subs	r3, r2, r3
 8016906:	4619      	mov	r1, r3
 8016908:	f00a fece 	bl	80216a8 <_lv_memset_00>
        }
    }

    return LV_DRAW_MASK_RES_CHANGED;
 801690c:	2302      	movs	r3, #2
}
 801690e:	4618      	mov	r0, r3
 8016910:	3734      	adds	r7, #52	; 0x34
 8016912:	46bd      	mov	sp, r7
 8016914:	bd90      	pop	{r4, r7, pc}

08016916 <line_mask_steep>:

LV_ATTRIBUTE_FAST_MEM static lv_draw_mask_res_t line_mask_steep(lv_opa_t * mask_buf, lv_coord_t abs_x, lv_coord_t abs_y,
                                                                lv_coord_t len,
                                                                lv_draw_mask_line_param_t * p)
{
 8016916:	b590      	push	{r4, r7, lr}
 8016918:	b091      	sub	sp, #68	; 0x44
 801691a:	af00      	add	r7, sp, #0
 801691c:	60f8      	str	r0, [r7, #12]
 801691e:	4608      	mov	r0, r1
 8016920:	4611      	mov	r1, r2
 8016922:	461a      	mov	r2, r3
 8016924:	4603      	mov	r3, r0
 8016926:	817b      	strh	r3, [r7, #10]
 8016928:	460b      	mov	r3, r1
 801692a:	813b      	strh	r3, [r7, #8]
 801692c:	4613      	mov	r3, r2
 801692e:	80fb      	strh	r3, [r7, #6]
    int32_t k;
    int32_t x_at_y;
    /* At the beginning of the mask if the limit line is greater then the mask's y.
     * Then the mask is in the "wrong" area*/
    x_at_y = (int32_t)((int32_t)p->xy_steep * abs_y) >> 10;
 8016930:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016932:	699b      	ldr	r3, [r3, #24]
 8016934:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8016938:	fb02 f303 	mul.w	r3, r2, r3
 801693c:	129b      	asrs	r3, r3, #10
 801693e:	63bb      	str	r3, [r7, #56]	; 0x38
    if(p->xy_steep > 0) x_at_y++;
 8016940:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016942:	699b      	ldr	r3, [r3, #24]
 8016944:	2b00      	cmp	r3, #0
 8016946:	dd02      	ble.n	801694e <line_mask_steep+0x38>
 8016948:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801694a:	3301      	adds	r3, #1
 801694c:	63bb      	str	r3, [r7, #56]	; 0x38
    if(x_at_y < abs_x) {
 801694e:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016952:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8016954:	429a      	cmp	r2, r3
 8016956:	da0b      	bge.n	8016970 <line_mask_steep+0x5a>
        if(p->inv) {
 8016958:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801695a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 801695e:	f003 0302 	and.w	r3, r3, #2
 8016962:	b2db      	uxtb	r3, r3
 8016964:	2b00      	cmp	r3, #0
 8016966:	d001      	beq.n	801696c <line_mask_steep+0x56>
            return LV_DRAW_MASK_RES_FULL_COVER;
 8016968:	2301      	movs	r3, #1
 801696a:	e213      	b.n	8016d94 <line_mask_steep+0x47e>
        }
        else {
            return LV_DRAW_MASK_RES_TRANSP;
 801696c:	2300      	movs	r3, #0
 801696e:	e211      	b.n	8016d94 <line_mask_steep+0x47e>
        }
    }

    /* At the end of the mask if the limit line is smaller then the mask's y.
     * Then the mask is in the "good" area*/
    x_at_y = (int32_t)((int32_t)p->xy_steep * (abs_y)) >> 10;
 8016970:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016972:	699b      	ldr	r3, [r3, #24]
 8016974:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8016978:	fb02 f303 	mul.w	r3, r2, r3
 801697c:	129b      	asrs	r3, r3, #10
 801697e:	63bb      	str	r3, [r7, #56]	; 0x38
    if(x_at_y > abs_x + len) {
 8016980:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8016984:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016988:	4413      	add	r3, r2
 801698a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801698c:	429a      	cmp	r2, r3
 801698e:	dd0b      	ble.n	80169a8 <line_mask_steep+0x92>
        if(p->inv) {
 8016990:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016992:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016996:	f003 0302 	and.w	r3, r3, #2
 801699a:	b2db      	uxtb	r3, r3
 801699c:	2b00      	cmp	r3, #0
 801699e:	d001      	beq.n	80169a4 <line_mask_steep+0x8e>
            return LV_DRAW_MASK_RES_TRANSP;
 80169a0:	2300      	movs	r3, #0
 80169a2:	e1f7      	b.n	8016d94 <line_mask_steep+0x47e>
        }
        else {
            return LV_DRAW_MASK_RES_FULL_COVER;
 80169a4:	2301      	movs	r3, #1
 80169a6:	e1f5      	b.n	8016d94 <line_mask_steep+0x47e>
        }
    }

    /*X start*/
    int32_t xs = ((abs_y << 8) * p->xy_steep) >> 10;
 80169a8:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80169ac:	021b      	lsls	r3, r3, #8
 80169ae:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80169b0:	6992      	ldr	r2, [r2, #24]
 80169b2:	fb02 f303 	mul.w	r3, r2, r3
 80169b6:	129b      	asrs	r3, r3, #10
 80169b8:	62bb      	str	r3, [r7, #40]	; 0x28
    int32_t xsi = xs >> 8;
 80169ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80169bc:	121b      	asrs	r3, r3, #8
 80169be:	637b      	str	r3, [r7, #52]	; 0x34
    int32_t xsf = xs & 0xFF;
 80169c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80169c2:	b2db      	uxtb	r3, r3
 80169c4:	633b      	str	r3, [r7, #48]	; 0x30

    /*X end*/
    int32_t xe = (((abs_y + 1) << 8) * p->xy_steep) >> 10;
 80169c6:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80169ca:	3301      	adds	r3, #1
 80169cc:	021b      	lsls	r3, r3, #8
 80169ce:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80169d0:	6992      	ldr	r2, [r2, #24]
 80169d2:	fb02 f303 	mul.w	r3, r2, r3
 80169d6:	129b      	asrs	r3, r3, #10
 80169d8:	627b      	str	r3, [r7, #36]	; 0x24
    int32_t xei = xe >> 8;
 80169da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80169dc:	121b      	asrs	r3, r3, #8
 80169de:	623b      	str	r3, [r7, #32]
    int32_t xef = xe & 0xFF;
 80169e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80169e2:	b2db      	uxtb	r3, r3
 80169e4:	61fb      	str	r3, [r7, #28]

    lv_opa_t m;

    k = xsi - abs_x;
 80169e6:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 80169ea:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80169ec:	1ad3      	subs	r3, r2, r3
 80169ee:	63fb      	str	r3, [r7, #60]	; 0x3c
    if(xsi != xei && (p->xy_steep < 0 && xsf == 0)) {
 80169f0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80169f2:	6a3b      	ldr	r3, [r7, #32]
 80169f4:	429a      	cmp	r2, r3
 80169f6:	d00d      	beq.n	8016a14 <line_mask_steep+0xfe>
 80169f8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80169fa:	699b      	ldr	r3, [r3, #24]
 80169fc:	2b00      	cmp	r3, #0
 80169fe:	da09      	bge.n	8016a14 <line_mask_steep+0xfe>
 8016a00:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016a02:	2b00      	cmp	r3, #0
 8016a04:	d106      	bne.n	8016a14 <line_mask_steep+0xfe>
        xsf = 0xFF;
 8016a06:	23ff      	movs	r3, #255	; 0xff
 8016a08:	633b      	str	r3, [r7, #48]	; 0x30
        xsi = xei;
 8016a0a:	6a3b      	ldr	r3, [r7, #32]
 8016a0c:	637b      	str	r3, [r7, #52]	; 0x34
        k--;
 8016a0e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016a10:	3b01      	subs	r3, #1
 8016a12:	63fb      	str	r3, [r7, #60]	; 0x3c
    }

    if(xsi == xei) {
 8016a14:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8016a16:	6a3b      	ldr	r3, [r7, #32]
 8016a18:	429a      	cmp	r2, r3
 8016a1a:	d165      	bne.n	8016ae8 <line_mask_steep+0x1d2>
        if(k >= 0 && k < len) {
 8016a1c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016a1e:	2b00      	cmp	r3, #0
 8016a20:	db25      	blt.n	8016a6e <line_mask_steep+0x158>
 8016a22:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016a26:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016a28:	429a      	cmp	r2, r3
 8016a2a:	da20      	bge.n	8016a6e <line_mask_steep+0x158>
            m = (xsf + xef) >> 1;
 8016a2c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016a2e:	69fb      	ldr	r3, [r7, #28]
 8016a30:	4413      	add	r3, r2
 8016a32:	105b      	asrs	r3, r3, #1
 8016a34:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            if(p->inv) m = 255 - m;
 8016a38:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016a3a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016a3e:	f003 0302 	and.w	r3, r3, #2
 8016a42:	b2db      	uxtb	r3, r3
 8016a44:	2b00      	cmp	r3, #0
 8016a46:	d004      	beq.n	8016a52 <line_mask_steep+0x13c>
 8016a48:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016a4c:	43db      	mvns	r3, r3
 8016a4e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
            mask_buf[k] = mask_mix(mask_buf[k], m);
 8016a52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016a54:	68fa      	ldr	r2, [r7, #12]
 8016a56:	4413      	add	r3, r2
 8016a58:	7818      	ldrb	r0, [r3, #0]
 8016a5a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016a5c:	68fa      	ldr	r2, [r7, #12]
 8016a5e:	18d4      	adds	r4, r2, r3
 8016a60:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016a64:	4619      	mov	r1, r3
 8016a66:	f000 fda1 	bl	80175ac <mask_mix>
 8016a6a:	4603      	mov	r3, r0
 8016a6c:	7023      	strb	r3, [r4, #0]
        }
        k++;
 8016a6e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016a70:	3301      	adds	r3, #1
 8016a72:	63fb      	str	r3, [r7, #60]	; 0x3c

        if(p->inv) {
 8016a74:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016a76:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016a7a:	f003 0302 	and.w	r3, r3, #2
 8016a7e:	b2db      	uxtb	r3, r3
 8016a80:	2b00      	cmp	r3, #0
 8016a82:	d015      	beq.n	8016ab0 <line_mask_steep+0x19a>
            k = xsi - abs_x;
 8016a84:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016a88:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8016a8a:	1ad3      	subs	r3, r2, r3
 8016a8c:	63fb      	str	r3, [r7, #60]	; 0x3c
            if(k >= len) {
 8016a8e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016a92:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016a94:	429a      	cmp	r2, r3
 8016a96:	db01      	blt.n	8016a9c <line_mask_steep+0x186>
                return LV_DRAW_MASK_RES_TRANSP;
 8016a98:	2300      	movs	r3, #0
 8016a9a:	e17b      	b.n	8016d94 <line_mask_steep+0x47e>
            }
            if(k >= 0) _lv_memset_00(&mask_buf[0], k);
 8016a9c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016a9e:	2b00      	cmp	r3, #0
 8016aa0:	f2c0 8177 	blt.w	8016d92 <line_mask_steep+0x47c>
 8016aa4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016aa6:	4619      	mov	r1, r3
 8016aa8:	68f8      	ldr	r0, [r7, #12]
 8016aaa:	f00a fdfd 	bl	80216a8 <_lv_memset_00>
 8016aae:	e170      	b.n	8016d92 <line_mask_steep+0x47c>

        }
        else {
            if(k > len) k = len;
 8016ab0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016ab4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016ab6:	429a      	cmp	r2, r3
 8016ab8:	dd02      	ble.n	8016ac0 <line_mask_steep+0x1aa>
 8016aba:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016abe:	63fb      	str	r3, [r7, #60]	; 0x3c
            if(k == 0) return LV_DRAW_MASK_RES_TRANSP;
 8016ac0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016ac2:	2b00      	cmp	r3, #0
 8016ac4:	d101      	bne.n	8016aca <line_mask_steep+0x1b4>
 8016ac6:	2300      	movs	r3, #0
 8016ac8:	e164      	b.n	8016d94 <line_mask_steep+0x47e>
            else if(k > 0) _lv_memset_00(&mask_buf[k],  len - k);
 8016aca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016acc:	2b00      	cmp	r3, #0
 8016ace:	f340 8160 	ble.w	8016d92 <line_mask_steep+0x47c>
 8016ad2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016ad4:	68fa      	ldr	r2, [r7, #12]
 8016ad6:	18d0      	adds	r0, r2, r3
 8016ad8:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8016adc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016ade:	1ad3      	subs	r3, r2, r3
 8016ae0:	4619      	mov	r1, r3
 8016ae2:	f00a fde1 	bl	80216a8 <_lv_memset_00>
 8016ae6:	e154      	b.n	8016d92 <line_mask_steep+0x47c>
        }

    }
    else {
        int32_t y_inters;
        if(p->xy_steep < 0) {
 8016ae8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016aea:	699b      	ldr	r3, [r3, #24]
 8016aec:	2b00      	cmp	r3, #0
 8016aee:	f280 80a7 	bge.w	8016c40 <line_mask_steep+0x32a>
            y_inters = (xsf * (-p->yx_steep)) >> 10;
 8016af2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016af4:	69db      	ldr	r3, [r3, #28]
 8016af6:	425b      	negs	r3, r3
 8016af8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016afa:	fb02 f303 	mul.w	r3, r2, r3
 8016afe:	129b      	asrs	r3, r3, #10
 8016b00:	61bb      	str	r3, [r7, #24]
            if(k >= 0 && k < len) {
 8016b02:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016b04:	2b00      	cmp	r3, #0
 8016b06:	db26      	blt.n	8016b56 <line_mask_steep+0x240>
 8016b08:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016b0c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016b0e:	429a      	cmp	r2, r3
 8016b10:	da21      	bge.n	8016b56 <line_mask_steep+0x240>
                m = (y_inters * xsf) >> 9;
 8016b12:	69bb      	ldr	r3, [r7, #24]
 8016b14:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8016b16:	fb02 f303 	mul.w	r3, r2, r3
 8016b1a:	125b      	asrs	r3, r3, #9
 8016b1c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                if(p->inv) m = 255 - m;
 8016b20:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016b22:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016b26:	f003 0302 	and.w	r3, r3, #2
 8016b2a:	b2db      	uxtb	r3, r3
 8016b2c:	2b00      	cmp	r3, #0
 8016b2e:	d004      	beq.n	8016b3a <line_mask_steep+0x224>
 8016b30:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016b34:	43db      	mvns	r3, r3
 8016b36:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                mask_buf[k] = mask_mix(mask_buf[k], m);
 8016b3a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016b3c:	68fa      	ldr	r2, [r7, #12]
 8016b3e:	4413      	add	r3, r2
 8016b40:	7818      	ldrb	r0, [r3, #0]
 8016b42:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016b44:	68fa      	ldr	r2, [r7, #12]
 8016b46:	18d4      	adds	r4, r2, r3
 8016b48:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016b4c:	4619      	mov	r1, r3
 8016b4e:	f000 fd2d 	bl	80175ac <mask_mix>
 8016b52:	4603      	mov	r3, r0
 8016b54:	7023      	strb	r3, [r4, #0]
            }
            k--;
 8016b56:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016b58:	3b01      	subs	r3, #1
 8016b5a:	63fb      	str	r3, [r7, #60]	; 0x3c

            int32_t x_inters = ((255 - y_inters) * (-p->xy_steep)) >> 10;
 8016b5c:	69bb      	ldr	r3, [r7, #24]
 8016b5e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8016b62:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8016b64:	6992      	ldr	r2, [r2, #24]
 8016b66:	4252      	negs	r2, r2
 8016b68:	fb02 f303 	mul.w	r3, r2, r3
 8016b6c:	129b      	asrs	r3, r3, #10
 8016b6e:	613b      	str	r3, [r7, #16]

            if(k >= 0 && k < len) {
 8016b70:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016b72:	2b00      	cmp	r3, #0
 8016b74:	db2a      	blt.n	8016bcc <line_mask_steep+0x2b6>
 8016b76:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016b7a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016b7c:	429a      	cmp	r2, r3
 8016b7e:	da25      	bge.n	8016bcc <line_mask_steep+0x2b6>
                m = 255 - (((255 - y_inters) * x_inters) >> 9);
 8016b80:	69bb      	ldr	r3, [r7, #24]
 8016b82:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8016b86:	693a      	ldr	r2, [r7, #16]
 8016b88:	fb02 f303 	mul.w	r3, r2, r3
 8016b8c:	125b      	asrs	r3, r3, #9
 8016b8e:	b2db      	uxtb	r3, r3
 8016b90:	43db      	mvns	r3, r3
 8016b92:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                if(p->inv) m = 255 - m;
 8016b96:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016b98:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016b9c:	f003 0302 	and.w	r3, r3, #2
 8016ba0:	b2db      	uxtb	r3, r3
 8016ba2:	2b00      	cmp	r3, #0
 8016ba4:	d004      	beq.n	8016bb0 <line_mask_steep+0x29a>
 8016ba6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016baa:	43db      	mvns	r3, r3
 8016bac:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                mask_buf[k] = mask_mix(mask_buf[k], m);
 8016bb0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016bb2:	68fa      	ldr	r2, [r7, #12]
 8016bb4:	4413      	add	r3, r2
 8016bb6:	7818      	ldrb	r0, [r3, #0]
 8016bb8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016bba:	68fa      	ldr	r2, [r7, #12]
 8016bbc:	18d4      	adds	r4, r2, r3
 8016bbe:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016bc2:	4619      	mov	r1, r3
 8016bc4:	f000 fcf2 	bl	80175ac <mask_mix>
 8016bc8:	4603      	mov	r3, r0
 8016bca:	7023      	strb	r3, [r4, #0]
            }

            k += 2;
 8016bcc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016bce:	3302      	adds	r3, #2
 8016bd0:	63fb      	str	r3, [r7, #60]	; 0x3c

            if(p->inv) {
 8016bd2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016bd4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016bd8:	f003 0302 	and.w	r3, r3, #2
 8016bdc:	b2db      	uxtb	r3, r3
 8016bde:	2b00      	cmp	r3, #0
 8016be0:	d018      	beq.n	8016c14 <line_mask_steep+0x2fe>
                k = xsi - abs_x - 1;
 8016be2:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016be6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8016be8:	1ad3      	subs	r3, r2, r3
 8016bea:	3b01      	subs	r3, #1
 8016bec:	63fb      	str	r3, [r7, #60]	; 0x3c

                if(k > len) k = len;
 8016bee:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016bf2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016bf4:	429a      	cmp	r2, r3
 8016bf6:	dd03      	ble.n	8016c00 <line_mask_steep+0x2ea>
 8016bf8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016bfc:	63fb      	str	r3, [r7, #60]	; 0x3c
 8016bfe:	e0c8      	b.n	8016d92 <line_mask_steep+0x47c>
                else if(k > 0) _lv_memset_00(&mask_buf[0],  k);
 8016c00:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c02:	2b00      	cmp	r3, #0
 8016c04:	f340 80c5 	ble.w	8016d92 <line_mask_steep+0x47c>
 8016c08:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c0a:	4619      	mov	r1, r3
 8016c0c:	68f8      	ldr	r0, [r7, #12]
 8016c0e:	f00a fd4b 	bl	80216a8 <_lv_memset_00>
 8016c12:	e0be      	b.n	8016d92 <line_mask_steep+0x47c>

            }
            else {
                if(k > len) return LV_DRAW_MASK_RES_FULL_COVER;
 8016c14:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016c18:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016c1a:	429a      	cmp	r2, r3
 8016c1c:	dd01      	ble.n	8016c22 <line_mask_steep+0x30c>
 8016c1e:	2301      	movs	r3, #1
 8016c20:	e0b8      	b.n	8016d94 <line_mask_steep+0x47e>
                if(k >= 0) _lv_memset_00(&mask_buf[k],  len - k);
 8016c22:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c24:	2b00      	cmp	r3, #0
 8016c26:	f2c0 80b4 	blt.w	8016d92 <line_mask_steep+0x47c>
 8016c2a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c2c:	68fa      	ldr	r2, [r7, #12]
 8016c2e:	18d0      	adds	r0, r2, r3
 8016c30:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8016c34:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c36:	1ad3      	subs	r3, r2, r3
 8016c38:	4619      	mov	r1, r3
 8016c3a:	f00a fd35 	bl	80216a8 <_lv_memset_00>
 8016c3e:	e0a8      	b.n	8016d92 <line_mask_steep+0x47c>
            }

        }
        else {
            y_inters = ((255 - xsf) * p->yx_steep) >> 10;
 8016c40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016c42:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8016c46:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8016c48:	69d2      	ldr	r2, [r2, #28]
 8016c4a:	fb02 f303 	mul.w	r3, r2, r3
 8016c4e:	129b      	asrs	r3, r3, #10
 8016c50:	61bb      	str	r3, [r7, #24]
            if(k >= 0 && k < len) {
 8016c52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c54:	2b00      	cmp	r3, #0
 8016c56:	db2a      	blt.n	8016cae <line_mask_steep+0x398>
 8016c58:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016c5c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016c5e:	429a      	cmp	r2, r3
 8016c60:	da25      	bge.n	8016cae <line_mask_steep+0x398>
                m = 255 - ((y_inters * (255 - xsf)) >> 9);
 8016c62:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8016c64:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8016c68:	69ba      	ldr	r2, [r7, #24]
 8016c6a:	fb02 f303 	mul.w	r3, r2, r3
 8016c6e:	125b      	asrs	r3, r3, #9
 8016c70:	b2db      	uxtb	r3, r3
 8016c72:	43db      	mvns	r3, r3
 8016c74:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                if(p->inv) m = 255 - m;
 8016c78:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016c7a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016c7e:	f003 0302 	and.w	r3, r3, #2
 8016c82:	b2db      	uxtb	r3, r3
 8016c84:	2b00      	cmp	r3, #0
 8016c86:	d004      	beq.n	8016c92 <line_mask_steep+0x37c>
 8016c88:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016c8c:	43db      	mvns	r3, r3
 8016c8e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                mask_buf[k] = mask_mix(mask_buf[k], m);
 8016c92:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c94:	68fa      	ldr	r2, [r7, #12]
 8016c96:	4413      	add	r3, r2
 8016c98:	7818      	ldrb	r0, [r3, #0]
 8016c9a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016c9c:	68fa      	ldr	r2, [r7, #12]
 8016c9e:	18d4      	adds	r4, r2, r3
 8016ca0:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016ca4:	4619      	mov	r1, r3
 8016ca6:	f000 fc81 	bl	80175ac <mask_mix>
 8016caa:	4603      	mov	r3, r0
 8016cac:	7023      	strb	r3, [r4, #0]
            }

            k++;
 8016cae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016cb0:	3301      	adds	r3, #1
 8016cb2:	63fb      	str	r3, [r7, #60]	; 0x3c

            int32_t x_inters = ((255 - y_inters) * p->xy_steep) >> 10;
 8016cb4:	69bb      	ldr	r3, [r7, #24]
 8016cb6:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8016cba:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8016cbc:	6992      	ldr	r2, [r2, #24]
 8016cbe:	fb02 f303 	mul.w	r3, r2, r3
 8016cc2:	129b      	asrs	r3, r3, #10
 8016cc4:	617b      	str	r3, [r7, #20]
            if(k >= 0 && k < len) {
 8016cc6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016cc8:	2b00      	cmp	r3, #0
 8016cca:	db28      	blt.n	8016d1e <line_mask_steep+0x408>
 8016ccc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016cd0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016cd2:	429a      	cmp	r2, r3
 8016cd4:	da23      	bge.n	8016d1e <line_mask_steep+0x408>
                m = ((255 - y_inters) * x_inters) >> 9;
 8016cd6:	69bb      	ldr	r3, [r7, #24]
 8016cd8:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8016cdc:	697a      	ldr	r2, [r7, #20]
 8016cde:	fb02 f303 	mul.w	r3, r2, r3
 8016ce2:	125b      	asrs	r3, r3, #9
 8016ce4:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                if(p->inv) m = 255 - m;
 8016ce8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016cea:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016cee:	f003 0302 	and.w	r3, r3, #2
 8016cf2:	b2db      	uxtb	r3, r3
 8016cf4:	2b00      	cmp	r3, #0
 8016cf6:	d004      	beq.n	8016d02 <line_mask_steep+0x3ec>
 8016cf8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016cfc:	43db      	mvns	r3, r3
 8016cfe:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
                mask_buf[k] = mask_mix(mask_buf[k], m);
 8016d02:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016d04:	68fa      	ldr	r2, [r7, #12]
 8016d06:	4413      	add	r3, r2
 8016d08:	7818      	ldrb	r0, [r3, #0]
 8016d0a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016d0c:	68fa      	ldr	r2, [r7, #12]
 8016d0e:	18d4      	adds	r4, r2, r3
 8016d10:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8016d14:	4619      	mov	r1, r3
 8016d16:	f000 fc49 	bl	80175ac <mask_mix>
 8016d1a:	4603      	mov	r3, r0
 8016d1c:	7023      	strb	r3, [r4, #0]
            }
            k++;
 8016d1e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016d20:	3301      	adds	r3, #1
 8016d22:	63fb      	str	r3, [r7, #60]	; 0x3c

            if(p->inv) {
 8016d24:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016d26:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8016d2a:	f003 0302 	and.w	r3, r3, #2
 8016d2e:	b2db      	uxtb	r3, r3
 8016d30:	2b00      	cmp	r3, #0
 8016d32:	d014      	beq.n	8016d5e <line_mask_steep+0x448>
                k = xsi - abs_x;
 8016d34:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016d38:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8016d3a:	1ad3      	subs	r3, r2, r3
 8016d3c:	63fb      	str	r3, [r7, #60]	; 0x3c
                if(k > len)  return LV_DRAW_MASK_RES_TRANSP;
 8016d3e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016d42:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016d44:	429a      	cmp	r2, r3
 8016d46:	dd01      	ble.n	8016d4c <line_mask_steep+0x436>
 8016d48:	2300      	movs	r3, #0
 8016d4a:	e023      	b.n	8016d94 <line_mask_steep+0x47e>
                if(k >= 0) _lv_memset_00(&mask_buf[0],  k);
 8016d4c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016d4e:	2b00      	cmp	r3, #0
 8016d50:	db1f      	blt.n	8016d92 <line_mask_steep+0x47c>
 8016d52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016d54:	4619      	mov	r1, r3
 8016d56:	68f8      	ldr	r0, [r7, #12]
 8016d58:	f00a fca6 	bl	80216a8 <_lv_memset_00>
 8016d5c:	e019      	b.n	8016d92 <line_mask_steep+0x47c>

            }
            else {
                if(k > len) k = len;
 8016d5e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016d62:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8016d64:	429a      	cmp	r2, r3
 8016d66:	dd02      	ble.n	8016d6e <line_mask_steep+0x458>
 8016d68:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016d6c:	63fb      	str	r3, [r7, #60]	; 0x3c
                if(k == 0) return LV_DRAW_MASK_RES_TRANSP;
 8016d6e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016d70:	2b00      	cmp	r3, #0
 8016d72:	d101      	bne.n	8016d78 <line_mask_steep+0x462>
 8016d74:	2300      	movs	r3, #0
 8016d76:	e00d      	b.n	8016d94 <line_mask_steep+0x47e>
                else if(k > 0) _lv_memset_00(&mask_buf[k],  len - k);
 8016d78:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016d7a:	2b00      	cmp	r3, #0
 8016d7c:	dd09      	ble.n	8016d92 <line_mask_steep+0x47c>
 8016d7e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016d80:	68fa      	ldr	r2, [r7, #12]
 8016d82:	18d0      	adds	r0, r2, r3
 8016d84:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8016d88:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016d8a:	1ad3      	subs	r3, r2, r3
 8016d8c:	4619      	mov	r1, r3
 8016d8e:	f00a fc8b 	bl	80216a8 <_lv_memset_00>
            }
        }
    }

    return LV_DRAW_MASK_RES_CHANGED;
 8016d92:	2302      	movs	r3, #2
}
 8016d94:	4618      	mov	r0, r3
 8016d96:	3744      	adds	r7, #68	; 0x44
 8016d98:	46bd      	mov	sp, r7
 8016d9a:	bd90      	pop	{r4, r7, pc}

08016d9c <lv_draw_mask_radius>:
}

LV_ATTRIBUTE_FAST_MEM static lv_draw_mask_res_t lv_draw_mask_radius(lv_opa_t * mask_buf, lv_coord_t abs_x,
                                                                    lv_coord_t abs_y, lv_coord_t len,
                                                                    lv_draw_mask_radius_param_t * p)
{
 8016d9c:	b590      	push	{r4, r7, lr}
 8016d9e:	b0a3      	sub	sp, #140	; 0x8c
 8016da0:	af00      	add	r7, sp, #0
 8016da2:	60f8      	str	r0, [r7, #12]
 8016da4:	4608      	mov	r0, r1
 8016da6:	4611      	mov	r1, r2
 8016da8:	461a      	mov	r2, r3
 8016daa:	4603      	mov	r3, r0
 8016dac:	817b      	strh	r3, [r7, #10]
 8016dae:	460b      	mov	r3, r1
 8016db0:	813b      	strh	r3, [r7, #8]
 8016db2:	4613      	mov	r3, r2
 8016db4:	80fb      	strh	r3, [r7, #6]
    bool outer = p->cfg.outer;
 8016db6:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8016dba:	7c9b      	ldrb	r3, [r3, #18]
 8016dbc:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8016dc0:	b2db      	uxtb	r3, r3
 8016dc2:	2b00      	cmp	r3, #0
 8016dc4:	bf14      	ite	ne
 8016dc6:	2301      	movne	r3, #1
 8016dc8:	2300      	moveq	r3, #0
 8016dca:	f887 3056 	strb.w	r3, [r7, #86]	; 0x56
    int32_t radius = p->cfg.radius;
 8016dce:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8016dd2:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8016dd6:	653b      	str	r3, [r7, #80]	; 0x50
    lv_area_t rect;
    lv_area_copy(&rect, &p->cfg.rect);
 8016dd8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8016ddc:	f103 0208 	add.w	r2, r3, #8
 8016de0:	f107 0320 	add.w	r3, r7, #32
 8016de4:	4611      	mov	r1, r2
 8016de6:	4618      	mov	r0, r3
 8016de8:	f7ff f876 	bl	8015ed8 <lv_area_copy>

    if(outer == false) {
 8016dec:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 8016df0:	f083 0301 	eor.w	r3, r3, #1
 8016df4:	b2db      	uxtb	r3, r3
 8016df6:	2b00      	cmp	r3, #0
 8016df8:	d00d      	beq.n	8016e16 <lv_draw_mask_radius+0x7a>
        if(abs_y < rect.y1 || abs_y > rect.y2) {
 8016dfa:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8016dfe:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8016e02:	429a      	cmp	r2, r3
 8016e04:	db05      	blt.n	8016e12 <lv_draw_mask_radius+0x76>
 8016e06:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8016e0a:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8016e0e:	429a      	cmp	r2, r3
 8016e10:	dd0f      	ble.n	8016e32 <lv_draw_mask_radius+0x96>
            return LV_DRAW_MASK_RES_TRANSP;
 8016e12:	2300      	movs	r3, #0
 8016e14:	e3c6      	b.n	80175a4 <lv_draw_mask_radius+0x808>
        }
    }
    else {
        if(abs_y < rect.y1 || abs_y > rect.y2) {
 8016e16:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8016e1a:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8016e1e:	429a      	cmp	r2, r3
 8016e20:	db05      	blt.n	8016e2e <lv_draw_mask_radius+0x92>
 8016e22:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8016e26:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8016e2a:	429a      	cmp	r2, r3
 8016e2c:	dd01      	ble.n	8016e32 <lv_draw_mask_radius+0x96>
            return LV_DRAW_MASK_RES_FULL_COVER;
 8016e2e:	2301      	movs	r3, #1
 8016e30:	e3b8      	b.n	80175a4 <lv_draw_mask_radius+0x808>
        }
    }

    if((abs_x >= rect.x1 + radius && abs_x + len <= rect.x2 - radius) ||
 8016e32:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8016e36:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8016e3a:	4619      	mov	r1, r3
 8016e3c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016e3e:	440b      	add	r3, r1
 8016e40:	429a      	cmp	r2, r3
 8016e42:	db0b      	blt.n	8016e5c <lv_draw_mask_radius+0xc0>
 8016e44:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8016e48:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016e4c:	441a      	add	r2, r3
 8016e4e:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8016e52:	4619      	mov	r1, r3
 8016e54:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016e56:	1acb      	subs	r3, r1, r3
 8016e58:	429a      	cmp	r2, r3
 8016e5a:	dd13      	ble.n	8016e84 <lv_draw_mask_radius+0xe8>
       (abs_y >= rect.y1 + radius && abs_y <= rect.y2 - radius)) {
 8016e5c:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8016e60:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8016e64:	4619      	mov	r1, r3
 8016e66:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016e68:	440b      	add	r3, r1
    if((abs_x >= rect.x1 + radius && abs_x + len <= rect.x2 - radius) ||
 8016e6a:	429a      	cmp	r2, r3
 8016e6c:	f2c0 8090 	blt.w	8016f90 <lv_draw_mask_radius+0x1f4>
       (abs_y >= rect.y1 + radius && abs_y <= rect.y2 - radius)) {
 8016e70:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8016e74:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8016e78:	4619      	mov	r1, r3
 8016e7a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016e7c:	1acb      	subs	r3, r1, r3
 8016e7e:	429a      	cmp	r2, r3
 8016e80:	f300 8086 	bgt.w	8016f90 <lv_draw_mask_radius+0x1f4>
        if(outer == false) {
 8016e84:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 8016e88:	f083 0301 	eor.w	r3, r3, #1
 8016e8c:	b2db      	uxtb	r3, r3
 8016e8e:	2b00      	cmp	r3, #0
 8016e90:	d03d      	beq.n	8016f0e <lv_draw_mask_radius+0x172>
            /*Remove the edges*/
            int32_t last =  rect.x1 - abs_x;
 8016e92:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8016e96:	461a      	mov	r2, r3
 8016e98:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016e9c:	1ad3      	subs	r3, r2, r3
 8016e9e:	62fb      	str	r3, [r7, #44]	; 0x2c
            if(last > len) return LV_DRAW_MASK_RES_TRANSP;
 8016ea0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016ea4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8016ea6:	429a      	cmp	r2, r3
 8016ea8:	dd01      	ble.n	8016eae <lv_draw_mask_radius+0x112>
 8016eaa:	2300      	movs	r3, #0
 8016eac:	e37a      	b.n	80175a4 <lv_draw_mask_radius+0x808>
            if(last >= 0) {
 8016eae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016eb0:	2b00      	cmp	r3, #0
 8016eb2:	db04      	blt.n	8016ebe <lv_draw_mask_radius+0x122>
                _lv_memset_00(&mask_buf[0], last);
 8016eb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016eb6:	4619      	mov	r1, r3
 8016eb8:	68f8      	ldr	r0, [r7, #12]
 8016eba:	f00a fbf5 	bl	80216a8 <_lv_memset_00>
            }

            int32_t first = rect.x2 - abs_x + 1;
 8016ebe:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8016ec2:	461a      	mov	r2, r3
 8016ec4:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016ec8:	1ad3      	subs	r3, r2, r3
 8016eca:	3301      	adds	r3, #1
 8016ecc:	62bb      	str	r3, [r7, #40]	; 0x28
            if(first <= 0) return LV_DRAW_MASK_RES_TRANSP;
 8016ece:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ed0:	2b00      	cmp	r3, #0
 8016ed2:	dc01      	bgt.n	8016ed8 <lv_draw_mask_radius+0x13c>
 8016ed4:	2300      	movs	r3, #0
 8016ed6:	e365      	b.n	80175a4 <lv_draw_mask_radius+0x808>
            else if(first < len) {
 8016ed8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016edc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016ede:	429a      	cmp	r2, r3
 8016ee0:	da09      	bge.n	8016ef6 <lv_draw_mask_radius+0x15a>
                _lv_memset_00(&mask_buf[first], len - first);
 8016ee2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016ee4:	68fa      	ldr	r2, [r7, #12]
 8016ee6:	18d0      	adds	r0, r2, r3
 8016ee8:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8016eec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8016eee:	1ad3      	subs	r3, r2, r3
 8016ef0:	4619      	mov	r1, r3
 8016ef2:	f00a fbd9 	bl	80216a8 <_lv_memset_00>
            }
            if(last == 0 && first == len) return LV_DRAW_MASK_RES_FULL_COVER;
 8016ef6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016ef8:	2b00      	cmp	r3, #0
 8016efa:	d106      	bne.n	8016f0a <lv_draw_mask_radius+0x16e>
 8016efc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016f00:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8016f02:	429a      	cmp	r2, r3
 8016f04:	d101      	bne.n	8016f0a <lv_draw_mask_radius+0x16e>
 8016f06:	2301      	movs	r3, #1
 8016f08:	e34c      	b.n	80175a4 <lv_draw_mask_radius+0x808>
            else return LV_DRAW_MASK_RES_CHANGED;
 8016f0a:	2302      	movs	r3, #2
 8016f0c:	e34a      	b.n	80175a4 <lv_draw_mask_radius+0x808>
        }
        else {
            int32_t first = rect.x1 - abs_x;
 8016f0e:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8016f12:	461a      	mov	r2, r3
 8016f14:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016f18:	1ad3      	subs	r3, r2, r3
 8016f1a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
            if(first < 0) first = 0;
 8016f1e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8016f22:	2b00      	cmp	r3, #0
 8016f24:	da02      	bge.n	8016f2c <lv_draw_mask_radius+0x190>
 8016f26:	2300      	movs	r3, #0
 8016f28:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
            if(first <= len) {
 8016f2c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016f30:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8016f34:	429a      	cmp	r2, r3
 8016f36:	dc29      	bgt.n	8016f8c <lv_draw_mask_radius+0x1f0>
                int32_t last =  rect.x2 - abs_x - first + 1;
 8016f38:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8016f3c:	461a      	mov	r2, r3
 8016f3e:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016f42:	1ad2      	subs	r2, r2, r3
 8016f44:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8016f48:	1ad3      	subs	r3, r2, r3
 8016f4a:	3301      	adds	r3, #1
 8016f4c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                if(first + last > len) last = len - first;
 8016f50:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8016f54:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8016f58:	441a      	add	r2, r3
 8016f5a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8016f5e:	429a      	cmp	r2, r3
 8016f60:	dd06      	ble.n	8016f70 <lv_draw_mask_radius+0x1d4>
 8016f62:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8016f66:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8016f6a:	1ad3      	subs	r3, r2, r3
 8016f6c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                if(last >= 0) {
 8016f70:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8016f74:	2b00      	cmp	r3, #0
 8016f76:	db09      	blt.n	8016f8c <lv_draw_mask_radius+0x1f0>
                    _lv_memset_00(&mask_buf[first], last);
 8016f78:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8016f7c:	68fa      	ldr	r2, [r7, #12]
 8016f7e:	4413      	add	r3, r2
 8016f80:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8016f84:	4611      	mov	r1, r2
 8016f86:	4618      	mov	r0, r3
 8016f88:	f00a fb8e 	bl	80216a8 <_lv_memset_00>
                }
            }
        }
        return LV_DRAW_MASK_RES_CHANGED;
 8016f8c:	2302      	movs	r3, #2
 8016f8e:	e309      	b.n	80175a4 <lv_draw_mask_radius+0x808>
    }

    int32_t k = rect.x1 - abs_x; /*First relevant coordinate on the of the mask*/
 8016f90:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8016f94:	461a      	mov	r2, r3
 8016f96:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016f9a:	1ad3      	subs	r3, r2, r3
 8016f9c:	64fb      	str	r3, [r7, #76]	; 0x4c
    int32_t w = lv_area_get_width(&rect);
 8016f9e:	f107 0320 	add.w	r3, r7, #32
 8016fa2:	4618      	mov	r0, r3
 8016fa4:	f7fe ffa6 	bl	8015ef4 <lv_area_get_width>
 8016fa8:	4603      	mov	r3, r0
 8016faa:	64bb      	str	r3, [r7, #72]	; 0x48
    int32_t h = lv_area_get_height(&rect);
 8016fac:	f107 0320 	add.w	r3, r7, #32
 8016fb0:	4618      	mov	r0, r3
 8016fb2:	f7fe ffb6 	bl	8015f22 <lv_area_get_height>
 8016fb6:	4603      	mov	r3, r0
 8016fb8:	647b      	str	r3, [r7, #68]	; 0x44
    abs_x -= rect.x1;
 8016fba:	897a      	ldrh	r2, [r7, #10]
 8016fbc:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8016fc0:	b29b      	uxth	r3, r3
 8016fc2:	1ad3      	subs	r3, r2, r3
 8016fc4:	b29b      	uxth	r3, r3
 8016fc6:	817b      	strh	r3, [r7, #10]
    abs_y -= rect.y1;
 8016fc8:	893a      	ldrh	r2, [r7, #8]
 8016fca:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8016fce:	b29b      	uxth	r3, r3
 8016fd0:	1ad3      	subs	r3, r2, r3
 8016fd2:	b29b      	uxth	r3, r3
 8016fd4:	813b      	strh	r3, [r7, #8]

    uint32_t r2 = p->cfg.radius * p->cfg.radius;
 8016fd6:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8016fda:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8016fde:	461a      	mov	r2, r3
 8016fe0:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8016fe4:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8016fe8:	fb02 f303 	mul.w	r3, r2, r3
 8016fec:	643b      	str	r3, [r7, #64]	; 0x40

    /*Handle corner areas*/
    if(abs_y < radius || abs_y > h - radius - 1) {
 8016fee:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8016ff2:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8016ff4:	429a      	cmp	r2, r3
 8016ff6:	dc07      	bgt.n	8017008 <lv_draw_mask_radius+0x26c>
 8016ff8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8016ffa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8016ffc:	1ad2      	subs	r2, r2, r3
 8016ffe:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8017002:	429a      	cmp	r2, r3
 8017004:	f300 82cd 	bgt.w	80175a2 <lv_draw_mask_radius+0x806>

        uint32_t sqrt_mask;
        if(radius <= 32) sqrt_mask = 0x200;
 8017008:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801700a:	2b20      	cmp	r3, #32
 801700c:	dc02      	bgt.n	8017014 <lv_draw_mask_radius+0x278>
 801700e:	f44f 7300 	mov.w	r3, #512	; 0x200
 8017012:	67fb      	str	r3, [r7, #124]	; 0x7c
        if(radius <= 256) sqrt_mask = 0x800;
 8017014:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8017016:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801701a:	dc03      	bgt.n	8017024 <lv_draw_mask_radius+0x288>
 801701c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8017020:	67fb      	str	r3, [r7, #124]	; 0x7c
 8017022:	e002      	b.n	801702a <lv_draw_mask_radius+0x28e>
        else sqrt_mask = 0x8000;
 8017024:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8017028:	67fb      	str	r3, [r7, #124]	; 0x7c

        lv_sqrt_res_t x0;
        lv_sqrt_res_t x1;
        /* y = 0 should mean the top of the circle */
        int32_t y;
        if(abs_y < radius) {
 801702a:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 801702e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8017030:	429a      	cmp	r2, r3
 8017032:	dd3c      	ble.n	80170ae <lv_draw_mask_radius+0x312>
            y = radius - abs_y;
 8017034:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8017038:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801703a:	1ad3      	subs	r3, r2, r3
 801703c:	67bb      	str	r3, [r7, #120]	; 0x78

            /* Get the x intersection points for `abs_y` and `abs_y-1`
             * Use the circle's equation x = sqrt(r^2 - y^2)
             * Try to use the values from the previous run*/
            if(y == p->y_prev) {
 801703e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8017042:	695b      	ldr	r3, [r3, #20]
 8017044:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8017046:	429a      	cmp	r2, r3
 8017048:	d108      	bne.n	801705c <lv_draw_mask_radius+0x2c0>
                x0.f = p->y_prev_x.f;
 801704a:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 801704e:	8b5b      	ldrh	r3, [r3, #26]
 8017050:	83fb      	strh	r3, [r7, #30]
                x0.i = p->y_prev_x.i;
 8017052:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8017056:	8b1b      	ldrh	r3, [r3, #24]
 8017058:	83bb      	strh	r3, [r7, #28]
 801705a:	e00b      	b.n	8017074 <lv_draw_mask_radius+0x2d8>
            }
            else {
                _lv_sqrt(r2 - (y * y), &x0, sqrt_mask);
 801705c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 801705e:	fb03 f303 	mul.w	r3, r3, r3
 8017062:	461a      	mov	r2, r3
 8017064:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017066:	1a9b      	subs	r3, r3, r2
 8017068:	f107 011c 	add.w	r1, r7, #28
 801706c:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 801706e:	4618      	mov	r0, r3
 8017070:	f009 fd5c 	bl	8020b2c <_lv_sqrt>
            }
            _lv_sqrt(r2 - ((y - 1) * (y - 1)), &x1, sqrt_mask);
 8017074:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8017076:	3b01      	subs	r3, #1
 8017078:	6fba      	ldr	r2, [r7, #120]	; 0x78
 801707a:	3a01      	subs	r2, #1
 801707c:	fb02 f303 	mul.w	r3, r2, r3
 8017080:	461a      	mov	r2, r3
 8017082:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017084:	1a9b      	subs	r3, r3, r2
 8017086:	f107 0118 	add.w	r1, r7, #24
 801708a:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 801708c:	4618      	mov	r0, r3
 801708e:	f009 fd4d 	bl	8020b2c <_lv_sqrt>
            p->y_prev = y - 1;
 8017092:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8017094:	1e5a      	subs	r2, r3, #1
 8017096:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 801709a:	615a      	str	r2, [r3, #20]
            p->y_prev_x.f = x1.f;
 801709c:	8b7a      	ldrh	r2, [r7, #26]
 801709e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80170a2:	835a      	strh	r2, [r3, #26]
            p->y_prev_x.i = x1.i;
 80170a4:	8b3a      	ldrh	r2, [r7, #24]
 80170a6:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80170aa:	831a      	strh	r2, [r3, #24]
 80170ac:	e03e      	b.n	801712c <lv_draw_mask_radius+0x390>
        }
        else {
            y = radius - (h - abs_y) + 1;
 80170ae:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80170b2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80170b4:	1ad3      	subs	r3, r2, r3
 80170b6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80170b8:	1ad3      	subs	r3, r2, r3
 80170ba:	3301      	adds	r3, #1
 80170bc:	67bb      	str	r3, [r7, #120]	; 0x78

            /* Get the x intersection points for `abs_y` and `abs_y-1`
             * Use the circle's equation x = sqrt(r^2 - y^2)
             * Try to use the values from the previous run*/
            if((y - 1) == p->y_prev) {
 80170be:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80170c0:	1e5a      	subs	r2, r3, #1
 80170c2:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80170c6:	695b      	ldr	r3, [r3, #20]
 80170c8:	429a      	cmp	r2, r3
 80170ca:	d108      	bne.n	80170de <lv_draw_mask_radius+0x342>
                x1.f = p->y_prev_x.f;
 80170cc:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80170d0:	8b5b      	ldrh	r3, [r3, #26]
 80170d2:	837b      	strh	r3, [r7, #26]
                x1.i = p->y_prev_x.i;
 80170d4:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80170d8:	8b1b      	ldrh	r3, [r3, #24]
 80170da:	833b      	strh	r3, [r7, #24]
 80170dc:	e00e      	b.n	80170fc <lv_draw_mask_radius+0x360>
            }
            else {
                _lv_sqrt(r2 - ((y - 1) * (y - 1)), &x1, sqrt_mask);
 80170de:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80170e0:	3b01      	subs	r3, #1
 80170e2:	6fba      	ldr	r2, [r7, #120]	; 0x78
 80170e4:	3a01      	subs	r2, #1
 80170e6:	fb02 f303 	mul.w	r3, r2, r3
 80170ea:	461a      	mov	r2, r3
 80170ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80170ee:	1a9b      	subs	r3, r3, r2
 80170f0:	f107 0118 	add.w	r1, r7, #24
 80170f4:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 80170f6:	4618      	mov	r0, r3
 80170f8:	f009 fd18 	bl	8020b2c <_lv_sqrt>
            }

            _lv_sqrt(r2 - (y * y), &x0, sqrt_mask);
 80170fc:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80170fe:	fb03 f303 	mul.w	r3, r3, r3
 8017102:	461a      	mov	r2, r3
 8017104:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017106:	1a9b      	subs	r3, r3, r2
 8017108:	f107 011c 	add.w	r1, r7, #28
 801710c:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 801710e:	4618      	mov	r0, r3
 8017110:	f009 fd0c 	bl	8020b2c <_lv_sqrt>
            p->y_prev = y;
 8017114:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8017118:	6fba      	ldr	r2, [r7, #120]	; 0x78
 801711a:	615a      	str	r2, [r3, #20]
            p->y_prev_x.f = x0.f;
 801711c:	8bfa      	ldrh	r2, [r7, #30]
 801711e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8017122:	835a      	strh	r2, [r3, #26]
            p->y_prev_x.i = x0.i;
 8017124:	8bba      	ldrh	r2, [r7, #28]
 8017126:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 801712a:	831a      	strh	r2, [r3, #24]
        }

        /* If x1 is on the next round coordinate (e.g. x0: 3.5, x1:4.0)
         * then treat x1 as x1: 3.99 to handle them as they were on the same pixel*/
        if(x0.i == x1.i - 1 && x1.f == 0) {
 801712c:	8bbb      	ldrh	r3, [r7, #28]
 801712e:	461a      	mov	r2, r3
 8017130:	8b3b      	ldrh	r3, [r7, #24]
 8017132:	3b01      	subs	r3, #1
 8017134:	429a      	cmp	r2, r3
 8017136:	d108      	bne.n	801714a <lv_draw_mask_radius+0x3ae>
 8017138:	8b7b      	ldrh	r3, [r7, #26]
 801713a:	2b00      	cmp	r3, #0
 801713c:	d105      	bne.n	801714a <lv_draw_mask_radius+0x3ae>
            x1.i--;
 801713e:	8b3b      	ldrh	r3, [r7, #24]
 8017140:	3b01      	subs	r3, #1
 8017142:	b29b      	uxth	r3, r3
 8017144:	833b      	strh	r3, [r7, #24]
            x1.f = 0xFF;
 8017146:	23ff      	movs	r3, #255	; 0xff
 8017148:	837b      	strh	r3, [r7, #26]
        }

        /*If the two x intersections are on the same x then just get average of the fractions*/
        if(x0.i == x1.i) {
 801714a:	8bba      	ldrh	r2, [r7, #28]
 801714c:	8b3b      	ldrh	r3, [r7, #24]
 801714e:	429a      	cmp	r2, r3
 8017150:	f040 80a9 	bne.w	80172a6 <lv_draw_mask_radius+0x50a>
            lv_opa_t m = (x0.f + x1.f) >> 1;
 8017154:	8bfb      	ldrh	r3, [r7, #30]
 8017156:	461a      	mov	r2, r3
 8017158:	8b7b      	ldrh	r3, [r7, #26]
 801715a:	4413      	add	r3, r2
 801715c:	105b      	asrs	r3, r3, #1
 801715e:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
            if(outer) m = 255 - m;
 8017162:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 8017166:	2b00      	cmp	r3, #0
 8017168:	d004      	beq.n	8017174 <lv_draw_mask_radius+0x3d8>
 801716a:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 801716e:	43db      	mvns	r3, r3
 8017170:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
            int32_t ofs = radius - x0.i - 1;
 8017174:	8bbb      	ldrh	r3, [r7, #28]
 8017176:	461a      	mov	r2, r3
 8017178:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801717a:	1a9b      	subs	r3, r3, r2
 801717c:	3b01      	subs	r3, #1
 801717e:	63bb      	str	r3, [r7, #56]	; 0x38

            /*Left corner*/
            int32_t kl = k + ofs;
 8017180:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8017182:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8017184:	4413      	add	r3, r2
 8017186:	637b      	str	r3, [r7, #52]	; 0x34

            if(kl >= 0 && kl < len) {
 8017188:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801718a:	2b00      	cmp	r3, #0
 801718c:	db12      	blt.n	80171b4 <lv_draw_mask_radius+0x418>
 801718e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8017192:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8017194:	429a      	cmp	r2, r3
 8017196:	da0d      	bge.n	80171b4 <lv_draw_mask_radius+0x418>
                mask_buf[kl] = mask_mix(mask_buf[kl], m);
 8017198:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801719a:	68fa      	ldr	r2, [r7, #12]
 801719c:	4413      	add	r3, r2
 801719e:	7818      	ldrb	r0, [r3, #0]
 80171a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80171a2:	68fa      	ldr	r2, [r7, #12]
 80171a4:	18d4      	adds	r4, r2, r3
 80171a6:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 80171aa:	4619      	mov	r1, r3
 80171ac:	f000 f9fe 	bl	80175ac <mask_mix>
 80171b0:	4603      	mov	r3, r0
 80171b2:	7023      	strb	r3, [r4, #0]
            }

            /*Right corner*/
            int32_t kr = k + (w - ofs - 1);
 80171b4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80171b6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80171b8:	1ad3      	subs	r3, r2, r3
 80171ba:	3b01      	subs	r3, #1
 80171bc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80171be:	4413      	add	r3, r2
 80171c0:	633b      	str	r3, [r7, #48]	; 0x30
            if(kr >= 0 && kr < len) {
 80171c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80171c4:	2b00      	cmp	r3, #0
 80171c6:	db12      	blt.n	80171ee <lv_draw_mask_radius+0x452>
 80171c8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80171cc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80171ce:	429a      	cmp	r2, r3
 80171d0:	da0d      	bge.n	80171ee <lv_draw_mask_radius+0x452>
                mask_buf[kr] = mask_mix(mask_buf[kr], m);
 80171d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80171d4:	68fa      	ldr	r2, [r7, #12]
 80171d6:	4413      	add	r3, r2
 80171d8:	7818      	ldrb	r0, [r3, #0]
 80171da:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80171dc:	68fa      	ldr	r2, [r7, #12]
 80171de:	18d4      	adds	r4, r2, r3
 80171e0:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 80171e4:	4619      	mov	r1, r3
 80171e6:	f000 f9e1 	bl	80175ac <mask_mix>
 80171ea:	4603      	mov	r3, r0
 80171ec:	7023      	strb	r3, [r4, #0]
            }

            /*Clear the unused parts*/
            if(outer == false) {
 80171ee:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 80171f2:	f083 0301 	eor.w	r3, r3, #1
 80171f6:	b2db      	uxtb	r3, r3
 80171f8:	2b00      	cmp	r3, #0
 80171fa:	d027      	beq.n	801724c <lv_draw_mask_radius+0x4b0>
                kr++;
 80171fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80171fe:	3301      	adds	r3, #1
 8017200:	633b      	str	r3, [r7, #48]	; 0x30
                if(kl > len)  {
 8017202:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8017206:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8017208:	429a      	cmp	r2, r3
 801720a:	dd01      	ble.n	8017210 <lv_draw_mask_radius+0x474>
                    return LV_DRAW_MASK_RES_TRANSP;
 801720c:	2300      	movs	r3, #0
 801720e:	e1c9      	b.n	80175a4 <lv_draw_mask_radius+0x808>
                }
                if(kl >= 0) {
 8017210:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017212:	2b00      	cmp	r3, #0
 8017214:	db04      	blt.n	8017220 <lv_draw_mask_radius+0x484>
                    _lv_memset_00(&mask_buf[0], kl);
 8017216:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017218:	4619      	mov	r1, r3
 801721a:	68f8      	ldr	r0, [r7, #12]
 801721c:	f00a fa44 	bl	80216a8 <_lv_memset_00>
                }
                if(kr < 0) {
 8017220:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017222:	2b00      	cmp	r3, #0
 8017224:	da01      	bge.n	801722a <lv_draw_mask_radius+0x48e>
                    return LV_DRAW_MASK_RES_TRANSP;
 8017226:	2300      	movs	r3, #0
 8017228:	e1bc      	b.n	80175a4 <lv_draw_mask_radius+0x808>
                }
                if(kr <= len) {
 801722a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801722e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8017230:	429a      	cmp	r2, r3
 8017232:	f300 81b6 	bgt.w	80175a2 <lv_draw_mask_radius+0x806>
                    _lv_memset_00(&mask_buf[kr], len - kr);
 8017236:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017238:	68fa      	ldr	r2, [r7, #12]
 801723a:	18d0      	adds	r0, r2, r3
 801723c:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8017240:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8017242:	1ad3      	subs	r3, r2, r3
 8017244:	4619      	mov	r1, r3
 8017246:	f00a fa2f 	bl	80216a8 <_lv_memset_00>
 801724a:	e1aa      	b.n	80175a2 <lv_draw_mask_radius+0x806>
                }
            }
            else {
                kl++;
 801724c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801724e:	3301      	adds	r3, #1
 8017250:	637b      	str	r3, [r7, #52]	; 0x34
                int32_t first = kl;
 8017252:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8017254:	673b      	str	r3, [r7, #112]	; 0x70
                if(first < 0) first = 0;
 8017256:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8017258:	2b00      	cmp	r3, #0
 801725a:	da01      	bge.n	8017260 <lv_draw_mask_radius+0x4c4>
 801725c:	2300      	movs	r3, #0
 801725e:	673b      	str	r3, [r7, #112]	; 0x70

                int32_t len_tmp = kr - first;
 8017260:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8017262:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8017264:	1ad3      	subs	r3, r2, r3
 8017266:	66fb      	str	r3, [r7, #108]	; 0x6c
                if(len_tmp + first > len) len_tmp = len - first;
 8017268:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801726a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801726c:	441a      	add	r2, r3
 801726e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8017272:	429a      	cmp	r2, r3
 8017274:	dd04      	ble.n	8017280 <lv_draw_mask_radius+0x4e4>
 8017276:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801727a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801727c:	1ad3      	subs	r3, r2, r3
 801727e:	66fb      	str	r3, [r7, #108]	; 0x6c
                if(first < len && len_tmp >= 0) {
 8017280:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8017284:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8017286:	429a      	cmp	r2, r3
 8017288:	f280 818b 	bge.w	80175a2 <lv_draw_mask_radius+0x806>
 801728c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801728e:	2b00      	cmp	r3, #0
 8017290:	f2c0 8187 	blt.w	80175a2 <lv_draw_mask_radius+0x806>
                    _lv_memset_00(&mask_buf[first], len_tmp);
 8017294:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8017296:	68fa      	ldr	r2, [r7, #12]
 8017298:	4413      	add	r3, r2
 801729a:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801729c:	4611      	mov	r1, r2
 801729e:	4618      	mov	r0, r3
 80172a0:	f00a fa02 	bl	80216a8 <_lv_memset_00>
 80172a4:	e17d      	b.n	80175a2 <lv_draw_mask_radius+0x806>
                }
            }
        }
        /*Multiple pixels are affected. Get y intersection of the pixels*/
        else {
            int32_t ofs = radius - (x0.i + 1);
 80172a6:	8bbb      	ldrh	r3, [r7, #28]
 80172a8:	3301      	adds	r3, #1
 80172aa:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 80172ac:	1ad3      	subs	r3, r2, r3
 80172ae:	63fb      	str	r3, [r7, #60]	; 0x3c
            int32_t kl = k + ofs;
 80172b0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80172b2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80172b4:	4413      	add	r3, r2
 80172b6:	66bb      	str	r3, [r7, #104]	; 0x68
            int32_t kr = k + (w - ofs - 1);
 80172b8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80172ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80172bc:	1ad3      	subs	r3, r2, r3
 80172be:	3b01      	subs	r3, #1
 80172c0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80172c2:	4413      	add	r3, r2
 80172c4:	667b      	str	r3, [r7, #100]	; 0x64

            if(outer) {
 80172c6:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 80172ca:	2b00      	cmp	r3, #0
 80172cc:	d027      	beq.n	801731e <lv_draw_mask_radius+0x582>
                int32_t first = kl + 1;
 80172ce:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80172d0:	3301      	adds	r3, #1
 80172d2:	663b      	str	r3, [r7, #96]	; 0x60
                if(first < 0) first = 0;
 80172d4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80172d6:	2b00      	cmp	r3, #0
 80172d8:	da01      	bge.n	80172de <lv_draw_mask_radius+0x542>
 80172da:	2300      	movs	r3, #0
 80172dc:	663b      	str	r3, [r7, #96]	; 0x60

                int32_t len_tmp = kr - first;
 80172de:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80172e0:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80172e2:	1ad3      	subs	r3, r2, r3
 80172e4:	65fb      	str	r3, [r7, #92]	; 0x5c
                if(len_tmp + first > len) len_tmp = len - first;
 80172e6:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 80172e8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80172ea:	441a      	add	r2, r3
 80172ec:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80172f0:	429a      	cmp	r2, r3
 80172f2:	dd04      	ble.n	80172fe <lv_draw_mask_radius+0x562>
 80172f4:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 80172f8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80172fa:	1ad3      	subs	r3, r2, r3
 80172fc:	65fb      	str	r3, [r7, #92]	; 0x5c
                if(first < len && len_tmp >= 0) {
 80172fe:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8017302:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8017304:	429a      	cmp	r2, r3
 8017306:	da0a      	bge.n	801731e <lv_draw_mask_radius+0x582>
 8017308:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801730a:	2b00      	cmp	r3, #0
 801730c:	db07      	blt.n	801731e <lv_draw_mask_radius+0x582>
                    _lv_memset_00(&mask_buf[first], len_tmp);
 801730e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8017310:	68fa      	ldr	r2, [r7, #12]
 8017312:	4413      	add	r3, r2
 8017314:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8017316:	4611      	mov	r1, r2
 8017318:	4618      	mov	r0, r3
 801731a:	f00a f9c5 	bl	80216a8 <_lv_memset_00>
                }
            }

            uint32_t i = x0.i + 1;
 801731e:	8bbb      	ldrh	r3, [r7, #28]
 8017320:	3301      	adds	r3, #1
 8017322:	65bb      	str	r3, [r7, #88]	; 0x58
            lv_opa_t m;
            lv_sqrt_res_t y_prev;
            lv_sqrt_res_t y_next;

            _lv_sqrt(r2 - (x0.i * x0.i), &y_prev, sqrt_mask);
 8017324:	8bbb      	ldrh	r3, [r7, #28]
 8017326:	8bba      	ldrh	r2, [r7, #28]
 8017328:	fb02 f303 	mul.w	r3, r2, r3
 801732c:	461a      	mov	r2, r3
 801732e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8017330:	1a9b      	subs	r3, r3, r2
 8017332:	f107 0114 	add.w	r1, r7, #20
 8017336:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8017338:	4618      	mov	r0, r3
 801733a:	f009 fbf7 	bl	8020b2c <_lv_sqrt>

            if(y_prev.f == 0) {
 801733e:	8afb      	ldrh	r3, [r7, #22]
 8017340:	2b00      	cmp	r3, #0
 8017342:	d105      	bne.n	8017350 <lv_draw_mask_radius+0x5b4>
                y_prev.i--;
 8017344:	8abb      	ldrh	r3, [r7, #20]
 8017346:	3b01      	subs	r3, #1
 8017348:	b29b      	uxth	r3, r3
 801734a:	82bb      	strh	r3, [r7, #20]
                y_prev.f = 0xFF;
 801734c:	23ff      	movs	r3, #255	; 0xff
 801734e:	82fb      	strh	r3, [r7, #22]
            }

            /*The first y intersection is special as it might be in the previous line*/
            if(y_prev.i >= y) {
 8017350:	8abb      	ldrh	r3, [r7, #20]
 8017352:	461a      	mov	r2, r3
 8017354:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8017356:	4293      	cmp	r3, r2
 8017358:	f300 80ac 	bgt.w	80174b4 <lv_draw_mask_radius+0x718>
                _lv_sqrt(r2 - (i * i), &y_next, sqrt_mask);
 801735c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801735e:	fb03 f303 	mul.w	r3, r3, r3
 8017362:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8017364:	1ad3      	subs	r3, r2, r3
 8017366:	f107 0110 	add.w	r1, r7, #16
 801736a:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 801736c:	4618      	mov	r0, r3
 801736e:	f009 fbdd 	bl	8020b2c <_lv_sqrt>
                m = 255 - (((255 - x0.f) * (255 - y_next.f)) >> 9);
 8017372:	8bfb      	ldrh	r3, [r7, #30]
 8017374:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8017378:	8a7a      	ldrh	r2, [r7, #18]
 801737a:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
 801737e:	fb02 f303 	mul.w	r3, r2, r3
 8017382:	125b      	asrs	r3, r3, #9
 8017384:	b2db      	uxtb	r3, r3
 8017386:	43db      	mvns	r3, r3
 8017388:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

                if(outer) m = 255 - m;
 801738c:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 8017390:	2b00      	cmp	r3, #0
 8017392:	d004      	beq.n	801739e <lv_draw_mask_radius+0x602>
 8017394:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8017398:	43db      	mvns	r3, r3
 801739a:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
                if(kl >= 0 && kl < len) mask_buf[kl] = mask_mix(mask_buf[kl], m);
 801739e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80173a0:	2b00      	cmp	r3, #0
 80173a2:	db12      	blt.n	80173ca <lv_draw_mask_radius+0x62e>
 80173a4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80173a8:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80173aa:	429a      	cmp	r2, r3
 80173ac:	da0d      	bge.n	80173ca <lv_draw_mask_radius+0x62e>
 80173ae:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80173b0:	68fa      	ldr	r2, [r7, #12]
 80173b2:	4413      	add	r3, r2
 80173b4:	7818      	ldrb	r0, [r3, #0]
 80173b6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80173b8:	68fa      	ldr	r2, [r7, #12]
 80173ba:	18d4      	adds	r4, r2, r3
 80173bc:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80173c0:	4619      	mov	r1, r3
 80173c2:	f000 f8f3 	bl	80175ac <mask_mix>
 80173c6:	4603      	mov	r3, r0
 80173c8:	7023      	strb	r3, [r4, #0]
                if(kr >= 0 && kr < len) mask_buf[kr] = mask_mix(mask_buf[kr], m);
 80173ca:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80173cc:	2b00      	cmp	r3, #0
 80173ce:	db12      	blt.n	80173f6 <lv_draw_mask_radius+0x65a>
 80173d0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80173d4:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 80173d6:	429a      	cmp	r2, r3
 80173d8:	da0d      	bge.n	80173f6 <lv_draw_mask_radius+0x65a>
 80173da:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80173dc:	68fa      	ldr	r2, [r7, #12]
 80173de:	4413      	add	r3, r2
 80173e0:	7818      	ldrb	r0, [r3, #0]
 80173e2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80173e4:	68fa      	ldr	r2, [r7, #12]
 80173e6:	18d4      	adds	r4, r2, r3
 80173e8:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80173ec:	4619      	mov	r1, r3
 80173ee:	f000 f8dd 	bl	80175ac <mask_mix>
 80173f2:	4603      	mov	r3, r0
 80173f4:	7023      	strb	r3, [r4, #0]
                kl--;
 80173f6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80173f8:	3b01      	subs	r3, #1
 80173fa:	66bb      	str	r3, [r7, #104]	; 0x68
                kr++;
 80173fc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80173fe:	3301      	adds	r3, #1
 8017400:	667b      	str	r3, [r7, #100]	; 0x64
                y_prev.f = y_next.f;
 8017402:	8a7b      	ldrh	r3, [r7, #18]
 8017404:	82fb      	strh	r3, [r7, #22]
                i++;
 8017406:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8017408:	3301      	adds	r3, #1
 801740a:	65bb      	str	r3, [r7, #88]	; 0x58
            }

            /*Set all points which are crossed by the circle*/
            for(; i <= x1.i; i++) {
 801740c:	e052      	b.n	80174b4 <lv_draw_mask_radius+0x718>
                /* These values are very close to each other. It's enough to approximate sqrt
                 * The non-approximated version is lv_sqrt(r2 - (i * i), &y_next, sqrt_mask); */
                sqrt_approx(&y_next, &y_prev, r2 - (i * i));
 801740e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8017410:	fb03 f303 	mul.w	r3, r3, r3
 8017414:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8017416:	1ad2      	subs	r2, r2, r3
 8017418:	f107 0114 	add.w	r1, r7, #20
 801741c:	f107 0310 	add.w	r3, r7, #16
 8017420:	4618      	mov	r0, r3
 8017422:	f000 f8e7 	bl	80175f4 <sqrt_approx>

                m = (y_prev.f + y_next.f) >> 1;
 8017426:	8afb      	ldrh	r3, [r7, #22]
 8017428:	461a      	mov	r2, r3
 801742a:	8a7b      	ldrh	r3, [r7, #18]
 801742c:	4413      	add	r3, r2
 801742e:	105b      	asrs	r3, r3, #1
 8017430:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
                if(outer) m = 255 - m;
 8017434:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 8017438:	2b00      	cmp	r3, #0
 801743a:	d004      	beq.n	8017446 <lv_draw_mask_radius+0x6aa>
 801743c:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8017440:	43db      	mvns	r3, r3
 8017442:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
                if(kl >= 0 && kl < len) mask_buf[kl] = mask_mix(mask_buf[kl], m);
 8017446:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017448:	2b00      	cmp	r3, #0
 801744a:	db12      	blt.n	8017472 <lv_draw_mask_radius+0x6d6>
 801744c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8017450:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8017452:	429a      	cmp	r2, r3
 8017454:	da0d      	bge.n	8017472 <lv_draw_mask_radius+0x6d6>
 8017456:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017458:	68fa      	ldr	r2, [r7, #12]
 801745a:	4413      	add	r3, r2
 801745c:	7818      	ldrb	r0, [r3, #0]
 801745e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017460:	68fa      	ldr	r2, [r7, #12]
 8017462:	18d4      	adds	r4, r2, r3
 8017464:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8017468:	4619      	mov	r1, r3
 801746a:	f000 f89f 	bl	80175ac <mask_mix>
 801746e:	4603      	mov	r3, r0
 8017470:	7023      	strb	r3, [r4, #0]
                if(kr >= 0 && kr < len) mask_buf[kr] = mask_mix(mask_buf[kr], m);
 8017472:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017474:	2b00      	cmp	r3, #0
 8017476:	db12      	blt.n	801749e <lv_draw_mask_radius+0x702>
 8017478:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801747c:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801747e:	429a      	cmp	r2, r3
 8017480:	da0d      	bge.n	801749e <lv_draw_mask_radius+0x702>
 8017482:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017484:	68fa      	ldr	r2, [r7, #12]
 8017486:	4413      	add	r3, r2
 8017488:	7818      	ldrb	r0, [r3, #0]
 801748a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801748c:	68fa      	ldr	r2, [r7, #12]
 801748e:	18d4      	adds	r4, r2, r3
 8017490:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8017494:	4619      	mov	r1, r3
 8017496:	f000 f889 	bl	80175ac <mask_mix>
 801749a:	4603      	mov	r3, r0
 801749c:	7023      	strb	r3, [r4, #0]
                kl--;
 801749e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80174a0:	3b01      	subs	r3, #1
 80174a2:	66bb      	str	r3, [r7, #104]	; 0x68
                kr++;
 80174a4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80174a6:	3301      	adds	r3, #1
 80174a8:	667b      	str	r3, [r7, #100]	; 0x64
                y_prev.f = y_next.f;
 80174aa:	8a7b      	ldrh	r3, [r7, #18]
 80174ac:	82fb      	strh	r3, [r7, #22]
            for(; i <= x1.i; i++) {
 80174ae:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80174b0:	3301      	adds	r3, #1
 80174b2:	65bb      	str	r3, [r7, #88]	; 0x58
 80174b4:	8b3b      	ldrh	r3, [r7, #24]
 80174b6:	461a      	mov	r2, r3
 80174b8:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80174ba:	4293      	cmp	r3, r2
 80174bc:	d9a7      	bls.n	801740e <lv_draw_mask_radius+0x672>
            }

            /*If the last pixel was left in its middle therefore
             * the circle still has parts on the next one*/
            if(y_prev.f) {
 80174be:	8afb      	ldrh	r3, [r7, #22]
 80174c0:	2b00      	cmp	r3, #0
 80174c2:	d041      	beq.n	8017548 <lv_draw_mask_radius+0x7ac>
                m = (y_prev.f * x1.f) >> 9;
 80174c4:	8afb      	ldrh	r3, [r7, #22]
 80174c6:	8b7a      	ldrh	r2, [r7, #26]
 80174c8:	fb02 f303 	mul.w	r3, r2, r3
 80174cc:	125b      	asrs	r3, r3, #9
 80174ce:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
                if(outer) m = 255 - m;
 80174d2:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 80174d6:	2b00      	cmp	r3, #0
 80174d8:	d004      	beq.n	80174e4 <lv_draw_mask_radius+0x748>
 80174da:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80174de:	43db      	mvns	r3, r3
 80174e0:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
                if(kl >= 0 && kl < len) mask_buf[kl] = mask_mix(mask_buf[kl], m);
 80174e4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80174e6:	2b00      	cmp	r3, #0
 80174e8:	db12      	blt.n	8017510 <lv_draw_mask_radius+0x774>
 80174ea:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80174ee:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80174f0:	429a      	cmp	r2, r3
 80174f2:	da0d      	bge.n	8017510 <lv_draw_mask_radius+0x774>
 80174f4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80174f6:	68fa      	ldr	r2, [r7, #12]
 80174f8:	4413      	add	r3, r2
 80174fa:	7818      	ldrb	r0, [r3, #0]
 80174fc:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80174fe:	68fa      	ldr	r2, [r7, #12]
 8017500:	18d4      	adds	r4, r2, r3
 8017502:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8017506:	4619      	mov	r1, r3
 8017508:	f000 f850 	bl	80175ac <mask_mix>
 801750c:	4603      	mov	r3, r0
 801750e:	7023      	strb	r3, [r4, #0]
                if(kr >= 0 && kr < len) mask_buf[kr] = mask_mix(mask_buf[kr], m);
 8017510:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017512:	2b00      	cmp	r3, #0
 8017514:	db12      	blt.n	801753c <lv_draw_mask_radius+0x7a0>
 8017516:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801751a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801751c:	429a      	cmp	r2, r3
 801751e:	da0d      	bge.n	801753c <lv_draw_mask_radius+0x7a0>
 8017520:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017522:	68fa      	ldr	r2, [r7, #12]
 8017524:	4413      	add	r3, r2
 8017526:	7818      	ldrb	r0, [r3, #0]
 8017528:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801752a:	68fa      	ldr	r2, [r7, #12]
 801752c:	18d4      	adds	r4, r2, r3
 801752e:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8017532:	4619      	mov	r1, r3
 8017534:	f000 f83a 	bl	80175ac <mask_mix>
 8017538:	4603      	mov	r3, r0
 801753a:	7023      	strb	r3, [r4, #0]
                kl--;
 801753c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801753e:	3b01      	subs	r3, #1
 8017540:	66bb      	str	r3, [r7, #104]	; 0x68
                kr++;
 8017542:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017544:	3301      	adds	r3, #1
 8017546:	667b      	str	r3, [r7, #100]	; 0x64
            }

            if(outer == 0) {
 8017548:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 801754c:	f083 0301 	eor.w	r3, r3, #1
 8017550:	b2db      	uxtb	r3, r3
 8017552:	2b00      	cmp	r3, #0
 8017554:	d025      	beq.n	80175a2 <lv_draw_mask_radius+0x806>
                kl++;
 8017556:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017558:	3301      	adds	r3, #1
 801755a:	66bb      	str	r3, [r7, #104]	; 0x68
                if(kl > len) {
 801755c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8017560:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8017562:	429a      	cmp	r2, r3
 8017564:	dd01      	ble.n	801756a <lv_draw_mask_radius+0x7ce>
                    return LV_DRAW_MASK_RES_TRANSP;
 8017566:	2300      	movs	r3, #0
 8017568:	e01c      	b.n	80175a4 <lv_draw_mask_radius+0x808>
                }
                if(kl >= 0) _lv_memset_00(&mask_buf[0], kl);
 801756a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801756c:	2b00      	cmp	r3, #0
 801756e:	db04      	blt.n	801757a <lv_draw_mask_radius+0x7de>
 8017570:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017572:	4619      	mov	r1, r3
 8017574:	68f8      	ldr	r0, [r7, #12]
 8017576:	f00a f897 	bl	80216a8 <_lv_memset_00>

                if(kr < 0) {
 801757a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801757c:	2b00      	cmp	r3, #0
 801757e:	da01      	bge.n	8017584 <lv_draw_mask_radius+0x7e8>
                    return LV_DRAW_MASK_RES_TRANSP;
 8017580:	2300      	movs	r3, #0
                    return LV_DRAW_MASK_RES_TRANSP;
 8017582:	e00f      	b.n	80175a4 <lv_draw_mask_radius+0x808>
                }
                if(kr < len) _lv_memset_00(&mask_buf[kr], len - kr);
 8017584:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8017588:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801758a:	429a      	cmp	r2, r3
 801758c:	da09      	bge.n	80175a2 <lv_draw_mask_radius+0x806>
 801758e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017590:	68fa      	ldr	r2, [r7, #12]
 8017592:	18d0      	adds	r0, r2, r3
 8017594:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8017598:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801759a:	1ad3      	subs	r3, r2, r3
 801759c:	4619      	mov	r1, r3
 801759e:	f00a f883 	bl	80216a8 <_lv_memset_00>
            }
        }
    }

    return LV_DRAW_MASK_RES_CHANGED;
 80175a2:	2302      	movs	r3, #2
}
 80175a4:	4618      	mov	r0, r3
 80175a6:	378c      	adds	r7, #140	; 0x8c
 80175a8:	46bd      	mov	sp, r7
 80175aa:	bd90      	pop	{r4, r7, pc}

080175ac <mask_mix>:
    return LV_DRAW_MASK_RES_CHANGED;
}


LV_ATTRIBUTE_FAST_MEM static inline lv_opa_t mask_mix(lv_opa_t mask_act, lv_opa_t mask_new)
{
 80175ac:	b480      	push	{r7}
 80175ae:	b083      	sub	sp, #12
 80175b0:	af00      	add	r7, sp, #0
 80175b2:	4603      	mov	r3, r0
 80175b4:	460a      	mov	r2, r1
 80175b6:	71fb      	strb	r3, [r7, #7]
 80175b8:	4613      	mov	r3, r2
 80175ba:	71bb      	strb	r3, [r7, #6]
    if(mask_new >= LV_OPA_MAX) return mask_act;
 80175bc:	79bb      	ldrb	r3, [r7, #6]
 80175be:	2bfc      	cmp	r3, #252	; 0xfc
 80175c0:	d901      	bls.n	80175c6 <mask_mix+0x1a>
 80175c2:	79fb      	ldrb	r3, [r7, #7]
 80175c4:	e010      	b.n	80175e8 <mask_mix+0x3c>
    if(mask_new <= LV_OPA_MIN) return 0;
 80175c6:	79bb      	ldrb	r3, [r7, #6]
 80175c8:	2b02      	cmp	r3, #2
 80175ca:	d801      	bhi.n	80175d0 <mask_mix+0x24>
 80175cc:	2300      	movs	r3, #0
 80175ce:	e00b      	b.n	80175e8 <mask_mix+0x3c>

    return LV_MATH_UDIV255(mask_act * mask_new);// >> 8);
 80175d0:	79fb      	ldrb	r3, [r7, #7]
 80175d2:	79ba      	ldrb	r2, [r7, #6]
 80175d4:	fb02 f303 	mul.w	r3, r2, r3
 80175d8:	461a      	mov	r2, r3
 80175da:	4613      	mov	r3, r2
 80175dc:	021b      	lsls	r3, r3, #8
 80175de:	4413      	add	r3, r2
 80175e0:	01db      	lsls	r3, r3, #7
 80175e2:	4413      	add	r3, r2
 80175e4:	0ddb      	lsrs	r3, r3, #23
 80175e6:	b2db      	uxtb	r3, r3
}
 80175e8:	4618      	mov	r0, r3
 80175ea:	370c      	adds	r7, #12
 80175ec:	46bd      	mov	sp, r7
 80175ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80175f2:	4770      	bx	lr

080175f4 <sqrt_approx>:
 * @param q store the result here
 * @param ref the reference point (already calculated sqrt)
 * @param x the value which sqrt should be approximated
 */
LV_ATTRIBUTE_FAST_MEM static inline void sqrt_approx(lv_sqrt_res_t * q, lv_sqrt_res_t * ref, uint32_t x)
{
 80175f4:	b480      	push	{r7}
 80175f6:	b089      	sub	sp, #36	; 0x24
 80175f8:	af00      	add	r7, sp, #0
 80175fa:	60f8      	str	r0, [r7, #12]
 80175fc:	60b9      	str	r1, [r7, #8]
 80175fe:	607a      	str	r2, [r7, #4]
    x = x << 8; /*Upscale for extra precision*/
 8017600:	687b      	ldr	r3, [r7, #4]
 8017602:	021b      	lsls	r3, r3, #8
 8017604:	607b      	str	r3, [r7, #4]

    uint32_t raw = (ref->i << 4) + (ref->f >> 4);
 8017606:	68bb      	ldr	r3, [r7, #8]
 8017608:	881b      	ldrh	r3, [r3, #0]
 801760a:	011b      	lsls	r3, r3, #4
 801760c:	68ba      	ldr	r2, [r7, #8]
 801760e:	8852      	ldrh	r2, [r2, #2]
 8017610:	0912      	lsrs	r2, r2, #4
 8017612:	b292      	uxth	r2, r2
 8017614:	4413      	add	r3, r2
 8017616:	61fb      	str	r3, [r7, #28]
    uint32_t raw2 = raw * raw;
 8017618:	69fb      	ldr	r3, [r7, #28]
 801761a:	fb03 f303 	mul.w	r3, r3, r3
 801761e:	61bb      	str	r3, [r7, #24]

    int32_t d = x - raw2;
 8017620:	687a      	ldr	r2, [r7, #4]
 8017622:	69bb      	ldr	r3, [r7, #24]
 8017624:	1ad3      	subs	r3, r2, r3
 8017626:	617b      	str	r3, [r7, #20]
    d = (int32_t)d / (int32_t)(2 * raw) + raw;
 8017628:	69fb      	ldr	r3, [r7, #28]
 801762a:	005b      	lsls	r3, r3, #1
 801762c:	461a      	mov	r2, r3
 801762e:	697b      	ldr	r3, [r7, #20]
 8017630:	fb93 f3f2 	sdiv	r3, r3, r2
 8017634:	461a      	mov	r2, r3
 8017636:	69fb      	ldr	r3, [r7, #28]
 8017638:	4413      	add	r3, r2
 801763a:	617b      	str	r3, [r7, #20]

    q->i = d >> 4;
 801763c:	697b      	ldr	r3, [r7, #20]
 801763e:	111b      	asrs	r3, r3, #4
 8017640:	b29a      	uxth	r2, r3
 8017642:	68fb      	ldr	r3, [r7, #12]
 8017644:	801a      	strh	r2, [r3, #0]
    q->f = (d & 0xF) << 4;
 8017646:	697b      	ldr	r3, [r7, #20]
 8017648:	011b      	lsls	r3, r3, #4
 801764a:	b29b      	uxth	r3, r3
 801764c:	b2db      	uxtb	r3, r3
 801764e:	b29a      	uxth	r2, r3
 8017650:	68fb      	ldr	r3, [r7, #12]
 8017652:	805a      	strh	r2, [r3, #2]
}
 8017654:	bf00      	nop
 8017656:	3724      	adds	r7, #36	; 0x24
 8017658:	46bd      	mov	sp, r7
 801765a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801765e:	4770      	bx	lr

08017660 <_lv_memcpy_small>:
 * @param dst pointer to the destination buffer
 * @param src pointer to the source buffer
 * @param len number of byte to copy
 */
LV_ATTRIBUTE_FAST_MEM static inline void * _lv_memcpy_small(void * dst, const void * src, size_t len)
{
 8017660:	b480      	push	{r7}
 8017662:	b087      	sub	sp, #28
 8017664:	af00      	add	r7, sp, #0
 8017666:	60f8      	str	r0, [r7, #12]
 8017668:	60b9      	str	r1, [r7, #8]
 801766a:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 801766c:	68fb      	ldr	r3, [r7, #12]
 801766e:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 8017670:	68bb      	ldr	r3, [r7, #8]
 8017672:	613b      	str	r3, [r7, #16]

    while(len) {
 8017674:	e00c      	b.n	8017690 <_lv_memcpy_small+0x30>
        *d8 = *s8;
 8017676:	693b      	ldr	r3, [r7, #16]
 8017678:	781a      	ldrb	r2, [r3, #0]
 801767a:	697b      	ldr	r3, [r7, #20]
 801767c:	701a      	strb	r2, [r3, #0]
        d8++;
 801767e:	697b      	ldr	r3, [r7, #20]
 8017680:	3301      	adds	r3, #1
 8017682:	617b      	str	r3, [r7, #20]
        s8++;
 8017684:	693b      	ldr	r3, [r7, #16]
 8017686:	3301      	adds	r3, #1
 8017688:	613b      	str	r3, [r7, #16]
        len--;
 801768a:	687b      	ldr	r3, [r7, #4]
 801768c:	3b01      	subs	r3, #1
 801768e:	607b      	str	r3, [r7, #4]
    while(len) {
 8017690:	687b      	ldr	r3, [r7, #4]
 8017692:	2b00      	cmp	r3, #0
 8017694:	d1ef      	bne.n	8017676 <_lv_memcpy_small+0x16>
    }

    return dst;
 8017696:	68fb      	ldr	r3, [r7, #12]
}
 8017698:	4618      	mov	r0, r3
 801769a:	371c      	adds	r7, #28
 801769c:	46bd      	mov	sp, r7
 801769e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80176a2:	4770      	bx	lr

080176a4 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 80176a4:	b580      	push	{r7, lr}
 80176a6:	b082      	sub	sp, #8
 80176a8:	af00      	add	r7, sp, #0
 80176aa:	6078      	str	r0, [r7, #4]
 80176ac:	6039      	str	r1, [r7, #0]
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
 80176ae:	2208      	movs	r2, #8
 80176b0:	6839      	ldr	r1, [r7, #0]
 80176b2:	6878      	ldr	r0, [r7, #4]
 80176b4:	f7ff ffd4 	bl	8017660 <_lv_memcpy_small>
}
 80176b8:	bf00      	nop
 80176ba:	3708      	adds	r7, #8
 80176bc:	46bd      	mov	sp, r7
 80176be:	bd80      	pop	{r7, pc}

080176c0 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 80176c0:	b480      	push	{r7}
 80176c2:	b083      	sub	sp, #12
 80176c4:	af00      	add	r7, sp, #0
 80176c6:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 80176c8:	687b      	ldr	r3, [r7, #4]
 80176ca:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80176ce:	b29a      	uxth	r2, r3
 80176d0:	687b      	ldr	r3, [r7, #4]
 80176d2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80176d6:	b29b      	uxth	r3, r3
 80176d8:	1ad3      	subs	r3, r2, r3
 80176da:	b29b      	uxth	r3, r3
 80176dc:	3301      	adds	r3, #1
 80176de:	b29b      	uxth	r3, r3
 80176e0:	b21b      	sxth	r3, r3
}
 80176e2:	4618      	mov	r0, r3
 80176e4:	370c      	adds	r7, #12
 80176e6:	46bd      	mov	sp, r7
 80176e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80176ec:	4770      	bx	lr

080176ee <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 80176ee:	b480      	push	{r7}
 80176f0:	b083      	sub	sp, #12
 80176f2:	af00      	add	r7, sp, #0
 80176f4:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 80176f6:	687b      	ldr	r3, [r7, #4]
 80176f8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80176fc:	b29a      	uxth	r2, r3
 80176fe:	687b      	ldr	r3, [r7, #4]
 8017700:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017704:	b29b      	uxth	r3, r3
 8017706:	1ad3      	subs	r3, r2, r3
 8017708:	b29b      	uxth	r3, r3
 801770a:	3301      	adds	r3, #1
 801770c:	b29b      	uxth	r3, r3
 801770e:	b21b      	sxth	r3, r3
}
 8017710:	4618      	mov	r0, r3
 8017712:	370c      	adds	r7, #12
 8017714:	46bd      	mov	sp, r7
 8017716:	f85d 7b04 	ldr.w	r7, [sp], #4
 801771a:	4770      	bx	lr

0801771c <lv_color_mix>:
{
 801771c:	b480      	push	{r7}
 801771e:	b085      	sub	sp, #20
 8017720:	af00      	add	r7, sp, #0
 8017722:	80b8      	strh	r0, [r7, #4]
 8017724:	8039      	strh	r1, [r7, #0]
 8017726:	4613      	mov	r3, r2
 8017728:	70fb      	strb	r3, [r7, #3]
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
 801772a:	797b      	ldrb	r3, [r7, #5]
 801772c:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8017730:	b2db      	uxtb	r3, r3
 8017732:	461a      	mov	r2, r3
 8017734:	78fb      	ldrb	r3, [r7, #3]
 8017736:	fb03 f202 	mul.w	r2, r3, r2
 801773a:	787b      	ldrb	r3, [r7, #1]
 801773c:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8017740:	b2db      	uxtb	r3, r3
 8017742:	4619      	mov	r1, r3
 8017744:	78fb      	ldrb	r3, [r7, #3]
 8017746:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801774a:	fb01 f303 	mul.w	r3, r1, r3
 801774e:	4413      	add	r3, r2
 8017750:	3380      	adds	r3, #128	; 0x80
 8017752:	461a      	mov	r2, r3
 8017754:	4613      	mov	r3, r2
 8017756:	021b      	lsls	r3, r3, #8
 8017758:	4413      	add	r3, r2
 801775a:	01db      	lsls	r3, r3, #7
 801775c:	4413      	add	r3, r2
 801775e:	0ddb      	lsrs	r3, r3, #23
 8017760:	f003 031f 	and.w	r3, r3, #31
 8017764:	b2da      	uxtb	r2, r3
 8017766:	7b7b      	ldrb	r3, [r7, #13]
 8017768:	f362 03c7 	bfi	r3, r2, #3, #5
 801776c:	737b      	strb	r3, [r7, #13]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
 801776e:	88bb      	ldrh	r3, [r7, #4]
 8017770:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8017774:	b2db      	uxtb	r3, r3
 8017776:	461a      	mov	r2, r3
 8017778:	78fb      	ldrb	r3, [r7, #3]
 801777a:	fb03 f202 	mul.w	r2, r3, r2
 801777e:	883b      	ldrh	r3, [r7, #0]
 8017780:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8017784:	b2db      	uxtb	r3, r3
 8017786:	4619      	mov	r1, r3
 8017788:	78fb      	ldrb	r3, [r7, #3]
 801778a:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801778e:	fb01 f303 	mul.w	r3, r1, r3
 8017792:	4413      	add	r3, r2
 8017794:	3380      	adds	r3, #128	; 0x80
 8017796:	461a      	mov	r2, r3
 8017798:	4613      	mov	r3, r2
 801779a:	021b      	lsls	r3, r3, #8
 801779c:	4413      	add	r3, r2
 801779e:	01db      	lsls	r3, r3, #7
 80177a0:	4413      	add	r3, r2
 80177a2:	0ddb      	lsrs	r3, r3, #23
 80177a4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80177a8:	b2da      	uxtb	r2, r3
 80177aa:	89bb      	ldrh	r3, [r7, #12]
 80177ac:	f362 134a 	bfi	r3, r2, #5, #6
 80177b0:	81bb      	strh	r3, [r7, #12]
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
 80177b2:	793b      	ldrb	r3, [r7, #4]
 80177b4:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80177b8:	b2db      	uxtb	r3, r3
 80177ba:	461a      	mov	r2, r3
 80177bc:	78fb      	ldrb	r3, [r7, #3]
 80177be:	fb03 f202 	mul.w	r2, r3, r2
 80177c2:	783b      	ldrb	r3, [r7, #0]
 80177c4:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80177c8:	b2db      	uxtb	r3, r3
 80177ca:	4619      	mov	r1, r3
 80177cc:	78fb      	ldrb	r3, [r7, #3]
 80177ce:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80177d2:	fb01 f303 	mul.w	r3, r1, r3
 80177d6:	4413      	add	r3, r2
 80177d8:	3380      	adds	r3, #128	; 0x80
 80177da:	461a      	mov	r2, r3
 80177dc:	4613      	mov	r3, r2
 80177de:	021b      	lsls	r3, r3, #8
 80177e0:	4413      	add	r3, r2
 80177e2:	01db      	lsls	r3, r3, #7
 80177e4:	4413      	add	r3, r2
 80177e6:	0ddb      	lsrs	r3, r3, #23
 80177e8:	f003 031f 	and.w	r3, r3, #31
 80177ec:	b2da      	uxtb	r2, r3
 80177ee:	7b3b      	ldrb	r3, [r7, #12]
 80177f0:	f362 0304 	bfi	r3, r2, #0, #5
 80177f4:	733b      	strb	r3, [r7, #12]
    return ret;
 80177f6:	89bb      	ldrh	r3, [r7, #12]
}
 80177f8:	4618      	mov	r0, r3
 80177fa:	3714      	adds	r7, #20
 80177fc:	46bd      	mov	sp, r7
 80177fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017802:	4770      	bx	lr

08017804 <lv_draw_rect_dsc_init>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

LV_ATTRIBUTE_FAST_MEM void lv_draw_rect_dsc_init(lv_draw_rect_dsc_t * dsc)
{
 8017804:	b580      	push	{r7, lr}
 8017806:	b082      	sub	sp, #8
 8017808:	af00      	add	r7, sp, #0
 801780a:	6078      	str	r0, [r7, #4]
    _lv_memset_00(dsc, sizeof(lv_draw_rect_dsc_t));
 801780c:	2154      	movs	r1, #84	; 0x54
 801780e:	6878      	ldr	r0, [r7, #4]
 8017810:	f009 ff4a 	bl	80216a8 <_lv_memset_00>
    dsc->bg_color = LV_COLOR_WHITE;
 8017814:	687b      	ldr	r3, [r7, #4]
 8017816:	4a40      	ldr	r2, [pc, #256]	; (8017918 <lv_draw_rect_dsc_init+0x114>)
 8017818:	8812      	ldrh	r2, [r2, #0]
 801781a:	805a      	strh	r2, [r3, #2]
    dsc->bg_grad_color = LV_COLOR_BLACK;
 801781c:	687a      	ldr	r2, [r7, #4]
 801781e:	7913      	ldrb	r3, [r2, #4]
 8017820:	f36f 0304 	bfc	r3, #0, #5
 8017824:	7113      	strb	r3, [r2, #4]
 8017826:	687a      	ldr	r2, [r7, #4]
 8017828:	8893      	ldrh	r3, [r2, #4]
 801782a:	f36f 134a 	bfc	r3, #5, #6
 801782e:	8093      	strh	r3, [r2, #4]
 8017830:	687a      	ldr	r2, [r7, #4]
 8017832:	7953      	ldrb	r3, [r2, #5]
 8017834:	f36f 03c7 	bfc	r3, #3, #5
 8017838:	7153      	strb	r3, [r2, #5]
    dsc->border_color = LV_COLOR_BLACK;
 801783a:	687a      	ldr	r2, [r7, #4]
 801783c:	7b93      	ldrb	r3, [r2, #14]
 801783e:	f36f 0304 	bfc	r3, #0, #5
 8017842:	7393      	strb	r3, [r2, #14]
 8017844:	687a      	ldr	r2, [r7, #4]
 8017846:	89d3      	ldrh	r3, [r2, #14]
 8017848:	f36f 134a 	bfc	r3, #5, #6
 801784c:	81d3      	strh	r3, [r2, #14]
 801784e:	687a      	ldr	r2, [r7, #4]
 8017850:	7bd3      	ldrb	r3, [r2, #15]
 8017852:	f36f 03c7 	bfc	r3, #3, #5
 8017856:	73d3      	strb	r3, [r2, #15]
    dsc->pattern_recolor = LV_COLOR_BLACK;
 8017858:	687a      	ldr	r2, [r7, #4]
 801785a:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 801785e:	f36f 0304 	bfc	r3, #0, #5
 8017862:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
 8017866:	687a      	ldr	r2, [r7, #4]
 8017868:	8e93      	ldrh	r3, [r2, #52]	; 0x34
 801786a:	f36f 134a 	bfc	r3, #5, #6
 801786e:	8693      	strh	r3, [r2, #52]	; 0x34
 8017870:	687a      	ldr	r2, [r7, #4]
 8017872:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 8017876:	f36f 03c7 	bfc	r3, #3, #5
 801787a:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35
    dsc->value_color = LV_COLOR_BLACK;
 801787e:	687a      	ldr	r2, [r7, #4]
 8017880:	f892 3046 	ldrb.w	r3, [r2, #70]	; 0x46
 8017884:	f36f 0304 	bfc	r3, #0, #5
 8017888:	f882 3046 	strb.w	r3, [r2, #70]	; 0x46
 801788c:	687a      	ldr	r2, [r7, #4]
 801788e:	f8b2 3046 	ldrh.w	r3, [r2, #70]	; 0x46
 8017892:	f36f 134a 	bfc	r3, #5, #6
 8017896:	f8a2 3046 	strh.w	r3, [r2, #70]	; 0x46
 801789a:	687a      	ldr	r2, [r7, #4]
 801789c:	f892 3047 	ldrb.w	r3, [r2, #71]	; 0x47
 80178a0:	f36f 03c7 	bfc	r3, #3, #5
 80178a4:	f882 3047 	strb.w	r3, [r2, #71]	; 0x47
    dsc->shadow_color = LV_COLOR_BLACK;
 80178a8:	687a      	ldr	r2, [r7, #4]
 80178aa:	f892 3020 	ldrb.w	r3, [r2, #32]
 80178ae:	f36f 0304 	bfc	r3, #0, #5
 80178b2:	f882 3020 	strb.w	r3, [r2, #32]
 80178b6:	687a      	ldr	r2, [r7, #4]
 80178b8:	8c13      	ldrh	r3, [r2, #32]
 80178ba:	f36f 134a 	bfc	r3, #5, #6
 80178be:	8413      	strh	r3, [r2, #32]
 80178c0:	687a      	ldr	r2, [r7, #4]
 80178c2:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 80178c6:	f36f 03c7 	bfc	r3, #3, #5
 80178ca:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
    dsc->bg_grad_color_stop = 0xFF;
 80178ce:	687b      	ldr	r3, [r7, #4]
 80178d0:	22ff      	movs	r2, #255	; 0xff
 80178d2:	815a      	strh	r2, [r3, #10]
    dsc->bg_opa = LV_OPA_COVER;
 80178d4:	687b      	ldr	r3, [r7, #4]
 80178d6:	22ff      	movs	r2, #255	; 0xff
 80178d8:	731a      	strb	r2, [r3, #12]
    dsc->outline_opa = LV_OPA_COVER;
 80178da:	687b      	ldr	r3, [r7, #4]
 80178dc:	22ff      	movs	r2, #255	; 0xff
 80178de:	779a      	strb	r2, [r3, #30]
    dsc->border_opa = LV_OPA_COVER;
 80178e0:	687b      	ldr	r3, [r7, #4]
 80178e2:	22ff      	movs	r2, #255	; 0xff
 80178e4:	751a      	strb	r2, [r3, #20]
    dsc->pattern_opa = LV_OPA_COVER;
 80178e6:	687b      	ldr	r3, [r7, #4]
 80178e8:	22ff      	movs	r2, #255	; 0xff
 80178ea:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
    dsc->pattern_font = LV_THEME_DEFAULT_FONT_NORMAL;
 80178ee:	687b      	ldr	r3, [r7, #4]
 80178f0:	4a0a      	ldr	r2, [pc, #40]	; (801791c <lv_draw_rect_dsc_init+0x118>)
 80178f2:	631a      	str	r2, [r3, #48]	; 0x30
    dsc->value_opa = LV_OPA_COVER;
 80178f4:	687b      	ldr	r3, [r7, #4]
 80178f6:	22ff      	movs	r2, #255	; 0xff
 80178f8:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    dsc->value_font = LV_THEME_DEFAULT_FONT_NORMAL;
 80178fc:	687b      	ldr	r3, [r7, #4]
 80178fe:	4a07      	ldr	r2, [pc, #28]	; (801791c <lv_draw_rect_dsc_init+0x118>)
 8017900:	641a      	str	r2, [r3, #64]	; 0x40
    dsc->shadow_opa = LV_OPA_COVER;
 8017902:	687b      	ldr	r3, [r7, #4]
 8017904:	22ff      	movs	r2, #255	; 0xff
 8017906:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
    dsc->border_side = LV_BORDER_SIDE_FULL;
 801790a:	687b      	ldr	r3, [r7, #4]
 801790c:	220f      	movs	r2, #15
 801790e:	825a      	strh	r2, [r3, #18]

}
 8017910:	bf00      	nop
 8017912:	3708      	adds	r7, #8
 8017914:	46bd      	mov	sp, r7
 8017916:	bd80      	pop	{r7, pc}
 8017918:	0802e464 	.word	0x0802e464
 801791c:	200001a8 	.word	0x200001a8

08017920 <lv_draw_rect>:
 * @param coords the coordinates of the rectangle
 * @param mask the rectangle will be drawn only in this mask
 * @param dsc pointer to an initialized `lv_draw_rect_dsc_t` variable
 */
void lv_draw_rect(const lv_area_t * coords, const lv_area_t * clip, const lv_draw_rect_dsc_t * dsc)
{
 8017920:	b580      	push	{r7, lr}
 8017922:	b084      	sub	sp, #16
 8017924:	af00      	add	r7, sp, #0
 8017926:	60f8      	str	r0, [r7, #12]
 8017928:	60b9      	str	r1, [r7, #8]
 801792a:	607a      	str	r2, [r7, #4]
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
 801792c:	68f8      	ldr	r0, [r7, #12]
 801792e:	f7ff fede 	bl	80176ee <lv_area_get_height>
 8017932:	4603      	mov	r3, r0
 8017934:	2b00      	cmp	r3, #0
 8017936:	dd24      	ble.n	8017982 <lv_draw_rect+0x62>
 8017938:	68f8      	ldr	r0, [r7, #12]
 801793a:	f7ff fec1 	bl	80176c0 <lv_area_get_width>
 801793e:	4603      	mov	r3, r0
 8017940:	2b00      	cmp	r3, #0
 8017942:	dd1e      	ble.n	8017982 <lv_draw_rect+0x62>
#if LV_USE_SHADOW
    draw_shadow(coords, clip, dsc);
 8017944:	687a      	ldr	r2, [r7, #4]
 8017946:	68b9      	ldr	r1, [r7, #8]
 8017948:	68f8      	ldr	r0, [r7, #12]
 801794a:	f000 ff0b 	bl	8018764 <draw_shadow>
#endif

    draw_bg(coords, clip, dsc);
 801794e:	687a      	ldr	r2, [r7, #4]
 8017950:	68b9      	ldr	r1, [r7, #8]
 8017952:	68f8      	ldr	r0, [r7, #12]
 8017954:	f000 f819 	bl	801798a <draw_bg>

#if LV_USE_PATTERN
    draw_pattern(coords, clip, dsc);
 8017958:	687a      	ldr	r2, [r7, #4]
 801795a:	68b9      	ldr	r1, [r7, #8]
 801795c:	68f8      	ldr	r0, [r7, #12]
 801795e:	f002 fea8 	bl	801a6b2 <draw_pattern>
#endif
    draw_border(coords, clip, dsc);
 8017962:	687a      	ldr	r2, [r7, #4]
 8017964:	68b9      	ldr	r1, [r7, #8]
 8017966:	68f8      	ldr	r0, [r7, #12]
 8017968:	f000 fbf4 	bl	8018154 <draw_border>

#if LV_USE_VALUE_STR
    draw_value_str(coords, clip, dsc);
 801796c:	687a      	ldr	r2, [r7, #4]
 801796e:	68b9      	ldr	r1, [r7, #8]
 8017970:	68f8      	ldr	r0, [r7, #12]
 8017972:	f003 f8b8 	bl	801aae6 <draw_value_str>
#endif

#if LV_USE_OUTLINE
    draw_outline(coords, clip, dsc);
 8017976:	687a      	ldr	r2, [r7, #4]
 8017978:	68b9      	ldr	r1, [r7, #8]
 801797a:	68f8      	ldr	r0, [r7, #12]
 801797c:	f002 fdfb 	bl	801a576 <draw_outline>
 8017980:	e000      	b.n	8017984 <lv_draw_rect+0x64>
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
 8017982:	bf00      	nop
#endif

    LV_ASSERT_MEM_INTEGRITY();
}
 8017984:	3710      	adds	r7, #16
 8017986:	46bd      	mov	sp, r7
 8017988:	bd80      	pop	{r7, pc}

0801798a <draw_bg>:
 *   STATIC FUNCTIONS
 **********************/

LV_ATTRIBUTE_FAST_MEM static void draw_bg(const lv_area_t * coords, const lv_area_t * clip,
                                          const lv_draw_rect_dsc_t * dsc)
{
 801798a:	b590      	push	{r4, r7, lr}
 801798c:	b0ad      	sub	sp, #180	; 0xb4
 801798e:	af04      	add	r7, sp, #16
 8017990:	60f8      	str	r0, [r7, #12]
 8017992:	60b9      	str	r1, [r7, #8]
 8017994:	607a      	str	r2, [r7, #4]
    if(dsc->bg_opa <= LV_OPA_MIN) return;
 8017996:	687b      	ldr	r3, [r7, #4]
 8017998:	7b1b      	ldrb	r3, [r3, #12]
 801799a:	2b02      	cmp	r3, #2
 801799c:	f240 83d4 	bls.w	8018148 <draw_bg+0x7be>

    lv_area_t coords_bg;
    lv_area_copy(&coords_bg, coords);
 80179a0:	f107 0348 	add.w	r3, r7, #72	; 0x48
 80179a4:	68f9      	ldr	r1, [r7, #12]
 80179a6:	4618      	mov	r0, r3
 80179a8:	f7ff fe7c 	bl	80176a4 <lv_area_copy>

    /*If the border fully covers make the bg area 1px smaller to avoid artifacts on the corners*/
    if(dsc->border_width > 1 && dsc->border_opa >= LV_OPA_MAX && dsc->radius != 0) {
 80179ac:	687b      	ldr	r3, [r7, #4]
 80179ae:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80179b2:	2b01      	cmp	r3, #1
 80179b4:	dd4a      	ble.n	8017a4c <draw_bg+0xc2>
 80179b6:	687b      	ldr	r3, [r7, #4]
 80179b8:	7d1b      	ldrb	r3, [r3, #20]
 80179ba:	2bfc      	cmp	r3, #252	; 0xfc
 80179bc:	d946      	bls.n	8017a4c <draw_bg+0xc2>
 80179be:	687b      	ldr	r3, [r7, #4]
 80179c0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80179c4:	2b00      	cmp	r3, #0
 80179c6:	d041      	beq.n	8017a4c <draw_bg+0xc2>
        coords_bg.x1 += (dsc->border_side & LV_BORDER_SIDE_LEFT) ? 1 : 0;
 80179c8:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 80179cc:	b29a      	uxth	r2, r3
 80179ce:	687b      	ldr	r3, [r7, #4]
 80179d0:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80179d4:	b29b      	uxth	r3, r3
 80179d6:	109b      	asrs	r3, r3, #2
 80179d8:	b29b      	uxth	r3, r3
 80179da:	f003 0301 	and.w	r3, r3, #1
 80179de:	b29b      	uxth	r3, r3
 80179e0:	4413      	add	r3, r2
 80179e2:	b29b      	uxth	r3, r3
 80179e4:	b21b      	sxth	r3, r3
 80179e6:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
        coords_bg.y1 += (dsc->border_side & LV_BORDER_SIDE_TOP) ? 1 : 0;
 80179ea:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 80179ee:	b29a      	uxth	r2, r3
 80179f0:	687b      	ldr	r3, [r7, #4]
 80179f2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80179f6:	b29b      	uxth	r3, r3
 80179f8:	105b      	asrs	r3, r3, #1
 80179fa:	b29b      	uxth	r3, r3
 80179fc:	f003 0301 	and.w	r3, r3, #1
 8017a00:	b29b      	uxth	r3, r3
 8017a02:	4413      	add	r3, r2
 8017a04:	b29b      	uxth	r3, r3
 8017a06:	b21b      	sxth	r3, r3
 8017a08:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
        coords_bg.x2 -= (dsc->border_side & LV_BORDER_SIDE_RIGHT) ? 1 : 0;
 8017a0c:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8017a10:	b29a      	uxth	r2, r3
 8017a12:	687b      	ldr	r3, [r7, #4]
 8017a14:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8017a18:	b29b      	uxth	r3, r3
 8017a1a:	10db      	asrs	r3, r3, #3
 8017a1c:	b29b      	uxth	r3, r3
 8017a1e:	f003 0301 	and.w	r3, r3, #1
 8017a22:	b29b      	uxth	r3, r3
 8017a24:	1ad3      	subs	r3, r2, r3
 8017a26:	b29b      	uxth	r3, r3
 8017a28:	b21b      	sxth	r3, r3
 8017a2a:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
        coords_bg.y2 -= (dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? 1 : 0;
 8017a2e:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8017a32:	b29a      	uxth	r2, r3
 8017a34:	687b      	ldr	r3, [r7, #4]
 8017a36:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8017a3a:	b29b      	uxth	r3, r3
 8017a3c:	f003 0301 	and.w	r3, r3, #1
 8017a40:	b29b      	uxth	r3, r3
 8017a42:	1ad3      	subs	r3, r2, r3
 8017a44:	b29b      	uxth	r3, r3
 8017a46:	b21b      	sxth	r3, r3
 8017a48:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    }

    lv_opa_t opa = dsc->bg_opa;
 8017a4c:	687b      	ldr	r3, [r7, #4]
 8017a4e:	7b1b      	ldrb	r3, [r3, #12]
 8017a50:	f887 309f 	strb.w	r3, [r7, #159]	; 0x9f

    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 8017a54:	f897 309f 	ldrb.w	r3, [r7, #159]	; 0x9f
 8017a58:	2bfd      	cmp	r3, #253	; 0xfd
 8017a5a:	d902      	bls.n	8017a62 <draw_bg+0xd8>
 8017a5c:	23ff      	movs	r3, #255	; 0xff
 8017a5e:	f887 309f 	strb.w	r3, [r7, #159]	; 0x9f

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
 8017a62:	f7f6 fcbd 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 8017a66:	67b8      	str	r0, [r7, #120]	; 0x78
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8017a68:	6fb8      	ldr	r0, [r7, #120]	; 0x78
 8017a6a:	f007 f8cf 	bl	801ec0c <lv_disp_get_buf>
 8017a6e:	6778      	str	r0, [r7, #116]	; 0x74

    /* Get clipped fill area which is the real draw area.
     * It is always the same or inside `fill_area` */
    lv_area_t draw_area;
    bool is_common;
    is_common = _lv_area_intersect(&draw_area, &coords_bg, clip);
 8017a70:	f107 0148 	add.w	r1, r7, #72	; 0x48
 8017a74:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8017a78:	68ba      	ldr	r2, [r7, #8]
 8017a7a:	4618      	mov	r0, r3
 8017a7c:	f007 fcf6 	bl	801f46c <_lv_area_intersect>
 8017a80:	4603      	mov	r3, r0
 8017a82:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
    if(is_common == false) return;
 8017a86:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 8017a8a:	f083 0301 	eor.w	r3, r3, #1
 8017a8e:	b2db      	uxtb	r3, r3
 8017a90:	2b00      	cmp	r3, #0
 8017a92:	f040 835b 	bne.w	801814c <draw_bg+0x7c2>

    const lv_area_t * disp_area = &vdb->area;
 8017a96:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8017a98:	3310      	adds	r3, #16
 8017a9a:	66fb      	str	r3, [r7, #108]	; 0x6c

    /* Now `draw_area` has absolute coordinates.
     * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
    draw_area.x1 -= disp_area->x1;
 8017a9c:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8017aa0:	b29a      	uxth	r2, r3
 8017aa2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017aa4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017aa8:	b29b      	uxth	r3, r3
 8017aaa:	1ad3      	subs	r3, r2, r3
 8017aac:	b29b      	uxth	r3, r3
 8017aae:	b21b      	sxth	r3, r3
 8017ab0:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
    draw_area.y1 -= disp_area->y1;
 8017ab4:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8017ab8:	b29a      	uxth	r2, r3
 8017aba:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017abc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017ac0:	b29b      	uxth	r3, r3
 8017ac2:	1ad3      	subs	r3, r2, r3
 8017ac4:	b29b      	uxth	r3, r3
 8017ac6:	b21b      	sxth	r3, r3
 8017ac8:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
    draw_area.x2 -= disp_area->x1;
 8017acc:	f9b7 3044 	ldrsh.w	r3, [r7, #68]	; 0x44
 8017ad0:	b29a      	uxth	r2, r3
 8017ad2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017ad4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017ad8:	b29b      	uxth	r3, r3
 8017ada:	1ad3      	subs	r3, r2, r3
 8017adc:	b29b      	uxth	r3, r3
 8017ade:	b21b      	sxth	r3, r3
 8017ae0:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
    draw_area.y2 -= disp_area->y1;
 8017ae4:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8017ae8:	b29a      	uxth	r2, r3
 8017aea:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017aec:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017af0:	b29b      	uxth	r3, r3
 8017af2:	1ad3      	subs	r3, r2, r3
 8017af4:	b29b      	uxth	r3, r3
 8017af6:	b21b      	sxth	r3, r3
 8017af8:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46

    int32_t draw_area_w = lv_area_get_width(&draw_area);
 8017afc:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8017b00:	4618      	mov	r0, r3
 8017b02:	f7ff fddd 	bl	80176c0 <lv_area_get_width>
 8017b06:	4603      	mov	r3, r0
 8017b08:	66bb      	str	r3, [r7, #104]	; 0x68

    /*Create a mask if there is a radius*/
    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
 8017b0a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017b0c:	4618      	mov	r0, r3
 8017b0e:	f009 f9bf 	bl	8020e90 <_lv_mem_buf_get>
 8017b12:	6678      	str	r0, [r7, #100]	; 0x64

    lv_grad_dir_t grad_dir = dsc->bg_grad_dir;
 8017b14:	687b      	ldr	r3, [r7, #4]
 8017b16:	799b      	ldrb	r3, [r3, #6]
 8017b18:	f887 309e 	strb.w	r3, [r7, #158]	; 0x9e
    if(dsc->bg_color.full == dsc->bg_grad_color.full) grad_dir = LV_GRAD_DIR_NONE;
 8017b1c:	687b      	ldr	r3, [r7, #4]
 8017b1e:	885a      	ldrh	r2, [r3, #2]
 8017b20:	687b      	ldr	r3, [r7, #4]
 8017b22:	889b      	ldrh	r3, [r3, #4]
 8017b24:	429a      	cmp	r2, r3
 8017b26:	d102      	bne.n	8017b2e <draw_bg+0x1a4>
 8017b28:	2300      	movs	r3, #0
 8017b2a:	f887 309e 	strb.w	r3, [r7, #158]	; 0x9e

    uint16_t other_mask_cnt = lv_draw_mask_get_cnt();
 8017b2e:	f7fe fadd 	bl	80160ec <lv_draw_mask_get_cnt>
 8017b32:	4603      	mov	r3, r0
 8017b34:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
    bool simple_mode = true;
 8017b38:	2301      	movs	r3, #1
 8017b3a:	f887 309d 	strb.w	r3, [r7, #157]	; 0x9d
    if(other_mask_cnt) simple_mode = false;
 8017b3e:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8017b42:	2b00      	cmp	r3, #0
 8017b44:	d003      	beq.n	8017b4e <draw_bg+0x1c4>
 8017b46:	2300      	movs	r3, #0
 8017b48:	f887 309d 	strb.w	r3, [r7, #157]	; 0x9d
 8017b4c:	e006      	b.n	8017b5c <draw_bg+0x1d2>
    else if(grad_dir == LV_GRAD_DIR_HOR) simple_mode = false;
 8017b4e:	f897 309e 	ldrb.w	r3, [r7, #158]	; 0x9e
 8017b52:	2b02      	cmp	r3, #2
 8017b54:	d102      	bne.n	8017b5c <draw_bg+0x1d2>
 8017b56:	2300      	movs	r3, #0
 8017b58:	f887 309d 	strb.w	r3, [r7, #157]	; 0x9d

    int16_t mask_rout_id = LV_MASK_ID_INV;
 8017b5c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8017b60:	f8a7 309a 	strh.w	r3, [r7, #154]	; 0x9a

    int32_t coords_w = lv_area_get_width(&coords_bg);
 8017b64:	f107 0348 	add.w	r3, r7, #72	; 0x48
 8017b68:	4618      	mov	r0, r3
 8017b6a:	f7ff fda9 	bl	80176c0 <lv_area_get_width>
 8017b6e:	4603      	mov	r3, r0
 8017b70:	65fb      	str	r3, [r7, #92]	; 0x5c
    int32_t coords_h = lv_area_get_height(&coords_bg);
 8017b72:	f107 0348 	add.w	r3, r7, #72	; 0x48
 8017b76:	4618      	mov	r0, r3
 8017b78:	f7ff fdb9 	bl	80176ee <lv_area_get_height>
 8017b7c:	4603      	mov	r3, r0
 8017b7e:	65bb      	str	r3, [r7, #88]	; 0x58

    /*Get the real radius*/
    int32_t rout = dsc->radius;
 8017b80:	687b      	ldr	r3, [r7, #4]
 8017b82:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017b86:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    int32_t short_side = LV_MATH_MIN(coords_w, coords_h);
 8017b8a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8017b8c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8017b8e:	4293      	cmp	r3, r2
 8017b90:	bfa8      	it	ge
 8017b92:	4613      	movge	r3, r2
 8017b94:	657b      	str	r3, [r7, #84]	; 0x54
    if(rout > short_side >> 1) rout = short_side >> 1;
 8017b96:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8017b98:	105b      	asrs	r3, r3, #1
 8017b9a:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8017b9e:	429a      	cmp	r2, r3
 8017ba0:	dd03      	ble.n	8017baa <draw_bg+0x220>
 8017ba2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8017ba4:	105b      	asrs	r3, r3, #1
 8017ba6:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

    /*Most simple case: just a plain rectangle*/
    if(simple_mode && rout == 0 && (grad_dir == LV_GRAD_DIR_NONE)) {
 8017baa:	f897 309d 	ldrb.w	r3, [r7, #157]	; 0x9d
 8017bae:	2b00      	cmp	r3, #0
 8017bb0:	d018      	beq.n	8017be4 <draw_bg+0x25a>
 8017bb2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017bb6:	2b00      	cmp	r3, #0
 8017bb8:	d114      	bne.n	8017be4 <draw_bg+0x25a>
 8017bba:	f897 309e 	ldrb.w	r3, [r7, #158]	; 0x9e
 8017bbe:	2b00      	cmp	r3, #0
 8017bc0:	d110      	bne.n	8017be4 <draw_bg+0x25a>
        _lv_blend_fill(clip, &coords_bg,
                       dsc->bg_color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa,
                       dsc->bg_blend_mode);
 8017bc2:	687b      	ldr	r3, [r7, #4]
 8017bc4:	7b5b      	ldrb	r3, [r3, #13]
        _lv_blend_fill(clip, &coords_bg,
 8017bc6:	687a      	ldr	r2, [r7, #4]
 8017bc8:	f107 0148 	add.w	r1, r7, #72	; 0x48
 8017bcc:	9302      	str	r3, [sp, #8]
 8017bce:	f897 309f 	ldrb.w	r3, [r7, #159]	; 0x9f
 8017bd2:	9301      	str	r3, [sp, #4]
 8017bd4:	2301      	movs	r3, #1
 8017bd6:	9300      	str	r3, [sp, #0]
 8017bd8:	2300      	movs	r3, #0
 8017bda:	8852      	ldrh	r2, [r2, #2]
 8017bdc:	68b8      	ldr	r0, [r7, #8]
 8017bde:	f7f8 fe41 	bl	8010864 <_lv_blend_fill>
 8017be2:	e2a8      	b.n	8018136 <draw_bg+0x7ac>
    }
    /*More complex case: there is a radius, gradient or other mask.*/
    else {
        lv_draw_mask_radius_param_t mask_rout_param;
        if(rout > 0) {
 8017be4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017be8:	2b00      	cmp	r3, #0
 8017bea:	dd12      	ble.n	8017c12 <draw_bg+0x288>
            lv_draw_mask_radius_init(&mask_rout_param, &coords_bg, rout, false);
 8017bec:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017bf0:	b21a      	sxth	r2, r3
 8017bf2:	f107 0148 	add.w	r1, r7, #72	; 0x48
 8017bf6:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8017bfa:	2300      	movs	r3, #0
 8017bfc:	f7fe fbc2 	bl	8016384 <lv_draw_mask_radius_init>
            mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
 8017c00:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8017c04:	2100      	movs	r1, #0
 8017c06:	4618      	mov	r0, r3
 8017c08:	f7fe f9a2 	bl	8015f50 <lv_draw_mask_add>
 8017c0c:	4603      	mov	r3, r0
 8017c0e:	f8a7 309a 	strh.w	r3, [r7, #154]	; 0x9a
        }

        /*Draw the background line by line*/
        int32_t h;
        lv_draw_mask_res_t mask_res = LV_DRAW_MASK_RES_FULL_COVER;
 8017c12:	2301      	movs	r3, #1
 8017c14:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
        lv_color_t grad_color = dsc->bg_color;
 8017c18:	687b      	ldr	r3, [r7, #4]
 8017c1a:	885b      	ldrh	r3, [r3, #2]
 8017c1c:	843b      	strh	r3, [r7, #32]


        lv_color_t * grad_map = NULL;
 8017c1e:	2300      	movs	r3, #0
 8017c20:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
        /*In case of horizontal gradient pre-compute a line with a gradient*/
        if(grad_dir == LV_GRAD_DIR_HOR) {
 8017c24:	f897 309e 	ldrb.w	r3, [r7, #158]	; 0x9e
 8017c28:	2b02      	cmp	r3, #2
 8017c2a:	d125      	bne.n	8017c78 <draw_bg+0x2ee>
            grad_map = _lv_mem_buf_get(coords_w * sizeof(lv_color_t));
 8017c2c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8017c2e:	005b      	lsls	r3, r3, #1
 8017c30:	4618      	mov	r0, r3
 8017c32:	f009 f92d 	bl	8020e90 <_lv_mem_buf_get>
 8017c36:	f8c7 0088 	str.w	r0, [r7, #136]	; 0x88

            int32_t i;
            for(i = 0; i < coords_w; i++) {
 8017c3a:	2300      	movs	r3, #0
 8017c3c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8017c40:	e015      	b.n	8017c6e <draw_bg+0x2e4>
                grad_map[i] = grad_get(dsc, coords_w, i);
 8017c42:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8017c44:	b219      	sxth	r1, r3
 8017c46:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017c4a:	b218      	sxth	r0, r3
 8017c4c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017c50:	005b      	lsls	r3, r3, #1
 8017c52:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8017c56:	18d4      	adds	r4, r2, r3
 8017c58:	4602      	mov	r2, r0
 8017c5a:	6878      	ldr	r0, [r7, #4]
 8017c5c:	f000 fd2b 	bl	80186b6 <grad_get>
 8017c60:	4603      	mov	r3, r0
 8017c62:	8023      	strh	r3, [r4, #0]
            for(i = 0; i < coords_w; i++) {
 8017c64:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8017c68:	3301      	adds	r3, #1
 8017c6a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
 8017c6e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8017c72:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8017c74:	429a      	cmp	r2, r3
 8017c76:	dbe4      	blt.n	8017c42 <draw_bg+0x2b8>
            }
        }

        bool split = false;
 8017c78:	2300      	movs	r3, #0
 8017c7a:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83
        if(lv_area_get_width(&coords_bg) - 2 * rout > SPLIT_LIMIT) split = true;
 8017c7e:	f107 0348 	add.w	r3, r7, #72	; 0x48
 8017c82:	4618      	mov	r0, r3
 8017c84:	f7ff fd1c 	bl	80176c0 <lv_area_get_width>
 8017c88:	4603      	mov	r3, r0
 8017c8a:	461a      	mov	r2, r3
 8017c8c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017c90:	005b      	lsls	r3, r3, #1
 8017c92:	1ad3      	subs	r3, r2, r3
 8017c94:	2b32      	cmp	r3, #50	; 0x32
 8017c96:	dd02      	ble.n	8017c9e <draw_bg+0x314>
 8017c98:	2301      	movs	r3, #1
 8017c9a:	f887 3083 	strb.w	r3, [r7, #131]	; 0x83

        lv_opa_t opa2;

        lv_area_t fill_area;
        fill_area.x1 = coords_bg.x1;
 8017c9e:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 8017ca2:	833b      	strh	r3, [r7, #24]
        fill_area.x2 = coords_bg.x2;
 8017ca4:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8017ca8:	83bb      	strh	r3, [r7, #28]
        fill_area.y1 = disp_area->y1 + draw_area.y1;
 8017caa:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8017cac:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017cb0:	b29a      	uxth	r2, r3
 8017cb2:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8017cb6:	b29b      	uxth	r3, r3
 8017cb8:	4413      	add	r3, r2
 8017cba:	b29b      	uxth	r3, r3
 8017cbc:	b21b      	sxth	r3, r3
 8017cbe:	837b      	strh	r3, [r7, #26]
        fill_area.y2 = fill_area.y1;
 8017cc0:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8017cc4:	83fb      	strh	r3, [r7, #30]
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
 8017cc6:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8017cca:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8017cce:	e18a      	b.n	8017fe6 <draw_bg+0x65c>
            int32_t y = h + vdb->area.y1;
 8017cd0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8017cd2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8017cd6:	461a      	mov	r2, r3
 8017cd8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8017cdc:	4413      	add	r3, r2
 8017cde:	653b      	str	r3, [r7, #80]	; 0x50

            opa2 = opa;
 8017ce0:	f897 309f 	ldrb.w	r3, [r7, #159]	; 0x9f
 8017ce4:	f887 3082 	strb.w	r3, [r7, #130]	; 0x82

            /*In not corner areas apply the mask only if required*/
            if(y > coords_bg.y1 + rout + 1 &&
 8017ce8:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 8017cec:	461a      	mov	r2, r3
 8017cee:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017cf2:	4413      	add	r3, r2
 8017cf4:	3301      	adds	r3, #1
 8017cf6:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8017cf8:	429a      	cmp	r2, r3
 8017cfa:	dd37      	ble.n	8017d6c <draw_bg+0x3e2>
               y < coords_bg.y2 - rout - 1) {
 8017cfc:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8017d00:	461a      	mov	r2, r3
 8017d02:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017d06:	1ad3      	subs	r3, r2, r3
 8017d08:	3b01      	subs	r3, #1
            if(y > coords_bg.y1 + rout + 1 &&
 8017d0a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8017d0c:	429a      	cmp	r2, r3
 8017d0e:	da2d      	bge.n	8017d6c <draw_bg+0x3e2>
                mask_res = LV_DRAW_MASK_RES_FULL_COVER;
 8017d10:	2301      	movs	r3, #1
 8017d12:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
                if(simple_mode == false) {
 8017d16:	f897 309d 	ldrb.w	r3, [r7, #157]	; 0x9d
 8017d1a:	f083 0301 	eor.w	r3, r3, #1
 8017d1e:	b2db      	uxtb	r3, r3
 8017d20:	2b00      	cmp	r3, #0
 8017d22:	d046      	beq.n	8017db2 <draw_bg+0x428>
                    _lv_memset(mask_buf, opa, draw_area_w);
 8017d24:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8017d26:	f897 309f 	ldrb.w	r3, [r7, #159]	; 0x9f
 8017d2a:	4619      	mov	r1, r3
 8017d2c:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8017d2e:	f009 fc2d 	bl	802158c <_lv_memset>
                    mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
 8017d32:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8017d34:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8017d38:	b29a      	uxth	r2, r3
 8017d3a:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8017d3e:	b29b      	uxth	r3, r3
 8017d40:	4413      	add	r3, r2
 8017d42:	b29b      	uxth	r3, r3
 8017d44:	b219      	sxth	r1, r3
 8017d46:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8017d48:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8017d4c:	b29a      	uxth	r2, r3
 8017d4e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8017d52:	b29b      	uxth	r3, r3
 8017d54:	4413      	add	r3, r2
 8017d56:	b29b      	uxth	r3, r3
 8017d58:	b21a      	sxth	r2, r3
 8017d5a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017d5c:	b21b      	sxth	r3, r3
 8017d5e:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8017d60:	f7fe f928 	bl	8015fb4 <lv_draw_mask_apply>
 8017d64:	4603      	mov	r3, r0
 8017d66:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
                if(simple_mode == false) {
 8017d6a:	e022      	b.n	8017db2 <draw_bg+0x428>
                }
            }
            /*In corner areas apply the mask anyway*/
            else {
                _lv_memset(mask_buf, opa, draw_area_w);
 8017d6c:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8017d6e:	f897 309f 	ldrb.w	r3, [r7, #159]	; 0x9f
 8017d72:	4619      	mov	r1, r3
 8017d74:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8017d76:	f009 fc09 	bl	802158c <_lv_memset>
                mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
 8017d7a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8017d7c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8017d80:	b29a      	uxth	r2, r3
 8017d82:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8017d86:	b29b      	uxth	r3, r3
 8017d88:	4413      	add	r3, r2
 8017d8a:	b29b      	uxth	r3, r3
 8017d8c:	b219      	sxth	r1, r3
 8017d8e:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8017d90:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8017d94:	b29a      	uxth	r2, r3
 8017d96:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8017d9a:	b29b      	uxth	r3, r3
 8017d9c:	4413      	add	r3, r2
 8017d9e:	b29b      	uxth	r3, r3
 8017da0:	b21a      	sxth	r2, r3
 8017da2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017da4:	b21b      	sxth	r3, r3
 8017da6:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8017da8:	f7fe f904 	bl	8015fb4 <lv_draw_mask_apply>
 8017dac:	4603      	mov	r3, r0
 8017dae:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
            }

            /*If mask will taken into account its base opacity was already set by memset above*/
            if(mask_res == LV_DRAW_MASK_RES_CHANGED) {
 8017db2:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 8017db6:	2b02      	cmp	r3, #2
 8017db8:	d102      	bne.n	8017dc0 <draw_bg+0x436>
                opa2 = LV_OPA_COVER;
 8017dba:	23ff      	movs	r3, #255	; 0xff
 8017dbc:	f887 3082 	strb.w	r3, [r7, #130]	; 0x82
            }

            /*Get the current line color*/
            if(grad_dir == LV_GRAD_DIR_VER) {
 8017dc0:	f897 309e 	ldrb.w	r3, [r7, #158]	; 0x9e
 8017dc4:	2b01      	cmp	r3, #1
 8017dc6:	d114      	bne.n	8017df2 <draw_bg+0x468>
                grad_color = grad_get(dsc, lv_area_get_height(&coords_bg), y - coords_bg.y1);
 8017dc8:	f107 0348 	add.w	r3, r7, #72	; 0x48
 8017dcc:	4618      	mov	r0, r3
 8017dce:	f7ff fc8e 	bl	80176ee <lv_area_get_height>
 8017dd2:	4603      	mov	r3, r0
 8017dd4:	4619      	mov	r1, r3
 8017dd6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8017dd8:	b29a      	uxth	r2, r3
 8017dda:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 8017dde:	b29b      	uxth	r3, r3
 8017de0:	1ad3      	subs	r3, r2, r3
 8017de2:	b29b      	uxth	r3, r3
 8017de4:	b21b      	sxth	r3, r3
 8017de6:	461a      	mov	r2, r3
 8017de8:	6878      	ldr	r0, [r7, #4]
 8017dea:	f000 fc64 	bl	80186b6 <grad_get>
 8017dee:	4603      	mov	r3, r0
 8017df0:	843b      	strh	r3, [r7, #32]
            }

            /* If there is not other mask and drawing the corner area split the drawing to corner and middle areas
             * because it the middle mask shouldn't be taken into account (therefore its faster)*/
            if(simple_mode && split &&
 8017df2:	f897 309d 	ldrb.w	r3, [r7, #157]	; 0x9d
 8017df6:	2b00      	cmp	r3, #0
 8017df8:	f000 809c 	beq.w	8017f34 <draw_bg+0x5aa>
 8017dfc:	f897 3083 	ldrb.w	r3, [r7, #131]	; 0x83
 8017e00:	2b00      	cmp	r3, #0
 8017e02:	f000 8097 	beq.w	8017f34 <draw_bg+0x5aa>
               (y < coords_bg.y1 + rout + 1 ||
 8017e06:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 8017e0a:	461a      	mov	r2, r3
 8017e0c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017e10:	4413      	add	r3, r2
            if(simple_mode && split &&
 8017e12:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8017e14:	429a      	cmp	r2, r3
 8017e16:	dd09      	ble.n	8017e2c <draw_bg+0x4a2>
                y > coords_bg.y2 - rout - 1)) {
 8017e18:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8017e1c:	461a      	mov	r2, r3
 8017e1e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017e22:	1ad3      	subs	r3, r2, r3
               (y < coords_bg.y1 + rout + 1 ||
 8017e24:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8017e26:	429a      	cmp	r2, r3
 8017e28:	f2c0 8084 	blt.w	8017f34 <draw_bg+0x5aa>

                /*Left part*/
                lv_area_t fill_area2;
                fill_area2.x1 = coords_bg.x1;
 8017e2c:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 8017e30:	823b      	strh	r3, [r7, #16]
                fill_area2.x2 = coords_bg.x1 + rout - 1;
 8017e32:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 8017e36:	b29a      	uxth	r2, r3
 8017e38:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017e3c:	b29b      	uxth	r3, r3
 8017e3e:	4413      	add	r3, r2
 8017e40:	b29b      	uxth	r3, r3
 8017e42:	3b01      	subs	r3, #1
 8017e44:	b29b      	uxth	r3, r3
 8017e46:	b21b      	sxth	r3, r3
 8017e48:	82bb      	strh	r3, [r7, #20]
                fill_area2.y1 = fill_area.y1;
 8017e4a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8017e4e:	827b      	strh	r3, [r7, #18]
                fill_area2.y2 = fill_area.y2;
 8017e50:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8017e54:	82fb      	strh	r3, [r7, #22]

                _lv_blend_fill(clip, &fill_area2,
                               grad_color, mask_buf, mask_res, opa2, dsc->bg_blend_mode);
 8017e56:	687b      	ldr	r3, [r7, #4]
 8017e58:	7b5b      	ldrb	r3, [r3, #13]
                _lv_blend_fill(clip, &fill_area2,
 8017e5a:	f107 0110 	add.w	r1, r7, #16
 8017e5e:	9302      	str	r3, [sp, #8]
 8017e60:	f897 3082 	ldrb.w	r3, [r7, #130]	; 0x82
 8017e64:	9301      	str	r3, [sp, #4]
 8017e66:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 8017e6a:	9300      	str	r3, [sp, #0]
 8017e6c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017e6e:	8c3a      	ldrh	r2, [r7, #32]
 8017e70:	68b8      	ldr	r0, [r7, #8]
 8017e72:	f7f8 fcf7 	bl	8010864 <_lv_blend_fill>

                /*Center part*/
                if(grad_dir == LV_GRAD_DIR_VER) {
 8017e76:	f897 309e 	ldrb.w	r3, [r7, #158]	; 0x9e
 8017e7a:	2b01      	cmp	r3, #1
 8017e7c:	d122      	bne.n	8017ec4 <draw_bg+0x53a>
                    fill_area2.x1 = coords_bg.x1 + rout;
 8017e7e:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 8017e82:	b29a      	uxth	r2, r3
 8017e84:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017e88:	b29b      	uxth	r3, r3
 8017e8a:	4413      	add	r3, r2
 8017e8c:	b29b      	uxth	r3, r3
 8017e8e:	b21b      	sxth	r3, r3
 8017e90:	823b      	strh	r3, [r7, #16]
                    fill_area2.x2 = coords_bg.x2 - rout;
 8017e92:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8017e96:	b29a      	uxth	r2, r3
 8017e98:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017e9c:	b29b      	uxth	r3, r3
 8017e9e:	1ad3      	subs	r3, r2, r3
 8017ea0:	b29b      	uxth	r3, r3
 8017ea2:	b21b      	sxth	r3, r3
 8017ea4:	82bb      	strh	r3, [r7, #20]
                    _lv_blend_fill(clip, &fill_area2,
                                   grad_color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, dsc->bg_blend_mode);
 8017ea6:	687b      	ldr	r3, [r7, #4]
 8017ea8:	7b5b      	ldrb	r3, [r3, #13]
                    _lv_blend_fill(clip, &fill_area2,
 8017eaa:	f107 0110 	add.w	r1, r7, #16
 8017eae:	9302      	str	r3, [sp, #8]
 8017eb0:	f897 309f 	ldrb.w	r3, [r7, #159]	; 0x9f
 8017eb4:	9301      	str	r3, [sp, #4]
 8017eb6:	2301      	movs	r3, #1
 8017eb8:	9300      	str	r3, [sp, #0]
 8017eba:	2300      	movs	r3, #0
 8017ebc:	8c3a      	ldrh	r2, [r7, #32]
 8017ebe:	68b8      	ldr	r0, [r7, #8]
 8017ec0:	f7f8 fcd0 	bl	8010864 <_lv_blend_fill>
                }

                /*Right part*/
                fill_area2.x1 = coords_bg.x2 - rout + 1;
 8017ec4:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8017ec8:	b29a      	uxth	r2, r3
 8017eca:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017ece:	b29b      	uxth	r3, r3
 8017ed0:	1ad3      	subs	r3, r2, r3
 8017ed2:	b29b      	uxth	r3, r3
 8017ed4:	3301      	adds	r3, #1
 8017ed6:	b29b      	uxth	r3, r3
 8017ed8:	b21b      	sxth	r3, r3
 8017eda:	823b      	strh	r3, [r7, #16]
                fill_area2.x2 = coords_bg.x2;
 8017edc:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8017ee0:	82bb      	strh	r3, [r7, #20]

                int32_t mask_ofs = (coords_bg.x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
 8017ee2:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8017ee6:	461a      	mov	r2, r3
 8017ee8:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8017eec:	1ad3      	subs	r3, r2, r3
 8017eee:	1c5a      	adds	r2, r3, #1
 8017ef0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8017ef2:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8017ef6:	4619      	mov	r1, r3
 8017ef8:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8017efc:	440b      	add	r3, r1
 8017efe:	1ad3      	subs	r3, r2, r3
 8017f00:	67fb      	str	r3, [r7, #124]	; 0x7c
                if(mask_ofs < 0) mask_ofs = 0;
 8017f02:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8017f04:	2b00      	cmp	r3, #0
 8017f06:	da01      	bge.n	8017f0c <draw_bg+0x582>
 8017f08:	2300      	movs	r3, #0
 8017f0a:	67fb      	str	r3, [r7, #124]	; 0x7c
                _lv_blend_fill(clip, &fill_area2,
 8017f0c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 8017f0e:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 8017f10:	441a      	add	r2, r3
                               grad_color, mask_buf + mask_ofs, mask_res, opa2, dsc->bg_blend_mode);
 8017f12:	687b      	ldr	r3, [r7, #4]
 8017f14:	7b5b      	ldrb	r3, [r3, #13]
                _lv_blend_fill(clip, &fill_area2,
 8017f16:	f107 0110 	add.w	r1, r7, #16
 8017f1a:	9302      	str	r3, [sp, #8]
 8017f1c:	f897 3082 	ldrb.w	r3, [r7, #130]	; 0x82
 8017f20:	9301      	str	r3, [sp, #4]
 8017f22:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 8017f26:	9300      	str	r3, [sp, #0]
 8017f28:	4613      	mov	r3, r2
 8017f2a:	8c3a      	ldrh	r2, [r7, #32]
 8017f2c:	68b8      	ldr	r0, [r7, #8]
 8017f2e:	f7f8 fc99 	bl	8010864 <_lv_blend_fill>
                y > coords_bg.y2 - rout - 1)) {
 8017f32:	e045      	b.n	8017fc0 <draw_bg+0x636>


            }
            else {
                if(grad_dir == LV_GRAD_DIR_HOR) {
 8017f34:	f897 309e 	ldrb.w	r3, [r7, #158]	; 0x9e
 8017f38:	2b02      	cmp	r3, #2
 8017f3a:	d111      	bne.n	8017f60 <draw_bg+0x5d6>
                    _lv_blend_map(clip, &fill_area, grad_map, mask_buf, mask_res, opa2, dsc->bg_blend_mode);
 8017f3c:	687b      	ldr	r3, [r7, #4]
 8017f3e:	7b5b      	ldrb	r3, [r3, #13]
 8017f40:	f107 0118 	add.w	r1, r7, #24
 8017f44:	9302      	str	r3, [sp, #8]
 8017f46:	f897 3082 	ldrb.w	r3, [r7, #130]	; 0x82
 8017f4a:	9301      	str	r3, [sp, #4]
 8017f4c:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 8017f50:	9300      	str	r3, [sp, #0]
 8017f52:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017f54:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8017f58:	68b8      	ldr	r0, [r7, #8]
 8017f5a:	f7f8 fd4b 	bl	80109f4 <_lv_blend_map>
 8017f5e:	e02f      	b.n	8017fc0 <draw_bg+0x636>
                }
                else if(grad_dir == LV_GRAD_DIR_VER) {
 8017f60:	f897 309e 	ldrb.w	r3, [r7, #158]	; 0x9e
 8017f64:	2b01      	cmp	r3, #1
 8017f66:	d110      	bne.n	8017f8a <draw_bg+0x600>
                    _lv_blend_fill(clip, &fill_area,
                                   grad_color, mask_buf, mask_res, opa2, dsc->bg_blend_mode);
 8017f68:	687b      	ldr	r3, [r7, #4]
 8017f6a:	7b5b      	ldrb	r3, [r3, #13]
                    _lv_blend_fill(clip, &fill_area,
 8017f6c:	f107 0118 	add.w	r1, r7, #24
 8017f70:	9302      	str	r3, [sp, #8]
 8017f72:	f897 3082 	ldrb.w	r3, [r7, #130]	; 0x82
 8017f76:	9301      	str	r3, [sp, #4]
 8017f78:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 8017f7c:	9300      	str	r3, [sp, #0]
 8017f7e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017f80:	8c3a      	ldrh	r2, [r7, #32]
 8017f82:	68b8      	ldr	r0, [r7, #8]
 8017f84:	f7f8 fc6e 	bl	8010864 <_lv_blend_fill>
 8017f88:	e01a      	b.n	8017fc0 <draw_bg+0x636>
                }
                else if(other_mask_cnt != 0 || !split) {
 8017f8a:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8017f8e:	2b00      	cmp	r3, #0
 8017f90:	d106      	bne.n	8017fa0 <draw_bg+0x616>
 8017f92:	f897 3083 	ldrb.w	r3, [r7, #131]	; 0x83
 8017f96:	f083 0301 	eor.w	r3, r3, #1
 8017f9a:	b2db      	uxtb	r3, r3
 8017f9c:	2b00      	cmp	r3, #0
 8017f9e:	d00f      	beq.n	8017fc0 <draw_bg+0x636>
                    _lv_blend_fill(clip, &fill_area,
                                   grad_color, mask_buf, mask_res, opa2, dsc->bg_blend_mode);
 8017fa0:	687b      	ldr	r3, [r7, #4]
 8017fa2:	7b5b      	ldrb	r3, [r3, #13]
                    _lv_blend_fill(clip, &fill_area,
 8017fa4:	f107 0118 	add.w	r1, r7, #24
 8017fa8:	9302      	str	r3, [sp, #8]
 8017faa:	f897 3082 	ldrb.w	r3, [r7, #130]	; 0x82
 8017fae:	9301      	str	r3, [sp, #4]
 8017fb0:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 8017fb4:	9300      	str	r3, [sp, #0]
 8017fb6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8017fb8:	8c3a      	ldrh	r2, [r7, #32]
 8017fba:	68b8      	ldr	r0, [r7, #8]
 8017fbc:	f7f8 fc52 	bl	8010864 <_lv_blend_fill>
                }
            }
            fill_area.y1++;
 8017fc0:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8017fc4:	b29b      	uxth	r3, r3
 8017fc6:	3301      	adds	r3, #1
 8017fc8:	b29b      	uxth	r3, r3
 8017fca:	b21b      	sxth	r3, r3
 8017fcc:	837b      	strh	r3, [r7, #26]
            fill_area.y2++;
 8017fce:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8017fd2:	b29b      	uxth	r3, r3
 8017fd4:	3301      	adds	r3, #1
 8017fd6:	b29b      	uxth	r3, r3
 8017fd8:	b21b      	sxth	r3, r3
 8017fda:	83fb      	strh	r3, [r7, #30]
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
 8017fdc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8017fe0:	3301      	adds	r3, #1
 8017fe2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8017fe6:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8017fea:	461a      	mov	r2, r3
 8017fec:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8017ff0:	4293      	cmp	r3, r2
 8017ff2:	f77f ae6d 	ble.w	8017cd0 <draw_bg+0x346>
        }

        if(grad_dir == LV_GRAD_DIR_NONE && other_mask_cnt == 0 && split) {
 8017ff6:	f897 309e 	ldrb.w	r3, [r7, #158]	; 0x9e
 8017ffa:	2b00      	cmp	r3, #0
 8017ffc:	f040 8093 	bne.w	8018126 <draw_bg+0x79c>
 8018000:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8018004:	2b00      	cmp	r3, #0
 8018006:	f040 808e 	bne.w	8018126 <draw_bg+0x79c>
 801800a:	f897 3083 	ldrb.w	r3, [r7, #131]	; 0x83
 801800e:	2b00      	cmp	r3, #0
 8018010:	f000 8089 	beq.w	8018126 <draw_bg+0x79c>
            /*Central part*/
            fill_area.x1 = coords_bg.x1 + rout;
 8018014:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 8018018:	b29a      	uxth	r2, r3
 801801a:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 801801e:	b29b      	uxth	r3, r3
 8018020:	4413      	add	r3, r2
 8018022:	b29b      	uxth	r3, r3
 8018024:	b21b      	sxth	r3, r3
 8018026:	833b      	strh	r3, [r7, #24]
            fill_area.x2 = coords_bg.x2 - rout;
 8018028:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 801802c:	b29a      	uxth	r2, r3
 801802e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8018032:	b29b      	uxth	r3, r3
 8018034:	1ad3      	subs	r3, r2, r3
 8018036:	b29b      	uxth	r3, r3
 8018038:	b21b      	sxth	r3, r3
 801803a:	83bb      	strh	r3, [r7, #28]
            fill_area.y1 = coords_bg.y1;
 801803c:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 8018040:	837b      	strh	r3, [r7, #26]
            fill_area.y2 = coords_bg.y1 + rout;
 8018042:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 8018046:	b29a      	uxth	r2, r3
 8018048:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 801804c:	b29b      	uxth	r3, r3
 801804e:	4413      	add	r3, r2
 8018050:	b29b      	uxth	r3, r3
 8018052:	b21b      	sxth	r3, r3
 8018054:	83fb      	strh	r3, [r7, #30]

            _lv_blend_fill(clip, &fill_area,
                           dsc->bg_color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, dsc->bg_blend_mode);
 8018056:	687b      	ldr	r3, [r7, #4]
 8018058:	7b5b      	ldrb	r3, [r3, #13]
            _lv_blend_fill(clip, &fill_area,
 801805a:	687a      	ldr	r2, [r7, #4]
 801805c:	f107 0118 	add.w	r1, r7, #24
 8018060:	9302      	str	r3, [sp, #8]
 8018062:	f897 309f 	ldrb.w	r3, [r7, #159]	; 0x9f
 8018066:	9301      	str	r3, [sp, #4]
 8018068:	2301      	movs	r3, #1
 801806a:	9300      	str	r3, [sp, #0]
 801806c:	2300      	movs	r3, #0
 801806e:	8852      	ldrh	r2, [r2, #2]
 8018070:	68b8      	ldr	r0, [r7, #8]
 8018072:	f7f8 fbf7 	bl	8010864 <_lv_blend_fill>

            fill_area.y1 = coords_bg.y2 - rout;
 8018076:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801807a:	b29a      	uxth	r2, r3
 801807c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8018080:	b29b      	uxth	r3, r3
 8018082:	1ad3      	subs	r3, r2, r3
 8018084:	b29b      	uxth	r3, r3
 8018086:	b21b      	sxth	r3, r3
 8018088:	837b      	strh	r3, [r7, #26]
            if(fill_area.y1 <= fill_area.y2) fill_area.y1 = fill_area.y2 + 1;    /*Avoid overdrawing the last line*/
 801808a:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 801808e:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8018092:	429a      	cmp	r2, r3
 8018094:	dc06      	bgt.n	80180a4 <draw_bg+0x71a>
 8018096:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801809a:	b29b      	uxth	r3, r3
 801809c:	3301      	adds	r3, #1
 801809e:	b29b      	uxth	r3, r3
 80180a0:	b21b      	sxth	r3, r3
 80180a2:	837b      	strh	r3, [r7, #26]
            fill_area.y2 = coords_bg.y2;
 80180a4:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 80180a8:	83fb      	strh	r3, [r7, #30]


            _lv_blend_fill(clip, &fill_area,
                           dsc->bg_color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, dsc->bg_blend_mode);
 80180aa:	687b      	ldr	r3, [r7, #4]
 80180ac:	7b5b      	ldrb	r3, [r3, #13]
            _lv_blend_fill(clip, &fill_area,
 80180ae:	687a      	ldr	r2, [r7, #4]
 80180b0:	f107 0118 	add.w	r1, r7, #24
 80180b4:	9302      	str	r3, [sp, #8]
 80180b6:	f897 309f 	ldrb.w	r3, [r7, #159]	; 0x9f
 80180ba:	9301      	str	r3, [sp, #4]
 80180bc:	2301      	movs	r3, #1
 80180be:	9300      	str	r3, [sp, #0]
 80180c0:	2300      	movs	r3, #0
 80180c2:	8852      	ldrh	r2, [r2, #2]
 80180c4:	68b8      	ldr	r0, [r7, #8]
 80180c6:	f7f8 fbcd 	bl	8010864 <_lv_blend_fill>

            fill_area.x1 = coords_bg.x1;
 80180ca:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 80180ce:	833b      	strh	r3, [r7, #24]
            fill_area.x2 = coords_bg.x2;
 80180d0:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 80180d4:	83bb      	strh	r3, [r7, #28]
            fill_area.y1 = coords_bg.y1 + rout + 1;
 80180d6:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 80180da:	b29a      	uxth	r2, r3
 80180dc:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80180e0:	b29b      	uxth	r3, r3
 80180e2:	4413      	add	r3, r2
 80180e4:	b29b      	uxth	r3, r3
 80180e6:	3301      	adds	r3, #1
 80180e8:	b29b      	uxth	r3, r3
 80180ea:	b21b      	sxth	r3, r3
 80180ec:	837b      	strh	r3, [r7, #26]
            fill_area.y2 = coords_bg.y2 - rout - 1;
 80180ee:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 80180f2:	b29a      	uxth	r2, r3
 80180f4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80180f8:	b29b      	uxth	r3, r3
 80180fa:	1ad3      	subs	r3, r2, r3
 80180fc:	b29b      	uxth	r3, r3
 80180fe:	3b01      	subs	r3, #1
 8018100:	b29b      	uxth	r3, r3
 8018102:	b21b      	sxth	r3, r3
 8018104:	83fb      	strh	r3, [r7, #30]

            _lv_blend_fill(clip, &fill_area,
                           dsc->bg_color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, dsc->bg_blend_mode);
 8018106:	687b      	ldr	r3, [r7, #4]
 8018108:	7b5b      	ldrb	r3, [r3, #13]
            _lv_blend_fill(clip, &fill_area,
 801810a:	687a      	ldr	r2, [r7, #4]
 801810c:	f107 0118 	add.w	r1, r7, #24
 8018110:	9302      	str	r3, [sp, #8]
 8018112:	f897 309f 	ldrb.w	r3, [r7, #159]	; 0x9f
 8018116:	9301      	str	r3, [sp, #4]
 8018118:	2301      	movs	r3, #1
 801811a:	9300      	str	r3, [sp, #0]
 801811c:	2300      	movs	r3, #0
 801811e:	8852      	ldrh	r2, [r2, #2]
 8018120:	68b8      	ldr	r0, [r7, #8]
 8018122:	f7f8 fb9f 	bl	8010864 <_lv_blend_fill>

        }

        if(grad_map) _lv_mem_buf_release(grad_map);
 8018126:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801812a:	2b00      	cmp	r3, #0
 801812c:	d003      	beq.n	8018136 <draw_bg+0x7ac>
 801812e:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
 8018132:	f008 ff8d 	bl	8021050 <_lv_mem_buf_release>
    }

    lv_draw_mask_remove_id(mask_rout_id);
 8018136:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 801813a:	4618      	mov	r0, r3
 801813c:	f7fd ff7e 	bl	801603c <lv_draw_mask_remove_id>

    _lv_mem_buf_release(mask_buf);
 8018140:	6e78      	ldr	r0, [r7, #100]	; 0x64
 8018142:	f008 ff85 	bl	8021050 <_lv_mem_buf_release>
 8018146:	e002      	b.n	801814e <draw_bg+0x7c4>
    if(dsc->bg_opa <= LV_OPA_MIN) return;
 8018148:	bf00      	nop
 801814a:	e000      	b.n	801814e <draw_bg+0x7c4>
    if(is_common == false) return;
 801814c:	bf00      	nop

}
 801814e:	37a4      	adds	r7, #164	; 0xa4
 8018150:	46bd      	mov	sp, r7
 8018152:	bd90      	pop	{r4, r7, pc}

08018154 <draw_border>:

LV_ATTRIBUTE_FAST_MEM static void draw_border(const lv_area_t * coords, const lv_area_t * clip,
                                              const lv_draw_rect_dsc_t * dsc)
{
 8018154:	b580      	push	{r7, lr}
 8018156:	b0b0      	sub	sp, #192	; 0xc0
 8018158:	af04      	add	r7, sp, #16
 801815a:	60f8      	str	r0, [r7, #12]
 801815c:	60b9      	str	r1, [r7, #8]
 801815e:	607a      	str	r2, [r7, #4]
    if(dsc->border_opa <= LV_OPA_MIN) return;
 8018160:	687b      	ldr	r3, [r7, #4]
 8018162:	7d1b      	ldrb	r3, [r3, #20]
 8018164:	2b02      	cmp	r3, #2
 8018166:	f240 829a 	bls.w	801869e <draw_border+0x54a>
    if(dsc->border_width == 0) return;
 801816a:	687b      	ldr	r3, [r7, #4]
 801816c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8018170:	2b00      	cmp	r3, #0
 8018172:	f000 8296 	beq.w	80186a2 <draw_border+0x54e>
    if(dsc->border_side == LV_BORDER_SIDE_NONE) return;
 8018176:	687b      	ldr	r3, [r7, #4]
 8018178:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801817c:	2b00      	cmp	r3, #0
 801817e:	f000 8292 	beq.w	80186a6 <draw_border+0x552>
    if(dsc->border_post) return;
 8018182:	687b      	ldr	r3, [r7, #4]
 8018184:	7d9b      	ldrb	r3, [r3, #22]
 8018186:	f003 0301 	and.w	r3, r3, #1
 801818a:	b2db      	uxtb	r3, r3
 801818c:	2b00      	cmp	r3, #0
 801818e:	f040 828c 	bne.w	80186aa <draw_border+0x556>

    int32_t coords_w = lv_area_get_width(coords);
 8018192:	68f8      	ldr	r0, [r7, #12]
 8018194:	f7ff fa94 	bl	80176c0 <lv_area_get_width>
 8018198:	4603      	mov	r3, r0
 801819a:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    int32_t coords_h = lv_area_get_height(coords);
 801819e:	68f8      	ldr	r0, [r7, #12]
 80181a0:	f7ff faa5 	bl	80176ee <lv_area_get_height>
 80181a4:	4603      	mov	r3, r0
 80181a6:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

    /*Get the real radius*/
    int32_t rout = dsc->radius;
 80181aa:	687b      	ldr	r3, [r7, #4]
 80181ac:	f9b3 3000 	ldrsh.w	r3, [r3]
 80181b0:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    int32_t short_side = LV_MATH_MIN(coords_w, coords_h);
 80181b4:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80181b8:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80181bc:	4293      	cmp	r3, r2
 80181be:	bfa8      	it	ge
 80181c0:	4613      	movge	r3, r2
 80181c2:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    if(rout > short_side >> 1) rout = short_side >> 1;
 80181c6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80181ca:	105b      	asrs	r3, r3, #1
 80181cc:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 80181d0:	429a      	cmp	r2, r3
 80181d2:	dd04      	ble.n	80181de <draw_border+0x8a>
 80181d4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 80181d8:	105b      	asrs	r3, r3, #1
 80181da:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac

    /*Get the inner area*/
    lv_area_t area_inner;
    lv_area_copy(&area_inner, coords);
 80181de:	f107 0364 	add.w	r3, r7, #100	; 0x64
 80181e2:	68f9      	ldr	r1, [r7, #12]
 80181e4:	4618      	mov	r0, r3
 80181e6:	f7ff fa5d 	bl	80176a4 <lv_area_copy>
    area_inner.x1 += ((dsc->border_side & LV_BORDER_SIDE_LEFT) ? dsc->border_width : - (dsc->border_width + rout));
 80181ea:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 80181ee:	b29a      	uxth	r2, r3
 80181f0:	687b      	ldr	r3, [r7, #4]
 80181f2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80181f6:	b29b      	uxth	r3, r3
 80181f8:	f003 0304 	and.w	r3, r3, #4
 80181fc:	2b00      	cmp	r3, #0
 80181fe:	d004      	beq.n	801820a <draw_border+0xb6>
 8018200:	687b      	ldr	r3, [r7, #4]
 8018202:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8018206:	b29b      	uxth	r3, r3
 8018208:	e00a      	b.n	8018220 <draw_border+0xcc>
 801820a:	687b      	ldr	r3, [r7, #4]
 801820c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8018210:	b299      	uxth	r1, r3
 8018212:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8018216:	b29b      	uxth	r3, r3
 8018218:	440b      	add	r3, r1
 801821a:	b29b      	uxth	r3, r3
 801821c:	425b      	negs	r3, r3
 801821e:	b29b      	uxth	r3, r3
 8018220:	4413      	add	r3, r2
 8018222:	b29b      	uxth	r3, r3
 8018224:	b21b      	sxth	r3, r3
 8018226:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    area_inner.x2 -= ((dsc->border_side & LV_BORDER_SIDE_RIGHT) ? dsc->border_width : - (dsc->border_width + rout));
 801822a:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 801822e:	b29a      	uxth	r2, r3
 8018230:	687b      	ldr	r3, [r7, #4]
 8018232:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8018236:	b29b      	uxth	r3, r3
 8018238:	f003 0308 	and.w	r3, r3, #8
 801823c:	2b00      	cmp	r3, #0
 801823e:	d004      	beq.n	801824a <draw_border+0xf6>
 8018240:	687b      	ldr	r3, [r7, #4]
 8018242:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8018246:	b29b      	uxth	r3, r3
 8018248:	e00a      	b.n	8018260 <draw_border+0x10c>
 801824a:	687b      	ldr	r3, [r7, #4]
 801824c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8018250:	b299      	uxth	r1, r3
 8018252:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8018256:	b29b      	uxth	r3, r3
 8018258:	440b      	add	r3, r1
 801825a:	b29b      	uxth	r3, r3
 801825c:	425b      	negs	r3, r3
 801825e:	b29b      	uxth	r3, r3
 8018260:	1ad3      	subs	r3, r2, r3
 8018262:	b29b      	uxth	r3, r3
 8018264:	b21b      	sxth	r3, r3
 8018266:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
    area_inner.y1 += ((dsc->border_side & LV_BORDER_SIDE_TOP) ? dsc->border_width : - (dsc->border_width + rout));
 801826a:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 801826e:	b29a      	uxth	r2, r3
 8018270:	687b      	ldr	r3, [r7, #4]
 8018272:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8018276:	b29b      	uxth	r3, r3
 8018278:	f003 0302 	and.w	r3, r3, #2
 801827c:	2b00      	cmp	r3, #0
 801827e:	d004      	beq.n	801828a <draw_border+0x136>
 8018280:	687b      	ldr	r3, [r7, #4]
 8018282:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8018286:	b29b      	uxth	r3, r3
 8018288:	e00a      	b.n	80182a0 <draw_border+0x14c>
 801828a:	687b      	ldr	r3, [r7, #4]
 801828c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8018290:	b299      	uxth	r1, r3
 8018292:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8018296:	b29b      	uxth	r3, r3
 8018298:	440b      	add	r3, r1
 801829a:	b29b      	uxth	r3, r3
 801829c:	425b      	negs	r3, r3
 801829e:	b29b      	uxth	r3, r3
 80182a0:	4413      	add	r3, r2
 80182a2:	b29b      	uxth	r3, r3
 80182a4:	b21b      	sxth	r3, r3
 80182a6:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
    area_inner.y2 -= ((dsc->border_side & LV_BORDER_SIDE_BOTTOM) ? dsc->border_width : - (dsc->border_width + rout));
 80182aa:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 80182ae:	b29a      	uxth	r2, r3
 80182b0:	687b      	ldr	r3, [r7, #4]
 80182b2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80182b6:	b29b      	uxth	r3, r3
 80182b8:	f003 0301 	and.w	r3, r3, #1
 80182bc:	2b00      	cmp	r3, #0
 80182be:	d004      	beq.n	80182ca <draw_border+0x176>
 80182c0:	687b      	ldr	r3, [r7, #4]
 80182c2:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80182c6:	b29b      	uxth	r3, r3
 80182c8:	e00a      	b.n	80182e0 <draw_border+0x18c>
 80182ca:	687b      	ldr	r3, [r7, #4]
 80182cc:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80182d0:	b299      	uxth	r1, r3
 80182d2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 80182d6:	b29b      	uxth	r3, r3
 80182d8:	440b      	add	r3, r1
 80182da:	b29b      	uxth	r3, r3
 80182dc:	425b      	negs	r3, r3
 80182de:	b29b      	uxth	r3, r3
 80182e0:	1ad3      	subs	r3, r2, r3
 80182e2:	b29b      	uxth	r3, r3
 80182e4:	b21b      	sxth	r3, r3
 80182e6:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a

    if(dsc->border_side == LV_BORDER_SIDE_FULL) {
 80182ea:	687b      	ldr	r3, [r7, #4]
 80182ec:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80182f0:	2b0f      	cmp	r3, #15
 80182f2:	d114      	bne.n	801831e <draw_border+0x1ca>
        draw_full_border(&area_inner, coords, clip, dsc->radius, dsc->border_color, dsc->border_opa, dsc->border_blend_mode);
 80182f4:	687b      	ldr	r3, [r7, #4]
 80182f6:	f9b3 1000 	ldrsh.w	r1, [r3]
 80182fa:	687b      	ldr	r3, [r7, #4]
 80182fc:	7d1b      	ldrb	r3, [r3, #20]
 80182fe:	687a      	ldr	r2, [r7, #4]
 8018300:	7d52      	ldrb	r2, [r2, #21]
 8018302:	f107 0064 	add.w	r0, r7, #100	; 0x64
 8018306:	9202      	str	r2, [sp, #8]
 8018308:	9301      	str	r3, [sp, #4]
 801830a:	687b      	ldr	r3, [r7, #4]
 801830c:	89db      	ldrh	r3, [r3, #14]
 801830e:	f8ad 3000 	strh.w	r3, [sp]
 8018312:	460b      	mov	r3, r1
 8018314:	68ba      	ldr	r2, [r7, #8]
 8018316:	68f9      	ldr	r1, [r7, #12]
 8018318:	f002 fc91 	bl	801ac3e <draw_full_border>
 801831c:	e1c8      	b.n	80186b0 <draw_border+0x55c>
    }
    else {
        lv_opa_t opa = dsc->border_opa;
 801831e:	687b      	ldr	r3, [r7, #4]
 8018320:	7d1b      	ldrb	r3, [r3, #20]
 8018322:	f887 30ab 	strb.w	r3, [r7, #171]	; 0xab
        if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 8018326:	f897 30ab 	ldrb.w	r3, [r7, #171]	; 0xab
 801832a:	2bfd      	cmp	r3, #253	; 0xfd
 801832c:	d902      	bls.n	8018334 <draw_border+0x1e0>
 801832e:	23ff      	movs	r3, #255	; 0xff
 8018330:	f887 30ab 	strb.w	r3, [r7, #171]	; 0xab

        lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
 8018334:	f7f6 f854 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 8018338:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 801833c:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
 8018340:	f006 fc64 	bl	801ec0c <lv_disp_get_buf>
 8018344:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c

        /* Get clipped fill area which is the real draw area.
         * It is always the same or inside `fill_area` */
        lv_area_t draw_area;
        bool is_common;
        is_common = _lv_area_intersect(&draw_area, coords, clip);
 8018348:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801834c:	68ba      	ldr	r2, [r7, #8]
 801834e:	68f9      	ldr	r1, [r7, #12]
 8018350:	4618      	mov	r0, r3
 8018352:	f007 f88b 	bl	801f46c <_lv_area_intersect>
 8018356:	4603      	mov	r3, r0
 8018358:	f887 308b 	strb.w	r3, [r7, #139]	; 0x8b
        if(is_common == false) return;
 801835c:	f897 308b 	ldrb.w	r3, [r7, #139]	; 0x8b
 8018360:	f083 0301 	eor.w	r3, r3, #1
 8018364:	b2db      	uxtb	r3, r3
 8018366:	2b00      	cmp	r3, #0
 8018368:	f040 81a1 	bne.w	80186ae <draw_border+0x55a>

        const lv_area_t * disp_area = &vdb->area;
 801836c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8018370:	3310      	adds	r3, #16
 8018372:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84

        /* Now `draw_area` has absolute coordinates.
         * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
        draw_area.x1 -= disp_area->x1;
 8018376:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 801837a:	b29a      	uxth	r2, r3
 801837c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8018380:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018384:	b29b      	uxth	r3, r3
 8018386:	1ad3      	subs	r3, r2, r3
 8018388:	b29b      	uxth	r3, r3
 801838a:	b21b      	sxth	r3, r3
 801838c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
        draw_area.y1 -= disp_area->y1;
 8018390:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8018394:	b29a      	uxth	r2, r3
 8018396:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 801839a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801839e:	b29b      	uxth	r3, r3
 80183a0:	1ad3      	subs	r3, r2, r3
 80183a2:	b29b      	uxth	r3, r3
 80183a4:	b21b      	sxth	r3, r3
 80183a6:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
        draw_area.x2 -= disp_area->x1;
 80183aa:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 80183ae:	b29a      	uxth	r2, r3
 80183b0:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80183b4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80183b8:	b29b      	uxth	r3, r3
 80183ba:	1ad3      	subs	r3, r2, r3
 80183bc:	b29b      	uxth	r3, r3
 80183be:	b21b      	sxth	r3, r3
 80183c0:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
        draw_area.y2 -= disp_area->y1;
 80183c4:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 80183c8:	b29a      	uxth	r2, r3
 80183ca:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80183ce:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80183d2:	b29b      	uxth	r3, r3
 80183d4:	1ad3      	subs	r3, r2, r3
 80183d6:	b29b      	uxth	r3, r3
 80183d8:	b21b      	sxth	r3, r3
 80183da:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

        int32_t draw_area_w = lv_area_get_width(&draw_area);
 80183de:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 80183e2:	4618      	mov	r0, r3
 80183e4:	f7ff f96c 	bl	80176c0 <lv_area_get_width>
 80183e8:	4603      	mov	r3, r0
 80183ea:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

        /*Create a mask if there is a radius*/
        lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
 80183ee:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80183f2:	4618      	mov	r0, r3
 80183f4:	f008 fd4c 	bl	8020e90 <_lv_mem_buf_get>
 80183f8:	67f8      	str	r0, [r7, #124]	; 0x7c

        /*Create mask for the outer area*/
        int16_t mask_rout_id = LV_MASK_ID_INV;
 80183fa:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80183fe:	f8a7 30a8 	strh.w	r3, [r7, #168]	; 0xa8
        lv_draw_mask_radius_param_t mask_rout_param;
        if(rout > 0) {
 8018402:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8018406:	2b00      	cmp	r3, #0
 8018408:	dd11      	ble.n	801842e <draw_border+0x2da>
            lv_draw_mask_radius_init(&mask_rout_param, coords, rout, false);
 801840a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801840e:	b21a      	sxth	r2, r3
 8018410:	f107 0040 	add.w	r0, r7, #64	; 0x40
 8018414:	2300      	movs	r3, #0
 8018416:	68f9      	ldr	r1, [r7, #12]
 8018418:	f7fd ffb4 	bl	8016384 <lv_draw_mask_radius_init>
            mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
 801841c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8018420:	2100      	movs	r1, #0
 8018422:	4618      	mov	r0, r3
 8018424:	f7fd fd94 	bl	8015f50 <lv_draw_mask_add>
 8018428:	4603      	mov	r3, r0
 801842a:	f8a7 30a8 	strh.w	r3, [r7, #168]	; 0xa8
        }

        /*Create mask for the inner mask*/
        int32_t rin = rout - dsc->border_width;
 801842e:	687b      	ldr	r3, [r7, #4]
 8018430:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8018434:	461a      	mov	r2, r3
 8018436:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801843a:	1a9b      	subs	r3, r3, r2
 801843c:	67bb      	str	r3, [r7, #120]	; 0x78
        if(rin < 0) rin = 0;
 801843e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8018440:	2b00      	cmp	r3, #0
 8018442:	da01      	bge.n	8018448 <draw_border+0x2f4>
 8018444:	2300      	movs	r3, #0
 8018446:	67bb      	str	r3, [r7, #120]	; 0x78
        lv_draw_mask_radius_param_t mask_rin_param;
        lv_draw_mask_radius_init(&mask_rin_param, &area_inner, rout - dsc->border_width, true);
 8018448:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801844c:	b29a      	uxth	r2, r3
 801844e:	687b      	ldr	r3, [r7, #4]
 8018450:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8018454:	b29b      	uxth	r3, r3
 8018456:	1ad3      	subs	r3, r2, r3
 8018458:	b29b      	uxth	r3, r3
 801845a:	b21a      	sxth	r2, r3
 801845c:	f107 0164 	add.w	r1, r7, #100	; 0x64
 8018460:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8018464:	2301      	movs	r3, #1
 8018466:	f7fd ff8d 	bl	8016384 <lv_draw_mask_radius_init>
        int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);
 801846a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 801846e:	2100      	movs	r1, #0
 8018470:	4618      	mov	r0, r3
 8018472:	f7fd fd6d 	bl	8015f50 <lv_draw_mask_add>
 8018476:	4603      	mov	r3, r0
 8018478:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

        int32_t corner_size = LV_MATH_MAX(rout, dsc->border_width - 1);
 801847c:	687b      	ldr	r3, [r7, #4]
 801847e:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8018482:	461a      	mov	r2, r3
 8018484:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8018488:	4293      	cmp	r3, r2
 801848a:	da04      	bge.n	8018496 <draw_border+0x342>
 801848c:	687b      	ldr	r3, [r7, #4]
 801848e:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8018492:	3b01      	subs	r3, #1
 8018494:	e001      	b.n	801849a <draw_border+0x346>
 8018496:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801849a:	673b      	str	r3, [r7, #112]	; 0x70

        int32_t h;
        lv_draw_mask_res_t mask_res;
        lv_area_t fill_area;

        lv_color_t color = dsc->border_color;
 801849c:	687b      	ldr	r3, [r7, #4]
 801849e:	89db      	ldrh	r3, [r3, #14]
 80184a0:	833b      	strh	r3, [r7, #24]
        lv_blend_mode_t blend_mode = dsc->border_blend_mode;
 80184a2:	687b      	ldr	r3, [r7, #4]
 80184a4:	7d5b      	ldrb	r3, [r3, #21]
 80184a6:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f

        fill_area.x1 = coords->x1;
 80184aa:	68fb      	ldr	r3, [r7, #12]
 80184ac:	f9b3 3000 	ldrsh.w	r3, [r3]
 80184b0:	83bb      	strh	r3, [r7, #28]
        fill_area.x2 = coords->x2;
 80184b2:	68fb      	ldr	r3, [r7, #12]
 80184b4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80184b8:	843b      	strh	r3, [r7, #32]
        fill_area.y1 = disp_area->y1 + draw_area.y1;
 80184ba:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80184be:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80184c2:	b29a      	uxth	r2, r3
 80184c4:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80184c8:	b29b      	uxth	r3, r3
 80184ca:	4413      	add	r3, r2
 80184cc:	b29b      	uxth	r3, r3
 80184ce:	b21b      	sxth	r3, r3
 80184d0:	83fb      	strh	r3, [r7, #30]
        fill_area.y2 = fill_area.y1;
 80184d2:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80184d6:	847b      	strh	r3, [r7, #34]	; 0x22

        uint32_t buf_ofs = 0;
 80184d8:	2300      	movs	r3, #0
 80184da:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
        if(dsc->border_side == LV_BORDER_SIDE_LEFT) fill_area.x2 = coords->x1 + corner_size;
 80184de:	687b      	ldr	r3, [r7, #4]
 80184e0:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80184e4:	2b04      	cmp	r3, #4
 80184e6:	d10a      	bne.n	80184fe <draw_border+0x3aa>
 80184e8:	68fb      	ldr	r3, [r7, #12]
 80184ea:	f9b3 3000 	ldrsh.w	r3, [r3]
 80184ee:	b29a      	uxth	r2, r3
 80184f0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80184f2:	b29b      	uxth	r3, r3
 80184f4:	4413      	add	r3, r2
 80184f6:	b29b      	uxth	r3, r3
 80184f8:	b21b      	sxth	r3, r3
 80184fa:	843b      	strh	r3, [r7, #32]
 80184fc:	e017      	b.n	801852e <draw_border+0x3da>
        else if(dsc->border_side == LV_BORDER_SIDE_RIGHT) {
 80184fe:	687b      	ldr	r3, [r7, #4]
 8018500:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8018504:	2b08      	cmp	r3, #8
 8018506:	d112      	bne.n	801852e <draw_border+0x3da>
            fill_area.x1 = coords->x2 - corner_size;
 8018508:	68fb      	ldr	r3, [r7, #12]
 801850a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801850e:	b29a      	uxth	r2, r3
 8018510:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8018512:	b29b      	uxth	r3, r3
 8018514:	1ad3      	subs	r3, r2, r3
 8018516:	b29b      	uxth	r3, r3
 8018518:	b21b      	sxth	r3, r3
 801851a:	83bb      	strh	r3, [r7, #28]
            buf_ofs = fill_area.x1 - coords->x1;
 801851c:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8018520:	461a      	mov	r2, r3
 8018522:	68fb      	ldr	r3, [r7, #12]
 8018524:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018528:	1ad3      	subs	r3, r2, r3
 801852a:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
        }

        volatile bool top_only = false;
 801852e:	2300      	movs	r3, #0
 8018530:	75fb      	strb	r3, [r7, #23]
        volatile bool bottom_only = false;
 8018532:	2300      	movs	r3, #0
 8018534:	75bb      	strb	r3, [r7, #22]
        if(dsc->border_side == LV_BORDER_SIDE_TOP) top_only = true;
 8018536:	687b      	ldr	r3, [r7, #4]
 8018538:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801853c:	2b02      	cmp	r3, #2
 801853e:	d101      	bne.n	8018544 <draw_border+0x3f0>
 8018540:	2301      	movs	r3, #1
 8018542:	75fb      	strb	r3, [r7, #23]
        if(dsc->border_side == LV_BORDER_SIDE_BOTTOM) bottom_only = true;
 8018544:	687b      	ldr	r3, [r7, #4]
 8018546:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801854a:	2b01      	cmp	r3, #1
 801854c:	d101      	bne.n	8018552 <draw_border+0x3fe>
 801854e:	2301      	movs	r3, #1
 8018550:	75bb      	strb	r3, [r7, #22]
        if(dsc->border_side == (LV_BORDER_SIDE_TOP | LV_BORDER_SIDE_BOTTOM)) {
 8018552:	687b      	ldr	r3, [r7, #4]
 8018554:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8018558:	2b03      	cmp	r3, #3
 801855a:	d103      	bne.n	8018564 <draw_border+0x410>
            top_only = true;
 801855c:	2301      	movs	r3, #1
 801855e:	75fb      	strb	r3, [r7, #23]
            bottom_only = true;
 8018560:	2301      	movs	r3, #1
 8018562:	75bb      	strb	r3, [r7, #22]
        }

        volatile bool normal = !top_only && !bottom_only ? true : false;
 8018564:	7dfb      	ldrb	r3, [r7, #23]
 8018566:	b2db      	uxtb	r3, r3
 8018568:	f083 0301 	eor.w	r3, r3, #1
 801856c:	b2db      	uxtb	r3, r3
 801856e:	2b00      	cmp	r3, #0
 8018570:	d008      	beq.n	8018584 <draw_border+0x430>
 8018572:	7dbb      	ldrb	r3, [r7, #22]
 8018574:	b2db      	uxtb	r3, r3
 8018576:	f083 0301 	eor.w	r3, r3, #1
 801857a:	b2db      	uxtb	r3, r3
 801857c:	2b00      	cmp	r3, #0
 801857e:	d001      	beq.n	8018584 <draw_border+0x430>
 8018580:	2301      	movs	r3, #1
 8018582:	e000      	b.n	8018586 <draw_border+0x432>
 8018584:	2300      	movs	r3, #0
 8018586:	f003 0301 	and.w	r3, r3, #1
 801858a:	b2db      	uxtb	r3, r3
 801858c:	757b      	strb	r3, [r7, #21]

        for(h = draw_area.y1; h <= draw_area.y2; h++) {
 801858e:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8018592:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8018596:	e06d      	b.n	8018674 <draw_border+0x520>
            if(normal ||
 8018598:	7d7b      	ldrb	r3, [r7, #21]
 801859a:	b2db      	uxtb	r3, r3
 801859c:	2b00      	cmp	r3, #0
 801859e:	d11d      	bne.n	80185dc <draw_border+0x488>
               (top_only && fill_area.y1 <= coords->y1 + corner_size) ||
 80185a0:	7dfb      	ldrb	r3, [r7, #23]
 80185a2:	b2db      	uxtb	r3, r3
            if(normal ||
 80185a4:	2b00      	cmp	r3, #0
 80185a6:	d00a      	beq.n	80185be <draw_border+0x46a>
               (top_only && fill_area.y1 <= coords->y1 + corner_size) ||
 80185a8:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80185ac:	461a      	mov	r2, r3
 80185ae:	68fb      	ldr	r3, [r7, #12]
 80185b0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80185b4:	4619      	mov	r1, r3
 80185b6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80185b8:	440b      	add	r3, r1
 80185ba:	429a      	cmp	r2, r3
 80185bc:	dd0e      	ble.n	80185dc <draw_border+0x488>
               (bottom_only && fill_area.y1 >= coords->y2 - corner_size)) {
 80185be:	7dbb      	ldrb	r3, [r7, #22]
 80185c0:	b2db      	uxtb	r3, r3
               (top_only && fill_area.y1 <= coords->y1 + corner_size) ||
 80185c2:	2b00      	cmp	r3, #0
 80185c4:	d043      	beq.n	801864e <draw_border+0x4fa>
               (bottom_only && fill_area.y1 >= coords->y2 - corner_size)) {
 80185c6:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80185ca:	461a      	mov	r2, r3
 80185cc:	68fb      	ldr	r3, [r7, #12]
 80185ce:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80185d2:	4619      	mov	r1, r3
 80185d4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80185d6:	1acb      	subs	r3, r1, r3
 80185d8:	429a      	cmp	r2, r3
 80185da:	db38      	blt.n	801864e <draw_border+0x4fa>
                _lv_memset_ff(mask_buf, draw_area_w);
 80185dc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80185e0:	4619      	mov	r1, r3
 80185e2:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 80185e4:	f009 f8e1 	bl	80217aa <_lv_memset_ff>
                mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
 80185e8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80185ec:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80185f0:	b29a      	uxth	r2, r3
 80185f2:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 80185f6:	b29b      	uxth	r3, r3
 80185f8:	4413      	add	r3, r2
 80185fa:	b29b      	uxth	r3, r3
 80185fc:	b219      	sxth	r1, r3
 80185fe:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8018602:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8018606:	b29a      	uxth	r2, r3
 8018608:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801860c:	b29b      	uxth	r3, r3
 801860e:	4413      	add	r3, r2
 8018610:	b29b      	uxth	r3, r3
 8018612:	b21a      	sxth	r2, r3
 8018614:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8018618:	b21b      	sxth	r3, r3
 801861a:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 801861c:	f7fd fcca 	bl	8015fb4 <lv_draw_mask_apply>
 8018620:	4603      	mov	r3, r0
 8018622:	f887 306e 	strb.w	r3, [r7, #110]	; 0x6e
                _lv_blend_fill(clip, &fill_area, color, mask_buf + buf_ofs, mask_res, opa, blend_mode);
 8018626:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8018628:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 801862c:	441a      	add	r2, r3
 801862e:	f107 011c 	add.w	r1, r7, #28
 8018632:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8018636:	9302      	str	r3, [sp, #8]
 8018638:	f897 30ab 	ldrb.w	r3, [r7, #171]	; 0xab
 801863c:	9301      	str	r3, [sp, #4]
 801863e:	f897 306e 	ldrb.w	r3, [r7, #110]	; 0x6e
 8018642:	9300      	str	r3, [sp, #0]
 8018644:	4613      	mov	r3, r2
 8018646:	8b3a      	ldrh	r2, [r7, #24]
 8018648:	68b8      	ldr	r0, [r7, #8]
 801864a:	f7f8 f90b 	bl	8010864 <_lv_blend_fill>
            }
            fill_area.y1++;
 801864e:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8018652:	b29b      	uxth	r3, r3
 8018654:	3301      	adds	r3, #1
 8018656:	b29b      	uxth	r3, r3
 8018658:	b21b      	sxth	r3, r3
 801865a:	83fb      	strh	r3, [r7, #30]
            fill_area.y2++;
 801865c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8018660:	b29b      	uxth	r3, r3
 8018662:	3301      	adds	r3, #1
 8018664:	b29b      	uxth	r3, r3
 8018666:	b21b      	sxth	r3, r3
 8018668:	847b      	strh	r3, [r7, #34]	; 0x22
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
 801866a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801866e:	3301      	adds	r3, #1
 8018670:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
 8018674:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8018678:	461a      	mov	r2, r3
 801867a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801867e:	4293      	cmp	r3, r2
 8018680:	dd8a      	ble.n	8018598 <draw_border+0x444>

        }
        lv_draw_mask_remove_id(mask_rin_id);
 8018682:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018686:	4618      	mov	r0, r3
 8018688:	f7fd fcd8 	bl	801603c <lv_draw_mask_remove_id>
        lv_draw_mask_remove_id(mask_rout_id);
 801868c:	f9b7 30a8 	ldrsh.w	r3, [r7, #168]	; 0xa8
 8018690:	4618      	mov	r0, r3
 8018692:	f7fd fcd3 	bl	801603c <lv_draw_mask_remove_id>
        _lv_mem_buf_release(mask_buf);
 8018696:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 8018698:	f008 fcda 	bl	8021050 <_lv_mem_buf_release>
 801869c:	e008      	b.n	80186b0 <draw_border+0x55c>
    if(dsc->border_opa <= LV_OPA_MIN) return;
 801869e:	bf00      	nop
 80186a0:	e006      	b.n	80186b0 <draw_border+0x55c>
    if(dsc->border_width == 0) return;
 80186a2:	bf00      	nop
 80186a4:	e004      	b.n	80186b0 <draw_border+0x55c>
    if(dsc->border_side == LV_BORDER_SIDE_NONE) return;
 80186a6:	bf00      	nop
 80186a8:	e002      	b.n	80186b0 <draw_border+0x55c>
    if(dsc->border_post) return;
 80186aa:	bf00      	nop
 80186ac:	e000      	b.n	80186b0 <draw_border+0x55c>
        if(is_common == false) return;
 80186ae:	bf00      	nop
    }
}
 80186b0:	37b0      	adds	r7, #176	; 0xb0
 80186b2:	46bd      	mov	sp, r7
 80186b4:	bd80      	pop	{r7, pc}

080186b6 <grad_get>:

LV_ATTRIBUTE_FAST_MEM static inline lv_color_t grad_get(const lv_draw_rect_dsc_t * dsc, lv_coord_t s, lv_coord_t i)
{
 80186b6:	b580      	push	{r7, lr}
 80186b8:	b086      	sub	sp, #24
 80186ba:	af00      	add	r7, sp, #0
 80186bc:	6078      	str	r0, [r7, #4]
 80186be:	460b      	mov	r3, r1
 80186c0:	807b      	strh	r3, [r7, #2]
 80186c2:	4613      	mov	r3, r2
 80186c4:	803b      	strh	r3, [r7, #0]
    int32_t min = (dsc->bg_main_color_stop * s) >> 8;
 80186c6:	687b      	ldr	r3, [r7, #4]
 80186c8:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 80186cc:	461a      	mov	r2, r3
 80186ce:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80186d2:	fb02 f303 	mul.w	r3, r2, r3
 80186d6:	121b      	asrs	r3, r3, #8
 80186d8:	617b      	str	r3, [r7, #20]
    if(i <= min) return dsc->bg_color;
 80186da:	f9b7 3000 	ldrsh.w	r3, [r7]
 80186de:	697a      	ldr	r2, [r7, #20]
 80186e0:	429a      	cmp	r2, r3
 80186e2:	db02      	blt.n	80186ea <grad_get+0x34>
 80186e4:	687b      	ldr	r3, [r7, #4]
 80186e6:	885b      	ldrh	r3, [r3, #2]
 80186e8:	e038      	b.n	801875c <grad_get+0xa6>

    int32_t max = (dsc->bg_grad_color_stop * s) >> 8;
 80186ea:	687b      	ldr	r3, [r7, #4]
 80186ec:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 80186f0:	461a      	mov	r2, r3
 80186f2:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80186f6:	fb02 f303 	mul.w	r3, r2, r3
 80186fa:	121b      	asrs	r3, r3, #8
 80186fc:	613b      	str	r3, [r7, #16]
    if(i >= max) return dsc->bg_grad_color;
 80186fe:	f9b7 3000 	ldrsh.w	r3, [r7]
 8018702:	693a      	ldr	r2, [r7, #16]
 8018704:	429a      	cmp	r2, r3
 8018706:	dc02      	bgt.n	801870e <grad_get+0x58>
 8018708:	687b      	ldr	r3, [r7, #4]
 801870a:	889b      	ldrh	r3, [r3, #4]
 801870c:	e026      	b.n	801875c <grad_get+0xa6>

    int32_t d = dsc->bg_grad_color_stop - dsc->bg_main_color_stop;
 801870e:	687b      	ldr	r3, [r7, #4]
 8018710:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8018714:	461a      	mov	r2, r3
 8018716:	687b      	ldr	r3, [r7, #4]
 8018718:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 801871c:	1ad3      	subs	r3, r2, r3
 801871e:	60fb      	str	r3, [r7, #12]
    d = (s * d) >> 8;
 8018720:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8018724:	68fa      	ldr	r2, [r7, #12]
 8018726:	fb02 f303 	mul.w	r3, r2, r3
 801872a:	121b      	asrs	r3, r3, #8
 801872c:	60fb      	str	r3, [r7, #12]
    i -= min;
 801872e:	883a      	ldrh	r2, [r7, #0]
 8018730:	697b      	ldr	r3, [r7, #20]
 8018732:	b29b      	uxth	r3, r3
 8018734:	1ad3      	subs	r3, r2, r3
 8018736:	b29b      	uxth	r3, r3
 8018738:	803b      	strh	r3, [r7, #0]
    lv_opa_t mix = (i * 255) / d;
 801873a:	f9b7 2000 	ldrsh.w	r2, [r7]
 801873e:	4613      	mov	r3, r2
 8018740:	021b      	lsls	r3, r3, #8
 8018742:	1a9a      	subs	r2, r3, r2
 8018744:	68fb      	ldr	r3, [r7, #12]
 8018746:	fb92 f3f3 	sdiv	r3, r2, r3
 801874a:	72fb      	strb	r3, [r7, #11]
    return lv_color_mix(dsc->bg_grad_color, dsc->bg_color, mix);
 801874c:	7afa      	ldrb	r2, [r7, #11]
 801874e:	6879      	ldr	r1, [r7, #4]
 8018750:	687b      	ldr	r3, [r7, #4]
 8018752:	8849      	ldrh	r1, [r1, #2]
 8018754:	8898      	ldrh	r0, [r3, #4]
 8018756:	f7fe ffe1 	bl	801771c <lv_color_mix>
 801875a:	4603      	mov	r3, r0
}
 801875c:	4618      	mov	r0, r3
 801875e:	3718      	adds	r7, #24
 8018760:	46bd      	mov	sp, r7
 8018762:	bd80      	pop	{r7, pc}

08018764 <draw_shadow>:

#if LV_USE_SHADOW
LV_ATTRIBUTE_FAST_MEM static void draw_shadow(const lv_area_t * coords, const lv_area_t * clip,
                                              const lv_draw_rect_dsc_t * dsc)
{
 8018764:	b590      	push	{r4, r7, lr}
 8018766:	b0cb      	sub	sp, #300	; 0x12c
 8018768:	af04      	add	r7, sp, #16
 801876a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801876e:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8018772:	6018      	str	r0, [r3, #0]
 8018774:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018778:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 801877c:	6019      	str	r1, [r3, #0]
 801877e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018782:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018786:	601a      	str	r2, [r3, #0]
    /*Check whether the shadow is visible*/
    if(dsc->shadow_width == 0) return;
 8018788:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801878c:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018790:	681b      	ldr	r3, [r3, #0]
 8018792:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
 8018796:	2b00      	cmp	r3, #0
 8018798:	f001 83fb 	beq.w	8019f92 <draw_shadow+0x182e>
    if(dsc->shadow_opa <= LV_OPA_MIN) return;
 801879c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80187a0:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80187a4:	681b      	ldr	r3, [r3, #0]
 80187a6:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 80187aa:	2b02      	cmp	r3, #2
 80187ac:	f241 83f3 	bls.w	8019f96 <draw_shadow+0x1832>

    if(dsc->shadow_width == 1 && dsc->shadow_ofs_x == 0 &&
 80187b0:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80187b4:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80187b8:	681b      	ldr	r3, [r3, #0]
 80187ba:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
 80187be:	2b01      	cmp	r3, #1
 80187c0:	d11b      	bne.n	80187fa <draw_shadow+0x96>
 80187c2:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80187c6:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80187ca:	681b      	ldr	r3, [r3, #0]
 80187cc:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
 80187d0:	2b00      	cmp	r3, #0
 80187d2:	d112      	bne.n	80187fa <draw_shadow+0x96>
       dsc->shadow_ofs_y == 0 && dsc->shadow_spread <= 0) {
 80187d4:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80187d8:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80187dc:	681b      	ldr	r3, [r3, #0]
 80187de:	f9b3 3026 	ldrsh.w	r3, [r3, #38]	; 0x26
    if(dsc->shadow_width == 1 && dsc->shadow_ofs_x == 0 &&
 80187e2:	2b00      	cmp	r3, #0
 80187e4:	d109      	bne.n	80187fa <draw_shadow+0x96>
       dsc->shadow_ofs_y == 0 && dsc->shadow_spread <= 0) {
 80187e6:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80187ea:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80187ee:	681b      	ldr	r3, [r3, #0]
 80187f0:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 80187f4:	2b00      	cmp	r3, #0
 80187f6:	f341 83d0 	ble.w	8019f9a <draw_shadow+0x1836>
        return;
    }

    int32_t sw = dsc->shadow_width;
 80187fa:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80187fe:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018802:	681b      	ldr	r3, [r3, #0]
 8018804:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
 8018808:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4

    lv_area_t sh_rect_area;
    sh_rect_area.x1 = coords->x1  + dsc->shadow_ofs_x - dsc->shadow_spread;
 801880c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018810:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8018814:	681b      	ldr	r3, [r3, #0]
 8018816:	f9b3 3000 	ldrsh.w	r3, [r3]
 801881a:	b29a      	uxth	r2, r3
 801881c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018820:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018824:	681b      	ldr	r3, [r3, #0]
 8018826:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
 801882a:	b29b      	uxth	r3, r3
 801882c:	4413      	add	r3, r2
 801882e:	b29a      	uxth	r2, r3
 8018830:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018834:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018838:	681b      	ldr	r3, [r3, #0]
 801883a:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 801883e:	b29b      	uxth	r3, r3
 8018840:	1ad3      	subs	r3, r2, r3
 8018842:	b29b      	uxth	r3, r3
 8018844:	b21b      	sxth	r3, r3
 8018846:	f8a7 309c 	strh.w	r3, [r7, #156]	; 0x9c
    sh_rect_area.x2 = coords->x2  + dsc->shadow_ofs_x + dsc->shadow_spread;
 801884a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801884e:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8018852:	681b      	ldr	r3, [r3, #0]
 8018854:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8018858:	b29a      	uxth	r2, r3
 801885a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801885e:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018862:	681b      	ldr	r3, [r3, #0]
 8018864:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
 8018868:	b29b      	uxth	r3, r3
 801886a:	4413      	add	r3, r2
 801886c:	b29a      	uxth	r2, r3
 801886e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018872:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018876:	681b      	ldr	r3, [r3, #0]
 8018878:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 801887c:	b29b      	uxth	r3, r3
 801887e:	4413      	add	r3, r2
 8018880:	b29b      	uxth	r3, r3
 8018882:	b21b      	sxth	r3, r3
 8018884:	f8a7 30a0 	strh.w	r3, [r7, #160]	; 0xa0
    sh_rect_area.y1 = coords->y1  + dsc->shadow_ofs_y - dsc->shadow_spread;
 8018888:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801888c:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8018890:	681b      	ldr	r3, [r3, #0]
 8018892:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8018896:	b29a      	uxth	r2, r3
 8018898:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801889c:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80188a0:	681b      	ldr	r3, [r3, #0]
 80188a2:	f9b3 3026 	ldrsh.w	r3, [r3, #38]	; 0x26
 80188a6:	b29b      	uxth	r3, r3
 80188a8:	4413      	add	r3, r2
 80188aa:	b29a      	uxth	r2, r3
 80188ac:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80188b0:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80188b4:	681b      	ldr	r3, [r3, #0]
 80188b6:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 80188ba:	b29b      	uxth	r3, r3
 80188bc:	1ad3      	subs	r3, r2, r3
 80188be:	b29b      	uxth	r3, r3
 80188c0:	b21b      	sxth	r3, r3
 80188c2:	f8a7 309e 	strh.w	r3, [r7, #158]	; 0x9e
    sh_rect_area.y2 = coords->y2  + dsc->shadow_ofs_y + dsc->shadow_spread;
 80188c6:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80188ca:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 80188ce:	681b      	ldr	r3, [r3, #0]
 80188d0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80188d4:	b29a      	uxth	r2, r3
 80188d6:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80188da:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80188de:	681b      	ldr	r3, [r3, #0]
 80188e0:	f9b3 3026 	ldrsh.w	r3, [r3, #38]	; 0x26
 80188e4:	b29b      	uxth	r3, r3
 80188e6:	4413      	add	r3, r2
 80188e8:	b29a      	uxth	r2, r3
 80188ea:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80188ee:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80188f2:	681b      	ldr	r3, [r3, #0]
 80188f4:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 80188f8:	b29b      	uxth	r3, r3
 80188fa:	4413      	add	r3, r2
 80188fc:	b29b      	uxth	r3, r3
 80188fe:	b21b      	sxth	r3, r3
 8018900:	f8a7 30a2 	strh.w	r3, [r7, #162]	; 0xa2

    lv_area_t sh_area;
    sh_area.x1 = sh_rect_area.x1 - sw / 2 - 1;
 8018904:	f9b7 309c 	ldrsh.w	r3, [r7, #156]	; 0x9c
 8018908:	b29a      	uxth	r2, r3
 801890a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 801890e:	0fd9      	lsrs	r1, r3, #31
 8018910:	440b      	add	r3, r1
 8018912:	105b      	asrs	r3, r3, #1
 8018914:	425b      	negs	r3, r3
 8018916:	b29b      	uxth	r3, r3
 8018918:	4413      	add	r3, r2
 801891a:	b29b      	uxth	r3, r3
 801891c:	3b01      	subs	r3, #1
 801891e:	b29b      	uxth	r3, r3
 8018920:	b21b      	sxth	r3, r3
 8018922:	f8a7 3094 	strh.w	r3, [r7, #148]	; 0x94
    sh_area.x2 = sh_rect_area.x2 + sw / 2 + 1;
 8018926:	f9b7 30a0 	ldrsh.w	r3, [r7, #160]	; 0xa0
 801892a:	b29a      	uxth	r2, r3
 801892c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8018930:	0fd9      	lsrs	r1, r3, #31
 8018932:	440b      	add	r3, r1
 8018934:	105b      	asrs	r3, r3, #1
 8018936:	b29b      	uxth	r3, r3
 8018938:	4413      	add	r3, r2
 801893a:	b29b      	uxth	r3, r3
 801893c:	3301      	adds	r3, #1
 801893e:	b29b      	uxth	r3, r3
 8018940:	b21b      	sxth	r3, r3
 8018942:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98
    sh_area.y1 = sh_rect_area.y1 - sw / 2 - 1;
 8018946:	f9b7 309e 	ldrsh.w	r3, [r7, #158]	; 0x9e
 801894a:	b29a      	uxth	r2, r3
 801894c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8018950:	0fd9      	lsrs	r1, r3, #31
 8018952:	440b      	add	r3, r1
 8018954:	105b      	asrs	r3, r3, #1
 8018956:	425b      	negs	r3, r3
 8018958:	b29b      	uxth	r3, r3
 801895a:	4413      	add	r3, r2
 801895c:	b29b      	uxth	r3, r3
 801895e:	3b01      	subs	r3, #1
 8018960:	b29b      	uxth	r3, r3
 8018962:	b21b      	sxth	r3, r3
 8018964:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96
    sh_area.y2 = sh_rect_area.y2 + sw / 2 + 1;
 8018968:	f9b7 30a2 	ldrsh.w	r3, [r7, #162]	; 0xa2
 801896c:	b29a      	uxth	r2, r3
 801896e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8018972:	0fd9      	lsrs	r1, r3, #31
 8018974:	440b      	add	r3, r1
 8018976:	105b      	asrs	r3, r3, #1
 8018978:	b29b      	uxth	r3, r3
 801897a:	4413      	add	r3, r2
 801897c:	b29b      	uxth	r3, r3
 801897e:	3301      	adds	r3, #1
 8018980:	b29b      	uxth	r3, r3
 8018982:	b21b      	sxth	r3, r3
 8018984:	f8a7 309a 	strh.w	r3, [r7, #154]	; 0x9a

    lv_opa_t opa = dsc->shadow_opa;
 8018988:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801898c:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018990:	681b      	ldr	r3, [r3, #0]
 8018992:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 8018996:	f887 3117 	strb.w	r3, [r7, #279]	; 0x117

    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 801899a:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
 801899e:	2bfd      	cmp	r3, #253	; 0xfd
 80189a0:	d902      	bls.n	80189a8 <draw_shadow+0x244>
 80189a2:	23ff      	movs	r3, #255	; 0xff
 80189a4:	f887 3117 	strb.w	r3, [r7, #279]	; 0x117

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
 80189a8:	f7f5 fd1a 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 80189ac:	f8c7 00f0 	str.w	r0, [r7, #240]	; 0xf0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 80189b0:	f8d7 00f0 	ldr.w	r0, [r7, #240]	; 0xf0
 80189b4:	f006 f92a 	bl	801ec0c <lv_disp_get_buf>
 80189b8:	f8c7 00ec 	str.w	r0, [r7, #236]	; 0xec

    /* Get clipped fill area which is the real draw area.
     * It is always the same or inside `fill_area` */
    lv_area_t draw_area;
    bool is_common;
    is_common = _lv_area_intersect(&draw_area, &sh_area, clip);
 80189bc:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80189c0:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 80189c4:	f107 0194 	add.w	r1, r7, #148	; 0x94
 80189c8:	f107 008c 	add.w	r0, r7, #140	; 0x8c
 80189cc:	681a      	ldr	r2, [r3, #0]
 80189ce:	f006 fd4d 	bl	801f46c <_lv_area_intersect>
 80189d2:	4603      	mov	r3, r0
 80189d4:	f887 30eb 	strb.w	r3, [r7, #235]	; 0xeb
    if(is_common == false) return;
 80189d8:	f897 30eb 	ldrb.w	r3, [r7, #235]	; 0xeb
 80189dc:	f083 0301 	eor.w	r3, r3, #1
 80189e0:	b2db      	uxtb	r3, r3
 80189e2:	2b00      	cmp	r3, #0
 80189e4:	f041 82db 	bne.w	8019f9e <draw_shadow+0x183a>

    const lv_area_t * disp_area = &vdb->area;
 80189e8:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 80189ec:	3310      	adds	r3, #16
 80189ee:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4

    /* Now `draw_area` has absolute coordinates.
     * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
    draw_area.x1 -= disp_area->x1;
 80189f2:	f9b7 308c 	ldrsh.w	r3, [r7, #140]	; 0x8c
 80189f6:	b29a      	uxth	r2, r3
 80189f8:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 80189fc:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018a00:	b29b      	uxth	r3, r3
 8018a02:	1ad3      	subs	r3, r2, r3
 8018a04:	b29b      	uxth	r3, r3
 8018a06:	b21b      	sxth	r3, r3
 8018a08:	f8a7 308c 	strh.w	r3, [r7, #140]	; 0x8c
    draw_area.y1 -= disp_area->y1;
 8018a0c:	f9b7 308e 	ldrsh.w	r3, [r7, #142]	; 0x8e
 8018a10:	b29a      	uxth	r2, r3
 8018a12:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8018a16:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8018a1a:	b29b      	uxth	r3, r3
 8018a1c:	1ad3      	subs	r3, r2, r3
 8018a1e:	b29b      	uxth	r3, r3
 8018a20:	b21b      	sxth	r3, r3
 8018a22:	f8a7 308e 	strh.w	r3, [r7, #142]	; 0x8e
    draw_area.x2 -= disp_area->x1;
 8018a26:	f9b7 3090 	ldrsh.w	r3, [r7, #144]	; 0x90
 8018a2a:	b29a      	uxth	r2, r3
 8018a2c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8018a30:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018a34:	b29b      	uxth	r3, r3
 8018a36:	1ad3      	subs	r3, r2, r3
 8018a38:	b29b      	uxth	r3, r3
 8018a3a:	b21b      	sxth	r3, r3
 8018a3c:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
    draw_area.y2 -= disp_area->y1;
 8018a40:	f9b7 3092 	ldrsh.w	r3, [r7, #146]	; 0x92
 8018a44:	b29a      	uxth	r2, r3
 8018a46:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8018a4a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8018a4e:	b29b      	uxth	r3, r3
 8018a50:	1ad3      	subs	r3, r2, r3
 8018a52:	b29b      	uxth	r3, r3
 8018a54:	b21b      	sxth	r3, r3
 8018a56:	f8a7 3092 	strh.w	r3, [r7, #146]	; 0x92

    /*Consider 1 px smaller bg to be sure the edge will be covered by the shadow*/
    lv_area_t bg_coords;
    lv_area_copy(&bg_coords, coords);
 8018a5a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018a5e:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8018a62:	f107 0284 	add.w	r2, r7, #132	; 0x84
 8018a66:	6819      	ldr	r1, [r3, #0]
 8018a68:	4610      	mov	r0, r2
 8018a6a:	f7fe fe1b 	bl	80176a4 <lv_area_copy>
    bg_coords.x1 += 1;
 8018a6e:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 8018a72:	b29b      	uxth	r3, r3
 8018a74:	3301      	adds	r3, #1
 8018a76:	b29b      	uxth	r3, r3
 8018a78:	b21b      	sxth	r3, r3
 8018a7a:	f8a7 3084 	strh.w	r3, [r7, #132]	; 0x84
    bg_coords.y1 += 1;
 8018a7e:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 8018a82:	b29b      	uxth	r3, r3
 8018a84:	3301      	adds	r3, #1
 8018a86:	b29b      	uxth	r3, r3
 8018a88:	b21b      	sxth	r3, r3
 8018a8a:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
    bg_coords.x2 -= 1;
 8018a8e:	f9b7 3088 	ldrsh.w	r3, [r7, #136]	; 0x88
 8018a92:	b29b      	uxth	r3, r3
 8018a94:	3b01      	subs	r3, #1
 8018a96:	b29b      	uxth	r3, r3
 8018a98:	b21b      	sxth	r3, r3
 8018a9a:	f8a7 3088 	strh.w	r3, [r7, #136]	; 0x88
    bg_coords.y2 -= 1;
 8018a9e:	f9b7 308a 	ldrsh.w	r3, [r7, #138]	; 0x8a
 8018aa2:	b29b      	uxth	r3, r3
 8018aa4:	3b01      	subs	r3, #1
 8018aa6:	b29b      	uxth	r3, r3
 8018aa8:	b21b      	sxth	r3, r3
 8018aaa:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a

    /*Get the real radius*/
    int32_t r_bg = dsc->radius;
 8018aae:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018ab2:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018ab6:	681b      	ldr	r3, [r3, #0]
 8018ab8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018abc:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    int32_t short_side = LV_MATH_MIN(lv_area_get_width(&bg_coords), lv_area_get_height(&bg_coords));
 8018ac0:	f107 0384 	add.w	r3, r7, #132	; 0x84
 8018ac4:	4618      	mov	r0, r3
 8018ac6:	f7fe fdfb 	bl	80176c0 <lv_area_get_width>
 8018aca:	4603      	mov	r3, r0
 8018acc:	461c      	mov	r4, r3
 8018ace:	f107 0384 	add.w	r3, r7, #132	; 0x84
 8018ad2:	4618      	mov	r0, r3
 8018ad4:	f7fe fe0b 	bl	80176ee <lv_area_get_height>
 8018ad8:	4603      	mov	r3, r0
 8018ada:	429c      	cmp	r4, r3
 8018adc:	da06      	bge.n	8018aec <draw_shadow+0x388>
 8018ade:	f107 0384 	add.w	r3, r7, #132	; 0x84
 8018ae2:	4618      	mov	r0, r3
 8018ae4:	f7fe fdec 	bl	80176c0 <lv_area_get_width>
 8018ae8:	4603      	mov	r3, r0
 8018aea:	e005      	b.n	8018af8 <draw_shadow+0x394>
 8018aec:	f107 0384 	add.w	r3, r7, #132	; 0x84
 8018af0:	4618      	mov	r0, r3
 8018af2:	f7fe fdfc 	bl	80176ee <lv_area_get_height>
 8018af6:	4603      	mov	r3, r0
 8018af8:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    if(r_bg > short_side >> 1) r_bg = short_side >> 1;
 8018afc:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8018b00:	105b      	asrs	r3, r3, #1
 8018b02:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 8018b06:	429a      	cmp	r2, r3
 8018b08:	dd04      	ble.n	8018b14 <draw_shadow+0x3b0>
 8018b0a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8018b0e:	105b      	asrs	r3, r3, #1
 8018b10:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110

    int32_t r_sh = dsc->radius;
 8018b14:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018b18:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018b1c:	681b      	ldr	r3, [r3, #0]
 8018b1e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018b22:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    short_side = LV_MATH_MIN(lv_area_get_width(&sh_rect_area), lv_area_get_height(&sh_rect_area));
 8018b26:	f107 039c 	add.w	r3, r7, #156	; 0x9c
 8018b2a:	4618      	mov	r0, r3
 8018b2c:	f7fe fdc8 	bl	80176c0 <lv_area_get_width>
 8018b30:	4603      	mov	r3, r0
 8018b32:	461c      	mov	r4, r3
 8018b34:	f107 039c 	add.w	r3, r7, #156	; 0x9c
 8018b38:	4618      	mov	r0, r3
 8018b3a:	f7fe fdd8 	bl	80176ee <lv_area_get_height>
 8018b3e:	4603      	mov	r3, r0
 8018b40:	429c      	cmp	r4, r3
 8018b42:	da06      	bge.n	8018b52 <draw_shadow+0x3ee>
 8018b44:	f107 039c 	add.w	r3, r7, #156	; 0x9c
 8018b48:	4618      	mov	r0, r3
 8018b4a:	f7fe fdb9 	bl	80176c0 <lv_area_get_width>
 8018b4e:	4603      	mov	r3, r0
 8018b50:	e005      	b.n	8018b5e <draw_shadow+0x3fa>
 8018b52:	f107 039c 	add.w	r3, r7, #156	; 0x9c
 8018b56:	4618      	mov	r0, r3
 8018b58:	f7fe fdc9 	bl	80176ee <lv_area_get_height>
 8018b5c:	4603      	mov	r3, r0
 8018b5e:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
    if(r_sh > short_side >> 1) r_sh = short_side >> 1;
 8018b62:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8018b66:	105b      	asrs	r3, r3, #1
 8018b68:	f8d7 210c 	ldr.w	r2, [r7, #268]	; 0x10c
 8018b6c:	429a      	cmp	r2, r3
 8018b6e:	dd04      	ble.n	8018b7a <draw_shadow+0x416>
 8018b70:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8018b74:	105b      	asrs	r3, r3, #1
 8018b76:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c


    int32_t corner_size = sw  + r_sh;
 8018b7a:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 8018b7e:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8018b82:	4413      	add	r3, r2
 8018b84:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
            sh_cache_size = corner_size;
            sh_cache_r = r_sh;
        }
    }
#else
    sh_buf = _lv_mem_buf_get(corner_size * corner_size * sizeof(uint16_t));
 8018b88:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8018b8c:	fb03 f303 	mul.w	r3, r3, r3
 8018b90:	005b      	lsls	r3, r3, #1
 8018b92:	4618      	mov	r0, r3
 8018b94:	f008 f97c 	bl	8020e90 <_lv_mem_buf_get>
 8018b98:	f8c7 00d8 	str.w	r0, [r7, #216]	; 0xd8
    shadow_draw_corner_buf(&sh_rect_area, (uint16_t *)sh_buf, dsc->shadow_width, r_sh);
 8018b9c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018ba0:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018ba4:	681b      	ldr	r3, [r3, #0]
 8018ba6:	f9b3 2022 	ldrsh.w	r2, [r3, #34]	; 0x22
 8018baa:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8018bae:	b21b      	sxth	r3, r3
 8018bb0:	f107 009c 	add.w	r0, r7, #156	; 0x9c
 8018bb4:	f8d7 10d8 	ldr.w	r1, [r7, #216]	; 0xd8
 8018bb8:	f001 f9f6 	bl	8019fa8 <shadow_draw_corner_buf>
#endif

    lv_coord_t h_half = sh_area.y1 + lv_area_get_height(&sh_area) / 2;
 8018bbc:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 8018bc0:	b29c      	uxth	r4, r3
 8018bc2:	f107 0394 	add.w	r3, r7, #148	; 0x94
 8018bc6:	4618      	mov	r0, r3
 8018bc8:	f7fe fd91 	bl	80176ee <lv_area_get_height>
 8018bcc:	4603      	mov	r3, r0
 8018bce:	0fda      	lsrs	r2, r3, #31
 8018bd0:	4413      	add	r3, r2
 8018bd2:	105b      	asrs	r3, r3, #1
 8018bd4:	b21b      	sxth	r3, r3
 8018bd6:	b29b      	uxth	r3, r3
 8018bd8:	4423      	add	r3, r4
 8018bda:	b29b      	uxth	r3, r3
 8018bdc:	f8a7 30d6 	strh.w	r3, [r7, #214]	; 0xd6
    lv_coord_t w_half = sh_area.x1 + lv_area_get_width(&sh_area) / 2;
 8018be0:	f9b7 3094 	ldrsh.w	r3, [r7, #148]	; 0x94
 8018be4:	b29c      	uxth	r4, r3
 8018be6:	f107 0394 	add.w	r3, r7, #148	; 0x94
 8018bea:	4618      	mov	r0, r3
 8018bec:	f7fe fd68 	bl	80176c0 <lv_area_get_width>
 8018bf0:	4603      	mov	r3, r0
 8018bf2:	0fda      	lsrs	r2, r3, #31
 8018bf4:	4413      	add	r3, r2
 8018bf6:	105b      	asrs	r3, r3, #1
 8018bf8:	b21b      	sxth	r3, r3
 8018bfa:	b29b      	uxth	r3, r3
 8018bfc:	4423      	add	r3, r4
 8018bfe:	b29b      	uxth	r3, r3
 8018c00:	f8a7 30d4 	strh.w	r3, [r7, #212]	; 0xd4

    bool simple_mode = true;
 8018c04:	2301      	movs	r3, #1
 8018c06:	f887 310b 	strb.w	r3, [r7, #267]	; 0x10b
    if(lv_draw_mask_get_cnt() > 0) simple_mode = false;
 8018c0a:	f7fd fa6f 	bl	80160ec <lv_draw_mask_get_cnt>
 8018c0e:	4603      	mov	r3, r0
 8018c10:	2b00      	cmp	r3, #0
 8018c12:	d003      	beq.n	8018c1c <draw_shadow+0x4b8>
 8018c14:	2300      	movs	r3, #0
 8018c16:	f887 310b 	strb.w	r3, [r7, #267]	; 0x10b
 8018c1a:	e021      	b.n	8018c60 <draw_shadow+0x4fc>
    else if(dsc->shadow_ofs_x != 0 || dsc->shadow_ofs_y != 0) simple_mode = false;
 8018c1c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018c20:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018c24:	681b      	ldr	r3, [r3, #0]
 8018c26:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
 8018c2a:	2b00      	cmp	r3, #0
 8018c2c:	d108      	bne.n	8018c40 <draw_shadow+0x4dc>
 8018c2e:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018c32:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018c36:	681b      	ldr	r3, [r3, #0]
 8018c38:	f9b3 3026 	ldrsh.w	r3, [r3, #38]	; 0x26
 8018c3c:	2b00      	cmp	r3, #0
 8018c3e:	d003      	beq.n	8018c48 <draw_shadow+0x4e4>
 8018c40:	2300      	movs	r3, #0
 8018c42:	f887 310b 	strb.w	r3, [r7, #267]	; 0x10b
 8018c46:	e00b      	b.n	8018c60 <draw_shadow+0x4fc>
    else if(dsc->shadow_spread != 0) simple_mode = false;
 8018c48:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018c4c:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018c50:	681b      	ldr	r3, [r3, #0]
 8018c52:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8018c56:	2b00      	cmp	r3, #0
 8018c58:	d002      	beq.n	8018c60 <draw_shadow+0x4fc>
 8018c5a:	2300      	movs	r3, #0
 8018c5c:	f887 310b 	strb.w	r3, [r7, #267]	; 0x10b

    /*Create a mask*/
    lv_draw_mask_res_t mask_res;
    lv_opa_t * mask_buf = _lv_mem_buf_get(lv_area_get_width(&sh_area));
 8018c60:	f107 0394 	add.w	r3, r7, #148	; 0x94
 8018c64:	4618      	mov	r0, r3
 8018c66:	f7fe fd2b 	bl	80176c0 <lv_area_get_width>
 8018c6a:	4603      	mov	r3, r0
 8018c6c:	4618      	mov	r0, r3
 8018c6e:	f008 f90f 	bl	8020e90 <_lv_mem_buf_get>
 8018c72:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0

    lv_draw_mask_radius_param_t mask_rout_param;
    lv_draw_mask_radius_init(&mask_rout_param, &bg_coords, r_bg, true);
 8018c76:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8018c7a:	b21a      	sxth	r2, r3
 8018c7c:	f107 0184 	add.w	r1, r7, #132	; 0x84
 8018c80:	f107 0068 	add.w	r0, r7, #104	; 0x68
 8018c84:	2301      	movs	r3, #1
 8018c86:	f7fd fb7d 	bl	8016384 <lv_draw_mask_radius_init>

    int16_t mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
 8018c8a:	f107 0368 	add.w	r3, r7, #104	; 0x68
 8018c8e:	2100      	movs	r1, #0
 8018c90:	4618      	mov	r0, r3
 8018c92:	f7fd f95d 	bl	8015f50 <lv_draw_mask_add>
 8018c96:	4603      	mov	r3, r0
 8018c98:	f8a7 30ce 	strh.w	r3, [r7, #206]	; 0xce
    lv_area_t a;

    /*Draw the top right corner*/
    int32_t y;
    lv_opa_t * sh_buf_tmp;
    a.x2 = sh_area.x2;
 8018c9c:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
 8018ca0:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    a.x1 = a.x2 - corner_size + 1;
 8018ca4:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 8018ca8:	b29a      	uxth	r2, r3
 8018caa:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8018cae:	b29b      	uxth	r3, r3
 8018cb0:	1ad3      	subs	r3, r2, r3
 8018cb2:	b29b      	uxth	r3, r3
 8018cb4:	3301      	adds	r3, #1
 8018cb6:	b29b      	uxth	r3, r3
 8018cb8:	b21b      	sxth	r3, r3
 8018cba:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    a.y1 = sh_area.y1;
 8018cbe:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 8018cc2:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
    a.y2 = a.y1 + corner_size - 1;
 8018cc6:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8018cca:	b29a      	uxth	r2, r3
 8018ccc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8018cd0:	b29b      	uxth	r3, r3
 8018cd2:	4413      	add	r3, r2
 8018cd4:	b29b      	uxth	r3, r3
 8018cd6:	3b01      	subs	r3, #1
 8018cd8:	b29b      	uxth	r3, r3
 8018cda:	b21b      	sxth	r3, r3
 8018cdc:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

    lv_area_t ca;
    bool has_com = _lv_area_intersect(&ca, &a, clip);
 8018ce0:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018ce4:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 8018ce8:	f107 0160 	add.w	r1, r7, #96	; 0x60
 8018cec:	f107 0058 	add.w	r0, r7, #88	; 0x58
 8018cf0:	681a      	ldr	r2, [r3, #0]
 8018cf2:	f006 fbbb 	bl	801f46c <_lv_area_intersect>
 8018cf6:	4603      	mov	r3, r0
 8018cf8:	f887 30cd 	strb.w	r3, [r7, #205]	; 0xcd
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
 8018cfc:	f897 30cd 	ldrb.w	r3, [r7, #205]	; 0xcd
 8018d00:	2b00      	cmp	r3, #0
 8018d02:	f000 80c7 	beq.w	8018e94 <draw_shadow+0x730>
 8018d06:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8018d0a:	b21a      	sxth	r2, r3
 8018d0c:	f107 0184 	add.w	r1, r7, #132	; 0x84
 8018d10:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8018d14:	4618      	mov	r0, r3
 8018d16:	f006 fd8b 	bl	801f830 <_lv_area_is_in>
 8018d1a:	4603      	mov	r3, r0
 8018d1c:	f083 0301 	eor.w	r3, r3, #1
 8018d20:	b2db      	uxtb	r3, r3
 8018d22:	2b00      	cmp	r3, #0
 8018d24:	f000 80b6 	beq.w	8018e94 <draw_shadow+0x730>
        /*Avoid overlap in the middle with large radius*/
        if(ca.y2 > h_half) ca.y2 = h_half;
 8018d28:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8018d2c:	f9b7 20d6 	ldrsh.w	r2, [r7, #214]	; 0xd6
 8018d30:	429a      	cmp	r2, r3
 8018d32:	da03      	bge.n	8018d3c <draw_shadow+0x5d8>
 8018d34:	f8b7 30d6 	ldrh.w	r3, [r7, #214]	; 0xd6
 8018d38:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
        if(ca.x1 <= w_half) ca.x1 = w_half + 1;
 8018d3c:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8018d40:	f9b7 20d4 	ldrsh.w	r2, [r7, #212]	; 0xd4
 8018d44:	429a      	cmp	r2, r3
 8018d46:	db06      	blt.n	8018d56 <draw_shadow+0x5f2>
 8018d48:	f8b7 30d4 	ldrh.w	r3, [r7, #212]	; 0xd4
 8018d4c:	3301      	adds	r3, #1
 8018d4e:	b29b      	uxth	r3, r3
 8018d50:	b21b      	sxth	r3, r3
 8018d52:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58

        lv_coord_t h = lv_area_get_height(&ca);
 8018d56:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8018d5a:	4618      	mov	r0, r3
 8018d5c:	f7fe fcc7 	bl	80176ee <lv_area_get_height>
 8018d60:	4603      	mov	r3, r0
 8018d62:	f8a7 30ca 	strh.w	r3, [r7, #202]	; 0xca
        lv_coord_t w = lv_area_get_width(&ca);
 8018d66:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8018d6a:	4618      	mov	r0, r3
 8018d6c:	f7fe fca8 	bl	80176c0 <lv_area_get_width>
 8018d70:	4603      	mov	r3, r0
 8018d72:	f8a7 30c8 	strh.w	r3, [r7, #200]	; 0xc8
        if(w > 0) {
 8018d76:	f9b7 30c8 	ldrsh.w	r3, [r7, #200]	; 0xc8
 8018d7a:	2b00      	cmp	r3, #0
 8018d7c:	f340 808a 	ble.w	8018e94 <draw_shadow+0x730>
            sh_buf_tmp = sh_buf + (ca.x1 - a.x1);
 8018d80:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8018d84:	461a      	mov	r2, r3
 8018d86:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 8018d8a:	1ad3      	subs	r3, r2, r3
 8018d8c:	461a      	mov	r2, r3
 8018d8e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8018d92:	4413      	add	r3, r2
 8018d94:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
            sh_buf_tmp += corner_size * (ca.y1 - a.y1);
 8018d98:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8018d9c:	461a      	mov	r2, r3
 8018d9e:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8018da2:	1ad3      	subs	r3, r2, r3
 8018da4:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8018da8:	fb02 f303 	mul.w	r3, r2, r3
 8018dac:	461a      	mov	r2, r3
 8018dae:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8018db2:	4413      	add	r3, r2
 8018db4:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

            lv_area_t fa;
            lv_area_copy(&fa, &ca);
 8018db8:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8018dbc:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8018dc0:	4611      	mov	r1, r2
 8018dc2:	4618      	mov	r0, r3
 8018dc4:	f7fe fc6e 	bl	80176a4 <lv_area_copy>
            fa.y2 = fa.y1;
 8018dc8:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8018dcc:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56

            for(y = 0; y < h; y++) {
 8018dd0:	2300      	movs	r3, #0
 8018dd2:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8018dd6:	e057      	b.n	8018e88 <draw_shadow+0x724>
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
 8018dd8:	f9b7 30c8 	ldrsh.w	r3, [r7, #200]	; 0xc8
 8018ddc:	461a      	mov	r2, r3
 8018dde:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
 8018de2:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8018de6:	f008 f9b9 	bl	802115c <_lv_memcpy>
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
 8018dea:	f9b7 1050 	ldrsh.w	r1, [r7, #80]	; 0x50
 8018dee:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 8018df2:	f9b7 30c8 	ldrsh.w	r3, [r7, #200]	; 0xc8
 8018df6:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8018dfa:	f7fd f8db 	bl	8015fb4 <lv_draw_mask_apply>
 8018dfe:	4603      	mov	r3, r0
 8018e00:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
 8018e04:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8018e08:	2b01      	cmp	r3, #1
 8018e0a:	d102      	bne.n	8018e12 <draw_shadow+0x6ae>
 8018e0c:	2302      	movs	r3, #2
 8018e0e:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a

                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
                               mask_res, opa, dsc->shadow_blend_mode);
 8018e12:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018e16:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8018e1a:	681b      	ldr	r3, [r3, #0]
 8018e1c:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
 8018e20:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8018e24:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 8018e28:	6812      	ldr	r2, [r2, #0]
 8018e2a:	f107 0150 	add.w	r1, r7, #80	; 0x50
 8018e2e:	f507 708c 	add.w	r0, r7, #280	; 0x118
 8018e32:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
 8018e36:	9302      	str	r3, [sp, #8]
 8018e38:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
 8018e3c:	9301      	str	r3, [sp, #4]
 8018e3e:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8018e42:	9300      	str	r3, [sp, #0]
 8018e44:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8018e48:	8c12      	ldrh	r2, [r2, #32]
 8018e4a:	6800      	ldr	r0, [r0, #0]
 8018e4c:	f7f7 fd0a 	bl	8010864 <_lv_blend_fill>
                fa.y1++;
 8018e50:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8018e54:	b29b      	uxth	r3, r3
 8018e56:	3301      	adds	r3, #1
 8018e58:	b29b      	uxth	r3, r3
 8018e5a:	b21b      	sxth	r3, r3
 8018e5c:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                fa.y2++;
 8018e60:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8018e64:	b29b      	uxth	r3, r3
 8018e66:	3301      	adds	r3, #1
 8018e68:	b29b      	uxth	r3, r3
 8018e6a:	b21b      	sxth	r3, r3
 8018e6c:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
                sh_buf_tmp += corner_size;
 8018e70:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8018e74:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8018e78:	4413      	add	r3, r2
 8018e7a:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
            for(y = 0; y < h; y++) {
 8018e7e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8018e82:	3301      	adds	r3, #1
 8018e84:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8018e88:	f9b7 30ca 	ldrsh.w	r3, [r7, #202]	; 0xca
 8018e8c:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8018e90:	429a      	cmp	r2, r3
 8018e92:	dba1      	blt.n	8018dd8 <draw_shadow+0x674>
            }
        }
    }

    /*Draw the bottom right corner*/
    a.x2 = sh_area.x2;
 8018e94:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
 8018e98:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    a.x1 = a.x2 - corner_size + 1;
 8018e9c:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 8018ea0:	b29a      	uxth	r2, r3
 8018ea2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8018ea6:	b29b      	uxth	r3, r3
 8018ea8:	1ad3      	subs	r3, r2, r3
 8018eaa:	b29b      	uxth	r3, r3
 8018eac:	3301      	adds	r3, #1
 8018eae:	b29b      	uxth	r3, r3
 8018eb0:	b21b      	sxth	r3, r3
 8018eb2:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    a.y1 = sh_area.y2 - corner_size + 1;
 8018eb6:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 8018eba:	b29a      	uxth	r2, r3
 8018ebc:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8018ec0:	b29b      	uxth	r3, r3
 8018ec2:	1ad3      	subs	r3, r2, r3
 8018ec4:	b29b      	uxth	r3, r3
 8018ec6:	3301      	adds	r3, #1
 8018ec8:	b29b      	uxth	r3, r3
 8018eca:	b21b      	sxth	r3, r3
 8018ecc:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
    a.y2 = sh_area.y2;
 8018ed0:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 8018ed4:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

    has_com = _lv_area_intersect(&ca, &a, clip);
 8018ed8:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8018edc:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 8018ee0:	f107 0160 	add.w	r1, r7, #96	; 0x60
 8018ee4:	f107 0058 	add.w	r0, r7, #88	; 0x58
 8018ee8:	681a      	ldr	r2, [r3, #0]
 8018eea:	f006 fabf 	bl	801f46c <_lv_area_intersect>
 8018eee:	4603      	mov	r3, r0
 8018ef0:	f887 30cd 	strb.w	r3, [r7, #205]	; 0xcd
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
 8018ef4:	f897 30cd 	ldrb.w	r3, [r7, #205]	; 0xcd
 8018ef8:	2b00      	cmp	r3, #0
 8018efa:	f000 80ca 	beq.w	8019092 <draw_shadow+0x92e>
 8018efe:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8018f02:	b21a      	sxth	r2, r3
 8018f04:	f107 0184 	add.w	r1, r7, #132	; 0x84
 8018f08:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8018f0c:	4618      	mov	r0, r3
 8018f0e:	f006 fc8f 	bl	801f830 <_lv_area_is_in>
 8018f12:	4603      	mov	r3, r0
 8018f14:	f083 0301 	eor.w	r3, r3, #1
 8018f18:	b2db      	uxtb	r3, r3
 8018f1a:	2b00      	cmp	r3, #0
 8018f1c:	f000 80b9 	beq.w	8019092 <draw_shadow+0x92e>
        /*Avoid overlap in the middle with large radius*/
        if(ca.y1 <= h_half) ca.y1 = h_half + 1;
 8018f20:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8018f24:	f9b7 20d6 	ldrsh.w	r2, [r7, #214]	; 0xd6
 8018f28:	429a      	cmp	r2, r3
 8018f2a:	db06      	blt.n	8018f3a <draw_shadow+0x7d6>
 8018f2c:	f8b7 30d6 	ldrh.w	r3, [r7, #214]	; 0xd6
 8018f30:	3301      	adds	r3, #1
 8018f32:	b29b      	uxth	r3, r3
 8018f34:	b21b      	sxth	r3, r3
 8018f36:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
        if(ca.x1 <= w_half) ca.x1 = w_half + 1;
 8018f3a:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8018f3e:	f9b7 20d4 	ldrsh.w	r2, [r7, #212]	; 0xd4
 8018f42:	429a      	cmp	r2, r3
 8018f44:	db06      	blt.n	8018f54 <draw_shadow+0x7f0>
 8018f46:	f8b7 30d4 	ldrh.w	r3, [r7, #212]	; 0xd4
 8018f4a:	3301      	adds	r3, #1
 8018f4c:	b29b      	uxth	r3, r3
 8018f4e:	b21b      	sxth	r3, r3
 8018f50:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58

        lv_coord_t h = lv_area_get_height(&ca);
 8018f54:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8018f58:	4618      	mov	r0, r3
 8018f5a:	f7fe fbc8 	bl	80176ee <lv_area_get_height>
 8018f5e:	4603      	mov	r3, r0
 8018f60:	f8a7 30c6 	strh.w	r3, [r7, #198]	; 0xc6
        lv_coord_t w = lv_area_get_width(&ca);
 8018f64:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8018f68:	4618      	mov	r0, r3
 8018f6a:	f7fe fba9 	bl	80176c0 <lv_area_get_width>
 8018f6e:	4603      	mov	r3, r0
 8018f70:	f8a7 30c4 	strh.w	r3, [r7, #196]	; 0xc4

        if(w > 0) {
 8018f74:	f9b7 30c4 	ldrsh.w	r3, [r7, #196]	; 0xc4
 8018f78:	2b00      	cmp	r3, #0
 8018f7a:	f340 808a 	ble.w	8019092 <draw_shadow+0x92e>
            sh_buf_tmp = sh_buf + (ca.x1 - a.x1);
 8018f7e:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8018f82:	461a      	mov	r2, r3
 8018f84:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 8018f88:	1ad3      	subs	r3, r2, r3
 8018f8a:	461a      	mov	r2, r3
 8018f8c:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8018f90:	4413      	add	r3, r2
 8018f92:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
            sh_buf_tmp += corner_size * (a.y2 - ca.y2);
 8018f96:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 8018f9a:	461a      	mov	r2, r3
 8018f9c:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8018fa0:	1ad3      	subs	r3, r2, r3
 8018fa2:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8018fa6:	fb02 f303 	mul.w	r3, r2, r3
 8018faa:	461a      	mov	r2, r3
 8018fac:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8018fb0:	4413      	add	r3, r2
 8018fb2:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

            lv_area_t fa;
            lv_area_copy(&fa, &ca);
 8018fb6:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8018fba:	f107 0348 	add.w	r3, r7, #72	; 0x48
 8018fbe:	4611      	mov	r1, r2
 8018fc0:	4618      	mov	r0, r3
 8018fc2:	f7fe fb6f 	bl	80176a4 <lv_area_copy>
            fa.y1 = fa.y2;    /*Fill from bottom to top*/
 8018fc6:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8018fca:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a

            for(y = 0; y < h; y++) {
 8018fce:	2300      	movs	r3, #0
 8018fd0:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8018fd4:	e057      	b.n	8019086 <draw_shadow+0x922>
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
 8018fd6:	f9b7 30c4 	ldrsh.w	r3, [r7, #196]	; 0xc4
 8018fda:	461a      	mov	r2, r3
 8018fdc:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
 8018fe0:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8018fe4:	f008 f8ba 	bl	802115c <_lv_memcpy>
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
 8018fe8:	f9b7 1048 	ldrsh.w	r1, [r7, #72]	; 0x48
 8018fec:	f9b7 204a 	ldrsh.w	r2, [r7, #74]	; 0x4a
 8018ff0:	f9b7 30c4 	ldrsh.w	r3, [r7, #196]	; 0xc4
 8018ff4:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8018ff8:	f7fc ffdc 	bl	8015fb4 <lv_draw_mask_apply>
 8018ffc:	4603      	mov	r3, r0
 8018ffe:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
 8019002:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019006:	2b01      	cmp	r3, #1
 8019008:	d102      	bne.n	8019010 <draw_shadow+0x8ac>
 801900a:	2302      	movs	r3, #2
 801900c:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a

                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
                               mask_res, opa, dsc->shadow_blend_mode);
 8019010:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019014:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8019018:	681b      	ldr	r3, [r3, #0]
 801901a:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
 801901e:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8019022:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 8019026:	6812      	ldr	r2, [r2, #0]
 8019028:	f107 0148 	add.w	r1, r7, #72	; 0x48
 801902c:	f507 708c 	add.w	r0, r7, #280	; 0x118
 8019030:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
 8019034:	9302      	str	r3, [sp, #8]
 8019036:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
 801903a:	9301      	str	r3, [sp, #4]
 801903c:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019040:	9300      	str	r3, [sp, #0]
 8019042:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8019046:	8c12      	ldrh	r2, [r2, #32]
 8019048:	6800      	ldr	r0, [r0, #0]
 801904a:	f7f7 fc0b 	bl	8010864 <_lv_blend_fill>
                fa.y1--;
 801904e:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 8019052:	b29b      	uxth	r3, r3
 8019054:	3b01      	subs	r3, #1
 8019056:	b29b      	uxth	r3, r3
 8019058:	b21b      	sxth	r3, r3
 801905a:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
                fa.y2--;
 801905e:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8019062:	b29b      	uxth	r3, r3
 8019064:	3b01      	subs	r3, #1
 8019066:	b29b      	uxth	r3, r3
 8019068:	b21b      	sxth	r3, r3
 801906a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
                sh_buf_tmp += corner_size;
 801906e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019072:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8019076:	4413      	add	r3, r2
 8019078:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
            for(y = 0; y < h; y++) {
 801907c:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8019080:	3301      	adds	r3, #1
 8019082:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8019086:	f9b7 30c6 	ldrsh.w	r3, [r7, #198]	; 0xc6
 801908a:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 801908e:	429a      	cmp	r2, r3
 8019090:	dba1      	blt.n	8018fd6 <draw_shadow+0x872>
            }
        }
    }

    /*Fill the right side*/
    a.x2 = sh_area.x2;
 8019092:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
 8019096:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    a.x1 = a.x2 - corner_size + 1;
 801909a:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 801909e:	b29a      	uxth	r2, r3
 80190a0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80190a4:	b29b      	uxth	r3, r3
 80190a6:	1ad3      	subs	r3, r2, r3
 80190a8:	b29b      	uxth	r3, r3
 80190aa:	3301      	adds	r3, #1
 80190ac:	b29b      	uxth	r3, r3
 80190ae:	b21b      	sxth	r3, r3
 80190b0:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    a.y1 = sh_area.y1 + corner_size;
 80190b4:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 80190b8:	b29a      	uxth	r2, r3
 80190ba:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80190be:	b29b      	uxth	r3, r3
 80190c0:	4413      	add	r3, r2
 80190c2:	b29b      	uxth	r3, r3
 80190c4:	b21b      	sxth	r3, r3
 80190c6:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
    a.y2 = sh_area.y2 - corner_size;
 80190ca:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 80190ce:	b29a      	uxth	r2, r3
 80190d0:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80190d4:	b29b      	uxth	r3, r3
 80190d6:	1ad3      	subs	r3, r2, r3
 80190d8:	b29b      	uxth	r3, r3
 80190da:	b21b      	sxth	r3, r3
 80190dc:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

    has_com = _lv_area_intersect(&ca, &a, clip);
 80190e0:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80190e4:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 80190e8:	f107 0160 	add.w	r1, r7, #96	; 0x60
 80190ec:	f107 0058 	add.w	r0, r7, #88	; 0x58
 80190f0:	681a      	ldr	r2, [r3, #0]
 80190f2:	f006 f9bb 	bl	801f46c <_lv_area_intersect>
 80190f6:	4603      	mov	r3, r0
 80190f8:	f887 30cd 	strb.w	r3, [r7, #205]	; 0xcd
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
 80190fc:	f897 30cd 	ldrb.w	r3, [r7, #205]	; 0xcd
 8019100:	2b00      	cmp	r3, #0
 8019102:	f000 80ca 	beq.w	801929a <draw_shadow+0xb36>
 8019106:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 801910a:	b21a      	sxth	r2, r3
 801910c:	f107 0184 	add.w	r1, r7, #132	; 0x84
 8019110:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8019114:	4618      	mov	r0, r3
 8019116:	f006 fb8b 	bl	801f830 <_lv_area_is_in>
 801911a:	4603      	mov	r3, r0
 801911c:	f083 0301 	eor.w	r3, r3, #1
 8019120:	b2db      	uxtb	r3, r3
 8019122:	2b00      	cmp	r3, #0
 8019124:	f000 80b9 	beq.w	801929a <draw_shadow+0xb36>
        if(simple_mode) ca.x1 = LV_MATH_MAX(ca.x1, coords->x2);
 8019128:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 801912c:	2b00      	cmp	r3, #0
 801912e:	d00e      	beq.n	801914e <draw_shadow+0x9ea>
 8019130:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019134:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8019138:	681b      	ldr	r3, [r3, #0]
 801913a:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801913e:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8019142:	4293      	cmp	r3, r2
 8019144:	bfb8      	it	lt
 8019146:	4613      	movlt	r3, r2
 8019148:	b21b      	sxth	r3, r3
 801914a:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
        /*Draw horizontal lines*/
        lv_coord_t w = lv_area_get_width(&ca);
 801914e:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8019152:	4618      	mov	r0, r3
 8019154:	f7fe fab4 	bl	80176c0 <lv_area_get_width>
 8019158:	4603      	mov	r3, r0
 801915a:	f8a7 30c2 	strh.w	r3, [r7, #194]	; 0xc2
        if(w > 0) {
 801915e:	f9b7 30c2 	ldrsh.w	r3, [r7, #194]	; 0xc2
 8019162:	2b00      	cmp	r3, #0
 8019164:	f340 8099 	ble.w	801929a <draw_shadow+0xb36>
            lv_coord_t h = lv_area_get_height(&ca);
 8019168:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801916c:	4618      	mov	r0, r3
 801916e:	f7fe fabe 	bl	80176ee <lv_area_get_height>
 8019172:	4603      	mov	r3, r0
 8019174:	f8a7 30c0 	strh.w	r3, [r7, #192]	; 0xc0

            /*The last line of the shadow is repeated on the side*/
            sh_buf_tmp = sh_buf + corner_size * (corner_size - 1);
 8019178:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801917c:	3b01      	subs	r3, #1
 801917e:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8019182:	fb02 f303 	mul.w	r3, r2, r3
 8019186:	461a      	mov	r2, r3
 8019188:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801918c:	4413      	add	r3, r2
 801918e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
            sh_buf_tmp += ca.x1 - a.x1;
 8019192:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8019196:	461a      	mov	r2, r3
 8019198:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 801919c:	1ad3      	subs	r3, r2, r3
 801919e:	461a      	mov	r2, r3
 80191a0:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 80191a4:	4413      	add	r3, r2
 80191a6:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

            lv_area_t fa;
            lv_area_copy(&fa, &ca);
 80191aa:	f107 0258 	add.w	r2, r7, #88	; 0x58
 80191ae:	f107 0340 	add.w	r3, r7, #64	; 0x40
 80191b2:	4611      	mov	r1, r2
 80191b4:	4618      	mov	r0, r3
 80191b6:	f7fe fa75 	bl	80176a4 <lv_area_copy>
            fa.y2 = fa.y1;
 80191ba:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 80191be:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            mask_res = LV_DRAW_MASK_RES_FULL_COVER;
 80191c2:	2301      	movs	r3, #1
 80191c4:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
            for(y = 0; y < h; y++) {
 80191c8:	2300      	movs	r3, #0
 80191ca:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 80191ce:	e05e      	b.n	801928e <draw_shadow+0xb2a>
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
 80191d0:	f9b7 30c2 	ldrsh.w	r3, [r7, #194]	; 0xc2
 80191d4:	461a      	mov	r2, r3
 80191d6:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
 80191da:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 80191de:	f007 ffbd 	bl	802115c <_lv_memcpy>

                if(simple_mode) {
 80191e2:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 80191e6:	2b00      	cmp	r3, #0
 80191e8:	d003      	beq.n	80191f2 <draw_shadow+0xa8e>
                    mask_res = LV_DRAW_MASK_RES_CHANGED;
 80191ea:	2302      	movs	r3, #2
 80191ec:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
 80191f0:	e013      	b.n	801921a <draw_shadow+0xab6>
                }
                else {
                    mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
 80191f2:	f9b7 1040 	ldrsh.w	r1, [r7, #64]	; 0x40
 80191f6:	f9b7 2042 	ldrsh.w	r2, [r7, #66]	; 0x42
 80191fa:	f9b7 30c2 	ldrsh.w	r3, [r7, #194]	; 0xc2
 80191fe:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019202:	f7fc fed7 	bl	8015fb4 <lv_draw_mask_apply>
 8019206:	4603      	mov	r3, r0
 8019208:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
 801920c:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019210:	2b01      	cmp	r3, #1
 8019212:	d102      	bne.n	801921a <draw_shadow+0xab6>
 8019214:	2302      	movs	r3, #2
 8019216:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
                }

                _lv_blend_fill(clip, &fa,
                               dsc->shadow_color, mask_buf, mask_res, dsc->shadow_opa, dsc->shadow_blend_mode);
 801921a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801921e:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8019222:	681b      	ldr	r3, [r3, #0]
 8019224:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 8019228:	f507 728c 	add.w	r2, r7, #280	; 0x118
 801922c:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 8019230:	6812      	ldr	r2, [r2, #0]
 8019232:	f892 102b 	ldrb.w	r1, [r2, #43]	; 0x2b
                _lv_blend_fill(clip, &fa,
 8019236:	f507 728c 	add.w	r2, r7, #280	; 0x118
 801923a:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 801923e:	6812      	ldr	r2, [r2, #0]
 8019240:	f107 0440 	add.w	r4, r7, #64	; 0x40
 8019244:	f507 708c 	add.w	r0, r7, #280	; 0x118
 8019248:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
 801924c:	9102      	str	r1, [sp, #8]
 801924e:	9301      	str	r3, [sp, #4]
 8019250:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019254:	9300      	str	r3, [sp, #0]
 8019256:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 801925a:	8c12      	ldrh	r2, [r2, #32]
 801925c:	4621      	mov	r1, r4
 801925e:	6800      	ldr	r0, [r0, #0]
 8019260:	f7f7 fb00 	bl	8010864 <_lv_blend_fill>
                fa.y1++;
 8019264:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8019268:	b29b      	uxth	r3, r3
 801926a:	3301      	adds	r3, #1
 801926c:	b29b      	uxth	r3, r3
 801926e:	b21b      	sxth	r3, r3
 8019270:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
                fa.y2++;
 8019274:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8019278:	b29b      	uxth	r3, r3
 801927a:	3301      	adds	r3, #1
 801927c:	b29b      	uxth	r3, r3
 801927e:	b21b      	sxth	r3, r3
 8019280:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            for(y = 0; y < h; y++) {
 8019284:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8019288:	3301      	adds	r3, #1
 801928a:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 801928e:	f9b7 30c0 	ldrsh.w	r3, [r7, #192]	; 0xc0
 8019292:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019296:	429a      	cmp	r2, r3
 8019298:	db9a      	blt.n	80191d0 <draw_shadow+0xa6c>
            }
        }
    }

    /*Invert the shadow corner buffer and draw the corners on the left*/
    sh_buf_tmp = sh_buf ;
 801929a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801929e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    for(y = 0; y < corner_size; y++) {
 80192a2:	2300      	movs	r3, #0
 80192a4:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 80192a8:	e042      	b.n	8019330 <draw_shadow+0xbcc>
        int32_t x;
        for(x = 0; x < corner_size / 2; x++) {
 80192aa:	2300      	movs	r3, #0
 80192ac:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 80192b0:	e028      	b.n	8019304 <draw_shadow+0xba0>
            lv_opa_t tmp = sh_buf_tmp[x];
 80192b2:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 80192b6:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80192ba:	4413      	add	r3, r2
 80192bc:	781b      	ldrb	r3, [r3, #0]
 80192be:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
            sh_buf_tmp[x] = sh_buf_tmp[corner_size - x - 1];
 80192c2:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 80192c6:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 80192ca:	1ad3      	subs	r3, r2, r3
 80192cc:	3b01      	subs	r3, #1
 80192ce:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80192d2:	441a      	add	r2, r3
 80192d4:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 80192d8:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
 80192dc:	440b      	add	r3, r1
 80192de:	7812      	ldrb	r2, [r2, #0]
 80192e0:	701a      	strb	r2, [r3, #0]
            sh_buf_tmp[corner_size - x - 1] = tmp;
 80192e2:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 80192e6:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 80192ea:	1ad3      	subs	r3, r2, r3
 80192ec:	3b01      	subs	r3, #1
 80192ee:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80192f2:	4413      	add	r3, r2
 80192f4:	f897 20a7 	ldrb.w	r2, [r7, #167]	; 0xa7
 80192f8:	701a      	strb	r2, [r3, #0]
        for(x = 0; x < corner_size / 2; x++) {
 80192fa:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 80192fe:	3301      	adds	r3, #1
 8019300:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
 8019304:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019308:	0fda      	lsrs	r2, r3, #31
 801930a:	4413      	add	r3, r2
 801930c:	105b      	asrs	r3, r3, #1
 801930e:	461a      	mov	r2, r3
 8019310:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8019314:	4293      	cmp	r3, r2
 8019316:	dbcc      	blt.n	80192b2 <draw_shadow+0xb4e>
        }
        sh_buf_tmp += corner_size;
 8019318:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801931c:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8019320:	4413      	add	r3, r2
 8019322:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
    for(y = 0; y < corner_size; y++) {
 8019326:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 801932a:	3301      	adds	r3, #1
 801932c:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8019330:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019334:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019338:	429a      	cmp	r2, r3
 801933a:	dbb6      	blt.n	80192aa <draw_shadow+0xb46>
    }

    /*Draw the top left corner*/
    a.x1 = sh_area.x1;
 801933c:	f9b7 3094 	ldrsh.w	r3, [r7, #148]	; 0x94
 8019340:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    a.x2 = a.x1 + corner_size - 1;
 8019344:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 8019348:	b29a      	uxth	r2, r3
 801934a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801934e:	b29b      	uxth	r3, r3
 8019350:	4413      	add	r3, r2
 8019352:	b29b      	uxth	r3, r3
 8019354:	3b01      	subs	r3, #1
 8019356:	b29b      	uxth	r3, r3
 8019358:	b21b      	sxth	r3, r3
 801935a:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    a.y1 = sh_area.y1;
 801935e:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 8019362:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
    a.y2 = a.y1 + corner_size - 1;
 8019366:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801936a:	b29a      	uxth	r2, r3
 801936c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019370:	b29b      	uxth	r3, r3
 8019372:	4413      	add	r3, r2
 8019374:	b29b      	uxth	r3, r3
 8019376:	3b01      	subs	r3, #1
 8019378:	b29b      	uxth	r3, r3
 801937a:	b21b      	sxth	r3, r3
 801937c:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

    has_com = _lv_area_intersect(&ca, &a, clip);
 8019380:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019384:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 8019388:	f107 0160 	add.w	r1, r7, #96	; 0x60
 801938c:	f107 0058 	add.w	r0, r7, #88	; 0x58
 8019390:	681a      	ldr	r2, [r3, #0]
 8019392:	f006 f86b 	bl	801f46c <_lv_area_intersect>
 8019396:	4603      	mov	r3, r0
 8019398:	f887 30cd 	strb.w	r3, [r7, #205]	; 0xcd
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
 801939c:	f897 30cd 	ldrb.w	r3, [r7, #205]	; 0xcd
 80193a0:	2b00      	cmp	r3, #0
 80193a2:	f000 80c1 	beq.w	8019528 <draw_shadow+0xdc4>
 80193a6:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 80193aa:	b21a      	sxth	r2, r3
 80193ac:	f107 0184 	add.w	r1, r7, #132	; 0x84
 80193b0:	f107 0360 	add.w	r3, r7, #96	; 0x60
 80193b4:	4618      	mov	r0, r3
 80193b6:	f006 fa3b 	bl	801f830 <_lv_area_is_in>
 80193ba:	4603      	mov	r3, r0
 80193bc:	f083 0301 	eor.w	r3, r3, #1
 80193c0:	b2db      	uxtb	r3, r3
 80193c2:	2b00      	cmp	r3, #0
 80193c4:	f000 80b0 	beq.w	8019528 <draw_shadow+0xdc4>
        /*Avoid overlap in the middle with large radius*/
        if(ca.y2 > h_half) ca.y2 = h_half;
 80193c8:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80193cc:	f9b7 20d6 	ldrsh.w	r2, [r7, #214]	; 0xd6
 80193d0:	429a      	cmp	r2, r3
 80193d2:	da03      	bge.n	80193dc <draw_shadow+0xc78>
 80193d4:	f8b7 30d6 	ldrh.w	r3, [r7, #214]	; 0xd6
 80193d8:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
        if(ca.x2 > w_half) ca.x2 = w_half;
 80193dc:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 80193e0:	f9b7 20d4 	ldrsh.w	r2, [r7, #212]	; 0xd4
 80193e4:	429a      	cmp	r2, r3
 80193e6:	da03      	bge.n	80193f0 <draw_shadow+0xc8c>
 80193e8:	f8b7 30d4 	ldrh.w	r3, [r7, #212]	; 0xd4
 80193ec:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c

        lv_coord_t h = lv_area_get_height(&ca);
 80193f0:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80193f4:	4618      	mov	r0, r3
 80193f6:	f7fe f97a 	bl	80176ee <lv_area_get_height>
 80193fa:	4603      	mov	r3, r0
 80193fc:	f8a7 30be 	strh.w	r3, [r7, #190]	; 0xbe
        lv_coord_t w = lv_area_get_width(&ca);
 8019400:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8019404:	4618      	mov	r0, r3
 8019406:	f7fe f95b 	bl	80176c0 <lv_area_get_width>
 801940a:	4603      	mov	r3, r0
 801940c:	f8a7 30bc 	strh.w	r3, [r7, #188]	; 0xbc
        if(w > 0) {
 8019410:	f9b7 30bc 	ldrsh.w	r3, [r7, #188]	; 0xbc
 8019414:	2b00      	cmp	r3, #0
 8019416:	f340 8087 	ble.w	8019528 <draw_shadow+0xdc4>
            sh_buf_tmp = sh_buf + (ca.x1 - a.x1);
 801941a:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 801941e:	461a      	mov	r2, r3
 8019420:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 8019424:	1ad3      	subs	r3, r2, r3
 8019426:	461a      	mov	r2, r3
 8019428:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801942c:	4413      	add	r3, r2
 801942e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
            sh_buf_tmp += corner_size * (ca.y1 - a.y1);
 8019432:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8019436:	461a      	mov	r2, r3
 8019438:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801943c:	1ad3      	subs	r3, r2, r3
 801943e:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8019442:	fb02 f303 	mul.w	r3, r2, r3
 8019446:	461a      	mov	r2, r3
 8019448:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 801944c:	4413      	add	r3, r2
 801944e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

            lv_area_t fa;
            lv_area_copy(&fa, &ca);
 8019452:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8019456:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801945a:	4611      	mov	r1, r2
 801945c:	4618      	mov	r0, r3
 801945e:	f7fe f921 	bl	80176a4 <lv_area_copy>
            fa.y2 = fa.y1;
 8019462:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8019466:	87fb      	strh	r3, [r7, #62]	; 0x3e

            for(y = 0; y < h; y++) {
 8019468:	2300      	movs	r3, #0
 801946a:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 801946e:	e055      	b.n	801951c <draw_shadow+0xdb8>
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
 8019470:	f9b7 30bc 	ldrsh.w	r3, [r7, #188]	; 0xbc
 8019474:	461a      	mov	r2, r3
 8019476:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
 801947a:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 801947e:	f007 fe6d 	bl	802115c <_lv_memcpy>
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
 8019482:	f9b7 1038 	ldrsh.w	r1, [r7, #56]	; 0x38
 8019486:	f9b7 203a 	ldrsh.w	r2, [r7, #58]	; 0x3a
 801948a:	f9b7 30bc 	ldrsh.w	r3, [r7, #188]	; 0xbc
 801948e:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019492:	f7fc fd8f 	bl	8015fb4 <lv_draw_mask_apply>
 8019496:	4603      	mov	r3, r0
 8019498:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
 801949c:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 80194a0:	2b01      	cmp	r3, #1
 80194a2:	d102      	bne.n	80194aa <draw_shadow+0xd46>
 80194a4:	2302      	movs	r3, #2
 80194a6:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a

                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
                               mask_res, opa, dsc->shadow_blend_mode);
 80194aa:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80194ae:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80194b2:	681b      	ldr	r3, [r3, #0]
 80194b4:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
 80194b8:	f507 728c 	add.w	r2, r7, #280	; 0x118
 80194bc:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 80194c0:	6812      	ldr	r2, [r2, #0]
 80194c2:	f107 0138 	add.w	r1, r7, #56	; 0x38
 80194c6:	f507 708c 	add.w	r0, r7, #280	; 0x118
 80194ca:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
 80194ce:	9302      	str	r3, [sp, #8]
 80194d0:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
 80194d4:	9301      	str	r3, [sp, #4]
 80194d6:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 80194da:	9300      	str	r3, [sp, #0]
 80194dc:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80194e0:	8c12      	ldrh	r2, [r2, #32]
 80194e2:	6800      	ldr	r0, [r0, #0]
 80194e4:	f7f7 f9be 	bl	8010864 <_lv_blend_fill>
                fa.y1++;
 80194e8:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 80194ec:	b29b      	uxth	r3, r3
 80194ee:	3301      	adds	r3, #1
 80194f0:	b29b      	uxth	r3, r3
 80194f2:	b21b      	sxth	r3, r3
 80194f4:	877b      	strh	r3, [r7, #58]	; 0x3a
                fa.y2++;
 80194f6:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80194fa:	b29b      	uxth	r3, r3
 80194fc:	3301      	adds	r3, #1
 80194fe:	b29b      	uxth	r3, r3
 8019500:	b21b      	sxth	r3, r3
 8019502:	87fb      	strh	r3, [r7, #62]	; 0x3e
                sh_buf_tmp += corner_size;
 8019504:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019508:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 801950c:	4413      	add	r3, r2
 801950e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
            for(y = 0; y < h; y++) {
 8019512:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8019516:	3301      	adds	r3, #1
 8019518:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 801951c:	f9b7 30be 	ldrsh.w	r3, [r7, #190]	; 0xbe
 8019520:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019524:	429a      	cmp	r2, r3
 8019526:	dba3      	blt.n	8019470 <draw_shadow+0xd0c>
            }
        }
    }

    /*Draw the bottom left corner*/
    a.x1 = sh_area.x1;
 8019528:	f9b7 3094 	ldrsh.w	r3, [r7, #148]	; 0x94
 801952c:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    a.x2 = a.x1 + corner_size - 1;
 8019530:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 8019534:	b29a      	uxth	r2, r3
 8019536:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801953a:	b29b      	uxth	r3, r3
 801953c:	4413      	add	r3, r2
 801953e:	b29b      	uxth	r3, r3
 8019540:	3b01      	subs	r3, #1
 8019542:	b29b      	uxth	r3, r3
 8019544:	b21b      	sxth	r3, r3
 8019546:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    a.y1 = sh_area.y2 - corner_size + 1;
 801954a:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 801954e:	b29a      	uxth	r2, r3
 8019550:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019554:	b29b      	uxth	r3, r3
 8019556:	1ad3      	subs	r3, r2, r3
 8019558:	b29b      	uxth	r3, r3
 801955a:	3301      	adds	r3, #1
 801955c:	b29b      	uxth	r3, r3
 801955e:	b21b      	sxth	r3, r3
 8019560:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
    a.y2 = sh_area.y2;
 8019564:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 8019568:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

    has_com = _lv_area_intersect(&ca, &a, clip);
 801956c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019570:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 8019574:	f107 0160 	add.w	r1, r7, #96	; 0x60
 8019578:	f107 0058 	add.w	r0, r7, #88	; 0x58
 801957c:	681a      	ldr	r2, [r3, #0]
 801957e:	f005 ff75 	bl	801f46c <_lv_area_intersect>
 8019582:	4603      	mov	r3, r0
 8019584:	f887 30cd 	strb.w	r3, [r7, #205]	; 0xcd
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
 8019588:	f897 30cd 	ldrb.w	r3, [r7, #205]	; 0xcd
 801958c:	2b00      	cmp	r3, #0
 801958e:	f000 80c4 	beq.w	801971a <draw_shadow+0xfb6>
 8019592:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8019596:	b21a      	sxth	r2, r3
 8019598:	f107 0184 	add.w	r1, r7, #132	; 0x84
 801959c:	f107 0360 	add.w	r3, r7, #96	; 0x60
 80195a0:	4618      	mov	r0, r3
 80195a2:	f006 f945 	bl	801f830 <_lv_area_is_in>
 80195a6:	4603      	mov	r3, r0
 80195a8:	f083 0301 	eor.w	r3, r3, #1
 80195ac:	b2db      	uxtb	r3, r3
 80195ae:	2b00      	cmp	r3, #0
 80195b0:	f000 80b3 	beq.w	801971a <draw_shadow+0xfb6>
        /*Avoid overlap in the middle with large radius*/
        if(ca.y1 <= h_half) ca.y1 = h_half + 1;
 80195b4:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 80195b8:	f9b7 20d6 	ldrsh.w	r2, [r7, #214]	; 0xd6
 80195bc:	429a      	cmp	r2, r3
 80195be:	db06      	blt.n	80195ce <draw_shadow+0xe6a>
 80195c0:	f8b7 30d6 	ldrh.w	r3, [r7, #214]	; 0xd6
 80195c4:	3301      	adds	r3, #1
 80195c6:	b29b      	uxth	r3, r3
 80195c8:	b21b      	sxth	r3, r3
 80195ca:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
        if(ca.x2 > w_half) ca.x2 = w_half;
 80195ce:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 80195d2:	f9b7 20d4 	ldrsh.w	r2, [r7, #212]	; 0xd4
 80195d6:	429a      	cmp	r2, r3
 80195d8:	da03      	bge.n	80195e2 <draw_shadow+0xe7e>
 80195da:	f8b7 30d4 	ldrh.w	r3, [r7, #212]	; 0xd4
 80195de:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
        lv_coord_t h = lv_area_get_height(&ca);
 80195e2:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80195e6:	4618      	mov	r0, r3
 80195e8:	f7fe f881 	bl	80176ee <lv_area_get_height>
 80195ec:	4603      	mov	r3, r0
 80195ee:	f8a7 30ba 	strh.w	r3, [r7, #186]	; 0xba
        lv_coord_t w = lv_area_get_width(&ca);
 80195f2:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80195f6:	4618      	mov	r0, r3
 80195f8:	f7fe f862 	bl	80176c0 <lv_area_get_width>
 80195fc:	4603      	mov	r3, r0
 80195fe:	f8a7 30b8 	strh.w	r3, [r7, #184]	; 0xb8

        if(w > 0) {
 8019602:	f9b7 30b8 	ldrsh.w	r3, [r7, #184]	; 0xb8
 8019606:	2b00      	cmp	r3, #0
 8019608:	f340 8087 	ble.w	801971a <draw_shadow+0xfb6>
            sh_buf_tmp = sh_buf + (ca.x1 - a.x1);
 801960c:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8019610:	461a      	mov	r2, r3
 8019612:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 8019616:	1ad3      	subs	r3, r2, r3
 8019618:	461a      	mov	r2, r3
 801961a:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 801961e:	4413      	add	r3, r2
 8019620:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
            sh_buf_tmp += corner_size * (a.y2 - ca.y2);
 8019624:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 8019628:	461a      	mov	r2, r3
 801962a:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801962e:	1ad3      	subs	r3, r2, r3
 8019630:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8019634:	fb02 f303 	mul.w	r3, r2, r3
 8019638:	461a      	mov	r2, r3
 801963a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 801963e:	4413      	add	r3, r2
 8019640:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

            lv_area_t fa;
            lv_area_copy(&fa, &ca);
 8019644:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8019648:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801964c:	4611      	mov	r1, r2
 801964e:	4618      	mov	r0, r3
 8019650:	f7fe f828 	bl	80176a4 <lv_area_copy>
            fa.y1 = fa.y2;    /*Fill from bottom to top*/
 8019654:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8019658:	867b      	strh	r3, [r7, #50]	; 0x32

            for(y = 0; y < h; y++) {
 801965a:	2300      	movs	r3, #0
 801965c:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8019660:	e055      	b.n	801970e <draw_shadow+0xfaa>
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
 8019662:	f9b7 30b8 	ldrsh.w	r3, [r7, #184]	; 0xb8
 8019666:	461a      	mov	r2, r3
 8019668:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
 801966c:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019670:	f007 fd74 	bl	802115c <_lv_memcpy>
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
 8019674:	f9b7 1030 	ldrsh.w	r1, [r7, #48]	; 0x30
 8019678:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 801967c:	f9b7 30b8 	ldrsh.w	r3, [r7, #184]	; 0xb8
 8019680:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019684:	f7fc fc96 	bl	8015fb4 <lv_draw_mask_apply>
 8019688:	4603      	mov	r3, r0
 801968a:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
 801968e:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019692:	2b01      	cmp	r3, #1
 8019694:	d102      	bne.n	801969c <draw_shadow+0xf38>
 8019696:	2302      	movs	r3, #2
 8019698:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a

                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
                               mask_res, opa, dsc->shadow_blend_mode);
 801969c:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80196a0:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80196a4:	681b      	ldr	r3, [r3, #0]
 80196a6:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
                _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
 80196aa:	f507 728c 	add.w	r2, r7, #280	; 0x118
 80196ae:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 80196b2:	6812      	ldr	r2, [r2, #0]
 80196b4:	f107 0130 	add.w	r1, r7, #48	; 0x30
 80196b8:	f507 708c 	add.w	r0, r7, #280	; 0x118
 80196bc:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
 80196c0:	9302      	str	r3, [sp, #8]
 80196c2:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
 80196c6:	9301      	str	r3, [sp, #4]
 80196c8:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 80196cc:	9300      	str	r3, [sp, #0]
 80196ce:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80196d2:	8c12      	ldrh	r2, [r2, #32]
 80196d4:	6800      	ldr	r0, [r0, #0]
 80196d6:	f7f7 f8c5 	bl	8010864 <_lv_blend_fill>
                fa.y1--;
 80196da:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 80196de:	b29b      	uxth	r3, r3
 80196e0:	3b01      	subs	r3, #1
 80196e2:	b29b      	uxth	r3, r3
 80196e4:	b21b      	sxth	r3, r3
 80196e6:	867b      	strh	r3, [r7, #50]	; 0x32
                fa.y2--;
 80196e8:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80196ec:	b29b      	uxth	r3, r3
 80196ee:	3b01      	subs	r3, #1
 80196f0:	b29b      	uxth	r3, r3
 80196f2:	b21b      	sxth	r3, r3
 80196f4:	86fb      	strh	r3, [r7, #54]	; 0x36
                sh_buf_tmp += corner_size;
 80196f6:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80196fa:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 80196fe:	4413      	add	r3, r2
 8019700:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
            for(y = 0; y < h; y++) {
 8019704:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8019708:	3301      	adds	r3, #1
 801970a:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 801970e:	f9b7 30ba 	ldrsh.w	r3, [r7, #186]	; 0xba
 8019712:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019716:	429a      	cmp	r2, r3
 8019718:	dba3      	blt.n	8019662 <draw_shadow+0xefe>
            }
        }
    }

    /*Fill the left side*/
    a.x1 = sh_area.x1;
 801971a:	f9b7 3094 	ldrsh.w	r3, [r7, #148]	; 0x94
 801971e:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    a.x2 = a.x1 + corner_size - 1;
 8019722:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 8019726:	b29a      	uxth	r2, r3
 8019728:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801972c:	b29b      	uxth	r3, r3
 801972e:	4413      	add	r3, r2
 8019730:	b29b      	uxth	r3, r3
 8019732:	3b01      	subs	r3, #1
 8019734:	b29b      	uxth	r3, r3
 8019736:	b21b      	sxth	r3, r3
 8019738:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    a.y1 = sh_area.y1 + corner_size;
 801973c:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 8019740:	b29a      	uxth	r2, r3
 8019742:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019746:	b29b      	uxth	r3, r3
 8019748:	4413      	add	r3, r2
 801974a:	b29b      	uxth	r3, r3
 801974c:	b21b      	sxth	r3, r3
 801974e:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
    a.y2 = sh_area.y2 - corner_size;
 8019752:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 8019756:	b29a      	uxth	r2, r3
 8019758:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 801975c:	b29b      	uxth	r3, r3
 801975e:	1ad3      	subs	r3, r2, r3
 8019760:	b29b      	uxth	r3, r3
 8019762:	b21b      	sxth	r3, r3
 8019764:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

    has_com = _lv_area_intersect(&ca, &a, clip);
 8019768:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801976c:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 8019770:	f107 0160 	add.w	r1, r7, #96	; 0x60
 8019774:	f107 0058 	add.w	r0, r7, #88	; 0x58
 8019778:	681a      	ldr	r2, [r3, #0]
 801977a:	f005 fe77 	bl	801f46c <_lv_area_intersect>
 801977e:	4603      	mov	r3, r0
 8019780:	f887 30cd 	strb.w	r3, [r7, #205]	; 0xcd
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
 8019784:	f897 30cd 	ldrb.w	r3, [r7, #205]	; 0xcd
 8019788:	2b00      	cmp	r3, #0
 801978a:	f000 80c4 	beq.w	8019916 <draw_shadow+0x11b2>
 801978e:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8019792:	b21a      	sxth	r2, r3
 8019794:	f107 0184 	add.w	r1, r7, #132	; 0x84
 8019798:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801979c:	4618      	mov	r0, r3
 801979e:	f006 f847 	bl	801f830 <_lv_area_is_in>
 80197a2:	4603      	mov	r3, r0
 80197a4:	f083 0301 	eor.w	r3, r3, #1
 80197a8:	b2db      	uxtb	r3, r3
 80197aa:	2b00      	cmp	r3, #0
 80197ac:	f000 80b3 	beq.w	8019916 <draw_shadow+0x11b2>
        if(simple_mode) ca.x2 = LV_MATH_MIN(coords->x1, ca.x2);
 80197b0:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 80197b4:	2b00      	cmp	r3, #0
 80197b6:	d00e      	beq.n	80197d6 <draw_shadow+0x1072>
 80197b8:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 80197bc:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80197c0:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 80197c4:	681b      	ldr	r3, [r3, #0]
 80197c6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80197ca:	4293      	cmp	r3, r2
 80197cc:	bfa8      	it	ge
 80197ce:	4613      	movge	r3, r2
 80197d0:	b21b      	sxth	r3, r3
 80197d2:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
        /*Draw vertical lines*/
        lv_coord_t w = lv_area_get_width(&ca);
 80197d6:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80197da:	4618      	mov	r0, r3
 80197dc:	f7fd ff70 	bl	80176c0 <lv_area_get_width>
 80197e0:	4603      	mov	r3, r0
 80197e2:	f8a7 30b6 	strh.w	r3, [r7, #182]	; 0xb6
        if(w > 0) {
 80197e6:	f9b7 30b6 	ldrsh.w	r3, [r7, #182]	; 0xb6
 80197ea:	2b00      	cmp	r3, #0
 80197ec:	f340 8093 	ble.w	8019916 <draw_shadow+0x11b2>
            lv_coord_t h = lv_area_get_height(&ca);
 80197f0:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80197f4:	4618      	mov	r0, r3
 80197f6:	f7fd ff7a 	bl	80176ee <lv_area_get_height>
 80197fa:	4603      	mov	r3, r0
 80197fc:	f8a7 30b4 	strh.w	r3, [r7, #180]	; 0xb4
            /*The last line of the shadow is repeated on the side*/
            sh_buf_tmp = sh_buf + corner_size * (corner_size - 1);
 8019800:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019804:	3b01      	subs	r3, #1
 8019806:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 801980a:	fb02 f303 	mul.w	r3, r2, r3
 801980e:	461a      	mov	r2, r3
 8019810:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8019814:	4413      	add	r3, r2
 8019816:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
            sh_buf_tmp += ca.x1 - a.x1;
 801981a:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 801981e:	461a      	mov	r2, r3
 8019820:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 8019824:	1ad3      	subs	r3, r2, r3
 8019826:	461a      	mov	r2, r3
 8019828:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 801982c:	4413      	add	r3, r2
 801982e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

            lv_area_t fa;
            lv_area_copy(&fa, &ca);
 8019832:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8019836:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801983a:	4611      	mov	r1, r2
 801983c:	4618      	mov	r0, r3
 801983e:	f7fd ff31 	bl	80176a4 <lv_area_copy>
            fa.y2 = fa.y1;
 8019842:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8019846:	85fb      	strh	r3, [r7, #46]	; 0x2e
            for(y = 0; y < h; y++) {
 8019848:	2300      	movs	r3, #0
 801984a:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 801984e:	e05c      	b.n	801990a <draw_shadow+0x11a6>
                _lv_memcpy(mask_buf, sh_buf_tmp, w);
 8019850:	f9b7 30b6 	ldrsh.w	r3, [r7, #182]	; 0xb6
 8019854:	461a      	mov	r2, r3
 8019856:	f8d7 1100 	ldr.w	r1, [r7, #256]	; 0x100
 801985a:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 801985e:	f007 fc7d 	bl	802115c <_lv_memcpy>
                if(simple_mode) {
 8019862:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 8019866:	2b00      	cmp	r3, #0
 8019868:	d003      	beq.n	8019872 <draw_shadow+0x110e>
                    mask_res = LV_DRAW_MASK_RES_CHANGED;
 801986a:	2302      	movs	r3, #2
 801986c:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
 8019870:	e013      	b.n	801989a <draw_shadow+0x1136>
                }
                else {
                    mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
 8019872:	f9b7 1028 	ldrsh.w	r1, [r7, #40]	; 0x28
 8019876:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 801987a:	f9b7 30b6 	ldrsh.w	r3, [r7, #182]	; 0xb6
 801987e:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019882:	f7fc fb97 	bl	8015fb4 <lv_draw_mask_apply>
 8019886:	4603      	mov	r3, r0
 8019888:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
                    if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
 801988c:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019890:	2b01      	cmp	r3, #1
 8019892:	d102      	bne.n	801989a <draw_shadow+0x1136>
 8019894:	2302      	movs	r3, #2
 8019896:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
                }

                _lv_blend_fill(clip, &fa,
                               dsc->shadow_color, mask_buf, mask_res, dsc->shadow_opa, dsc->shadow_blend_mode);
 801989a:	f507 738c 	add.w	r3, r7, #280	; 0x118
 801989e:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 80198a2:	681b      	ldr	r3, [r3, #0]
 80198a4:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 80198a8:	f507 728c 	add.w	r2, r7, #280	; 0x118
 80198ac:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 80198b0:	6812      	ldr	r2, [r2, #0]
 80198b2:	f892 102b 	ldrb.w	r1, [r2, #43]	; 0x2b
                _lv_blend_fill(clip, &fa,
 80198b6:	f507 728c 	add.w	r2, r7, #280	; 0x118
 80198ba:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 80198be:	6812      	ldr	r2, [r2, #0]
 80198c0:	f107 0428 	add.w	r4, r7, #40	; 0x28
 80198c4:	f507 708c 	add.w	r0, r7, #280	; 0x118
 80198c8:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
 80198cc:	9102      	str	r1, [sp, #8]
 80198ce:	9301      	str	r3, [sp, #4]
 80198d0:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 80198d4:	9300      	str	r3, [sp, #0]
 80198d6:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 80198da:	8c12      	ldrh	r2, [r2, #32]
 80198dc:	4621      	mov	r1, r4
 80198de:	6800      	ldr	r0, [r0, #0]
 80198e0:	f7f6 ffc0 	bl	8010864 <_lv_blend_fill>
                fa.y1++;
 80198e4:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80198e8:	b29b      	uxth	r3, r3
 80198ea:	3301      	adds	r3, #1
 80198ec:	b29b      	uxth	r3, r3
 80198ee:	b21b      	sxth	r3, r3
 80198f0:	857b      	strh	r3, [r7, #42]	; 0x2a
                fa.y2++;
 80198f2:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 80198f6:	b29b      	uxth	r3, r3
 80198f8:	3301      	adds	r3, #1
 80198fa:	b29b      	uxth	r3, r3
 80198fc:	b21b      	sxth	r3, r3
 80198fe:	85fb      	strh	r3, [r7, #46]	; 0x2e
            for(y = 0; y < h; y++) {
 8019900:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8019904:	3301      	adds	r3, #1
 8019906:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 801990a:	f9b7 30b4 	ldrsh.w	r3, [r7, #180]	; 0xb4
 801990e:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019912:	429a      	cmp	r2, r3
 8019914:	db9c      	blt.n	8019850 <draw_shadow+0x10ec>
            }
        }
    }

    /*Fill the top side*/
    a.x1 = sh_area.x1 + corner_size;
 8019916:	f9b7 3094 	ldrsh.w	r3, [r7, #148]	; 0x94
 801991a:	b29a      	uxth	r2, r3
 801991c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019920:	b29b      	uxth	r3, r3
 8019922:	4413      	add	r3, r2
 8019924:	b29b      	uxth	r3, r3
 8019926:	b21b      	sxth	r3, r3
 8019928:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    a.x2 = sh_area.x2 - corner_size;
 801992c:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
 8019930:	b29a      	uxth	r2, r3
 8019932:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019936:	b29b      	uxth	r3, r3
 8019938:	1ad3      	subs	r3, r2, r3
 801993a:	b29b      	uxth	r3, r3
 801993c:	b21b      	sxth	r3, r3
 801993e:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    a.y1 = sh_area.y1;
 8019942:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 8019946:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
    a.y2 = sh_area.y1 + corner_size - 1;
 801994a:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 801994e:	b29a      	uxth	r2, r3
 8019950:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019954:	b29b      	uxth	r3, r3
 8019956:	4413      	add	r3, r2
 8019958:	b29b      	uxth	r3, r3
 801995a:	3b01      	subs	r3, #1
 801995c:	b29b      	uxth	r3, r3
 801995e:	b21b      	sxth	r3, r3
 8019960:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

    has_com = _lv_area_intersect(&ca, &a, clip);
 8019964:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019968:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 801996c:	f107 0160 	add.w	r1, r7, #96	; 0x60
 8019970:	f107 0058 	add.w	r0, r7, #88	; 0x58
 8019974:	681a      	ldr	r2, [r3, #0]
 8019976:	f005 fd79 	bl	801f46c <_lv_area_intersect>
 801997a:	4603      	mov	r3, r0
 801997c:	f887 30cd 	strb.w	r3, [r7, #205]	; 0xcd
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
 8019980:	f897 30cd 	ldrb.w	r3, [r7, #205]	; 0xcd
 8019984:	2b00      	cmp	r3, #0
 8019986:	f000 80d7 	beq.w	8019b38 <draw_shadow+0x13d4>
 801998a:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 801998e:	b21a      	sxth	r2, r3
 8019990:	f107 0184 	add.w	r1, r7, #132	; 0x84
 8019994:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8019998:	4618      	mov	r0, r3
 801999a:	f005 ff49 	bl	801f830 <_lv_area_is_in>
 801999e:	4603      	mov	r3, r0
 80199a0:	f083 0301 	eor.w	r3, r3, #1
 80199a4:	b2db      	uxtb	r3, r3
 80199a6:	2b00      	cmp	r3, #0
 80199a8:	f000 80c6 	beq.w	8019b38 <draw_shadow+0x13d4>
        if(simple_mode) ca.y2 = LV_MATH_MIN(ca.y2, coords->y1);
 80199ac:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 80199b0:	2b00      	cmp	r3, #0
 80199b2:	d00e      	beq.n	80199d2 <draw_shadow+0x126e>
 80199b4:	f507 738c 	add.w	r3, r7, #280	; 0x118
 80199b8:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 80199bc:	681b      	ldr	r3, [r3, #0]
 80199be:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 80199c2:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80199c6:	4293      	cmp	r3, r2
 80199c8:	bfa8      	it	ge
 80199ca:	4613      	movge	r3, r2
 80199cc:	b21b      	sxth	r3, r3
 80199ce:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
        /*Draw horizontal lines*/
        lv_coord_t w = lv_area_get_width(&ca);
 80199d2:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80199d6:	4618      	mov	r0, r3
 80199d8:	f7fd fe72 	bl	80176c0 <lv_area_get_width>
 80199dc:	4603      	mov	r3, r0
 80199de:	f8a7 30b2 	strh.w	r3, [r7, #178]	; 0xb2
        lv_coord_t h = lv_area_get_height(&ca);
 80199e2:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80199e6:	4618      	mov	r0, r3
 80199e8:	f7fd fe81 	bl	80176ee <lv_area_get_height>
 80199ec:	4603      	mov	r3, r0
 80199ee:	f8a7 30b0 	strh.w	r3, [r7, #176]	; 0xb0
        sh_buf_tmp = sh_buf + corner_size - 1;
 80199f2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80199f6:	3b01      	subs	r3, #1
 80199f8:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 80199fc:	4413      	add	r3, r2
 80199fe:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
        sh_buf_tmp += corner_size * (ca.y1 - a.y1);
 8019a02:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8019a06:	461a      	mov	r2, r3
 8019a08:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8019a0c:	1ad3      	subs	r3, r2, r3
 8019a0e:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8019a12:	fb02 f303 	mul.w	r3, r2, r3
 8019a16:	461a      	mov	r2, r3
 8019a18:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8019a1c:	4413      	add	r3, r2
 8019a1e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

        lv_area_t fa;
        lv_area_copy(&fa, &ca);
 8019a22:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8019a26:	f107 0320 	add.w	r3, r7, #32
 8019a2a:	4611      	mov	r1, r2
 8019a2c:	4618      	mov	r0, r3
 8019a2e:	f7fd fe39 	bl	80176a4 <lv_area_copy>
        fa.y2 = fa.y1;
 8019a32:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8019a36:	84fb      	strh	r3, [r7, #38]	; 0x26
        mask_res = LV_DRAW_MASK_RES_FULL_COVER;
 8019a38:	2301      	movs	r3, #1
 8019a3a:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
        for(y = 0; y < h; y++) {
 8019a3e:	2300      	movs	r3, #0
 8019a40:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8019a44:	e072      	b.n	8019b2c <draw_shadow+0x13c8>
            lv_opa_t opa_tmp = sh_buf_tmp[0];
 8019a46:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8019a4a:	781b      	ldrb	r3, [r3, #0]
 8019a4c:	f887 30fb 	strb.w	r3, [r7, #251]	; 0xfb
            if(opa_tmp != LV_OPA_COVER || opa != LV_OPA_COVER) opa_tmp = (opa * opa_tmp) >> 8;
 8019a50:	f897 30fb 	ldrb.w	r3, [r7, #251]	; 0xfb
 8019a54:	2bff      	cmp	r3, #255	; 0xff
 8019a56:	d103      	bne.n	8019a60 <draw_shadow+0x12fc>
 8019a58:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
 8019a5c:	2bff      	cmp	r3, #255	; 0xff
 8019a5e:	d008      	beq.n	8019a72 <draw_shadow+0x130e>
 8019a60:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
 8019a64:	f897 20fb 	ldrb.w	r2, [r7, #251]	; 0xfb
 8019a68:	fb02 f303 	mul.w	r3, r2, r3
 8019a6c:	121b      	asrs	r3, r3, #8
 8019a6e:	f887 30fb 	strb.w	r3, [r7, #251]	; 0xfb

            _lv_memset(mask_buf, opa_tmp, w);
 8019a72:	f9b7 20b2 	ldrsh.w	r2, [r7, #178]	; 0xb2
 8019a76:	f897 30fb 	ldrb.w	r3, [r7, #251]	; 0xfb
 8019a7a:	4619      	mov	r1, r3
 8019a7c:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019a80:	f007 fd84 	bl	802158c <_lv_memset>

            if(simple_mode) {
 8019a84:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 8019a88:	2b00      	cmp	r3, #0
 8019a8a:	d003      	beq.n	8019a94 <draw_shadow+0x1330>
                mask_res = LV_DRAW_MASK_RES_CHANGED;
 8019a8c:	2302      	movs	r3, #2
 8019a8e:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
 8019a92:	e013      	b.n	8019abc <draw_shadow+0x1358>
            }
            else {
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
 8019a94:	f9b7 1020 	ldrsh.w	r1, [r7, #32]
 8019a98:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 8019a9c:	f9b7 30b2 	ldrsh.w	r3, [r7, #178]	; 0xb2
 8019aa0:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019aa4:	f7fc fa86 	bl	8015fb4 <lv_draw_mask_apply>
 8019aa8:	4603      	mov	r3, r0
 8019aaa:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
 8019aae:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019ab2:	2b01      	cmp	r3, #1
 8019ab4:	d102      	bne.n	8019abc <draw_shadow+0x1358>
 8019ab6:	2302      	movs	r3, #2
 8019ab8:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
            }

            _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
                           mask_res, LV_OPA_COVER, dsc->shadow_blend_mode);
 8019abc:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019ac0:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8019ac4:	681b      	ldr	r3, [r3, #0]
 8019ac6:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
            _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
 8019aca:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8019ace:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 8019ad2:	6812      	ldr	r2, [r2, #0]
 8019ad4:	f107 0120 	add.w	r1, r7, #32
 8019ad8:	f507 708c 	add.w	r0, r7, #280	; 0x118
 8019adc:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
 8019ae0:	9302      	str	r3, [sp, #8]
 8019ae2:	23ff      	movs	r3, #255	; 0xff
 8019ae4:	9301      	str	r3, [sp, #4]
 8019ae6:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019aea:	9300      	str	r3, [sp, #0]
 8019aec:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8019af0:	8c12      	ldrh	r2, [r2, #32]
 8019af2:	6800      	ldr	r0, [r0, #0]
 8019af4:	f7f6 feb6 	bl	8010864 <_lv_blend_fill>
            fa.y1++;
 8019af8:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8019afc:	b29b      	uxth	r3, r3
 8019afe:	3301      	adds	r3, #1
 8019b00:	b29b      	uxth	r3, r3
 8019b02:	b21b      	sxth	r3, r3
 8019b04:	847b      	strh	r3, [r7, #34]	; 0x22
            fa.y2++;
 8019b06:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8019b0a:	b29b      	uxth	r3, r3
 8019b0c:	3301      	adds	r3, #1
 8019b0e:	b29b      	uxth	r3, r3
 8019b10:	b21b      	sxth	r3, r3
 8019b12:	84fb      	strh	r3, [r7, #38]	; 0x26
            sh_buf_tmp += corner_size;
 8019b14:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019b18:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8019b1c:	4413      	add	r3, r2
 8019b1e:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
        for(y = 0; y < h; y++) {
 8019b22:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8019b26:	3301      	adds	r3, #1
 8019b28:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8019b2c:	f9b7 30b0 	ldrsh.w	r3, [r7, #176]	; 0xb0
 8019b30:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019b34:	429a      	cmp	r2, r3
 8019b36:	db86      	blt.n	8019a46 <draw_shadow+0x12e2>
        }
    }


    /*Fill the bottom side*/
    a.x1 = sh_area.x1 + corner_size;
 8019b38:	f9b7 3094 	ldrsh.w	r3, [r7, #148]	; 0x94
 8019b3c:	b29a      	uxth	r2, r3
 8019b3e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019b42:	b29b      	uxth	r3, r3
 8019b44:	4413      	add	r3, r2
 8019b46:	b29b      	uxth	r3, r3
 8019b48:	b21b      	sxth	r3, r3
 8019b4a:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    a.x2 = sh_area.x2 - corner_size;
 8019b4e:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
 8019b52:	b29a      	uxth	r2, r3
 8019b54:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019b58:	b29b      	uxth	r3, r3
 8019b5a:	1ad3      	subs	r3, r2, r3
 8019b5c:	b29b      	uxth	r3, r3
 8019b5e:	b21b      	sxth	r3, r3
 8019b60:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    a.y1 = sh_area.y2 - corner_size + 1;
 8019b64:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 8019b68:	b29a      	uxth	r2, r3
 8019b6a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019b6e:	b29b      	uxth	r3, r3
 8019b70:	1ad3      	subs	r3, r2, r3
 8019b72:	b29b      	uxth	r3, r3
 8019b74:	3301      	adds	r3, #1
 8019b76:	b29b      	uxth	r3, r3
 8019b78:	b21b      	sxth	r3, r3
 8019b7a:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
    a.y2 = sh_area.y2;
 8019b7e:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 8019b82:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

    has_com = _lv_area_intersect(&ca, &a, clip);
 8019b86:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019b8a:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 8019b8e:	f107 0160 	add.w	r1, r7, #96	; 0x60
 8019b92:	f107 0058 	add.w	r0, r7, #88	; 0x58
 8019b96:	681a      	ldr	r2, [r3, #0]
 8019b98:	f005 fc68 	bl	801f46c <_lv_area_intersect>
 8019b9c:	4603      	mov	r3, r0
 8019b9e:	f887 30cd 	strb.w	r3, [r7, #205]	; 0xcd
    if(has_com && _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
 8019ba2:	f897 30cd 	ldrb.w	r3, [r7, #205]	; 0xcd
 8019ba6:	2b00      	cmp	r3, #0
 8019ba8:	f000 80f5 	beq.w	8019d96 <draw_shadow+0x1632>
 8019bac:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8019bb0:	b21a      	sxth	r2, r3
 8019bb2:	f107 0184 	add.w	r1, r7, #132	; 0x84
 8019bb6:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8019bba:	4618      	mov	r0, r3
 8019bbc:	f005 fe38 	bl	801f830 <_lv_area_is_in>
 8019bc0:	4603      	mov	r3, r0
 8019bc2:	f083 0301 	eor.w	r3, r3, #1
 8019bc6:	b2db      	uxtb	r3, r3
 8019bc8:	2b00      	cmp	r3, #0
 8019bca:	f000 80e4 	beq.w	8019d96 <draw_shadow+0x1632>
        if(simple_mode) ca.y1 = LV_MATH_MAX(ca.y1, coords->y2);
 8019bce:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 8019bd2:	2b00      	cmp	r3, #0
 8019bd4:	d00e      	beq.n	8019bf4 <draw_shadow+0x1490>
 8019bd6:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019bda:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 8019bde:	681b      	ldr	r3, [r3, #0]
 8019be0:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 8019be4:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8019be8:	4293      	cmp	r3, r2
 8019bea:	bfb8      	it	lt
 8019bec:	4613      	movlt	r3, r2
 8019bee:	b21b      	sxth	r3, r3
 8019bf0:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
        /*Draw horizontal lines*/
        lv_coord_t w = lv_area_get_width(&ca);
 8019bf4:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8019bf8:	4618      	mov	r0, r3
 8019bfa:	f7fd fd61 	bl	80176c0 <lv_area_get_width>
 8019bfe:	4603      	mov	r3, r0
 8019c00:	f8a7 30ae 	strh.w	r3, [r7, #174]	; 0xae
        lv_coord_t h = lv_area_get_height(&ca);
 8019c04:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8019c08:	4618      	mov	r0, r3
 8019c0a:	f7fd fd70 	bl	80176ee <lv_area_get_height>
 8019c0e:	4603      	mov	r3, r0
 8019c10:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac
        sh_buf_tmp = sh_buf + corner_size - 1;
 8019c14:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019c18:	3b01      	subs	r3, #1
 8019c1a:	f8d7 20d8 	ldr.w	r2, [r7, #216]	; 0xd8
 8019c1e:	4413      	add	r3, r2
 8019c20:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
        sh_buf_tmp += corner_size * (a.y2 - ca.y2);
 8019c24:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 8019c28:	461a      	mov	r2, r3
 8019c2a:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8019c2e:	1ad3      	subs	r3, r2, r3
 8019c30:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8019c34:	fb02 f303 	mul.w	r3, r2, r3
 8019c38:	461a      	mov	r2, r3
 8019c3a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8019c3e:	4413      	add	r3, r2
 8019c40:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100

        lv_area_t fa;
        lv_area_copy(&fa, &ca);
 8019c44:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8019c48:	f107 0318 	add.w	r3, r7, #24
 8019c4c:	4611      	mov	r1, r2
 8019c4e:	4618      	mov	r0, r3
 8019c50:	f7fd fd28 	bl	80176a4 <lv_area_copy>
        fa.y1 = fa.y2;
 8019c54:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019c58:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8019c5c:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 8019c60:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019c64:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8019c68:	805a      	strh	r2, [r3, #2]
        for(y = 0; y < h; y++) {
 8019c6a:	2300      	movs	r3, #0
 8019c6c:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8019c70:	e08a      	b.n	8019d88 <draw_shadow+0x1624>
            lv_opa_t opa_tmp = sh_buf_tmp[0];
 8019c72:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8019c76:	781b      	ldrb	r3, [r3, #0]
 8019c78:	f887 30fa 	strb.w	r3, [r7, #250]	; 0xfa
            if(opa_tmp != LV_OPA_COVER || opa != LV_OPA_COVER) opa_tmp = (opa * opa_tmp) >> 8;
 8019c7c:	f897 30fa 	ldrb.w	r3, [r7, #250]	; 0xfa
 8019c80:	2bff      	cmp	r3, #255	; 0xff
 8019c82:	d103      	bne.n	8019c8c <draw_shadow+0x1528>
 8019c84:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
 8019c88:	2bff      	cmp	r3, #255	; 0xff
 8019c8a:	d008      	beq.n	8019c9e <draw_shadow+0x153a>
 8019c8c:	f897 3117 	ldrb.w	r3, [r7, #279]	; 0x117
 8019c90:	f897 20fa 	ldrb.w	r2, [r7, #250]	; 0xfa
 8019c94:	fb02 f303 	mul.w	r3, r2, r3
 8019c98:	121b      	asrs	r3, r3, #8
 8019c9a:	f887 30fa 	strb.w	r3, [r7, #250]	; 0xfa

            _lv_memset(mask_buf, opa_tmp, w);
 8019c9e:	f9b7 20ae 	ldrsh.w	r2, [r7, #174]	; 0xae
 8019ca2:	f897 30fa 	ldrb.w	r3, [r7, #250]	; 0xfa
 8019ca6:	4619      	mov	r1, r3
 8019ca8:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019cac:	f007 fc6e 	bl	802158c <_lv_memset>
            if(simple_mode) {
 8019cb0:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 8019cb4:	2b00      	cmp	r3, #0
 8019cb6:	d003      	beq.n	8019cc0 <draw_shadow+0x155c>
                mask_res = LV_DRAW_MASK_RES_CHANGED;
 8019cb8:	2302      	movs	r3, #2
 8019cba:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
 8019cbe:	e01b      	b.n	8019cf8 <draw_shadow+0x1594>
            }
            else {
                mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
 8019cc0:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019cc4:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8019cc8:	f9b3 1000 	ldrsh.w	r1, [r3]
 8019ccc:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019cd0:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8019cd4:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8019cd8:	f9b7 30ae 	ldrsh.w	r3, [r7, #174]	; 0xae
 8019cdc:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019ce0:	f7fc f968 	bl	8015fb4 <lv_draw_mask_apply>
 8019ce4:	4603      	mov	r3, r0
 8019ce6:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
                if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
 8019cea:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019cee:	2b01      	cmp	r3, #1
 8019cf0:	d102      	bne.n	8019cf8 <draw_shadow+0x1594>
 8019cf2:	2302      	movs	r3, #2
 8019cf4:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
            }

            _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
                           mask_res, LV_OPA_COVER, dsc->shadow_blend_mode);
 8019cf8:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019cfc:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8019d00:	681b      	ldr	r3, [r3, #0]
 8019d02:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
            _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
 8019d06:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8019d0a:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 8019d0e:	6812      	ldr	r2, [r2, #0]
 8019d10:	f107 0118 	add.w	r1, r7, #24
 8019d14:	f507 708c 	add.w	r0, r7, #280	; 0x118
 8019d18:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
 8019d1c:	9302      	str	r3, [sp, #8]
 8019d1e:	23ff      	movs	r3, #255	; 0xff
 8019d20:	9301      	str	r3, [sp, #4]
 8019d22:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019d26:	9300      	str	r3, [sp, #0]
 8019d28:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8019d2c:	8c12      	ldrh	r2, [r2, #32]
 8019d2e:	6800      	ldr	r0, [r0, #0]
 8019d30:	f7f6 fd98 	bl	8010864 <_lv_blend_fill>
            fa.y1--;
 8019d34:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019d38:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8019d3c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8019d40:	b29b      	uxth	r3, r3
 8019d42:	3b01      	subs	r3, #1
 8019d44:	b29b      	uxth	r3, r3
 8019d46:	b21a      	sxth	r2, r3
 8019d48:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019d4c:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8019d50:	805a      	strh	r2, [r3, #2]
            fa.y2--;
 8019d52:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019d56:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8019d5a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019d5e:	b29b      	uxth	r3, r3
 8019d60:	3b01      	subs	r3, #1
 8019d62:	b29b      	uxth	r3, r3
 8019d64:	b21a      	sxth	r2, r3
 8019d66:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019d6a:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 8019d6e:	80da      	strh	r2, [r3, #6]
            sh_buf_tmp += corner_size;
 8019d70:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019d74:	f8d7 2100 	ldr.w	r2, [r7, #256]	; 0x100
 8019d78:	4413      	add	r3, r2
 8019d7a:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
        for(y = 0; y < h; y++) {
 8019d7e:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8019d82:	3301      	adds	r3, #1
 8019d84:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8019d88:	f9b7 30ac 	ldrsh.w	r3, [r7, #172]	; 0xac
 8019d8c:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019d90:	429a      	cmp	r2, r3
 8019d92:	f6ff af6e 	blt.w	8019c72 <draw_shadow+0x150e>
        }
    }

    /*Draw the middle area*/
    a.x1 = sh_area.x1 + corner_size;
 8019d96:	f9b7 3094 	ldrsh.w	r3, [r7, #148]	; 0x94
 8019d9a:	b29a      	uxth	r2, r3
 8019d9c:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019da0:	b29b      	uxth	r3, r3
 8019da2:	4413      	add	r3, r2
 8019da4:	b29b      	uxth	r3, r3
 8019da6:	b21b      	sxth	r3, r3
 8019da8:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    a.x2 = sh_area.x2 - corner_size;
 8019dac:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
 8019db0:	b29a      	uxth	r2, r3
 8019db2:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019db6:	b29b      	uxth	r3, r3
 8019db8:	1ad3      	subs	r3, r2, r3
 8019dba:	b29b      	uxth	r3, r3
 8019dbc:	b21b      	sxth	r3, r3
 8019dbe:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    a.y1 = sh_area.y1 + corner_size;
 8019dc2:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 8019dc6:	b29a      	uxth	r2, r3
 8019dc8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019dcc:	b29b      	uxth	r3, r3
 8019dce:	4413      	add	r3, r2
 8019dd0:	b29b      	uxth	r3, r3
 8019dd2:	b21b      	sxth	r3, r3
 8019dd4:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
    a.y2 = sh_area.y2 - corner_size;
 8019dd8:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 8019ddc:	b29a      	uxth	r2, r3
 8019dde:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8019de2:	b29b      	uxth	r3, r3
 8019de4:	1ad3      	subs	r3, r2, r3
 8019de6:	b29b      	uxth	r3, r3
 8019de8:	b21b      	sxth	r3, r3
 8019dea:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

    has_com = _lv_area_intersect(&ca, &a, clip);
 8019dee:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019df2:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 8019df6:	f107 0160 	add.w	r1, r7, #96	; 0x60
 8019dfa:	f107 0058 	add.w	r0, r7, #88	; 0x58
 8019dfe:	681a      	ldr	r2, [r3, #0]
 8019e00:	f005 fb34 	bl	801f46c <_lv_area_intersect>
 8019e04:	4603      	mov	r3, r0
 8019e06:	f887 30cd 	strb.w	r3, [r7, #205]	; 0xcd
    if(has_com && simple_mode == false &&  _lv_area_is_in(&a, &bg_coords, r_bg) == false) {
 8019e0a:	f897 30cd 	ldrb.w	r3, [r7, #205]	; 0xcd
 8019e0e:	2b00      	cmp	r3, #0
 8019e10:	f000 80b1 	beq.w	8019f76 <draw_shadow+0x1812>
 8019e14:	f897 310b 	ldrb.w	r3, [r7, #267]	; 0x10b
 8019e18:	f083 0301 	eor.w	r3, r3, #1
 8019e1c:	b2db      	uxtb	r3, r3
 8019e1e:	2b00      	cmp	r3, #0
 8019e20:	f000 80a9 	beq.w	8019f76 <draw_shadow+0x1812>
 8019e24:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8019e28:	b21a      	sxth	r2, r3
 8019e2a:	f107 0184 	add.w	r1, r7, #132	; 0x84
 8019e2e:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8019e32:	4618      	mov	r0, r3
 8019e34:	f005 fcfc 	bl	801f830 <_lv_area_is_in>
 8019e38:	4603      	mov	r3, r0
 8019e3a:	f083 0301 	eor.w	r3, r3, #1
 8019e3e:	b2db      	uxtb	r3, r3
 8019e40:	2b00      	cmp	r3, #0
 8019e42:	f000 8098 	beq.w	8019f76 <draw_shadow+0x1812>
        /*Draw horizontal lines*/
        lv_coord_t w = lv_area_get_width(&ca);
 8019e46:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8019e4a:	4618      	mov	r0, r3
 8019e4c:	f7fd fc38 	bl	80176c0 <lv_area_get_width>
 8019e50:	4603      	mov	r3, r0
 8019e52:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
        lv_coord_t h = lv_area_get_height(&ca);
 8019e56:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8019e5a:	4618      	mov	r0, r3
 8019e5c:	f7fd fc47 	bl	80176ee <lv_area_get_height>
 8019e60:	4603      	mov	r3, r0
 8019e62:	f8a7 30a8 	strh.w	r3, [r7, #168]	; 0xa8

        lv_area_t fa;
        lv_area_copy(&fa, &ca);
 8019e66:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8019e6a:	f107 0310 	add.w	r3, r7, #16
 8019e6e:	4611      	mov	r1, r2
 8019e70:	4618      	mov	r0, r3
 8019e72:	f7fd fc17 	bl	80176a4 <lv_area_copy>
        fa.y2 = fa.y1;
 8019e76:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019e7a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8019e7e:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8019e82:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019e86:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8019e8a:	80da      	strh	r2, [r3, #6]
        for(y = 0; y < h; y++) {
 8019e8c:	2300      	movs	r3, #0
 8019e8e:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8019e92:	e06a      	b.n	8019f6a <draw_shadow+0x1806>
            _lv_memset(mask_buf, dsc->shadow_opa, w);
 8019e94:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019e98:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8019e9c:	681b      	ldr	r3, [r3, #0]
 8019e9e:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 8019ea2:	f9b7 20aa 	ldrsh.w	r2, [r7, #170]	; 0xaa
 8019ea6:	4619      	mov	r1, r3
 8019ea8:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019eac:	f007 fb6e 	bl	802158c <_lv_memset>
            mask_res = lv_draw_mask_apply(mask_buf, fa.x1, fa.y1, w);
 8019eb0:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019eb4:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8019eb8:	f9b3 1000 	ldrsh.w	r1, [r3]
 8019ebc:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019ec0:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8019ec4:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8019ec8:	f9b7 30aa 	ldrsh.w	r3, [r7, #170]	; 0xaa
 8019ecc:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019ed0:	f7fc f870 	bl	8015fb4 <lv_draw_mask_apply>
 8019ed4:	4603      	mov	r3, r0
 8019ed6:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a
            if(mask_res == LV_DRAW_MASK_RES_FULL_COVER) mask_res = LV_DRAW_MASK_RES_CHANGED;
 8019eda:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019ede:	2b01      	cmp	r3, #1
 8019ee0:	d102      	bne.n	8019ee8 <draw_shadow+0x1784>
 8019ee2:	2302      	movs	r3, #2
 8019ee4:	f887 310a 	strb.w	r3, [r7, #266]	; 0x10a

            _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
                           mask_res, LV_OPA_COVER, dsc->shadow_blend_mode);
 8019ee8:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019eec:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8019ef0:	681b      	ldr	r3, [r3, #0]
 8019ef2:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
            _lv_blend_fill(clip, &fa, dsc->shadow_color, mask_buf,
 8019ef6:	f507 728c 	add.w	r2, r7, #280	; 0x118
 8019efa:	f5a2 728a 	sub.w	r2, r2, #276	; 0x114
 8019efe:	6812      	ldr	r2, [r2, #0]
 8019f00:	f107 0110 	add.w	r1, r7, #16
 8019f04:	f507 708c 	add.w	r0, r7, #280	; 0x118
 8019f08:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
 8019f0c:	9302      	str	r3, [sp, #8]
 8019f0e:	23ff      	movs	r3, #255	; 0xff
 8019f10:	9301      	str	r3, [sp, #4]
 8019f12:	f897 310a 	ldrb.w	r3, [r7, #266]	; 0x10a
 8019f16:	9300      	str	r3, [sp, #0]
 8019f18:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8019f1c:	8c12      	ldrh	r2, [r2, #32]
 8019f1e:	6800      	ldr	r0, [r0, #0]
 8019f20:	f7f6 fca0 	bl	8010864 <_lv_blend_fill>
            fa.y1++;
 8019f24:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019f28:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8019f2c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8019f30:	b29b      	uxth	r3, r3
 8019f32:	3301      	adds	r3, #1
 8019f34:	b29b      	uxth	r3, r3
 8019f36:	b21a      	sxth	r2, r3
 8019f38:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019f3c:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8019f40:	805a      	strh	r2, [r3, #2]
            fa.y2++;
 8019f42:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019f46:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8019f4a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019f4e:	b29b      	uxth	r3, r3
 8019f50:	3301      	adds	r3, #1
 8019f52:	b29b      	uxth	r3, r3
 8019f54:	b21a      	sxth	r2, r3
 8019f56:	f507 738c 	add.w	r3, r7, #280	; 0x118
 8019f5a:	f5a3 7384 	sub.w	r3, r3, #264	; 0x108
 8019f5e:	80da      	strh	r2, [r3, #6]
        for(y = 0; y < h; y++) {
 8019f60:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8019f64:	3301      	adds	r3, #1
 8019f66:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
 8019f6a:	f9b7 30a8 	ldrsh.w	r3, [r7, #168]	; 0xa8
 8019f6e:	f8d7 2104 	ldr.w	r2, [r7, #260]	; 0x104
 8019f72:	429a      	cmp	r2, r3
 8019f74:	db8e      	blt.n	8019e94 <draw_shadow+0x1730>
        }
    }

    lv_draw_mask_remove_id(mask_rout_id);
 8019f76:	f9b7 30ce 	ldrsh.w	r3, [r7, #206]	; 0xce
 8019f7a:	4618      	mov	r0, r3
 8019f7c:	f7fc f85e 	bl	801603c <lv_draw_mask_remove_id>
    _lv_mem_buf_release(mask_buf);
 8019f80:	f8d7 00d0 	ldr.w	r0, [r7, #208]	; 0xd0
 8019f84:	f007 f864 	bl	8021050 <_lv_mem_buf_release>
    _lv_mem_buf_release(sh_buf);
 8019f88:	f8d7 00d8 	ldr.w	r0, [r7, #216]	; 0xd8
 8019f8c:	f007 f860 	bl	8021050 <_lv_mem_buf_release>
 8019f90:	e006      	b.n	8019fa0 <draw_shadow+0x183c>
    if(dsc->shadow_width == 0) return;
 8019f92:	bf00      	nop
 8019f94:	e004      	b.n	8019fa0 <draw_shadow+0x183c>
    if(dsc->shadow_opa <= LV_OPA_MIN) return;
 8019f96:	bf00      	nop
 8019f98:	e002      	b.n	8019fa0 <draw_shadow+0x183c>
        return;
 8019f9a:	bf00      	nop
 8019f9c:	e000      	b.n	8019fa0 <draw_shadow+0x183c>
    if(is_common == false) return;
 8019f9e:	bf00      	nop
}
 8019fa0:	f507 778e 	add.w	r7, r7, #284	; 0x11c
 8019fa4:	46bd      	mov	sp, r7
 8019fa6:	bd90      	pop	{r4, r7, pc}

08019fa8 <shadow_draw_corner_buf>:
 * @param sw shadow width
 * @param r radius
 */
LV_ATTRIBUTE_FAST_MEM static void shadow_draw_corner_buf(const lv_area_t * coords, uint16_t * sh_buf, lv_coord_t sw,
                                                         lv_coord_t r)
{
 8019fa8:	b590      	push	{r4, r7, lr}
 8019faa:	b09d      	sub	sp, #116	; 0x74
 8019fac:	af02      	add	r7, sp, #8
 8019fae:	60f8      	str	r0, [r7, #12]
 8019fb0:	60b9      	str	r1, [r7, #8]
 8019fb2:	4611      	mov	r1, r2
 8019fb4:	461a      	mov	r2, r3
 8019fb6:	460b      	mov	r3, r1
 8019fb8:	80fb      	strh	r3, [r7, #6]
 8019fba:	4613      	mov	r3, r2
 8019fbc:	80bb      	strh	r3, [r7, #4]
    int32_t sw_ori = sw;
 8019fbe:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8019fc2:	64fb      	str	r3, [r7, #76]	; 0x4c
    int32_t size = sw_ori  + r;
 8019fc4:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8019fc8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8019fca:	4413      	add	r3, r2
 8019fcc:	64bb      	str	r3, [r7, #72]	; 0x48

    lv_area_t sh_area;
    lv_area_copy(&sh_area, coords);
 8019fce:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8019fd2:	68f9      	ldr	r1, [r7, #12]
 8019fd4:	4618      	mov	r0, r3
 8019fd6:	f7fd fb65 	bl	80176a4 <lv_area_copy>
    sh_area.x2 = sw / 2 + r - 1  - ((sw & 1) ? 0 : 1);
 8019fda:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8019fde:	0fda      	lsrs	r2, r3, #31
 8019fe0:	4413      	add	r3, r2
 8019fe2:	105b      	asrs	r3, r3, #1
 8019fe4:	b21b      	sxth	r3, r3
 8019fe6:	b29a      	uxth	r2, r3
 8019fe8:	88bb      	ldrh	r3, [r7, #4]
 8019fea:	4413      	add	r3, r2
 8019fec:	b29a      	uxth	r2, r3
 8019fee:	88fb      	ldrh	r3, [r7, #6]
 8019ff0:	f003 0301 	and.w	r3, r3, #1
 8019ff4:	2b00      	cmp	r3, #0
 8019ff6:	bf0c      	ite	eq
 8019ff8:	2301      	moveq	r3, #1
 8019ffa:	2300      	movne	r3, #0
 8019ffc:	b2db      	uxtb	r3, r3
 8019ffe:	b29b      	uxth	r3, r3
 801a000:	1ad3      	subs	r3, r2, r3
 801a002:	b29b      	uxth	r3, r3
 801a004:	3b01      	subs	r3, #1
 801a006:	b29b      	uxth	r3, r3
 801a008:	b21b      	sxth	r3, r3
 801a00a:	86bb      	strh	r3, [r7, #52]	; 0x34
    sh_area.y1 = sw / 2 + 1;
 801a00c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a010:	0fda      	lsrs	r2, r3, #31
 801a012:	4413      	add	r3, r2
 801a014:	105b      	asrs	r3, r3, #1
 801a016:	b21b      	sxth	r3, r3
 801a018:	b29b      	uxth	r3, r3
 801a01a:	3301      	adds	r3, #1
 801a01c:	b29b      	uxth	r3, r3
 801a01e:	b21b      	sxth	r3, r3
 801a020:	867b      	strh	r3, [r7, #50]	; 0x32

    sh_area.x1 = sh_area.x2 - lv_area_get_width(coords);
 801a022:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 801a026:	b29c      	uxth	r4, r3
 801a028:	68f8      	ldr	r0, [r7, #12]
 801a02a:	f7fd fb49 	bl	80176c0 <lv_area_get_width>
 801a02e:	4603      	mov	r3, r0
 801a030:	b29b      	uxth	r3, r3
 801a032:	1ae3      	subs	r3, r4, r3
 801a034:	b29b      	uxth	r3, r3
 801a036:	b21b      	sxth	r3, r3
 801a038:	863b      	strh	r3, [r7, #48]	; 0x30
    sh_area.y2 = sh_area.y1 + lv_area_get_height(coords);
 801a03a:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a03e:	b29c      	uxth	r4, r3
 801a040:	68f8      	ldr	r0, [r7, #12]
 801a042:	f7fd fb54 	bl	80176ee <lv_area_get_height>
 801a046:	4603      	mov	r3, r0
 801a048:	b29b      	uxth	r3, r3
 801a04a:	4423      	add	r3, r4
 801a04c:	b29b      	uxth	r3, r3
 801a04e:	b21b      	sxth	r3, r3
 801a050:	86fb      	strh	r3, [r7, #54]	; 0x36

    lv_draw_mask_radius_param_t mask_param;
    lv_draw_mask_radius_init(&mask_param, &sh_area, r, false);
 801a052:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801a056:	f107 0130 	add.w	r1, r7, #48	; 0x30
 801a05a:	f107 0014 	add.w	r0, r7, #20
 801a05e:	2300      	movs	r3, #0
 801a060:	f7fc f990 	bl	8016384 <lv_draw_mask_radius_init>

#if SHADOW_ENHANCE
    /*Set half shadow width width because blur will be repeated*/
    if(sw_ori == 1) sw = 1;
 801a064:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801a066:	2b01      	cmp	r3, #1
 801a068:	d102      	bne.n	801a070 <shadow_draw_corner_buf+0xc8>
 801a06a:	2301      	movs	r3, #1
 801a06c:	80fb      	strh	r3, [r7, #6]
 801a06e:	e002      	b.n	801a076 <shadow_draw_corner_buf+0xce>
    else sw = sw_ori >> 1;
 801a070:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801a072:	105b      	asrs	r3, r3, #1
 801a074:	80fb      	strh	r3, [r7, #6]
#endif

    int32_t y;
    lv_opa_t * mask_line = _lv_mem_buf_get(size);
 801a076:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a078:	4618      	mov	r0, r3
 801a07a:	f006 ff09 	bl	8020e90 <_lv_mem_buf_get>
 801a07e:	6478      	str	r0, [r7, #68]	; 0x44
    uint16_t * sh_ups_tmp_buf = (uint16_t *)sh_buf;
 801a080:	68bb      	ldr	r3, [r7, #8]
 801a082:	663b      	str	r3, [r7, #96]	; 0x60
    for(y = 0; y < size; y++) {
 801a084:	2300      	movs	r3, #0
 801a086:	667b      	str	r3, [r7, #100]	; 0x64
 801a088:	e062      	b.n	801a150 <shadow_draw_corner_buf+0x1a8>
        _lv_memset_ff(mask_line, size);
 801a08a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a08c:	4619      	mov	r1, r3
 801a08e:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801a090:	f007 fb8b 	bl	80217aa <_lv_memset_ff>
        lv_draw_mask_res_t mask_res = mask_param.dsc.cb(mask_line, 0, y, size, &mask_param);
 801a094:	697c      	ldr	r4, [r7, #20]
 801a096:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801a098:	b21a      	sxth	r2, r3
 801a09a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a09c:	b219      	sxth	r1, r3
 801a09e:	f107 0314 	add.w	r3, r7, #20
 801a0a2:	9300      	str	r3, [sp, #0]
 801a0a4:	460b      	mov	r3, r1
 801a0a6:	2100      	movs	r1, #0
 801a0a8:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801a0aa:	47a0      	blx	r4
 801a0ac:	4603      	mov	r3, r0
 801a0ae:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
        if(mask_res == LV_DRAW_MASK_RES_TRANSP) {
 801a0b2:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 801a0b6:	2b00      	cmp	r3, #0
 801a0b8:	d106      	bne.n	801a0c8 <shadow_draw_corner_buf+0x120>
            _lv_memset_00(sh_ups_tmp_buf, size * sizeof(sh_ups_tmp_buf[0]));
 801a0ba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a0bc:	005b      	lsls	r3, r3, #1
 801a0be:	4619      	mov	r1, r3
 801a0c0:	6e38      	ldr	r0, [r7, #96]	; 0x60
 801a0c2:	f007 faf1 	bl	80216a8 <_lv_memset_00>
 801a0c6:	e03b      	b.n	801a140 <shadow_draw_corner_buf+0x198>
        }
        else {
            int32_t i;
            sh_ups_tmp_buf[0] = (mask_line[0] << SHADOW_UPSACALE_SHIFT) / sw;
 801a0c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801a0ca:	781b      	ldrb	r3, [r3, #0]
 801a0cc:	019a      	lsls	r2, r3, #6
 801a0ce:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a0d2:	fb92 f3f3 	sdiv	r3, r2, r3
 801a0d6:	b29a      	uxth	r2, r3
 801a0d8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801a0da:	801a      	strh	r2, [r3, #0]
            for(i = 1; i < size; i++) {
 801a0dc:	2301      	movs	r3, #1
 801a0de:	65fb      	str	r3, [r7, #92]	; 0x5c
 801a0e0:	e02a      	b.n	801a138 <shadow_draw_corner_buf+0x190>
                if(mask_line[i] == mask_line[i - 1]) sh_ups_tmp_buf[i] = sh_ups_tmp_buf[i - 1];
 801a0e2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801a0e4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a0e6:	4413      	add	r3, r2
 801a0e8:	781a      	ldrb	r2, [r3, #0]
 801a0ea:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801a0ec:	3b01      	subs	r3, #1
 801a0ee:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801a0f0:	440b      	add	r3, r1
 801a0f2:	781b      	ldrb	r3, [r3, #0]
 801a0f4:	429a      	cmp	r2, r3
 801a0f6:	d10d      	bne.n	801a114 <shadow_draw_corner_buf+0x16c>
 801a0f8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801a0fa:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 801a0fe:	3b01      	subs	r3, #1
 801a100:	005b      	lsls	r3, r3, #1
 801a102:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801a104:	441a      	add	r2, r3
 801a106:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801a108:	005b      	lsls	r3, r3, #1
 801a10a:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801a10c:	440b      	add	r3, r1
 801a10e:	8812      	ldrh	r2, [r2, #0]
 801a110:	801a      	strh	r2, [r3, #0]
 801a112:	e00e      	b.n	801a132 <shadow_draw_corner_buf+0x18a>
                else  sh_ups_tmp_buf[i] = (mask_line[i] << SHADOW_UPSACALE_SHIFT) / sw;
 801a114:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801a116:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801a118:	4413      	add	r3, r2
 801a11a:	781b      	ldrb	r3, [r3, #0]
 801a11c:	019a      	lsls	r2, r3, #6
 801a11e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a122:	fb92 f1f3 	sdiv	r1, r2, r3
 801a126:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801a128:	005b      	lsls	r3, r3, #1
 801a12a:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801a12c:	4413      	add	r3, r2
 801a12e:	b28a      	uxth	r2, r1
 801a130:	801a      	strh	r2, [r3, #0]
            for(i = 1; i < size; i++) {
 801a132:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 801a134:	3301      	adds	r3, #1
 801a136:	65fb      	str	r3, [r7, #92]	; 0x5c
 801a138:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 801a13a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a13c:	429a      	cmp	r2, r3
 801a13e:	dbd0      	blt.n	801a0e2 <shadow_draw_corner_buf+0x13a>
            }
        }

        sh_ups_tmp_buf += size;
 801a140:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a142:	005b      	lsls	r3, r3, #1
 801a144:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801a146:	4413      	add	r3, r2
 801a148:	663b      	str	r3, [r7, #96]	; 0x60
    for(y = 0; y < size; y++) {
 801a14a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801a14c:	3301      	adds	r3, #1
 801a14e:	667b      	str	r3, [r7, #100]	; 0x64
 801a150:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801a152:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a154:	429a      	cmp	r2, r3
 801a156:	db98      	blt.n	801a08a <shadow_draw_corner_buf+0xe2>
    }
    _lv_mem_buf_release(mask_line);
 801a158:	6c78      	ldr	r0, [r7, #68]	; 0x44
 801a15a:	f006 ff79 	bl	8021050 <_lv_mem_buf_release>

    if(sw == 1) {
 801a15e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a162:	2b01      	cmp	r3, #1
 801a164:	d11a      	bne.n	801a19c <shadow_draw_corner_buf+0x1f4>
        int32_t i;
        lv_opa_t * res_buf = (lv_opa_t *)sh_buf;
 801a166:	68bb      	ldr	r3, [r7, #8]
 801a168:	63fb      	str	r3, [r7, #60]	; 0x3c
        for(i = 0; i < size * size; i++) {
 801a16a:	2300      	movs	r3, #0
 801a16c:	65bb      	str	r3, [r7, #88]	; 0x58
 801a16e:	e00e      	b.n	801a18e <shadow_draw_corner_buf+0x1e6>
            res_buf[i] = (sh_buf[i] >> SHADOW_UPSACALE_SHIFT);
 801a170:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801a172:	005b      	lsls	r3, r3, #1
 801a174:	68ba      	ldr	r2, [r7, #8]
 801a176:	4413      	add	r3, r2
 801a178:	881b      	ldrh	r3, [r3, #0]
 801a17a:	099b      	lsrs	r3, r3, #6
 801a17c:	b299      	uxth	r1, r3
 801a17e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801a180:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801a182:	4413      	add	r3, r2
 801a184:	b2ca      	uxtb	r2, r1
 801a186:	701a      	strb	r2, [r3, #0]
        for(i = 0; i < size * size; i++) {
 801a188:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801a18a:	3301      	adds	r3, #1
 801a18c:	65bb      	str	r3, [r7, #88]	; 0x58
 801a18e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a190:	fb03 f303 	mul.w	r3, r3, r3
 801a194:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801a196:	429a      	cmp	r2, r3
 801a198:	dbea      	blt.n	801a170 <shadow_draw_corner_buf+0x1c8>
        }
        return;
 801a19a:	e078      	b.n	801a28e <shadow_draw_corner_buf+0x2e6>
    }

    shadow_blur_corner(size, sw, sh_buf);
 801a19c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a19e:	b21b      	sxth	r3, r3
 801a1a0:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 801a1a4:	68ba      	ldr	r2, [r7, #8]
 801a1a6:	4618      	mov	r0, r3
 801a1a8:	f000 f874 	bl	801a294 <shadow_blur_corner>
    lv_opa_t * res_buf = (lv_opa_t *)sh_buf;
    for(x = 0; x < size * size; x++) {
        res_buf[x] = sh_buf[x];
    }
#else
    sw += sw_ori & 1;
 801a1ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801a1ae:	b29b      	uxth	r3, r3
 801a1b0:	f003 0301 	and.w	r3, r3, #1
 801a1b4:	b29a      	uxth	r2, r3
 801a1b6:	88fb      	ldrh	r3, [r7, #6]
 801a1b8:	4413      	add	r3, r2
 801a1ba:	b29b      	uxth	r3, r3
 801a1bc:	80fb      	strh	r3, [r7, #6]
    if(sw > 1) {
 801a1be:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a1c2:	2b01      	cmp	r3, #1
 801a1c4:	dd4b      	ble.n	801a25e <shadow_draw_corner_buf+0x2b6>
        uint32_t i;
        sh_buf[0] = (sh_buf[0] << SHADOW_UPSACALE_SHIFT) / sw;
 801a1c6:	68bb      	ldr	r3, [r7, #8]
 801a1c8:	881b      	ldrh	r3, [r3, #0]
 801a1ca:	019a      	lsls	r2, r3, #6
 801a1cc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a1d0:	fb92 f3f3 	sdiv	r3, r2, r3
 801a1d4:	b29a      	uxth	r2, r3
 801a1d6:	68bb      	ldr	r3, [r7, #8]
 801a1d8:	801a      	strh	r2, [r3, #0]
        for(i = 1; i < (uint32_t) size * size; i++) {
 801a1da:	2301      	movs	r3, #1
 801a1dc:	657b      	str	r3, [r7, #84]	; 0x54
 801a1de:	e02f      	b.n	801a240 <shadow_draw_corner_buf+0x298>
            if(sh_buf[i] == sh_buf[i - 1]) sh_buf[i] = sh_buf[i - 1];
 801a1e0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a1e2:	005b      	lsls	r3, r3, #1
 801a1e4:	68ba      	ldr	r2, [r7, #8]
 801a1e6:	4413      	add	r3, r2
 801a1e8:	881a      	ldrh	r2, [r3, #0]
 801a1ea:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a1ec:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 801a1f0:	3b01      	subs	r3, #1
 801a1f2:	005b      	lsls	r3, r3, #1
 801a1f4:	68b9      	ldr	r1, [r7, #8]
 801a1f6:	440b      	add	r3, r1
 801a1f8:	881b      	ldrh	r3, [r3, #0]
 801a1fa:	429a      	cmp	r2, r3
 801a1fc:	d10d      	bne.n	801a21a <shadow_draw_corner_buf+0x272>
 801a1fe:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a200:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 801a204:	3b01      	subs	r3, #1
 801a206:	005b      	lsls	r3, r3, #1
 801a208:	68ba      	ldr	r2, [r7, #8]
 801a20a:	441a      	add	r2, r3
 801a20c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a20e:	005b      	lsls	r3, r3, #1
 801a210:	68b9      	ldr	r1, [r7, #8]
 801a212:	440b      	add	r3, r1
 801a214:	8812      	ldrh	r2, [r2, #0]
 801a216:	801a      	strh	r2, [r3, #0]
 801a218:	e00f      	b.n	801a23a <shadow_draw_corner_buf+0x292>
            else  sh_buf[i] = (sh_buf[i] << SHADOW_UPSACALE_SHIFT) / sw;
 801a21a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a21c:	005b      	lsls	r3, r3, #1
 801a21e:	68ba      	ldr	r2, [r7, #8]
 801a220:	4413      	add	r3, r2
 801a222:	881b      	ldrh	r3, [r3, #0]
 801a224:	019a      	lsls	r2, r3, #6
 801a226:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a22a:	fb92 f1f3 	sdiv	r1, r2, r3
 801a22e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a230:	005b      	lsls	r3, r3, #1
 801a232:	68ba      	ldr	r2, [r7, #8]
 801a234:	4413      	add	r3, r2
 801a236:	b28a      	uxth	r2, r1
 801a238:	801a      	strh	r2, [r3, #0]
        for(i = 1; i < (uint32_t) size * size; i++) {
 801a23a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801a23c:	3301      	adds	r3, #1
 801a23e:	657b      	str	r3, [r7, #84]	; 0x54
 801a240:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a242:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801a244:	fb02 f303 	mul.w	r3, r2, r3
 801a248:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801a24a:	429a      	cmp	r2, r3
 801a24c:	d3c8      	bcc.n	801a1e0 <shadow_draw_corner_buf+0x238>
        }

        shadow_blur_corner(size, sw, sh_buf);
 801a24e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a250:	b21b      	sxth	r3, r3
 801a252:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 801a256:	68ba      	ldr	r2, [r7, #8]
 801a258:	4618      	mov	r0, r3
 801a25a:	f000 f81b 	bl	801a294 <shadow_blur_corner>
    }
    int32_t x;
    lv_opa_t * res_buf = (lv_opa_t *)sh_buf;
 801a25e:	68bb      	ldr	r3, [r7, #8]
 801a260:	643b      	str	r3, [r7, #64]	; 0x40
    for(x = 0; x < size * size; x++) {
 801a262:	2300      	movs	r3, #0
 801a264:	653b      	str	r3, [r7, #80]	; 0x50
 801a266:	e00c      	b.n	801a282 <shadow_draw_corner_buf+0x2da>
        res_buf[x] = sh_buf[x];
 801a268:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801a26a:	005b      	lsls	r3, r3, #1
 801a26c:	68ba      	ldr	r2, [r7, #8]
 801a26e:	4413      	add	r3, r2
 801a270:	8819      	ldrh	r1, [r3, #0]
 801a272:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801a274:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801a276:	4413      	add	r3, r2
 801a278:	b2ca      	uxtb	r2, r1
 801a27a:	701a      	strb	r2, [r3, #0]
    for(x = 0; x < size * size; x++) {
 801a27c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801a27e:	3301      	adds	r3, #1
 801a280:	653b      	str	r3, [r7, #80]	; 0x50
 801a282:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801a284:	fb03 f303 	mul.w	r3, r3, r3
 801a288:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801a28a:	429a      	cmp	r2, r3
 801a28c:	dbec      	blt.n	801a268 <shadow_draw_corner_buf+0x2c0>
    }
#endif

}
 801a28e:	376c      	adds	r7, #108	; 0x6c
 801a290:	46bd      	mov	sp, r7
 801a292:	bd90      	pop	{r4, r7, pc}

0801a294 <shadow_blur_corner>:

LV_ATTRIBUTE_FAST_MEM static void shadow_blur_corner(lv_coord_t size, lv_coord_t sw, uint16_t * sh_ups_buf)
{
 801a294:	b580      	push	{r7, lr}
 801a296:	b090      	sub	sp, #64	; 0x40
 801a298:	af00      	add	r7, sp, #0
 801a29a:	4603      	mov	r3, r0
 801a29c:	603a      	str	r2, [r7, #0]
 801a29e:	80fb      	strh	r3, [r7, #6]
 801a2a0:	460b      	mov	r3, r1
 801a2a2:	80bb      	strh	r3, [r7, #4]
    int32_t s_left = sw >> 1;
 801a2a4:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801a2a8:	105b      	asrs	r3, r3, #1
 801a2aa:	b21b      	sxth	r3, r3
 801a2ac:	63fb      	str	r3, [r7, #60]	; 0x3c
    int32_t s_right = (sw >> 1);
 801a2ae:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801a2b2:	105b      	asrs	r3, r3, #1
 801a2b4:	b21b      	sxth	r3, r3
 801a2b6:	613b      	str	r3, [r7, #16]
    if((sw & 1) == 0) s_left--;
 801a2b8:	88bb      	ldrh	r3, [r7, #4]
 801a2ba:	f003 0301 	and.w	r3, r3, #1
 801a2be:	2b00      	cmp	r3, #0
 801a2c0:	d102      	bne.n	801a2c8 <shadow_blur_corner+0x34>
 801a2c2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a2c4:	3b01      	subs	r3, #1
 801a2c6:	63fb      	str	r3, [r7, #60]	; 0x3c

    /*Horizontal blur*/
    uint16_t * sh_ups_blur_buf = _lv_mem_buf_get(size * sizeof(uint16_t));
 801a2c8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a2cc:	005b      	lsls	r3, r3, #1
 801a2ce:	4618      	mov	r0, r3
 801a2d0:	f006 fdde 	bl	8020e90 <_lv_mem_buf_get>
 801a2d4:	60f8      	str	r0, [r7, #12]

    int32_t x;
    int32_t y;

    uint16_t * sh_ups_tmp_buf = sh_ups_buf;
 801a2d6:	683b      	ldr	r3, [r7, #0]
 801a2d8:	633b      	str	r3, [r7, #48]	; 0x30

    for(y = 0; y < size; y++) {
 801a2da:	2300      	movs	r3, #0
 801a2dc:	637b      	str	r3, [r7, #52]	; 0x34
 801a2de:	e05e      	b.n	801a39e <shadow_blur_corner+0x10a>
        int32_t v = sh_ups_tmp_buf[size - 1] * sw;
 801a2e0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a2e4:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 801a2e8:	3b01      	subs	r3, #1
 801a2ea:	005b      	lsls	r3, r3, #1
 801a2ec:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801a2ee:	4413      	add	r3, r2
 801a2f0:	881b      	ldrh	r3, [r3, #0]
 801a2f2:	461a      	mov	r2, r3
 801a2f4:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801a2f8:	fb02 f303 	mul.w	r3, r2, r3
 801a2fc:	62fb      	str	r3, [r7, #44]	; 0x2c
        for(x = size - 1; x >= 0; x--) {
 801a2fe:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a302:	3b01      	subs	r3, #1
 801a304:	63bb      	str	r3, [r7, #56]	; 0x38
 801a306:	e036      	b.n	801a376 <shadow_blur_corner+0xe2>
            sh_ups_blur_buf[x] = v;
 801a308:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a30a:	005b      	lsls	r3, r3, #1
 801a30c:	68fa      	ldr	r2, [r7, #12]
 801a30e:	4413      	add	r3, r2
 801a310:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a312:	b292      	uxth	r2, r2
 801a314:	801a      	strh	r2, [r3, #0]

            /*Forget the right pixel*/
            uint32_t right_val = 0;
 801a316:	2300      	movs	r3, #0
 801a318:	62bb      	str	r3, [r7, #40]	; 0x28
            if(x + s_right < size) right_val = sh_ups_tmp_buf[x + s_right];
 801a31a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a31c:	693b      	ldr	r3, [r7, #16]
 801a31e:	441a      	add	r2, r3
 801a320:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a324:	429a      	cmp	r2, r3
 801a326:	da07      	bge.n	801a338 <shadow_blur_corner+0xa4>
 801a328:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a32a:	693b      	ldr	r3, [r7, #16]
 801a32c:	4413      	add	r3, r2
 801a32e:	005b      	lsls	r3, r3, #1
 801a330:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801a332:	4413      	add	r3, r2
 801a334:	881b      	ldrh	r3, [r3, #0]
 801a336:	62bb      	str	r3, [r7, #40]	; 0x28
            v -= right_val;
 801a338:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a33a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801a33c:	1ad3      	subs	r3, r2, r3
 801a33e:	62fb      	str	r3, [r7, #44]	; 0x2c

            /*Add the left pixel*/
            uint32_t left_val;
            if(x - s_left - 1 < 0) left_val = sh_ups_tmp_buf[0];
 801a340:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a342:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a344:	1ad3      	subs	r3, r2, r3
 801a346:	2b00      	cmp	r3, #0
 801a348:	dc03      	bgt.n	801a352 <shadow_blur_corner+0xbe>
 801a34a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a34c:	881b      	ldrh	r3, [r3, #0]
 801a34e:	627b      	str	r3, [r7, #36]	; 0x24
 801a350:	e00a      	b.n	801a368 <shadow_blur_corner+0xd4>
            else left_val = sh_ups_tmp_buf[x - s_left - 1];
 801a352:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a354:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a356:	1ad3      	subs	r3, r2, r3
 801a358:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 801a35c:	3b01      	subs	r3, #1
 801a35e:	005b      	lsls	r3, r3, #1
 801a360:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801a362:	4413      	add	r3, r2
 801a364:	881b      	ldrh	r3, [r3, #0]
 801a366:	627b      	str	r3, [r7, #36]	; 0x24
            v += left_val;
 801a368:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801a36a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a36c:	4413      	add	r3, r2
 801a36e:	62fb      	str	r3, [r7, #44]	; 0x2c
        for(x = size - 1; x >= 0; x--) {
 801a370:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a372:	3b01      	subs	r3, #1
 801a374:	63bb      	str	r3, [r7, #56]	; 0x38
 801a376:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a378:	2b00      	cmp	r3, #0
 801a37a:	dac5      	bge.n	801a308 <shadow_blur_corner+0x74>
        }
        _lv_memcpy(sh_ups_tmp_buf, sh_ups_blur_buf, size * sizeof(uint16_t));
 801a37c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a380:	005b      	lsls	r3, r3, #1
 801a382:	461a      	mov	r2, r3
 801a384:	68f9      	ldr	r1, [r7, #12]
 801a386:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801a388:	f006 fee8 	bl	802115c <_lv_memcpy>
        sh_ups_tmp_buf += size;
 801a38c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a390:	005b      	lsls	r3, r3, #1
 801a392:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801a394:	4413      	add	r3, r2
 801a396:	633b      	str	r3, [r7, #48]	; 0x30
    for(y = 0; y < size; y++) {
 801a398:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a39a:	3301      	adds	r3, #1
 801a39c:	637b      	str	r3, [r7, #52]	; 0x34
 801a39e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a3a2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a3a4:	429a      	cmp	r2, r3
 801a3a6:	db9b      	blt.n	801a2e0 <shadow_blur_corner+0x4c>
    }

    /*Vertical blur*/
    uint32_t i;
    sh_ups_buf[0] = sh_ups_buf[0] / sw;
 801a3a8:	683b      	ldr	r3, [r7, #0]
 801a3aa:	881b      	ldrh	r3, [r3, #0]
 801a3ac:	461a      	mov	r2, r3
 801a3ae:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801a3b2:	fb92 f3f3 	sdiv	r3, r2, r3
 801a3b6:	b29a      	uxth	r2, r3
 801a3b8:	683b      	ldr	r3, [r7, #0]
 801a3ba:	801a      	strh	r2, [r3, #0]
    for(i = 1; i < (uint32_t)size * size; i++) {
 801a3bc:	2301      	movs	r3, #1
 801a3be:	623b      	str	r3, [r7, #32]
 801a3c0:	e02f      	b.n	801a422 <shadow_blur_corner+0x18e>
        if(sh_ups_buf[i] == sh_ups_buf[i - 1]) sh_ups_buf[i] = sh_ups_buf[i - 1];
 801a3c2:	6a3b      	ldr	r3, [r7, #32]
 801a3c4:	005b      	lsls	r3, r3, #1
 801a3c6:	683a      	ldr	r2, [r7, #0]
 801a3c8:	4413      	add	r3, r2
 801a3ca:	881a      	ldrh	r2, [r3, #0]
 801a3cc:	6a3b      	ldr	r3, [r7, #32]
 801a3ce:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 801a3d2:	3b01      	subs	r3, #1
 801a3d4:	005b      	lsls	r3, r3, #1
 801a3d6:	6839      	ldr	r1, [r7, #0]
 801a3d8:	440b      	add	r3, r1
 801a3da:	881b      	ldrh	r3, [r3, #0]
 801a3dc:	429a      	cmp	r2, r3
 801a3de:	d10d      	bne.n	801a3fc <shadow_blur_corner+0x168>
 801a3e0:	6a3b      	ldr	r3, [r7, #32]
 801a3e2:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 801a3e6:	3b01      	subs	r3, #1
 801a3e8:	005b      	lsls	r3, r3, #1
 801a3ea:	683a      	ldr	r2, [r7, #0]
 801a3ec:	441a      	add	r2, r3
 801a3ee:	6a3b      	ldr	r3, [r7, #32]
 801a3f0:	005b      	lsls	r3, r3, #1
 801a3f2:	6839      	ldr	r1, [r7, #0]
 801a3f4:	440b      	add	r3, r1
 801a3f6:	8812      	ldrh	r2, [r2, #0]
 801a3f8:	801a      	strh	r2, [r3, #0]
 801a3fa:	e00f      	b.n	801a41c <shadow_blur_corner+0x188>
        else  sh_ups_buf[i] = sh_ups_buf[i] / sw;
 801a3fc:	6a3b      	ldr	r3, [r7, #32]
 801a3fe:	005b      	lsls	r3, r3, #1
 801a400:	683a      	ldr	r2, [r7, #0]
 801a402:	4413      	add	r3, r2
 801a404:	881b      	ldrh	r3, [r3, #0]
 801a406:	461a      	mov	r2, r3
 801a408:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801a40c:	fb92 f1f3 	sdiv	r1, r2, r3
 801a410:	6a3b      	ldr	r3, [r7, #32]
 801a412:	005b      	lsls	r3, r3, #1
 801a414:	683a      	ldr	r2, [r7, #0]
 801a416:	4413      	add	r3, r2
 801a418:	b28a      	uxth	r2, r1
 801a41a:	801a      	strh	r2, [r3, #0]
    for(i = 1; i < (uint32_t)size * size; i++) {
 801a41c:	6a3b      	ldr	r3, [r7, #32]
 801a41e:	3301      	adds	r3, #1
 801a420:	623b      	str	r3, [r7, #32]
 801a422:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a426:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801a42a:	fb02 f303 	mul.w	r3, r2, r3
 801a42e:	6a3a      	ldr	r2, [r7, #32]
 801a430:	429a      	cmp	r2, r3
 801a432:	d3c6      	bcc.n	801a3c2 <shadow_blur_corner+0x12e>
    }

    for(x = 0; x < size; x++) {
 801a434:	2300      	movs	r3, #0
 801a436:	63bb      	str	r3, [r7, #56]	; 0x38
 801a438:	e090      	b.n	801a55c <shadow_blur_corner+0x2c8>
        sh_ups_tmp_buf = &sh_ups_buf[x];
 801a43a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a43c:	005b      	lsls	r3, r3, #1
 801a43e:	683a      	ldr	r2, [r7, #0]
 801a440:	4413      	add	r3, r2
 801a442:	633b      	str	r3, [r7, #48]	; 0x30
        int32_t v = sh_ups_tmp_buf[0] * sw;
 801a444:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a446:	881b      	ldrh	r3, [r3, #0]
 801a448:	461a      	mov	r2, r3
 801a44a:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801a44e:	fb02 f303 	mul.w	r3, r2, r3
 801a452:	61fb      	str	r3, [r7, #28]
        for(y = 0; y < size ; y++, sh_ups_tmp_buf += size) {
 801a454:	2300      	movs	r3, #0
 801a456:	637b      	str	r3, [r7, #52]	; 0x34
 801a458:	e05b      	b.n	801a512 <shadow_blur_corner+0x27e>
            sh_ups_blur_buf[y] = v < 0 ? 0 : (v >> SHADOW_UPSACALE_SHIFT);
 801a45a:	69fb      	ldr	r3, [r7, #28]
 801a45c:	2b00      	cmp	r3, #0
 801a45e:	db03      	blt.n	801a468 <shadow_blur_corner+0x1d4>
 801a460:	69fb      	ldr	r3, [r7, #28]
 801a462:	119b      	asrs	r3, r3, #6
 801a464:	b299      	uxth	r1, r3
 801a466:	e000      	b.n	801a46a <shadow_blur_corner+0x1d6>
 801a468:	2100      	movs	r1, #0
 801a46a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a46c:	005b      	lsls	r3, r3, #1
 801a46e:	68fa      	ldr	r2, [r7, #12]
 801a470:	4413      	add	r3, r2
 801a472:	460a      	mov	r2, r1
 801a474:	801a      	strh	r2, [r3, #0]

            /*Forget the top pixel*/
            uint32_t top_val;
            if(y - s_right <= 0) top_val = sh_ups_tmp_buf[0];
 801a476:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a478:	693b      	ldr	r3, [r7, #16]
 801a47a:	1ad3      	subs	r3, r2, r3
 801a47c:	2b00      	cmp	r3, #0
 801a47e:	dc03      	bgt.n	801a488 <shadow_blur_corner+0x1f4>
 801a480:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a482:	881b      	ldrh	r3, [r3, #0]
 801a484:	61bb      	str	r3, [r7, #24]
 801a486:	e00d      	b.n	801a4a4 <shadow_blur_corner+0x210>
            else top_val = sh_ups_buf[(y - s_right) * size + x];
 801a488:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a48a:	693b      	ldr	r3, [r7, #16]
 801a48c:	1ad3      	subs	r3, r2, r3
 801a48e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801a492:	fb03 f202 	mul.w	r2, r3, r2
 801a496:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a498:	4413      	add	r3, r2
 801a49a:	005b      	lsls	r3, r3, #1
 801a49c:	683a      	ldr	r2, [r7, #0]
 801a49e:	4413      	add	r3, r2
 801a4a0:	881b      	ldrh	r3, [r3, #0]
 801a4a2:	61bb      	str	r3, [r7, #24]
            v -= top_val;
 801a4a4:	69fa      	ldr	r2, [r7, #28]
 801a4a6:	69bb      	ldr	r3, [r7, #24]
 801a4a8:	1ad3      	subs	r3, r2, r3
 801a4aa:	61fb      	str	r3, [r7, #28]

            /*Add the bottom pixel*/
            uint32_t bottom_val;
            if(y + s_left + 1 < size) bottom_val = sh_ups_buf[(y + s_left + 1) * size + x];
 801a4ac:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a4ae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a4b0:	4413      	add	r3, r2
 801a4b2:	1c5a      	adds	r2, r3, #1
 801a4b4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a4b8:	429a      	cmp	r2, r3
 801a4ba:	da0f      	bge.n	801a4dc <shadow_blur_corner+0x248>
 801a4bc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a4be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801a4c0:	4413      	add	r3, r2
 801a4c2:	3301      	adds	r3, #1
 801a4c4:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801a4c8:	fb03 f202 	mul.w	r2, r3, r2
 801a4cc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a4ce:	4413      	add	r3, r2
 801a4d0:	005b      	lsls	r3, r3, #1
 801a4d2:	683a      	ldr	r2, [r7, #0]
 801a4d4:	4413      	add	r3, r2
 801a4d6:	881b      	ldrh	r3, [r3, #0]
 801a4d8:	617b      	str	r3, [r7, #20]
 801a4da:	e00d      	b.n	801a4f8 <shadow_blur_corner+0x264>
            else bottom_val = sh_ups_buf[(size - 1) * size + x];
 801a4dc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a4e0:	3b01      	subs	r3, #1
 801a4e2:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801a4e6:	fb03 f202 	mul.w	r2, r3, r2
 801a4ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a4ec:	4413      	add	r3, r2
 801a4ee:	005b      	lsls	r3, r3, #1
 801a4f0:	683a      	ldr	r2, [r7, #0]
 801a4f2:	4413      	add	r3, r2
 801a4f4:	881b      	ldrh	r3, [r3, #0]
 801a4f6:	617b      	str	r3, [r7, #20]
            v += bottom_val;
 801a4f8:	69fa      	ldr	r2, [r7, #28]
 801a4fa:	697b      	ldr	r3, [r7, #20]
 801a4fc:	4413      	add	r3, r2
 801a4fe:	61fb      	str	r3, [r7, #28]
        for(y = 0; y < size ; y++, sh_ups_tmp_buf += size) {
 801a500:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a502:	3301      	adds	r3, #1
 801a504:	637b      	str	r3, [r7, #52]	; 0x34
 801a506:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a50a:	005b      	lsls	r3, r3, #1
 801a50c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801a50e:	4413      	add	r3, r2
 801a510:	633b      	str	r3, [r7, #48]	; 0x30
 801a512:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a516:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a518:	429a      	cmp	r2, r3
 801a51a:	db9e      	blt.n	801a45a <shadow_blur_corner+0x1c6>
        }

        /*Write back the result into `sh_ups_buf`*/
        sh_ups_tmp_buf = &sh_ups_buf[x];
 801a51c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a51e:	005b      	lsls	r3, r3, #1
 801a520:	683a      	ldr	r2, [r7, #0]
 801a522:	4413      	add	r3, r2
 801a524:	633b      	str	r3, [r7, #48]	; 0x30
        for(y = 0; y < size; y++, sh_ups_tmp_buf += size) {
 801a526:	2300      	movs	r3, #0
 801a528:	637b      	str	r3, [r7, #52]	; 0x34
 801a52a:	e00f      	b.n	801a54c <shadow_blur_corner+0x2b8>
            (*sh_ups_tmp_buf) = sh_ups_blur_buf[y];
 801a52c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a52e:	005b      	lsls	r3, r3, #1
 801a530:	68fa      	ldr	r2, [r7, #12]
 801a532:	4413      	add	r3, r2
 801a534:	881a      	ldrh	r2, [r3, #0]
 801a536:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801a538:	801a      	strh	r2, [r3, #0]
        for(y = 0; y < size; y++, sh_ups_tmp_buf += size) {
 801a53a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801a53c:	3301      	adds	r3, #1
 801a53e:	637b      	str	r3, [r7, #52]	; 0x34
 801a540:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a544:	005b      	lsls	r3, r3, #1
 801a546:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801a548:	4413      	add	r3, r2
 801a54a:	633b      	str	r3, [r7, #48]	; 0x30
 801a54c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a550:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801a552:	429a      	cmp	r2, r3
 801a554:	dbea      	blt.n	801a52c <shadow_blur_corner+0x298>
    for(x = 0; x < size; x++) {
 801a556:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801a558:	3301      	adds	r3, #1
 801a55a:	63bb      	str	r3, [r7, #56]	; 0x38
 801a55c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a560:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801a562:	429a      	cmp	r2, r3
 801a564:	f6ff af69 	blt.w	801a43a <shadow_blur_corner+0x1a6>
        }
    }

    _lv_mem_buf_release(sh_ups_blur_buf);
 801a568:	68f8      	ldr	r0, [r7, #12]
 801a56a:	f006 fd71 	bl	8021050 <_lv_mem_buf_release>
}
 801a56e:	bf00      	nop
 801a570:	3740      	adds	r7, #64	; 0x40
 801a572:	46bd      	mov	sp, r7
 801a574:	bd80      	pop	{r7, pc}

0801a576 <draw_outline>:

#endif

#if LV_USE_OUTLINE
static void draw_outline(const lv_area_t * coords, const lv_area_t * clip, const lv_draw_rect_dsc_t * dsc)
{
 801a576:	b590      	push	{r4, r7, lr}
 801a578:	b08f      	sub	sp, #60	; 0x3c
 801a57a:	af04      	add	r7, sp, #16
 801a57c:	60f8      	str	r0, [r7, #12]
 801a57e:	60b9      	str	r1, [r7, #8]
 801a580:	607a      	str	r2, [r7, #4]
    if(dsc->outline_opa <= LV_OPA_MIN) return;
 801a582:	687b      	ldr	r3, [r7, #4]
 801a584:	7f9b      	ldrb	r3, [r3, #30]
 801a586:	2b02      	cmp	r3, #2
 801a588:	f240 808d 	bls.w	801a6a6 <draw_outline+0x130>
    if(dsc->outline_width == 0) return;
 801a58c:	687b      	ldr	r3, [r7, #4]
 801a58e:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801a592:	2b00      	cmp	r3, #0
 801a594:	f000 8089 	beq.w	801a6aa <draw_outline+0x134>

    lv_opa_t opa = dsc->outline_opa;
 801a598:	687b      	ldr	r3, [r7, #4]
 801a59a:	7f9b      	ldrb	r3, [r3, #30]
 801a59c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 801a5a0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801a5a4:	2bfd      	cmp	r3, #253	; 0xfd
 801a5a6:	d902      	bls.n	801a5ae <draw_outline+0x38>
 801a5a8:	23ff      	movs	r3, #255	; 0xff
 801a5aa:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

    /*Get the inner radius*/
    lv_area_t area_inner;
    lv_area_copy(&area_inner, coords);
 801a5ae:	f107 031c 	add.w	r3, r7, #28
 801a5b2:	68f9      	ldr	r1, [r7, #12]
 801a5b4:	4618      	mov	r0, r3
 801a5b6:	f7fd f875 	bl	80176a4 <lv_area_copy>
    area_inner.x1 -= dsc->outline_pad;
 801a5ba:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 801a5be:	b29a      	uxth	r2, r3
 801a5c0:	687b      	ldr	r3, [r7, #4]
 801a5c2:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 801a5c6:	b29b      	uxth	r3, r3
 801a5c8:	1ad3      	subs	r3, r2, r3
 801a5ca:	b29b      	uxth	r3, r3
 801a5cc:	b21b      	sxth	r3, r3
 801a5ce:	83bb      	strh	r3, [r7, #28]
    area_inner.y1 -= dsc->outline_pad;
 801a5d0:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801a5d4:	b29a      	uxth	r2, r3
 801a5d6:	687b      	ldr	r3, [r7, #4]
 801a5d8:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 801a5dc:	b29b      	uxth	r3, r3
 801a5de:	1ad3      	subs	r3, r2, r3
 801a5e0:	b29b      	uxth	r3, r3
 801a5e2:	b21b      	sxth	r3, r3
 801a5e4:	83fb      	strh	r3, [r7, #30]
    area_inner.x2 += dsc->outline_pad;
 801a5e6:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801a5ea:	b29a      	uxth	r2, r3
 801a5ec:	687b      	ldr	r3, [r7, #4]
 801a5ee:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 801a5f2:	b29b      	uxth	r3, r3
 801a5f4:	4413      	add	r3, r2
 801a5f6:	b29b      	uxth	r3, r3
 801a5f8:	b21b      	sxth	r3, r3
 801a5fa:	843b      	strh	r3, [r7, #32]
    area_inner.y2 += dsc->outline_pad;
 801a5fc:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801a600:	b29a      	uxth	r2, r3
 801a602:	687b      	ldr	r3, [r7, #4]
 801a604:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 801a608:	b29b      	uxth	r3, r3
 801a60a:	4413      	add	r3, r2
 801a60c:	b29b      	uxth	r3, r3
 801a60e:	b21b      	sxth	r3, r3
 801a610:	847b      	strh	r3, [r7, #34]	; 0x22

    lv_area_t area_outer;
    lv_area_copy(&area_outer, &area_inner);
 801a612:	f107 021c 	add.w	r2, r7, #28
 801a616:	f107 0314 	add.w	r3, r7, #20
 801a61a:	4611      	mov	r1, r2
 801a61c:	4618      	mov	r0, r3
 801a61e:	f7fd f841 	bl	80176a4 <lv_area_copy>

    area_outer.x1 -= dsc->outline_width;
 801a622:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801a626:	b29a      	uxth	r2, r3
 801a628:	687b      	ldr	r3, [r7, #4]
 801a62a:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801a62e:	b29b      	uxth	r3, r3
 801a630:	1ad3      	subs	r3, r2, r3
 801a632:	b29b      	uxth	r3, r3
 801a634:	b21b      	sxth	r3, r3
 801a636:	82bb      	strh	r3, [r7, #20]
    area_outer.x2 += dsc->outline_width;
 801a638:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801a63c:	b29a      	uxth	r2, r3
 801a63e:	687b      	ldr	r3, [r7, #4]
 801a640:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801a644:	b29b      	uxth	r3, r3
 801a646:	4413      	add	r3, r2
 801a648:	b29b      	uxth	r3, r3
 801a64a:	b21b      	sxth	r3, r3
 801a64c:	833b      	strh	r3, [r7, #24]
    area_outer.y1 -= dsc->outline_width;
 801a64e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801a652:	b29a      	uxth	r2, r3
 801a654:	687b      	ldr	r3, [r7, #4]
 801a656:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801a65a:	b29b      	uxth	r3, r3
 801a65c:	1ad3      	subs	r3, r2, r3
 801a65e:	b29b      	uxth	r3, r3
 801a660:	b21b      	sxth	r3, r3
 801a662:	82fb      	strh	r3, [r7, #22]
    area_outer.y2 += dsc->outline_width;
 801a664:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801a668:	b29a      	uxth	r2, r3
 801a66a:	687b      	ldr	r3, [r7, #4]
 801a66c:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801a670:	b29b      	uxth	r3, r3
 801a672:	4413      	add	r3, r2
 801a674:	b29b      	uxth	r3, r3
 801a676:	b21b      	sxth	r3, r3
 801a678:	837b      	strh	r3, [r7, #26]

    draw_full_border(&area_inner, &area_outer, clip, dsc->radius, dsc->outline_color, dsc->outline_opa,
 801a67a:	687b      	ldr	r3, [r7, #4]
 801a67c:	f9b3 4000 	ldrsh.w	r4, [r3]
 801a680:	687b      	ldr	r3, [r7, #4]
 801a682:	7f9b      	ldrb	r3, [r3, #30]
                     dsc->outline_blend_mode);
 801a684:	687a      	ldr	r2, [r7, #4]
 801a686:	7fd2      	ldrb	r2, [r2, #31]
    draw_full_border(&area_inner, &area_outer, clip, dsc->radius, dsc->outline_color, dsc->outline_opa,
 801a688:	f107 0114 	add.w	r1, r7, #20
 801a68c:	f107 001c 	add.w	r0, r7, #28
 801a690:	9202      	str	r2, [sp, #8]
 801a692:	9301      	str	r3, [sp, #4]
 801a694:	687b      	ldr	r3, [r7, #4]
 801a696:	8b1b      	ldrh	r3, [r3, #24]
 801a698:	f8ad 3000 	strh.w	r3, [sp]
 801a69c:	4623      	mov	r3, r4
 801a69e:	68ba      	ldr	r2, [r7, #8]
 801a6a0:	f000 facd 	bl	801ac3e <draw_full_border>
 801a6a4:	e002      	b.n	801a6ac <draw_outline+0x136>
    if(dsc->outline_opa <= LV_OPA_MIN) return;
 801a6a6:	bf00      	nop
 801a6a8:	e000      	b.n	801a6ac <draw_outline+0x136>
    if(dsc->outline_width == 0) return;
 801a6aa:	bf00      	nop
}
 801a6ac:	372c      	adds	r7, #44	; 0x2c
 801a6ae:	46bd      	mov	sp, r7
 801a6b0:	bd90      	pop	{r4, r7, pc}

0801a6b2 <draw_pattern>:
#endif

#if LV_USE_PATTERN
static void draw_pattern(const lv_area_t * coords, const lv_area_t * clip, const lv_draw_rect_dsc_t * dsc)
{
 801a6b2:	b5b0      	push	{r4, r5, r7, lr}
 801a6b4:	b0b0      	sub	sp, #192	; 0xc0
 801a6b6:	af04      	add	r7, sp, #16
 801a6b8:	60f8      	str	r0, [r7, #12]
 801a6ba:	60b9      	str	r1, [r7, #8]
 801a6bc:	607a      	str	r2, [r7, #4]
    if(dsc->pattern_image == NULL) return;
 801a6be:	687b      	ldr	r3, [r7, #4]
 801a6c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a6c2:	2b00      	cmp	r3, #0
 801a6c4:	f000 8207 	beq.w	801aad6 <draw_pattern+0x424>
    if(dsc->pattern_opa <= LV_OPA_MIN) return;
 801a6c8:	687b      	ldr	r3, [r7, #4]
 801a6ca:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 801a6ce:	2b02      	cmp	r3, #2
 801a6d0:	f240 8203 	bls.w	801aada <draw_pattern+0x428>

    lv_img_src_t src_type = lv_img_src_get_type(dsc->pattern_image);
 801a6d4:	687b      	ldr	r3, [r7, #4]
 801a6d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a6d8:	4618      	mov	r0, r3
 801a6da:	f7f7 ff7c 	bl	80125d6 <lv_img_src_get_type>
 801a6de:	4603      	mov	r3, r0
 801a6e0:	f887 30a5 	strb.w	r3, [r7, #165]	; 0xa5
    lv_draw_img_dsc_t img_dsc;
    lv_draw_label_dsc_t label_dsc;
    int32_t img_w;
    int32_t img_h;

    if(src_type == LV_IMG_SRC_FILE || src_type == LV_IMG_SRC_VARIABLE) {
 801a6e4:	f897 30a5 	ldrb.w	r3, [r7, #165]	; 0xa5
 801a6e8:	2b01      	cmp	r3, #1
 801a6ea:	d003      	beq.n	801a6f4 <draw_pattern+0x42>
 801a6ec:	f897 30a5 	ldrb.w	r3, [r7, #165]	; 0xa5
 801a6f0:	2b00      	cmp	r3, #0
 801a6f2:	d130      	bne.n	801a756 <draw_pattern+0xa4>
        lv_img_header_t header;
        lv_res_t res = lv_img_decoder_get_info(dsc->pattern_image, &header);
 801a6f4:	687b      	ldr	r3, [r7, #4]
 801a6f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a6f8:	f107 0250 	add.w	r2, r7, #80	; 0x50
 801a6fc:	4611      	mov	r1, r2
 801a6fe:	4618      	mov	r0, r3
 801a700:	f002 f994 	bl	801ca2c <lv_img_decoder_get_info>
 801a704:	4603      	mov	r3, r0
 801a706:	f887 30a4 	strb.w	r3, [r7, #164]	; 0xa4
        if(res != LV_RES_OK) {
 801a70a:	f897 30a4 	ldrb.w	r3, [r7, #164]	; 0xa4
 801a70e:	2b01      	cmp	r3, #1
 801a710:	f040 81e5 	bne.w	801aade <draw_pattern+0x42c>
            LV_LOG_WARN("draw_img: can't get image info");
            return;
        }

        img_w = header.w;
 801a714:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801a716:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a71a:	b29b      	uxth	r3, r3
 801a71c:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
        img_h = header.h;
 801a720:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 801a724:	f3c3 134a 	ubfx	r3, r3, #5, #11
 801a728:	b29b      	uxth	r3, r3
 801a72a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

        lv_draw_img_dsc_init(&img_dsc);
 801a72e:	f107 037c 	add.w	r3, r7, #124	; 0x7c
 801a732:	4618      	mov	r0, r3
 801a734:	f7f7 fe6a 	bl	801240c <lv_draw_img_dsc_init>
        img_dsc.opa = dsc->pattern_opa;
 801a738:	687b      	ldr	r3, [r7, #4]
 801a73a:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 801a73e:	f887 307c 	strb.w	r3, [r7, #124]	; 0x7c
        img_dsc.recolor_opa = dsc->pattern_recolor_opa;
 801a742:	687b      	ldr	r3, [r7, #4]
 801a744:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
 801a748:	f887 3086 	strb.w	r3, [r7, #134]	; 0x86
        img_dsc.recolor = dsc->pattern_recolor;
 801a74c:	687b      	ldr	r3, [r7, #4]
 801a74e:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 801a750:	f8a7 3088 	strh.w	r3, [r7, #136]	; 0x88
    if(src_type == LV_IMG_SRC_FILE || src_type == LV_IMG_SRC_VARIABLE) {
 801a754:	e036      	b.n	801a7c4 <draw_pattern+0x112>
    }
    else if(src_type == LV_IMG_SRC_SYMBOL) {
 801a756:	f897 30a5 	ldrb.w	r3, [r7, #165]	; 0xa5
 801a75a:	2b02      	cmp	r3, #2
 801a75c:	d12b      	bne.n	801a7b6 <draw_pattern+0x104>
        lv_draw_label_dsc_init(&label_dsc);
 801a75e:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 801a762:	4618      	mov	r0, r3
 801a764:	f7f8 fdf8 	bl	8013358 <lv_draw_label_dsc_init>
        label_dsc.color = dsc->pattern_recolor;
 801a768:	687b      	ldr	r3, [r7, #4]
 801a76a:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 801a76c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
        label_dsc.font = dsc->pattern_font;
 801a770:	687b      	ldr	r3, [r7, #4]
 801a772:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801a774:	663b      	str	r3, [r7, #96]	; 0x60
        label_dsc.opa = dsc->pattern_opa;
 801a776:	687b      	ldr	r3, [r7, #4]
 801a778:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 801a77c:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
        lv_point_t s;
        _lv_txt_get_size(&s, dsc->pattern_image, label_dsc.font, label_dsc.letter_space, label_dsc.line_space, LV_COORD_MAX,
 801a780:	687b      	ldr	r3, [r7, #4]
 801a782:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 801a784:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801a786:	f9b7 4068 	ldrsh.w	r4, [r7, #104]	; 0x68
 801a78a:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 801a78e:	f107 004c 	add.w	r0, r7, #76	; 0x4c
 801a792:	2500      	movs	r5, #0
 801a794:	9502      	str	r5, [sp, #8]
 801a796:	f647 4518 	movw	r5, #31768	; 0x7c18
 801a79a:	9501      	str	r5, [sp, #4]
 801a79c:	9300      	str	r3, [sp, #0]
 801a79e:	4623      	mov	r3, r4
 801a7a0:	f007 fc74 	bl	802208c <_lv_txt_get_size>
                         LV_TXT_FLAG_NONE);
        img_w = s.x;
 801a7a4:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 801a7a8:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
        img_h = s.y;
 801a7ac:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801a7b0:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
 801a7b4:	e006      	b.n	801a7c4 <draw_pattern+0x112>

    }
    else {
        /*Trigger the error handler of image drawer*/
        LV_LOG_WARN("lv_img_design: image source type is unknown");
        lv_draw_img(coords, clip, NULL, NULL);
 801a7b6:	2300      	movs	r3, #0
 801a7b8:	2200      	movs	r2, #0
 801a7ba:	68b9      	ldr	r1, [r7, #8]
 801a7bc:	68f8      	ldr	r0, [r7, #12]
 801a7be:	f7f7 fe4d 	bl	801245c <lv_draw_img>
        return;
 801a7c2:	e18d      	b.n	801aae0 <draw_pattern+0x42e>
    }

    lv_area_t coords_tmp;

    if(dsc->pattern_repeat) {
 801a7c4:	687b      	ldr	r3, [r7, #4]
 801a7c6:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 801a7ca:	f003 0301 	and.w	r3, r3, #1
 801a7ce:	b2db      	uxtb	r3, r3
 801a7d0:	2b00      	cmp	r3, #0
 801a7d2:	f000 80cf 	beq.w	801a974 <draw_pattern+0x2c2>
        lv_draw_mask_radius_param_t radius_mask_param;
        lv_draw_mask_radius_init(&radius_mask_param, coords, dsc->radius, false);
 801a7d6:	687b      	ldr	r3, [r7, #4]
 801a7d8:	f9b3 2000 	ldrsh.w	r2, [r3]
 801a7dc:	f107 0030 	add.w	r0, r7, #48	; 0x30
 801a7e0:	2300      	movs	r3, #0
 801a7e2:	68f9      	ldr	r1, [r7, #12]
 801a7e4:	f7fb fdce 	bl	8016384 <lv_draw_mask_radius_init>
        int16_t radius_mask_id = lv_draw_mask_add(&radius_mask_param, NULL);
 801a7e8:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801a7ec:	2100      	movs	r1, #0
 801a7ee:	4618      	mov	r0, r3
 801a7f0:	f7fb fbae 	bl	8015f50 <lv_draw_mask_add>
 801a7f4:	4603      	mov	r3, r0
 801a7f6:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96

        /*Align the pattern to the middle*/
        int32_t ofs_x = (lv_area_get_width(coords) - (lv_area_get_width(coords) / img_w) * img_w) / 2;
 801a7fa:	68f8      	ldr	r0, [r7, #12]
 801a7fc:	f7fc ff60 	bl	80176c0 <lv_area_get_width>
 801a800:	4603      	mov	r3, r0
 801a802:	461c      	mov	r4, r3
 801a804:	68f8      	ldr	r0, [r7, #12]
 801a806:	f7fc ff5b 	bl	80176c0 <lv_area_get_width>
 801a80a:	4603      	mov	r3, r0
 801a80c:	461a      	mov	r2, r3
 801a80e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801a812:	fb92 f3f3 	sdiv	r3, r2, r3
 801a816:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
 801a81a:	fb02 f303 	mul.w	r3, r2, r3
 801a81e:	1ae3      	subs	r3, r4, r3
 801a820:	0fda      	lsrs	r2, r3, #31
 801a822:	4413      	add	r3, r2
 801a824:	105b      	asrs	r3, r3, #1
 801a826:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
        int32_t ofs_y = (lv_area_get_height(coords) - (lv_area_get_height(coords) / img_h) * img_h) / 2;
 801a82a:	68f8      	ldr	r0, [r7, #12]
 801a82c:	f7fc ff5f 	bl	80176ee <lv_area_get_height>
 801a830:	4603      	mov	r3, r0
 801a832:	461c      	mov	r4, r3
 801a834:	68f8      	ldr	r0, [r7, #12]
 801a836:	f7fc ff5a 	bl	80176ee <lv_area_get_height>
 801a83a:	4603      	mov	r3, r0
 801a83c:	461a      	mov	r2, r3
 801a83e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801a842:	fb92 f3f3 	sdiv	r3, r2, r3
 801a846:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 801a84a:	fb02 f303 	mul.w	r3, r2, r3
 801a84e:	1ae3      	subs	r3, r4, r3
 801a850:	0fda      	lsrs	r2, r3, #31
 801a852:	4413      	add	r3, r2
 801a854:	105b      	asrs	r3, r3, #1
 801a856:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

        coords_tmp.y1 = coords->y1 - ofs_y;
 801a85a:	68fb      	ldr	r3, [r7, #12]
 801a85c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801a860:	b29a      	uxth	r2, r3
 801a862:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 801a866:	b29b      	uxth	r3, r3
 801a868:	1ad3      	subs	r3, r2, r3
 801a86a:	b29b      	uxth	r3, r3
 801a86c:	b21b      	sxth	r3, r3
 801a86e:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
        coords_tmp.y2 = coords_tmp.y1 + img_h - 1;
 801a872:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801a876:	b29a      	uxth	r2, r3
 801a878:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801a87c:	b29b      	uxth	r3, r3
 801a87e:	4413      	add	r3, r2
 801a880:	b29b      	uxth	r3, r3
 801a882:	3b01      	subs	r3, #1
 801a884:	b29b      	uxth	r3, r3
 801a886:	b21b      	sxth	r3, r3
 801a888:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
        for(; coords_tmp.y1 <= coords->y2; coords_tmp.y1 += img_h, coords_tmp.y2 += img_h) {
 801a88c:	e065      	b.n	801a95a <draw_pattern+0x2a8>
            coords_tmp.x1 = coords->x1 - ofs_x;
 801a88e:	68fb      	ldr	r3, [r7, #12]
 801a890:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a894:	b29a      	uxth	r2, r3
 801a896:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 801a89a:	b29b      	uxth	r3, r3
 801a89c:	1ad3      	subs	r3, r2, r3
 801a89e:	b29b      	uxth	r3, r3
 801a8a0:	b21b      	sxth	r3, r3
 801a8a2:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            coords_tmp.x2 = coords_tmp.x1 + img_w - 1;
 801a8a6:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801a8aa:	b29a      	uxth	r2, r3
 801a8ac:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801a8b0:	b29b      	uxth	r3, r3
 801a8b2:	4413      	add	r3, r2
 801a8b4:	b29b      	uxth	r3, r3
 801a8b6:	3b01      	subs	r3, #1
 801a8b8:	b29b      	uxth	r3, r3
 801a8ba:	b21b      	sxth	r3, r3
 801a8bc:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
            for(; coords_tmp.x1 <= coords->x2; coords_tmp.x1 += img_w, coords_tmp.x2 += img_w) {
 801a8c0:	e02e      	b.n	801a920 <draw_pattern+0x26e>
                if(src_type == LV_IMG_SRC_SYMBOL)  lv_draw_label(&coords_tmp, clip, &label_dsc, dsc->pattern_image, NULL);
 801a8c2:	f897 30a5 	ldrb.w	r3, [r7, #165]	; 0xa5
 801a8c6:	2b02      	cmp	r3, #2
 801a8c8:	d10b      	bne.n	801a8e2 <draw_pattern+0x230>
 801a8ca:	687b      	ldr	r3, [r7, #4]
 801a8cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801a8ce:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801a8d2:	f107 0054 	add.w	r0, r7, #84	; 0x54
 801a8d6:	2100      	movs	r1, #0
 801a8d8:	9100      	str	r1, [sp, #0]
 801a8da:	68b9      	ldr	r1, [r7, #8]
 801a8dc:	f7f8 fd7a 	bl	80133d4 <lv_draw_label>
 801a8e0:	e008      	b.n	801a8f4 <draw_pattern+0x242>
                else lv_draw_img(&coords_tmp, clip, dsc->pattern_image, &img_dsc);
 801a8e2:	687b      	ldr	r3, [r7, #4]
 801a8e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801a8e6:	f107 037c 	add.w	r3, r7, #124	; 0x7c
 801a8ea:	f107 0054 	add.w	r0, r7, #84	; 0x54
 801a8ee:	68b9      	ldr	r1, [r7, #8]
 801a8f0:	f7f7 fdb4 	bl	801245c <lv_draw_img>
            for(; coords_tmp.x1 <= coords->x2; coords_tmp.x1 += img_w, coords_tmp.x2 += img_w) {
 801a8f4:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801a8f8:	b29a      	uxth	r2, r3
 801a8fa:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801a8fe:	b29b      	uxth	r3, r3
 801a900:	4413      	add	r3, r2
 801a902:	b29b      	uxth	r3, r3
 801a904:	b21b      	sxth	r3, r3
 801a906:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
 801a90a:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 801a90e:	b29a      	uxth	r2, r3
 801a910:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801a914:	b29b      	uxth	r3, r3
 801a916:	4413      	add	r3, r2
 801a918:	b29b      	uxth	r3, r3
 801a91a:	b21b      	sxth	r3, r3
 801a91c:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
 801a920:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 801a924:	68fb      	ldr	r3, [r7, #12]
 801a926:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801a92a:	429a      	cmp	r2, r3
 801a92c:	ddc9      	ble.n	801a8c2 <draw_pattern+0x210>
        for(; coords_tmp.y1 <= coords->y2; coords_tmp.y1 += img_h, coords_tmp.y2 += img_h) {
 801a92e:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801a932:	b29a      	uxth	r2, r3
 801a934:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801a938:	b29b      	uxth	r3, r3
 801a93a:	4413      	add	r3, r2
 801a93c:	b29b      	uxth	r3, r3
 801a93e:	b21b      	sxth	r3, r3
 801a940:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 801a944:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801a948:	b29a      	uxth	r2, r3
 801a94a:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801a94e:	b29b      	uxth	r3, r3
 801a950:	4413      	add	r3, r2
 801a952:	b29b      	uxth	r3, r3
 801a954:	b21b      	sxth	r3, r3
 801a956:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
 801a95a:	f9b7 2056 	ldrsh.w	r2, [r7, #86]	; 0x56
 801a95e:	68fb      	ldr	r3, [r7, #12]
 801a960:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801a964:	429a      	cmp	r2, r3
 801a966:	dd92      	ble.n	801a88e <draw_pattern+0x1dc>
            }
        }
        lv_draw_mask_remove_id(radius_mask_id);
 801a968:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 801a96c:	4618      	mov	r0, r3
 801a96e:	f7fb fb65 	bl	801603c <lv_draw_mask_remove_id>
 801a972:	e0b5      	b.n	801aae0 <draw_pattern+0x42e>
    }
    else {
        int32_t obj_w = lv_area_get_width(coords);
 801a974:	68f8      	ldr	r0, [r7, #12]
 801a976:	f7fc fea3 	bl	80176c0 <lv_area_get_width>
 801a97a:	4603      	mov	r3, r0
 801a97c:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
        int32_t obj_h = lv_area_get_height(coords);
 801a980:	68f8      	ldr	r0, [r7, #12]
 801a982:	f7fc feb4 	bl	80176ee <lv_area_get_height>
 801a986:	4603      	mov	r3, r0
 801a988:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
        coords_tmp.x1 = coords->x1 + (obj_w - img_w) / 2;
 801a98c:	68fb      	ldr	r3, [r7, #12]
 801a98e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a992:	b29a      	uxth	r2, r3
 801a994:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 801a998:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801a99c:	1acb      	subs	r3, r1, r3
 801a99e:	0fd9      	lsrs	r1, r3, #31
 801a9a0:	440b      	add	r3, r1
 801a9a2:	105b      	asrs	r3, r3, #1
 801a9a4:	b29b      	uxth	r3, r3
 801a9a6:	4413      	add	r3, r2
 801a9a8:	b29b      	uxth	r3, r3
 801a9aa:	b21b      	sxth	r3, r3
 801a9ac:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
        coords_tmp.y1 = coords->y1 + (obj_h - img_h) / 2;
 801a9b0:	68fb      	ldr	r3, [r7, #12]
 801a9b2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801a9b6:	b29a      	uxth	r2, r3
 801a9b8:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
 801a9bc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801a9c0:	1acb      	subs	r3, r1, r3
 801a9c2:	0fd9      	lsrs	r1, r3, #31
 801a9c4:	440b      	add	r3, r1
 801a9c6:	105b      	asrs	r3, r3, #1
 801a9c8:	b29b      	uxth	r3, r3
 801a9ca:	4413      	add	r3, r2
 801a9cc:	b29b      	uxth	r3, r3
 801a9ce:	b21b      	sxth	r3, r3
 801a9d0:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
        coords_tmp.x2 = coords_tmp.x1 + img_w - 1;
 801a9d4:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801a9d8:	b29a      	uxth	r2, r3
 801a9da:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801a9de:	b29b      	uxth	r3, r3
 801a9e0:	4413      	add	r3, r2
 801a9e2:	b29b      	uxth	r3, r3
 801a9e4:	3b01      	subs	r3, #1
 801a9e6:	b29b      	uxth	r3, r3
 801a9e8:	b21b      	sxth	r3, r3
 801a9ea:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
        coords_tmp.y2 = coords_tmp.y1 + img_h - 1;
 801a9ee:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801a9f2:	b29a      	uxth	r2, r3
 801a9f4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801a9f8:	b29b      	uxth	r3, r3
 801a9fa:	4413      	add	r3, r2
 801a9fc:	b29b      	uxth	r3, r3
 801a9fe:	3b01      	subs	r3, #1
 801aa00:	b29b      	uxth	r3, r3
 801aa02:	b21b      	sxth	r3, r3
 801aa04:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a

        /* If the (obj_h - img_h) is odd there is a rounding error when divided by 2.
         * It's better round up in case of symbols because probably there is some extra space in the bottom
         * due to the base line of font*/
        if(src_type == LV_IMG_SRC_SYMBOL) {
 801aa08:	f897 30a5 	ldrb.w	r3, [r7, #165]	; 0xa5
 801aa0c:	2b02      	cmp	r3, #2
 801aa0e:	d11e      	bne.n	801aa4e <draw_pattern+0x39c>
            int32_t y_corr = (obj_h - img_h) & 0x1;
 801aa10:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 801aa14:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 801aa18:	1ad3      	subs	r3, r2, r3
 801aa1a:	f003 0301 	and.w	r3, r3, #1
 801aa1e:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
            coords_tmp.y1 += y_corr;
 801aa22:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801aa26:	b29a      	uxth	r2, r3
 801aa28:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 801aa2c:	b29b      	uxth	r3, r3
 801aa2e:	4413      	add	r3, r2
 801aa30:	b29b      	uxth	r3, r3
 801aa32:	b21b      	sxth	r3, r3
 801aa34:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
            coords_tmp.y2 += y_corr;
 801aa38:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801aa3c:	b29a      	uxth	r2, r3
 801aa3e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 801aa42:	b29b      	uxth	r3, r3
 801aa44:	4413      	add	r3, r2
 801aa46:	b29b      	uxth	r3, r3
 801aa48:	b21b      	sxth	r3, r3
 801aa4a:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
        }

        int16_t radius_mask_id = LV_MASK_ID_INV;
 801aa4e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801aa52:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6
        if(_lv_area_is_in(&coords_tmp, coords, dsc->radius) == false) {
 801aa56:	687b      	ldr	r3, [r7, #4]
 801aa58:	f9b3 2000 	ldrsh.w	r2, [r3]
 801aa5c:	f107 0354 	add.w	r3, r7, #84	; 0x54
 801aa60:	68f9      	ldr	r1, [r7, #12]
 801aa62:	4618      	mov	r0, r3
 801aa64:	f004 fee4 	bl	801f830 <_lv_area_is_in>
 801aa68:	4603      	mov	r3, r0
 801aa6a:	f083 0301 	eor.w	r3, r3, #1
 801aa6e:	b2db      	uxtb	r3, r3
 801aa70:	2b00      	cmp	r3, #0
 801aa72:	d011      	beq.n	801aa98 <draw_pattern+0x3e6>
            lv_draw_mask_radius_param_t radius_mask_param;
            lv_draw_mask_radius_init(&radius_mask_param, coords, dsc->radius, false);
 801aa74:	687b      	ldr	r3, [r7, #4]
 801aa76:	f9b3 2000 	ldrsh.w	r2, [r3]
 801aa7a:	f107 0014 	add.w	r0, r7, #20
 801aa7e:	2300      	movs	r3, #0
 801aa80:	68f9      	ldr	r1, [r7, #12]
 801aa82:	f7fb fc7f 	bl	8016384 <lv_draw_mask_radius_init>
            radius_mask_id = lv_draw_mask_add(&radius_mask_param, NULL);
 801aa86:	f107 0314 	add.w	r3, r7, #20
 801aa8a:	2100      	movs	r1, #0
 801aa8c:	4618      	mov	r0, r3
 801aa8e:	f7fb fa5f 	bl	8015f50 <lv_draw_mask_add>
 801aa92:	4603      	mov	r3, r0
 801aa94:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6
        }

        if(src_type == LV_IMG_SRC_SYMBOL)  lv_draw_label(&coords_tmp, clip, &label_dsc, dsc->pattern_image, NULL);
 801aa98:	f897 30a5 	ldrb.w	r3, [r7, #165]	; 0xa5
 801aa9c:	2b02      	cmp	r3, #2
 801aa9e:	d10b      	bne.n	801aab8 <draw_pattern+0x406>
 801aaa0:	687b      	ldr	r3, [r7, #4]
 801aaa2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801aaa4:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 801aaa8:	f107 0054 	add.w	r0, r7, #84	; 0x54
 801aaac:	2100      	movs	r1, #0
 801aaae:	9100      	str	r1, [sp, #0]
 801aab0:	68b9      	ldr	r1, [r7, #8]
 801aab2:	f7f8 fc8f 	bl	80133d4 <lv_draw_label>
 801aab6:	e008      	b.n	801aaca <draw_pattern+0x418>
        else lv_draw_img(&coords_tmp, clip, dsc->pattern_image, &img_dsc);
 801aab8:	687b      	ldr	r3, [r7, #4]
 801aaba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 801aabc:	f107 037c 	add.w	r3, r7, #124	; 0x7c
 801aac0:	f107 0054 	add.w	r0, r7, #84	; 0x54
 801aac4:	68b9      	ldr	r1, [r7, #8]
 801aac6:	f7f7 fcc9 	bl	801245c <lv_draw_img>

        lv_draw_mask_remove_id(radius_mask_id);
 801aaca:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 801aace:	4618      	mov	r0, r3
 801aad0:	f7fb fab4 	bl	801603c <lv_draw_mask_remove_id>
 801aad4:	e004      	b.n	801aae0 <draw_pattern+0x42e>
    if(dsc->pattern_image == NULL) return;
 801aad6:	bf00      	nop
 801aad8:	e002      	b.n	801aae0 <draw_pattern+0x42e>
    if(dsc->pattern_opa <= LV_OPA_MIN) return;
 801aada:	bf00      	nop
 801aadc:	e000      	b.n	801aae0 <draw_pattern+0x42e>
            return;
 801aade:	bf00      	nop
    }
}
 801aae0:	37b0      	adds	r7, #176	; 0xb0
 801aae2:	46bd      	mov	sp, r7
 801aae4:	bdb0      	pop	{r4, r5, r7, pc}

0801aae6 <draw_value_str>:
#endif


#if LV_USE_VALUE_STR
static void draw_value_str(const lv_area_t * coords, const lv_area_t * clip, const lv_draw_rect_dsc_t * dsc)
{
 801aae6:	b5b0      	push	{r4, r5, r7, lr}
 801aae8:	b094      	sub	sp, #80	; 0x50
 801aaea:	af04      	add	r7, sp, #16
 801aaec:	60f8      	str	r0, [r7, #12]
 801aaee:	60b9      	str	r1, [r7, #8]
 801aaf0:	607a      	str	r2, [r7, #4]
    if(dsc->value_str == NULL) return;
 801aaf2:	687b      	ldr	r3, [r7, #4]
 801aaf4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801aaf6:	2b00      	cmp	r3, #0
 801aaf8:	f000 809b 	beq.w	801ac32 <draw_value_str+0x14c>
    if(dsc->value_opa <= LV_OPA_MIN) return;
 801aafc:	687b      	ldr	r3, [r7, #4]
 801aafe:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 801ab02:	2b02      	cmp	r3, #2
 801ab04:	f240 8097 	bls.w	801ac36 <draw_value_str+0x150>

    lv_point_t s;
    _lv_txt_get_size(&s, dsc->value_str, dsc->value_font, dsc->value_letter_space, dsc->value_line_space, LV_COORD_MAX,
 801ab08:	687b      	ldr	r3, [r7, #4]
 801ab0a:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 801ab0c:	687b      	ldr	r3, [r7, #4]
 801ab0e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 801ab10:	687b      	ldr	r3, [r7, #4]
 801ab12:	f9b3 404c 	ldrsh.w	r4, [r3, #76]	; 0x4c
 801ab16:	687b      	ldr	r3, [r7, #4]
 801ab18:	f9b3 304e 	ldrsh.w	r3, [r3, #78]	; 0x4e
 801ab1c:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 801ab20:	2500      	movs	r5, #0
 801ab22:	9502      	str	r5, [sp, #8]
 801ab24:	f647 4518 	movw	r5, #31768	; 0x7c18
 801ab28:	9501      	str	r5, [sp, #4]
 801ab2a:	9300      	str	r3, [sp, #0]
 801ab2c:	4623      	mov	r3, r4
 801ab2e:	f007 faad 	bl	802208c <_lv_txt_get_size>
                     LV_TXT_FLAG_NONE);

    lv_area_t value_area;
    value_area.x1 = 0;
 801ab32:	2300      	movs	r3, #0
 801ab34:	86bb      	strh	r3, [r7, #52]	; 0x34
    value_area.y1 = 0;
 801ab36:	2300      	movs	r3, #0
 801ab38:	86fb      	strh	r3, [r7, #54]	; 0x36
    value_area.x2 = s.x - 1;
 801ab3a:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 801ab3e:	b29b      	uxth	r3, r3
 801ab40:	3b01      	subs	r3, #1
 801ab42:	b29b      	uxth	r3, r3
 801ab44:	b21b      	sxth	r3, r3
 801ab46:	873b      	strh	r3, [r7, #56]	; 0x38
    value_area.y2 = s.y - 1;
 801ab48:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801ab4c:	b29b      	uxth	r3, r3
 801ab4e:	3b01      	subs	r3, #1
 801ab50:	b29b      	uxth	r3, r3
 801ab52:	b21b      	sxth	r3, r3
 801ab54:	877b      	strh	r3, [r7, #58]	; 0x3a

    lv_point_t p_align;
    _lv_area_align(coords, &value_area, dsc->value_align, &p_align);
 801ab56:	687b      	ldr	r3, [r7, #4]
 801ab58:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
 801ab5c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801ab60:	f107 0134 	add.w	r1, r7, #52	; 0x34
 801ab64:	68f8      	ldr	r0, [r7, #12]
 801ab66:	f004 fef9 	bl	801f95c <_lv_area_align>

    value_area.x1 += p_align.x + dsc->value_ofs_x;
 801ab6a:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 801ab6e:	b29a      	uxth	r2, r3
 801ab70:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801ab74:	b299      	uxth	r1, r3
 801ab76:	687b      	ldr	r3, [r7, #4]
 801ab78:	f9b3 3048 	ldrsh.w	r3, [r3, #72]	; 0x48
 801ab7c:	b29b      	uxth	r3, r3
 801ab7e:	440b      	add	r3, r1
 801ab80:	b29b      	uxth	r3, r3
 801ab82:	4413      	add	r3, r2
 801ab84:	b29b      	uxth	r3, r3
 801ab86:	b21b      	sxth	r3, r3
 801ab88:	86bb      	strh	r3, [r7, #52]	; 0x34
    value_area.y1 += p_align.y + dsc->value_ofs_y;
 801ab8a:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801ab8e:	b29a      	uxth	r2, r3
 801ab90:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801ab94:	b299      	uxth	r1, r3
 801ab96:	687b      	ldr	r3, [r7, #4]
 801ab98:	f9b3 304a 	ldrsh.w	r3, [r3, #74]	; 0x4a
 801ab9c:	b29b      	uxth	r3, r3
 801ab9e:	440b      	add	r3, r1
 801aba0:	b29b      	uxth	r3, r3
 801aba2:	4413      	add	r3, r2
 801aba4:	b29b      	uxth	r3, r3
 801aba6:	b21b      	sxth	r3, r3
 801aba8:	86fb      	strh	r3, [r7, #54]	; 0x36
    value_area.x2 += p_align.x + dsc->value_ofs_x;
 801abaa:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801abae:	b29a      	uxth	r2, r3
 801abb0:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801abb4:	b299      	uxth	r1, r3
 801abb6:	687b      	ldr	r3, [r7, #4]
 801abb8:	f9b3 3048 	ldrsh.w	r3, [r3, #72]	; 0x48
 801abbc:	b29b      	uxth	r3, r3
 801abbe:	440b      	add	r3, r1
 801abc0:	b29b      	uxth	r3, r3
 801abc2:	4413      	add	r3, r2
 801abc4:	b29b      	uxth	r3, r3
 801abc6:	b21b      	sxth	r3, r3
 801abc8:	873b      	strh	r3, [r7, #56]	; 0x38
    value_area.y2 += p_align.y + dsc->value_ofs_y;
 801abca:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801abce:	b29a      	uxth	r2, r3
 801abd0:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801abd4:	b299      	uxth	r1, r3
 801abd6:	687b      	ldr	r3, [r7, #4]
 801abd8:	f9b3 304a 	ldrsh.w	r3, [r3, #74]	; 0x4a
 801abdc:	b29b      	uxth	r3, r3
 801abde:	440b      	add	r3, r1
 801abe0:	b29b      	uxth	r3, r3
 801abe2:	4413      	add	r3, r2
 801abe4:	b29b      	uxth	r3, r3
 801abe6:	b21b      	sxth	r3, r3
 801abe8:	877b      	strh	r3, [r7, #58]	; 0x3a

    lv_draw_label_dsc_t label_dsc;
    lv_draw_label_dsc_init(&label_dsc);
 801abea:	f107 0310 	add.w	r3, r7, #16
 801abee:	4618      	mov	r0, r3
 801abf0:	f7f8 fbb2 	bl	8013358 <lv_draw_label_dsc_init>
    label_dsc.font = dsc->value_font;
 801abf4:	687b      	ldr	r3, [r7, #4]
 801abf6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801abf8:	617b      	str	r3, [r7, #20]
    label_dsc.letter_space = dsc->value_letter_space;
 801abfa:	687b      	ldr	r3, [r7, #4]
 801abfc:	f9b3 304c 	ldrsh.w	r3, [r3, #76]	; 0x4c
 801ac00:	83bb      	strh	r3, [r7, #28]
    label_dsc.line_space = dsc->value_line_space;
 801ac02:	687b      	ldr	r3, [r7, #4]
 801ac04:	f9b3 304e 	ldrsh.w	r3, [r3, #78]	; 0x4e
 801ac08:	837b      	strh	r3, [r7, #26]
    label_dsc.color = dsc->value_color;
 801ac0a:	687b      	ldr	r3, [r7, #4]
 801ac0c:	f8b3 3046 	ldrh.w	r3, [r3, #70]	; 0x46
 801ac10:	823b      	strh	r3, [r7, #16]
    label_dsc.opa = dsc->value_opa;
 801ac12:	687b      	ldr	r3, [r7, #4]
 801ac14:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 801ac18:	763b      	strb	r3, [r7, #24]

    lv_draw_label(&value_area, clip, &label_dsc, dsc->value_str, NULL);
 801ac1a:	687b      	ldr	r3, [r7, #4]
 801ac1c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801ac1e:	f107 0210 	add.w	r2, r7, #16
 801ac22:	f107 0034 	add.w	r0, r7, #52	; 0x34
 801ac26:	2100      	movs	r1, #0
 801ac28:	9100      	str	r1, [sp, #0]
 801ac2a:	68b9      	ldr	r1, [r7, #8]
 801ac2c:	f7f8 fbd2 	bl	80133d4 <lv_draw_label>
 801ac30:	e002      	b.n	801ac38 <draw_value_str+0x152>
    if(dsc->value_str == NULL) return;
 801ac32:	bf00      	nop
 801ac34:	e000      	b.n	801ac38 <draw_value_str+0x152>
    if(dsc->value_opa <= LV_OPA_MIN) return;
 801ac36:	bf00      	nop
}
 801ac38:	3740      	adds	r7, #64	; 0x40
 801ac3a:	46bd      	mov	sp, r7
 801ac3c:	bdb0      	pop	{r4, r5, r7, pc}

0801ac3e <draw_full_border>:
#endif

static void draw_full_border(const lv_area_t * area_inner, const lv_area_t * area_outer, const lv_area_t * clip,
                             lv_coord_t radius, lv_color_t color, lv_opa_t opa, lv_blend_mode_t blend_mode)
{
 801ac3e:	b580      	push	{r7, lr}
 801ac40:	b0b6      	sub	sp, #216	; 0xd8
 801ac42:	af04      	add	r7, sp, #16
 801ac44:	60f8      	str	r0, [r7, #12]
 801ac46:	60b9      	str	r1, [r7, #8]
 801ac48:	607a      	str	r2, [r7, #4]
 801ac4a:	807b      	strh	r3, [r7, #2]
    uint8_t other_mask_cnt = lv_draw_mask_get_cnt();
 801ac4c:	f7fb fa4e 	bl	80160ec <lv_draw_mask_get_cnt>
 801ac50:	4603      	mov	r3, r0
 801ac52:	f887 30ab 	strb.w	r3, [r7, #171]	; 0xab
    bool simple_mode = true;
 801ac56:	2301      	movs	r3, #1
 801ac58:	f887 30c7 	strb.w	r3, [r7, #199]	; 0xc7
    if(other_mask_cnt) simple_mode = false;
 801ac5c:	f897 30ab 	ldrb.w	r3, [r7, #171]	; 0xab
 801ac60:	2b00      	cmp	r3, #0
 801ac62:	d002      	beq.n	801ac6a <draw_full_border+0x2c>
 801ac64:	2300      	movs	r3, #0
 801ac66:	f887 30c7 	strb.w	r3, [r7, #199]	; 0xc7

    int32_t inner_w = lv_area_get_width(area_inner);
 801ac6a:	68f8      	ldr	r0, [r7, #12]
 801ac6c:	f7fc fd28 	bl	80176c0 <lv_area_get_width>
 801ac70:	4603      	mov	r3, r0
 801ac72:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    int32_t inner_h = lv_area_get_height(area_inner);
 801ac76:	68f8      	ldr	r0, [r7, #12]
 801ac78:	f7fc fd39 	bl	80176ee <lv_area_get_height>
 801ac7c:	4603      	mov	r3, r0
 801ac7e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
    lv_coord_t border_width = area_outer->x2 - area_inner->x2;
 801ac82:	68bb      	ldr	r3, [r7, #8]
 801ac84:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801ac88:	b29a      	uxth	r2, r3
 801ac8a:	68fb      	ldr	r3, [r7, #12]
 801ac8c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801ac90:	b29b      	uxth	r3, r3
 801ac92:	1ad3      	subs	r3, r2, r3
 801ac94:	b29b      	uxth	r3, r3
 801ac96:	f8a7 309e 	strh.w	r3, [r7, #158]	; 0x9e
    int32_t rin = radius;
 801ac9a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801ac9e:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0

    int32_t short_side = LV_MATH_MIN(inner_w, inner_h);
 801aca2:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
 801aca6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801acaa:	4293      	cmp	r3, r2
 801acac:	bfa8      	it	ge
 801acae:	4613      	movge	r3, r2
 801acb0:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    if(rin > short_side >> 1) rin = short_side >> 1;
 801acb4:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 801acb8:	105b      	asrs	r3, r3, #1
 801acba:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 801acbe:	429a      	cmp	r2, r3
 801acc0:	dd04      	ble.n	801accc <draw_full_border+0x8e>
 801acc2:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 801acc6:	105b      	asrs	r3, r3, #1
 801acc8:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0

    /*Get the outer area*/
    int32_t rout = rin + border_width;
 801accc:	f9b7 309e 	ldrsh.w	r3, [r7, #158]	; 0x9e
 801acd0:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 801acd4:	4413      	add	r3, r2
 801acd6:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

    int32_t coords_out_w = lv_area_get_width(area_outer);
 801acda:	68b8      	ldr	r0, [r7, #8]
 801acdc:	f7fc fcf0 	bl	80176c0 <lv_area_get_width>
 801ace0:	4603      	mov	r3, r0
 801ace2:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    int32_t coords_out_h = lv_area_get_height(area_outer);
 801ace6:	68b8      	ldr	r0, [r7, #8]
 801ace8:	f7fc fd01 	bl	80176ee <lv_area_get_height>
 801acec:	4603      	mov	r3, r0
 801acee:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
    short_side = LV_MATH_MIN(coords_out_w, coords_out_h);
 801acf2:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 801acf6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 801acfa:	4293      	cmp	r3, r2
 801acfc:	bfa8      	it	ge
 801acfe:	4613      	movge	r3, r2
 801ad00:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
    if(rout > short_side >> 1) rout = short_side >> 1;
 801ad04:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 801ad08:	105b      	asrs	r3, r3, #1
 801ad0a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 801ad0e:	429a      	cmp	r2, r3
 801ad10:	dd04      	ble.n	801ad1c <draw_full_border+0xde>
 801ad12:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 801ad16:	105b      	asrs	r3, r3, #1
 801ad18:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

    lv_disp_t * disp    = _lv_refr_get_disp_refreshing();
 801ad1c:	f7f3 fb60 	bl	800e3e0 <_lv_refr_get_disp_refreshing>
 801ad20:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 801ad24:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 801ad28:	f003 ff70 	bl	801ec0c <lv_disp_get_buf>
 801ad2c:	f8c7 0088 	str.w	r0, [r7, #136]	; 0x88

    /* Get clipped fill area which is the real draw area.
     * It is always the same or inside `fill_area` */
    lv_area_t draw_area;
    bool is_common;
    is_common = _lv_area_intersect(&draw_area, area_outer, clip);
 801ad30:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801ad34:	687a      	ldr	r2, [r7, #4]
 801ad36:	68b9      	ldr	r1, [r7, #8]
 801ad38:	4618      	mov	r0, r3
 801ad3a:	f004 fb97 	bl	801f46c <_lv_area_intersect>
 801ad3e:	4603      	mov	r3, r0
 801ad40:	f887 3087 	strb.w	r3, [r7, #135]	; 0x87
    if(is_common == false) return;
 801ad44:	f897 3087 	ldrb.w	r3, [r7, #135]	; 0x87
 801ad48:	f083 0301 	eor.w	r3, r3, #1
 801ad4c:	b2db      	uxtb	r3, r3
 801ad4e:	2b00      	cmp	r3, #0
 801ad50:	f040 834c 	bne.w	801b3ec <draw_full_border+0x7ae>

    const lv_area_t * disp_area = &vdb->area;
 801ad54:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801ad58:	3310      	adds	r3, #16
 801ad5a:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80

    /* Now `draw_area` has absolute coordinates.
     * Make it relative to `disp_area` to simplify draw to `disp_buf`*/
    draw_area.x1 -= disp_area->x1;
 801ad5e:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 801ad62:	b29a      	uxth	r2, r3
 801ad64:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801ad68:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ad6c:	b29b      	uxth	r3, r3
 801ad6e:	1ad3      	subs	r3, r2, r3
 801ad70:	b29b      	uxth	r3, r3
 801ad72:	b21b      	sxth	r3, r3
 801ad74:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    draw_area.y1 -= disp_area->y1;
 801ad78:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801ad7c:	b29a      	uxth	r2, r3
 801ad7e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801ad82:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801ad86:	b29b      	uxth	r3, r3
 801ad88:	1ad3      	subs	r3, r2, r3
 801ad8a:	b29b      	uxth	r3, r3
 801ad8c:	b21b      	sxth	r3, r3
 801ad8e:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
    draw_area.x2 -= disp_area->x1;
 801ad92:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 801ad96:	b29a      	uxth	r2, r3
 801ad98:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801ad9c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ada0:	b29b      	uxth	r3, r3
 801ada2:	1ad3      	subs	r3, r2, r3
 801ada4:	b29b      	uxth	r3, r3
 801ada6:	b21b      	sxth	r3, r3
 801ada8:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    draw_area.y2 -= disp_area->y1;
 801adac:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 801adb0:	b29a      	uxth	r2, r3
 801adb2:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801adb6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801adba:	b29b      	uxth	r3, r3
 801adbc:	1ad3      	subs	r3, r2, r3
 801adbe:	b29b      	uxth	r3, r3
 801adc0:	b21b      	sxth	r3, r3
 801adc2:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66

    int32_t draw_area_w = lv_area_get_width(&draw_area);
 801adc6:	f107 0360 	add.w	r3, r7, #96	; 0x60
 801adca:	4618      	mov	r0, r3
 801adcc:	f7fc fc78 	bl	80176c0 <lv_area_get_width>
 801add0:	4603      	mov	r3, r0
 801add2:	67fb      	str	r3, [r7, #124]	; 0x7c

    /*Create inner the mask*/
    lv_draw_mask_radius_param_t mask_rin_param;
    lv_draw_mask_radius_init(&mask_rin_param, area_inner, rin, true);
 801add4:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 801add8:	b21a      	sxth	r2, r3
 801adda:	f107 0044 	add.w	r0, r7, #68	; 0x44
 801adde:	2301      	movs	r3, #1
 801ade0:	68f9      	ldr	r1, [r7, #12]
 801ade2:	f7fb facf 	bl	8016384 <lv_draw_mask_radius_init>
    int16_t mask_rin_id = lv_draw_mask_add(&mask_rin_param, NULL);
 801ade6:	f107 0344 	add.w	r3, r7, #68	; 0x44
 801adea:	2100      	movs	r1, #0
 801adec:	4618      	mov	r0, r3
 801adee:	f7fb f8af 	bl	8015f50 <lv_draw_mask_add>
 801adf2:	4603      	mov	r3, r0
 801adf4:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a

    lv_draw_mask_radius_param_t mask_rout_param;
    lv_draw_mask_radius_init(&mask_rout_param, area_outer, rout, false);
 801adf8:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801adfc:	b21a      	sxth	r2, r3
 801adfe:	f107 0028 	add.w	r0, r7, #40	; 0x28
 801ae02:	2300      	movs	r3, #0
 801ae04:	68b9      	ldr	r1, [r7, #8]
 801ae06:	f7fb fabd 	bl	8016384 <lv_draw_mask_radius_init>
    int16_t mask_rout_id = lv_draw_mask_add(&mask_rout_param, NULL);
 801ae0a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801ae0e:	2100      	movs	r1, #0
 801ae10:	4618      	mov	r0, r3
 801ae12:	f7fb f89d 	bl	8015f50 <lv_draw_mask_add>
 801ae16:	4603      	mov	r3, r0
 801ae18:	f8a7 3078 	strh.w	r3, [r7, #120]	; 0x78

    lv_opa_t * mask_buf = _lv_mem_buf_get(draw_area_w);
 801ae1c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801ae1e:	4618      	mov	r0, r3
 801ae20:	f006 f836 	bl	8020e90 <_lv_mem_buf_get>
 801ae24:	6778      	str	r0, [r7, #116]	; 0x74

    int32_t corner_size = LV_MATH_MAX(rout, border_width - 1);
 801ae26:	f9b7 309e 	ldrsh.w	r3, [r7, #158]	; 0x9e
 801ae2a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 801ae2e:	429a      	cmp	r2, r3
 801ae30:	da03      	bge.n	801ae3a <draw_full_border+0x1fc>
 801ae32:	f9b7 309e 	ldrsh.w	r3, [r7, #158]	; 0x9e
 801ae36:	3b01      	subs	r3, #1
 801ae38:	e001      	b.n	801ae3e <draw_full_border+0x200>
 801ae3a:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801ae3e:	673b      	str	r3, [r7, #112]	; 0x70
    int32_t h;
    lv_draw_mask_res_t mask_res;
    lv_area_t fill_area;

    /*Apply some optimization if there is no other mask*/
    if(simple_mode) {
 801ae40:	f897 30c7 	ldrb.w	r3, [r7, #199]	; 0xc7
 801ae44:	2b00      	cmp	r3, #0
 801ae46:	f000 8259 	beq.w	801b2fc <draw_full_border+0x6be>
        /*Draw the upper corner area*/
        int32_t upper_corner_end = area_outer->y1 - disp_area->y1 + corner_size;
 801ae4a:	68bb      	ldr	r3, [r7, #8]
 801ae4c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801ae50:	461a      	mov	r2, r3
 801ae52:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801ae56:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801ae5a:	1ad3      	subs	r3, r2, r3
 801ae5c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 801ae5e:	4413      	add	r3, r2
 801ae60:	66bb      	str	r3, [r7, #104]	; 0x68

        fill_area.x1 = area_outer->x1;
 801ae62:	68bb      	ldr	r3, [r7, #8]
 801ae64:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ae68:	843b      	strh	r3, [r7, #32]
        fill_area.x2 = area_outer->x2;
 801ae6a:	68bb      	ldr	r3, [r7, #8]
 801ae6c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801ae70:	84bb      	strh	r3, [r7, #36]	; 0x24
        fill_area.y1 = disp_area->y1 + draw_area.y1;
 801ae72:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801ae76:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801ae7a:	b29a      	uxth	r2, r3
 801ae7c:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801ae80:	b29b      	uxth	r3, r3
 801ae82:	4413      	add	r3, r2
 801ae84:	b29b      	uxth	r3, r3
 801ae86:	b21b      	sxth	r3, r3
 801ae88:	847b      	strh	r3, [r7, #34]	; 0x22
        fill_area.y2 = fill_area.y1;
 801ae8a:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801ae8e:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(h = draw_area.y1; h <= upper_corner_end; h++) {
 801ae90:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801ae94:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 801ae98:	e0cf      	b.n	801b03a <draw_full_border+0x3fc>
            _lv_memset_ff(mask_buf, draw_area_w);
 801ae9a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801ae9c:	4619      	mov	r1, r3
 801ae9e:	6f78      	ldr	r0, [r7, #116]	; 0x74
 801aea0:	f006 fc83 	bl	80217aa <_lv_memset_ff>
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
 801aea4:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801aea8:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801aeac:	b29a      	uxth	r2, r3
 801aeae:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 801aeb2:	b29b      	uxth	r3, r3
 801aeb4:	4413      	add	r3, r2
 801aeb6:	b29b      	uxth	r3, r3
 801aeb8:	b219      	sxth	r1, r3
 801aeba:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801aebe:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801aec2:	b29a      	uxth	r2, r3
 801aec4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801aec8:	b29b      	uxth	r3, r3
 801aeca:	4413      	add	r3, r2
 801aecc:	b29b      	uxth	r3, r3
 801aece:	b21a      	sxth	r2, r3
 801aed0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801aed2:	b21b      	sxth	r3, r3
 801aed4:	6f78      	ldr	r0, [r7, #116]	; 0x74
 801aed6:	f7fb f86d 	bl	8015fb4 <lv_draw_mask_apply>
 801aeda:	4603      	mov	r3, r0
 801aedc:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f

            lv_area_t fill_area2;
            fill_area2.y1 = fill_area.y1;
 801aee0:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801aee4:	837b      	strh	r3, [r7, #26]
            fill_area2.y2 = fill_area.y2;
 801aee6:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801aeea:	83fb      	strh	r3, [r7, #30]

            fill_area2.x1 = area_outer->x1;
 801aeec:	68bb      	ldr	r3, [r7, #8]
 801aeee:	f9b3 3000 	ldrsh.w	r3, [r3]
 801aef2:	833b      	strh	r3, [r7, #24]
            fill_area2.x2 = area_outer->x1 + rout - 1;
 801aef4:	68bb      	ldr	r3, [r7, #8]
 801aef6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801aefa:	b29a      	uxth	r2, r3
 801aefc:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801af00:	b29b      	uxth	r3, r3
 801af02:	4413      	add	r3, r2
 801af04:	b29b      	uxth	r3, r3
 801af06:	3b01      	subs	r3, #1
 801af08:	b29b      	uxth	r3, r3
 801af0a:	b21b      	sxth	r3, r3
 801af0c:	83bb      	strh	r3, [r7, #28]

            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
 801af0e:	f107 0118 	add.w	r1, r7, #24
 801af12:	f897 30d8 	ldrb.w	r3, [r7, #216]	; 0xd8
 801af16:	9302      	str	r3, [sp, #8]
 801af18:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 801af1c:	9301      	str	r3, [sp, #4]
 801af1e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801af22:	9300      	str	r3, [sp, #0]
 801af24:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801af26:	f8b7 20d0 	ldrh.w	r2, [r7, #208]	; 0xd0
 801af2a:	6878      	ldr	r0, [r7, #4]
 801af2c:	f7f5 fc9a 	bl	8010864 <_lv_blend_fill>

            /*Draw the top horizontal line*/
            if(fill_area2.y2 < area_outer->y1 + border_width) {
 801af30:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801af34:	461a      	mov	r2, r3
 801af36:	68bb      	ldr	r3, [r7, #8]
 801af38:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801af3c:	4619      	mov	r1, r3
 801af3e:	f9b7 309e 	ldrsh.w	r3, [r7, #158]	; 0x9e
 801af42:	440b      	add	r3, r1
 801af44:	429a      	cmp	r2, r3
 801af46:	da25      	bge.n	801af94 <draw_full_border+0x356>
                fill_area2.x1 = area_outer->x1 + rout;
 801af48:	68bb      	ldr	r3, [r7, #8]
 801af4a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801af4e:	b29a      	uxth	r2, r3
 801af50:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801af54:	b29b      	uxth	r3, r3
 801af56:	4413      	add	r3, r2
 801af58:	b29b      	uxth	r3, r3
 801af5a:	b21b      	sxth	r3, r3
 801af5c:	833b      	strh	r3, [r7, #24]
                fill_area2.x2 = area_outer->x2 - rout;
 801af5e:	68bb      	ldr	r3, [r7, #8]
 801af60:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801af64:	b29a      	uxth	r2, r3
 801af66:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801af6a:	b29b      	uxth	r3, r3
 801af6c:	1ad3      	subs	r3, r2, r3
 801af6e:	b29b      	uxth	r3, r3
 801af70:	b21b      	sxth	r3, r3
 801af72:	83bb      	strh	r3, [r7, #28]

                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
 801af74:	f107 0118 	add.w	r1, r7, #24
 801af78:	f897 30d8 	ldrb.w	r3, [r7, #216]	; 0xd8
 801af7c:	9302      	str	r3, [sp, #8]
 801af7e:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 801af82:	9301      	str	r3, [sp, #4]
 801af84:	2301      	movs	r3, #1
 801af86:	9300      	str	r3, [sp, #0]
 801af88:	2300      	movs	r3, #0
 801af8a:	f8b7 20d0 	ldrh.w	r2, [r7, #208]	; 0xd0
 801af8e:	6878      	ldr	r0, [r7, #4]
 801af90:	f7f5 fc68 	bl	8010864 <_lv_blend_fill>
            }

            fill_area2.x1 = area_outer->x2 - rout + 1;
 801af94:	68bb      	ldr	r3, [r7, #8]
 801af96:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801af9a:	b29a      	uxth	r2, r3
 801af9c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801afa0:	b29b      	uxth	r3, r3
 801afa2:	1ad3      	subs	r3, r2, r3
 801afa4:	b29b      	uxth	r3, r3
 801afa6:	3301      	adds	r3, #1
 801afa8:	b29b      	uxth	r3, r3
 801afaa:	b21b      	sxth	r3, r3
 801afac:	833b      	strh	r3, [r7, #24]
            fill_area2.x2 = area_outer->x2;
 801afae:	68bb      	ldr	r3, [r7, #8]
 801afb0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801afb4:	83bb      	strh	r3, [r7, #28]

            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
 801afb6:	68bb      	ldr	r3, [r7, #8]
 801afb8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801afbc:	461a      	mov	r2, r3
 801afbe:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801afc2:	1ad3      	subs	r3, r2, r3
 801afc4:	1c5a      	adds	r2, r3, #1
 801afc6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801afca:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801afce:	4619      	mov	r1, r3
 801afd0:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 801afd4:	440b      	add	r3, r1
 801afd6:	1ad3      	subs	r3, r2, r3
 801afd8:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
            if(mask_ofs < 0) mask_ofs = 0;
 801afdc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801afe0:	2b00      	cmp	r3, #0
 801afe2:	da02      	bge.n	801afea <draw_full_border+0x3ac>
 801afe4:	2300      	movs	r3, #0
 801afe6:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
 801afea:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 801afee:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801aff0:	441a      	add	r2, r3
 801aff2:	f107 0118 	add.w	r1, r7, #24
 801aff6:	f897 30d8 	ldrb.w	r3, [r7, #216]	; 0xd8
 801affa:	9302      	str	r3, [sp, #8]
 801affc:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 801b000:	9301      	str	r3, [sp, #4]
 801b002:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801b006:	9300      	str	r3, [sp, #0]
 801b008:	4613      	mov	r3, r2
 801b00a:	f8b7 20d0 	ldrh.w	r2, [r7, #208]	; 0xd0
 801b00e:	6878      	ldr	r0, [r7, #4]
 801b010:	f7f5 fc28 	bl	8010864 <_lv_blend_fill>

            fill_area.y1++;
 801b014:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801b018:	b29b      	uxth	r3, r3
 801b01a:	3301      	adds	r3, #1
 801b01c:	b29b      	uxth	r3, r3
 801b01e:	b21b      	sxth	r3, r3
 801b020:	847b      	strh	r3, [r7, #34]	; 0x22
            fill_area.y2++;
 801b022:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801b026:	b29b      	uxth	r3, r3
 801b028:	3301      	adds	r3, #1
 801b02a:	b29b      	uxth	r3, r3
 801b02c:	b21b      	sxth	r3, r3
 801b02e:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(h = draw_area.y1; h <= upper_corner_end; h++) {
 801b030:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801b034:	3301      	adds	r3, #1
 801b036:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 801b03a:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
 801b03e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b040:	429a      	cmp	r2, r3
 801b042:	f77f af2a 	ble.w	801ae9a <draw_full_border+0x25c>
        }

        /*Draw the lower corner area */
        int32_t lower_corner_end = area_outer->y2 - disp_area->y1 - corner_size;
 801b046:	68bb      	ldr	r3, [r7, #8]
 801b048:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801b04c:	461a      	mov	r2, r3
 801b04e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b052:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801b056:	1ad2      	subs	r2, r2, r3
 801b058:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801b05a:	1ad3      	subs	r3, r2, r3
 801b05c:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
        if(lower_corner_end <= upper_corner_end) lower_corner_end = upper_corner_end + 1;
 801b060:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 801b064:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b066:	429a      	cmp	r2, r3
 801b068:	dc03      	bgt.n	801b072 <draw_full_border+0x434>
 801b06a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801b06c:	3301      	adds	r3, #1
 801b06e:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
        fill_area.y1 = disp_area->y1 + lower_corner_end;
 801b072:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b076:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801b07a:	b29a      	uxth	r2, r3
 801b07c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 801b080:	b29b      	uxth	r3, r3
 801b082:	4413      	add	r3, r2
 801b084:	b29b      	uxth	r3, r3
 801b086:	b21b      	sxth	r3, r3
 801b088:	847b      	strh	r3, [r7, #34]	; 0x22
        fill_area.y2 = fill_area.y1;
 801b08a:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801b08e:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(h = lower_corner_end; h <= draw_area.y2; h++) {
 801b090:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 801b094:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 801b098:	e0cf      	b.n	801b23a <draw_full_border+0x5fc>
            _lv_memset_ff(mask_buf, draw_area_w);
 801b09a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801b09c:	4619      	mov	r1, r3
 801b09e:	6f78      	ldr	r0, [r7, #116]	; 0x74
 801b0a0:	f006 fb83 	bl	80217aa <_lv_memset_ff>
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
 801b0a4:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b0a8:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801b0ac:	b29a      	uxth	r2, r3
 801b0ae:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 801b0b2:	b29b      	uxth	r3, r3
 801b0b4:	4413      	add	r3, r2
 801b0b6:	b29b      	uxth	r3, r3
 801b0b8:	b219      	sxth	r1, r3
 801b0ba:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b0be:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801b0c2:	b29a      	uxth	r2, r3
 801b0c4:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801b0c8:	b29b      	uxth	r3, r3
 801b0ca:	4413      	add	r3, r2
 801b0cc:	b29b      	uxth	r3, r3
 801b0ce:	b21a      	sxth	r2, r3
 801b0d0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801b0d2:	b21b      	sxth	r3, r3
 801b0d4:	6f78      	ldr	r0, [r7, #116]	; 0x74
 801b0d6:	f7fa ff6d 	bl	8015fb4 <lv_draw_mask_apply>
 801b0da:	4603      	mov	r3, r0
 801b0dc:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f

            lv_area_t fill_area2;
            fill_area2.x1 = area_outer->x1;
 801b0e0:	68bb      	ldr	r3, [r7, #8]
 801b0e2:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b0e6:	823b      	strh	r3, [r7, #16]
            fill_area2.x2 = area_outer->x1 + rout - 1;
 801b0e8:	68bb      	ldr	r3, [r7, #8]
 801b0ea:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b0ee:	b29a      	uxth	r2, r3
 801b0f0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801b0f4:	b29b      	uxth	r3, r3
 801b0f6:	4413      	add	r3, r2
 801b0f8:	b29b      	uxth	r3, r3
 801b0fa:	3b01      	subs	r3, #1
 801b0fc:	b29b      	uxth	r3, r3
 801b0fe:	b21b      	sxth	r3, r3
 801b100:	82bb      	strh	r3, [r7, #20]
            fill_area2.y1 = fill_area.y1;
 801b102:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801b106:	827b      	strh	r3, [r7, #18]
            fill_area2.y2 = fill_area.y2;
 801b108:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801b10c:	82fb      	strh	r3, [r7, #22]

            _lv_blend_fill(clip, &fill_area2, color, mask_buf, mask_res, opa, blend_mode);
 801b10e:	f107 0110 	add.w	r1, r7, #16
 801b112:	f897 30d8 	ldrb.w	r3, [r7, #216]	; 0xd8
 801b116:	9302      	str	r3, [sp, #8]
 801b118:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 801b11c:	9301      	str	r3, [sp, #4]
 801b11e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801b122:	9300      	str	r3, [sp, #0]
 801b124:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801b126:	f8b7 20d0 	ldrh.w	r2, [r7, #208]	; 0xd0
 801b12a:	6878      	ldr	r0, [r7, #4]
 801b12c:	f7f5 fb9a 	bl	8010864 <_lv_blend_fill>

            /*Draw the bottom horizontal line*/
            if(fill_area2.y2 > area_outer->y2 - border_width) {
 801b130:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801b134:	461a      	mov	r2, r3
 801b136:	68bb      	ldr	r3, [r7, #8]
 801b138:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801b13c:	4619      	mov	r1, r3
 801b13e:	f9b7 309e 	ldrsh.w	r3, [r7, #158]	; 0x9e
 801b142:	1acb      	subs	r3, r1, r3
 801b144:	429a      	cmp	r2, r3
 801b146:	dd25      	ble.n	801b194 <draw_full_border+0x556>
                fill_area2.x1 = area_outer->x1 + rout;
 801b148:	68bb      	ldr	r3, [r7, #8]
 801b14a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b14e:	b29a      	uxth	r2, r3
 801b150:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801b154:	b29b      	uxth	r3, r3
 801b156:	4413      	add	r3, r2
 801b158:	b29b      	uxth	r3, r3
 801b15a:	b21b      	sxth	r3, r3
 801b15c:	823b      	strh	r3, [r7, #16]
                fill_area2.x2 = area_outer->x2 - rout;
 801b15e:	68bb      	ldr	r3, [r7, #8]
 801b160:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b164:	b29a      	uxth	r2, r3
 801b166:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801b16a:	b29b      	uxth	r3, r3
 801b16c:	1ad3      	subs	r3, r2, r3
 801b16e:	b29b      	uxth	r3, r3
 801b170:	b21b      	sxth	r3, r3
 801b172:	82bb      	strh	r3, [r7, #20]

                _lv_blend_fill(clip, &fill_area2, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
 801b174:	f107 0110 	add.w	r1, r7, #16
 801b178:	f897 30d8 	ldrb.w	r3, [r7, #216]	; 0xd8
 801b17c:	9302      	str	r3, [sp, #8]
 801b17e:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 801b182:	9301      	str	r3, [sp, #4]
 801b184:	2301      	movs	r3, #1
 801b186:	9300      	str	r3, [sp, #0]
 801b188:	2300      	movs	r3, #0
 801b18a:	f8b7 20d0 	ldrh.w	r2, [r7, #208]	; 0xd0
 801b18e:	6878      	ldr	r0, [r7, #4]
 801b190:	f7f5 fb68 	bl	8010864 <_lv_blend_fill>
            }
            fill_area2.x1 = area_outer->x2 - rout + 1;
 801b194:	68bb      	ldr	r3, [r7, #8]
 801b196:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b19a:	b29a      	uxth	r2, r3
 801b19c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801b1a0:	b29b      	uxth	r3, r3
 801b1a2:	1ad3      	subs	r3, r2, r3
 801b1a4:	b29b      	uxth	r3, r3
 801b1a6:	3301      	adds	r3, #1
 801b1a8:	b29b      	uxth	r3, r3
 801b1aa:	b21b      	sxth	r3, r3
 801b1ac:	823b      	strh	r3, [r7, #16]
            fill_area2.x2 = area_outer->x2;
 801b1ae:	68bb      	ldr	r3, [r7, #8]
 801b1b0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b1b4:	82bb      	strh	r3, [r7, #20]

            int32_t mask_ofs = (area_outer->x2 - rout + 1) - (vdb->area.x1 + draw_area.x1);
 801b1b6:	68bb      	ldr	r3, [r7, #8]
 801b1b8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b1bc:	461a      	mov	r2, r3
 801b1be:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 801b1c2:	1ad3      	subs	r3, r2, r3
 801b1c4:	1c5a      	adds	r2, r3, #1
 801b1c6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b1ca:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801b1ce:	4619      	mov	r1, r3
 801b1d0:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 801b1d4:	440b      	add	r3, r1
 801b1d6:	1ad3      	subs	r3, r2, r3
 801b1d8:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
            if(mask_ofs < 0) mask_ofs = 0;
 801b1dc:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801b1e0:	2b00      	cmp	r3, #0
 801b1e2:	da02      	bge.n	801b1ea <draw_full_border+0x5ac>
 801b1e4:	2300      	movs	r3, #0
 801b1e6:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
            _lv_blend_fill(clip, &fill_area2, color, mask_buf + mask_ofs, mask_res, opa, blend_mode);
 801b1ea:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 801b1ee:	6f7a      	ldr	r2, [r7, #116]	; 0x74
 801b1f0:	441a      	add	r2, r3
 801b1f2:	f107 0110 	add.w	r1, r7, #16
 801b1f6:	f897 30d8 	ldrb.w	r3, [r7, #216]	; 0xd8
 801b1fa:	9302      	str	r3, [sp, #8]
 801b1fc:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 801b200:	9301      	str	r3, [sp, #4]
 801b202:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801b206:	9300      	str	r3, [sp, #0]
 801b208:	4613      	mov	r3, r2
 801b20a:	f8b7 20d0 	ldrh.w	r2, [r7, #208]	; 0xd0
 801b20e:	6878      	ldr	r0, [r7, #4]
 801b210:	f7f5 fb28 	bl	8010864 <_lv_blend_fill>


            fill_area.y1++;
 801b214:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801b218:	b29b      	uxth	r3, r3
 801b21a:	3301      	adds	r3, #1
 801b21c:	b29b      	uxth	r3, r3
 801b21e:	b21b      	sxth	r3, r3
 801b220:	847b      	strh	r3, [r7, #34]	; 0x22
            fill_area.y2++;
 801b222:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801b226:	b29b      	uxth	r3, r3
 801b228:	3301      	adds	r3, #1
 801b22a:	b29b      	uxth	r3, r3
 801b22c:	b21b      	sxth	r3, r3
 801b22e:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(h = lower_corner_end; h <= draw_area.y2; h++) {
 801b230:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801b234:	3301      	adds	r3, #1
 801b236:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 801b23a:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 801b23e:	461a      	mov	r2, r3
 801b240:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801b244:	4293      	cmp	r3, r2
 801b246:	f77f af28 	ble.w	801b09a <draw_full_border+0x45c>
        }

        /*Draw the left vertical part*/
        fill_area.y1 = area_outer->y1 + corner_size + 1;
 801b24a:	68bb      	ldr	r3, [r7, #8]
 801b24c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801b250:	b29a      	uxth	r2, r3
 801b252:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801b254:	b29b      	uxth	r3, r3
 801b256:	4413      	add	r3, r2
 801b258:	b29b      	uxth	r3, r3
 801b25a:	3301      	adds	r3, #1
 801b25c:	b29b      	uxth	r3, r3
 801b25e:	b21b      	sxth	r3, r3
 801b260:	847b      	strh	r3, [r7, #34]	; 0x22
        fill_area.y2 = area_outer->y2 - corner_size - 1;
 801b262:	68bb      	ldr	r3, [r7, #8]
 801b264:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801b268:	b29a      	uxth	r2, r3
 801b26a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 801b26c:	b29b      	uxth	r3, r3
 801b26e:	1ad3      	subs	r3, r2, r3
 801b270:	b29b      	uxth	r3, r3
 801b272:	3b01      	subs	r3, #1
 801b274:	b29b      	uxth	r3, r3
 801b276:	b21b      	sxth	r3, r3
 801b278:	84fb      	strh	r3, [r7, #38]	; 0x26

        fill_area.x1 = area_outer->x1;
 801b27a:	68bb      	ldr	r3, [r7, #8]
 801b27c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b280:	843b      	strh	r3, [r7, #32]
        fill_area.x2 = area_outer->x1 + border_width - 1;
 801b282:	68bb      	ldr	r3, [r7, #8]
 801b284:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b288:	b29a      	uxth	r2, r3
 801b28a:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
 801b28e:	4413      	add	r3, r2
 801b290:	b29b      	uxth	r3, r3
 801b292:	3b01      	subs	r3, #1
 801b294:	b29b      	uxth	r3, r3
 801b296:	b21b      	sxth	r3, r3
 801b298:	84bb      	strh	r3, [r7, #36]	; 0x24
        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
 801b29a:	f107 0120 	add.w	r1, r7, #32
 801b29e:	f897 30d8 	ldrb.w	r3, [r7, #216]	; 0xd8
 801b2a2:	9302      	str	r3, [sp, #8]
 801b2a4:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 801b2a8:	9301      	str	r3, [sp, #4]
 801b2aa:	2301      	movs	r3, #1
 801b2ac:	9300      	str	r3, [sp, #0]
 801b2ae:	2300      	movs	r3, #0
 801b2b0:	f8b7 20d0 	ldrh.w	r2, [r7, #208]	; 0xd0
 801b2b4:	6878      	ldr	r0, [r7, #4]
 801b2b6:	f7f5 fad5 	bl	8010864 <_lv_blend_fill>

        /*Draw the right vertical border*/
        fill_area.x1 = area_outer->x2 - border_width + 1;
 801b2ba:	68bb      	ldr	r3, [r7, #8]
 801b2bc:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b2c0:	b29a      	uxth	r2, r3
 801b2c2:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
 801b2c6:	1ad3      	subs	r3, r2, r3
 801b2c8:	b29b      	uxth	r3, r3
 801b2ca:	3301      	adds	r3, #1
 801b2cc:	b29b      	uxth	r3, r3
 801b2ce:	b21b      	sxth	r3, r3
 801b2d0:	843b      	strh	r3, [r7, #32]
        fill_area.x2 = area_outer->x2;
 801b2d2:	68bb      	ldr	r3, [r7, #8]
 801b2d4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b2d8:	84bb      	strh	r3, [r7, #36]	; 0x24

        _lv_blend_fill(clip, &fill_area, color, NULL, LV_DRAW_MASK_RES_FULL_COVER, opa, blend_mode);
 801b2da:	f107 0120 	add.w	r1, r7, #32
 801b2de:	f897 30d8 	ldrb.w	r3, [r7, #216]	; 0xd8
 801b2e2:	9302      	str	r3, [sp, #8]
 801b2e4:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 801b2e8:	9301      	str	r3, [sp, #4]
 801b2ea:	2301      	movs	r3, #1
 801b2ec:	9300      	str	r3, [sp, #0]
 801b2ee:	2300      	movs	r3, #0
 801b2f0:	f8b7 20d0 	ldrh.w	r2, [r7, #208]	; 0xd0
 801b2f4:	6878      	ldr	r0, [r7, #4]
 801b2f6:	f7f5 fab5 	bl	8010864 <_lv_blend_fill>
 801b2fa:	e069      	b.n	801b3d0 <draw_full_border+0x792>
    }
    /*Process line by line if there is other mask too*/
    else {
        fill_area.x1 = area_outer->x1;
 801b2fc:	68bb      	ldr	r3, [r7, #8]
 801b2fe:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b302:	843b      	strh	r3, [r7, #32]
        fill_area.x2 = area_outer->x2;
 801b304:	68bb      	ldr	r3, [r7, #8]
 801b306:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b30a:	84bb      	strh	r3, [r7, #36]	; 0x24
        fill_area.y1 = disp_area->y1 + draw_area.y1;
 801b30c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801b310:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801b314:	b29a      	uxth	r2, r3
 801b316:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801b31a:	b29b      	uxth	r3, r3
 801b31c:	4413      	add	r3, r2
 801b31e:	b29b      	uxth	r3, r3
 801b320:	b21b      	sxth	r3, r3
 801b322:	847b      	strh	r3, [r7, #34]	; 0x22
        fill_area.y2 = fill_area.y1;
 801b324:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801b328:	84fb      	strh	r3, [r7, #38]	; 0x26

        for(h = draw_area.y1; h <= draw_area.y2; h++) {
 801b32a:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801b32e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 801b332:	e046      	b.n	801b3c2 <draw_full_border+0x784>
            _lv_memset_ff(mask_buf, draw_area_w);
 801b334:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801b336:	4619      	mov	r1, r3
 801b338:	6f78      	ldr	r0, [r7, #116]	; 0x74
 801b33a:	f006 fa36 	bl	80217aa <_lv_memset_ff>
            mask_res = lv_draw_mask_apply(mask_buf, vdb->area.x1 + draw_area.x1, vdb->area.y1 + h, draw_area_w);
 801b33e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b342:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801b346:	b29a      	uxth	r2, r3
 801b348:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 801b34c:	b29b      	uxth	r3, r3
 801b34e:	4413      	add	r3, r2
 801b350:	b29b      	uxth	r3, r3
 801b352:	b219      	sxth	r1, r3
 801b354:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801b358:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801b35c:	b29a      	uxth	r2, r3
 801b35e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801b362:	b29b      	uxth	r3, r3
 801b364:	4413      	add	r3, r2
 801b366:	b29b      	uxth	r3, r3
 801b368:	b21a      	sxth	r2, r3
 801b36a:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 801b36c:	b21b      	sxth	r3, r3
 801b36e:	6f78      	ldr	r0, [r7, #116]	; 0x74
 801b370:	f7fa fe20 	bl	8015fb4 <lv_draw_mask_apply>
 801b374:	4603      	mov	r3, r0
 801b376:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f

            _lv_blend_fill(clip, &fill_area, color, mask_buf, mask_res, opa, blend_mode);
 801b37a:	f107 0120 	add.w	r1, r7, #32
 801b37e:	f897 30d8 	ldrb.w	r3, [r7, #216]	; 0xd8
 801b382:	9302      	str	r3, [sp, #8]
 801b384:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
 801b388:	9301      	str	r3, [sp, #4]
 801b38a:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801b38e:	9300      	str	r3, [sp, #0]
 801b390:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 801b392:	f8b7 20d0 	ldrh.w	r2, [r7, #208]	; 0xd0
 801b396:	6878      	ldr	r0, [r7, #4]
 801b398:	f7f5 fa64 	bl	8010864 <_lv_blend_fill>
            fill_area.y1++;
 801b39c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801b3a0:	b29b      	uxth	r3, r3
 801b3a2:	3301      	adds	r3, #1
 801b3a4:	b29b      	uxth	r3, r3
 801b3a6:	b21b      	sxth	r3, r3
 801b3a8:	847b      	strh	r3, [r7, #34]	; 0x22
            fill_area.y2++;
 801b3aa:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801b3ae:	b29b      	uxth	r3, r3
 801b3b0:	3301      	adds	r3, #1
 801b3b2:	b29b      	uxth	r3, r3
 801b3b4:	b21b      	sxth	r3, r3
 801b3b6:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(h = draw_area.y1; h <= draw_area.y2; h++) {
 801b3b8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801b3bc:	3301      	adds	r3, #1
 801b3be:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 801b3c2:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 801b3c6:	461a      	mov	r2, r3
 801b3c8:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 801b3cc:	4293      	cmp	r3, r2
 801b3ce:	ddb1      	ble.n	801b334 <draw_full_border+0x6f6>

        }
    }
    lv_draw_mask_remove_id(mask_rin_id);
 801b3d0:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 801b3d4:	4618      	mov	r0, r3
 801b3d6:	f7fa fe31 	bl	801603c <lv_draw_mask_remove_id>
    lv_draw_mask_remove_id(mask_rout_id);
 801b3da:	f9b7 3078 	ldrsh.w	r3, [r7, #120]	; 0x78
 801b3de:	4618      	mov	r0, r3
 801b3e0:	f7fa fe2c 	bl	801603c <lv_draw_mask_remove_id>
    _lv_mem_buf_release(mask_buf);
 801b3e4:	6f78      	ldr	r0, [r7, #116]	; 0x74
 801b3e6:	f005 fe33 	bl	8021050 <_lv_mem_buf_release>
 801b3ea:	e000      	b.n	801b3ee <draw_full_border+0x7b0>
    if(is_common == false) return;
 801b3ec:	bf00      	nop
}
 801b3ee:	37c8      	adds	r7, #200	; 0xc8
 801b3f0:	46bd      	mov	sp, r7
 801b3f2:	bd80      	pop	{r7, pc}

0801b3f4 <lv_color_mix>:
{
 801b3f4:	b480      	push	{r7}
 801b3f6:	b085      	sub	sp, #20
 801b3f8:	af00      	add	r7, sp, #0
 801b3fa:	80b8      	strh	r0, [r7, #4]
 801b3fc:	8039      	strh	r1, [r7, #0]
 801b3fe:	4613      	mov	r3, r2
 801b400:	70fb      	strb	r3, [r7, #3]
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
 801b402:	797b      	ldrb	r3, [r7, #5]
 801b404:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801b408:	b2db      	uxtb	r3, r3
 801b40a:	461a      	mov	r2, r3
 801b40c:	78fb      	ldrb	r3, [r7, #3]
 801b40e:	fb03 f202 	mul.w	r2, r3, r2
 801b412:	787b      	ldrb	r3, [r7, #1]
 801b414:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801b418:	b2db      	uxtb	r3, r3
 801b41a:	4619      	mov	r1, r3
 801b41c:	78fb      	ldrb	r3, [r7, #3]
 801b41e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801b422:	fb01 f303 	mul.w	r3, r1, r3
 801b426:	4413      	add	r3, r2
 801b428:	3380      	adds	r3, #128	; 0x80
 801b42a:	461a      	mov	r2, r3
 801b42c:	4613      	mov	r3, r2
 801b42e:	021b      	lsls	r3, r3, #8
 801b430:	4413      	add	r3, r2
 801b432:	01db      	lsls	r3, r3, #7
 801b434:	4413      	add	r3, r2
 801b436:	0ddb      	lsrs	r3, r3, #23
 801b438:	f003 031f 	and.w	r3, r3, #31
 801b43c:	b2da      	uxtb	r2, r3
 801b43e:	7b7b      	ldrb	r3, [r7, #13]
 801b440:	f362 03c7 	bfi	r3, r2, #3, #5
 801b444:	737b      	strb	r3, [r7, #13]
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
 801b446:	88bb      	ldrh	r3, [r7, #4]
 801b448:	f3c3 1345 	ubfx	r3, r3, #5, #6
 801b44c:	b2db      	uxtb	r3, r3
 801b44e:	461a      	mov	r2, r3
 801b450:	78fb      	ldrb	r3, [r7, #3]
 801b452:	fb03 f202 	mul.w	r2, r3, r2
 801b456:	883b      	ldrh	r3, [r7, #0]
 801b458:	f3c3 1345 	ubfx	r3, r3, #5, #6
 801b45c:	b2db      	uxtb	r3, r3
 801b45e:	4619      	mov	r1, r3
 801b460:	78fb      	ldrb	r3, [r7, #3]
 801b462:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801b466:	fb01 f303 	mul.w	r3, r1, r3
 801b46a:	4413      	add	r3, r2
 801b46c:	3380      	adds	r3, #128	; 0x80
 801b46e:	461a      	mov	r2, r3
 801b470:	4613      	mov	r3, r2
 801b472:	021b      	lsls	r3, r3, #8
 801b474:	4413      	add	r3, r2
 801b476:	01db      	lsls	r3, r3, #7
 801b478:	4413      	add	r3, r2
 801b47a:	0ddb      	lsrs	r3, r3, #23
 801b47c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801b480:	b2da      	uxtb	r2, r3
 801b482:	89bb      	ldrh	r3, [r7, #12]
 801b484:	f362 134a 	bfi	r3, r2, #5, #6
 801b488:	81bb      	strh	r3, [r7, #12]
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
 801b48a:	793b      	ldrb	r3, [r7, #4]
 801b48c:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801b490:	b2db      	uxtb	r3, r3
 801b492:	461a      	mov	r2, r3
 801b494:	78fb      	ldrb	r3, [r7, #3]
 801b496:	fb03 f202 	mul.w	r2, r3, r2
 801b49a:	783b      	ldrb	r3, [r7, #0]
 801b49c:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801b4a0:	b2db      	uxtb	r3, r3
 801b4a2:	4619      	mov	r1, r3
 801b4a4:	78fb      	ldrb	r3, [r7, #3]
 801b4a6:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801b4aa:	fb01 f303 	mul.w	r3, r1, r3
 801b4ae:	4413      	add	r3, r2
 801b4b0:	3380      	adds	r3, #128	; 0x80
 801b4b2:	461a      	mov	r2, r3
 801b4b4:	4613      	mov	r3, r2
 801b4b6:	021b      	lsls	r3, r3, #8
 801b4b8:	4413      	add	r3, r2
 801b4ba:	01db      	lsls	r3, r3, #7
 801b4bc:	4413      	add	r3, r2
 801b4be:	0ddb      	lsrs	r3, r3, #23
 801b4c0:	f003 031f 	and.w	r3, r3, #31
 801b4c4:	b2da      	uxtb	r2, r3
 801b4c6:	7b3b      	ldrb	r3, [r7, #12]
 801b4c8:	f362 0304 	bfi	r3, r2, #0, #5
 801b4cc:	733b      	strb	r3, [r7, #12]
    return ret;
 801b4ce:	89bb      	ldrh	r3, [r7, #12]
}
 801b4d0:	4618      	mov	r0, r3
 801b4d2:	3714      	adds	r7, #20
 801b4d4:	46bd      	mov	sp, r7
 801b4d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b4da:	4770      	bx	lr

0801b4dc <_lv_memcpy_small>:
{
 801b4dc:	b480      	push	{r7}
 801b4de:	b087      	sub	sp, #28
 801b4e0:	af00      	add	r7, sp, #0
 801b4e2:	60f8      	str	r0, [r7, #12]
 801b4e4:	60b9      	str	r1, [r7, #8]
 801b4e6:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 801b4e8:	68fb      	ldr	r3, [r7, #12]
 801b4ea:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 801b4ec:	68bb      	ldr	r3, [r7, #8]
 801b4ee:	613b      	str	r3, [r7, #16]
    while(len) {
 801b4f0:	e00c      	b.n	801b50c <_lv_memcpy_small+0x30>
        *d8 = *s8;
 801b4f2:	693b      	ldr	r3, [r7, #16]
 801b4f4:	781a      	ldrb	r2, [r3, #0]
 801b4f6:	697b      	ldr	r3, [r7, #20]
 801b4f8:	701a      	strb	r2, [r3, #0]
        d8++;
 801b4fa:	697b      	ldr	r3, [r7, #20]
 801b4fc:	3301      	adds	r3, #1
 801b4fe:	617b      	str	r3, [r7, #20]
        s8++;
 801b500:	693b      	ldr	r3, [r7, #16]
 801b502:	3301      	adds	r3, #1
 801b504:	613b      	str	r3, [r7, #16]
        len--;
 801b506:	687b      	ldr	r3, [r7, #4]
 801b508:	3b01      	subs	r3, #1
 801b50a:	607b      	str	r3, [r7, #4]
    while(len) {
 801b50c:	687b      	ldr	r3, [r7, #4]
 801b50e:	2b00      	cmp	r3, #0
 801b510:	d1ef      	bne.n	801b4f2 <_lv_memcpy_small+0x16>
    return dst;
 801b512:	68fb      	ldr	r3, [r7, #12]
}
 801b514:	4618      	mov	r0, r3
 801b516:	371c      	adds	r7, #28
 801b518:	46bd      	mov	sp, r7
 801b51a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b51e:	4770      	bx	lr

0801b520 <lv_img_buf_get_px_color>:
 * Not used in other cases.
 * @param safe true: check out of bounds
 * @return color of the point
 */
lv_color_t lv_img_buf_get_px_color(lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_color_t color)
{
 801b520:	b580      	push	{r7, lr}
 801b522:	b090      	sub	sp, #64	; 0x40
 801b524:	af00      	add	r7, sp, #0
 801b526:	60f8      	str	r0, [r7, #12]
 801b528:	80bb      	strh	r3, [r7, #4]
 801b52a:	460b      	mov	r3, r1
 801b52c:	817b      	strh	r3, [r7, #10]
 801b52e:	4613      	mov	r3, r2
 801b530:	813b      	strh	r3, [r7, #8]
    lv_color_t p_color = LV_COLOR_BLACK;
 801b532:	7d3b      	ldrb	r3, [r7, #20]
 801b534:	f36f 0304 	bfc	r3, #0, #5
 801b538:	753b      	strb	r3, [r7, #20]
 801b53a:	8abb      	ldrh	r3, [r7, #20]
 801b53c:	f36f 134a 	bfc	r3, #5, #6
 801b540:	82bb      	strh	r3, [r7, #20]
 801b542:	7d7b      	ldrb	r3, [r7, #21]
 801b544:	f36f 03c7 	bfc	r3, #3, #5
 801b548:	757b      	strb	r3, [r7, #21]
    uint8_t * buf_u8 = (uint8_t *)dsc->data;
 801b54a:	68fb      	ldr	r3, [r7, #12]
 801b54c:	689b      	ldr	r3, [r3, #8]
 801b54e:	63fb      	str	r3, [r7, #60]	; 0x3c

    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED ||
 801b550:	68fb      	ldr	r3, [r7, #12]
 801b552:	781b      	ldrb	r3, [r3, #0]
 801b554:	f003 031f 	and.w	r3, r3, #31
 801b558:	b2db      	uxtb	r3, r3
 801b55a:	2b04      	cmp	r3, #4
 801b55c:	d00d      	beq.n	801b57a <lv_img_buf_get_px_color+0x5a>
 801b55e:	68fb      	ldr	r3, [r7, #12]
 801b560:	781b      	ldrb	r3, [r3, #0]
 801b562:	f003 031f 	and.w	r3, r3, #31
 801b566:	b2db      	uxtb	r3, r3
 801b568:	2b06      	cmp	r3, #6
 801b56a:	d006      	beq.n	801b57a <lv_img_buf_get_px_color+0x5a>
       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA) {
 801b56c:	68fb      	ldr	r3, [r7, #12]
 801b56e:	781b      	ldrb	r3, [r3, #0]
 801b570:	f003 031f 	and.w	r3, r3, #31
 801b574:	b2db      	uxtb	r3, r3
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED ||
 801b576:	2b05      	cmp	r3, #5
 801b578:	d128      	bne.n	801b5cc <lv_img_buf_get_px_color+0xac>
        uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf) >> 3;
 801b57a:	68fb      	ldr	r3, [r7, #12]
 801b57c:	781b      	ldrb	r3, [r3, #0]
 801b57e:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801b582:	b2db      	uxtb	r3, r3
 801b584:	4618      	mov	r0, r3
 801b586:	f7f6 ff95 	bl	80124b4 <lv_img_cf_get_px_size>
 801b58a:	4603      	mov	r3, r0
 801b58c:	08db      	lsrs	r3, r3, #3
 801b58e:	77fb      	strb	r3, [r7, #31]
        uint32_t px     = dsc->header.w * y * px_size + x * px_size;
 801b590:	68fb      	ldr	r3, [r7, #12]
 801b592:	681b      	ldr	r3, [r3, #0]
 801b594:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801b598:	b29b      	uxth	r3, r3
 801b59a:	461a      	mov	r2, r3
 801b59c:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 801b5a0:	fb02 f303 	mul.w	r3, r2, r3
 801b5a4:	7ffa      	ldrb	r2, [r7, #31]
 801b5a6:	fb03 f202 	mul.w	r2, r3, r2
 801b5aa:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801b5ae:	7ff9      	ldrb	r1, [r7, #31]
 801b5b0:	fb01 f303 	mul.w	r3, r1, r3
 801b5b4:	4413      	add	r3, r2
 801b5b6:	61bb      	str	r3, [r7, #24]
        _lv_memcpy_small(&p_color, &buf_u8[px], sizeof(lv_color_t));
 801b5b8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801b5ba:	69bb      	ldr	r3, [r7, #24]
 801b5bc:	18d1      	adds	r1, r2, r3
 801b5be:	f107 0314 	add.w	r3, r7, #20
 801b5c2:	2202      	movs	r2, #2
 801b5c4:	4618      	mov	r0, r3
 801b5c6:	f7ff ff89 	bl	801b4dc <_lv_memcpy_small>
       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA) {
 801b5ca:	e0ef      	b.n	801b7ac <lv_img_buf_get_px_color+0x28c>
#if LV_COLOR_SIZE == 32
        p_color.ch.alpha = 0xFF; /*Only the color should be get so use a default alpha value*/
#endif
    }
    else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT) {
 801b5cc:	68fb      	ldr	r3, [r7, #12]
 801b5ce:	781b      	ldrb	r3, [r3, #0]
 801b5d0:	f003 031f 	and.w	r3, r3, #31
 801b5d4:	b2db      	uxtb	r3, r3
 801b5d6:	2b07      	cmp	r3, #7
 801b5d8:	d132      	bne.n	801b640 <lv_img_buf_get_px_color+0x120>
        buf_u8 += 4 * 2;
 801b5da:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b5dc:	3308      	adds	r3, #8
 801b5de:	63fb      	str	r3, [r7, #60]	; 0x3c
        uint8_t bit = x & 0x7;
 801b5e0:	897b      	ldrh	r3, [r7, #10]
 801b5e2:	b2db      	uxtb	r3, r3
 801b5e4:	f003 0307 	and.w	r3, r3, #7
 801b5e8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        x           = x >> 3;
 801b5ec:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801b5f0:	10db      	asrs	r3, r3, #3
 801b5f2:	817b      	strh	r3, [r7, #10]

        /* Get the current pixel.
         * dsc->header.w + 7 means rounding up to 8 because the lines are byte aligned
         * so the possible real width are 8, 16, 24 ...*/
        uint32_t px  = ((dsc->header.w + 7) >> 3) * y + x;
 801b5f4:	68fb      	ldr	r3, [r7, #12]
 801b5f6:	681b      	ldr	r3, [r3, #0]
 801b5f8:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801b5fc:	b29b      	uxth	r3, r3
 801b5fe:	3307      	adds	r3, #7
 801b600:	10db      	asrs	r3, r3, #3
 801b602:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801b606:	fb03 f202 	mul.w	r2, r3, r2
 801b60a:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801b60e:	4413      	add	r3, r2
 801b610:	623b      	str	r3, [r7, #32]
        p_color.full = (buf_u8[px] & (1 << (7 - bit))) >> (7 - bit);
 801b612:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801b614:	6a3b      	ldr	r3, [r7, #32]
 801b616:	4413      	add	r3, r2
 801b618:	781b      	ldrb	r3, [r3, #0]
 801b61a:	4619      	mov	r1, r3
 801b61c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801b620:	f1c3 0307 	rsb	r3, r3, #7
 801b624:	2201      	movs	r2, #1
 801b626:	fa02 f303 	lsl.w	r3, r2, r3
 801b62a:	ea01 0203 	and.w	r2, r1, r3
 801b62e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801b632:	f1c3 0307 	rsb	r3, r3, #7
 801b636:	fa42 f303 	asr.w	r3, r2, r3
 801b63a:	b29b      	uxth	r3, r3
 801b63c:	82bb      	strh	r3, [r7, #20]
 801b63e:	e0b5      	b.n	801b7ac <lv_img_buf_get_px_color+0x28c>
    }
    else if(dsc->header.cf == LV_IMG_CF_INDEXED_2BIT) {
 801b640:	68fb      	ldr	r3, [r7, #12]
 801b642:	781b      	ldrb	r3, [r3, #0]
 801b644:	f003 031f 	and.w	r3, r3, #31
 801b648:	b2db      	uxtb	r3, r3
 801b64a:	2b08      	cmp	r3, #8
 801b64c:	d134      	bne.n	801b6b8 <lv_img_buf_get_px_color+0x198>
        buf_u8 += 4 * 4;
 801b64e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b650:	3310      	adds	r3, #16
 801b652:	63fb      	str	r3, [r7, #60]	; 0x3c
        uint8_t bit = (x & 0x3) * 2;
 801b654:	897b      	ldrh	r3, [r7, #10]
 801b656:	b2db      	uxtb	r3, r3
 801b658:	f003 0303 	and.w	r3, r3, #3
 801b65c:	b2db      	uxtb	r3, r3
 801b65e:	005b      	lsls	r3, r3, #1
 801b660:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        x           = x >> 2;
 801b664:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801b668:	109b      	asrs	r3, r3, #2
 801b66a:	817b      	strh	r3, [r7, #10]

        /* Get the current pixel.
         * dsc->header.w + 3 means rounding up to 4 because the lines are byte aligned
         * so the possible real width are 4, 8, 12 ...*/
        uint32_t px  = ((dsc->header.w + 3) >> 2) * y + x;
 801b66c:	68fb      	ldr	r3, [r7, #12]
 801b66e:	681b      	ldr	r3, [r3, #0]
 801b670:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801b674:	b29b      	uxth	r3, r3
 801b676:	3303      	adds	r3, #3
 801b678:	109b      	asrs	r3, r3, #2
 801b67a:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801b67e:	fb03 f202 	mul.w	r2, r3, r2
 801b682:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801b686:	4413      	add	r3, r2
 801b688:	62bb      	str	r3, [r7, #40]	; 0x28
        p_color.full = (buf_u8[px] & (3 << (6 - bit))) >> (6 - bit);
 801b68a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801b68c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b68e:	4413      	add	r3, r2
 801b690:	781b      	ldrb	r3, [r3, #0]
 801b692:	4619      	mov	r1, r3
 801b694:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801b698:	f1c3 0306 	rsb	r3, r3, #6
 801b69c:	2203      	movs	r2, #3
 801b69e:	fa02 f303 	lsl.w	r3, r2, r3
 801b6a2:	ea01 0203 	and.w	r2, r1, r3
 801b6a6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801b6aa:	f1c3 0306 	rsb	r3, r3, #6
 801b6ae:	fa42 f303 	asr.w	r3, r2, r3
 801b6b2:	b29b      	uxth	r3, r3
 801b6b4:	82bb      	strh	r3, [r7, #20]
 801b6b6:	e079      	b.n	801b7ac <lv_img_buf_get_px_color+0x28c>
    }
    else if(dsc->header.cf == LV_IMG_CF_INDEXED_4BIT) {
 801b6b8:	68fb      	ldr	r3, [r7, #12]
 801b6ba:	781b      	ldrb	r3, [r3, #0]
 801b6bc:	f003 031f 	and.w	r3, r3, #31
 801b6c0:	b2db      	uxtb	r3, r3
 801b6c2:	2b09      	cmp	r3, #9
 801b6c4:	d134      	bne.n	801b730 <lv_img_buf_get_px_color+0x210>
        buf_u8 += 4 * 16;
 801b6c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b6c8:	3340      	adds	r3, #64	; 0x40
 801b6ca:	63fb      	str	r3, [r7, #60]	; 0x3c
        uint8_t bit = (x & 0x1) * 4;
 801b6cc:	897b      	ldrh	r3, [r7, #10]
 801b6ce:	b2db      	uxtb	r3, r3
 801b6d0:	f003 0301 	and.w	r3, r3, #1
 801b6d4:	b2db      	uxtb	r3, r3
 801b6d6:	009b      	lsls	r3, r3, #2
 801b6d8:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        x           = x >> 1;
 801b6dc:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801b6e0:	105b      	asrs	r3, r3, #1
 801b6e2:	817b      	strh	r3, [r7, #10]

        /* Get the current pixel.
         * dsc->header.w + 1 means rounding up to 2 because the lines are byte aligned
         * so the possible real width are 2, 4, 6 ...*/
        uint32_t px  = ((dsc->header.w + 1) >> 1) * y + x;
 801b6e4:	68fb      	ldr	r3, [r7, #12]
 801b6e6:	681b      	ldr	r3, [r3, #0]
 801b6e8:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801b6ec:	b29b      	uxth	r3, r3
 801b6ee:	3301      	adds	r3, #1
 801b6f0:	105b      	asrs	r3, r3, #1
 801b6f2:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801b6f6:	fb03 f202 	mul.w	r2, r3, r2
 801b6fa:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801b6fe:	4413      	add	r3, r2
 801b700:	633b      	str	r3, [r7, #48]	; 0x30
        p_color.full = (buf_u8[px] & (0xF << (4 - bit))) >> (4 - bit);
 801b702:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801b704:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b706:	4413      	add	r3, r2
 801b708:	781b      	ldrb	r3, [r3, #0]
 801b70a:	4619      	mov	r1, r3
 801b70c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801b710:	f1c3 0304 	rsb	r3, r3, #4
 801b714:	220f      	movs	r2, #15
 801b716:	fa02 f303 	lsl.w	r3, r2, r3
 801b71a:	ea01 0203 	and.w	r2, r1, r3
 801b71e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801b722:	f1c3 0304 	rsb	r3, r3, #4
 801b726:	fa42 f303 	asr.w	r3, r2, r3
 801b72a:	b29b      	uxth	r3, r3
 801b72c:	82bb      	strh	r3, [r7, #20]
 801b72e:	e03d      	b.n	801b7ac <lv_img_buf_get_px_color+0x28c>
    }
    else if(dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {
 801b730:	68fb      	ldr	r3, [r7, #12]
 801b732:	781b      	ldrb	r3, [r3, #0]
 801b734:	f003 031f 	and.w	r3, r3, #31
 801b738:	b2db      	uxtb	r3, r3
 801b73a:	2b0a      	cmp	r3, #10
 801b73c:	d118      	bne.n	801b770 <lv_img_buf_get_px_color+0x250>
        buf_u8 += 4 * 256;
 801b73e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801b740:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801b744:	63fb      	str	r3, [r7, #60]	; 0x3c
        uint32_t px  = dsc->header.w * y + x;
 801b746:	68fb      	ldr	r3, [r7, #12]
 801b748:	681b      	ldr	r3, [r3, #0]
 801b74a:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801b74e:	b29b      	uxth	r3, r3
 801b750:	461a      	mov	r2, r3
 801b752:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 801b756:	fb03 f202 	mul.w	r2, r3, r2
 801b75a:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801b75e:	4413      	add	r3, r2
 801b760:	63bb      	str	r3, [r7, #56]	; 0x38
        p_color.full = buf_u8[px];
 801b762:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801b764:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b766:	4413      	add	r3, r2
 801b768:	781b      	ldrb	r3, [r3, #0]
 801b76a:	b29b      	uxth	r3, r3
 801b76c:	82bb      	strh	r3, [r7, #20]
 801b76e:	e01d      	b.n	801b7ac <lv_img_buf_get_px_color+0x28c>
    }
    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
 801b770:	68fb      	ldr	r3, [r7, #12]
 801b772:	781b      	ldrb	r3, [r3, #0]
 801b774:	f003 031f 	and.w	r3, r3, #31
 801b778:	b2db      	uxtb	r3, r3
 801b77a:	2b0b      	cmp	r3, #11
 801b77c:	d014      	beq.n	801b7a8 <lv_img_buf_get_px_color+0x288>
 801b77e:	68fb      	ldr	r3, [r7, #12]
 801b780:	781b      	ldrb	r3, [r3, #0]
 801b782:	f003 031f 	and.w	r3, r3, #31
 801b786:	b2db      	uxtb	r3, r3
 801b788:	2b0c      	cmp	r3, #12
 801b78a:	d00d      	beq.n	801b7a8 <lv_img_buf_get_px_color+0x288>
            dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
 801b78c:	68fb      	ldr	r3, [r7, #12]
 801b78e:	781b      	ldrb	r3, [r3, #0]
 801b790:	f003 031f 	and.w	r3, r3, #31
 801b794:	b2db      	uxtb	r3, r3
    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
 801b796:	2b0d      	cmp	r3, #13
 801b798:	d006      	beq.n	801b7a8 <lv_img_buf_get_px_color+0x288>
            dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
 801b79a:	68fb      	ldr	r3, [r7, #12]
 801b79c:	781b      	ldrb	r3, [r3, #0]
 801b79e:	f003 031f 	and.w	r3, r3, #31
 801b7a2:	b2db      	uxtb	r3, r3
 801b7a4:	2b0e      	cmp	r3, #14
 801b7a6:	d101      	bne.n	801b7ac <lv_img_buf_get_px_color+0x28c>
        p_color = color;
 801b7a8:	88bb      	ldrh	r3, [r7, #4]
 801b7aa:	82bb      	strh	r3, [r7, #20]
    }
    return p_color;
 801b7ac:	8abb      	ldrh	r3, [r7, #20]
}
 801b7ae:	4618      	mov	r0, r3
 801b7b0:	3740      	adds	r7, #64	; 0x40
 801b7b2:	46bd      	mov	sp, r7
 801b7b4:	bd80      	pop	{r7, pc}
	...

0801b7b8 <lv_img_buf_get_px_alpha>:
 * @param y x coordinate of the point to set
 * @param safe true: check out of bounds
 * @return alpha value of the point
 */
lv_opa_t lv_img_buf_get_px_alpha(lv_img_dsc_t * dsc, lv_coord_t x, lv_coord_t y)
{
 801b7b8:	b490      	push	{r4, r7}
 801b7ba:	b092      	sub	sp, #72	; 0x48
 801b7bc:	af00      	add	r7, sp, #0
 801b7be:	6078      	str	r0, [r7, #4]
 801b7c0:	460b      	mov	r3, r1
 801b7c2:	807b      	strh	r3, [r7, #2]
 801b7c4:	4613      	mov	r3, r2
 801b7c6:	803b      	strh	r3, [r7, #0]
    uint8_t * buf_u8 = (uint8_t *)dsc->data;
 801b7c8:	687b      	ldr	r3, [r7, #4]
 801b7ca:	689b      	ldr	r3, [r3, #8]
 801b7cc:	647b      	str	r3, [r7, #68]	; 0x44

    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA) {
 801b7ce:	687b      	ldr	r3, [r7, #4]
 801b7d0:	781b      	ldrb	r3, [r3, #0]
 801b7d2:	f003 031f 	and.w	r3, r3, #31
 801b7d6:	b2db      	uxtb	r3, r3
 801b7d8:	2b05      	cmp	r3, #5
 801b7da:	d116      	bne.n	801b80a <lv_img_buf_get_px_alpha+0x52>
        uint32_t px = dsc->header.w * y * LV_IMG_PX_SIZE_ALPHA_BYTE + x * LV_IMG_PX_SIZE_ALPHA_BYTE;
 801b7dc:	687b      	ldr	r3, [r7, #4]
 801b7de:	681b      	ldr	r3, [r3, #0]
 801b7e0:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801b7e4:	b29b      	uxth	r3, r3
 801b7e6:	461a      	mov	r2, r3
 801b7e8:	f9b7 3000 	ldrsh.w	r3, [r7]
 801b7ec:	fb03 f202 	mul.w	r2, r3, r2
 801b7f0:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801b7f4:	441a      	add	r2, r3
 801b7f6:	4613      	mov	r3, r2
 801b7f8:	005b      	lsls	r3, r3, #1
 801b7fa:	4413      	add	r3, r2
 801b7fc:	623b      	str	r3, [r7, #32]
        return buf_u8[px + LV_IMG_PX_SIZE_ALPHA_BYTE - 1];
 801b7fe:	6a3b      	ldr	r3, [r7, #32]
 801b800:	3302      	adds	r3, #2
 801b802:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801b804:	4413      	add	r3, r2
 801b806:	781b      	ldrb	r3, [r3, #0]
 801b808:	e0de      	b.n	801b9c8 <lv_img_buf_get_px_alpha+0x210>
    }
    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT) {
 801b80a:	687b      	ldr	r3, [r7, #4]
 801b80c:	781b      	ldrb	r3, [r3, #0]
 801b80e:	f003 031f 	and.w	r3, r3, #31
 801b812:	b2db      	uxtb	r3, r3
 801b814:	2b0b      	cmp	r3, #11
 801b816:	d136      	bne.n	801b886 <lv_img_buf_get_px_alpha+0xce>
        uint8_t bit = x & 0x7;
 801b818:	887b      	ldrh	r3, [r7, #2]
 801b81a:	b2db      	uxtb	r3, r3
 801b81c:	f003 0307 	and.w	r3, r3, #7
 801b820:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
        x           = x >> 3;
 801b824:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801b828:	10db      	asrs	r3, r3, #3
 801b82a:	807b      	strh	r3, [r7, #2]

        /* Get the current pixel.
         * dsc->header.w + 7 means rounding up to 8 because the lines are byte aligned
         * so the possible real width are 8 ,16, 24 ...*/
        uint32_t px    = ((dsc->header.w + 7) >> 3) * y + x;
 801b82c:	687b      	ldr	r3, [r7, #4]
 801b82e:	681b      	ldr	r3, [r3, #0]
 801b830:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801b834:	b29b      	uxth	r3, r3
 801b836:	3307      	adds	r3, #7
 801b838:	10db      	asrs	r3, r3, #3
 801b83a:	f9b7 2000 	ldrsh.w	r2, [r7]
 801b83e:	fb03 f202 	mul.w	r2, r3, r2
 801b842:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801b846:	4413      	add	r3, r2
 801b848:	62bb      	str	r3, [r7, #40]	; 0x28
        uint8_t px_opa = (buf_u8[px] & (1 << (7 - bit))) >> (7 - bit);
 801b84a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801b84c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801b84e:	4413      	add	r3, r2
 801b850:	781b      	ldrb	r3, [r3, #0]
 801b852:	4619      	mov	r1, r3
 801b854:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 801b858:	f1c3 0307 	rsb	r3, r3, #7
 801b85c:	2201      	movs	r2, #1
 801b85e:	fa02 f303 	lsl.w	r3, r2, r3
 801b862:	ea01 0203 	and.w	r2, r1, r3
 801b866:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 801b86a:	f1c3 0307 	rsb	r3, r3, #7
 801b86e:	fa42 f303 	asr.w	r3, r2, r3
 801b872:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        return px_opa ? LV_OPA_TRANSP : LV_OPA_COVER;
 801b876:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801b87a:	2b00      	cmp	r3, #0
 801b87c:	d001      	beq.n	801b882 <lv_img_buf_get_px_alpha+0xca>
 801b87e:	2300      	movs	r3, #0
 801b880:	e0a2      	b.n	801b9c8 <lv_img_buf_get_px_alpha+0x210>
 801b882:	23ff      	movs	r3, #255	; 0xff
 801b884:	e0a0      	b.n	801b9c8 <lv_img_buf_get_px_alpha+0x210>
    }
    else if(dsc->header.cf == LV_IMG_CF_ALPHA_2BIT) {
 801b886:	687b      	ldr	r3, [r7, #4]
 801b888:	781b      	ldrb	r3, [r3, #0]
 801b88a:	f003 031f 	and.w	r3, r3, #31
 801b88e:	b2db      	uxtb	r3, r3
 801b890:	2b0c      	cmp	r3, #12
 801b892:	d139      	bne.n	801b908 <lv_img_buf_get_px_alpha+0x150>
        const uint8_t opa_table[4] = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
 801b894:	4b4f      	ldr	r3, [pc, #316]	; (801b9d4 <lv_img_buf_get_px_alpha+0x21c>)
 801b896:	61fb      	str	r3, [r7, #28]

        uint8_t bit = (x & 0x3) * 2;
 801b898:	887b      	ldrh	r3, [r7, #2]
 801b89a:	b2db      	uxtb	r3, r3
 801b89c:	f003 0303 	and.w	r3, r3, #3
 801b8a0:	b2db      	uxtb	r3, r3
 801b8a2:	005b      	lsls	r3, r3, #1
 801b8a4:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
        x           = x >> 2;
 801b8a8:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801b8ac:	109b      	asrs	r3, r3, #2
 801b8ae:	807b      	strh	r3, [r7, #2]

        /* Get the current pixel.
         * dsc->header.w + 4 means rounding up to 8 because the lines are byte aligned
         * so the possible real width are 4 ,8, 12 ...*/
        uint32_t px    = ((dsc->header.w + 3) >> 2) * y + x;
 801b8b0:	687b      	ldr	r3, [r7, #4]
 801b8b2:	681b      	ldr	r3, [r3, #0]
 801b8b4:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801b8b8:	b29b      	uxth	r3, r3
 801b8ba:	3303      	adds	r3, #3
 801b8bc:	109b      	asrs	r3, r3, #2
 801b8be:	f9b7 2000 	ldrsh.w	r2, [r7]
 801b8c2:	fb03 f202 	mul.w	r2, r3, r2
 801b8c6:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801b8ca:	4413      	add	r3, r2
 801b8cc:	633b      	str	r3, [r7, #48]	; 0x30
        uint8_t px_opa = (buf_u8[px] & (3 << (6 - bit))) >> (6 - bit);
 801b8ce:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801b8d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801b8d2:	4413      	add	r3, r2
 801b8d4:	781b      	ldrb	r3, [r3, #0]
 801b8d6:	4619      	mov	r1, r3
 801b8d8:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801b8dc:	f1c3 0306 	rsb	r3, r3, #6
 801b8e0:	2203      	movs	r2, #3
 801b8e2:	fa02 f303 	lsl.w	r3, r2, r3
 801b8e6:	ea01 0203 	and.w	r2, r1, r3
 801b8ea:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801b8ee:	f1c3 0306 	rsb	r3, r3, #6
 801b8f2:	fa42 f303 	asr.w	r3, r2, r3
 801b8f6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
        return opa_table[px_opa];
 801b8fa:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801b8fe:	3348      	adds	r3, #72	; 0x48
 801b900:	443b      	add	r3, r7
 801b902:	f813 3c2c 	ldrb.w	r3, [r3, #-44]
 801b906:	e05f      	b.n	801b9c8 <lv_img_buf_get_px_alpha+0x210>
    }
    else if(dsc->header.cf == LV_IMG_CF_ALPHA_4BIT) {
 801b908:	687b      	ldr	r3, [r7, #4]
 801b90a:	781b      	ldrb	r3, [r3, #0]
 801b90c:	f003 031f 	and.w	r3, r3, #31
 801b910:	b2db      	uxtb	r3, r3
 801b912:	2b0d      	cmp	r3, #13
 801b914:	d13d      	bne.n	801b992 <lv_img_buf_get_px_alpha+0x1da>
        const uint8_t opa_table[16] = {0,  17, 34,  51, /*Opacity mapping with bpp = 4*/
 801b916:	4b30      	ldr	r3, [pc, #192]	; (801b9d8 <lv_img_buf_get_px_alpha+0x220>)
 801b918:	f107 040c 	add.w	r4, r7, #12
 801b91c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801b91e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                                       68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255
                                      };

        uint8_t bit = (x & 0x1) * 4;
 801b922:	887b      	ldrh	r3, [r7, #2]
 801b924:	b2db      	uxtb	r3, r3
 801b926:	f003 0301 	and.w	r3, r3, #1
 801b92a:	b2db      	uxtb	r3, r3
 801b92c:	009b      	lsls	r3, r3, #2
 801b92e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
        x           = x >> 1;
 801b932:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801b936:	105b      	asrs	r3, r3, #1
 801b938:	807b      	strh	r3, [r7, #2]

        /* Get the current pixel.
         * dsc->header.w + 1 means rounding up to 8 because the lines are byte aligned
         * so the possible real width are 2 ,4, 6 ...*/
        uint32_t px    = ((dsc->header.w + 1) >> 1) * y + x;
 801b93a:	687b      	ldr	r3, [r7, #4]
 801b93c:	681b      	ldr	r3, [r3, #0]
 801b93e:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801b942:	b29b      	uxth	r3, r3
 801b944:	3301      	adds	r3, #1
 801b946:	105b      	asrs	r3, r3, #1
 801b948:	f9b7 2000 	ldrsh.w	r2, [r7]
 801b94c:	fb03 f202 	mul.w	r2, r3, r2
 801b950:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801b954:	4413      	add	r3, r2
 801b956:	63bb      	str	r3, [r7, #56]	; 0x38
        uint8_t px_opa = (buf_u8[px] & (0xF << (4 - bit))) >> (4 - bit);
 801b958:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801b95a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b95c:	4413      	add	r3, r2
 801b95e:	781b      	ldrb	r3, [r3, #0]
 801b960:	4619      	mov	r1, r3
 801b962:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801b966:	f1c3 0304 	rsb	r3, r3, #4
 801b96a:	220f      	movs	r2, #15
 801b96c:	fa02 f303 	lsl.w	r3, r2, r3
 801b970:	ea01 0203 	and.w	r2, r1, r3
 801b974:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801b978:	f1c3 0304 	rsb	r3, r3, #4
 801b97c:	fa42 f303 	asr.w	r3, r2, r3
 801b980:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        return opa_table[px_opa];
 801b984:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801b988:	3348      	adds	r3, #72	; 0x48
 801b98a:	443b      	add	r3, r7
 801b98c:	f813 3c3c 	ldrb.w	r3, [r3, #-60]
 801b990:	e01a      	b.n	801b9c8 <lv_img_buf_get_px_alpha+0x210>
    }
    else if(dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
 801b992:	687b      	ldr	r3, [r7, #4]
 801b994:	781b      	ldrb	r3, [r3, #0]
 801b996:	f003 031f 	and.w	r3, r3, #31
 801b99a:	b2db      	uxtb	r3, r3
 801b99c:	2b0e      	cmp	r3, #14
 801b99e:	d112      	bne.n	801b9c6 <lv_img_buf_get_px_alpha+0x20e>
        uint32_t px = dsc->header.w * y + x;
 801b9a0:	687b      	ldr	r3, [r7, #4]
 801b9a2:	681b      	ldr	r3, [r3, #0]
 801b9a4:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801b9a8:	b29b      	uxth	r3, r3
 801b9aa:	461a      	mov	r2, r3
 801b9ac:	f9b7 3000 	ldrsh.w	r3, [r7]
 801b9b0:	fb03 f202 	mul.w	r2, r3, r2
 801b9b4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801b9b8:	4413      	add	r3, r2
 801b9ba:	643b      	str	r3, [r7, #64]	; 0x40
        return buf_u8[px];
 801b9bc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801b9be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b9c0:	4413      	add	r3, r2
 801b9c2:	781b      	ldrb	r3, [r3, #0]
 801b9c4:	e000      	b.n	801b9c8 <lv_img_buf_get_px_alpha+0x210>
    }

    return LV_OPA_COVER;
 801b9c6:	23ff      	movs	r3, #255	; 0xff
}
 801b9c8:	4618      	mov	r0, r3
 801b9ca:	3748      	adds	r7, #72	; 0x48
 801b9cc:	46bd      	mov	sp, r7
 801b9ce:	bc90      	pop	{r4, r7}
 801b9d0:	4770      	bx	lr
 801b9d2:	bf00      	nop
 801b9d4:	ffaa5500 	.word	0xffaa5500
 801b9d8:	0802e468 	.word	0x0802e468

0801b9dc <_lv_img_buf_transform_init>:
/**
 * Initialize a descriptor to transform an image
 * @param dsc pointer to an `lv_img_transform_dsc_t` variable whose `cfg` field is initialized
 */
void _lv_img_buf_transform_init(lv_img_transform_dsc_t * dsc)
{
 801b9dc:	b580      	push	{r7, lr}
 801b9de:	b08a      	sub	sp, #40	; 0x28
 801b9e0:	af00      	add	r7, sp, #0
 801b9e2:	6078      	str	r0, [r7, #4]
    dsc->tmp.pivot_x_256 = dsc->cfg.pivot_x * 256;
 801b9e4:	687b      	ldr	r3, [r7, #4]
 801b9e6:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 801b9ea:	021a      	lsls	r2, r3, #8
 801b9ec:	687b      	ldr	r3, [r7, #4]
 801b9ee:	625a      	str	r2, [r3, #36]	; 0x24
    dsc->tmp.pivot_y_256 = dsc->cfg.pivot_y * 256;
 801b9f0:	687b      	ldr	r3, [r7, #4]
 801b9f2:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801b9f6:	021a      	lsls	r2, r3, #8
 801b9f8:	687b      	ldr	r3, [r7, #4]
 801b9fa:	629a      	str	r2, [r3, #40]	; 0x28

    int32_t angle_low = dsc->cfg.angle / 10;
 801b9fc:	687b      	ldr	r3, [r7, #4]
 801b9fe:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 801ba02:	4a74      	ldr	r2, [pc, #464]	; (801bbd4 <_lv_img_buf_transform_init+0x1f8>)
 801ba04:	fb82 1203 	smull	r1, r2, r2, r3
 801ba08:	1092      	asrs	r2, r2, #2
 801ba0a:	17db      	asrs	r3, r3, #31
 801ba0c:	1ad3      	subs	r3, r2, r3
 801ba0e:	b21b      	sxth	r3, r3
 801ba10:	627b      	str	r3, [r7, #36]	; 0x24
    int32_t angle_hight = angle_low + 1;
 801ba12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ba14:	3301      	adds	r3, #1
 801ba16:	623b      	str	r3, [r7, #32]
    int32_t angle_rem = dsc->cfg.angle  - (angle_low * 10);
 801ba18:	687b      	ldr	r3, [r7, #4]
 801ba1a:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 801ba1e:	4619      	mov	r1, r3
 801ba20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ba22:	f06f 0209 	mvn.w	r2, #9
 801ba26:	fb02 f303 	mul.w	r3, r2, r3
 801ba2a:	440b      	add	r3, r1
 801ba2c:	61fb      	str	r3, [r7, #28]

    int32_t s1 = _lv_trigo_sin(-angle_low);
 801ba2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ba30:	b29b      	uxth	r3, r3
 801ba32:	425b      	negs	r3, r3
 801ba34:	b29b      	uxth	r3, r3
 801ba36:	b21b      	sxth	r3, r3
 801ba38:	4618      	mov	r0, r3
 801ba3a:	f005 f807 	bl	8020a4c <_lv_trigo_sin>
 801ba3e:	4603      	mov	r3, r0
 801ba40:	61bb      	str	r3, [r7, #24]
    int32_t s2 = _lv_trigo_sin(-angle_hight);
 801ba42:	6a3b      	ldr	r3, [r7, #32]
 801ba44:	b29b      	uxth	r3, r3
 801ba46:	425b      	negs	r3, r3
 801ba48:	b29b      	uxth	r3, r3
 801ba4a:	b21b      	sxth	r3, r3
 801ba4c:	4618      	mov	r0, r3
 801ba4e:	f004 fffd 	bl	8020a4c <_lv_trigo_sin>
 801ba52:	4603      	mov	r3, r0
 801ba54:	617b      	str	r3, [r7, #20]

    int32_t c1 = _lv_trigo_sin(-angle_low + 90);
 801ba56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ba58:	b29b      	uxth	r3, r3
 801ba5a:	f1c3 035a 	rsb	r3, r3, #90	; 0x5a
 801ba5e:	b29b      	uxth	r3, r3
 801ba60:	b21b      	sxth	r3, r3
 801ba62:	4618      	mov	r0, r3
 801ba64:	f004 fff2 	bl	8020a4c <_lv_trigo_sin>
 801ba68:	4603      	mov	r3, r0
 801ba6a:	613b      	str	r3, [r7, #16]
    int32_t c2 = _lv_trigo_sin(-angle_hight + 90);
 801ba6c:	6a3b      	ldr	r3, [r7, #32]
 801ba6e:	b29b      	uxth	r3, r3
 801ba70:	f1c3 035a 	rsb	r3, r3, #90	; 0x5a
 801ba74:	b29b      	uxth	r3, r3
 801ba76:	b21b      	sxth	r3, r3
 801ba78:	4618      	mov	r0, r3
 801ba7a:	f004 ffe7 	bl	8020a4c <_lv_trigo_sin>
 801ba7e:	4603      	mov	r3, r0
 801ba80:	60fb      	str	r3, [r7, #12]

    dsc->tmp.sinma = (s1 * (10 - angle_rem) + s2 * angle_rem) / 10;
 801ba82:	69fb      	ldr	r3, [r7, #28]
 801ba84:	f1c3 030a 	rsb	r3, r3, #10
 801ba88:	69ba      	ldr	r2, [r7, #24]
 801ba8a:	fb03 f202 	mul.w	r2, r3, r2
 801ba8e:	697b      	ldr	r3, [r7, #20]
 801ba90:	69f9      	ldr	r1, [r7, #28]
 801ba92:	fb01 f303 	mul.w	r3, r1, r3
 801ba96:	4413      	add	r3, r2
 801ba98:	4a4e      	ldr	r2, [pc, #312]	; (801bbd4 <_lv_img_buf_transform_init+0x1f8>)
 801ba9a:	fb82 1203 	smull	r1, r2, r2, r3
 801ba9e:	1092      	asrs	r2, r2, #2
 801baa0:	17db      	asrs	r3, r3, #31
 801baa2:	1ad2      	subs	r2, r2, r3
 801baa4:	687b      	ldr	r3, [r7, #4]
 801baa6:	62da      	str	r2, [r3, #44]	; 0x2c
    dsc->tmp.cosma = (c1 * (10 - angle_rem) + c2 * angle_rem) / 10;
 801baa8:	69fb      	ldr	r3, [r7, #28]
 801baaa:	f1c3 030a 	rsb	r3, r3, #10
 801baae:	693a      	ldr	r2, [r7, #16]
 801bab0:	fb03 f202 	mul.w	r2, r3, r2
 801bab4:	68fb      	ldr	r3, [r7, #12]
 801bab6:	69f9      	ldr	r1, [r7, #28]
 801bab8:	fb01 f303 	mul.w	r3, r1, r3
 801babc:	4413      	add	r3, r2
 801babe:	4a45      	ldr	r2, [pc, #276]	; (801bbd4 <_lv_img_buf_transform_init+0x1f8>)
 801bac0:	fb82 1203 	smull	r1, r2, r2, r3
 801bac4:	1092      	asrs	r2, r2, #2
 801bac6:	17db      	asrs	r3, r3, #31
 801bac8:	1ad2      	subs	r2, r2, r3
 801baca:	687b      	ldr	r3, [r7, #4]
 801bacc:	631a      	str	r2, [r3, #48]	; 0x30

    /*Use smaller value to avoid overflow*/
    dsc->tmp.sinma = dsc->tmp.sinma >> (LV_TRIGO_SHIFT - _LV_TRANSFORM_TRIGO_SHIFT);
 801bace:	687b      	ldr	r3, [r7, #4]
 801bad0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801bad2:	115a      	asrs	r2, r3, #5
 801bad4:	687b      	ldr	r3, [r7, #4]
 801bad6:	62da      	str	r2, [r3, #44]	; 0x2c
    dsc->tmp.cosma = dsc->tmp.cosma >> (LV_TRIGO_SHIFT - _LV_TRANSFORM_TRIGO_SHIFT);
 801bad8:	687b      	ldr	r3, [r7, #4]
 801bada:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801badc:	115a      	asrs	r2, r3, #5
 801bade:	687b      	ldr	r3, [r7, #4]
 801bae0:	631a      	str	r2, [r3, #48]	; 0x30

    dsc->tmp.chroma_keyed = lv_img_cf_is_chroma_keyed(dsc->cfg.cf) ? 1 : 0;
 801bae2:	687b      	ldr	r3, [r7, #4]
 801bae4:	7c9b      	ldrb	r3, [r3, #18]
 801bae6:	4618      	mov	r0, r3
 801bae8:	f7f6 fd30 	bl	801254c <lv_img_cf_is_chroma_keyed>
 801baec:	4603      	mov	r3, r0
 801baee:	4619      	mov	r1, r3
 801baf0:	687a      	ldr	r2, [r7, #4]
 801baf2:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 801baf6:	f361 0300 	bfi	r3, r1, #0, #1
 801bafa:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
    dsc->tmp.has_alpha = lv_img_cf_has_alpha(dsc->cfg.cf) ? 1 : 0;
 801bafe:	687b      	ldr	r3, [r7, #4]
 801bb00:	7c9b      	ldrb	r3, [r3, #18]
 801bb02:	4618      	mov	r0, r3
 801bb04:	f7f6 fd3e 	bl	8012584 <lv_img_cf_has_alpha>
 801bb08:	4603      	mov	r3, r0
 801bb0a:	4619      	mov	r1, r3
 801bb0c:	687a      	ldr	r2, [r7, #4]
 801bb0e:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 801bb12:	f361 0341 	bfi	r3, r1, #1, #1
 801bb16:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
    if(dsc->cfg.cf == LV_IMG_CF_TRUE_COLOR || dsc->cfg.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
 801bb1a:	687b      	ldr	r3, [r7, #4]
 801bb1c:	7c9b      	ldrb	r3, [r3, #18]
 801bb1e:	2b04      	cmp	r3, #4
 801bb20:	d007      	beq.n	801bb32 <_lv_img_buf_transform_init+0x156>
 801bb22:	687b      	ldr	r3, [r7, #4]
 801bb24:	7c9b      	ldrb	r3, [r3, #18]
 801bb26:	2b05      	cmp	r3, #5
 801bb28:	d003      	beq.n	801bb32 <_lv_img_buf_transform_init+0x156>
       dsc->cfg.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
 801bb2a:	687b      	ldr	r3, [r7, #4]
 801bb2c:	7c9b      	ldrb	r3, [r3, #18]
    if(dsc->cfg.cf == LV_IMG_CF_TRUE_COLOR || dsc->cfg.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
 801bb2e:	2b06      	cmp	r3, #6
 801bb30:	d107      	bne.n	801bb42 <_lv_img_buf_transform_init+0x166>
        dsc->tmp.native_color = 1;
 801bb32:	687a      	ldr	r2, [r7, #4]
 801bb34:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 801bb38:	f043 0304 	orr.w	r3, r3, #4
 801bb3c:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
 801bb40:	e006      	b.n	801bb50 <_lv_img_buf_transform_init+0x174>
    }
    else {
        dsc->tmp.native_color = 0;
 801bb42:	687a      	ldr	r2, [r7, #4]
 801bb44:	f892 3034 	ldrb.w	r3, [r2, #52]	; 0x34
 801bb48:	f36f 0382 	bfc	r3, #2, #1
 801bb4c:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
    }

    dsc->tmp.img_dsc.data = dsc->cfg.src;
 801bb50:	687b      	ldr	r3, [r7, #4]
 801bb52:	681a      	ldr	r2, [r3, #0]
 801bb54:	687b      	ldr	r3, [r7, #4]
 801bb56:	621a      	str	r2, [r3, #32]
    dsc->tmp.img_dsc.header.always_zero = 0;
 801bb58:	687a      	ldr	r2, [r7, #4]
 801bb5a:	7e13      	ldrb	r3, [r2, #24]
 801bb5c:	f36f 1347 	bfc	r3, #5, #3
 801bb60:	7613      	strb	r3, [r2, #24]
    dsc->tmp.img_dsc.header.cf = dsc->cfg.cf;
 801bb62:	687b      	ldr	r3, [r7, #4]
 801bb64:	7c9b      	ldrb	r3, [r3, #18]
 801bb66:	f003 031f 	and.w	r3, r3, #31
 801bb6a:	b2d9      	uxtb	r1, r3
 801bb6c:	687a      	ldr	r2, [r7, #4]
 801bb6e:	7e13      	ldrb	r3, [r2, #24]
 801bb70:	f361 0304 	bfi	r3, r1, #0, #5
 801bb74:	7613      	strb	r3, [r2, #24]
    dsc->tmp.img_dsc.header.w = dsc->cfg.src_w;
 801bb76:	687b      	ldr	r3, [r7, #4]
 801bb78:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801bb7c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 801bb80:	b299      	uxth	r1, r3
 801bb82:	687a      	ldr	r2, [r7, #4]
 801bb84:	6993      	ldr	r3, [r2, #24]
 801bb86:	f361 2394 	bfi	r3, r1, #10, #11
 801bb8a:	6193      	str	r3, [r2, #24]
    dsc->tmp.img_dsc.header.h = dsc->cfg.src_h;
 801bb8c:	687b      	ldr	r3, [r7, #4]
 801bb8e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801bb92:	f3c3 030a 	ubfx	r3, r3, #0, #11
 801bb96:	b299      	uxth	r1, r3
 801bb98:	687a      	ldr	r2, [r7, #4]
 801bb9a:	8b53      	ldrh	r3, [r2, #26]
 801bb9c:	f361 134f 	bfi	r3, r1, #5, #11
 801bba0:	8353      	strh	r3, [r2, #26]

    /* The inverse of the zoom will be sued during the transformation
     *  + dsc->cfg.zoom / 2 for rounding*/
    dsc->tmp.zoom_inv = (((256 * 256) << _LV_ZOOM_INV_UPSCALE) + dsc->cfg.zoom / 2) / dsc->cfg.zoom;
 801bba2:	687b      	ldr	r3, [r7, #4]
 801bba4:	89db      	ldrh	r3, [r3, #14]
 801bba6:	085b      	lsrs	r3, r3, #1
 801bba8:	b29b      	uxth	r3, r3
 801bbaa:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
 801bbae:	687a      	ldr	r2, [r7, #4]
 801bbb0:	89d2      	ldrh	r2, [r2, #14]
 801bbb2:	fb93 f3f2 	sdiv	r3, r3, r2
 801bbb6:	461a      	mov	r2, r3
 801bbb8:	687b      	ldr	r3, [r7, #4]
 801bbba:	639a      	str	r2, [r3, #56]	; 0x38

    dsc->res.opa = LV_OPA_COVER;
 801bbbc:	687b      	ldr	r3, [r7, #4]
 801bbbe:	22ff      	movs	r2, #255	; 0xff
 801bbc0:	759a      	strb	r2, [r3, #22]
    dsc->res.color = dsc->cfg.color;
 801bbc2:	687b      	ldr	r3, [r7, #4]
 801bbc4:	687a      	ldr	r2, [r7, #4]
 801bbc6:	8a12      	ldrh	r2, [r2, #16]
 801bbc8:	829a      	strh	r2, [r3, #20]
}
 801bbca:	bf00      	nop
 801bbcc:	3728      	adds	r7, #40	; 0x28
 801bbce:	46bd      	mov	sp, r7
 801bbd0:	bd80      	pop	{r7, pc}
 801bbd2:	bf00      	nop
 801bbd4:	66666667 	.word	0x66666667

0801bbd8 <_lv_img_buf_get_transformed_area>:
 * @param zoom zoom, (256 no zoom)
 * @param pivot x,y pivot coordinates of rotation
 */
void _lv_img_buf_get_transformed_area(lv_area_t * res, lv_coord_t w, lv_coord_t h, int16_t angle, uint16_t zoom,
                                      const lv_point_t * pivot)
{
 801bbd8:	b580      	push	{r7, lr}
 801bbda:	b092      	sub	sp, #72	; 0x48
 801bbdc:	af00      	add	r7, sp, #0
 801bbde:	60f8      	str	r0, [r7, #12]
 801bbe0:	4608      	mov	r0, r1
 801bbe2:	4611      	mov	r1, r2
 801bbe4:	461a      	mov	r2, r3
 801bbe6:	4603      	mov	r3, r0
 801bbe8:	817b      	strh	r3, [r7, #10]
 801bbea:	460b      	mov	r3, r1
 801bbec:	813b      	strh	r3, [r7, #8]
 801bbee:	4613      	mov	r3, r2
 801bbf0:	80fb      	strh	r3, [r7, #6]
#if LV_USE_IMG_TRANSFORM
    if(angle == 0 && zoom == LV_IMG_ZOOM_NONE) {
 801bbf2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801bbf6:	2b00      	cmp	r3, #0
 801bbf8:	d117      	bne.n	801bc2a <_lv_img_buf_get_transformed_area+0x52>
 801bbfa:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 801bbfe:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 801bc02:	d112      	bne.n	801bc2a <_lv_img_buf_get_transformed_area+0x52>
        res->x1 = 0;
 801bc04:	68fb      	ldr	r3, [r7, #12]
 801bc06:	2200      	movs	r2, #0
 801bc08:	801a      	strh	r2, [r3, #0]
        res->y1 = 0;
 801bc0a:	68fb      	ldr	r3, [r7, #12]
 801bc0c:	2200      	movs	r2, #0
 801bc0e:	805a      	strh	r2, [r3, #2]
        res->x2 = w - 1;
 801bc10:	897b      	ldrh	r3, [r7, #10]
 801bc12:	3b01      	subs	r3, #1
 801bc14:	b29b      	uxth	r3, r3
 801bc16:	b21a      	sxth	r2, r3
 801bc18:	68fb      	ldr	r3, [r7, #12]
 801bc1a:	809a      	strh	r2, [r3, #4]
        res->y2 = h - 1;
 801bc1c:	893b      	ldrh	r3, [r7, #8]
 801bc1e:	3b01      	subs	r3, #1
 801bc20:	b29b      	uxth	r3, r3
 801bc22:	b21a      	sxth	r2, r3
 801bc24:	68fb      	ldr	r3, [r7, #12]
 801bc26:	80da      	strh	r2, [r3, #6]
        return;
 801bc28:	e1f6      	b.n	801c018 <_lv_img_buf_get_transformed_area+0x440>
    }


    res->x1 = (((-pivot->x) * zoom) >> 8) - 1;
 801bc2a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bc2c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bc30:	425b      	negs	r3, r3
 801bc32:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 801bc36:	fb02 f303 	mul.w	r3, r2, r3
 801bc3a:	121b      	asrs	r3, r3, #8
 801bc3c:	b29b      	uxth	r3, r3
 801bc3e:	3b01      	subs	r3, #1
 801bc40:	b29b      	uxth	r3, r3
 801bc42:	b21a      	sxth	r2, r3
 801bc44:	68fb      	ldr	r3, [r7, #12]
 801bc46:	801a      	strh	r2, [r3, #0]
    res->y1 = (((-pivot->y) * zoom) >> 8) - 1;
 801bc48:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bc4a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bc4e:	425b      	negs	r3, r3
 801bc50:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 801bc54:	fb02 f303 	mul.w	r3, r2, r3
 801bc58:	121b      	asrs	r3, r3, #8
 801bc5a:	b29b      	uxth	r3, r3
 801bc5c:	3b01      	subs	r3, #1
 801bc5e:	b29b      	uxth	r3, r3
 801bc60:	b21a      	sxth	r2, r3
 801bc62:	68fb      	ldr	r3, [r7, #12]
 801bc64:	805a      	strh	r2, [r3, #2]
    res->x2 = (((w - pivot->x) * zoom) >> 8) + 2;
 801bc66:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801bc6a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801bc6c:	f9b2 2000 	ldrsh.w	r2, [r2]
 801bc70:	1a9b      	subs	r3, r3, r2
 801bc72:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 801bc76:	fb02 f303 	mul.w	r3, r2, r3
 801bc7a:	121b      	asrs	r3, r3, #8
 801bc7c:	b29b      	uxth	r3, r3
 801bc7e:	3302      	adds	r3, #2
 801bc80:	b29b      	uxth	r3, r3
 801bc82:	b21a      	sxth	r2, r3
 801bc84:	68fb      	ldr	r3, [r7, #12]
 801bc86:	809a      	strh	r2, [r3, #4]
    res->y2 = (((h - pivot->y) * zoom) >> 8) + 2;
 801bc88:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 801bc8c:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 801bc8e:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 801bc92:	1a9b      	subs	r3, r3, r2
 801bc94:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 801bc98:	fb02 f303 	mul.w	r3, r2, r3
 801bc9c:	121b      	asrs	r3, r3, #8
 801bc9e:	b29b      	uxth	r3, r3
 801bca0:	3302      	adds	r3, #2
 801bca2:	b29b      	uxth	r3, r3
 801bca4:	b21a      	sxth	r2, r3
 801bca6:	68fb      	ldr	r3, [r7, #12]
 801bca8:	80da      	strh	r2, [r3, #6]

    if(angle == 0) {
 801bcaa:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801bcae:	2b00      	cmp	r3, #0
 801bcb0:	d134      	bne.n	801bd1c <_lv_img_buf_get_transformed_area+0x144>
        res->x1 += pivot->x;
 801bcb2:	68fb      	ldr	r3, [r7, #12]
 801bcb4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bcb8:	b29a      	uxth	r2, r3
 801bcba:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bcbc:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bcc0:	b29b      	uxth	r3, r3
 801bcc2:	4413      	add	r3, r2
 801bcc4:	b29b      	uxth	r3, r3
 801bcc6:	b21a      	sxth	r2, r3
 801bcc8:	68fb      	ldr	r3, [r7, #12]
 801bcca:	801a      	strh	r2, [r3, #0]
        res->y1 += pivot->y;
 801bccc:	68fb      	ldr	r3, [r7, #12]
 801bcce:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bcd2:	b29a      	uxth	r2, r3
 801bcd4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bcd6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bcda:	b29b      	uxth	r3, r3
 801bcdc:	4413      	add	r3, r2
 801bcde:	b29b      	uxth	r3, r3
 801bce0:	b21a      	sxth	r2, r3
 801bce2:	68fb      	ldr	r3, [r7, #12]
 801bce4:	805a      	strh	r2, [r3, #2]
        res->x2 += pivot->x;
 801bce6:	68fb      	ldr	r3, [r7, #12]
 801bce8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801bcec:	b29a      	uxth	r2, r3
 801bcee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bcf0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bcf4:	b29b      	uxth	r3, r3
 801bcf6:	4413      	add	r3, r2
 801bcf8:	b29b      	uxth	r3, r3
 801bcfa:	b21a      	sxth	r2, r3
 801bcfc:	68fb      	ldr	r3, [r7, #12]
 801bcfe:	809a      	strh	r2, [r3, #4]
        res->y2 += pivot->y;
 801bd00:	68fb      	ldr	r3, [r7, #12]
 801bd02:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801bd06:	b29a      	uxth	r2, r3
 801bd08:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bd0a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bd0e:	b29b      	uxth	r3, r3
 801bd10:	4413      	add	r3, r2
 801bd12:	b29b      	uxth	r3, r3
 801bd14:	b21a      	sxth	r2, r3
 801bd16:	68fb      	ldr	r3, [r7, #12]
 801bd18:	80da      	strh	r2, [r3, #6]
        return;
 801bd1a:	e17d      	b.n	801c018 <_lv_img_buf_get_transformed_area+0x440>
    }

    int32_t angle_low = angle / 10;
 801bd1c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801bd20:	4ab6      	ldr	r2, [pc, #728]	; (801bffc <_lv_img_buf_get_transformed_area+0x424>)
 801bd22:	fb82 1203 	smull	r1, r2, r2, r3
 801bd26:	1092      	asrs	r2, r2, #2
 801bd28:	17db      	asrs	r3, r3, #31
 801bd2a:	1ad3      	subs	r3, r2, r3
 801bd2c:	b21b      	sxth	r3, r3
 801bd2e:	647b      	str	r3, [r7, #68]	; 0x44
    int32_t angle_hight = angle_low + 1;
 801bd30:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bd32:	3301      	adds	r3, #1
 801bd34:	643b      	str	r3, [r7, #64]	; 0x40
    int32_t angle_rem = angle  - (angle_low * 10);
 801bd36:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801bd3a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bd3c:	f06f 0109 	mvn.w	r1, #9
 801bd40:	fb01 f303 	mul.w	r3, r1, r3
 801bd44:	4413      	add	r3, r2
 801bd46:	63fb      	str	r3, [r7, #60]	; 0x3c

    int32_t s1 = _lv_trigo_sin(angle_low);
 801bd48:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bd4a:	b21b      	sxth	r3, r3
 801bd4c:	4618      	mov	r0, r3
 801bd4e:	f004 fe7d 	bl	8020a4c <_lv_trigo_sin>
 801bd52:	4603      	mov	r3, r0
 801bd54:	63bb      	str	r3, [r7, #56]	; 0x38
    int32_t s2 = _lv_trigo_sin(angle_hight);
 801bd56:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bd58:	b21b      	sxth	r3, r3
 801bd5a:	4618      	mov	r0, r3
 801bd5c:	f004 fe76 	bl	8020a4c <_lv_trigo_sin>
 801bd60:	4603      	mov	r3, r0
 801bd62:	637b      	str	r3, [r7, #52]	; 0x34

    int32_t c1 = _lv_trigo_sin(angle_low + 90);
 801bd64:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801bd66:	b29b      	uxth	r3, r3
 801bd68:	335a      	adds	r3, #90	; 0x5a
 801bd6a:	b29b      	uxth	r3, r3
 801bd6c:	b21b      	sxth	r3, r3
 801bd6e:	4618      	mov	r0, r3
 801bd70:	f004 fe6c 	bl	8020a4c <_lv_trigo_sin>
 801bd74:	4603      	mov	r3, r0
 801bd76:	633b      	str	r3, [r7, #48]	; 0x30
    int32_t c2 = _lv_trigo_sin(angle_hight + 90);
 801bd78:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801bd7a:	b29b      	uxth	r3, r3
 801bd7c:	335a      	adds	r3, #90	; 0x5a
 801bd7e:	b29b      	uxth	r3, r3
 801bd80:	b21b      	sxth	r3, r3
 801bd82:	4618      	mov	r0, r3
 801bd84:	f004 fe62 	bl	8020a4c <_lv_trigo_sin>
 801bd88:	4603      	mov	r3, r0
 801bd8a:	62fb      	str	r3, [r7, #44]	; 0x2c

    int32_t sinma = (s1 * (10 - angle_rem) + s2 * angle_rem) / 10;
 801bd8c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bd8e:	f1c3 030a 	rsb	r3, r3, #10
 801bd92:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801bd94:	fb03 f202 	mul.w	r2, r3, r2
 801bd98:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801bd9a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801bd9c:	fb01 f303 	mul.w	r3, r1, r3
 801bda0:	4413      	add	r3, r2
 801bda2:	4a96      	ldr	r2, [pc, #600]	; (801bffc <_lv_img_buf_get_transformed_area+0x424>)
 801bda4:	fb82 1203 	smull	r1, r2, r2, r3
 801bda8:	1092      	asrs	r2, r2, #2
 801bdaa:	17db      	asrs	r3, r3, #31
 801bdac:	1ad3      	subs	r3, r2, r3
 801bdae:	62bb      	str	r3, [r7, #40]	; 0x28
    int32_t cosma = (c1 * (10 - angle_rem) + c2 * angle_rem) / 10;
 801bdb0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801bdb2:	f1c3 030a 	rsb	r3, r3, #10
 801bdb6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801bdb8:	fb03 f202 	mul.w	r2, r3, r2
 801bdbc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801bdbe:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801bdc0:	fb01 f303 	mul.w	r3, r1, r3
 801bdc4:	4413      	add	r3, r2
 801bdc6:	4a8d      	ldr	r2, [pc, #564]	; (801bffc <_lv_img_buf_get_transformed_area+0x424>)
 801bdc8:	fb82 1203 	smull	r1, r2, r2, r3
 801bdcc:	1092      	asrs	r2, r2, #2
 801bdce:	17db      	asrs	r3, r3, #31
 801bdd0:	1ad3      	subs	r3, r2, r3
 801bdd2:	627b      	str	r3, [r7, #36]	; 0x24

    /*Use smaller value to avoid overflow*/
    sinma = sinma >> (LV_TRIGO_SHIFT - _LV_TRANSFORM_TRIGO_SHIFT);
 801bdd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bdd6:	115b      	asrs	r3, r3, #5
 801bdd8:	62bb      	str	r3, [r7, #40]	; 0x28
    cosma = cosma >> (LV_TRIGO_SHIFT - _LV_TRANSFORM_TRIGO_SHIFT);
 801bdda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801bddc:	115b      	asrs	r3, r3, #5
 801bdde:	627b      	str	r3, [r7, #36]	; 0x24
    lv_point_t rb;

    lv_coord_t xt;
    lv_coord_t yt;

    xt = res->x1;
 801bde0:	68fb      	ldr	r3, [r7, #12]
 801bde2:	881b      	ldrh	r3, [r3, #0]
 801bde4:	847b      	strh	r3, [r7, #34]	; 0x22
    yt = res->y1;
 801bde6:	68fb      	ldr	r3, [r7, #12]
 801bde8:	885b      	ldrh	r3, [r3, #2]
 801bdea:	843b      	strh	r3, [r7, #32]
    lt.x = ((cosma * xt - sinma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->x;
 801bdec:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801bdf0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801bdf2:	fb03 f202 	mul.w	r2, r3, r2
 801bdf6:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801bdfa:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801bdfc:	fb01 f303 	mul.w	r3, r1, r3
 801be00:	1ad3      	subs	r3, r2, r3
 801be02:	129b      	asrs	r3, r3, #10
 801be04:	b29a      	uxth	r2, r3
 801be06:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801be08:	f9b3 3000 	ldrsh.w	r3, [r3]
 801be0c:	b29b      	uxth	r3, r3
 801be0e:	4413      	add	r3, r2
 801be10:	b29b      	uxth	r3, r3
 801be12:	b21b      	sxth	r3, r3
 801be14:	83bb      	strh	r3, [r7, #28]
    lt.y = ((sinma * xt + cosma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->y;
 801be16:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801be1a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801be1c:	fb03 f202 	mul.w	r2, r3, r2
 801be20:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801be24:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801be26:	fb01 f303 	mul.w	r3, r1, r3
 801be2a:	4413      	add	r3, r2
 801be2c:	129b      	asrs	r3, r3, #10
 801be2e:	b29a      	uxth	r2, r3
 801be30:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801be32:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801be36:	b29b      	uxth	r3, r3
 801be38:	4413      	add	r3, r2
 801be3a:	b29b      	uxth	r3, r3
 801be3c:	b21b      	sxth	r3, r3
 801be3e:	83fb      	strh	r3, [r7, #30]

    xt = res->x2;
 801be40:	68fb      	ldr	r3, [r7, #12]
 801be42:	889b      	ldrh	r3, [r3, #4]
 801be44:	847b      	strh	r3, [r7, #34]	; 0x22
    yt = res->y1;
 801be46:	68fb      	ldr	r3, [r7, #12]
 801be48:	885b      	ldrh	r3, [r3, #2]
 801be4a:	843b      	strh	r3, [r7, #32]
    rt.x = ((cosma * xt - sinma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->x;
 801be4c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801be50:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801be52:	fb03 f202 	mul.w	r2, r3, r2
 801be56:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801be5a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801be5c:	fb01 f303 	mul.w	r3, r1, r3
 801be60:	1ad3      	subs	r3, r2, r3
 801be62:	129b      	asrs	r3, r3, #10
 801be64:	b29a      	uxth	r2, r3
 801be66:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801be68:	f9b3 3000 	ldrsh.w	r3, [r3]
 801be6c:	b29b      	uxth	r3, r3
 801be6e:	4413      	add	r3, r2
 801be70:	b29b      	uxth	r3, r3
 801be72:	b21b      	sxth	r3, r3
 801be74:	833b      	strh	r3, [r7, #24]
    rt.y = ((sinma * xt + cosma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->y;
 801be76:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801be7a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801be7c:	fb03 f202 	mul.w	r2, r3, r2
 801be80:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801be84:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801be86:	fb01 f303 	mul.w	r3, r1, r3
 801be8a:	4413      	add	r3, r2
 801be8c:	129b      	asrs	r3, r3, #10
 801be8e:	b29a      	uxth	r2, r3
 801be90:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801be92:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801be96:	b29b      	uxth	r3, r3
 801be98:	4413      	add	r3, r2
 801be9a:	b29b      	uxth	r3, r3
 801be9c:	b21b      	sxth	r3, r3
 801be9e:	837b      	strh	r3, [r7, #26]

    xt = res->x1;
 801bea0:	68fb      	ldr	r3, [r7, #12]
 801bea2:	881b      	ldrh	r3, [r3, #0]
 801bea4:	847b      	strh	r3, [r7, #34]	; 0x22
    yt = res->y2;
 801bea6:	68fb      	ldr	r3, [r7, #12]
 801bea8:	88db      	ldrh	r3, [r3, #6]
 801beaa:	843b      	strh	r3, [r7, #32]
    lb.x = ((cosma * xt - sinma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->x;
 801beac:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801beb0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801beb2:	fb03 f202 	mul.w	r2, r3, r2
 801beb6:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801beba:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801bebc:	fb01 f303 	mul.w	r3, r1, r3
 801bec0:	1ad3      	subs	r3, r2, r3
 801bec2:	129b      	asrs	r3, r3, #10
 801bec4:	b29a      	uxth	r2, r3
 801bec6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bec8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801becc:	b29b      	uxth	r3, r3
 801bece:	4413      	add	r3, r2
 801bed0:	b29b      	uxth	r3, r3
 801bed2:	b21b      	sxth	r3, r3
 801bed4:	82bb      	strh	r3, [r7, #20]
    lb.y = ((sinma * xt + cosma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->y;
 801bed6:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801beda:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801bedc:	fb03 f202 	mul.w	r2, r3, r2
 801bee0:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801bee4:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801bee6:	fb01 f303 	mul.w	r3, r1, r3
 801beea:	4413      	add	r3, r2
 801beec:	129b      	asrs	r3, r3, #10
 801beee:	b29a      	uxth	r2, r3
 801bef0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bef2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bef6:	b29b      	uxth	r3, r3
 801bef8:	4413      	add	r3, r2
 801befa:	b29b      	uxth	r3, r3
 801befc:	b21b      	sxth	r3, r3
 801befe:	82fb      	strh	r3, [r7, #22]

    xt = res->x2;
 801bf00:	68fb      	ldr	r3, [r7, #12]
 801bf02:	889b      	ldrh	r3, [r3, #4]
 801bf04:	847b      	strh	r3, [r7, #34]	; 0x22
    yt = res->y2;
 801bf06:	68fb      	ldr	r3, [r7, #12]
 801bf08:	88db      	ldrh	r3, [r3, #6]
 801bf0a:	843b      	strh	r3, [r7, #32]
    rb.x = ((cosma * xt - sinma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->x;
 801bf0c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801bf10:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801bf12:	fb03 f202 	mul.w	r2, r3, r2
 801bf16:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801bf1a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 801bf1c:	fb01 f303 	mul.w	r3, r1, r3
 801bf20:	1ad3      	subs	r3, r2, r3
 801bf22:	129b      	asrs	r3, r3, #10
 801bf24:	b29a      	uxth	r2, r3
 801bf26:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bf28:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bf2c:	b29b      	uxth	r3, r3
 801bf2e:	4413      	add	r3, r2
 801bf30:	b29b      	uxth	r3, r3
 801bf32:	b21b      	sxth	r3, r3
 801bf34:	823b      	strh	r3, [r7, #16]
    rb.y = ((sinma * xt + cosma * yt) >> _LV_TRANSFORM_TRIGO_SHIFT) + pivot->y;
 801bf36:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801bf3a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801bf3c:	fb03 f202 	mul.w	r2, r3, r2
 801bf40:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801bf44:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801bf46:	fb01 f303 	mul.w	r3, r1, r3
 801bf4a:	4413      	add	r3, r2
 801bf4c:	129b      	asrs	r3, r3, #10
 801bf4e:	b29a      	uxth	r2, r3
 801bf50:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801bf52:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bf56:	b29b      	uxth	r3, r3
 801bf58:	4413      	add	r3, r2
 801bf5a:	b29b      	uxth	r3, r3
 801bf5c:	b21b      	sxth	r3, r3
 801bf5e:	827b      	strh	r3, [r7, #18]

    res->x1 = LV_MATH_MIN4(lb.x, lt.x, rb.x, rt.x);
 801bf60:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 801bf64:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801bf68:	4293      	cmp	r3, r2
 801bf6a:	bfa8      	it	ge
 801bf6c:	4613      	movge	r3, r2
 801bf6e:	b21a      	sxth	r2, r3
 801bf70:	f9b7 101c 	ldrsh.w	r1, [r7, #28]
 801bf74:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801bf78:	428b      	cmp	r3, r1
 801bf7a:	bfa8      	it	ge
 801bf7c:	460b      	movge	r3, r1
 801bf7e:	b21b      	sxth	r3, r3
 801bf80:	4293      	cmp	r3, r2
 801bf82:	bfa8      	it	ge
 801bf84:	4613      	movge	r3, r2
 801bf86:	b21a      	sxth	r2, r3
 801bf88:	68fb      	ldr	r3, [r7, #12]
 801bf8a:	801a      	strh	r2, [r3, #0]
    res->x2 = LV_MATH_MAX4(lb.x, lt.x, rb.x, rt.x);
 801bf8c:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 801bf90:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801bf94:	4293      	cmp	r3, r2
 801bf96:	bfb8      	it	lt
 801bf98:	4613      	movlt	r3, r2
 801bf9a:	b21a      	sxth	r2, r3
 801bf9c:	f9b7 101c 	ldrsh.w	r1, [r7, #28]
 801bfa0:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801bfa4:	428b      	cmp	r3, r1
 801bfa6:	bfb8      	it	lt
 801bfa8:	460b      	movlt	r3, r1
 801bfaa:	b21b      	sxth	r3, r3
 801bfac:	4293      	cmp	r3, r2
 801bfae:	bfb8      	it	lt
 801bfb0:	4613      	movlt	r3, r2
 801bfb2:	b21a      	sxth	r2, r3
 801bfb4:	68fb      	ldr	r3, [r7, #12]
 801bfb6:	809a      	strh	r2, [r3, #4]
    res->y1 = LV_MATH_MIN4(lb.y, lt.y, rb.y, rt.y);
 801bfb8:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 801bfbc:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801bfc0:	4293      	cmp	r3, r2
 801bfc2:	bfa8      	it	ge
 801bfc4:	4613      	movge	r3, r2
 801bfc6:	b21a      	sxth	r2, r3
 801bfc8:	f9b7 101e 	ldrsh.w	r1, [r7, #30]
 801bfcc:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801bfd0:	428b      	cmp	r3, r1
 801bfd2:	bfa8      	it	ge
 801bfd4:	460b      	movge	r3, r1
 801bfd6:	b21b      	sxth	r3, r3
 801bfd8:	4293      	cmp	r3, r2
 801bfda:	bfa8      	it	ge
 801bfdc:	4613      	movge	r3, r2
 801bfde:	b21a      	sxth	r2, r3
 801bfe0:	68fb      	ldr	r3, [r7, #12]
 801bfe2:	805a      	strh	r2, [r3, #2]
    res->y2 = LV_MATH_MAX4(lb.y, lt.y, rb.y, rt.y);
 801bfe4:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 801bfe8:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801bfec:	4293      	cmp	r3, r2
 801bfee:	bfb8      	it	lt
 801bff0:	4613      	movlt	r3, r2
 801bff2:	b21a      	sxth	r2, r3
 801bff4:	f9b7 101e 	ldrsh.w	r1, [r7, #30]
 801bff8:	e002      	b.n	801c000 <_lv_img_buf_get_transformed_area+0x428>
 801bffa:	bf00      	nop
 801bffc:	66666667 	.word	0x66666667
 801c000:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801c004:	428b      	cmp	r3, r1
 801c006:	bfb8      	it	lt
 801c008:	460b      	movlt	r3, r1
 801c00a:	b21b      	sxth	r3, r3
 801c00c:	4293      	cmp	r3, r2
 801c00e:	bfb8      	it	lt
 801c010:	4613      	movlt	r3, r2
 801c012:	b21a      	sxth	r2, r3
 801c014:	68fb      	ldr	r3, [r7, #12]
 801c016:	80da      	strh	r2, [r3, #6]
    res->x1 = 0;
    res->y1 = 0;
    res->x2 = w - 1;
    res->y2 = h - 1;
#endif
}
 801c018:	3748      	adds	r7, #72	; 0x48
 801c01a:	46bd      	mov	sp, r7
 801c01c:	bd80      	pop	{r7, pc}
 801c01e:	bf00      	nop

0801c020 <_lv_img_buf_transform_anti_alias>:
/**
 * Continue transformation by taking the neighbors into account
 * @param dsc pointer to the transformation descriptor
 */
bool _lv_img_buf_transform_anti_alias(lv_img_transform_dsc_t * dsc)
{
 801c020:	b590      	push	{r4, r7, lr}
 801c022:	b093      	sub	sp, #76	; 0x4c
 801c024:	af00      	add	r7, sp, #0
 801c026:	6078      	str	r0, [r7, #4]
    const uint8_t * src_u8 = dsc->cfg.src;
 801c028:	687b      	ldr	r3, [r7, #4]
 801c02a:	681b      	ldr	r3, [r3, #0]
 801c02c:	633b      	str	r3, [r7, #48]	; 0x30

    /*Get the fractional part of the source pixel*/
    int xs_fract = dsc->tmp.xs & 0xff;
 801c02e:	687b      	ldr	r3, [r7, #4]
 801c030:	f9b3 303c 	ldrsh.w	r3, [r3, #60]	; 0x3c
 801c034:	b29b      	uxth	r3, r3
 801c036:	b2db      	uxtb	r3, r3
 801c038:	62fb      	str	r3, [r7, #44]	; 0x2c
    int ys_fract = dsc->tmp.ys & 0xff;
 801c03a:	687b      	ldr	r3, [r7, #4]
 801c03c:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 801c040:	b29b      	uxth	r3, r3
 801c042:	b2db      	uxtb	r3, r3
 801c044:	62bb      	str	r3, [r7, #40]	; 0x28
    int32_t xn;      /*x neighbor*/
    lv_opa_t xr; /*x mix ratio*/

    if(xs_fract < 0x70) {
 801c046:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c048:	2b6f      	cmp	r3, #111	; 0x6f
 801c04a:	dc12      	bgt.n	801c072 <_lv_img_buf_transform_anti_alias+0x52>
        xn = - 1;
 801c04c:	f04f 33ff 	mov.w	r3, #4294967295
 801c050:	647b      	str	r3, [r7, #68]	; 0x44
        if(dsc->tmp.xs_int + xn < 0) xn = 0;
 801c052:	687b      	ldr	r3, [r7, #4]
 801c054:	f9b3 3040 	ldrsh.w	r3, [r3, #64]	; 0x40
 801c058:	461a      	mov	r2, r3
 801c05a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c05c:	4413      	add	r3, r2
 801c05e:	2b00      	cmp	r3, #0
 801c060:	da01      	bge.n	801c066 <_lv_img_buf_transform_anti_alias+0x46>
 801c062:	2300      	movs	r3, #0
 801c064:	647b      	str	r3, [r7, #68]	; 0x44
        xr = xs_fract + 0x80;
 801c066:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c068:	b2db      	uxtb	r3, r3
 801c06a:	3b80      	subs	r3, #128	; 0x80
 801c06c:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 801c070:	e01d      	b.n	801c0ae <_lv_img_buf_transform_anti_alias+0x8e>
    }
    else if(xs_fract > 0x90) {
 801c072:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c074:	2b90      	cmp	r3, #144	; 0x90
 801c076:	dd15      	ble.n	801c0a4 <_lv_img_buf_transform_anti_alias+0x84>
        xn =  1;
 801c078:	2301      	movs	r3, #1
 801c07a:	647b      	str	r3, [r7, #68]	; 0x44
        if(dsc->tmp.xs_int + xn >= dsc->cfg.src_w) xn = 0;
 801c07c:	687b      	ldr	r3, [r7, #4]
 801c07e:	f9b3 3040 	ldrsh.w	r3, [r3, #64]	; 0x40
 801c082:	461a      	mov	r2, r3
 801c084:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c086:	4413      	add	r3, r2
 801c088:	687a      	ldr	r2, [r7, #4]
 801c08a:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
 801c08e:	4293      	cmp	r3, r2
 801c090:	db01      	blt.n	801c096 <_lv_img_buf_transform_anti_alias+0x76>
 801c092:	2300      	movs	r3, #0
 801c094:	647b      	str	r3, [r7, #68]	; 0x44
        xr = (0xFF - xs_fract) + 0x80;
 801c096:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c098:	b2db      	uxtb	r3, r3
 801c09a:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
 801c09e:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
 801c0a2:	e004      	b.n	801c0ae <_lv_img_buf_transform_anti_alias+0x8e>
    }
    else {
        xn = 0;
 801c0a4:	2300      	movs	r3, #0
 801c0a6:	647b      	str	r3, [r7, #68]	; 0x44
        xr = 0xFF;
 801c0a8:	23ff      	movs	r3, #255	; 0xff
 801c0aa:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43
    }

    int32_t yn;      /*x neighbor*/
    lv_opa_t yr; /*x mix ratio*/

    if(ys_fract < 0x70) {
 801c0ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c0b0:	2b6f      	cmp	r3, #111	; 0x6f
 801c0b2:	dc12      	bgt.n	801c0da <_lv_img_buf_transform_anti_alias+0xba>
        yn = - 1;
 801c0b4:	f04f 33ff 	mov.w	r3, #4294967295
 801c0b8:	63fb      	str	r3, [r7, #60]	; 0x3c
        if(dsc->tmp.ys_int + yn < 0) yn = 0;
 801c0ba:	687b      	ldr	r3, [r7, #4]
 801c0bc:	f9b3 3042 	ldrsh.w	r3, [r3, #66]	; 0x42
 801c0c0:	461a      	mov	r2, r3
 801c0c2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c0c4:	4413      	add	r3, r2
 801c0c6:	2b00      	cmp	r3, #0
 801c0c8:	da01      	bge.n	801c0ce <_lv_img_buf_transform_anti_alias+0xae>
 801c0ca:	2300      	movs	r3, #0
 801c0cc:	63fb      	str	r3, [r7, #60]	; 0x3c

        yr = ys_fract + 0x80;
 801c0ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c0d0:	b2db      	uxtb	r3, r3
 801c0d2:	3b80      	subs	r3, #128	; 0x80
 801c0d4:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
 801c0d8:	e01d      	b.n	801c116 <_lv_img_buf_transform_anti_alias+0xf6>
    }
    else if(ys_fract > 0x90) {
 801c0da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c0dc:	2b90      	cmp	r3, #144	; 0x90
 801c0de:	dd15      	ble.n	801c10c <_lv_img_buf_transform_anti_alias+0xec>
        yn =  1;
 801c0e0:	2301      	movs	r3, #1
 801c0e2:	63fb      	str	r3, [r7, #60]	; 0x3c
        if(dsc->tmp.ys_int + yn >= dsc->cfg.src_h) yn = 0;
 801c0e4:	687b      	ldr	r3, [r7, #4]
 801c0e6:	f9b3 3042 	ldrsh.w	r3, [r3, #66]	; 0x42
 801c0ea:	461a      	mov	r2, r3
 801c0ec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c0ee:	4413      	add	r3, r2
 801c0f0:	687a      	ldr	r2, [r7, #4]
 801c0f2:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 801c0f6:	4293      	cmp	r3, r2
 801c0f8:	db01      	blt.n	801c0fe <_lv_img_buf_transform_anti_alias+0xde>
 801c0fa:	2300      	movs	r3, #0
 801c0fc:	63fb      	str	r3, [r7, #60]	; 0x3c

        yr = (0xFF - ys_fract) + 0x80;
 801c0fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801c100:	b2db      	uxtb	r3, r3
 801c102:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
 801c106:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
 801c10a:	e004      	b.n	801c116 <_lv_img_buf_transform_anti_alias+0xf6>
    }
    else {
        yn = 0;
 801c10c:	2300      	movs	r3, #0
 801c10e:	63fb      	str	r3, [r7, #60]	; 0x3c
        yr = 0xFF;
 801c110:	23ff      	movs	r3, #255	; 0xff
 801c112:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
    }

    lv_color_t c00 = dsc->res.color;
 801c116:	687b      	ldr	r3, [r7, #4]
 801c118:	8a9b      	ldrh	r3, [r3, #20]
 801c11a:	843b      	strh	r3, [r7, #32]
    lv_color_t c01;
    lv_color_t c10;
    lv_color_t c11;

    lv_opa_t a00 = dsc->res.opa;
 801c11c:	687b      	ldr	r3, [r7, #4]
 801c11e:	7d9b      	ldrb	r3, [r3, #22]
 801c120:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    lv_opa_t a10 = 0;
 801c124:	2300      	movs	r3, #0
 801c126:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a
    lv_opa_t a01 = 0;
 801c12a:	2300      	movs	r3, #0
 801c12c:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
    lv_opa_t a11 = 0;
 801c130:	2300      	movs	r3, #0
 801c132:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38

    if(dsc->tmp.native_color) {
 801c136:	687b      	ldr	r3, [r7, #4]
 801c138:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801c13c:	f003 0304 	and.w	r3, r3, #4
 801c140:	b2db      	uxtb	r3, r3
 801c142:	2b00      	cmp	r3, #0
 801c144:	f000 80a2 	beq.w	801c28c <_lv_img_buf_transform_anti_alias+0x26c>
        _lv_memcpy_small(&c01, &src_u8[dsc->tmp.pxi + dsc->tmp.px_size * xn], sizeof(lv_color_t));
 801c148:	687b      	ldr	r3, [r7, #4]
 801c14a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801c14c:	687a      	ldr	r2, [r7, #4]
 801c14e:	f892 2048 	ldrb.w	r2, [r2, #72]	; 0x48
 801c152:	4611      	mov	r1, r2
 801c154:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801c156:	fb01 f202 	mul.w	r2, r1, r2
 801c15a:	4413      	add	r3, r2
 801c15c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801c15e:	18d1      	adds	r1, r2, r3
 801c160:	f107 031c 	add.w	r3, r7, #28
 801c164:	2202      	movs	r2, #2
 801c166:	4618      	mov	r0, r3
 801c168:	f7ff f9b8 	bl	801b4dc <_lv_memcpy_small>
        _lv_memcpy_small(&c10, &src_u8[dsc->tmp.pxi + dsc->cfg.src_w * dsc->tmp.px_size * yn], sizeof(lv_color_t));
 801c16c:	687b      	ldr	r3, [r7, #4]
 801c16e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801c170:	687a      	ldr	r2, [r7, #4]
 801c172:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
 801c176:	4611      	mov	r1, r2
 801c178:	687a      	ldr	r2, [r7, #4]
 801c17a:	f892 2048 	ldrb.w	r2, [r2, #72]	; 0x48
 801c17e:	fb01 f202 	mul.w	r2, r1, r2
 801c182:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801c184:	fb01 f202 	mul.w	r2, r1, r2
 801c188:	4413      	add	r3, r2
 801c18a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801c18c:	18d1      	adds	r1, r2, r3
 801c18e:	f107 0318 	add.w	r3, r7, #24
 801c192:	2202      	movs	r2, #2
 801c194:	4618      	mov	r0, r3
 801c196:	f7ff f9a1 	bl	801b4dc <_lv_memcpy_small>
        _lv_memcpy_small(&c11, &src_u8[dsc->tmp.pxi + dsc->cfg.src_w * dsc->tmp.px_size * yn + dsc->tmp.px_size * xn],
 801c19a:	687b      	ldr	r3, [r7, #4]
 801c19c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801c19e:	687b      	ldr	r3, [r7, #4]
 801c1a0:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 801c1a4:	4619      	mov	r1, r3
 801c1a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c1a8:	fb01 f303 	mul.w	r3, r1, r3
 801c1ac:	4618      	mov	r0, r3
 801c1ae:	687b      	ldr	r3, [r7, #4]
 801c1b0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801c1b4:	4619      	mov	r1, r3
 801c1b6:	687b      	ldr	r3, [r7, #4]
 801c1b8:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 801c1bc:	fb01 f303 	mul.w	r3, r1, r3
 801c1c0:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801c1c2:	fb01 f303 	mul.w	r3, r1, r3
 801c1c6:	4403      	add	r3, r0
 801c1c8:	4413      	add	r3, r2
 801c1ca:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801c1cc:	18d1      	adds	r1, r2, r3
 801c1ce:	f107 0314 	add.w	r3, r7, #20
 801c1d2:	2202      	movs	r2, #2
 801c1d4:	4618      	mov	r0, r3
 801c1d6:	f7ff f981 	bl	801b4dc <_lv_memcpy_small>
                         sizeof(lv_color_t));
        if(dsc->tmp.has_alpha) {
 801c1da:	687b      	ldr	r3, [r7, #4]
 801c1dc:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801c1e0:	f003 0302 	and.w	r3, r3, #2
 801c1e4:	b2db      	uxtb	r3, r3
 801c1e6:	2b00      	cmp	r3, #0
 801c1e8:	f000 80e2 	beq.w	801c3b0 <_lv_img_buf_transform_anti_alias+0x390>
            a10 = src_u8[dsc->tmp.pxi + dsc->tmp.px_size * xn + dsc->tmp.px_size - 1];
 801c1ec:	687b      	ldr	r3, [r7, #4]
 801c1ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801c1f0:	687a      	ldr	r2, [r7, #4]
 801c1f2:	f892 2048 	ldrb.w	r2, [r2, #72]	; 0x48
 801c1f6:	4611      	mov	r1, r2
 801c1f8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801c1fa:	fb01 f202 	mul.w	r2, r1, r2
 801c1fe:	4413      	add	r3, r2
 801c200:	687a      	ldr	r2, [r7, #4]
 801c202:	f892 2048 	ldrb.w	r2, [r2, #72]	; 0x48
 801c206:	4413      	add	r3, r2
 801c208:	3b01      	subs	r3, #1
 801c20a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801c20c:	4413      	add	r3, r2
 801c20e:	781b      	ldrb	r3, [r3, #0]
 801c210:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a
            a01 = src_u8[dsc->tmp.pxi + dsc->cfg.src_w * dsc->tmp.px_size * yn + dsc->tmp.px_size - 1];
 801c214:	687b      	ldr	r3, [r7, #4]
 801c216:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801c218:	687a      	ldr	r2, [r7, #4]
 801c21a:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
 801c21e:	4611      	mov	r1, r2
 801c220:	687a      	ldr	r2, [r7, #4]
 801c222:	f892 2048 	ldrb.w	r2, [r2, #72]	; 0x48
 801c226:	fb01 f202 	mul.w	r2, r1, r2
 801c22a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801c22c:	fb01 f202 	mul.w	r2, r1, r2
 801c230:	4413      	add	r3, r2
 801c232:	687a      	ldr	r2, [r7, #4]
 801c234:	f892 2048 	ldrb.w	r2, [r2, #72]	; 0x48
 801c238:	4413      	add	r3, r2
 801c23a:	3b01      	subs	r3, #1
 801c23c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801c23e:	4413      	add	r3, r2
 801c240:	781b      	ldrb	r3, [r3, #0]
 801c242:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
            a11 = src_u8[dsc->tmp.pxi + dsc->cfg.src_w * dsc->tmp.px_size * yn + dsc->tmp.px_size * xn + dsc->tmp.px_size - 1];
 801c246:	687b      	ldr	r3, [r7, #4]
 801c248:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 801c24a:	687b      	ldr	r3, [r7, #4]
 801c24c:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 801c250:	4619      	mov	r1, r3
 801c252:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c254:	fb01 f303 	mul.w	r3, r1, r3
 801c258:	4618      	mov	r0, r3
 801c25a:	687b      	ldr	r3, [r7, #4]
 801c25c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801c260:	4619      	mov	r1, r3
 801c262:	687b      	ldr	r3, [r7, #4]
 801c264:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
 801c268:	fb01 f303 	mul.w	r3, r1, r3
 801c26c:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801c26e:	fb01 f303 	mul.w	r3, r1, r3
 801c272:	4403      	add	r3, r0
 801c274:	4413      	add	r3, r2
 801c276:	687a      	ldr	r2, [r7, #4]
 801c278:	f892 2048 	ldrb.w	r2, [r2, #72]	; 0x48
 801c27c:	4413      	add	r3, r2
 801c27e:	3b01      	subs	r3, #1
 801c280:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801c282:	4413      	add	r3, r2
 801c284:	781b      	ldrb	r3, [r3, #0]
 801c286:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
 801c28a:	e091      	b.n	801c3b0 <_lv_img_buf_transform_anti_alias+0x390>
        }
    }
    else {
        c01 = lv_img_buf_get_px_color(&dsc->tmp.img_dsc, dsc->tmp.xs_int + xn, dsc->tmp.ys_int, dsc->cfg.color);
 801c28c:	687b      	ldr	r3, [r7, #4]
 801c28e:	f103 0018 	add.w	r0, r3, #24
 801c292:	687b      	ldr	r3, [r7, #4]
 801c294:	f9b3 3040 	ldrsh.w	r3, [r3, #64]	; 0x40
 801c298:	b29a      	uxth	r2, r3
 801c29a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c29c:	b29b      	uxth	r3, r3
 801c29e:	4413      	add	r3, r2
 801c2a0:	b29b      	uxth	r3, r3
 801c2a2:	b219      	sxth	r1, r3
 801c2a4:	687b      	ldr	r3, [r7, #4]
 801c2a6:	f9b3 2042 	ldrsh.w	r2, [r3, #66]	; 0x42
 801c2aa:	687b      	ldr	r3, [r7, #4]
 801c2ac:	8a1b      	ldrh	r3, [r3, #16]
 801c2ae:	f7ff f937 	bl	801b520 <lv_img_buf_get_px_color>
 801c2b2:	4603      	mov	r3, r0
 801c2b4:	83bb      	strh	r3, [r7, #28]
        c10 = lv_img_buf_get_px_color(&dsc->tmp.img_dsc, dsc->tmp.xs_int, dsc->tmp.ys_int + yn, dsc->cfg.color);
 801c2b6:	687b      	ldr	r3, [r7, #4]
 801c2b8:	f103 0018 	add.w	r0, r3, #24
 801c2bc:	687b      	ldr	r3, [r7, #4]
 801c2be:	f9b3 1040 	ldrsh.w	r1, [r3, #64]	; 0x40
 801c2c2:	687b      	ldr	r3, [r7, #4]
 801c2c4:	f9b3 3042 	ldrsh.w	r3, [r3, #66]	; 0x42
 801c2c8:	b29a      	uxth	r2, r3
 801c2ca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c2cc:	b29b      	uxth	r3, r3
 801c2ce:	4413      	add	r3, r2
 801c2d0:	b29b      	uxth	r3, r3
 801c2d2:	b21a      	sxth	r2, r3
 801c2d4:	687b      	ldr	r3, [r7, #4]
 801c2d6:	8a1b      	ldrh	r3, [r3, #16]
 801c2d8:	f7ff f922 	bl	801b520 <lv_img_buf_get_px_color>
 801c2dc:	4603      	mov	r3, r0
 801c2de:	833b      	strh	r3, [r7, #24]
        c11 = lv_img_buf_get_px_color(&dsc->tmp.img_dsc, dsc->tmp.xs_int + xn, dsc->tmp.ys_int + yn, dsc->cfg.color);
 801c2e0:	687b      	ldr	r3, [r7, #4]
 801c2e2:	f103 0018 	add.w	r0, r3, #24
 801c2e6:	687b      	ldr	r3, [r7, #4]
 801c2e8:	f9b3 3040 	ldrsh.w	r3, [r3, #64]	; 0x40
 801c2ec:	b29a      	uxth	r2, r3
 801c2ee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c2f0:	b29b      	uxth	r3, r3
 801c2f2:	4413      	add	r3, r2
 801c2f4:	b29b      	uxth	r3, r3
 801c2f6:	b219      	sxth	r1, r3
 801c2f8:	687b      	ldr	r3, [r7, #4]
 801c2fa:	f9b3 3042 	ldrsh.w	r3, [r3, #66]	; 0x42
 801c2fe:	b29a      	uxth	r2, r3
 801c300:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c302:	b29b      	uxth	r3, r3
 801c304:	4413      	add	r3, r2
 801c306:	b29b      	uxth	r3, r3
 801c308:	b21a      	sxth	r2, r3
 801c30a:	687b      	ldr	r3, [r7, #4]
 801c30c:	8a1b      	ldrh	r3, [r3, #16]
 801c30e:	f7ff f907 	bl	801b520 <lv_img_buf_get_px_color>
 801c312:	4603      	mov	r3, r0
 801c314:	82bb      	strh	r3, [r7, #20]

        if(dsc->tmp.has_alpha) {
 801c316:	687b      	ldr	r3, [r7, #4]
 801c318:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801c31c:	f003 0302 	and.w	r3, r3, #2
 801c320:	b2db      	uxtb	r3, r3
 801c322:	2b00      	cmp	r3, #0
 801c324:	d044      	beq.n	801c3b0 <_lv_img_buf_transform_anti_alias+0x390>
            a10 = lv_img_buf_get_px_alpha(&dsc->tmp.img_dsc, dsc->tmp.xs_int + xn, dsc->tmp.ys_int);
 801c326:	687b      	ldr	r3, [r7, #4]
 801c328:	f103 0018 	add.w	r0, r3, #24
 801c32c:	687b      	ldr	r3, [r7, #4]
 801c32e:	f9b3 3040 	ldrsh.w	r3, [r3, #64]	; 0x40
 801c332:	b29a      	uxth	r2, r3
 801c334:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c336:	b29b      	uxth	r3, r3
 801c338:	4413      	add	r3, r2
 801c33a:	b29b      	uxth	r3, r3
 801c33c:	b219      	sxth	r1, r3
 801c33e:	687b      	ldr	r3, [r7, #4]
 801c340:	f9b3 3042 	ldrsh.w	r3, [r3, #66]	; 0x42
 801c344:	461a      	mov	r2, r3
 801c346:	f7ff fa37 	bl	801b7b8 <lv_img_buf_get_px_alpha>
 801c34a:	4603      	mov	r3, r0
 801c34c:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a
            a01 = lv_img_buf_get_px_alpha(&dsc->tmp.img_dsc, dsc->tmp.xs_int, dsc->tmp.ys_int + yn);
 801c350:	687b      	ldr	r3, [r7, #4]
 801c352:	f103 0018 	add.w	r0, r3, #24
 801c356:	687b      	ldr	r3, [r7, #4]
 801c358:	f9b3 1040 	ldrsh.w	r1, [r3, #64]	; 0x40
 801c35c:	687b      	ldr	r3, [r7, #4]
 801c35e:	f9b3 3042 	ldrsh.w	r3, [r3, #66]	; 0x42
 801c362:	b29a      	uxth	r2, r3
 801c364:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c366:	b29b      	uxth	r3, r3
 801c368:	4413      	add	r3, r2
 801c36a:	b29b      	uxth	r3, r3
 801c36c:	b21b      	sxth	r3, r3
 801c36e:	461a      	mov	r2, r3
 801c370:	f7ff fa22 	bl	801b7b8 <lv_img_buf_get_px_alpha>
 801c374:	4603      	mov	r3, r0
 801c376:	f887 3039 	strb.w	r3, [r7, #57]	; 0x39
            a11 = lv_img_buf_get_px_alpha(&dsc->tmp.img_dsc, dsc->tmp.xs_int + xn, dsc->tmp.ys_int + yn);
 801c37a:	687b      	ldr	r3, [r7, #4]
 801c37c:	f103 0018 	add.w	r0, r3, #24
 801c380:	687b      	ldr	r3, [r7, #4]
 801c382:	f9b3 3040 	ldrsh.w	r3, [r3, #64]	; 0x40
 801c386:	b29a      	uxth	r2, r3
 801c388:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801c38a:	b29b      	uxth	r3, r3
 801c38c:	4413      	add	r3, r2
 801c38e:	b29b      	uxth	r3, r3
 801c390:	b219      	sxth	r1, r3
 801c392:	687b      	ldr	r3, [r7, #4]
 801c394:	f9b3 3042 	ldrsh.w	r3, [r3, #66]	; 0x42
 801c398:	b29a      	uxth	r2, r3
 801c39a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801c39c:	b29b      	uxth	r3, r3
 801c39e:	4413      	add	r3, r2
 801c3a0:	b29b      	uxth	r3, r3
 801c3a2:	b21b      	sxth	r3, r3
 801c3a4:	461a      	mov	r2, r3
 801c3a6:	f7ff fa07 	bl	801b7b8 <lv_img_buf_get_px_alpha>
 801c3aa:	4603      	mov	r3, r0
 801c3ac:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38
        }
    }

    lv_opa_t xr0 = xr;
 801c3b0:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 801c3b4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    lv_opa_t xr1 = xr;
 801c3b8:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 801c3bc:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
    if(dsc->tmp.has_alpha) {
 801c3c0:	687b      	ldr	r3, [r7, #4]
 801c3c2:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 801c3c6:	f003 0302 	and.w	r3, r3, #2
 801c3ca:	b2db      	uxtb	r3, r3
 801c3cc:	2b00      	cmp	r3, #0
 801c3ce:	d06b      	beq.n	801c4a8 <_lv_img_buf_transform_anti_alias+0x488>
        lv_opa_t a0 = (a00 * xr + (a10 * (255 - xr))) >> 8;
 801c3d0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801c3d4:	f897 2043 	ldrb.w	r2, [r7, #67]	; 0x43
 801c3d8:	fb03 f202 	mul.w	r2, r3, r2
 801c3dc:	f897 303a 	ldrb.w	r3, [r7, #58]	; 0x3a
 801c3e0:	f897 1043 	ldrb.w	r1, [r7, #67]	; 0x43
 801c3e4:	f1c1 01ff 	rsb	r1, r1, #255	; 0xff
 801c3e8:	fb01 f303 	mul.w	r3, r1, r3
 801c3ec:	4413      	add	r3, r2
 801c3ee:	121b      	asrs	r3, r3, #8
 801c3f0:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
        lv_opa_t a1 = (a01 * xr + (a11 * (255 - xr))) >> 8;
 801c3f4:	f897 3039 	ldrb.w	r3, [r7, #57]	; 0x39
 801c3f8:	f897 2043 	ldrb.w	r2, [r7, #67]	; 0x43
 801c3fc:	fb03 f202 	mul.w	r2, r3, r2
 801c400:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 801c404:	f897 1043 	ldrb.w	r1, [r7, #67]	; 0x43
 801c408:	f1c1 01ff 	rsb	r1, r1, #255	; 0xff
 801c40c:	fb01 f303 	mul.w	r3, r1, r3
 801c410:	4413      	add	r3, r2
 801c412:	121b      	asrs	r3, r3, #8
 801c414:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25
        dsc->res.opa = (a0 * yr + (a1 * (255 - yr))) >> 8;
 801c418:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 801c41c:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 801c420:	fb03 f202 	mul.w	r2, r3, r2
 801c424:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
 801c428:	f897 103b 	ldrb.w	r1, [r7, #59]	; 0x3b
 801c42c:	f1c1 01ff 	rsb	r1, r1, #255	; 0xff
 801c430:	fb01 f303 	mul.w	r3, r1, r3
 801c434:	4413      	add	r3, r2
 801c436:	121b      	asrs	r3, r3, #8
 801c438:	b2da      	uxtb	r2, r3
 801c43a:	687b      	ldr	r3, [r7, #4]
 801c43c:	759a      	strb	r2, [r3, #22]

        if(a0 <= LV_OPA_MIN && a1 <= LV_OPA_MIN) return false;
 801c43e:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 801c442:	2b02      	cmp	r3, #2
 801c444:	d805      	bhi.n	801c452 <_lv_img_buf_transform_anti_alias+0x432>
 801c446:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
 801c44a:	2b02      	cmp	r3, #2
 801c44c:	d801      	bhi.n	801c452 <_lv_img_buf_transform_anti_alias+0x432>
 801c44e:	2300      	movs	r3, #0
 801c450:	e07d      	b.n	801c54e <_lv_img_buf_transform_anti_alias+0x52e>
        if(a0 <= LV_OPA_MIN) yr = LV_OPA_TRANSP;
 801c452:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 801c456:	2b02      	cmp	r3, #2
 801c458:	d802      	bhi.n	801c460 <_lv_img_buf_transform_anti_alias+0x440>
 801c45a:	2300      	movs	r3, #0
 801c45c:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
        if(a1 <= LV_OPA_MIN) yr = LV_OPA_COVER;
 801c460:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
 801c464:	2b02      	cmp	r3, #2
 801c466:	d802      	bhi.n	801c46e <_lv_img_buf_transform_anti_alias+0x44e>
 801c468:	23ff      	movs	r3, #255	; 0xff
 801c46a:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
        if(a00 <= LV_OPA_MIN) xr0 = LV_OPA_TRANSP;
 801c46e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 801c472:	2b02      	cmp	r3, #2
 801c474:	d802      	bhi.n	801c47c <_lv_img_buf_transform_anti_alias+0x45c>
 801c476:	2300      	movs	r3, #0
 801c478:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        if(a10 <= LV_OPA_MIN) xr0 = LV_OPA_COVER;
 801c47c:	f897 303a 	ldrb.w	r3, [r7, #58]	; 0x3a
 801c480:	2b02      	cmp	r3, #2
 801c482:	d802      	bhi.n	801c48a <_lv_img_buf_transform_anti_alias+0x46a>
 801c484:	23ff      	movs	r3, #255	; 0xff
 801c486:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        if(a01 <= LV_OPA_MIN) xr1 = LV_OPA_TRANSP;
 801c48a:	f897 3039 	ldrb.w	r3, [r7, #57]	; 0x39
 801c48e:	2b02      	cmp	r3, #2
 801c490:	d802      	bhi.n	801c498 <_lv_img_buf_transform_anti_alias+0x478>
 801c492:	2300      	movs	r3, #0
 801c494:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
        if(a11 <= LV_OPA_MIN) xr1 = LV_OPA_COVER;
 801c498:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 801c49c:	2b02      	cmp	r3, #2
 801c49e:	d80e      	bhi.n	801c4be <_lv_img_buf_transform_anti_alias+0x49e>
 801c4a0:	23ff      	movs	r3, #255	; 0xff
 801c4a2:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
 801c4a6:	e00a      	b.n	801c4be <_lv_img_buf_transform_anti_alias+0x49e>
    }
    else {
        xr0 = xr;
 801c4a8:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 801c4ac:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
        xr1 = xr;
 801c4b0:	f897 3043 	ldrb.w	r3, [r7, #67]	; 0x43
 801c4b4:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
        dsc->res.opa = LV_OPA_COVER;
 801c4b8:	687b      	ldr	r3, [r7, #4]
 801c4ba:	22ff      	movs	r2, #255	; 0xff
 801c4bc:	759a      	strb	r2, [r3, #22]
    }

    lv_color_t c0;
    if(xr0 == LV_OPA_TRANSP) c0 = c01;
 801c4be:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801c4c2:	2b00      	cmp	r3, #0
 801c4c4:	d102      	bne.n	801c4cc <_lv_img_buf_transform_anti_alias+0x4ac>
 801c4c6:	8bbb      	ldrh	r3, [r7, #28]
 801c4c8:	823b      	strh	r3, [r7, #16]
 801c4ca:	e00f      	b.n	801c4ec <_lv_img_buf_transform_anti_alias+0x4cc>
    else if(xr0 == LV_OPA_COVER) c0 = c00;
 801c4cc:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801c4d0:	2bff      	cmp	r3, #255	; 0xff
 801c4d2:	d102      	bne.n	801c4da <_lv_img_buf_transform_anti_alias+0x4ba>
 801c4d4:	8c3b      	ldrh	r3, [r7, #32]
 801c4d6:	823b      	strh	r3, [r7, #16]
 801c4d8:	e008      	b.n	801c4ec <_lv_img_buf_transform_anti_alias+0x4cc>
    else c0 = lv_color_mix(c00, c01, xr0);
 801c4da:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801c4de:	461a      	mov	r2, r3
 801c4e0:	8bb9      	ldrh	r1, [r7, #28]
 801c4e2:	8c38      	ldrh	r0, [r7, #32]
 801c4e4:	f7fe ff86 	bl	801b3f4 <lv_color_mix>
 801c4e8:	4603      	mov	r3, r0
 801c4ea:	823b      	strh	r3, [r7, #16]

    lv_color_t c1;
    if(xr1 == LV_OPA_TRANSP) c1 = c11;
 801c4ec:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801c4f0:	2b00      	cmp	r3, #0
 801c4f2:	d102      	bne.n	801c4fa <_lv_img_buf_transform_anti_alias+0x4da>
 801c4f4:	8abb      	ldrh	r3, [r7, #20]
 801c4f6:	81bb      	strh	r3, [r7, #12]
 801c4f8:	e00f      	b.n	801c51a <_lv_img_buf_transform_anti_alias+0x4fa>
    else if(xr1 == LV_OPA_COVER) c1 = c10;
 801c4fa:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801c4fe:	2bff      	cmp	r3, #255	; 0xff
 801c500:	d102      	bne.n	801c508 <_lv_img_buf_transform_anti_alias+0x4e8>
 801c502:	8b3b      	ldrh	r3, [r7, #24]
 801c504:	81bb      	strh	r3, [r7, #12]
 801c506:	e008      	b.n	801c51a <_lv_img_buf_transform_anti_alias+0x4fa>
    else c1 = lv_color_mix(c10, c11, xr1);
 801c508:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801c50c:	461a      	mov	r2, r3
 801c50e:	8ab9      	ldrh	r1, [r7, #20]
 801c510:	8b38      	ldrh	r0, [r7, #24]
 801c512:	f7fe ff6f 	bl	801b3f4 <lv_color_mix>
 801c516:	4603      	mov	r3, r0
 801c518:	81bb      	strh	r3, [r7, #12]

    if(yr == LV_OPA_TRANSP) dsc->res.color = c1;
 801c51a:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 801c51e:	2b00      	cmp	r3, #0
 801c520:	d103      	bne.n	801c52a <_lv_img_buf_transform_anti_alias+0x50a>
 801c522:	687b      	ldr	r3, [r7, #4]
 801c524:	89ba      	ldrh	r2, [r7, #12]
 801c526:	829a      	strh	r2, [r3, #20]
 801c528:	e010      	b.n	801c54c <_lv_img_buf_transform_anti_alias+0x52c>
    else if(yr == LV_OPA_COVER) dsc->res.color = c0;
 801c52a:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 801c52e:	2bff      	cmp	r3, #255	; 0xff
 801c530:	d103      	bne.n	801c53a <_lv_img_buf_transform_anti_alias+0x51a>
 801c532:	687b      	ldr	r3, [r7, #4]
 801c534:	8a3a      	ldrh	r2, [r7, #16]
 801c536:	829a      	strh	r2, [r3, #20]
 801c538:	e008      	b.n	801c54c <_lv_img_buf_transform_anti_alias+0x52c>
    else dsc->res.color = lv_color_mix(c0, c1, yr);
 801c53a:	687c      	ldr	r4, [r7, #4]
 801c53c:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 801c540:	461a      	mov	r2, r3
 801c542:	89b9      	ldrh	r1, [r7, #12]
 801c544:	8a38      	ldrh	r0, [r7, #16]
 801c546:	f7fe ff55 	bl	801b3f4 <lv_color_mix>
 801c54a:	82a0      	strh	r0, [r4, #20]

    return true;
 801c54c:	2301      	movs	r3, #1
}
 801c54e:	4618      	mov	r0, r3
 801c550:	374c      	adds	r7, #76	; 0x4c
 801c552:	46bd      	mov	sp, r7
 801c554:	bd90      	pop	{r4, r7, pc}
	...

0801c558 <_lv_img_cache_open>:
 * @param src source of the image. Path to file or pointer to an `lv_img_dsc_t` variable
 * @param color color The color of the image with `LV_IMG_CF_ALPHA_...`
 * @return pointer to the cache entry or NULL if can open the image
 */
lv_img_cache_entry_t * _lv_img_cache_open(const void * src, lv_color_t color)
{
 801c558:	b580      	push	{r7, lr}
 801c55a:	b08a      	sub	sp, #40	; 0x28
 801c55c:	af00      	add	r7, sp, #0
 801c55e:	6078      	str	r0, [r7, #4]
 801c560:	8039      	strh	r1, [r7, #0]
    if(entry_cnt == 0) {
 801c562:	4b87      	ldr	r3, [pc, #540]	; (801c780 <_lv_img_cache_open+0x228>)
 801c564:	881b      	ldrh	r3, [r3, #0]
 801c566:	2b00      	cmp	r3, #0
 801c568:	d101      	bne.n	801c56e <_lv_img_cache_open+0x16>
        LV_LOG_WARN("lv_img_cache_open: the cache size is 0");
        return NULL;
 801c56a:	2300      	movs	r3, #0
 801c56c:	e104      	b.n	801c778 <_lv_img_cache_open+0x220>
    }

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
 801c56e:	4b85      	ldr	r3, [pc, #532]	; (801c784 <_lv_img_cache_open+0x22c>)
 801c570:	681b      	ldr	r3, [r3, #0]
 801c572:	61bb      	str	r3, [r7, #24]

    /*Decrement all lifes. Make the entries older*/
    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
 801c574:	2300      	movs	r3, #0
 801c576:	84fb      	strh	r3, [r7, #38]	; 0x26
 801c578:	e021      	b.n	801c5be <_lv_img_cache_open+0x66>
        if(cache[i].life > INT32_MIN + LV_IMG_CACHE_AGING) {
 801c57a:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c57c:	4613      	mov	r3, r2
 801c57e:	00db      	lsls	r3, r3, #3
 801c580:	4413      	add	r3, r2
 801c582:	009b      	lsls	r3, r3, #2
 801c584:	461a      	mov	r2, r3
 801c586:	69bb      	ldr	r3, [r7, #24]
 801c588:	4413      	add	r3, r2
 801c58a:	6a1b      	ldr	r3, [r3, #32]
 801c58c:	4a7e      	ldr	r2, [pc, #504]	; (801c788 <_lv_img_cache_open+0x230>)
 801c58e:	4293      	cmp	r3, r2
 801c590:	db12      	blt.n	801c5b8 <_lv_img_cache_open+0x60>
            cache[i].life -= LV_IMG_CACHE_AGING;
 801c592:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c594:	4613      	mov	r3, r2
 801c596:	00db      	lsls	r3, r3, #3
 801c598:	4413      	add	r3, r2
 801c59a:	009b      	lsls	r3, r3, #2
 801c59c:	461a      	mov	r2, r3
 801c59e:	69bb      	ldr	r3, [r7, #24]
 801c5a0:	4413      	add	r3, r2
 801c5a2:	6a19      	ldr	r1, [r3, #32]
 801c5a4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c5a6:	4613      	mov	r3, r2
 801c5a8:	00db      	lsls	r3, r3, #3
 801c5aa:	4413      	add	r3, r2
 801c5ac:	009b      	lsls	r3, r3, #2
 801c5ae:	461a      	mov	r2, r3
 801c5b0:	69bb      	ldr	r3, [r7, #24]
 801c5b2:	4413      	add	r3, r2
 801c5b4:	1e4a      	subs	r2, r1, #1
 801c5b6:	621a      	str	r2, [r3, #32]
    for(i = 0; i < entry_cnt; i++) {
 801c5b8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801c5ba:	3301      	adds	r3, #1
 801c5bc:	84fb      	strh	r3, [r7, #38]	; 0x26
 801c5be:	4b70      	ldr	r3, [pc, #448]	; (801c780 <_lv_img_cache_open+0x228>)
 801c5c0:	881b      	ldrh	r3, [r3, #0]
 801c5c2:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c5c4:	429a      	cmp	r2, r3
 801c5c6:	d3d8      	bcc.n	801c57a <_lv_img_cache_open+0x22>
        }
    }

    /*Is the image cached?*/
    lv_img_cache_entry_t * cached_src = NULL;
 801c5c8:	2300      	movs	r3, #0
 801c5ca:	623b      	str	r3, [r7, #32]
    for(i = 0; i < entry_cnt; i++) {
 801c5cc:	2300      	movs	r3, #0
 801c5ce:	84fb      	strh	r3, [r7, #38]	; 0x26
 801c5d0:	e064      	b.n	801c69c <_lv_img_cache_open+0x144>
        bool match = false;
 801c5d2:	2300      	movs	r3, #0
 801c5d4:	77fb      	strb	r3, [r7, #31]
        lv_img_src_t src_type = lv_img_src_get_type(cache[i].dec_dsc.src);
 801c5d6:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c5d8:	4613      	mov	r3, r2
 801c5da:	00db      	lsls	r3, r3, #3
 801c5dc:	4413      	add	r3, r2
 801c5de:	009b      	lsls	r3, r3, #2
 801c5e0:	461a      	mov	r2, r3
 801c5e2:	69bb      	ldr	r3, [r7, #24]
 801c5e4:	4413      	add	r3, r2
 801c5e6:	685b      	ldr	r3, [r3, #4]
 801c5e8:	4618      	mov	r0, r3
 801c5ea:	f7f5 fff4 	bl	80125d6 <lv_img_src_get_type>
 801c5ee:	4603      	mov	r3, r0
 801c5f0:	75fb      	strb	r3, [r7, #23]
        if(src_type == LV_IMG_SRC_VARIABLE) {
 801c5f2:	7dfb      	ldrb	r3, [r7, #23]
 801c5f4:	2b00      	cmp	r3, #0
 801c5f6:	d11a      	bne.n	801c62e <_lv_img_cache_open+0xd6>
            if(cache[i].dec_dsc.src == src && cache[i].dec_dsc.color.full == color.full) match = true;
 801c5f8:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c5fa:	4613      	mov	r3, r2
 801c5fc:	00db      	lsls	r3, r3, #3
 801c5fe:	4413      	add	r3, r2
 801c600:	009b      	lsls	r3, r3, #2
 801c602:	461a      	mov	r2, r3
 801c604:	69bb      	ldr	r3, [r7, #24]
 801c606:	4413      	add	r3, r2
 801c608:	685b      	ldr	r3, [r3, #4]
 801c60a:	687a      	ldr	r2, [r7, #4]
 801c60c:	429a      	cmp	r2, r3
 801c60e:	d123      	bne.n	801c658 <_lv_img_cache_open+0x100>
 801c610:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c612:	4613      	mov	r3, r2
 801c614:	00db      	lsls	r3, r3, #3
 801c616:	4413      	add	r3, r2
 801c618:	009b      	lsls	r3, r3, #2
 801c61a:	461a      	mov	r2, r3
 801c61c:	69bb      	ldr	r3, [r7, #24]
 801c61e:	4413      	add	r3, r2
 801c620:	891a      	ldrh	r2, [r3, #8]
 801c622:	883b      	ldrh	r3, [r7, #0]
 801c624:	429a      	cmp	r2, r3
 801c626:	d117      	bne.n	801c658 <_lv_img_cache_open+0x100>
 801c628:	2301      	movs	r3, #1
 801c62a:	77fb      	strb	r3, [r7, #31]
 801c62c:	e014      	b.n	801c658 <_lv_img_cache_open+0x100>
        }
        else if(src_type == LV_IMG_SRC_FILE) {
 801c62e:	7dfb      	ldrb	r3, [r7, #23]
 801c630:	2b01      	cmp	r3, #1
 801c632:	d111      	bne.n	801c658 <_lv_img_cache_open+0x100>
            if(strcmp(cache[i].dec_dsc.src, src) == 0) match = true;
 801c634:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c636:	4613      	mov	r3, r2
 801c638:	00db      	lsls	r3, r3, #3
 801c63a:	4413      	add	r3, r2
 801c63c:	009b      	lsls	r3, r3, #2
 801c63e:	461a      	mov	r2, r3
 801c640:	69bb      	ldr	r3, [r7, #24]
 801c642:	4413      	add	r3, r2
 801c644:	685b      	ldr	r3, [r3, #4]
 801c646:	6879      	ldr	r1, [r7, #4]
 801c648:	4618      	mov	r0, r3
 801c64a:	f7e3 fdcf 	bl	80001ec <strcmp>
 801c64e:	4603      	mov	r3, r0
 801c650:	2b00      	cmp	r3, #0
 801c652:	d101      	bne.n	801c658 <_lv_img_cache_open+0x100>
 801c654:	2301      	movs	r3, #1
 801c656:	77fb      	strb	r3, [r7, #31]
        }

        if(match) {
 801c658:	7ffb      	ldrb	r3, [r7, #31]
 801c65a:	2b00      	cmp	r3, #0
 801c65c:	d01b      	beq.n	801c696 <_lv_img_cache_open+0x13e>
            /* If opened increment its life.
             * Image difficult to open should live longer to keep avoid frequent their recaching.
             * Therefore increase `life` with `time_to_open`*/
            cached_src = &cache[i];
 801c65e:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c660:	4613      	mov	r3, r2
 801c662:	00db      	lsls	r3, r3, #3
 801c664:	4413      	add	r3, r2
 801c666:	009b      	lsls	r3, r3, #2
 801c668:	461a      	mov	r2, r3
 801c66a:	69bb      	ldr	r3, [r7, #24]
 801c66c:	4413      	add	r3, r2
 801c66e:	623b      	str	r3, [r7, #32]
            cached_src->life += cached_src->dec_dsc.time_to_open * LV_IMG_CACHE_LIFE_GAIN;
 801c670:	6a3b      	ldr	r3, [r7, #32]
 801c672:	6a1b      	ldr	r3, [r3, #32]
 801c674:	461a      	mov	r2, r3
 801c676:	6a3b      	ldr	r3, [r7, #32]
 801c678:	695b      	ldr	r3, [r3, #20]
 801c67a:	4413      	add	r3, r2
 801c67c:	461a      	mov	r2, r3
 801c67e:	6a3b      	ldr	r3, [r7, #32]
 801c680:	621a      	str	r2, [r3, #32]
            if(cached_src->life > LV_IMG_CACHE_LIFE_LIMIT) cached_src->life = LV_IMG_CACHE_LIFE_LIMIT;
 801c682:	6a3b      	ldr	r3, [r7, #32]
 801c684:	6a1b      	ldr	r3, [r3, #32]
 801c686:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 801c68a:	dd0d      	ble.n	801c6a8 <_lv_img_cache_open+0x150>
 801c68c:	6a3b      	ldr	r3, [r7, #32]
 801c68e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801c692:	621a      	str	r2, [r3, #32]
            LV_LOG_TRACE("image draw: image found in the cache");
            break;
 801c694:	e008      	b.n	801c6a8 <_lv_img_cache_open+0x150>
    for(i = 0; i < entry_cnt; i++) {
 801c696:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801c698:	3301      	adds	r3, #1
 801c69a:	84fb      	strh	r3, [r7, #38]	; 0x26
 801c69c:	4b38      	ldr	r3, [pc, #224]	; (801c780 <_lv_img_cache_open+0x228>)
 801c69e:	881b      	ldrh	r3, [r3, #0]
 801c6a0:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c6a2:	429a      	cmp	r2, r3
 801c6a4:	d395      	bcc.n	801c5d2 <_lv_img_cache_open+0x7a>
 801c6a6:	e000      	b.n	801c6aa <_lv_img_cache_open+0x152>
            break;
 801c6a8:	bf00      	nop
        }
    }

    /*The image is not cached then cache it now*/
    if(cached_src == NULL) {
 801c6aa:	6a3b      	ldr	r3, [r7, #32]
 801c6ac:	2b00      	cmp	r3, #0
 801c6ae:	d162      	bne.n	801c776 <_lv_img_cache_open+0x21e>
        /*Find an entry to reuse. Select the entry with the least life*/
        cached_src = &cache[0];
 801c6b0:	69bb      	ldr	r3, [r7, #24]
 801c6b2:	623b      	str	r3, [r7, #32]
        for(i = 1; i < entry_cnt; i++) {
 801c6b4:	2301      	movs	r3, #1
 801c6b6:	84fb      	strh	r3, [r7, #38]	; 0x26
 801c6b8:	e018      	b.n	801c6ec <_lv_img_cache_open+0x194>
            if(cache[i].life < cached_src->life) {
 801c6ba:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c6bc:	4613      	mov	r3, r2
 801c6be:	00db      	lsls	r3, r3, #3
 801c6c0:	4413      	add	r3, r2
 801c6c2:	009b      	lsls	r3, r3, #2
 801c6c4:	461a      	mov	r2, r3
 801c6c6:	69bb      	ldr	r3, [r7, #24]
 801c6c8:	4413      	add	r3, r2
 801c6ca:	6a1a      	ldr	r2, [r3, #32]
 801c6cc:	6a3b      	ldr	r3, [r7, #32]
 801c6ce:	6a1b      	ldr	r3, [r3, #32]
 801c6d0:	429a      	cmp	r2, r3
 801c6d2:	da08      	bge.n	801c6e6 <_lv_img_cache_open+0x18e>
                cached_src = &cache[i];
 801c6d4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c6d6:	4613      	mov	r3, r2
 801c6d8:	00db      	lsls	r3, r3, #3
 801c6da:	4413      	add	r3, r2
 801c6dc:	009b      	lsls	r3, r3, #2
 801c6de:	461a      	mov	r2, r3
 801c6e0:	69bb      	ldr	r3, [r7, #24]
 801c6e2:	4413      	add	r3, r2
 801c6e4:	623b      	str	r3, [r7, #32]
        for(i = 1; i < entry_cnt; i++) {
 801c6e6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801c6e8:	3301      	adds	r3, #1
 801c6ea:	84fb      	strh	r3, [r7, #38]	; 0x26
 801c6ec:	4b24      	ldr	r3, [pc, #144]	; (801c780 <_lv_img_cache_open+0x228>)
 801c6ee:	881b      	ldrh	r3, [r3, #0]
 801c6f0:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c6f2:	429a      	cmp	r2, r3
 801c6f4:	d3e1      	bcc.n	801c6ba <_lv_img_cache_open+0x162>
            }
        }

        /*Close the decoder to reuse if it was opened (has a valid source)*/
        if(cached_src->dec_dsc.src) {
 801c6f6:	6a3b      	ldr	r3, [r7, #32]
 801c6f8:	685b      	ldr	r3, [r3, #4]
 801c6fa:	2b00      	cmp	r3, #0
 801c6fc:	d003      	beq.n	801c706 <_lv_img_cache_open+0x1ae>
            lv_img_decoder_close(&cached_src->dec_dsc);
 801c6fe:	6a3b      	ldr	r3, [r7, #32]
 801c700:	4618      	mov	r0, r3
 801c702:	f000 fa71 	bl	801cbe8 <lv_img_decoder_close>
            LV_LOG_INFO("image draw: cache miss, cached to an empty entry");
        }

        /*Open the image and measure the time to open*/
        uint32_t t_start;
        t_start                          = lv_tick_get();
 801c706:	f002 faf5 	bl	801ecf4 <lv_tick_get>
 801c70a:	6138      	str	r0, [r7, #16]
        cached_src->dec_dsc.time_to_open = 0;
 801c70c:	6a3b      	ldr	r3, [r7, #32]
 801c70e:	2200      	movs	r2, #0
 801c710:	615a      	str	r2, [r3, #20]
        lv_res_t open_res                = lv_img_decoder_open(&cached_src->dec_dsc, src, color);
 801c712:	6a3b      	ldr	r3, [r7, #32]
 801c714:	883a      	ldrh	r2, [r7, #0]
 801c716:	6879      	ldr	r1, [r7, #4]
 801c718:	4618      	mov	r0, r3
 801c71a:	f000 f9c9 	bl	801cab0 <lv_img_decoder_open>
 801c71e:	4603      	mov	r3, r0
 801c720:	73fb      	strb	r3, [r7, #15]
        if(open_res == LV_RES_INV) {
 801c722:	7bfb      	ldrb	r3, [r7, #15]
 801c724:	2b00      	cmp	r3, #0
 801c726:	d112      	bne.n	801c74e <_lv_img_cache_open+0x1f6>
            LV_LOG_WARN("Image draw cannot open the image resource");
            lv_img_decoder_close(&cached_src->dec_dsc);
 801c728:	6a3b      	ldr	r3, [r7, #32]
 801c72a:	4618      	mov	r0, r3
 801c72c:	f000 fa5c 	bl	801cbe8 <lv_img_decoder_close>
            _lv_memset_00(&cached_src->dec_dsc, sizeof(lv_img_decoder_dsc_t));
 801c730:	6a3b      	ldr	r3, [r7, #32]
 801c732:	2120      	movs	r1, #32
 801c734:	4618      	mov	r0, r3
 801c736:	f004 ffb7 	bl	80216a8 <_lv_memset_00>
            _lv_memset_00(cached_src, sizeof(lv_img_cache_entry_t));
 801c73a:	2124      	movs	r1, #36	; 0x24
 801c73c:	6a38      	ldr	r0, [r7, #32]
 801c73e:	f004 ffb3 	bl	80216a8 <_lv_memset_00>
            cached_src->life = INT32_MIN; /*Make the empty entry very "weak" to force its use  */
 801c742:	6a3b      	ldr	r3, [r7, #32]
 801c744:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 801c748:	621a      	str	r2, [r3, #32]
            return NULL;
 801c74a:	2300      	movs	r3, #0
 801c74c:	e014      	b.n	801c778 <_lv_img_cache_open+0x220>
        }

        cached_src->life = 0;
 801c74e:	6a3b      	ldr	r3, [r7, #32]
 801c750:	2200      	movs	r2, #0
 801c752:	621a      	str	r2, [r3, #32]

        /*If `time_to_open` was not set in the open function set it here*/
        if(cached_src->dec_dsc.time_to_open == 0) {
 801c754:	6a3b      	ldr	r3, [r7, #32]
 801c756:	695b      	ldr	r3, [r3, #20]
 801c758:	2b00      	cmp	r3, #0
 801c75a:	d105      	bne.n	801c768 <_lv_img_cache_open+0x210>
            cached_src->dec_dsc.time_to_open = lv_tick_elaps(t_start);
 801c75c:	6938      	ldr	r0, [r7, #16]
 801c75e:	f002 fae3 	bl	801ed28 <lv_tick_elaps>
 801c762:	4602      	mov	r2, r0
 801c764:	6a3b      	ldr	r3, [r7, #32]
 801c766:	615a      	str	r2, [r3, #20]
        }

        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
 801c768:	6a3b      	ldr	r3, [r7, #32]
 801c76a:	695b      	ldr	r3, [r3, #20]
 801c76c:	2b00      	cmp	r3, #0
 801c76e:	d102      	bne.n	801c776 <_lv_img_cache_open+0x21e>
 801c770:	6a3b      	ldr	r3, [r7, #32]
 801c772:	2201      	movs	r2, #1
 801c774:	615a      	str	r2, [r3, #20]
    }

    return cached_src;
 801c776:	6a3b      	ldr	r3, [r7, #32]
}
 801c778:	4618      	mov	r0, r3
 801c77a:	3728      	adds	r7, #40	; 0x28
 801c77c:	46bd      	mov	sp, r7
 801c77e:	bd80      	pop	{r7, pc}
 801c780:	2000a148 	.word	0x2000a148
 801c784:	2000a1d4 	.word	0x2000a1d4
 801c788:	80000002 	.word	0x80000002

0801c78c <lv_img_cache_set_size>:
 * More cached images mean more opened image at same time which might mean more memory usage.
 * E.g. if 20 PNG or JPG images are open in the RAM they consume memory while opened in the cache.
 * @param new_entry_cnt number of image to cache
 */
void lv_img_cache_set_size(uint16_t new_entry_cnt)
{
 801c78c:	b5b0      	push	{r4, r5, r7, lr}
 801c78e:	b084      	sub	sp, #16
 801c790:	af00      	add	r7, sp, #0
 801c792:	4603      	mov	r3, r0
 801c794:	80fb      	strh	r3, [r7, #6]
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
 801c796:	4b2f      	ldr	r3, [pc, #188]	; (801c854 <lv_img_cache_set_size+0xc8>)
 801c798:	681b      	ldr	r3, [r3, #0]
 801c79a:	2b00      	cmp	r3, #0
 801c79c:	d007      	beq.n	801c7ae <lv_img_cache_set_size+0x22>
        /*Clean the cache before free it*/
        lv_img_cache_invalidate_src(NULL);
 801c79e:	2000      	movs	r0, #0
 801c7a0:	f000 f85e 	bl	801c860 <lv_img_cache_invalidate_src>
        lv_mem_free(LV_GC_ROOT(_lv_img_cache_array));
 801c7a4:	4b2b      	ldr	r3, [pc, #172]	; (801c854 <lv_img_cache_set_size+0xc8>)
 801c7a6:	681b      	ldr	r3, [r3, #0]
 801c7a8:	4618      	mov	r0, r3
 801c7aa:	f004 fa5d 	bl	8020c68 <lv_mem_free>
    }

    /*Reallocate the cache*/
    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(lv_img_cache_entry_t) * new_entry_cnt);
 801c7ae:	88fa      	ldrh	r2, [r7, #6]
 801c7b0:	4613      	mov	r3, r2
 801c7b2:	00db      	lsls	r3, r3, #3
 801c7b4:	4413      	add	r3, r2
 801c7b6:	009b      	lsls	r3, r3, #2
 801c7b8:	4618      	mov	r0, r3
 801c7ba:	f004 fa0b 	bl	8020bd4 <lv_mem_alloc>
 801c7be:	4603      	mov	r3, r0
 801c7c0:	4a24      	ldr	r2, [pc, #144]	; (801c854 <lv_img_cache_set_size+0xc8>)
 801c7c2:	6013      	str	r3, [r2, #0]
    LV_ASSERT_MEM(LV_GC_ROOT(_lv_img_cache_array));
 801c7c4:	4b23      	ldr	r3, [pc, #140]	; (801c854 <lv_img_cache_set_size+0xc8>)
 801c7c6:	681b      	ldr	r3, [r3, #0]
 801c7c8:	4618      	mov	r0, r3
 801c7ca:	f003 fc91 	bl	80200f0 <lv_debug_check_null>
 801c7ce:	4603      	mov	r3, r0
 801c7d0:	f083 0301 	eor.w	r3, r3, #1
 801c7d4:	b2db      	uxtb	r3, r3
 801c7d6:	2b00      	cmp	r3, #0
 801c7d8:	d00b      	beq.n	801c7f2 <lv_img_cache_set_size+0x66>
 801c7da:	4b1e      	ldr	r3, [pc, #120]	; (801c854 <lv_img_cache_set_size+0xc8>)
 801c7dc:	681b      	ldr	r3, [r3, #0]
 801c7de:	461a      	mov	r2, r3
 801c7e0:	2300      	movs	r3, #0
 801c7e2:	4614      	mov	r4, r2
 801c7e4:	461d      	mov	r5, r3
 801c7e6:	4622      	mov	r2, r4
 801c7e8:	462b      	mov	r3, r5
 801c7ea:	481b      	ldr	r0, [pc, #108]	; (801c858 <lv_img_cache_set_size+0xcc>)
 801c7ec:	f003 fc90 	bl	8020110 <lv_debug_log_error>
 801c7f0:	e7fe      	b.n	801c7f0 <lv_img_cache_set_size+0x64>
    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {
 801c7f2:	4b18      	ldr	r3, [pc, #96]	; (801c854 <lv_img_cache_set_size+0xc8>)
 801c7f4:	681b      	ldr	r3, [r3, #0]
 801c7f6:	2b00      	cmp	r3, #0
 801c7f8:	d103      	bne.n	801c802 <lv_img_cache_set_size+0x76>
        entry_cnt = 0;
 801c7fa:	4b18      	ldr	r3, [pc, #96]	; (801c85c <lv_img_cache_set_size+0xd0>)
 801c7fc:	2200      	movs	r2, #0
 801c7fe:	801a      	strh	r2, [r3, #0]
        return;
 801c800:	e025      	b.n	801c84e <lv_img_cache_set_size+0xc2>
    }
    entry_cnt = new_entry_cnt;
 801c802:	4a16      	ldr	r2, [pc, #88]	; (801c85c <lv_img_cache_set_size+0xd0>)
 801c804:	88fb      	ldrh	r3, [r7, #6]
 801c806:	8013      	strh	r3, [r2, #0]

    /*Clean the cache*/
    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
 801c808:	2300      	movs	r3, #0
 801c80a:	81fb      	strh	r3, [r7, #14]
 801c80c:	e01a      	b.n	801c844 <lv_img_cache_set_size+0xb8>
        _lv_memset_00(&LV_GC_ROOT(_lv_img_cache_array)[i].dec_dsc, sizeof(lv_img_decoder_dsc_t));
 801c80e:	4b11      	ldr	r3, [pc, #68]	; (801c854 <lv_img_cache_set_size+0xc8>)
 801c810:	6819      	ldr	r1, [r3, #0]
 801c812:	89fa      	ldrh	r2, [r7, #14]
 801c814:	4613      	mov	r3, r2
 801c816:	00db      	lsls	r3, r3, #3
 801c818:	4413      	add	r3, r2
 801c81a:	009b      	lsls	r3, r3, #2
 801c81c:	440b      	add	r3, r1
 801c81e:	2120      	movs	r1, #32
 801c820:	4618      	mov	r0, r3
 801c822:	f004 ff41 	bl	80216a8 <_lv_memset_00>
        _lv_memset_00(&LV_GC_ROOT(_lv_img_cache_array)[i], sizeof(lv_img_cache_entry_t));
 801c826:	4b0b      	ldr	r3, [pc, #44]	; (801c854 <lv_img_cache_set_size+0xc8>)
 801c828:	6819      	ldr	r1, [r3, #0]
 801c82a:	89fa      	ldrh	r2, [r7, #14]
 801c82c:	4613      	mov	r3, r2
 801c82e:	00db      	lsls	r3, r3, #3
 801c830:	4413      	add	r3, r2
 801c832:	009b      	lsls	r3, r3, #2
 801c834:	440b      	add	r3, r1
 801c836:	2124      	movs	r1, #36	; 0x24
 801c838:	4618      	mov	r0, r3
 801c83a:	f004 ff35 	bl	80216a8 <_lv_memset_00>
    for(i = 0; i < entry_cnt; i++) {
 801c83e:	89fb      	ldrh	r3, [r7, #14]
 801c840:	3301      	adds	r3, #1
 801c842:	81fb      	strh	r3, [r7, #14]
 801c844:	4b05      	ldr	r3, [pc, #20]	; (801c85c <lv_img_cache_set_size+0xd0>)
 801c846:	881b      	ldrh	r3, [r3, #0]
 801c848:	89fa      	ldrh	r2, [r7, #14]
 801c84a:	429a      	cmp	r2, r3
 801c84c:	d3df      	bcc.n	801c80e <lv_img_cache_set_size+0x82>
    }
}
 801c84e:	3710      	adds	r7, #16
 801c850:	46bd      	mov	sp, r7
 801c852:	bdb0      	pop	{r4, r5, r7, pc}
 801c854:	2000a1d4 	.word	0x2000a1d4
 801c858:	0802e478 	.word	0x0802e478
 801c85c:	2000a148 	.word	0x2000a148

0801c860 <lv_img_cache_invalidate_src>:
 * Invalidate an image source in the cache.
 * Useful if the image source is updated therefore it needs to be cached again.
 * @param src an image source path to a file or pointer to an `lv_img_dsc_t` variable.
 */
void lv_img_cache_invalidate_src(const void * src)
{
 801c860:	b580      	push	{r7, lr}
 801c862:	b084      	sub	sp, #16
 801c864:	af00      	add	r7, sp, #0
 801c866:	6078      	str	r0, [r7, #4]

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
 801c868:	4b27      	ldr	r3, [pc, #156]	; (801c908 <lv_img_cache_invalidate_src+0xa8>)
 801c86a:	681b      	ldr	r3, [r3, #0]
 801c86c:	60bb      	str	r3, [r7, #8]

    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
 801c86e:	2300      	movs	r3, #0
 801c870:	81fb      	strh	r3, [r7, #14]
 801c872:	e03f      	b.n	801c8f4 <lv_img_cache_invalidate_src+0x94>
        if(cache[i].dec_dsc.src == src || src == NULL) {
 801c874:	89fa      	ldrh	r2, [r7, #14]
 801c876:	4613      	mov	r3, r2
 801c878:	00db      	lsls	r3, r3, #3
 801c87a:	4413      	add	r3, r2
 801c87c:	009b      	lsls	r3, r3, #2
 801c87e:	461a      	mov	r2, r3
 801c880:	68bb      	ldr	r3, [r7, #8]
 801c882:	4413      	add	r3, r2
 801c884:	685b      	ldr	r3, [r3, #4]
 801c886:	687a      	ldr	r2, [r7, #4]
 801c888:	429a      	cmp	r2, r3
 801c88a:	d002      	beq.n	801c892 <lv_img_cache_invalidate_src+0x32>
 801c88c:	687b      	ldr	r3, [r7, #4]
 801c88e:	2b00      	cmp	r3, #0
 801c890:	d12d      	bne.n	801c8ee <lv_img_cache_invalidate_src+0x8e>
            if(cache[i].dec_dsc.src != NULL) {
 801c892:	89fa      	ldrh	r2, [r7, #14]
 801c894:	4613      	mov	r3, r2
 801c896:	00db      	lsls	r3, r3, #3
 801c898:	4413      	add	r3, r2
 801c89a:	009b      	lsls	r3, r3, #2
 801c89c:	461a      	mov	r2, r3
 801c89e:	68bb      	ldr	r3, [r7, #8]
 801c8a0:	4413      	add	r3, r2
 801c8a2:	685b      	ldr	r3, [r3, #4]
 801c8a4:	2b00      	cmp	r3, #0
 801c8a6:	d00a      	beq.n	801c8be <lv_img_cache_invalidate_src+0x5e>
                lv_img_decoder_close(&cache[i].dec_dsc);
 801c8a8:	89fa      	ldrh	r2, [r7, #14]
 801c8aa:	4613      	mov	r3, r2
 801c8ac:	00db      	lsls	r3, r3, #3
 801c8ae:	4413      	add	r3, r2
 801c8b0:	009b      	lsls	r3, r3, #2
 801c8b2:	461a      	mov	r2, r3
 801c8b4:	68bb      	ldr	r3, [r7, #8]
 801c8b6:	4413      	add	r3, r2
 801c8b8:	4618      	mov	r0, r3
 801c8ba:	f000 f995 	bl	801cbe8 <lv_img_decoder_close>
            }

            _lv_memset_00(&cache[i].dec_dsc, sizeof(lv_img_decoder_dsc_t));
 801c8be:	89fa      	ldrh	r2, [r7, #14]
 801c8c0:	4613      	mov	r3, r2
 801c8c2:	00db      	lsls	r3, r3, #3
 801c8c4:	4413      	add	r3, r2
 801c8c6:	009b      	lsls	r3, r3, #2
 801c8c8:	461a      	mov	r2, r3
 801c8ca:	68bb      	ldr	r3, [r7, #8]
 801c8cc:	4413      	add	r3, r2
 801c8ce:	2120      	movs	r1, #32
 801c8d0:	4618      	mov	r0, r3
 801c8d2:	f004 fee9 	bl	80216a8 <_lv_memset_00>
            _lv_memset_00(&cache[i], sizeof(lv_img_cache_entry_t));
 801c8d6:	89fa      	ldrh	r2, [r7, #14]
 801c8d8:	4613      	mov	r3, r2
 801c8da:	00db      	lsls	r3, r3, #3
 801c8dc:	4413      	add	r3, r2
 801c8de:	009b      	lsls	r3, r3, #2
 801c8e0:	461a      	mov	r2, r3
 801c8e2:	68bb      	ldr	r3, [r7, #8]
 801c8e4:	4413      	add	r3, r2
 801c8e6:	2124      	movs	r1, #36	; 0x24
 801c8e8:	4618      	mov	r0, r3
 801c8ea:	f004 fedd 	bl	80216a8 <_lv_memset_00>
    for(i = 0; i < entry_cnt; i++) {
 801c8ee:	89fb      	ldrh	r3, [r7, #14]
 801c8f0:	3301      	adds	r3, #1
 801c8f2:	81fb      	strh	r3, [r7, #14]
 801c8f4:	4b05      	ldr	r3, [pc, #20]	; (801c90c <lv_img_cache_invalidate_src+0xac>)
 801c8f6:	881b      	ldrh	r3, [r3, #0]
 801c8f8:	89fa      	ldrh	r2, [r7, #14]
 801c8fa:	429a      	cmp	r2, r3
 801c8fc:	d3ba      	bcc.n	801c874 <lv_img_cache_invalidate_src+0x14>
        }
    }
}
 801c8fe:	bf00      	nop
 801c900:	bf00      	nop
 801c902:	3710      	adds	r7, #16
 801c904:	46bd      	mov	sp, r7
 801c906:	bd80      	pop	{r7, pc}
 801c908:	2000a1d4 	.word	0x2000a1d4
 801c90c:	2000a148 	.word	0x2000a148

0801c910 <lv_color_make>:
#elif LV_COLOR_DEPTH == 32
#define LV_COLOR_MAKE(r8, g8, b8) (_LV_COLOR_MAKE_TYPE_HELPER{{b8, g8, r8, 0xff}}) /*Fix 0xff alpha*/
#endif

static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
 801c910:	b490      	push	{r4, r7}
 801c912:	b082      	sub	sp, #8
 801c914:	af00      	add	r7, sp, #0
 801c916:	4604      	mov	r4, r0
 801c918:	4608      	mov	r0, r1
 801c91a:	4611      	mov	r1, r2
 801c91c:	4622      	mov	r2, r4
 801c91e:	71fa      	strb	r2, [r7, #7]
 801c920:	4602      	mov	r2, r0
 801c922:	71ba      	strb	r2, [r7, #6]
 801c924:	460a      	mov	r2, r1
 801c926:	717a      	strb	r2, [r7, #5]
    return LV_COLOR_MAKE(r, g, b);
 801c928:	797a      	ldrb	r2, [r7, #5]
 801c92a:	08d2      	lsrs	r2, r2, #3
 801c92c:	b2d2      	uxtb	r2, r2
 801c92e:	f002 021f 	and.w	r2, r2, #31
 801c932:	b2d0      	uxtb	r0, r2
 801c934:	79ba      	ldrb	r2, [r7, #6]
 801c936:	0892      	lsrs	r2, r2, #2
 801c938:	b2d2      	uxtb	r2, r2
 801c93a:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 801c93e:	b2d1      	uxtb	r1, r2
 801c940:	79fa      	ldrb	r2, [r7, #7]
 801c942:	08d2      	lsrs	r2, r2, #3
 801c944:	b2d2      	uxtb	r2, r2
 801c946:	f002 021f 	and.w	r2, r2, #31
 801c94a:	b2d2      	uxtb	r2, r2
 801c94c:	f360 0304 	bfi	r3, r0, #0, #5
 801c950:	f361 134a 	bfi	r3, r1, #5, #6
 801c954:	f362 23cf 	bfi	r3, r2, #11, #5
}
 801c958:	4618      	mov	r0, r3
 801c95a:	3708      	adds	r7, #8
 801c95c:	46bd      	mov	sp, r7
 801c95e:	bc90      	pop	{r4, r7}
 801c960:	4770      	bx	lr

0801c962 <_lv_memcpy_small>:
{
 801c962:	b480      	push	{r7}
 801c964:	b087      	sub	sp, #28
 801c966:	af00      	add	r7, sp, #0
 801c968:	60f8      	str	r0, [r7, #12]
 801c96a:	60b9      	str	r1, [r7, #8]
 801c96c:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 801c96e:	68fb      	ldr	r3, [r7, #12]
 801c970:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 801c972:	68bb      	ldr	r3, [r7, #8]
 801c974:	613b      	str	r3, [r7, #16]
    while(len) {
 801c976:	e00c      	b.n	801c992 <_lv_memcpy_small+0x30>
        *d8 = *s8;
 801c978:	693b      	ldr	r3, [r7, #16]
 801c97a:	781a      	ldrb	r2, [r3, #0]
 801c97c:	697b      	ldr	r3, [r7, #20]
 801c97e:	701a      	strb	r2, [r3, #0]
        d8++;
 801c980:	697b      	ldr	r3, [r7, #20]
 801c982:	3301      	adds	r3, #1
 801c984:	617b      	str	r3, [r7, #20]
        s8++;
 801c986:	693b      	ldr	r3, [r7, #16]
 801c988:	3301      	adds	r3, #1
 801c98a:	613b      	str	r3, [r7, #16]
        len--;
 801c98c:	687b      	ldr	r3, [r7, #4]
 801c98e:	3b01      	subs	r3, #1
 801c990:	607b      	str	r3, [r7, #4]
    while(len) {
 801c992:	687b      	ldr	r3, [r7, #4]
 801c994:	2b00      	cmp	r3, #0
 801c996:	d1ef      	bne.n	801c978 <_lv_memcpy_small+0x16>
    return dst;
 801c998:	68fb      	ldr	r3, [r7, #12]
}
 801c99a:	4618      	mov	r0, r3
 801c99c:	371c      	adds	r7, #28
 801c99e:	46bd      	mov	sp, r7
 801c9a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c9a4:	4770      	bx	lr
	...

0801c9a8 <_lv_img_decoder_init>:

/**
 * Initialize the image decoder module
 * */
void _lv_img_decoder_init(void)
{
 801c9a8:	b5b0      	push	{r4, r5, r7, lr}
 801c9aa:	b082      	sub	sp, #8
 801c9ac:	af00      	add	r7, sp, #0
    _lv_ll_init(&LV_GC_ROOT(_lv_img_defoder_ll), sizeof(lv_img_decoder_t));
 801c9ae:	2110      	movs	r1, #16
 801c9b0:	4818      	ldr	r0, [pc, #96]	; (801ca14 <_lv_img_decoder_init+0x6c>)
 801c9b2:	f003 fddd 	bl	8020570 <_lv_ll_init>

    lv_img_decoder_t * decoder;

    /*Create a decoder for the built in color format*/
    decoder = lv_img_decoder_create();
 801c9b6:	f000 f93d 	bl	801cc34 <lv_img_decoder_create>
 801c9ba:	6078      	str	r0, [r7, #4]
    if(decoder == NULL) {
 801c9bc:	687b      	ldr	r3, [r7, #4]
 801c9be:	2b00      	cmp	r3, #0
 801c9c0:	d112      	bne.n	801c9e8 <_lv_img_decoder_init+0x40>
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
        LV_ASSERT_MEM(decoder);
 801c9c2:	6878      	ldr	r0, [r7, #4]
 801c9c4:	f003 fb94 	bl	80200f0 <lv_debug_check_null>
 801c9c8:	4603      	mov	r3, r0
 801c9ca:	f083 0301 	eor.w	r3, r3, #1
 801c9ce:	b2db      	uxtb	r3, r3
 801c9d0:	2b00      	cmp	r3, #0
 801c9d2:	d01a      	beq.n	801ca0a <_lv_img_decoder_init+0x62>
 801c9d4:	687b      	ldr	r3, [r7, #4]
 801c9d6:	2200      	movs	r2, #0
 801c9d8:	461c      	mov	r4, r3
 801c9da:	4615      	mov	r5, r2
 801c9dc:	4622      	mov	r2, r4
 801c9de:	462b      	mov	r3, r5
 801c9e0:	480d      	ldr	r0, [pc, #52]	; (801ca18 <_lv_img_decoder_init+0x70>)
 801c9e2:	f003 fb95 	bl	8020110 <lv_debug_log_error>
 801c9e6:	e7fe      	b.n	801c9e6 <_lv_img_decoder_init+0x3e>
        return;
    }

    lv_img_decoder_set_info_cb(decoder, lv_img_decoder_built_in_info);
 801c9e8:	490c      	ldr	r1, [pc, #48]	; (801ca1c <_lv_img_decoder_init+0x74>)
 801c9ea:	6878      	ldr	r0, [r7, #4]
 801c9ec:	f000 f94e 	bl	801cc8c <lv_img_decoder_set_info_cb>
    lv_img_decoder_set_open_cb(decoder, lv_img_decoder_built_in_open);
 801c9f0:	490b      	ldr	r1, [pc, #44]	; (801ca20 <_lv_img_decoder_init+0x78>)
 801c9f2:	6878      	ldr	r0, [r7, #4]
 801c9f4:	f000 f958 	bl	801cca8 <lv_img_decoder_set_open_cb>
    lv_img_decoder_set_read_line_cb(decoder, lv_img_decoder_built_in_read_line);
 801c9f8:	490a      	ldr	r1, [pc, #40]	; (801ca24 <_lv_img_decoder_init+0x7c>)
 801c9fa:	6878      	ldr	r0, [r7, #4]
 801c9fc:	f000 f962 	bl	801ccc4 <lv_img_decoder_set_read_line_cb>
    lv_img_decoder_set_close_cb(decoder, lv_img_decoder_built_in_close);
 801ca00:	4909      	ldr	r1, [pc, #36]	; (801ca28 <_lv_img_decoder_init+0x80>)
 801ca02:	6878      	ldr	r0, [r7, #4]
 801ca04:	f000 f96c 	bl	801cce0 <lv_img_decoder_set_close_cb>
 801ca08:	e000      	b.n	801ca0c <_lv_img_decoder_init+0x64>
        return;
 801ca0a:	bf00      	nop
}
 801ca0c:	3708      	adds	r7, #8
 801ca0e:	46bd      	mov	sp, r7
 801ca10:	bdb0      	pop	{r4, r5, r7, pc}
 801ca12:	bf00      	nop
 801ca14:	2000a1bc 	.word	0x2000a1bc
 801ca18:	0802e488 	.word	0x0802e488
 801ca1c:	0801ccfd 	.word	0x0801ccfd
 801ca20:	0801ce19 	.word	0x0801ce19
 801ca24:	0801d1d5 	.word	0x0801d1d5
 801ca28:	0801d2f9 	.word	0x0801d2f9

0801ca2c <lv_img_decoder_get_info>:
 * @param src the image source. E.g. file name or variable.
 * @param header the image info will be stored here
 * @return LV_RES_OK: success; LV_RES_INV: wasn't able to get info about the image
 */
lv_res_t lv_img_decoder_get_info(const char * src, lv_img_header_t * header)
{
 801ca2c:	b580      	push	{r7, lr}
 801ca2e:	b084      	sub	sp, #16
 801ca30:	af00      	add	r7, sp, #0
 801ca32:	6078      	str	r0, [r7, #4]
 801ca34:	6039      	str	r1, [r7, #0]
    header->always_zero = 0;
 801ca36:	683a      	ldr	r2, [r7, #0]
 801ca38:	7813      	ldrb	r3, [r2, #0]
 801ca3a:	f36f 1347 	bfc	r3, #5, #3
 801ca3e:	7013      	strb	r3, [r2, #0]
    header->h = 0;
 801ca40:	683a      	ldr	r2, [r7, #0]
 801ca42:	8853      	ldrh	r3, [r2, #2]
 801ca44:	f36f 134f 	bfc	r3, #5, #11
 801ca48:	8053      	strh	r3, [r2, #2]
    header->w = 0;
 801ca4a:	683a      	ldr	r2, [r7, #0]
 801ca4c:	6813      	ldr	r3, [r2, #0]
 801ca4e:	f36f 2394 	bfc	r3, #10, #11
 801ca52:	6013      	str	r3, [r2, #0]
    header->cf = LV_IMG_CF_UNKNOWN;
 801ca54:	683a      	ldr	r2, [r7, #0]
 801ca56:	7813      	ldrb	r3, [r2, #0]
 801ca58:	f36f 0304 	bfc	r3, #0, #5
 801ca5c:	7013      	strb	r3, [r2, #0]

    lv_res_t res = LV_RES_INV;
 801ca5e:	2300      	movs	r3, #0
 801ca60:	73fb      	strb	r3, [r7, #15]
    lv_img_decoder_t * d;
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
 801ca62:	4812      	ldr	r0, [pc, #72]	; (801caac <lv_img_decoder_get_info+0x80>)
 801ca64:	f003 fefa 	bl	802085c <_lv_ll_get_head>
 801ca68:	60b8      	str	r0, [r7, #8]
 801ca6a:	e015      	b.n	801ca98 <lv_img_decoder_get_info+0x6c>
        res = LV_RES_INV;
 801ca6c:	2300      	movs	r3, #0
 801ca6e:	73fb      	strb	r3, [r7, #15]
        if(d->info_cb) {
 801ca70:	68bb      	ldr	r3, [r7, #8]
 801ca72:	681b      	ldr	r3, [r3, #0]
 801ca74:	2b00      	cmp	r3, #0
 801ca76:	d00a      	beq.n	801ca8e <lv_img_decoder_get_info+0x62>
            res = d->info_cb(d, src, header);
 801ca78:	68bb      	ldr	r3, [r7, #8]
 801ca7a:	681b      	ldr	r3, [r3, #0]
 801ca7c:	683a      	ldr	r2, [r7, #0]
 801ca7e:	6879      	ldr	r1, [r7, #4]
 801ca80:	68b8      	ldr	r0, [r7, #8]
 801ca82:	4798      	blx	r3
 801ca84:	4603      	mov	r3, r0
 801ca86:	73fb      	strb	r3, [r7, #15]
            if(res == LV_RES_OK) break;
 801ca88:	7bfb      	ldrb	r3, [r7, #15]
 801ca8a:	2b01      	cmp	r3, #1
 801ca8c:	d008      	beq.n	801caa0 <lv_img_decoder_get_info+0x74>
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
 801ca8e:	68b9      	ldr	r1, [r7, #8]
 801ca90:	4806      	ldr	r0, [pc, #24]	; (801caac <lv_img_decoder_get_info+0x80>)
 801ca92:	f003 ff09 	bl	80208a8 <_lv_ll_get_next>
 801ca96:	60b8      	str	r0, [r7, #8]
 801ca98:	68bb      	ldr	r3, [r7, #8]
 801ca9a:	2b00      	cmp	r3, #0
 801ca9c:	d1e6      	bne.n	801ca6c <lv_img_decoder_get_info+0x40>
 801ca9e:	e000      	b.n	801caa2 <lv_img_decoder_get_info+0x76>
            if(res == LV_RES_OK) break;
 801caa0:	bf00      	nop
        }
    }

    return res;
 801caa2:	7bfb      	ldrb	r3, [r7, #15]
}
 801caa4:	4618      	mov	r0, r3
 801caa6:	3710      	adds	r7, #16
 801caa8:	46bd      	mov	sp, r7
 801caaa:	bd80      	pop	{r7, pc}
 801caac:	2000a1bc 	.word	0x2000a1bc

0801cab0 <lv_img_decoder_open>:
 * @param color The color of the image with `LV_IMG_CF_ALPHA_...`
 * @return LV_RES_OK: opened the image. `dsc->img_data` and `dsc->header` are set.
 *         LV_RES_INV: none of the registered image decoders were able to open the image.
 */
lv_res_t lv_img_decoder_open(lv_img_decoder_dsc_t * dsc, const void * src, lv_color_t color)
{
 801cab0:	b580      	push	{r7, lr}
 801cab2:	b088      	sub	sp, #32
 801cab4:	af00      	add	r7, sp, #0
 801cab6:	60f8      	str	r0, [r7, #12]
 801cab8:	60b9      	str	r1, [r7, #8]
 801caba:	80ba      	strh	r2, [r7, #4]
    dsc->color     = color;
 801cabc:	68fb      	ldr	r3, [r7, #12]
 801cabe:	88ba      	ldrh	r2, [r7, #4]
 801cac0:	811a      	strh	r2, [r3, #8]
    dsc->src_type  = lv_img_src_get_type(src);
 801cac2:	68b8      	ldr	r0, [r7, #8]
 801cac4:	f7f5 fd87 	bl	80125d6 <lv_img_src_get_type>
 801cac8:	4603      	mov	r3, r0
 801caca:	461a      	mov	r2, r3
 801cacc:	68fb      	ldr	r3, [r7, #12]
 801cace:	729a      	strb	r2, [r3, #10]
    dsc->user_data = NULL;
 801cad0:	68fb      	ldr	r3, [r7, #12]
 801cad2:	2200      	movs	r2, #0
 801cad4:	61da      	str	r2, [r3, #28]

    if(dsc->src_type == LV_IMG_SRC_FILE) {
 801cad6:	68fb      	ldr	r3, [r7, #12]
 801cad8:	7a9b      	ldrb	r3, [r3, #10]
 801cada:	2b01      	cmp	r3, #1
 801cadc:	d112      	bne.n	801cb04 <lv_img_decoder_open+0x54>
        size_t fnlen = strlen(src);
 801cade:	68b8      	ldr	r0, [r7, #8]
 801cae0:	f7e3 fb8e 	bl	8000200 <strlen>
 801cae4:	6178      	str	r0, [r7, #20]
        dsc->src = lv_mem_alloc(fnlen + 1);
 801cae6:	697b      	ldr	r3, [r7, #20]
 801cae8:	3301      	adds	r3, #1
 801caea:	4618      	mov	r0, r3
 801caec:	f004 f872 	bl	8020bd4 <lv_mem_alloc>
 801caf0:	4602      	mov	r2, r0
 801caf2:	68fb      	ldr	r3, [r7, #12]
 801caf4:	605a      	str	r2, [r3, #4]
        strcpy((char *)dsc->src, src);
 801caf6:	68fb      	ldr	r3, [r7, #12]
 801caf8:	685b      	ldr	r3, [r3, #4]
 801cafa:	68b9      	ldr	r1, [r7, #8]
 801cafc:	4618      	mov	r0, r3
 801cafe:	f011 fbf7 	bl	802e2f0 <strcpy>
 801cb02:	e002      	b.n	801cb0a <lv_img_decoder_open+0x5a>
    }
    else {
        dsc->src       = src;
 801cb04:	68fb      	ldr	r3, [r7, #12]
 801cb06:	68ba      	ldr	r2, [r7, #8]
 801cb08:	605a      	str	r2, [r3, #4]
    }

    lv_res_t res = LV_RES_INV;
 801cb0a:	2300      	movs	r3, #0
 801cb0c:	77fb      	strb	r3, [r7, #31]

    lv_img_decoder_t * d;
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
 801cb0e:	481f      	ldr	r0, [pc, #124]	; (801cb8c <lv_img_decoder_open+0xdc>)
 801cb10:	f003 fea4 	bl	802085c <_lv_ll_get_head>
 801cb14:	61b8      	str	r0, [r7, #24]
 801cb16:	e02f      	b.n	801cb78 <lv_img_decoder_open+0xc8>
        /*Info an Open callbacks are required*/
        if(d->info_cb == NULL || d->open_cb == NULL) continue;
 801cb18:	69bb      	ldr	r3, [r7, #24]
 801cb1a:	681b      	ldr	r3, [r3, #0]
 801cb1c:	2b00      	cmp	r3, #0
 801cb1e:	d023      	beq.n	801cb68 <lv_img_decoder_open+0xb8>
 801cb20:	69bb      	ldr	r3, [r7, #24]
 801cb22:	685b      	ldr	r3, [r3, #4]
 801cb24:	2b00      	cmp	r3, #0
 801cb26:	d01f      	beq.n	801cb68 <lv_img_decoder_open+0xb8>

        res = d->info_cb(d, src, &dsc->header);
 801cb28:	69bb      	ldr	r3, [r7, #24]
 801cb2a:	681b      	ldr	r3, [r3, #0]
 801cb2c:	68fa      	ldr	r2, [r7, #12]
 801cb2e:	320c      	adds	r2, #12
 801cb30:	68b9      	ldr	r1, [r7, #8]
 801cb32:	69b8      	ldr	r0, [r7, #24]
 801cb34:	4798      	blx	r3
 801cb36:	4603      	mov	r3, r0
 801cb38:	77fb      	strb	r3, [r7, #31]
        if(res != LV_RES_OK) continue;
 801cb3a:	7ffb      	ldrb	r3, [r7, #31]
 801cb3c:	2b01      	cmp	r3, #1
 801cb3e:	d115      	bne.n	801cb6c <lv_img_decoder_open+0xbc>

        dsc->error_msg = NULL;
 801cb40:	68fb      	ldr	r3, [r7, #12]
 801cb42:	2200      	movs	r2, #0
 801cb44:	619a      	str	r2, [r3, #24]
        dsc->img_data  = NULL;
 801cb46:	68fb      	ldr	r3, [r7, #12]
 801cb48:	2200      	movs	r2, #0
 801cb4a:	611a      	str	r2, [r3, #16]
        dsc->decoder   = d;
 801cb4c:	68fb      	ldr	r3, [r7, #12]
 801cb4e:	69ba      	ldr	r2, [r7, #24]
 801cb50:	601a      	str	r2, [r3, #0]

        res = d->open_cb(d, dsc);
 801cb52:	69bb      	ldr	r3, [r7, #24]
 801cb54:	685b      	ldr	r3, [r3, #4]
 801cb56:	68f9      	ldr	r1, [r7, #12]
 801cb58:	69b8      	ldr	r0, [r7, #24]
 801cb5a:	4798      	blx	r3
 801cb5c:	4603      	mov	r3, r0
 801cb5e:	77fb      	strb	r3, [r7, #31]

        /*Opened successfully. It is a good decoder to for this image source*/
        if(res == LV_RES_OK) break;
 801cb60:	7ffb      	ldrb	r3, [r7, #31]
 801cb62:	2b01      	cmp	r3, #1
 801cb64:	d00c      	beq.n	801cb80 <lv_img_decoder_open+0xd0>
 801cb66:	e002      	b.n	801cb6e <lv_img_decoder_open+0xbe>
        if(d->info_cb == NULL || d->open_cb == NULL) continue;
 801cb68:	bf00      	nop
 801cb6a:	e000      	b.n	801cb6e <lv_img_decoder_open+0xbe>
        if(res != LV_RES_OK) continue;
 801cb6c:	bf00      	nop
    _LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d) {
 801cb6e:	69b9      	ldr	r1, [r7, #24]
 801cb70:	4806      	ldr	r0, [pc, #24]	; (801cb8c <lv_img_decoder_open+0xdc>)
 801cb72:	f003 fe99 	bl	80208a8 <_lv_ll_get_next>
 801cb76:	61b8      	str	r0, [r7, #24]
 801cb78:	69bb      	ldr	r3, [r7, #24]
 801cb7a:	2b00      	cmp	r3, #0
 801cb7c:	d1cc      	bne.n	801cb18 <lv_img_decoder_open+0x68>
 801cb7e:	e000      	b.n	801cb82 <lv_img_decoder_open+0xd2>
        if(res == LV_RES_OK) break;
 801cb80:	bf00      	nop
    }

    return res;
 801cb82:	7ffb      	ldrb	r3, [r7, #31]
}
 801cb84:	4618      	mov	r0, r3
 801cb86:	3720      	adds	r7, #32
 801cb88:	46bd      	mov	sp, r7
 801cb8a:	bd80      	pop	{r7, pc}
 801cb8c:	2000a1bc 	.word	0x2000a1bc

0801cb90 <lv_img_decoder_read_line>:
 * @param len number of pixels to read
 * @param buf store the data here
 * @return LV_RES_OK: success; LV_RES_INV: an error occurred
 */
lv_res_t lv_img_decoder_read_line(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t * buf)
{
 801cb90:	b590      	push	{r4, r7, lr}
 801cb92:	b089      	sub	sp, #36	; 0x24
 801cb94:	af02      	add	r7, sp, #8
 801cb96:	60f8      	str	r0, [r7, #12]
 801cb98:	4608      	mov	r0, r1
 801cb9a:	4611      	mov	r1, r2
 801cb9c:	461a      	mov	r2, r3
 801cb9e:	4603      	mov	r3, r0
 801cba0:	817b      	strh	r3, [r7, #10]
 801cba2:	460b      	mov	r3, r1
 801cba4:	813b      	strh	r3, [r7, #8]
 801cba6:	4613      	mov	r3, r2
 801cba8:	80fb      	strh	r3, [r7, #6]
    lv_res_t res = LV_RES_INV;
 801cbaa:	2300      	movs	r3, #0
 801cbac:	75fb      	strb	r3, [r7, #23]
    if(dsc->decoder->read_line_cb) res = dsc->decoder->read_line_cb(dsc->decoder, dsc, x, y, len, buf);
 801cbae:	68fb      	ldr	r3, [r7, #12]
 801cbb0:	681b      	ldr	r3, [r3, #0]
 801cbb2:	689b      	ldr	r3, [r3, #8]
 801cbb4:	2b00      	cmp	r3, #0
 801cbb6:	d012      	beq.n	801cbde <lv_img_decoder_read_line+0x4e>
 801cbb8:	68fb      	ldr	r3, [r7, #12]
 801cbba:	681b      	ldr	r3, [r3, #0]
 801cbbc:	689c      	ldr	r4, [r3, #8]
 801cbbe:	68fb      	ldr	r3, [r7, #12]
 801cbc0:	6818      	ldr	r0, [r3, #0]
 801cbc2:	f9b7 1008 	ldrsh.w	r1, [r7, #8]
 801cbc6:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801cbca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801cbcc:	9301      	str	r3, [sp, #4]
 801cbce:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801cbd2:	9300      	str	r3, [sp, #0]
 801cbd4:	460b      	mov	r3, r1
 801cbd6:	68f9      	ldr	r1, [r7, #12]
 801cbd8:	47a0      	blx	r4
 801cbda:	4603      	mov	r3, r0
 801cbdc:	75fb      	strb	r3, [r7, #23]

    return res;
 801cbde:	7dfb      	ldrb	r3, [r7, #23]
}
 801cbe0:	4618      	mov	r0, r3
 801cbe2:	371c      	adds	r7, #28
 801cbe4:	46bd      	mov	sp, r7
 801cbe6:	bd90      	pop	{r4, r7, pc}

0801cbe8 <lv_img_decoder_close>:
/**
 * Close a decoding session
 * @param dsc pointer to `lv_img_decoder_dsc_t` used in `lv_img_decoder_open`
 */
void lv_img_decoder_close(lv_img_decoder_dsc_t * dsc)
{
 801cbe8:	b580      	push	{r7, lr}
 801cbea:	b082      	sub	sp, #8
 801cbec:	af00      	add	r7, sp, #0
 801cbee:	6078      	str	r0, [r7, #4]
    if(dsc->decoder) {
 801cbf0:	687b      	ldr	r3, [r7, #4]
 801cbf2:	681b      	ldr	r3, [r3, #0]
 801cbf4:	2b00      	cmp	r3, #0
 801cbf6:	d018      	beq.n	801cc2a <lv_img_decoder_close+0x42>
        if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);
 801cbf8:	687b      	ldr	r3, [r7, #4]
 801cbfa:	681b      	ldr	r3, [r3, #0]
 801cbfc:	68db      	ldr	r3, [r3, #12]
 801cbfe:	2b00      	cmp	r3, #0
 801cc00:	d007      	beq.n	801cc12 <lv_img_decoder_close+0x2a>
 801cc02:	687b      	ldr	r3, [r7, #4]
 801cc04:	681b      	ldr	r3, [r3, #0]
 801cc06:	68db      	ldr	r3, [r3, #12]
 801cc08:	687a      	ldr	r2, [r7, #4]
 801cc0a:	6812      	ldr	r2, [r2, #0]
 801cc0c:	6879      	ldr	r1, [r7, #4]
 801cc0e:	4610      	mov	r0, r2
 801cc10:	4798      	blx	r3

        if(dsc->src_type == LV_IMG_SRC_FILE) {
 801cc12:	687b      	ldr	r3, [r7, #4]
 801cc14:	7a9b      	ldrb	r3, [r3, #10]
 801cc16:	2b01      	cmp	r3, #1
 801cc18:	d107      	bne.n	801cc2a <lv_img_decoder_close+0x42>
            lv_mem_free(dsc->src);
 801cc1a:	687b      	ldr	r3, [r7, #4]
 801cc1c:	685b      	ldr	r3, [r3, #4]
 801cc1e:	4618      	mov	r0, r3
 801cc20:	f004 f822 	bl	8020c68 <lv_mem_free>
            dsc->src = NULL;
 801cc24:	687b      	ldr	r3, [r7, #4]
 801cc26:	2200      	movs	r2, #0
 801cc28:	605a      	str	r2, [r3, #4]
        }
    }
}
 801cc2a:	bf00      	nop
 801cc2c:	3708      	adds	r7, #8
 801cc2e:	46bd      	mov	sp, r7
 801cc30:	bd80      	pop	{r7, pc}
	...

0801cc34 <lv_img_decoder_create>:
/**
 * Create a new image decoder
 * @return pointer to the new image decoder
 */
lv_img_decoder_t * lv_img_decoder_create(void)
{
 801cc34:	b5b0      	push	{r4, r5, r7, lr}
 801cc36:	b082      	sub	sp, #8
 801cc38:	af00      	add	r7, sp, #0
    lv_img_decoder_t * decoder;
    decoder = _lv_ll_ins_head(&LV_GC_ROOT(_lv_img_defoder_ll));
 801cc3a:	4812      	ldr	r0, [pc, #72]	; (801cc84 <lv_img_decoder_create+0x50>)
 801cc3c:	f003 fcb1 	bl	80205a2 <_lv_ll_ins_head>
 801cc40:	6078      	str	r0, [r7, #4]
    LV_ASSERT_MEM(decoder);
 801cc42:	6878      	ldr	r0, [r7, #4]
 801cc44:	f003 fa54 	bl	80200f0 <lv_debug_check_null>
 801cc48:	4603      	mov	r3, r0
 801cc4a:	f083 0301 	eor.w	r3, r3, #1
 801cc4e:	b2db      	uxtb	r3, r3
 801cc50:	2b00      	cmp	r3, #0
 801cc52:	d009      	beq.n	801cc68 <lv_img_decoder_create+0x34>
 801cc54:	687b      	ldr	r3, [r7, #4]
 801cc56:	2200      	movs	r2, #0
 801cc58:	461c      	mov	r4, r3
 801cc5a:	4615      	mov	r5, r2
 801cc5c:	4622      	mov	r2, r4
 801cc5e:	462b      	mov	r3, r5
 801cc60:	4809      	ldr	r0, [pc, #36]	; (801cc88 <lv_img_decoder_create+0x54>)
 801cc62:	f003 fa55 	bl	8020110 <lv_debug_log_error>
 801cc66:	e7fe      	b.n	801cc66 <lv_img_decoder_create+0x32>
    if(decoder == NULL) return NULL;
 801cc68:	687b      	ldr	r3, [r7, #4]
 801cc6a:	2b00      	cmp	r3, #0
 801cc6c:	d101      	bne.n	801cc72 <lv_img_decoder_create+0x3e>
 801cc6e:	2300      	movs	r3, #0
 801cc70:	e004      	b.n	801cc7c <lv_img_decoder_create+0x48>

    _lv_memset_00(decoder, sizeof(lv_img_decoder_t));
 801cc72:	2110      	movs	r1, #16
 801cc74:	6878      	ldr	r0, [r7, #4]
 801cc76:	f004 fd17 	bl	80216a8 <_lv_memset_00>

    return decoder;
 801cc7a:	687b      	ldr	r3, [r7, #4]
}
 801cc7c:	4618      	mov	r0, r3
 801cc7e:	3708      	adds	r7, #8
 801cc80:	46bd      	mov	sp, r7
 801cc82:	bdb0      	pop	{r4, r5, r7, pc}
 801cc84:	2000a1bc 	.word	0x2000a1bc
 801cc88:	0802e488 	.word	0x0802e488

0801cc8c <lv_img_decoder_set_info_cb>:
 * Set a callback to get information about the image
 * @param decoder pointer to an image decoder
 * @param info_cb a function to collect info about an image (fill an `lv_img_header_t` struct)
 */
void lv_img_decoder_set_info_cb(lv_img_decoder_t * decoder, lv_img_decoder_info_f_t info_cb)
{
 801cc8c:	b480      	push	{r7}
 801cc8e:	b083      	sub	sp, #12
 801cc90:	af00      	add	r7, sp, #0
 801cc92:	6078      	str	r0, [r7, #4]
 801cc94:	6039      	str	r1, [r7, #0]
    decoder->info_cb = info_cb;
 801cc96:	687b      	ldr	r3, [r7, #4]
 801cc98:	683a      	ldr	r2, [r7, #0]
 801cc9a:	601a      	str	r2, [r3, #0]
}
 801cc9c:	bf00      	nop
 801cc9e:	370c      	adds	r7, #12
 801cca0:	46bd      	mov	sp, r7
 801cca2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cca6:	4770      	bx	lr

0801cca8 <lv_img_decoder_set_open_cb>:
 * Set a callback to open an image
 * @param decoder pointer to an image decoder
 * @param open_cb a function to open an image
 */
void lv_img_decoder_set_open_cb(lv_img_decoder_t * decoder, lv_img_decoder_open_f_t open_cb)
{
 801cca8:	b480      	push	{r7}
 801ccaa:	b083      	sub	sp, #12
 801ccac:	af00      	add	r7, sp, #0
 801ccae:	6078      	str	r0, [r7, #4]
 801ccb0:	6039      	str	r1, [r7, #0]
    decoder->open_cb = open_cb;
 801ccb2:	687b      	ldr	r3, [r7, #4]
 801ccb4:	683a      	ldr	r2, [r7, #0]
 801ccb6:	605a      	str	r2, [r3, #4]
}
 801ccb8:	bf00      	nop
 801ccba:	370c      	adds	r7, #12
 801ccbc:	46bd      	mov	sp, r7
 801ccbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ccc2:	4770      	bx	lr

0801ccc4 <lv_img_decoder_set_read_line_cb>:
 * Set a callback to a decoded line of an image
 * @param decoder pointer to an image decoder
 * @param read_line_cb a function to read a line of an image
 */
void lv_img_decoder_set_read_line_cb(lv_img_decoder_t * decoder, lv_img_decoder_read_line_f_t read_line_cb)
{
 801ccc4:	b480      	push	{r7}
 801ccc6:	b083      	sub	sp, #12
 801ccc8:	af00      	add	r7, sp, #0
 801ccca:	6078      	str	r0, [r7, #4]
 801cccc:	6039      	str	r1, [r7, #0]
    decoder->read_line_cb = read_line_cb;
 801ccce:	687b      	ldr	r3, [r7, #4]
 801ccd0:	683a      	ldr	r2, [r7, #0]
 801ccd2:	609a      	str	r2, [r3, #8]
}
 801ccd4:	bf00      	nop
 801ccd6:	370c      	adds	r7, #12
 801ccd8:	46bd      	mov	sp, r7
 801ccda:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ccde:	4770      	bx	lr

0801cce0 <lv_img_decoder_set_close_cb>:
 * Set a callback to close a decoding session. E.g. close files and free other resources.
 * @param decoder pointer to an image decoder
 * @param close_cb a function to close a decoding session
 */
void lv_img_decoder_set_close_cb(lv_img_decoder_t * decoder, lv_img_decoder_close_f_t close_cb)
{
 801cce0:	b480      	push	{r7}
 801cce2:	b083      	sub	sp, #12
 801cce4:	af00      	add	r7, sp, #0
 801cce6:	6078      	str	r0, [r7, #4]
 801cce8:	6039      	str	r1, [r7, #0]
    decoder->close_cb = close_cb;
 801ccea:	687b      	ldr	r3, [r7, #4]
 801ccec:	683a      	ldr	r2, [r7, #0]
 801ccee:	60da      	str	r2, [r3, #12]
}
 801ccf0:	bf00      	nop
 801ccf2:	370c      	adds	r7, #12
 801ccf4:	46bd      	mov	sp, r7
 801ccf6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ccfa:	4770      	bx	lr

0801ccfc <lv_img_decoder_built_in_info>:
 * @param src the image source: pointer to an `lv_img_dsc_t` variable, a file path or a symbol
 * @param header store the image data here
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_info(lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header)
{
 801ccfc:	b580      	push	{r7, lr}
 801ccfe:	b088      	sub	sp, #32
 801cd00:	af00      	add	r7, sp, #0
 801cd02:	60f8      	str	r0, [r7, #12]
 801cd04:	60b9      	str	r1, [r7, #8]
 801cd06:	607a      	str	r2, [r7, #4]
    (void)decoder; /*Unused*/

    lv_img_src_t src_type = lv_img_src_get_type(src);
 801cd08:	68b8      	ldr	r0, [r7, #8]
 801cd0a:	f7f5 fc64 	bl	80125d6 <lv_img_src_get_type>
 801cd0e:	4603      	mov	r3, r0
 801cd10:	77fb      	strb	r3, [r7, #31]
    if(src_type == LV_IMG_SRC_VARIABLE) {
 801cd12:	7ffb      	ldrb	r3, [r7, #31]
 801cd14:	2b00      	cmp	r3, #0
 801cd16:	d12c      	bne.n	801cd72 <lv_img_decoder_built_in_info+0x76>
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
 801cd18:	68bb      	ldr	r3, [r7, #8]
 801cd1a:	781b      	ldrb	r3, [r3, #0]
 801cd1c:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801cd20:	b2db      	uxtb	r3, r3
 801cd22:	777b      	strb	r3, [r7, #29]
        if(cf < CF_BUILT_IN_FIRST || cf > CF_BUILT_IN_LAST) return LV_RES_INV;
 801cd24:	7f7b      	ldrb	r3, [r7, #29]
 801cd26:	2b03      	cmp	r3, #3
 801cd28:	d902      	bls.n	801cd30 <lv_img_decoder_built_in_info+0x34>
 801cd2a:	7f7b      	ldrb	r3, [r7, #29]
 801cd2c:	2b0e      	cmp	r3, #14
 801cd2e:	d901      	bls.n	801cd34 <lv_img_decoder_built_in_info+0x38>
 801cd30:	2300      	movs	r3, #0
 801cd32:	e06d      	b.n	801ce10 <lv_img_decoder_built_in_info+0x114>

        header->w  = ((lv_img_dsc_t *)src)->header.w;
 801cd34:	68bb      	ldr	r3, [r7, #8]
 801cd36:	681b      	ldr	r3, [r3, #0]
 801cd38:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801cd3c:	b299      	uxth	r1, r3
 801cd3e:	687a      	ldr	r2, [r7, #4]
 801cd40:	6813      	ldr	r3, [r2, #0]
 801cd42:	f361 2394 	bfi	r3, r1, #10, #11
 801cd46:	6013      	str	r3, [r2, #0]
        header->h  = ((lv_img_dsc_t *)src)->header.h;
 801cd48:	68bb      	ldr	r3, [r7, #8]
 801cd4a:	885b      	ldrh	r3, [r3, #2]
 801cd4c:	f3c3 134a 	ubfx	r3, r3, #5, #11
 801cd50:	b299      	uxth	r1, r3
 801cd52:	687a      	ldr	r2, [r7, #4]
 801cd54:	8853      	ldrh	r3, [r2, #2]
 801cd56:	f361 134f 	bfi	r3, r1, #5, #11
 801cd5a:	8053      	strh	r3, [r2, #2]
        header->cf = ((lv_img_dsc_t *)src)->header.cf;
 801cd5c:	68bb      	ldr	r3, [r7, #8]
 801cd5e:	781b      	ldrb	r3, [r3, #0]
 801cd60:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801cd64:	b2d9      	uxtb	r1, r3
 801cd66:	687a      	ldr	r2, [r7, #4]
 801cd68:	7813      	ldrb	r3, [r2, #0]
 801cd6a:	f361 0304 	bfi	r3, r1, #0, #5
 801cd6e:	7013      	strb	r3, [r2, #0]
 801cd70:	e04d      	b.n	801ce0e <lv_img_decoder_built_in_info+0x112>
    }
#if LV_USE_FILESYSTEM
    else if(src_type == LV_IMG_SRC_FILE) {
 801cd72:	7ffb      	ldrb	r3, [r7, #31]
 801cd74:	2b01      	cmp	r3, #1
 801cd76:	d132      	bne.n	801cdde <lv_img_decoder_built_in_info+0xe2>
        lv_fs_file_t file;
        lv_fs_res_t res;
        uint32_t rn;
        res = lv_fs_open(&file, src, LV_FS_MODE_RD);
 801cd78:	f107 0314 	add.w	r3, r7, #20
 801cd7c:	2202      	movs	r2, #2
 801cd7e:	68b9      	ldr	r1, [r7, #8]
 801cd80:	4618      	mov	r0, r3
 801cd82:	f003 fa67 	bl	8020254 <lv_fs_open>
 801cd86:	4603      	mov	r3, r0
 801cd88:	77bb      	strb	r3, [r7, #30]
        if(res == LV_FS_RES_OK) {
 801cd8a:	7fbb      	ldrb	r3, [r7, #30]
 801cd8c:	2b00      	cmp	r3, #0
 801cd8e:	d116      	bne.n	801cdbe <lv_img_decoder_built_in_info+0xc2>
            res = lv_fs_read(&file, header, sizeof(lv_img_header_t), &rn);
 801cd90:	f107 0310 	add.w	r3, r7, #16
 801cd94:	f107 0014 	add.w	r0, r7, #20
 801cd98:	2204      	movs	r2, #4
 801cd9a:	6879      	ldr	r1, [r7, #4]
 801cd9c:	f003 fb1d 	bl	80203da <lv_fs_read>
 801cda0:	4603      	mov	r3, r0
 801cda2:	77bb      	strb	r3, [r7, #30]
            lv_fs_close(&file);
 801cda4:	f107 0314 	add.w	r3, r7, #20
 801cda8:	4618      	mov	r0, r3
 801cdaa:	f003 fae7 	bl	802037c <lv_fs_close>
            if(res != LV_FS_RES_OK || rn != sizeof(lv_img_header_t)) {
 801cdae:	7fbb      	ldrb	r3, [r7, #30]
 801cdb0:	2b00      	cmp	r3, #0
 801cdb2:	d102      	bne.n	801cdba <lv_img_decoder_built_in_info+0xbe>
 801cdb4:	693b      	ldr	r3, [r7, #16]
 801cdb6:	2b04      	cmp	r3, #4
 801cdb8:	d001      	beq.n	801cdbe <lv_img_decoder_built_in_info+0xc2>
                LV_LOG_WARN("Image get info get read file header");
                return LV_RES_INV;
 801cdba:	2300      	movs	r3, #0
 801cdbc:	e028      	b.n	801ce10 <lv_img_decoder_built_in_info+0x114>
            }
        }

        if(header->cf < CF_BUILT_IN_FIRST || header->cf > CF_BUILT_IN_LAST) return LV_RES_INV;
 801cdbe:	687b      	ldr	r3, [r7, #4]
 801cdc0:	781b      	ldrb	r3, [r3, #0]
 801cdc2:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801cdc6:	b2db      	uxtb	r3, r3
 801cdc8:	2b03      	cmp	r3, #3
 801cdca:	d906      	bls.n	801cdda <lv_img_decoder_built_in_info+0xde>
 801cdcc:	687b      	ldr	r3, [r7, #4]
 801cdce:	781b      	ldrb	r3, [r3, #0]
 801cdd0:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801cdd4:	b2db      	uxtb	r3, r3
 801cdd6:	2b0e      	cmp	r3, #14
 801cdd8:	d919      	bls.n	801ce0e <lv_img_decoder_built_in_info+0x112>
 801cdda:	2300      	movs	r3, #0
 801cddc:	e018      	b.n	801ce10 <lv_img_decoder_built_in_info+0x114>

    }
#endif
    else if(src_type == LV_IMG_SRC_SYMBOL) {
 801cdde:	7ffb      	ldrb	r3, [r7, #31]
 801cde0:	2b02      	cmp	r3, #2
 801cde2:	d112      	bne.n	801ce0a <lv_img_decoder_built_in_info+0x10e>
        /*The size depend on the font but it is unknown here. It should be handled outside of the
         * function*/
        header->w = 1;
 801cde4:	687a      	ldr	r2, [r7, #4]
 801cde6:	6813      	ldr	r3, [r2, #0]
 801cde8:	2101      	movs	r1, #1
 801cdea:	f361 2394 	bfi	r3, r1, #10, #11
 801cdee:	6013      	str	r3, [r2, #0]
        header->h = 1;
 801cdf0:	687a      	ldr	r2, [r7, #4]
 801cdf2:	8853      	ldrh	r3, [r2, #2]
 801cdf4:	2101      	movs	r1, #1
 801cdf6:	f361 134f 	bfi	r3, r1, #5, #11
 801cdfa:	8053      	strh	r3, [r2, #2]
        /* Symbols always have transparent parts. Important because of cover check in the design
         * function. The actual value doesn't matter because lv_draw_label will draw it*/
        header->cf = LV_IMG_CF_ALPHA_1BIT;
 801cdfc:	687a      	ldr	r2, [r7, #4]
 801cdfe:	7813      	ldrb	r3, [r2, #0]
 801ce00:	210b      	movs	r1, #11
 801ce02:	f361 0304 	bfi	r3, r1, #0, #5
 801ce06:	7013      	strb	r3, [r2, #0]
 801ce08:	e001      	b.n	801ce0e <lv_img_decoder_built_in_info+0x112>
    }
    else {
        LV_LOG_WARN("Image get info found unknown src type");
        return LV_RES_INV;
 801ce0a:	2300      	movs	r3, #0
 801ce0c:	e000      	b.n	801ce10 <lv_img_decoder_built_in_info+0x114>
    }
    return LV_RES_OK;
 801ce0e:	2301      	movs	r3, #1
}
 801ce10:	4618      	mov	r0, r3
 801ce12:	3720      	adds	r7, #32
 801ce14:	46bd      	mov	sp, r7
 801ce16:	bd80      	pop	{r7, pc}

0801ce18 <lv_img_decoder_built_in_open>:
 * @param decoder the decoder where this function belongs
 * @param dsc pointer to decoder descriptor. `src`, `style` are already initialized in it.
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
 801ce18:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 801ce1c:	b092      	sub	sp, #72	; 0x48
 801ce1e:	af00      	add	r7, sp, #0
 801ce20:	6178      	str	r0, [r7, #20]
 801ce22:	6139      	str	r1, [r7, #16]
    /*Open the file if it's a file*/
    if(dsc->src_type == LV_IMG_SRC_FILE) {
 801ce24:	693b      	ldr	r3, [r7, #16]
 801ce26:	7a9b      	ldrb	r3, [r3, #10]
 801ce28:	2b01      	cmp	r3, #1
 801ce2a:	d17f      	bne.n	801cf2c <lv_img_decoder_built_in_open+0x114>
#if LV_USE_FILESYSTEM

        /*Support only "*.bin" files*/
        if(strcmp(lv_fs_get_ext(dsc->src), "bin")) return LV_RES_INV;
 801ce2c:	693b      	ldr	r3, [r7, #16]
 801ce2e:	685b      	ldr	r3, [r3, #4]
 801ce30:	4618      	mov	r0, r3
 801ce32:	f003 fb4b 	bl	80204cc <lv_fs_get_ext>
 801ce36:	4603      	mov	r3, r0
 801ce38:	49a8      	ldr	r1, [pc, #672]	; (801d0dc <lv_img_decoder_built_in_open+0x2c4>)
 801ce3a:	4618      	mov	r0, r3
 801ce3c:	f7e3 f9d6 	bl	80001ec <strcmp>
 801ce40:	4603      	mov	r3, r0
 801ce42:	2b00      	cmp	r3, #0
 801ce44:	d001      	beq.n	801ce4a <lv_img_decoder_built_in_open+0x32>
 801ce46:	2300      	movs	r3, #0
 801ce48:	e1bf      	b.n	801d1ca <lv_img_decoder_built_in_open+0x3b2>

        lv_fs_file_t f;
        lv_fs_res_t res = lv_fs_open(&f, dsc->src, LV_FS_MODE_RD);
 801ce4a:	693b      	ldr	r3, [r7, #16]
 801ce4c:	6859      	ldr	r1, [r3, #4]
 801ce4e:	f107 0320 	add.w	r3, r7, #32
 801ce52:	2202      	movs	r2, #2
 801ce54:	4618      	mov	r0, r3
 801ce56:	f003 f9fd 	bl	8020254 <lv_fs_open>
 801ce5a:	4603      	mov	r3, r0
 801ce5c:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
        if(res != LV_FS_RES_OK) {
 801ce60:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801ce64:	2b00      	cmp	r3, #0
 801ce66:	d001      	beq.n	801ce6c <lv_img_decoder_built_in_open+0x54>
            LV_LOG_WARN("Built-in image decoder can't open the file");
            return LV_RES_INV;
 801ce68:	2300      	movs	r3, #0
 801ce6a:	e1ae      	b.n	801d1ca <lv_img_decoder_built_in_open+0x3b2>
        }

        /*If the file was open successfully save the file descriptor*/
        if(dsc->user_data == NULL) {
 801ce6c:	693b      	ldr	r3, [r7, #16]
 801ce6e:	69db      	ldr	r3, [r3, #28]
 801ce70:	2b00      	cmp	r3, #0
 801ce72:	d128      	bne.n	801cec6 <lv_img_decoder_built_in_open+0xae>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
 801ce74:	200c      	movs	r0, #12
 801ce76:	f003 fead 	bl	8020bd4 <lv_mem_alloc>
 801ce7a:	4602      	mov	r2, r0
 801ce7c:	693b      	ldr	r3, [r7, #16]
 801ce7e:	61da      	str	r2, [r3, #28]
            LV_ASSERT_MEM(dsc->user_data);
 801ce80:	693b      	ldr	r3, [r7, #16]
 801ce82:	69db      	ldr	r3, [r3, #28]
 801ce84:	4618      	mov	r0, r3
 801ce86:	f003 f933 	bl	80200f0 <lv_debug_check_null>
 801ce8a:	4603      	mov	r3, r0
 801ce8c:	f083 0301 	eor.w	r3, r3, #1
 801ce90:	b2db      	uxtb	r3, r3
 801ce92:	2b00      	cmp	r3, #0
 801ce94:	d00b      	beq.n	801ceae <lv_img_decoder_built_in_open+0x96>
 801ce96:	693b      	ldr	r3, [r7, #16]
 801ce98:	69db      	ldr	r3, [r3, #28]
 801ce9a:	461a      	mov	r2, r3
 801ce9c:	2300      	movs	r3, #0
 801ce9e:	60ba      	str	r2, [r7, #8]
 801cea0:	60fb      	str	r3, [r7, #12]
 801cea2:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 801cea6:	488e      	ldr	r0, [pc, #568]	; (801d0e0 <lv_img_decoder_built_in_open+0x2c8>)
 801cea8:	f003 f932 	bl	8020110 <lv_debug_log_error>
 801ceac:	e7fe      	b.n	801ceac <lv_img_decoder_built_in_open+0x94>
            if(dsc->user_data == NULL) {
 801ceae:	693b      	ldr	r3, [r7, #16]
 801ceb0:	69db      	ldr	r3, [r3, #28]
 801ceb2:	2b00      	cmp	r3, #0
 801ceb4:	d101      	bne.n	801ceba <lv_img_decoder_built_in_open+0xa2>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
                return LV_RES_INV;
 801ceb6:	2300      	movs	r3, #0
 801ceb8:	e187      	b.n	801d1ca <lv_img_decoder_built_in_open+0x3b2>
            }
            _lv_memset_00(dsc->user_data, sizeof(lv_img_decoder_built_in_data_t));
 801ceba:	693b      	ldr	r3, [r7, #16]
 801cebc:	69db      	ldr	r3, [r3, #28]
 801cebe:	210c      	movs	r1, #12
 801cec0:	4618      	mov	r0, r3
 801cec2:	f004 fbf1 	bl	80216a8 <_lv_memset_00>
        }

        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801cec6:	693b      	ldr	r3, [r7, #16]
 801cec8:	69db      	ldr	r3, [r3, #28]
 801ceca:	63bb      	str	r3, [r7, #56]	; 0x38
        user_data->f = lv_mem_alloc(sizeof(f));
 801cecc:	2008      	movs	r0, #8
 801cece:	f003 fe81 	bl	8020bd4 <lv_mem_alloc>
 801ced2:	4602      	mov	r2, r0
 801ced4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801ced6:	601a      	str	r2, [r3, #0]
        LV_ASSERT_MEM(user_data->f);
 801ced8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801ceda:	681b      	ldr	r3, [r3, #0]
 801cedc:	4618      	mov	r0, r3
 801cede:	f003 f907 	bl	80200f0 <lv_debug_check_null>
 801cee2:	4603      	mov	r3, r0
 801cee4:	f083 0301 	eor.w	r3, r3, #1
 801cee8:	b2db      	uxtb	r3, r3
 801ceea:	2b00      	cmp	r3, #0
 801ceec:	d00b      	beq.n	801cf06 <lv_img_decoder_built_in_open+0xee>
 801ceee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cef0:	681b      	ldr	r3, [r3, #0]
 801cef2:	461a      	mov	r2, r3
 801cef4:	2300      	movs	r3, #0
 801cef6:	603a      	str	r2, [r7, #0]
 801cef8:	607b      	str	r3, [r7, #4]
 801cefa:	e9d7 2300 	ldrd	r2, r3, [r7]
 801cefe:	4878      	ldr	r0, [pc, #480]	; (801d0e0 <lv_img_decoder_built_in_open+0x2c8>)
 801cf00:	f003 f906 	bl	8020110 <lv_debug_log_error>
 801cf04:	e7fe      	b.n	801cf04 <lv_img_decoder_built_in_open+0xec>
        if(user_data->f == NULL) {
 801cf06:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cf08:	681b      	ldr	r3, [r3, #0]
 801cf0a:	2b00      	cmp	r3, #0
 801cf0c:	d105      	bne.n	801cf1a <lv_img_decoder_built_in_open+0x102>
            LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
            lv_img_decoder_built_in_close(decoder, dsc);
 801cf0e:	6939      	ldr	r1, [r7, #16]
 801cf10:	6978      	ldr	r0, [r7, #20]
 801cf12:	f000 f9f1 	bl	801d2f8 <lv_img_decoder_built_in_close>
            return LV_RES_INV;
 801cf16:	2300      	movs	r3, #0
 801cf18:	e157      	b.n	801d1ca <lv_img_decoder_built_in_open+0x3b2>
        }

        _lv_memcpy_small(user_data->f, &f, sizeof(f));
 801cf1a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801cf1c:	681b      	ldr	r3, [r3, #0]
 801cf1e:	f107 0120 	add.w	r1, r7, #32
 801cf22:	2208      	movs	r2, #8
 801cf24:	4618      	mov	r0, r3
 801cf26:	f7ff fd1c 	bl	801c962 <_lv_memcpy_small>
 801cf2a:	e00a      	b.n	801cf42 <lv_img_decoder_built_in_open+0x12a>
#else
        LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
        return LV_RES_INV;
#endif
    }
    else if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 801cf2c:	693b      	ldr	r3, [r7, #16]
 801cf2e:	7a9b      	ldrb	r3, [r3, #10]
 801cf30:	2b00      	cmp	r3, #0
 801cf32:	d106      	bne.n	801cf42 <lv_img_decoder_built_in_open+0x12a>
        /*The variables should have valid data*/
        if(((lv_img_dsc_t *)dsc->src)->data == NULL) {
 801cf34:	693b      	ldr	r3, [r7, #16]
 801cf36:	685b      	ldr	r3, [r3, #4]
 801cf38:	689b      	ldr	r3, [r3, #8]
 801cf3a:	2b00      	cmp	r3, #0
 801cf3c:	d101      	bne.n	801cf42 <lv_img_decoder_built_in_open+0x12a>
            return LV_RES_INV;
 801cf3e:	2300      	movs	r3, #0
 801cf40:	e143      	b.n	801d1ca <lv_img_decoder_built_in_open+0x3b2>
        }
    }

    lv_img_cf_t cf = dsc->header.cf;
 801cf42:	693b      	ldr	r3, [r7, #16]
 801cf44:	7b1b      	ldrb	r3, [r3, #12]
 801cf46:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801cf4a:	b2db      	uxtb	r3, r3
 801cf4c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    /*Process true color formats*/
    if(cf == LV_IMG_CF_TRUE_COLOR || cf == LV_IMG_CF_TRUE_COLOR_ALPHA || cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
 801cf50:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801cf54:	2b04      	cmp	r3, #4
 801cf56:	d007      	beq.n	801cf68 <lv_img_decoder_built_in_open+0x150>
 801cf58:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801cf5c:	2b05      	cmp	r3, #5
 801cf5e:	d003      	beq.n	801cf68 <lv_img_decoder_built_in_open+0x150>
 801cf60:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801cf64:	2b06      	cmp	r3, #6
 801cf66:	d10f      	bne.n	801cf88 <lv_img_decoder_built_in_open+0x170>
        if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 801cf68:	693b      	ldr	r3, [r7, #16]
 801cf6a:	7a9b      	ldrb	r3, [r3, #10]
 801cf6c:	2b00      	cmp	r3, #0
 801cf6e:	d106      	bne.n	801cf7e <lv_img_decoder_built_in_open+0x166>
            /* In case of uncompressed formats the image stored in the ROM/RAM.
             * So simply give its pointer*/
            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
 801cf70:	693b      	ldr	r3, [r7, #16]
 801cf72:	685b      	ldr	r3, [r3, #4]
 801cf74:	689a      	ldr	r2, [r3, #8]
 801cf76:	693b      	ldr	r3, [r7, #16]
 801cf78:	611a      	str	r2, [r3, #16]
            return LV_RES_OK;
 801cf7a:	2301      	movs	r3, #1
 801cf7c:	e125      	b.n	801d1ca <lv_img_decoder_built_in_open+0x3b2>
        }
        else {
            /*If it's a file it need to be read line by line later*/
            dsc->img_data = NULL;
 801cf7e:	693b      	ldr	r3, [r7, #16]
 801cf80:	2200      	movs	r2, #0
 801cf82:	611a      	str	r2, [r3, #16]
            return LV_RES_OK;
 801cf84:	2301      	movs	r3, #1
 801cf86:	e120      	b.n	801d1ca <lv_img_decoder_built_in_open+0x3b2>
        }
    }
    /*Process indexed images. Build a palette*/
    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||
 801cf88:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801cf8c:	2b07      	cmp	r3, #7
 801cf8e:	d00c      	beq.n	801cfaa <lv_img_decoder_built_in_open+0x192>
 801cf90:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801cf94:	2b08      	cmp	r3, #8
 801cf96:	d008      	beq.n	801cfaa <lv_img_decoder_built_in_open+0x192>
 801cf98:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801cf9c:	2b09      	cmp	r3, #9
 801cf9e:	d004      	beq.n	801cfaa <lv_img_decoder_built_in_open+0x192>
 801cfa0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801cfa4:	2b0a      	cmp	r3, #10
 801cfa6:	f040 80f6 	bne.w	801d196 <lv_img_decoder_built_in_open+0x37e>
            cf == LV_IMG_CF_INDEXED_8BIT) {

#if LV_IMG_CF_INDEXED
        uint8_t px_size       = lv_img_cf_get_px_size(cf);
 801cfaa:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801cfae:	4618      	mov	r0, r3
 801cfb0:	f7f5 fa80 	bl	80124b4 <lv_img_cf_get_px_size>
 801cfb4:	4603      	mov	r3, r0
 801cfb6:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
        uint32_t palette_size = 1 << px_size;
 801cfba:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
 801cfbe:	2201      	movs	r2, #1
 801cfc0:	fa02 f303 	lsl.w	r3, r2, r3
 801cfc4:	633b      	str	r3, [r7, #48]	; 0x30

        /*Allocate the palette*/
        if(dsc->user_data == NULL) {
 801cfc6:	693b      	ldr	r3, [r7, #16]
 801cfc8:	69db      	ldr	r3, [r3, #28]
 801cfca:	2b00      	cmp	r3, #0
 801cfcc:	d12c      	bne.n	801d028 <lv_img_decoder_built_in_open+0x210>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
 801cfce:	200c      	movs	r0, #12
 801cfd0:	f003 fe00 	bl	8020bd4 <lv_mem_alloc>
 801cfd4:	4602      	mov	r2, r0
 801cfd6:	693b      	ldr	r3, [r7, #16]
 801cfd8:	61da      	str	r2, [r3, #28]
            LV_ASSERT_MEM(dsc->user_data);
 801cfda:	693b      	ldr	r3, [r7, #16]
 801cfdc:	69db      	ldr	r3, [r3, #28]
 801cfde:	4618      	mov	r0, r3
 801cfe0:	f003 f886 	bl	80200f0 <lv_debug_check_null>
 801cfe4:	4603      	mov	r3, r0
 801cfe6:	f083 0301 	eor.w	r3, r3, #1
 801cfea:	b2db      	uxtb	r3, r3
 801cfec:	2b00      	cmp	r3, #0
 801cfee:	d00b      	beq.n	801d008 <lv_img_decoder_built_in_open+0x1f0>
 801cff0:	693b      	ldr	r3, [r7, #16]
 801cff2:	69db      	ldr	r3, [r3, #28]
 801cff4:	461a      	mov	r2, r3
 801cff6:	2300      	movs	r3, #0
 801cff8:	4692      	mov	sl, r2
 801cffa:	469b      	mov	fp, r3
 801cffc:	4652      	mov	r2, sl
 801cffe:	465b      	mov	r3, fp
 801d000:	4837      	ldr	r0, [pc, #220]	; (801d0e0 <lv_img_decoder_built_in_open+0x2c8>)
 801d002:	f003 f885 	bl	8020110 <lv_debug_log_error>
 801d006:	e7fe      	b.n	801d006 <lv_img_decoder_built_in_open+0x1ee>
            if(dsc->user_data == NULL) {
 801d008:	693b      	ldr	r3, [r7, #16]
 801d00a:	69db      	ldr	r3, [r3, #28]
 801d00c:	2b00      	cmp	r3, #0
 801d00e:	d105      	bne.n	801d01c <lv_img_decoder_built_in_open+0x204>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
                lv_img_decoder_built_in_close(decoder, dsc);
 801d010:	6939      	ldr	r1, [r7, #16]
 801d012:	6978      	ldr	r0, [r7, #20]
 801d014:	f000 f970 	bl	801d2f8 <lv_img_decoder_built_in_close>
                return LV_RES_INV;
 801d018:	2300      	movs	r3, #0
 801d01a:	e0d6      	b.n	801d1ca <lv_img_decoder_built_in_open+0x3b2>
            }
            _lv_memset_00(dsc->user_data, sizeof(lv_img_decoder_built_in_data_t));
 801d01c:	693b      	ldr	r3, [r7, #16]
 801d01e:	69db      	ldr	r3, [r3, #28]
 801d020:	210c      	movs	r1, #12
 801d022:	4618      	mov	r0, r3
 801d024:	f004 fb40 	bl	80216a8 <_lv_memset_00>
        }

        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801d028:	693b      	ldr	r3, [r7, #16]
 801d02a:	69db      	ldr	r3, [r3, #28]
 801d02c:	62fb      	str	r3, [r7, #44]	; 0x2c
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
 801d02e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d030:	005b      	lsls	r3, r3, #1
 801d032:	4618      	mov	r0, r3
 801d034:	f003 fdce 	bl	8020bd4 <lv_mem_alloc>
 801d038:	4602      	mov	r2, r0
 801d03a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d03c:	605a      	str	r2, [r3, #4]
        LV_ASSERT_MEM(user_data->palette);
 801d03e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d040:	685b      	ldr	r3, [r3, #4]
 801d042:	4618      	mov	r0, r3
 801d044:	f003 f854 	bl	80200f0 <lv_debug_check_null>
 801d048:	4603      	mov	r3, r0
 801d04a:	f083 0301 	eor.w	r3, r3, #1
 801d04e:	b2db      	uxtb	r3, r3
 801d050:	2b00      	cmp	r3, #0
 801d052:	d00b      	beq.n	801d06c <lv_img_decoder_built_in_open+0x254>
 801d054:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d056:	685b      	ldr	r3, [r3, #4]
 801d058:	461a      	mov	r2, r3
 801d05a:	2300      	movs	r3, #0
 801d05c:	4690      	mov	r8, r2
 801d05e:	4699      	mov	r9, r3
 801d060:	4642      	mov	r2, r8
 801d062:	464b      	mov	r3, r9
 801d064:	481e      	ldr	r0, [pc, #120]	; (801d0e0 <lv_img_decoder_built_in_open+0x2c8>)
 801d066:	f003 f853 	bl	8020110 <lv_debug_log_error>
 801d06a:	e7fe      	b.n	801d06a <lv_img_decoder_built_in_open+0x252>
        user_data->opa                             = lv_mem_alloc(palette_size * sizeof(lv_opa_t));
 801d06c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801d06e:	f003 fdb1 	bl	8020bd4 <lv_mem_alloc>
 801d072:	4602      	mov	r2, r0
 801d074:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d076:	609a      	str	r2, [r3, #8]
        LV_ASSERT_MEM(user_data->opa);
 801d078:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d07a:	689b      	ldr	r3, [r3, #8]
 801d07c:	4618      	mov	r0, r3
 801d07e:	f003 f837 	bl	80200f0 <lv_debug_check_null>
 801d082:	4603      	mov	r3, r0
 801d084:	f083 0301 	eor.w	r3, r3, #1
 801d088:	b2db      	uxtb	r3, r3
 801d08a:	2b00      	cmp	r3, #0
 801d08c:	d00b      	beq.n	801d0a6 <lv_img_decoder_built_in_open+0x28e>
 801d08e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d090:	689b      	ldr	r3, [r3, #8]
 801d092:	461a      	mov	r2, r3
 801d094:	2300      	movs	r3, #0
 801d096:	4614      	mov	r4, r2
 801d098:	461d      	mov	r5, r3
 801d09a:	4622      	mov	r2, r4
 801d09c:	462b      	mov	r3, r5
 801d09e:	4810      	ldr	r0, [pc, #64]	; (801d0e0 <lv_img_decoder_built_in_open+0x2c8>)
 801d0a0:	f003 f836 	bl	8020110 <lv_debug_log_error>
 801d0a4:	e7fe      	b.n	801d0a4 <lv_img_decoder_built_in_open+0x28c>
        if(user_data->palette == NULL || user_data->opa == NULL) {
 801d0a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d0a8:	685b      	ldr	r3, [r3, #4]
 801d0aa:	2b00      	cmp	r3, #0
 801d0ac:	d003      	beq.n	801d0b6 <lv_img_decoder_built_in_open+0x29e>
 801d0ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d0b0:	689b      	ldr	r3, [r3, #8]
 801d0b2:	2b00      	cmp	r3, #0
 801d0b4:	d105      	bne.n	801d0c2 <lv_img_decoder_built_in_open+0x2aa>
            LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
            lv_img_decoder_built_in_close(decoder, dsc);
 801d0b6:	6939      	ldr	r1, [r7, #16]
 801d0b8:	6978      	ldr	r0, [r7, #20]
 801d0ba:	f000 f91d 	bl	801d2f8 <lv_img_decoder_built_in_close>
            return LV_RES_INV;
 801d0be:	2300      	movs	r3, #0
 801d0c0:	e083      	b.n	801d1ca <lv_img_decoder_built_in_open+0x3b2>
        }

        if(dsc->src_type == LV_IMG_SRC_FILE) {
 801d0c2:	693b      	ldr	r3, [r7, #16]
 801d0c4:	7a9b      	ldrb	r3, [r3, #10]
 801d0c6:	2b01      	cmp	r3, #1
 801d0c8:	d12f      	bne.n	801d12a <lv_img_decoder_built_in_open+0x312>
            /*Read the palette from file*/
#if LV_USE_FILESYSTEM
            lv_fs_seek(user_data->f, 4); /*Skip the header*/
 801d0ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d0cc:	681b      	ldr	r3, [r3, #0]
 801d0ce:	2104      	movs	r1, #4
 801d0d0:	4618      	mov	r0, r3
 801d0d2:	f003 f9b8 	bl	8020446 <lv_fs_seek>
            lv_color32_t cur_color;
            uint32_t i;
            for(i = 0; i < palette_size; i++) {
 801d0d6:	2300      	movs	r3, #0
 801d0d8:	647b      	str	r3, [r7, #68]	; 0x44
 801d0da:	e021      	b.n	801d120 <lv_img_decoder_built_in_open+0x308>
 801d0dc:	0802e498 	.word	0x0802e498
 801d0e0:	0802e488 	.word	0x0802e488
                lv_fs_read(user_data->f, &cur_color, sizeof(lv_color32_t), NULL);
 801d0e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d0e6:	6818      	ldr	r0, [r3, #0]
 801d0e8:	f107 011c 	add.w	r1, r7, #28
 801d0ec:	2300      	movs	r3, #0
 801d0ee:	2204      	movs	r2, #4
 801d0f0:	f003 f973 	bl	80203da <lv_fs_read>
                user_data->palette[i] = lv_color_make(cur_color.ch.red, cur_color.ch.green, cur_color.ch.blue);
 801d0f4:	7fb8      	ldrb	r0, [r7, #30]
 801d0f6:	7f79      	ldrb	r1, [r7, #29]
 801d0f8:	7f3d      	ldrb	r5, [r7, #28]
 801d0fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d0fc:	685a      	ldr	r2, [r3, #4]
 801d0fe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d100:	005b      	lsls	r3, r3, #1
 801d102:	18d4      	adds	r4, r2, r3
 801d104:	462a      	mov	r2, r5
 801d106:	f7ff fc03 	bl	801c910 <lv_color_make>
 801d10a:	4603      	mov	r3, r0
 801d10c:	8023      	strh	r3, [r4, #0]
                user_data->opa[i]     = cur_color.ch.alpha;
 801d10e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d110:	689a      	ldr	r2, [r3, #8]
 801d112:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d114:	4413      	add	r3, r2
 801d116:	7ffa      	ldrb	r2, [r7, #31]
 801d118:	701a      	strb	r2, [r3, #0]
            for(i = 0; i < palette_size; i++) {
 801d11a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801d11c:	3301      	adds	r3, #1
 801d11e:	647b      	str	r3, [r7, #68]	; 0x44
 801d120:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801d122:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d124:	429a      	cmp	r2, r3
 801d126:	d3dd      	bcc.n	801d0e4 <lv_img_decoder_built_in_open+0x2cc>
 801d128:	e030      	b.n	801d18c <lv_img_decoder_built_in_open+0x374>
            return LV_RES_INV;
#endif
        }
        else {
            /*The palette begins in the beginning of the image data. Just point to it.*/
            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;
 801d12a:	693b      	ldr	r3, [r7, #16]
 801d12c:	685b      	ldr	r3, [r3, #4]
 801d12e:	689b      	ldr	r3, [r3, #8]
 801d130:	62bb      	str	r3, [r7, #40]	; 0x28


            uint32_t i;
            for(i = 0; i < palette_size; i++) {
 801d132:	2300      	movs	r3, #0
 801d134:	643b      	str	r3, [r7, #64]	; 0x40
 801d136:	e025      	b.n	801d184 <lv_img_decoder_built_in_open+0x36c>
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
 801d138:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d13a:	009b      	lsls	r3, r3, #2
 801d13c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801d13e:	4413      	add	r3, r2
 801d140:	7898      	ldrb	r0, [r3, #2]
 801d142:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d144:	009b      	lsls	r3, r3, #2
 801d146:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801d148:	4413      	add	r3, r2
 801d14a:	7859      	ldrb	r1, [r3, #1]
 801d14c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d14e:	009b      	lsls	r3, r3, #2
 801d150:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801d152:	4413      	add	r3, r2
 801d154:	781d      	ldrb	r5, [r3, #0]
 801d156:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d158:	685a      	ldr	r2, [r3, #4]
 801d15a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d15c:	005b      	lsls	r3, r3, #1
 801d15e:	18d4      	adds	r4, r2, r3
 801d160:	462a      	mov	r2, r5
 801d162:	f7ff fbd5 	bl	801c910 <lv_color_make>
 801d166:	4603      	mov	r3, r0
 801d168:	8023      	strh	r3, [r4, #0]
                user_data->opa[i]     = palette_p[i].ch.alpha;
 801d16a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d16c:	009b      	lsls	r3, r3, #2
 801d16e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801d170:	441a      	add	r2, r3
 801d172:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d174:	6899      	ldr	r1, [r3, #8]
 801d176:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d178:	440b      	add	r3, r1
 801d17a:	78d2      	ldrb	r2, [r2, #3]
 801d17c:	701a      	strb	r2, [r3, #0]
            for(i = 0; i < palette_size; i++) {
 801d17e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d180:	3301      	adds	r3, #1
 801d182:	643b      	str	r3, [r7, #64]	; 0x40
 801d184:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801d186:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d188:	429a      	cmp	r2, r3
 801d18a:	d3d5      	bcc.n	801d138 <lv_img_decoder_built_in_open+0x320>
            }
        }

        dsc->img_data = NULL;
 801d18c:	693b      	ldr	r3, [r7, #16]
 801d18e:	2200      	movs	r2, #0
 801d190:	611a      	str	r2, [r3, #16]
        return LV_RES_OK;
 801d192:	2301      	movs	r3, #1
 801d194:	e019      	b.n	801d1ca <lv_img_decoder_built_in_open+0x3b2>
        LV_LOG_WARN("Indexed (palette) images are not enabled in lv_conf.h. See LV_IMG_CF_INDEXED");
        return LV_RES_INV;
#endif
    }
    /*Alpha indexed images. */
    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||
 801d196:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801d19a:	2b0b      	cmp	r3, #11
 801d19c:	d00b      	beq.n	801d1b6 <lv_img_decoder_built_in_open+0x39e>
 801d19e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801d1a2:	2b0c      	cmp	r3, #12
 801d1a4:	d007      	beq.n	801d1b6 <lv_img_decoder_built_in_open+0x39e>
 801d1a6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801d1aa:	2b0d      	cmp	r3, #13
 801d1ac:	d003      	beq.n	801d1b6 <lv_img_decoder_built_in_open+0x39e>
 801d1ae:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801d1b2:	2b0e      	cmp	r3, #14
 801d1b4:	d104      	bne.n	801d1c0 <lv_img_decoder_built_in_open+0x3a8>
            cf == LV_IMG_CF_ALPHA_8BIT) {
#if LV_IMG_CF_ALPHA
        dsc->img_data = NULL;
 801d1b6:	693b      	ldr	r3, [r7, #16]
 801d1b8:	2200      	movs	r2, #0
 801d1ba:	611a      	str	r2, [r3, #16]
        return LV_RES_OK; /*Nothing to process*/
 801d1bc:	2301      	movs	r3, #1
 801d1be:	e004      	b.n	801d1ca <lv_img_decoder_built_in_open+0x3b2>
#endif
    }
    /*Unknown format. Can't decode it.*/
    else {
        /*Free the potentially allocated memories*/
        lv_img_decoder_built_in_close(decoder, dsc);
 801d1c0:	6939      	ldr	r1, [r7, #16]
 801d1c2:	6978      	ldr	r0, [r7, #20]
 801d1c4:	f000 f898 	bl	801d2f8 <lv_img_decoder_built_in_close>

        LV_LOG_WARN("Image decoder open: unknown color format")
        return LV_RES_INV;
 801d1c8:	2300      	movs	r3, #0
    }
}
 801d1ca:	4618      	mov	r0, r3
 801d1cc:	3748      	adds	r7, #72	; 0x48
 801d1ce:	46bd      	mov	sp, r7
 801d1d0:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

0801d1d4 <lv_img_decoder_built_in_read_line>:
 * @param buf a buffer to store the decoded pixels
 * @return LV_RES_OK: ok; LV_RES_INV: failed
 */
lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,
                                           lv_coord_t y, lv_coord_t len, uint8_t * buf)
{
 801d1d4:	b580      	push	{r7, lr}
 801d1d6:	b088      	sub	sp, #32
 801d1d8:	af02      	add	r7, sp, #8
 801d1da:	60f8      	str	r0, [r7, #12]
 801d1dc:	60b9      	str	r1, [r7, #8]
 801d1de:	4611      	mov	r1, r2
 801d1e0:	461a      	mov	r2, r3
 801d1e2:	460b      	mov	r3, r1
 801d1e4:	80fb      	strh	r3, [r7, #6]
 801d1e6:	4613      	mov	r3, r2
 801d1e8:	80bb      	strh	r3, [r7, #4]
    (void)decoder; /*Unused*/

    lv_res_t res = LV_RES_INV;
 801d1ea:	2300      	movs	r3, #0
 801d1ec:	75fb      	strb	r3, [r7, #23]

    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
 801d1ee:	68bb      	ldr	r3, [r7, #8]
 801d1f0:	7b1b      	ldrb	r3, [r3, #12]
 801d1f2:	f003 031f 	and.w	r3, r3, #31
 801d1f6:	b2db      	uxtb	r3, r3
 801d1f8:	2b04      	cmp	r3, #4
 801d1fa:	d00d      	beq.n	801d218 <lv_img_decoder_built_in_read_line+0x44>
 801d1fc:	68bb      	ldr	r3, [r7, #8]
 801d1fe:	7b1b      	ldrb	r3, [r3, #12]
 801d200:	f003 031f 	and.w	r3, r3, #31
 801d204:	b2db      	uxtb	r3, r3
 801d206:	2b05      	cmp	r3, #5
 801d208:	d006      	beq.n	801d218 <lv_img_decoder_built_in_read_line+0x44>
       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
 801d20a:	68bb      	ldr	r3, [r7, #8]
 801d20c:	7b1b      	ldrb	r3, [r3, #12]
 801d20e:	f003 031f 	and.w	r3, r3, #31
 801d212:	b2db      	uxtb	r3, r3
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
 801d214:	2b06      	cmp	r3, #6
 801d216:	d112      	bne.n	801d23e <lv_img_decoder_built_in_read_line+0x6a>
        /* For TRUE_COLOR images read line required only for files.
         * For variables the image data was returned in `open`*/
        if(dsc->src_type == LV_IMG_SRC_FILE) {
 801d218:	68bb      	ldr	r3, [r7, #8]
 801d21a:	7a9b      	ldrb	r3, [r3, #10]
 801d21c:	2b01      	cmp	r3, #1
 801d21e:	d166      	bne.n	801d2ee <lv_img_decoder_built_in_read_line+0x11a>
            res = lv_img_decoder_built_in_line_true_color(dsc, x, y, len, buf);
 801d220:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 801d224:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801d228:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 801d22c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d22e:	9300      	str	r3, [sp, #0]
 801d230:	4603      	mov	r3, r0
 801d232:	68b8      	ldr	r0, [r7, #8]
 801d234:	f000 f895 	bl	801d362 <lv_img_decoder_built_in_line_true_color>
 801d238:	4603      	mov	r3, r0
 801d23a:	75fb      	strb	r3, [r7, #23]
        if(dsc->src_type == LV_IMG_SRC_FILE) {
 801d23c:	e057      	b.n	801d2ee <lv_img_decoder_built_in_read_line+0x11a>
        }
    }
    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
 801d23e:	68bb      	ldr	r3, [r7, #8]
 801d240:	7b1b      	ldrb	r3, [r3, #12]
 801d242:	f003 031f 	and.w	r3, r3, #31
 801d246:	b2db      	uxtb	r3, r3
 801d248:	2b0b      	cmp	r3, #11
 801d24a:	d014      	beq.n	801d276 <lv_img_decoder_built_in_read_line+0xa2>
 801d24c:	68bb      	ldr	r3, [r7, #8]
 801d24e:	7b1b      	ldrb	r3, [r3, #12]
 801d250:	f003 031f 	and.w	r3, r3, #31
 801d254:	b2db      	uxtb	r3, r3
 801d256:	2b0c      	cmp	r3, #12
 801d258:	d00d      	beq.n	801d276 <lv_img_decoder_built_in_read_line+0xa2>
            dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
 801d25a:	68bb      	ldr	r3, [r7, #8]
 801d25c:	7b1b      	ldrb	r3, [r3, #12]
 801d25e:	f003 031f 	and.w	r3, r3, #31
 801d262:	b2db      	uxtb	r3, r3
    else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
 801d264:	2b0d      	cmp	r3, #13
 801d266:	d006      	beq.n	801d276 <lv_img_decoder_built_in_read_line+0xa2>
            dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
 801d268:	68bb      	ldr	r3, [r7, #8]
 801d26a:	7b1b      	ldrb	r3, [r3, #12]
 801d26c:	f003 031f 	and.w	r3, r3, #31
 801d270:	b2db      	uxtb	r3, r3
 801d272:	2b0e      	cmp	r3, #14
 801d274:	d10e      	bne.n	801d294 <lv_img_decoder_built_in_read_line+0xc0>

        res = lv_img_decoder_built_in_line_alpha(dsc, x, y, len, buf);
 801d276:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 801d27a:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801d27e:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 801d282:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d284:	9300      	str	r3, [sp, #0]
 801d286:	4603      	mov	r3, r0
 801d288:	68b8      	ldr	r0, [r7, #8]
 801d28a:	f000 f8cb 	bl	801d424 <lv_img_decoder_built_in_line_alpha>
 801d28e:	4603      	mov	r3, r0
 801d290:	75fb      	strb	r3, [r7, #23]
 801d292:	e02c      	b.n	801d2ee <lv_img_decoder_built_in_read_line+0x11a>
    }
    else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
 801d294:	68bb      	ldr	r3, [r7, #8]
 801d296:	7b1b      	ldrb	r3, [r3, #12]
 801d298:	f003 031f 	and.w	r3, r3, #31
 801d29c:	b2db      	uxtb	r3, r3
 801d29e:	2b07      	cmp	r3, #7
 801d2a0:	d014      	beq.n	801d2cc <lv_img_decoder_built_in_read_line+0xf8>
 801d2a2:	68bb      	ldr	r3, [r7, #8]
 801d2a4:	7b1b      	ldrb	r3, [r3, #12]
 801d2a6:	f003 031f 	and.w	r3, r3, #31
 801d2aa:	b2db      	uxtb	r3, r3
 801d2ac:	2b08      	cmp	r3, #8
 801d2ae:	d00d      	beq.n	801d2cc <lv_img_decoder_built_in_read_line+0xf8>
            dsc->header.cf == LV_IMG_CF_INDEXED_4BIT || dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {
 801d2b0:	68bb      	ldr	r3, [r7, #8]
 801d2b2:	7b1b      	ldrb	r3, [r3, #12]
 801d2b4:	f003 031f 	and.w	r3, r3, #31
 801d2b8:	b2db      	uxtb	r3, r3
    else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
 801d2ba:	2b09      	cmp	r3, #9
 801d2bc:	d006      	beq.n	801d2cc <lv_img_decoder_built_in_read_line+0xf8>
            dsc->header.cf == LV_IMG_CF_INDEXED_4BIT || dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {
 801d2be:	68bb      	ldr	r3, [r7, #8]
 801d2c0:	7b1b      	ldrb	r3, [r3, #12]
 801d2c2:	f003 031f 	and.w	r3, r3, #31
 801d2c6:	b2db      	uxtb	r3, r3
 801d2c8:	2b0a      	cmp	r3, #10
 801d2ca:	d10e      	bne.n	801d2ea <lv_img_decoder_built_in_read_line+0x116>
        res = lv_img_decoder_built_in_line_indexed(dsc, x, y, len, buf);
 801d2cc:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 801d2d0:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801d2d4:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 801d2d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d2da:	9300      	str	r3, [sp, #0]
 801d2dc:	4603      	mov	r3, r0
 801d2de:	68b8      	ldr	r0, [r7, #8]
 801d2e0:	f000 fa50 	bl	801d784 <lv_img_decoder_built_in_line_indexed>
 801d2e4:	4603      	mov	r3, r0
 801d2e6:	75fb      	strb	r3, [r7, #23]
 801d2e8:	e001      	b.n	801d2ee <lv_img_decoder_built_in_read_line+0x11a>
    }
    else {
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
        return LV_RES_INV;
 801d2ea:	2300      	movs	r3, #0
 801d2ec:	e000      	b.n	801d2f0 <lv_img_decoder_built_in_read_line+0x11c>
    }

    return res;
 801d2ee:	7dfb      	ldrb	r3, [r7, #23]
}
 801d2f0:	4618      	mov	r0, r3
 801d2f2:	3718      	adds	r7, #24
 801d2f4:	46bd      	mov	sp, r7
 801d2f6:	bd80      	pop	{r7, pc}

0801d2f8 <lv_img_decoder_built_in_close>:
 * Close the pending decoding. Free resources etc.
 * @param decoder pointer to the decoder the function associated with
 * @param dsc pointer to decoder descriptor
 */
void lv_img_decoder_built_in_close(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
 801d2f8:	b580      	push	{r7, lr}
 801d2fa:	b084      	sub	sp, #16
 801d2fc:	af00      	add	r7, sp, #0
 801d2fe:	6078      	str	r0, [r7, #4]
 801d300:	6039      	str	r1, [r7, #0]
    (void)decoder; /*Unused*/

    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801d302:	683b      	ldr	r3, [r7, #0]
 801d304:	69db      	ldr	r3, [r3, #28]
 801d306:	60fb      	str	r3, [r7, #12]
    if(user_data) {
 801d308:	68fb      	ldr	r3, [r7, #12]
 801d30a:	2b00      	cmp	r3, #0
 801d30c:	d025      	beq.n	801d35a <lv_img_decoder_built_in_close+0x62>
#if LV_USE_FILESYSTEM
        if(user_data->f) {
 801d30e:	68fb      	ldr	r3, [r7, #12]
 801d310:	681b      	ldr	r3, [r3, #0]
 801d312:	2b00      	cmp	r3, #0
 801d314:	d009      	beq.n	801d32a <lv_img_decoder_built_in_close+0x32>
            lv_fs_close(user_data->f);
 801d316:	68fb      	ldr	r3, [r7, #12]
 801d318:	681b      	ldr	r3, [r3, #0]
 801d31a:	4618      	mov	r0, r3
 801d31c:	f003 f82e 	bl	802037c <lv_fs_close>
            lv_mem_free(user_data->f);
 801d320:	68fb      	ldr	r3, [r7, #12]
 801d322:	681b      	ldr	r3, [r3, #0]
 801d324:	4618      	mov	r0, r3
 801d326:	f003 fc9f 	bl	8020c68 <lv_mem_free>
        }
#endif
        if(user_data->palette) lv_mem_free(user_data->palette);
 801d32a:	68fb      	ldr	r3, [r7, #12]
 801d32c:	685b      	ldr	r3, [r3, #4]
 801d32e:	2b00      	cmp	r3, #0
 801d330:	d004      	beq.n	801d33c <lv_img_decoder_built_in_close+0x44>
 801d332:	68fb      	ldr	r3, [r7, #12]
 801d334:	685b      	ldr	r3, [r3, #4]
 801d336:	4618      	mov	r0, r3
 801d338:	f003 fc96 	bl	8020c68 <lv_mem_free>
        if(user_data->opa) lv_mem_free(user_data->opa);
 801d33c:	68fb      	ldr	r3, [r7, #12]
 801d33e:	689b      	ldr	r3, [r3, #8]
 801d340:	2b00      	cmp	r3, #0
 801d342:	d004      	beq.n	801d34e <lv_img_decoder_built_in_close+0x56>
 801d344:	68fb      	ldr	r3, [r7, #12]
 801d346:	689b      	ldr	r3, [r3, #8]
 801d348:	4618      	mov	r0, r3
 801d34a:	f003 fc8d 	bl	8020c68 <lv_mem_free>

        lv_mem_free(user_data);
 801d34e:	68f8      	ldr	r0, [r7, #12]
 801d350:	f003 fc8a 	bl	8020c68 <lv_mem_free>

        dsc->user_data = NULL;
 801d354:	683b      	ldr	r3, [r7, #0]
 801d356:	2200      	movs	r2, #0
 801d358:	61da      	str	r2, [r3, #28]
    }
}
 801d35a:	bf00      	nop
 801d35c:	3710      	adds	r7, #16
 801d35e:	46bd      	mov	sp, r7
 801d360:	bd80      	pop	{r7, pc}

0801d362 <lv_img_decoder_built_in_line_true_color>:
 *   STATIC FUNCTIONS
 **********************/

static lv_res_t lv_img_decoder_built_in_line_true_color(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                        lv_coord_t len, uint8_t * buf)
{
 801d362:	b580      	push	{r7, lr}
 801d364:	b08a      	sub	sp, #40	; 0x28
 801d366:	af00      	add	r7, sp, #0
 801d368:	60f8      	str	r0, [r7, #12]
 801d36a:	4608      	mov	r0, r1
 801d36c:	4611      	mov	r1, r2
 801d36e:	461a      	mov	r2, r3
 801d370:	4603      	mov	r3, r0
 801d372:	817b      	strh	r3, [r7, #10]
 801d374:	460b      	mov	r3, r1
 801d376:	813b      	strh	r3, [r7, #8]
 801d378:	4613      	mov	r3, r2
 801d37a:	80fb      	strh	r3, [r7, #6]
#if LV_USE_FILESYSTEM
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801d37c:	68fb      	ldr	r3, [r7, #12]
 801d37e:	69db      	ldr	r3, [r3, #28]
 801d380:	627b      	str	r3, [r7, #36]	; 0x24
    lv_fs_res_t res;
    uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf);
 801d382:	68fb      	ldr	r3, [r7, #12]
 801d384:	7b1b      	ldrb	r3, [r3, #12]
 801d386:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801d38a:	b2db      	uxtb	r3, r3
 801d38c:	4618      	mov	r0, r3
 801d38e:	f7f5 f891 	bl	80124b4 <lv_img_cf_get_px_size>
 801d392:	4603      	mov	r3, r0
 801d394:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

    uint32_t pos = ((y * dsc->header.w + x) * px_size) >> 3;
 801d398:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 801d39c:	68fa      	ldr	r2, [r7, #12]
 801d39e:	68d2      	ldr	r2, [r2, #12]
 801d3a0:	f3c2 228a 	ubfx	r2, r2, #10, #11
 801d3a4:	b292      	uxth	r2, r2
 801d3a6:	fb03 f202 	mul.w	r2, r3, r2
 801d3aa:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801d3ae:	4413      	add	r3, r2
 801d3b0:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 801d3b4:	fb02 f303 	mul.w	r3, r2, r3
 801d3b8:	10db      	asrs	r3, r3, #3
 801d3ba:	61fb      	str	r3, [r7, #28]
    pos += 4; /*Skip the header*/
 801d3bc:	69fb      	ldr	r3, [r7, #28]
 801d3be:	3304      	adds	r3, #4
 801d3c0:	61fb      	str	r3, [r7, #28]
    res = lv_fs_seek(user_data->f, pos);
 801d3c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d3c4:	681b      	ldr	r3, [r3, #0]
 801d3c6:	69f9      	ldr	r1, [r7, #28]
 801d3c8:	4618      	mov	r0, r3
 801d3ca:	f003 f83c 	bl	8020446 <lv_fs_seek>
 801d3ce:	4603      	mov	r3, r0
 801d3d0:	76fb      	strb	r3, [r7, #27]
    if(res != LV_FS_RES_OK) {
 801d3d2:	7efb      	ldrb	r3, [r7, #27]
 801d3d4:	2b00      	cmp	r3, #0
 801d3d6:	d001      	beq.n	801d3dc <lv_img_decoder_built_in_line_true_color+0x7a>
        LV_LOG_WARN("Built-in image decoder seek failed");
        return LV_RES_INV;
 801d3d8:	2300      	movs	r3, #0
 801d3da:	e01e      	b.n	801d41a <lv_img_decoder_built_in_line_true_color+0xb8>
    }
    uint32_t btr = len * (px_size >> 3);
 801d3dc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801d3e0:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 801d3e4:	08d2      	lsrs	r2, r2, #3
 801d3e6:	b2d2      	uxtb	r2, r2
 801d3e8:	fb02 f303 	mul.w	r3, r2, r3
 801d3ec:	617b      	str	r3, [r7, #20]
    uint32_t br  = 0;
 801d3ee:	2300      	movs	r3, #0
 801d3f0:	613b      	str	r3, [r7, #16]
    res = lv_fs_read(user_data->f, buf, btr, &br);
 801d3f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d3f4:	6818      	ldr	r0, [r3, #0]
 801d3f6:	f107 0310 	add.w	r3, r7, #16
 801d3fa:	697a      	ldr	r2, [r7, #20]
 801d3fc:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801d3fe:	f002 ffec 	bl	80203da <lv_fs_read>
 801d402:	4603      	mov	r3, r0
 801d404:	76fb      	strb	r3, [r7, #27]
    if(res != LV_FS_RES_OK || btr != br) {
 801d406:	7efb      	ldrb	r3, [r7, #27]
 801d408:	2b00      	cmp	r3, #0
 801d40a:	d103      	bne.n	801d414 <lv_img_decoder_built_in_line_true_color+0xb2>
 801d40c:	693b      	ldr	r3, [r7, #16]
 801d40e:	697a      	ldr	r2, [r7, #20]
 801d410:	429a      	cmp	r2, r3
 801d412:	d001      	beq.n	801d418 <lv_img_decoder_built_in_line_true_color+0xb6>
        LV_LOG_WARN("Built-in image decoder read failed");
        return LV_RES_INV;
 801d414:	2300      	movs	r3, #0
 801d416:	e000      	b.n	801d41a <lv_img_decoder_built_in_line_true_color+0xb8>
    }

    return LV_RES_OK;
 801d418:	2301      	movs	r3, #1
    LV_UNUSED(len);
    LV_UNUSED(buf);
    LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
    return LV_RES_INV;
#endif
}
 801d41a:	4618      	mov	r0, r3
 801d41c:	3728      	adds	r7, #40	; 0x28
 801d41e:	46bd      	mov	sp, r7
 801d420:	bd80      	pop	{r7, pc}
	...

0801d424 <lv_img_decoder_built_in_line_alpha>:

static lv_res_t lv_img_decoder_built_in_line_alpha(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                   lv_coord_t len, uint8_t * buf)
{
 801d424:	b590      	push	{r4, r7, lr}
 801d426:	b097      	sub	sp, #92	; 0x5c
 801d428:	af00      	add	r7, sp, #0
 801d42a:	60f8      	str	r0, [r7, #12]
 801d42c:	4608      	mov	r0, r1
 801d42e:	4611      	mov	r1, r2
 801d430:	461a      	mov	r2, r3
 801d432:	4603      	mov	r3, r0
 801d434:	817b      	strh	r3, [r7, #10]
 801d436:	460b      	mov	r3, r1
 801d438:	813b      	strh	r3, [r7, #8]
 801d43a:	4613      	mov	r3, r2
 801d43c:	80fb      	strh	r3, [r7, #6]

#if LV_IMG_CF_ALPHA
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
 801d43e:	f44f 437f 	mov.w	r3, #65280	; 0xff00
 801d442:	85bb      	strh	r3, [r7, #44]	; 0x2c
    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
 801d444:	4bb2      	ldr	r3, [pc, #712]	; (801d710 <lv_img_decoder_built_in_line_alpha+0x2ec>)
 801d446:	62bb      	str	r3, [r7, #40]	; 0x28
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
 801d448:	4bb2      	ldr	r3, [pc, #712]	; (801d714 <lv_img_decoder_built_in_line_alpha+0x2f0>)
 801d44a:	f107 0418 	add.w	r4, r7, #24
 801d44e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801d450:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                                           68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255
                                          };

    /*Simply fill the buffer with the color. Later only the alpha value will be modified.*/
    lv_color_t bg_color = dsc->color;
 801d454:	68fb      	ldr	r3, [r7, #12]
 801d456:	891b      	ldrh	r3, [r3, #8]
 801d458:	82bb      	strh	r3, [r7, #20]
    lv_coord_t i;
    for(i = 0; i < len; i++) {
 801d45a:	2300      	movs	r3, #0
 801d45c:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 801d460:	e01e      	b.n	801d4a0 <lv_img_decoder_built_in_line_alpha+0x7c>
#if LV_COLOR_DEPTH == 8 || LV_COLOR_DEPTH == 1
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full;
#elif LV_COLOR_DEPTH == 16
        /*Because of Alpha byte 16 bit color can start on odd address which can cause crash*/
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full & 0xFF;
 801d462:	8ab9      	ldrh	r1, [r7, #20]
 801d464:	f9b7 2056 	ldrsh.w	r2, [r7, #86]	; 0x56
 801d468:	4613      	mov	r3, r2
 801d46a:	005b      	lsls	r3, r3, #1
 801d46c:	4413      	add	r3, r2
 801d46e:	461a      	mov	r2, r3
 801d470:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801d472:	4413      	add	r3, r2
 801d474:	b2ca      	uxtb	r2, r1
 801d476:	701a      	strb	r2, [r3, #0]
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + 1] = (bg_color.full >> 8) & 0xFF;
 801d478:	8abb      	ldrh	r3, [r7, #20]
 801d47a:	0a1b      	lsrs	r3, r3, #8
 801d47c:	b299      	uxth	r1, r3
 801d47e:	f9b7 2056 	ldrsh.w	r2, [r7, #86]	; 0x56
 801d482:	4613      	mov	r3, r2
 801d484:	005b      	lsls	r3, r3, #1
 801d486:	4413      	add	r3, r2
 801d488:	3301      	adds	r3, #1
 801d48a:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801d48c:	4413      	add	r3, r2
 801d48e:	b2ca      	uxtb	r2, r1
 801d490:	701a      	strb	r2, [r3, #0]
    for(i = 0; i < len; i++) {
 801d492:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801d496:	b29b      	uxth	r3, r3
 801d498:	3301      	adds	r3, #1
 801d49a:	b29b      	uxth	r3, r3
 801d49c:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 801d4a0:	f9b7 2056 	ldrsh.w	r2, [r7, #86]	; 0x56
 801d4a4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801d4a8:	429a      	cmp	r2, r3
 801d4aa:	dbda      	blt.n	801d462 <lv_img_decoder_built_in_line_alpha+0x3e>
#else
#error "Invalid LV_COLOR_DEPTH. Check it in lv_conf.h"
#endif
    }

    const lv_opa_t * opa_table = NULL;
 801d4ac:	2300      	movs	r3, #0
 801d4ae:	653b      	str	r3, [r7, #80]	; 0x50
    uint8_t px_size            = lv_img_cf_get_px_size(dsc->header.cf);
 801d4b0:	68fb      	ldr	r3, [r7, #12]
 801d4b2:	7b1b      	ldrb	r3, [r3, #12]
 801d4b4:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801d4b8:	b2db      	uxtb	r3, r3
 801d4ba:	4618      	mov	r0, r3
 801d4bc:	f7f4 fffa 	bl	80124b4 <lv_img_cf_get_px_size>
 801d4c0:	4603      	mov	r3, r0
 801d4c2:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
 801d4c6:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801d4ca:	2201      	movs	r2, #1
 801d4cc:	fa02 f303 	lsl.w	r3, r2, r3
 801d4d0:	b29b      	uxth	r3, r3
 801d4d2:	3b01      	subs	r3, #1
 801d4d4:	87bb      	strh	r3, [r7, #60]	; 0x3c

    lv_coord_t w = 0;
 801d4d6:	2300      	movs	r3, #0
 801d4d8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    uint32_t ofs = 0;
 801d4dc:	2300      	movs	r3, #0
 801d4de:	64bb      	str	r3, [r7, #72]	; 0x48
    int8_t pos   = 0;
 801d4e0:	2300      	movs	r3, #0
 801d4e2:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    switch(dsc->header.cf) {
 801d4e6:	68fb      	ldr	r3, [r7, #12]
 801d4e8:	7b1b      	ldrb	r3, [r3, #12]
 801d4ea:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801d4ee:	b2db      	uxtb	r3, r3
 801d4f0:	3b0b      	subs	r3, #11
 801d4f2:	2b03      	cmp	r3, #3
 801d4f4:	f200 80c1 	bhi.w	801d67a <lv_img_decoder_built_in_line_alpha+0x256>
 801d4f8:	a201      	add	r2, pc, #4	; (adr r2, 801d500 <lv_img_decoder_built_in_line_alpha+0xdc>)
 801d4fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d4fe:	bf00      	nop
 801d500:	0801d511 	.word	0x0801d511
 801d504:	0801d577 	.word	0x0801d577
 801d508:	0801d5e1 	.word	0x0801d5e1
 801d50c:	0801d64b 	.word	0x0801d64b
        case LV_IMG_CF_ALPHA_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
 801d510:	68fb      	ldr	r3, [r7, #12]
 801d512:	68db      	ldr	r3, [r3, #12]
 801d514:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d518:	b29b      	uxth	r3, r3
 801d51a:	10db      	asrs	r3, r3, #3
 801d51c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
            if(dsc->header.w & 0x7) w++;
 801d520:	68fb      	ldr	r3, [r7, #12]
 801d522:	68db      	ldr	r3, [r3, #12]
 801d524:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d528:	b29b      	uxth	r3, r3
 801d52a:	f003 0307 	and.w	r3, r3, #7
 801d52e:	2b00      	cmp	r3, #0
 801d530:	d006      	beq.n	801d540 <lv_img_decoder_built_in_line_alpha+0x11c>
 801d532:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801d536:	b29b      	uxth	r3, r3
 801d538:	3301      	adds	r3, #1
 801d53a:	b29b      	uxth	r3, r3
 801d53c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
            ofs += w * y + (x >> 3); /*First pixel*/
 801d540:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801d544:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801d548:	fb02 f303 	mul.w	r3, r2, r3
 801d54c:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801d550:	10d2      	asrs	r2, r2, #3
 801d552:	b212      	sxth	r2, r2
 801d554:	4413      	add	r3, r2
 801d556:	461a      	mov	r2, r3
 801d558:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d55a:	4413      	add	r3, r2
 801d55c:	64bb      	str	r3, [r7, #72]	; 0x48
            pos       = 7 - (x & 0x7);
 801d55e:	897b      	ldrh	r3, [r7, #10]
 801d560:	b25b      	sxtb	r3, r3
 801d562:	43db      	mvns	r3, r3
 801d564:	b25b      	sxtb	r3, r3
 801d566:	f003 0307 	and.w	r3, r3, #7
 801d56a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            opa_table = alpha1_opa_table;
 801d56e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801d572:	653b      	str	r3, [r7, #80]	; 0x50
            break;
 801d574:	e081      	b.n	801d67a <lv_img_decoder_built_in_line_alpha+0x256>
        case LV_IMG_CF_ALPHA_2BIT:
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
 801d576:	68fb      	ldr	r3, [r7, #12]
 801d578:	68db      	ldr	r3, [r3, #12]
 801d57a:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d57e:	b29b      	uxth	r3, r3
 801d580:	109b      	asrs	r3, r3, #2
 801d582:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
            if(dsc->header.w & 0x3) w++;
 801d586:	68fb      	ldr	r3, [r7, #12]
 801d588:	68db      	ldr	r3, [r3, #12]
 801d58a:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d58e:	b29b      	uxth	r3, r3
 801d590:	f003 0303 	and.w	r3, r3, #3
 801d594:	2b00      	cmp	r3, #0
 801d596:	d006      	beq.n	801d5a6 <lv_img_decoder_built_in_line_alpha+0x182>
 801d598:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801d59c:	b29b      	uxth	r3, r3
 801d59e:	3301      	adds	r3, #1
 801d5a0:	b29b      	uxth	r3, r3
 801d5a2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
            ofs += w * y + (x >> 2); /*First pixel*/
 801d5a6:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801d5aa:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801d5ae:	fb02 f303 	mul.w	r3, r2, r3
 801d5b2:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801d5b6:	1092      	asrs	r2, r2, #2
 801d5b8:	b212      	sxth	r2, r2
 801d5ba:	4413      	add	r3, r2
 801d5bc:	461a      	mov	r2, r3
 801d5be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d5c0:	4413      	add	r3, r2
 801d5c2:	64bb      	str	r3, [r7, #72]	; 0x48
            pos       = 6 - ((x & 0x3) * 2);
 801d5c4:	897b      	ldrh	r3, [r7, #10]
 801d5c6:	43db      	mvns	r3, r3
 801d5c8:	b2db      	uxtb	r3, r3
 801d5ca:	f003 0303 	and.w	r3, r3, #3
 801d5ce:	b2db      	uxtb	r3, r3
 801d5d0:	005b      	lsls	r3, r3, #1
 801d5d2:	b2db      	uxtb	r3, r3
 801d5d4:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            opa_table = alpha2_opa_table;
 801d5d8:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801d5dc:	653b      	str	r3, [r7, #80]	; 0x50
            break;
 801d5de:	e04c      	b.n	801d67a <lv_img_decoder_built_in_line_alpha+0x256>
        case LV_IMG_CF_ALPHA_4BIT:
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
 801d5e0:	68fb      	ldr	r3, [r7, #12]
 801d5e2:	68db      	ldr	r3, [r3, #12]
 801d5e4:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d5e8:	b29b      	uxth	r3, r3
 801d5ea:	105b      	asrs	r3, r3, #1
 801d5ec:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
            if(dsc->header.w & 0x1) w++;
 801d5f0:	68fb      	ldr	r3, [r7, #12]
 801d5f2:	68db      	ldr	r3, [r3, #12]
 801d5f4:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d5f8:	b29b      	uxth	r3, r3
 801d5fa:	f003 0301 	and.w	r3, r3, #1
 801d5fe:	2b00      	cmp	r3, #0
 801d600:	d006      	beq.n	801d610 <lv_img_decoder_built_in_line_alpha+0x1ec>
 801d602:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801d606:	b29b      	uxth	r3, r3
 801d608:	3301      	adds	r3, #1
 801d60a:	b29b      	uxth	r3, r3
 801d60c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
            ofs += w * y + (x >> 1); /*First pixel*/
 801d610:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801d614:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801d618:	fb02 f303 	mul.w	r3, r2, r3
 801d61c:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801d620:	1052      	asrs	r2, r2, #1
 801d622:	b212      	sxth	r2, r2
 801d624:	4413      	add	r3, r2
 801d626:	461a      	mov	r2, r3
 801d628:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d62a:	4413      	add	r3, r2
 801d62c:	64bb      	str	r3, [r7, #72]	; 0x48
            pos       = 4 - ((x & 0x1) * 4);
 801d62e:	897b      	ldrh	r3, [r7, #10]
 801d630:	f003 0301 	and.w	r3, r3, #1
 801d634:	2b00      	cmp	r3, #0
 801d636:	d101      	bne.n	801d63c <lv_img_decoder_built_in_line_alpha+0x218>
 801d638:	2304      	movs	r3, #4
 801d63a:	e000      	b.n	801d63e <lv_img_decoder_built_in_line_alpha+0x21a>
 801d63c:	2300      	movs	r3, #0
 801d63e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            opa_table = alpha4_opa_table;
 801d642:	f107 0318 	add.w	r3, r7, #24
 801d646:	653b      	str	r3, [r7, #80]	; 0x50
            break;
 801d648:	e017      	b.n	801d67a <lv_img_decoder_built_in_line_alpha+0x256>
        case LV_IMG_CF_ALPHA_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
 801d64a:	68fb      	ldr	r3, [r7, #12]
 801d64c:	68db      	ldr	r3, [r3, #12]
 801d64e:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d652:	b29b      	uxth	r3, r3
 801d654:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
            ofs += w * y + x;  /*First pixel*/
 801d658:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801d65c:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801d660:	fb03 f202 	mul.w	r2, r3, r2
 801d664:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801d668:	4413      	add	r3, r2
 801d66a:	461a      	mov	r2, r3
 801d66c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d66e:	4413      	add	r3, r2
 801d670:	64bb      	str	r3, [r7, #72]	; 0x48
            pos = 0;
 801d672:	2300      	movs	r3, #0
 801d674:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            break;
 801d678:	bf00      	nop
    }

#if LV_USE_FILESYSTEM
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801d67a:	68fb      	ldr	r3, [r7, #12]
 801d67c:	69db      	ldr	r3, [r3, #28]
 801d67e:	63bb      	str	r3, [r7, #56]	; 0x38
    uint8_t * fs_buf = _lv_mem_buf_get(w);
 801d680:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801d684:	4618      	mov	r0, r3
 801d686:	f003 fc03 	bl	8020e90 <_lv_mem_buf_get>
 801d68a:	6378      	str	r0, [r7, #52]	; 0x34
#endif

    const uint8_t * data_tmp = NULL;
 801d68c:	2300      	movs	r3, #0
 801d68e:	643b      	str	r3, [r7, #64]	; 0x40
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 801d690:	68fb      	ldr	r3, [r7, #12]
 801d692:	7a9b      	ldrb	r3, [r3, #10]
 801d694:	2b00      	cmp	r3, #0
 801d696:	d108      	bne.n	801d6aa <lv_img_decoder_built_in_line_alpha+0x286>
        const lv_img_dsc_t * img_dsc = dsc->src;
 801d698:	68fb      	ldr	r3, [r7, #12]
 801d69a:	685b      	ldr	r3, [r3, #4]
 801d69c:	633b      	str	r3, [r7, #48]	; 0x30

        data_tmp = img_dsc->data + ofs;
 801d69e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d6a0:	689a      	ldr	r2, [r3, #8]
 801d6a2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d6a4:	4413      	add	r3, r2
 801d6a6:	643b      	str	r3, [r7, #64]	; 0x40
 801d6a8:	e011      	b.n	801d6ce <lv_img_decoder_built_in_line_alpha+0x2aa>
    }
    else {
#if LV_USE_FILESYSTEM
        lv_fs_seek(user_data->f, ofs + 4); /*+4 to skip the header*/
 801d6aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801d6ac:	681a      	ldr	r2, [r3, #0]
 801d6ae:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801d6b0:	3304      	adds	r3, #4
 801d6b2:	4619      	mov	r1, r3
 801d6b4:	4610      	mov	r0, r2
 801d6b6:	f002 fec6 	bl	8020446 <lv_fs_seek>
        lv_fs_read(user_data->f, fs_buf, w, NULL);
 801d6ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801d6bc:	6818      	ldr	r0, [r3, #0]
 801d6be:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 801d6c2:	2300      	movs	r3, #0
 801d6c4:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801d6c6:	f002 fe88 	bl	80203da <lv_fs_read>
        data_tmp = fs_buf;
 801d6ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801d6cc:	643b      	str	r3, [r7, #64]	; 0x40
        data_tmp = NULL; /*To avoid warnings*/
        return LV_RES_INV;
#endif
    }

    for(i = 0; i < len; i++) {
 801d6ce:	2300      	movs	r3, #0
 801d6d0:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 801d6d4:	e048      	b.n	801d768 <lv_img_decoder_built_in_line_alpha+0x344>
        uint8_t val_act = (*data_tmp & (mask << pos)) >> pos;
 801d6d6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d6d8:	781b      	ldrb	r3, [r3, #0]
 801d6da:	4619      	mov	r1, r3
 801d6dc:	8fba      	ldrh	r2, [r7, #60]	; 0x3c
 801d6de:	f997 3047 	ldrsb.w	r3, [r7, #71]	; 0x47
 801d6e2:	fa02 f303 	lsl.w	r3, r2, r3
 801d6e6:	ea01 0203 	and.w	r2, r1, r3
 801d6ea:	f997 3047 	ldrsb.w	r3, [r7, #71]	; 0x47
 801d6ee:	fa42 f303 	asr.w	r3, r2, r3
 801d6f2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
 801d6f6:	68fb      	ldr	r3, [r7, #12]
 801d6f8:	7b1b      	ldrb	r3, [r3, #12]
 801d6fa:	f003 031f 	and.w	r3, r3, #31
 801d6fe:	b2db      	uxtb	r3, r3
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
 801d700:	2b0e      	cmp	r3, #14
 801d702:	d009      	beq.n	801d718 <lv_img_decoder_built_in_line_alpha+0x2f4>
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
 801d704:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801d708:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 801d70a:	4413      	add	r3, r2
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
 801d70c:	781a      	ldrb	r2, [r3, #0]
 801d70e:	e005      	b.n	801d71c <lv_img_decoder_built_in_line_alpha+0x2f8>
 801d710:	ffaa5500 	.word	0xffaa5500
 801d714:	0802e49c 	.word	0x0802e49c
 801d718:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 801d71c:	f9b7 1056 	ldrsh.w	r1, [r7, #86]	; 0x56
 801d720:	460b      	mov	r3, r1
 801d722:	005b      	lsls	r3, r3, #1
 801d724:	440b      	add	r3, r1
 801d726:	3302      	adds	r3, #2
 801d728:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 801d72a:	440b      	add	r3, r1
 801d72c:	701a      	strb	r2, [r3, #0]

        pos -= px_size;
 801d72e:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 801d732:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801d736:	1ad3      	subs	r3, r2, r3
 801d738:	b2db      	uxtb	r3, r3
 801d73a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        if(pos < 0) {
 801d73e:	f997 3047 	ldrsb.w	r3, [r7, #71]	; 0x47
 801d742:	2b00      	cmp	r3, #0
 801d744:	da09      	bge.n	801d75a <lv_img_decoder_built_in_line_alpha+0x336>
            pos = 8 - px_size;
 801d746:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801d74a:	f1c3 0308 	rsb	r3, r3, #8
 801d74e:	b2db      	uxtb	r3, r3
 801d750:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            data_tmp++;
 801d754:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d756:	3301      	adds	r3, #1
 801d758:	643b      	str	r3, [r7, #64]	; 0x40
    for(i = 0; i < len; i++) {
 801d75a:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801d75e:	b29b      	uxth	r3, r3
 801d760:	3301      	adds	r3, #1
 801d762:	b29b      	uxth	r3, r3
 801d764:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 801d768:	f9b7 2056 	ldrsh.w	r2, [r7, #86]	; 0x56
 801d76c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801d770:	429a      	cmp	r2, r3
 801d772:	dbb0      	blt.n	801d6d6 <lv_img_decoder_built_in_line_alpha+0x2b2>
        }
    }
#if LV_USE_FILESYSTEM
    _lv_mem_buf_release(fs_buf);
 801d774:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801d776:	f003 fc6b 	bl	8021050 <_lv_mem_buf_release>
#endif
    return LV_RES_OK;
 801d77a:	2301      	movs	r3, #1

#else
    LV_LOG_WARN("Image built-in alpha line reader failed because LV_IMG_CF_ALPHA is 0 in lv_conf.h");
    return LV_RES_INV;
#endif
}
 801d77c:	4618      	mov	r0, r3
 801d77e:	375c      	adds	r7, #92	; 0x5c
 801d780:	46bd      	mov	sp, r7
 801d782:	bd90      	pop	{r4, r7, pc}

0801d784 <lv_img_decoder_built_in_line_indexed>:

static lv_res_t lv_img_decoder_built_in_line_indexed(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                     lv_coord_t len, uint8_t * buf)
{
 801d784:	b580      	push	{r7, lr}
 801d786:	b08e      	sub	sp, #56	; 0x38
 801d788:	af00      	add	r7, sp, #0
 801d78a:	60f8      	str	r0, [r7, #12]
 801d78c:	4608      	mov	r0, r1
 801d78e:	4611      	mov	r1, r2
 801d790:	461a      	mov	r2, r3
 801d792:	4603      	mov	r3, r0
 801d794:	817b      	strh	r3, [r7, #10]
 801d796:	460b      	mov	r3, r1
 801d798:	813b      	strh	r3, [r7, #8]
 801d79a:	4613      	mov	r3, r2
 801d79c:	80fb      	strh	r3, [r7, #6]

#if LV_IMG_CF_INDEXED
    uint8_t px_size = lv_img_cf_get_px_size(dsc->header.cf);
 801d79e:	68fb      	ldr	r3, [r7, #12]
 801d7a0:	7b1b      	ldrb	r3, [r3, #12]
 801d7a2:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801d7a6:	b2db      	uxtb	r3, r3
 801d7a8:	4618      	mov	r0, r3
 801d7aa:	f7f4 fe83 	bl	80124b4 <lv_img_cf_get_px_size>
 801d7ae:	4603      	mov	r3, r0
 801d7b0:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
 801d7b4:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801d7b8:	2201      	movs	r2, #1
 801d7ba:	fa02 f303 	lsl.w	r3, r2, r3
 801d7be:	b29b      	uxth	r3, r3
 801d7c0:	3b01      	subs	r3, #1
 801d7c2:	84fb      	strh	r3, [r7, #38]	; 0x26

    lv_coord_t w = 0;
 801d7c4:	2300      	movs	r3, #0
 801d7c6:	86fb      	strh	r3, [r7, #54]	; 0x36
    int8_t pos   = 0;
 801d7c8:	2300      	movs	r3, #0
 801d7ca:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
    uint32_t ofs = 0;
 801d7ce:	2300      	movs	r3, #0
 801d7d0:	633b      	str	r3, [r7, #48]	; 0x30
    switch(dsc->header.cf) {
 801d7d2:	68fb      	ldr	r3, [r7, #12]
 801d7d4:	7b1b      	ldrb	r3, [r3, #12]
 801d7d6:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801d7da:	b2db      	uxtb	r3, r3
 801d7dc:	3b07      	subs	r3, #7
 801d7de:	2b03      	cmp	r3, #3
 801d7e0:	f200 80be 	bhi.w	801d960 <lv_img_decoder_built_in_line_indexed+0x1dc>
 801d7e4:	a201      	add	r2, pc, #4	; (adr r2, 801d7ec <lv_img_decoder_built_in_line_indexed+0x68>)
 801d7e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801d7ea:	bf00      	nop
 801d7ec:	0801d7fd 	.word	0x0801d7fd
 801d7f0:	0801d85f 	.word	0x0801d85f
 801d7f4:	0801d8c5 	.word	0x0801d8c5
 801d7f8:	0801d92b 	.word	0x0801d92b
        case LV_IMG_CF_INDEXED_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
 801d7fc:	68fb      	ldr	r3, [r7, #12]
 801d7fe:	68db      	ldr	r3, [r3, #12]
 801d800:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d804:	b29b      	uxth	r3, r3
 801d806:	10db      	asrs	r3, r3, #3
 801d808:	86fb      	strh	r3, [r7, #54]	; 0x36
            if(dsc->header.w & 0x7) w++;
 801d80a:	68fb      	ldr	r3, [r7, #12]
 801d80c:	68db      	ldr	r3, [r3, #12]
 801d80e:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d812:	b29b      	uxth	r3, r3
 801d814:	f003 0307 	and.w	r3, r3, #7
 801d818:	2b00      	cmp	r3, #0
 801d81a:	d005      	beq.n	801d828 <lv_img_decoder_built_in_line_indexed+0xa4>
 801d81c:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801d820:	b29b      	uxth	r3, r3
 801d822:	3301      	adds	r3, #1
 801d824:	b29b      	uxth	r3, r3
 801d826:	86fb      	strh	r3, [r7, #54]	; 0x36
            ofs += w * y + (x >> 3); /*First pixel*/
 801d828:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801d82c:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801d830:	fb02 f303 	mul.w	r3, r2, r3
 801d834:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801d838:	10d2      	asrs	r2, r2, #3
 801d83a:	b212      	sxth	r2, r2
 801d83c:	4413      	add	r3, r2
 801d83e:	461a      	mov	r2, r3
 801d840:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d842:	4413      	add	r3, r2
 801d844:	633b      	str	r3, [r7, #48]	; 0x30
            ofs += 8;                /*Skip the palette*/
 801d846:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d848:	3308      	adds	r3, #8
 801d84a:	633b      	str	r3, [r7, #48]	; 0x30
            pos = 7 - (x & 0x7);
 801d84c:	897b      	ldrh	r3, [r7, #10]
 801d84e:	b25b      	sxtb	r3, r3
 801d850:	43db      	mvns	r3, r3
 801d852:	b25b      	sxtb	r3, r3
 801d854:	f003 0307 	and.w	r3, r3, #7
 801d858:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
            break;
 801d85c:	e080      	b.n	801d960 <lv_img_decoder_built_in_line_indexed+0x1dc>
        case LV_IMG_CF_INDEXED_2BIT:
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
 801d85e:	68fb      	ldr	r3, [r7, #12]
 801d860:	68db      	ldr	r3, [r3, #12]
 801d862:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d866:	b29b      	uxth	r3, r3
 801d868:	109b      	asrs	r3, r3, #2
 801d86a:	86fb      	strh	r3, [r7, #54]	; 0x36
            if(dsc->header.w & 0x3) w++;
 801d86c:	68fb      	ldr	r3, [r7, #12]
 801d86e:	68db      	ldr	r3, [r3, #12]
 801d870:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d874:	b29b      	uxth	r3, r3
 801d876:	f003 0303 	and.w	r3, r3, #3
 801d87a:	2b00      	cmp	r3, #0
 801d87c:	d005      	beq.n	801d88a <lv_img_decoder_built_in_line_indexed+0x106>
 801d87e:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801d882:	b29b      	uxth	r3, r3
 801d884:	3301      	adds	r3, #1
 801d886:	b29b      	uxth	r3, r3
 801d888:	86fb      	strh	r3, [r7, #54]	; 0x36
            ofs += w * y + (x >> 2); /*First pixel*/
 801d88a:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801d88e:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801d892:	fb02 f303 	mul.w	r3, r2, r3
 801d896:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801d89a:	1092      	asrs	r2, r2, #2
 801d89c:	b212      	sxth	r2, r2
 801d89e:	4413      	add	r3, r2
 801d8a0:	461a      	mov	r2, r3
 801d8a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d8a4:	4413      	add	r3, r2
 801d8a6:	633b      	str	r3, [r7, #48]	; 0x30
            ofs += 16;               /*Skip the palette*/
 801d8a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d8aa:	3310      	adds	r3, #16
 801d8ac:	633b      	str	r3, [r7, #48]	; 0x30
            pos = 6 - ((x & 0x3) * 2);
 801d8ae:	897b      	ldrh	r3, [r7, #10]
 801d8b0:	43db      	mvns	r3, r3
 801d8b2:	b2db      	uxtb	r3, r3
 801d8b4:	f003 0303 	and.w	r3, r3, #3
 801d8b8:	b2db      	uxtb	r3, r3
 801d8ba:	005b      	lsls	r3, r3, #1
 801d8bc:	b2db      	uxtb	r3, r3
 801d8be:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
            break;
 801d8c2:	e04d      	b.n	801d960 <lv_img_decoder_built_in_line_indexed+0x1dc>
        case LV_IMG_CF_INDEXED_4BIT:
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
 801d8c4:	68fb      	ldr	r3, [r7, #12]
 801d8c6:	68db      	ldr	r3, [r3, #12]
 801d8c8:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d8cc:	b29b      	uxth	r3, r3
 801d8ce:	105b      	asrs	r3, r3, #1
 801d8d0:	86fb      	strh	r3, [r7, #54]	; 0x36
            if(dsc->header.w & 0x1) w++;
 801d8d2:	68fb      	ldr	r3, [r7, #12]
 801d8d4:	68db      	ldr	r3, [r3, #12]
 801d8d6:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d8da:	b29b      	uxth	r3, r3
 801d8dc:	f003 0301 	and.w	r3, r3, #1
 801d8e0:	2b00      	cmp	r3, #0
 801d8e2:	d005      	beq.n	801d8f0 <lv_img_decoder_built_in_line_indexed+0x16c>
 801d8e4:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801d8e8:	b29b      	uxth	r3, r3
 801d8ea:	3301      	adds	r3, #1
 801d8ec:	b29b      	uxth	r3, r3
 801d8ee:	86fb      	strh	r3, [r7, #54]	; 0x36
            ofs += w * y + (x >> 1); /*First pixel*/
 801d8f0:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801d8f4:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801d8f8:	fb02 f303 	mul.w	r3, r2, r3
 801d8fc:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801d900:	1052      	asrs	r2, r2, #1
 801d902:	b212      	sxth	r2, r2
 801d904:	4413      	add	r3, r2
 801d906:	461a      	mov	r2, r3
 801d908:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d90a:	4413      	add	r3, r2
 801d90c:	633b      	str	r3, [r7, #48]	; 0x30
            ofs += 64;               /*Skip the palette*/
 801d90e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d910:	3340      	adds	r3, #64	; 0x40
 801d912:	633b      	str	r3, [r7, #48]	; 0x30
            pos = 4 - ((x & 0x1) * 4);
 801d914:	897b      	ldrh	r3, [r7, #10]
 801d916:	f003 0301 	and.w	r3, r3, #1
 801d91a:	2b00      	cmp	r3, #0
 801d91c:	d101      	bne.n	801d922 <lv_img_decoder_built_in_line_indexed+0x19e>
 801d91e:	2304      	movs	r3, #4
 801d920:	e000      	b.n	801d924 <lv_img_decoder_built_in_line_indexed+0x1a0>
 801d922:	2300      	movs	r3, #0
 801d924:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
            break;
 801d928:	e01a      	b.n	801d960 <lv_img_decoder_built_in_line_indexed+0x1dc>
        case LV_IMG_CF_INDEXED_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
 801d92a:	68fb      	ldr	r3, [r7, #12]
 801d92c:	68db      	ldr	r3, [r3, #12]
 801d92e:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801d932:	b29b      	uxth	r3, r3
 801d934:	86fb      	strh	r3, [r7, #54]	; 0x36
            ofs += w * y + x;  /*First pixel*/
 801d936:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801d93a:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801d93e:	fb03 f202 	mul.w	r2, r3, r2
 801d942:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801d946:	4413      	add	r3, r2
 801d948:	461a      	mov	r2, r3
 801d94a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d94c:	4413      	add	r3, r2
 801d94e:	633b      	str	r3, [r7, #48]	; 0x30
            ofs += 1024;       /*Skip the palette*/
 801d950:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d952:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801d956:	633b      	str	r3, [r7, #48]	; 0x30
            pos = 0;
 801d958:	2300      	movs	r3, #0
 801d95a:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
            break;
 801d95e:	bf00      	nop
    }

    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801d960:	68fb      	ldr	r3, [r7, #12]
 801d962:	69db      	ldr	r3, [r3, #28]
 801d964:	623b      	str	r3, [r7, #32]

#if LV_USE_FILESYSTEM
    uint8_t * fs_buf = _lv_mem_buf_get(w);
 801d966:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801d96a:	4618      	mov	r0, r3
 801d96c:	f003 fa90 	bl	8020e90 <_lv_mem_buf_get>
 801d970:	61f8      	str	r0, [r7, #28]
#endif
    const uint8_t * data_tmp = NULL;
 801d972:	2300      	movs	r3, #0
 801d974:	62fb      	str	r3, [r7, #44]	; 0x2c
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 801d976:	68fb      	ldr	r3, [r7, #12]
 801d978:	7a9b      	ldrb	r3, [r3, #10]
 801d97a:	2b00      	cmp	r3, #0
 801d97c:	d108      	bne.n	801d990 <lv_img_decoder_built_in_line_indexed+0x20c>
        const lv_img_dsc_t * img_dsc = dsc->src;
 801d97e:	68fb      	ldr	r3, [r7, #12]
 801d980:	685b      	ldr	r3, [r3, #4]
 801d982:	61bb      	str	r3, [r7, #24]
        data_tmp                     = img_dsc->data + ofs;
 801d984:	69bb      	ldr	r3, [r7, #24]
 801d986:	689a      	ldr	r2, [r3, #8]
 801d988:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d98a:	4413      	add	r3, r2
 801d98c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801d98e:	e011      	b.n	801d9b4 <lv_img_decoder_built_in_line_indexed+0x230>
    }
    else {
#if LV_USE_FILESYSTEM
        lv_fs_seek(user_data->f, ofs + 4); /*+4 to skip the header*/
 801d990:	6a3b      	ldr	r3, [r7, #32]
 801d992:	681a      	ldr	r2, [r3, #0]
 801d994:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801d996:	3304      	adds	r3, #4
 801d998:	4619      	mov	r1, r3
 801d99a:	4610      	mov	r0, r2
 801d99c:	f002 fd53 	bl	8020446 <lv_fs_seek>
        lv_fs_read(user_data->f, fs_buf, w, NULL);
 801d9a0:	6a3b      	ldr	r3, [r7, #32]
 801d9a2:	6818      	ldr	r0, [r3, #0]
 801d9a4:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 801d9a8:	2300      	movs	r3, #0
 801d9aa:	69f9      	ldr	r1, [r7, #28]
 801d9ac:	f002 fd15 	bl	80203da <lv_fs_read>
        data_tmp = fs_buf;
 801d9b0:	69fb      	ldr	r3, [r7, #28]
 801d9b2:	62fb      	str	r3, [r7, #44]	; 0x2c
        return LV_RES_INV;
#endif
    }

    lv_coord_t i;
    for(i = 0; i < len; i++) {
 801d9b4:	2300      	movs	r3, #0
 801d9b6:	857b      	strh	r3, [r7, #42]	; 0x2a
 801d9b8:	e057      	b.n	801da6a <lv_img_decoder_built_in_line_indexed+0x2e6>
        uint8_t val_act = (*data_tmp & (mask << pos)) >> pos;
 801d9ba:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801d9bc:	781b      	ldrb	r3, [r3, #0]
 801d9be:	4619      	mov	r1, r3
 801d9c0:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801d9c2:	f997 3035 	ldrsb.w	r3, [r7, #53]	; 0x35
 801d9c6:	fa02 f303 	lsl.w	r3, r2, r3
 801d9ca:	ea01 0203 	and.w	r2, r1, r3
 801d9ce:	f997 3035 	ldrsb.w	r3, [r7, #53]	; 0x35
 801d9d2:	fa42 f303 	asr.w	r3, r2, r3
 801d9d6:	75fb      	strb	r3, [r7, #23]

        lv_color_t color = user_data->palette[val_act];
 801d9d8:	6a3b      	ldr	r3, [r7, #32]
 801d9da:	685a      	ldr	r2, [r3, #4]
 801d9dc:	7dfb      	ldrb	r3, [r7, #23]
 801d9de:	005b      	lsls	r3, r3, #1
 801d9e0:	4413      	add	r3, r2
 801d9e2:	881b      	ldrh	r3, [r3, #0]
 801d9e4:	82bb      	strh	r3, [r7, #20]
#if LV_COLOR_DEPTH == 8 || LV_COLOR_DEPTH == 1
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = color.full;
#elif LV_COLOR_DEPTH == 16
        /*Because of Alpha byte 16 bit color can start on odd address which can cause crash*/
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = color.full & 0xFF;
 801d9e6:	8ab9      	ldrh	r1, [r7, #20]
 801d9e8:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 801d9ec:	4613      	mov	r3, r2
 801d9ee:	005b      	lsls	r3, r3, #1
 801d9f0:	4413      	add	r3, r2
 801d9f2:	461a      	mov	r2, r3
 801d9f4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801d9f6:	4413      	add	r3, r2
 801d9f8:	b2ca      	uxtb	r2, r1
 801d9fa:	701a      	strb	r2, [r3, #0]
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + 1] = (color.full >> 8) & 0xFF;
 801d9fc:	8abb      	ldrh	r3, [r7, #20]
 801d9fe:	0a1b      	lsrs	r3, r3, #8
 801da00:	b299      	uxth	r1, r3
 801da02:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 801da06:	4613      	mov	r3, r2
 801da08:	005b      	lsls	r3, r3, #1
 801da0a:	4413      	add	r3, r2
 801da0c:	3301      	adds	r3, #1
 801da0e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801da10:	4413      	add	r3, r2
 801da12:	b2ca      	uxtb	r2, r1
 801da14:	701a      	strb	r2, [r3, #0]
#elif LV_COLOR_DEPTH == 32
        *((uint32_t *)&buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE]) = color.full;
#else
#error "Invalid LV_COLOR_DEPTH. Check it in lv_conf.h"
#endif
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] = user_data->opa[val_act];
 801da16:	6a3b      	ldr	r3, [r7, #32]
 801da18:	689a      	ldr	r2, [r3, #8]
 801da1a:	7dfb      	ldrb	r3, [r7, #23]
 801da1c:	18d1      	adds	r1, r2, r3
 801da1e:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 801da22:	4613      	mov	r3, r2
 801da24:	005b      	lsls	r3, r3, #1
 801da26:	4413      	add	r3, r2
 801da28:	3302      	adds	r3, #2
 801da2a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801da2c:	4413      	add	r3, r2
 801da2e:	780a      	ldrb	r2, [r1, #0]
 801da30:	701a      	strb	r2, [r3, #0]

        pos -= px_size;
 801da32:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
 801da36:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801da3a:	1ad3      	subs	r3, r2, r3
 801da3c:	b2db      	uxtb	r3, r3
 801da3e:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
        if(pos < 0) {
 801da42:	f997 3035 	ldrsb.w	r3, [r7, #53]	; 0x35
 801da46:	2b00      	cmp	r3, #0
 801da48:	da09      	bge.n	801da5e <lv_img_decoder_built_in_line_indexed+0x2da>
            pos = 8 - px_size;
 801da4a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801da4e:	f1c3 0308 	rsb	r3, r3, #8
 801da52:	b2db      	uxtb	r3, r3
 801da54:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
            data_tmp++;
 801da58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801da5a:	3301      	adds	r3, #1
 801da5c:	62fb      	str	r3, [r7, #44]	; 0x2c
    for(i = 0; i < len; i++) {
 801da5e:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801da62:	b29b      	uxth	r3, r3
 801da64:	3301      	adds	r3, #1
 801da66:	b29b      	uxth	r3, r3
 801da68:	857b      	strh	r3, [r7, #42]	; 0x2a
 801da6a:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 801da6e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801da72:	429a      	cmp	r2, r3
 801da74:	dba1      	blt.n	801d9ba <lv_img_decoder_built_in_line_indexed+0x236>
        }
    }
#if LV_USE_FILESYSTEM
    _lv_mem_buf_release(fs_buf);
 801da76:	69f8      	ldr	r0, [r7, #28]
 801da78:	f003 faea 	bl	8021050 <_lv_mem_buf_release>
#endif
    return LV_RES_OK;
 801da7c:	2301      	movs	r3, #1
#else
    LV_LOG_WARN("Image built-in indexed line reader failed because LV_IMG_CF_INDEXED is 0 in lv_conf.h");
    return LV_RES_INV;
#endif
}
 801da7e:	4618      	mov	r0, r3
 801da80:	3738      	adds	r7, #56	; 0x38
 801da82:	46bd      	mov	sp, r7
 801da84:	bd80      	pop	{r7, pc}
 801da86:	bf00      	nop

0801da88 <lv_font_get_glyph_bitmap>:
 * @param font_p pointer to a font
 * @param letter an UNICODE character code
 * @return  pointer to the bitmap of the letter
 */
const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)
{
 801da88:	b580      	push	{r7, lr}
 801da8a:	b082      	sub	sp, #8
 801da8c:	af00      	add	r7, sp, #0
 801da8e:	6078      	str	r0, [r7, #4]
 801da90:	6039      	str	r1, [r7, #0]
    return font_p->get_glyph_bitmap(font_p, letter);
 801da92:	687b      	ldr	r3, [r7, #4]
 801da94:	685b      	ldr	r3, [r3, #4]
 801da96:	6839      	ldr	r1, [r7, #0]
 801da98:	6878      	ldr	r0, [r7, #4]
 801da9a:	4798      	blx	r3
 801da9c:	4603      	mov	r3, r0
}
 801da9e:	4618      	mov	r0, r3
 801daa0:	3708      	adds	r7, #8
 801daa2:	46bd      	mov	sp, r7
 801daa4:	bd80      	pop	{r7, pc}

0801daa6 <lv_font_get_glyph_dsc>:
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter,
                           uint32_t letter_next)
{
 801daa6:	b590      	push	{r4, r7, lr}
 801daa8:	b085      	sub	sp, #20
 801daaa:	af00      	add	r7, sp, #0
 801daac:	60f8      	str	r0, [r7, #12]
 801daae:	60b9      	str	r1, [r7, #8]
 801dab0:	607a      	str	r2, [r7, #4]
 801dab2:	603b      	str	r3, [r7, #0]
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
 801dab4:	68fb      	ldr	r3, [r7, #12]
 801dab6:	681c      	ldr	r4, [r3, #0]
 801dab8:	683b      	ldr	r3, [r7, #0]
 801daba:	687a      	ldr	r2, [r7, #4]
 801dabc:	68b9      	ldr	r1, [r7, #8]
 801dabe:	68f8      	ldr	r0, [r7, #12]
 801dac0:	47a0      	blx	r4
 801dac2:	4603      	mov	r3, r0
}
 801dac4:	4618      	mov	r0, r3
 801dac6:	3714      	adds	r7, #20
 801dac8:	46bd      	mov	sp, r7
 801daca:	bd90      	pop	{r4, r7, pc}

0801dacc <lv_font_get_glyph_width>:
 * @param letter an UNICODE letter
 * @param letter_next the next letter after `letter`. Used for kerning
 * @return the width of the glyph
 */
uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
{
 801dacc:	b580      	push	{r7, lr}
 801dace:	b088      	sub	sp, #32
 801dad0:	af00      	add	r7, sp, #0
 801dad2:	60f8      	str	r0, [r7, #12]
 801dad4:	60b9      	str	r1, [r7, #8]
 801dad6:	607a      	str	r2, [r7, #4]
    lv_font_glyph_dsc_t g;
    bool ret;
    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);
 801dad8:	f107 0110 	add.w	r1, r7, #16
 801dadc:	687b      	ldr	r3, [r7, #4]
 801dade:	68ba      	ldr	r2, [r7, #8]
 801dae0:	68f8      	ldr	r0, [r7, #12]
 801dae2:	f7ff ffe0 	bl	801daa6 <lv_font_get_glyph_dsc>
 801dae6:	4603      	mov	r3, r0
 801dae8:	77fb      	strb	r3, [r7, #31]
    if(ret) return g.adv_w;
 801daea:	7ffb      	ldrb	r3, [r7, #31]
 801daec:	2b00      	cmp	r3, #0
 801daee:	d001      	beq.n	801daf4 <lv_font_get_glyph_width+0x28>
 801daf0:	8a3b      	ldrh	r3, [r7, #16]
 801daf2:	e000      	b.n	801daf6 <lv_font_get_glyph_width+0x2a>
    else return 0;
 801daf4:	2300      	movs	r3, #0
}
 801daf6:	4618      	mov	r0, r3
 801daf8:	3720      	adds	r7, #32
 801dafa:	46bd      	mov	sp, r7
 801dafc:	bd80      	pop	{r7, pc}
	...

0801db00 <lv_font_get_bitmap_fmt_txt>:
 * @param font pointer to font
 * @param unicode_letter an unicode letter which bitmap should be get
 * @return pointer to the bitmap or NULL if not found
 */
const uint8_t * lv_font_get_bitmap_fmt_txt(const lv_font_t * font, uint32_t unicode_letter)
{
 801db00:	b5b0      	push	{r4, r5, r7, lr}
 801db02:	b08a      	sub	sp, #40	; 0x28
 801db04:	af02      	add	r7, sp, #8
 801db06:	6078      	str	r0, [r7, #4]
 801db08:	6039      	str	r1, [r7, #0]
    if(unicode_letter == '\t') unicode_letter = ' ';
 801db0a:	683b      	ldr	r3, [r7, #0]
 801db0c:	2b09      	cmp	r3, #9
 801db0e:	d101      	bne.n	801db14 <lv_font_get_bitmap_fmt_txt+0x14>
 801db10:	2320      	movs	r3, #32
 801db12:	603b      	str	r3, [r7, #0]

    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801db14:	687b      	ldr	r3, [r7, #4]
 801db16:	691b      	ldr	r3, [r3, #16]
 801db18:	61bb      	str	r3, [r7, #24]
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
 801db1a:	6839      	ldr	r1, [r7, #0]
 801db1c:	6878      	ldr	r0, [r7, #4]
 801db1e:	f000 f951 	bl	801ddc4 <get_glyph_dsc_id>
 801db22:	6178      	str	r0, [r7, #20]
    if(!gid) return NULL;
 801db24:	697b      	ldr	r3, [r7, #20]
 801db26:	2b00      	cmp	r3, #0
 801db28:	d101      	bne.n	801db2e <lv_font_get_bitmap_fmt_txt+0x2e>
 801db2a:	2300      	movs	r3, #0
 801db2c:	e0a6      	b.n	801dc7c <lv_font_get_bitmap_fmt_txt+0x17c>

    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
 801db2e:	69bb      	ldr	r3, [r7, #24]
 801db30:	685a      	ldr	r2, [r3, #4]
 801db32:	697b      	ldr	r3, [r7, #20]
 801db34:	00db      	lsls	r3, r3, #3
 801db36:	4413      	add	r3, r2
 801db38:	613b      	str	r3, [r7, #16]

    if(fdsc->bitmap_format == LV_FONT_FMT_TXT_PLAIN) {
 801db3a:	69bb      	ldr	r3, [r7, #24]
 801db3c:	7d1b      	ldrb	r3, [r3, #20]
 801db3e:	f003 0303 	and.w	r3, r3, #3
 801db42:	b2db      	uxtb	r3, r3
 801db44:	2b00      	cmp	r3, #0
 801db46:	d10b      	bne.n	801db60 <lv_font_get_bitmap_fmt_txt+0x60>
        if(gdsc) return &fdsc->glyph_bitmap[gdsc->bitmap_index];
 801db48:	693b      	ldr	r3, [r7, #16]
 801db4a:	2b00      	cmp	r3, #0
 801db4c:	f000 8095 	beq.w	801dc7a <lv_font_get_bitmap_fmt_txt+0x17a>
 801db50:	69bb      	ldr	r3, [r7, #24]
 801db52:	681b      	ldr	r3, [r3, #0]
 801db54:	693a      	ldr	r2, [r7, #16]
 801db56:	6812      	ldr	r2, [r2, #0]
 801db58:	f3c2 0213 	ubfx	r2, r2, #0, #20
 801db5c:	4413      	add	r3, r2
 801db5e:	e08d      	b.n	801dc7c <lv_font_get_bitmap_fmt_txt+0x17c>
    }
    /*Handle compressed bitmap*/
    else {
#if LV_USE_FONT_COMPRESSED
        uint32_t gsize = gdsc->box_w * gdsc->box_h;
 801db60:	693b      	ldr	r3, [r7, #16]
 801db62:	791b      	ldrb	r3, [r3, #4]
 801db64:	461a      	mov	r2, r3
 801db66:	693b      	ldr	r3, [r7, #16]
 801db68:	795b      	ldrb	r3, [r3, #5]
 801db6a:	fb02 f303 	mul.w	r3, r2, r3
 801db6e:	60fb      	str	r3, [r7, #12]
        if(gsize == 0) return NULL;
 801db70:	68fb      	ldr	r3, [r7, #12]
 801db72:	2b00      	cmp	r3, #0
 801db74:	d101      	bne.n	801db7a <lv_font_get_bitmap_fmt_txt+0x7a>
 801db76:	2300      	movs	r3, #0
 801db78:	e080      	b.n	801dc7c <lv_font_get_bitmap_fmt_txt+0x17c>

        uint32_t buf_size = gsize;
 801db7a:	68fb      	ldr	r3, [r7, #12]
 801db7c:	61fb      	str	r3, [r7, #28]
        /*Compute memory size needed to hold decompressed glyph, rounding up*/
        switch(fdsc->bpp) {
 801db7e:	69bb      	ldr	r3, [r7, #24]
 801db80:	7cdb      	ldrb	r3, [r3, #19]
 801db82:	f3c3 0383 	ubfx	r3, r3, #2, #4
 801db86:	b2db      	uxtb	r3, r3
 801db88:	3b01      	subs	r3, #1
 801db8a:	2b03      	cmp	r3, #3
 801db8c:	d81e      	bhi.n	801dbcc <lv_font_get_bitmap_fmt_txt+0xcc>
 801db8e:	a201      	add	r2, pc, #4	; (adr r2, 801db94 <lv_font_get_bitmap_fmt_txt+0x94>)
 801db90:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801db94:	0801dba5 	.word	0x0801dba5
 801db98:	0801dbaf 	.word	0x0801dbaf
 801db9c:	0801dbb9 	.word	0x0801dbb9
 801dba0:	0801dbc3 	.word	0x0801dbc3
            case 1:
                buf_size = (gsize + 7) >> 3;
 801dba4:	68fb      	ldr	r3, [r7, #12]
 801dba6:	3307      	adds	r3, #7
 801dba8:	08db      	lsrs	r3, r3, #3
 801dbaa:	61fb      	str	r3, [r7, #28]
                break;
 801dbac:	e00e      	b.n	801dbcc <lv_font_get_bitmap_fmt_txt+0xcc>
            case 2:
                buf_size = (gsize + 3) >> 2;
 801dbae:	68fb      	ldr	r3, [r7, #12]
 801dbb0:	3303      	adds	r3, #3
 801dbb2:	089b      	lsrs	r3, r3, #2
 801dbb4:	61fb      	str	r3, [r7, #28]
                break;
 801dbb6:	e009      	b.n	801dbcc <lv_font_get_bitmap_fmt_txt+0xcc>
            case 3:
                buf_size = (gsize + 1) >> 1;
 801dbb8:	68fb      	ldr	r3, [r7, #12]
 801dbba:	3301      	adds	r3, #1
 801dbbc:	085b      	lsrs	r3, r3, #1
 801dbbe:	61fb      	str	r3, [r7, #28]
                break;
 801dbc0:	e004      	b.n	801dbcc <lv_font_get_bitmap_fmt_txt+0xcc>
            case 4:
                buf_size = (gsize + 1) >> 1;
 801dbc2:	68fb      	ldr	r3, [r7, #12]
 801dbc4:	3301      	adds	r3, #1
 801dbc6:	085b      	lsrs	r3, r3, #1
 801dbc8:	61fb      	str	r3, [r7, #28]
                break;
 801dbca:	bf00      	nop
        }

        if(_lv_mem_get_size(decompr_buf) < buf_size) {
 801dbcc:	4b2d      	ldr	r3, [pc, #180]	; (801dc84 <lv_font_get_bitmap_fmt_txt+0x184>)
 801dbce:	681b      	ldr	r3, [r3, #0]
 801dbd0:	4618      	mov	r0, r3
 801dbd2:	f003 f93f 	bl	8020e54 <_lv_mem_get_size>
 801dbd6:	4602      	mov	r2, r0
 801dbd8:	69fb      	ldr	r3, [r7, #28]
 801dbda:	4293      	cmp	r3, r2
 801dbdc:	d925      	bls.n	801dc2a <lv_font_get_bitmap_fmt_txt+0x12a>
            decompr_buf = lv_mem_realloc(decompr_buf, buf_size);
 801dbde:	4b29      	ldr	r3, [pc, #164]	; (801dc84 <lv_font_get_bitmap_fmt_txt+0x184>)
 801dbe0:	681b      	ldr	r3, [r3, #0]
 801dbe2:	69f9      	ldr	r1, [r7, #28]
 801dbe4:	4618      	mov	r0, r3
 801dbe6:	f003 f895 	bl	8020d14 <lv_mem_realloc>
 801dbea:	4603      	mov	r3, r0
 801dbec:	4a25      	ldr	r2, [pc, #148]	; (801dc84 <lv_font_get_bitmap_fmt_txt+0x184>)
 801dbee:	6013      	str	r3, [r2, #0]
            LV_ASSERT_MEM(decompr_buf);
 801dbf0:	4b24      	ldr	r3, [pc, #144]	; (801dc84 <lv_font_get_bitmap_fmt_txt+0x184>)
 801dbf2:	681b      	ldr	r3, [r3, #0]
 801dbf4:	4618      	mov	r0, r3
 801dbf6:	f002 fa7b 	bl	80200f0 <lv_debug_check_null>
 801dbfa:	4603      	mov	r3, r0
 801dbfc:	f083 0301 	eor.w	r3, r3, #1
 801dc00:	b2db      	uxtb	r3, r3
 801dc02:	2b00      	cmp	r3, #0
 801dc04:	d00b      	beq.n	801dc1e <lv_font_get_bitmap_fmt_txt+0x11e>
 801dc06:	4b1f      	ldr	r3, [pc, #124]	; (801dc84 <lv_font_get_bitmap_fmt_txt+0x184>)
 801dc08:	681b      	ldr	r3, [r3, #0]
 801dc0a:	461a      	mov	r2, r3
 801dc0c:	2300      	movs	r3, #0
 801dc0e:	4614      	mov	r4, r2
 801dc10:	461d      	mov	r5, r3
 801dc12:	4622      	mov	r2, r4
 801dc14:	462b      	mov	r3, r5
 801dc16:	481c      	ldr	r0, [pc, #112]	; (801dc88 <lv_font_get_bitmap_fmt_txt+0x188>)
 801dc18:	f002 fa7a 	bl	8020110 <lv_debug_log_error>
 801dc1c:	e7fe      	b.n	801dc1c <lv_font_get_bitmap_fmt_txt+0x11c>
            if(decompr_buf == NULL) return NULL;
 801dc1e:	4b19      	ldr	r3, [pc, #100]	; (801dc84 <lv_font_get_bitmap_fmt_txt+0x184>)
 801dc20:	681b      	ldr	r3, [r3, #0]
 801dc22:	2b00      	cmp	r3, #0
 801dc24:	d101      	bne.n	801dc2a <lv_font_get_bitmap_fmt_txt+0x12a>
 801dc26:	2300      	movs	r3, #0
 801dc28:	e028      	b.n	801dc7c <lv_font_get_bitmap_fmt_txt+0x17c>
        }

        bool prefilter = fdsc->bitmap_format == LV_FONT_FMT_TXT_COMPRESSED ? true : false;
 801dc2a:	69bb      	ldr	r3, [r7, #24]
 801dc2c:	7d1b      	ldrb	r3, [r3, #20]
 801dc2e:	f003 0303 	and.w	r3, r3, #3
 801dc32:	b2db      	uxtb	r3, r3
 801dc34:	2b01      	cmp	r3, #1
 801dc36:	bf0c      	ite	eq
 801dc38:	2301      	moveq	r3, #1
 801dc3a:	2300      	movne	r3, #0
 801dc3c:	72fb      	strb	r3, [r7, #11]
        decompress(&fdsc->glyph_bitmap[gdsc->bitmap_index], decompr_buf, gdsc->box_w, gdsc->box_h, (uint8_t)fdsc->bpp,
 801dc3e:	69bb      	ldr	r3, [r7, #24]
 801dc40:	681b      	ldr	r3, [r3, #0]
 801dc42:	693a      	ldr	r2, [r7, #16]
 801dc44:	6812      	ldr	r2, [r2, #0]
 801dc46:	f3c2 0213 	ubfx	r2, r2, #0, #20
 801dc4a:	1898      	adds	r0, r3, r2
 801dc4c:	4b0d      	ldr	r3, [pc, #52]	; (801dc84 <lv_font_get_bitmap_fmt_txt+0x184>)
 801dc4e:	6819      	ldr	r1, [r3, #0]
 801dc50:	693b      	ldr	r3, [r7, #16]
 801dc52:	791b      	ldrb	r3, [r3, #4]
 801dc54:	b21a      	sxth	r2, r3
 801dc56:	693b      	ldr	r3, [r7, #16]
 801dc58:	795b      	ldrb	r3, [r3, #5]
 801dc5a:	b21c      	sxth	r4, r3
 801dc5c:	69bb      	ldr	r3, [r7, #24]
 801dc5e:	7cdb      	ldrb	r3, [r3, #19]
 801dc60:	f3c3 0383 	ubfx	r3, r3, #2, #4
 801dc64:	b2db      	uxtb	r3, r3
 801dc66:	461d      	mov	r5, r3
 801dc68:	7afb      	ldrb	r3, [r7, #11]
 801dc6a:	9301      	str	r3, [sp, #4]
 801dc6c:	9500      	str	r5, [sp, #0]
 801dc6e:	4623      	mov	r3, r4
 801dc70:	f000 fad2 	bl	801e218 <decompress>
                   prefilter);
        return decompr_buf;
 801dc74:	4b03      	ldr	r3, [pc, #12]	; (801dc84 <lv_font_get_bitmap_fmt_txt+0x184>)
 801dc76:	681b      	ldr	r3, [r3, #0]
 801dc78:	e000      	b.n	801dc7c <lv_font_get_bitmap_fmt_txt+0x17c>
        return NULL;
#endif
    }

    /*If not returned earlier then the letter is not found in this font*/
    return NULL;
 801dc7a:	2300      	movs	r3, #0
}
 801dc7c:	4618      	mov	r0, r3
 801dc7e:	3720      	adds	r7, #32
 801dc80:	46bd      	mov	sp, r7
 801dc82:	bdb0      	pop	{r4, r5, r7, pc}
 801dc84:	2000a14c 	.word	0x2000a14c
 801dc88:	0802e4ac 	.word	0x0802e4ac

0801dc8c <lv_font_get_glyph_dsc_fmt_txt>:
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc_fmt_txt(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out, uint32_t unicode_letter,
                                   uint32_t unicode_letter_next)
{
 801dc8c:	b580      	push	{r7, lr}
 801dc8e:	b08c      	sub	sp, #48	; 0x30
 801dc90:	af00      	add	r7, sp, #0
 801dc92:	60f8      	str	r0, [r7, #12]
 801dc94:	60b9      	str	r1, [r7, #8]
 801dc96:	607a      	str	r2, [r7, #4]
 801dc98:	603b      	str	r3, [r7, #0]
    bool is_tab = false;
 801dc9a:	2300      	movs	r3, #0
 801dc9c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    if(unicode_letter == '\t') {
 801dca0:	687b      	ldr	r3, [r7, #4]
 801dca2:	2b09      	cmp	r3, #9
 801dca4:	d104      	bne.n	801dcb0 <lv_font_get_glyph_dsc_fmt_txt+0x24>
        unicode_letter = ' ';
 801dca6:	2320      	movs	r3, #32
 801dca8:	607b      	str	r3, [r7, #4]
        is_tab = true;
 801dcaa:	2301      	movs	r3, #1
 801dcac:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    }
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801dcb0:	68fb      	ldr	r3, [r7, #12]
 801dcb2:	691b      	ldr	r3, [r3, #16]
 801dcb4:	627b      	str	r3, [r7, #36]	; 0x24
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
 801dcb6:	6879      	ldr	r1, [r7, #4]
 801dcb8:	68f8      	ldr	r0, [r7, #12]
 801dcba:	f000 f883 	bl	801ddc4 <get_glyph_dsc_id>
 801dcbe:	6238      	str	r0, [r7, #32]
    if(!gid) return false;
 801dcc0:	6a3b      	ldr	r3, [r7, #32]
 801dcc2:	2b00      	cmp	r3, #0
 801dcc4:	d101      	bne.n	801dcca <lv_font_get_glyph_dsc_fmt_txt+0x3e>
 801dcc6:	2300      	movs	r3, #0
 801dcc8:	e066      	b.n	801dd98 <lv_font_get_glyph_dsc_fmt_txt+0x10c>

    int8_t kvalue = 0;
 801dcca:	2300      	movs	r3, #0
 801dccc:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
    if(fdsc->kern_dsc) {
 801dcd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801dcd2:	68db      	ldr	r3, [r3, #12]
 801dcd4:	2b00      	cmp	r3, #0
 801dcd6:	d00f      	beq.n	801dcf8 <lv_font_get_glyph_dsc_fmt_txt+0x6c>
        uint32_t gid_next = get_glyph_dsc_id(font, unicode_letter_next);
 801dcd8:	6839      	ldr	r1, [r7, #0]
 801dcda:	68f8      	ldr	r0, [r7, #12]
 801dcdc:	f000 f872 	bl	801ddc4 <get_glyph_dsc_id>
 801dce0:	61f8      	str	r0, [r7, #28]
        if(gid_next) {
 801dce2:	69fb      	ldr	r3, [r7, #28]
 801dce4:	2b00      	cmp	r3, #0
 801dce6:	d007      	beq.n	801dcf8 <lv_font_get_glyph_dsc_fmt_txt+0x6c>
            kvalue = get_kern_value(font, gid, gid_next);
 801dce8:	69fa      	ldr	r2, [r7, #28]
 801dcea:	6a39      	ldr	r1, [r7, #32]
 801dcec:	68f8      	ldr	r0, [r7, #12]
 801dcee:	f000 f99f 	bl	801e030 <get_kern_value>
 801dcf2:	4603      	mov	r3, r0
 801dcf4:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
        }
    }

    /*Put together a glyph dsc*/
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
 801dcf8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801dcfa:	685a      	ldr	r2, [r3, #4]
 801dcfc:	6a3b      	ldr	r3, [r7, #32]
 801dcfe:	00db      	lsls	r3, r3, #3
 801dd00:	4413      	add	r3, r2
 801dd02:	61bb      	str	r3, [r7, #24]

    int32_t kv = ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
 801dd04:	f997 302e 	ldrsb.w	r3, [r7, #46]	; 0x2e
 801dd08:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801dd0a:	8a12      	ldrh	r2, [r2, #16]
 801dd0c:	fb02 f303 	mul.w	r3, r2, r3
 801dd10:	111b      	asrs	r3, r3, #4
 801dd12:	617b      	str	r3, [r7, #20]

    uint32_t adv_w = gdsc->adv_w;
 801dd14:	69bb      	ldr	r3, [r7, #24]
 801dd16:	885b      	ldrh	r3, [r3, #2]
 801dd18:	f3c3 130b 	ubfx	r3, r3, #4, #12
 801dd1c:	b29b      	uxth	r3, r3
 801dd1e:	62bb      	str	r3, [r7, #40]	; 0x28
    if(is_tab) adv_w *= 2;
 801dd20:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801dd24:	2b00      	cmp	r3, #0
 801dd26:	d002      	beq.n	801dd2e <lv_font_get_glyph_dsc_fmt_txt+0xa2>
 801dd28:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801dd2a:	005b      	lsls	r3, r3, #1
 801dd2c:	62bb      	str	r3, [r7, #40]	; 0x28

    adv_w += kv;
 801dd2e:	697b      	ldr	r3, [r7, #20]
 801dd30:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801dd32:	4413      	add	r3, r2
 801dd34:	62bb      	str	r3, [r7, #40]	; 0x28
    adv_w  = (adv_w + (1 << 3)) >> 4;
 801dd36:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801dd38:	3308      	adds	r3, #8
 801dd3a:	091b      	lsrs	r3, r3, #4
 801dd3c:	62bb      	str	r3, [r7, #40]	; 0x28

    dsc_out->adv_w = adv_w;
 801dd3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801dd40:	b29a      	uxth	r2, r3
 801dd42:	68bb      	ldr	r3, [r7, #8]
 801dd44:	801a      	strh	r2, [r3, #0]
    dsc_out->box_h = gdsc->box_h;
 801dd46:	69bb      	ldr	r3, [r7, #24]
 801dd48:	795b      	ldrb	r3, [r3, #5]
 801dd4a:	b29a      	uxth	r2, r3
 801dd4c:	68bb      	ldr	r3, [r7, #8]
 801dd4e:	809a      	strh	r2, [r3, #4]
    dsc_out->box_w = gdsc->box_w;
 801dd50:	69bb      	ldr	r3, [r7, #24]
 801dd52:	791b      	ldrb	r3, [r3, #4]
 801dd54:	b29a      	uxth	r2, r3
 801dd56:	68bb      	ldr	r3, [r7, #8]
 801dd58:	805a      	strh	r2, [r3, #2]
    dsc_out->ofs_x = gdsc->ofs_x;
 801dd5a:	69bb      	ldr	r3, [r7, #24]
 801dd5c:	f993 3006 	ldrsb.w	r3, [r3, #6]
 801dd60:	b21a      	sxth	r2, r3
 801dd62:	68bb      	ldr	r3, [r7, #8]
 801dd64:	80da      	strh	r2, [r3, #6]
    dsc_out->ofs_y = gdsc->ofs_y;
 801dd66:	69bb      	ldr	r3, [r7, #24]
 801dd68:	f993 3007 	ldrsb.w	r3, [r3, #7]
 801dd6c:	b21a      	sxth	r2, r3
 801dd6e:	68bb      	ldr	r3, [r7, #8]
 801dd70:	811a      	strh	r2, [r3, #8]
    dsc_out->bpp   = (uint8_t)fdsc->bpp;
 801dd72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801dd74:	7cdb      	ldrb	r3, [r3, #19]
 801dd76:	f3c3 0383 	ubfx	r3, r3, #2, #4
 801dd7a:	b2db      	uxtb	r3, r3
 801dd7c:	461a      	mov	r2, r3
 801dd7e:	68bb      	ldr	r3, [r7, #8]
 801dd80:	729a      	strb	r2, [r3, #10]

    if(is_tab) dsc_out->box_w = dsc_out->box_w * 2;
 801dd82:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801dd86:	2b00      	cmp	r3, #0
 801dd88:	d005      	beq.n	801dd96 <lv_font_get_glyph_dsc_fmt_txt+0x10a>
 801dd8a:	68bb      	ldr	r3, [r7, #8]
 801dd8c:	885b      	ldrh	r3, [r3, #2]
 801dd8e:	005b      	lsls	r3, r3, #1
 801dd90:	b29a      	uxth	r2, r3
 801dd92:	68bb      	ldr	r3, [r7, #8]
 801dd94:	805a      	strh	r2, [r3, #2]

    return true;
 801dd96:	2301      	movs	r3, #1
}
 801dd98:	4618      	mov	r0, r3
 801dd9a:	3730      	adds	r7, #48	; 0x30
 801dd9c:	46bd      	mov	sp, r7
 801dd9e:	bd80      	pop	{r7, pc}

0801dda0 <_lv_font_clean_up_fmt_txt>:

/**
 * Free the allocated memories.
 */
void _lv_font_clean_up_fmt_txt(void)
{
 801dda0:	b580      	push	{r7, lr}
 801dda2:	af00      	add	r7, sp, #0
    if(decompr_buf) {
 801dda4:	4b06      	ldr	r3, [pc, #24]	; (801ddc0 <_lv_font_clean_up_fmt_txt+0x20>)
 801dda6:	681b      	ldr	r3, [r3, #0]
 801dda8:	2b00      	cmp	r3, #0
 801ddaa:	d007      	beq.n	801ddbc <_lv_font_clean_up_fmt_txt+0x1c>
        lv_mem_free(decompr_buf);
 801ddac:	4b04      	ldr	r3, [pc, #16]	; (801ddc0 <_lv_font_clean_up_fmt_txt+0x20>)
 801ddae:	681b      	ldr	r3, [r3, #0]
 801ddb0:	4618      	mov	r0, r3
 801ddb2:	f002 ff59 	bl	8020c68 <lv_mem_free>
        decompr_buf = NULL;
 801ddb6:	4b02      	ldr	r3, [pc, #8]	; (801ddc0 <_lv_font_clean_up_fmt_txt+0x20>)
 801ddb8:	2200      	movs	r2, #0
 801ddba:	601a      	str	r2, [r3, #0]
    }
}
 801ddbc:	bf00      	nop
 801ddbe:	bd80      	pop	{r7, pc}
 801ddc0:	2000a14c 	.word	0x2000a14c

0801ddc4 <get_glyph_dsc_id>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
{
 801ddc4:	b590      	push	{r4, r7, lr}
 801ddc6:	b091      	sub	sp, #68	; 0x44
 801ddc8:	af02      	add	r7, sp, #8
 801ddca:	6078      	str	r0, [r7, #4]
 801ddcc:	6039      	str	r1, [r7, #0]
    if(letter == '\0') return 0;
 801ddce:	683b      	ldr	r3, [r7, #0]
 801ddd0:	2b00      	cmp	r3, #0
 801ddd2:	d101      	bne.n	801ddd8 <get_glyph_dsc_id+0x14>
 801ddd4:	2300      	movs	r3, #0
 801ddd6:	e125      	b.n	801e024 <get_glyph_dsc_id+0x260>

    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801ddd8:	687b      	ldr	r3, [r7, #4]
 801ddda:	691b      	ldr	r3, [r3, #16]
 801dddc:	62fb      	str	r3, [r7, #44]	; 0x2c

    /*Check the cache first*/
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
 801ddde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801dde0:	699b      	ldr	r3, [r3, #24]
 801dde2:	683a      	ldr	r2, [r7, #0]
 801dde4:	429a      	cmp	r2, r3
 801dde6:	d102      	bne.n	801ddee <get_glyph_dsc_id+0x2a>
 801dde8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ddea:	69db      	ldr	r3, [r3, #28]
 801ddec:	e11a      	b.n	801e024 <get_glyph_dsc_id+0x260>

    uint16_t i;
    for(i = 0; i < fdsc->cmap_num; i++) {
 801ddee:	2300      	movs	r3, #0
 801ddf0:	86fb      	strh	r3, [r7, #54]	; 0x36
 801ddf2:	e106      	b.n	801e002 <get_glyph_dsc_id+0x23e>

        /*Relative code point*/
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
 801ddf4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ddf6:	6899      	ldr	r1, [r3, #8]
 801ddf8:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801ddfa:	4613      	mov	r3, r2
 801ddfc:	009b      	lsls	r3, r3, #2
 801ddfe:	4413      	add	r3, r2
 801de00:	009b      	lsls	r3, r3, #2
 801de02:	440b      	add	r3, r1
 801de04:	681b      	ldr	r3, [r3, #0]
 801de06:	683a      	ldr	r2, [r7, #0]
 801de08:	1ad3      	subs	r3, r2, r3
 801de0a:	62bb      	str	r3, [r7, #40]	; 0x28
        if(rcp > fdsc->cmaps[i].range_length) continue;
 801de0c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801de0e:	6899      	ldr	r1, [r3, #8]
 801de10:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801de12:	4613      	mov	r3, r2
 801de14:	009b      	lsls	r3, r3, #2
 801de16:	4413      	add	r3, r2
 801de18:	009b      	lsls	r3, r3, #2
 801de1a:	440b      	add	r3, r1
 801de1c:	889b      	ldrh	r3, [r3, #4]
 801de1e:	461a      	mov	r2, r3
 801de20:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801de22:	4293      	cmp	r3, r2
 801de24:	f200 80e9 	bhi.w	801dffa <get_glyph_dsc_id+0x236>
        uint32_t glyph_id = 0;
 801de28:	2300      	movs	r3, #0
 801de2a:	633b      	str	r3, [r7, #48]	; 0x30
        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
 801de2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801de2e:	6899      	ldr	r1, [r3, #8]
 801de30:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801de32:	4613      	mov	r3, r2
 801de34:	009b      	lsls	r3, r3, #2
 801de36:	4413      	add	r3, r2
 801de38:	009b      	lsls	r3, r3, #2
 801de3a:	440b      	add	r3, r1
 801de3c:	7c9b      	ldrb	r3, [r3, #18]
 801de3e:	2b00      	cmp	r3, #0
 801de40:	d10d      	bne.n	801de5e <get_glyph_dsc_id+0x9a>
            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
 801de42:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801de44:	6899      	ldr	r1, [r3, #8]
 801de46:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801de48:	4613      	mov	r3, r2
 801de4a:	009b      	lsls	r3, r3, #2
 801de4c:	4413      	add	r3, r2
 801de4e:	009b      	lsls	r3, r3, #2
 801de50:	440b      	add	r3, r1
 801de52:	88db      	ldrh	r3, [r3, #6]
 801de54:	461a      	mov	r2, r3
 801de56:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801de58:	4413      	add	r3, r2
 801de5a:	633b      	str	r3, [r7, #48]	; 0x30
 801de5c:	e0c5      	b.n	801dfea <get_glyph_dsc_id+0x226>
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
 801de5e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801de60:	6899      	ldr	r1, [r3, #8]
 801de62:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801de64:	4613      	mov	r3, r2
 801de66:	009b      	lsls	r3, r3, #2
 801de68:	4413      	add	r3, r2
 801de6a:	009b      	lsls	r3, r3, #2
 801de6c:	440b      	add	r3, r1
 801de6e:	7c9b      	ldrb	r3, [r3, #18]
 801de70:	2b01      	cmp	r3, #1
 801de72:	d11a      	bne.n	801deaa <get_glyph_dsc_id+0xe6>
            const uint8_t * gid_ofs_8 = fdsc->cmaps[i].glyph_id_ofs_list;
 801de74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801de76:	6899      	ldr	r1, [r3, #8]
 801de78:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801de7a:	4613      	mov	r3, r2
 801de7c:	009b      	lsls	r3, r3, #2
 801de7e:	4413      	add	r3, r2
 801de80:	009b      	lsls	r3, r3, #2
 801de82:	440b      	add	r3, r1
 801de84:	68db      	ldr	r3, [r3, #12]
 801de86:	613b      	str	r3, [r7, #16]
            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
 801de88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801de8a:	6899      	ldr	r1, [r3, #8]
 801de8c:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801de8e:	4613      	mov	r3, r2
 801de90:	009b      	lsls	r3, r3, #2
 801de92:	4413      	add	r3, r2
 801de94:	009b      	lsls	r3, r3, #2
 801de96:	440b      	add	r3, r1
 801de98:	88db      	ldrh	r3, [r3, #6]
 801de9a:	4619      	mov	r1, r3
 801de9c:	693a      	ldr	r2, [r7, #16]
 801de9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801dea0:	4413      	add	r3, r2
 801dea2:	781b      	ldrb	r3, [r3, #0]
 801dea4:	440b      	add	r3, r1
 801dea6:	633b      	str	r3, [r7, #48]	; 0x30
 801dea8:	e09f      	b.n	801dfea <get_glyph_dsc_id+0x226>
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
 801deaa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801deac:	6899      	ldr	r1, [r3, #8]
 801deae:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801deb0:	4613      	mov	r3, r2
 801deb2:	009b      	lsls	r3, r3, #2
 801deb4:	4413      	add	r3, r2
 801deb6:	009b      	lsls	r3, r3, #2
 801deb8:	440b      	add	r3, r1
 801deba:	7c9b      	ldrb	r3, [r3, #18]
 801debc:	2b02      	cmp	r3, #2
 801debe:	d13e      	bne.n	801df3e <get_glyph_dsc_id+0x17a>
            uint16_t key = rcp;
 801dec0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801dec2:	b29b      	uxth	r3, r3
 801dec4:	81fb      	strh	r3, [r7, #14]
            uint8_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
 801dec6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801dec8:	6899      	ldr	r1, [r3, #8]
 801deca:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801decc:	4613      	mov	r3, r2
 801dece:	009b      	lsls	r3, r3, #2
 801ded0:	4413      	add	r3, r2
 801ded2:	009b      	lsls	r3, r3, #2
 801ded4:	440b      	add	r3, r1
 801ded6:	689c      	ldr	r4, [r3, #8]
 801ded8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801deda:	6899      	ldr	r1, [r3, #8]
 801dedc:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801dede:	4613      	mov	r3, r2
 801dee0:	009b      	lsls	r3, r3, #2
 801dee2:	4413      	add	r3, r2
 801dee4:	009b      	lsls	r3, r3, #2
 801dee6:	440b      	add	r3, r1
 801dee8:	8a1b      	ldrh	r3, [r3, #16]
 801deea:	461a      	mov	r2, r3
 801deec:	f107 000e 	add.w	r0, r7, #14
 801def0:	4b4e      	ldr	r3, [pc, #312]	; (801e02c <get_glyph_dsc_id+0x268>)
 801def2:	9300      	str	r3, [sp, #0]
 801def4:	2302      	movs	r3, #2
 801def6:	4621      	mov	r1, r4
 801def8:	f004 fdd2 	bl	8022aa0 <_lv_utils_bsearch>
 801defc:	61b8      	str	r0, [r7, #24]
                                            sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);

            if(p) {
 801defe:	69bb      	ldr	r3, [r7, #24]
 801df00:	2b00      	cmp	r3, #0
 801df02:	d072      	beq.n	801dfea <get_glyph_dsc_id+0x226>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t *) fdsc->cmaps[i].unicode_list);
 801df04:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801df06:	6899      	ldr	r1, [r3, #8]
 801df08:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801df0a:	4613      	mov	r3, r2
 801df0c:	009b      	lsls	r3, r3, #2
 801df0e:	4413      	add	r3, r2
 801df10:	009b      	lsls	r3, r3, #2
 801df12:	440b      	add	r3, r1
 801df14:	689b      	ldr	r3, [r3, #8]
 801df16:	69ba      	ldr	r2, [r7, #24]
 801df18:	1ad3      	subs	r3, r2, r3
 801df1a:	617b      	str	r3, [r7, #20]
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
 801df1c:	697b      	ldr	r3, [r7, #20]
 801df1e:	085b      	lsrs	r3, r3, #1
 801df20:	617b      	str	r3, [r7, #20]
                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
 801df22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801df24:	6899      	ldr	r1, [r3, #8]
 801df26:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801df28:	4613      	mov	r3, r2
 801df2a:	009b      	lsls	r3, r3, #2
 801df2c:	4413      	add	r3, r2
 801df2e:	009b      	lsls	r3, r3, #2
 801df30:	440b      	add	r3, r1
 801df32:	88db      	ldrh	r3, [r3, #6]
 801df34:	461a      	mov	r2, r3
 801df36:	697b      	ldr	r3, [r7, #20]
 801df38:	4413      	add	r3, r2
 801df3a:	633b      	str	r3, [r7, #48]	; 0x30
 801df3c:	e055      	b.n	801dfea <get_glyph_dsc_id+0x226>
            }
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
 801df3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801df40:	6899      	ldr	r1, [r3, #8]
 801df42:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801df44:	4613      	mov	r3, r2
 801df46:	009b      	lsls	r3, r3, #2
 801df48:	4413      	add	r3, r2
 801df4a:	009b      	lsls	r3, r3, #2
 801df4c:	440b      	add	r3, r1
 801df4e:	7c9b      	ldrb	r3, [r3, #18]
 801df50:	2b03      	cmp	r3, #3
 801df52:	d14a      	bne.n	801dfea <get_glyph_dsc_id+0x226>
            uint16_t key = rcp;
 801df54:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801df56:	b29b      	uxth	r3, r3
 801df58:	81bb      	strh	r3, [r7, #12]
            uint8_t * p = _lv_utils_bsearch(&key, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length,
 801df5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801df5c:	6899      	ldr	r1, [r3, #8]
 801df5e:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801df60:	4613      	mov	r3, r2
 801df62:	009b      	lsls	r3, r3, #2
 801df64:	4413      	add	r3, r2
 801df66:	009b      	lsls	r3, r3, #2
 801df68:	440b      	add	r3, r1
 801df6a:	689c      	ldr	r4, [r3, #8]
 801df6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801df6e:	6899      	ldr	r1, [r3, #8]
 801df70:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801df72:	4613      	mov	r3, r2
 801df74:	009b      	lsls	r3, r3, #2
 801df76:	4413      	add	r3, r2
 801df78:	009b      	lsls	r3, r3, #2
 801df7a:	440b      	add	r3, r1
 801df7c:	8a1b      	ldrh	r3, [r3, #16]
 801df7e:	461a      	mov	r2, r3
 801df80:	f107 000c 	add.w	r0, r7, #12
 801df84:	4b29      	ldr	r3, [pc, #164]	; (801e02c <get_glyph_dsc_id+0x268>)
 801df86:	9300      	str	r3, [sp, #0]
 801df88:	2302      	movs	r3, #2
 801df8a:	4621      	mov	r1, r4
 801df8c:	f004 fd88 	bl	8022aa0 <_lv_utils_bsearch>
 801df90:	6278      	str	r0, [r7, #36]	; 0x24
                                            sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);

            if(p) {
 801df92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801df94:	2b00      	cmp	r3, #0
 801df96:	d028      	beq.n	801dfea <get_glyph_dsc_id+0x226>
                lv_uintptr_t ofs = (lv_uintptr_t)(p - (uint8_t *) fdsc->cmaps[i].unicode_list);
 801df98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801df9a:	6899      	ldr	r1, [r3, #8]
 801df9c:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801df9e:	4613      	mov	r3, r2
 801dfa0:	009b      	lsls	r3, r3, #2
 801dfa2:	4413      	add	r3, r2
 801dfa4:	009b      	lsls	r3, r3, #2
 801dfa6:	440b      	add	r3, r1
 801dfa8:	689b      	ldr	r3, [r3, #8]
 801dfaa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801dfac:	1ad3      	subs	r3, r2, r3
 801dfae:	623b      	str	r3, [r7, #32]
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
 801dfb0:	6a3b      	ldr	r3, [r7, #32]
 801dfb2:	085b      	lsrs	r3, r3, #1
 801dfb4:	623b      	str	r3, [r7, #32]
                const uint8_t * gid_ofs_16 = fdsc->cmaps[i].glyph_id_ofs_list;
 801dfb6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801dfb8:	6899      	ldr	r1, [r3, #8]
 801dfba:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801dfbc:	4613      	mov	r3, r2
 801dfbe:	009b      	lsls	r3, r3, #2
 801dfc0:	4413      	add	r3, r2
 801dfc2:	009b      	lsls	r3, r3, #2
 801dfc4:	440b      	add	r3, r1
 801dfc6:	68db      	ldr	r3, [r3, #12]
 801dfc8:	61fb      	str	r3, [r7, #28]
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
 801dfca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801dfcc:	6899      	ldr	r1, [r3, #8]
 801dfce:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 801dfd0:	4613      	mov	r3, r2
 801dfd2:	009b      	lsls	r3, r3, #2
 801dfd4:	4413      	add	r3, r2
 801dfd6:	009b      	lsls	r3, r3, #2
 801dfd8:	440b      	add	r3, r1
 801dfda:	88db      	ldrh	r3, [r3, #6]
 801dfdc:	4619      	mov	r1, r3
 801dfde:	69fa      	ldr	r2, [r7, #28]
 801dfe0:	6a3b      	ldr	r3, [r7, #32]
 801dfe2:	4413      	add	r3, r2
 801dfe4:	781b      	ldrb	r3, [r3, #0]
 801dfe6:	440b      	add	r3, r1
 801dfe8:	633b      	str	r3, [r7, #48]	; 0x30
            }
        }

        /*Update the cache*/
        fdsc->last_letter = letter;
 801dfea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801dfec:	683a      	ldr	r2, [r7, #0]
 801dfee:	619a      	str	r2, [r3, #24]
        fdsc->last_glyph_id = glyph_id;
 801dff0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801dff2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 801dff4:	61da      	str	r2, [r3, #28]
        return glyph_id;
 801dff6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801dff8:	e014      	b.n	801e024 <get_glyph_dsc_id+0x260>
        if(rcp > fdsc->cmaps[i].range_length) continue;
 801dffa:	bf00      	nop
    for(i = 0; i < fdsc->cmap_num; i++) {
 801dffc:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801dffe:	3301      	adds	r3, #1
 801e000:	86fb      	strh	r3, [r7, #54]	; 0x36
 801e002:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e004:	8a5b      	ldrh	r3, [r3, #18]
 801e006:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801e00a:	b29b      	uxth	r3, r3
 801e00c:	461a      	mov	r2, r3
 801e00e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 801e010:	4293      	cmp	r3, r2
 801e012:	f4ff aeef 	bcc.w	801ddf4 <get_glyph_dsc_id+0x30>
    }

    fdsc->last_letter = letter;
 801e016:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e018:	683a      	ldr	r2, [r7, #0]
 801e01a:	619a      	str	r2, [r3, #24]
    fdsc->last_glyph_id = 0;
 801e01c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e01e:	2200      	movs	r2, #0
 801e020:	61da      	str	r2, [r3, #28]
    return 0;
 801e022:	2300      	movs	r3, #0

}
 801e024:	4618      	mov	r0, r3
 801e026:	373c      	adds	r7, #60	; 0x3c
 801e028:	46bd      	mov	sp, r7
 801e02a:	bd90      	pop	{r4, r7, pc}
 801e02c:	0801e7e9 	.word	0x0801e7e9

0801e030 <get_kern_value>:

static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t gid_right)
{
 801e030:	b580      	push	{r7, lr}
 801e032:	b094      	sub	sp, #80	; 0x50
 801e034:	af02      	add	r7, sp, #8
 801e036:	60f8      	str	r0, [r7, #12]
 801e038:	60b9      	str	r1, [r7, #8]
 801e03a:	607a      	str	r2, [r7, #4]
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801e03c:	68fb      	ldr	r3, [r7, #12]
 801e03e:	691b      	ldr	r3, [r3, #16]
 801e040:	643b      	str	r3, [r7, #64]	; 0x40

    int8_t value = 0;
 801e042:	2300      	movs	r3, #0
 801e044:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

    if(fdsc->kern_classes == 0) {
 801e048:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e04a:	7cdb      	ldrb	r3, [r3, #19]
 801e04c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801e050:	b2db      	uxtb	r3, r3
 801e052:	2b00      	cmp	r3, #0
 801e054:	d164      	bne.n	801e120 <get_kern_value+0xf0>
        /*Kern pairs*/
        const lv_font_fmt_txt_kern_pair_t * kdsc = fdsc->kern_dsc;
 801e056:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e058:	68db      	ldr	r3, [r3, #12]
 801e05a:	637b      	str	r3, [r7, #52]	; 0x34
        if(kdsc->glyph_ids_size == 0) {
 801e05c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e05e:	7adb      	ldrb	r3, [r3, #11]
 801e060:	f003 0303 	and.w	r3, r3, #3
 801e064:	b2db      	uxtb	r3, r3
 801e066:	2b00      	cmp	r3, #0
 801e068:	d12b      	bne.n	801e0c2 <get_kern_value+0x92>
            /* Use binary search to find the kern value.
             * The pairs are ordered left_id first, then right_id secondly. */
            const uint8_t * g_ids = kdsc->glyph_ids;
 801e06a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e06c:	681b      	ldr	r3, [r3, #0]
 801e06e:	627b      	str	r3, [r7, #36]	; 0x24
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
 801e070:	687b      	ldr	r3, [r7, #4]
 801e072:	b29b      	uxth	r3, r3
 801e074:	021b      	lsls	r3, r3, #8
 801e076:	b29a      	uxth	r2, r3
 801e078:	68bb      	ldr	r3, [r7, #8]
 801e07a:	b29b      	uxth	r3, r3
 801e07c:	4413      	add	r3, r2
 801e07e:	b29b      	uxth	r3, r3
 801e080:	837b      	strh	r3, [r7, #26]
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
 801e082:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e084:	689b      	ldr	r3, [r3, #8]
 801e086:	f3c3 0317 	ubfx	r3, r3, #0, #24
 801e08a:	461a      	mov	r2, r3
 801e08c:	f107 001a 	add.w	r0, r7, #26
 801e090:	4b3b      	ldr	r3, [pc, #236]	; (801e180 <get_kern_value+0x150>)
 801e092:	9300      	str	r3, [sp, #0]
 801e094:	2302      	movs	r3, #2
 801e096:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801e098:	f004 fd02 	bl	8022aa0 <_lv_utils_bsearch>
 801e09c:	6238      	str	r0, [r7, #32]

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
 801e09e:	6a3b      	ldr	r3, [r7, #32]
 801e0a0:	2b00      	cmp	r3, #0
 801e0a2:	d067      	beq.n	801e174 <get_kern_value+0x144>
                lv_uintptr_t ofs = (lv_uintptr_t)(kid_p - g_ids);
 801e0a4:	6a3a      	ldr	r2, [r7, #32]
 801e0a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e0a8:	1ad3      	subs	r3, r2, r3
 801e0aa:	61fb      	str	r3, [r7, #28]
                ofs = ofs >> 1;     /*ofs is for pair, divide by 2 to refer as a single value*/
 801e0ac:	69fb      	ldr	r3, [r7, #28]
 801e0ae:	085b      	lsrs	r3, r3, #1
 801e0b0:	61fb      	str	r3, [r7, #28]
                value = kdsc->values[ofs];
 801e0b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e0b4:	685a      	ldr	r2, [r3, #4]
 801e0b6:	69fb      	ldr	r3, [r7, #28]
 801e0b8:	4413      	add	r3, r2
 801e0ba:	781b      	ldrb	r3, [r3, #0]
 801e0bc:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 801e0c0:	e058      	b.n	801e174 <get_kern_value+0x144>
            }
        }
        else if(kdsc->glyph_ids_size == 1) {
 801e0c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e0c4:	7adb      	ldrb	r3, [r3, #11]
 801e0c6:	f003 0303 	and.w	r3, r3, #3
 801e0ca:	b2db      	uxtb	r3, r3
 801e0cc:	2b01      	cmp	r3, #1
 801e0ce:	d151      	bne.n	801e174 <get_kern_value+0x144>
            /* Use binary search to find the kern value.
             * The pairs are ordered left_id first, then right_id secondly. */
            const uint16_t * g_ids = kdsc->glyph_ids;
 801e0d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e0d2:	681b      	ldr	r3, [r3, #0]
 801e0d4:	633b      	str	r3, [r7, #48]	; 0x30
            lv_uintptr_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
 801e0d6:	687b      	ldr	r3, [r7, #4]
 801e0d8:	021a      	lsls	r2, r3, #8
 801e0da:	68bb      	ldr	r3, [r7, #8]
 801e0dc:	4413      	add	r3, r2
 801e0de:	617b      	str	r3, [r7, #20]
            uint8_t * kid_p = _lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
 801e0e0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e0e2:	689b      	ldr	r3, [r3, #8]
 801e0e4:	f3c3 0317 	ubfx	r3, r3, #0, #24
 801e0e8:	461a      	mov	r2, r3
 801e0ea:	f107 0014 	add.w	r0, r7, #20
 801e0ee:	4b25      	ldr	r3, [pc, #148]	; (801e184 <get_kern_value+0x154>)
 801e0f0:	9300      	str	r3, [sp, #0]
 801e0f2:	2304      	movs	r3, #4
 801e0f4:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801e0f6:	f004 fcd3 	bl	8022aa0 <_lv_utils_bsearch>
 801e0fa:	62f8      	str	r0, [r7, #44]	; 0x2c

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
 801e0fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801e0fe:	2b00      	cmp	r3, #0
 801e100:	d038      	beq.n	801e174 <get_kern_value+0x144>
                lv_uintptr_t ofs = (lv_uintptr_t)(kid_p - (const uint8_t *)g_ids);
 801e102:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801e104:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801e106:	1ad3      	subs	r3, r2, r3
 801e108:	62bb      	str	r3, [r7, #40]	; 0x28
                ofs = ofs >> 4;     /*ofs is 4 byte pairs, divide by 4 to refer as a single value*/
 801e10a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e10c:	091b      	lsrs	r3, r3, #4
 801e10e:	62bb      	str	r3, [r7, #40]	; 0x28
                value = kdsc->values[ofs];
 801e110:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801e112:	685a      	ldr	r2, [r3, #4]
 801e114:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e116:	4413      	add	r3, r2
 801e118:	781b      	ldrb	r3, [r3, #0]
 801e11a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 801e11e:	e029      	b.n	801e174 <get_kern_value+0x144>
            /*Invalid value*/
        }
    }
    else {
        /*Kern classes*/
        const lv_font_fmt_txt_kern_classes_t * kdsc = fdsc->kern_dsc;
 801e120:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801e122:	68db      	ldr	r3, [r3, #12]
 801e124:	63fb      	str	r3, [r7, #60]	; 0x3c
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
 801e126:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801e128:	685a      	ldr	r2, [r3, #4]
 801e12a:	68bb      	ldr	r3, [r7, #8]
 801e12c:	4413      	add	r3, r2
 801e12e:	781b      	ldrb	r3, [r3, #0]
 801e130:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
        uint8_t right_class = kdsc->right_class_mapping[gid_right];
 801e134:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801e136:	689a      	ldr	r2, [r3, #8]
 801e138:	687b      	ldr	r3, [r7, #4]
 801e13a:	4413      	add	r3, r2
 801e13c:	781b      	ldrb	r3, [r3, #0]
 801e13e:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a

        /* If class = 0, kerning not exist for that glyph
         * else got the value form `class_pair_values` 2D array*/
        if(left_class > 0 && right_class > 0) {
 801e142:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 801e146:	2b00      	cmp	r3, #0
 801e148:	d014      	beq.n	801e174 <get_kern_value+0x144>
 801e14a:	f897 303a 	ldrb.w	r3, [r7, #58]	; 0x3a
 801e14e:	2b00      	cmp	r3, #0
 801e150:	d010      	beq.n	801e174 <get_kern_value+0x144>
            value = kdsc->class_pair_values[(left_class - 1) * kdsc->right_class_cnt + (right_class - 1)];
 801e152:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801e154:	681b      	ldr	r3, [r3, #0]
 801e156:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 801e15a:	3a01      	subs	r2, #1
 801e15c:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801e15e:	7b49      	ldrb	r1, [r1, #13]
 801e160:	fb02 f101 	mul.w	r1, r2, r1
 801e164:	f897 203a 	ldrb.w	r2, [r7, #58]	; 0x3a
 801e168:	3a01      	subs	r2, #1
 801e16a:	440a      	add	r2, r1
 801e16c:	4413      	add	r3, r2
 801e16e:	781b      	ldrb	r3, [r3, #0]
 801e170:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        }

    }
    return value;
 801e174:	f997 3047 	ldrsb.w	r3, [r7, #71]	; 0x47
}
 801e178:	4618      	mov	r0, r3
 801e17a:	3748      	adds	r7, #72	; 0x48
 801e17c:	46bd      	mov	sp, r7
 801e17e:	bd80      	pop	{r7, pc}
 801e180:	0801e189 	.word	0x0801e189
 801e184:	0801e1d1 	.word	0x0801e1d1

0801e188 <kern_pair_8_compare>:

static int32_t kern_pair_8_compare(const void * ref, const void * element)
{
 801e188:	b480      	push	{r7}
 801e18a:	b085      	sub	sp, #20
 801e18c:	af00      	add	r7, sp, #0
 801e18e:	6078      	str	r0, [r7, #4]
 801e190:	6039      	str	r1, [r7, #0]
    const uint8_t * ref8_p = ref;
 801e192:	687b      	ldr	r3, [r7, #4]
 801e194:	60fb      	str	r3, [r7, #12]
    const uint8_t * element8_p = element;
 801e196:	683b      	ldr	r3, [r7, #0]
 801e198:	60bb      	str	r3, [r7, #8]

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];
 801e19a:	68fb      	ldr	r3, [r7, #12]
 801e19c:	781a      	ldrb	r2, [r3, #0]
 801e19e:	68bb      	ldr	r3, [r7, #8]
 801e1a0:	781b      	ldrb	r3, [r3, #0]
 801e1a2:	429a      	cmp	r2, r3
 801e1a4:	d006      	beq.n	801e1b4 <kern_pair_8_compare+0x2c>
 801e1a6:	68fb      	ldr	r3, [r7, #12]
 801e1a8:	781b      	ldrb	r3, [r3, #0]
 801e1aa:	461a      	mov	r2, r3
 801e1ac:	68bb      	ldr	r3, [r7, #8]
 801e1ae:	781b      	ldrb	r3, [r3, #0]
 801e1b0:	1ad3      	subs	r3, r2, r3
 801e1b2:	e007      	b.n	801e1c4 <kern_pair_8_compare+0x3c>
    else return (int32_t) ref8_p[1] - element8_p[1];
 801e1b4:	68fb      	ldr	r3, [r7, #12]
 801e1b6:	3301      	adds	r3, #1
 801e1b8:	781b      	ldrb	r3, [r3, #0]
 801e1ba:	461a      	mov	r2, r3
 801e1bc:	68bb      	ldr	r3, [r7, #8]
 801e1be:	3301      	adds	r3, #1
 801e1c0:	781b      	ldrb	r3, [r3, #0]
 801e1c2:	1ad3      	subs	r3, r2, r3

}
 801e1c4:	4618      	mov	r0, r3
 801e1c6:	3714      	adds	r7, #20
 801e1c8:	46bd      	mov	sp, r7
 801e1ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e1ce:	4770      	bx	lr

0801e1d0 <kern_pair_16_compare>:

static int32_t kern_pair_16_compare(const void * ref, const void * element)
{
 801e1d0:	b480      	push	{r7}
 801e1d2:	b085      	sub	sp, #20
 801e1d4:	af00      	add	r7, sp, #0
 801e1d6:	6078      	str	r0, [r7, #4]
 801e1d8:	6039      	str	r1, [r7, #0]
    const uint16_t * ref16_p = ref;
 801e1da:	687b      	ldr	r3, [r7, #4]
 801e1dc:	60fb      	str	r3, [r7, #12]
    const uint16_t * element16_p = element;
 801e1de:	683b      	ldr	r3, [r7, #0]
 801e1e0:	60bb      	str	r3, [r7, #8]

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];
 801e1e2:	68fb      	ldr	r3, [r7, #12]
 801e1e4:	881a      	ldrh	r2, [r3, #0]
 801e1e6:	68bb      	ldr	r3, [r7, #8]
 801e1e8:	881b      	ldrh	r3, [r3, #0]
 801e1ea:	429a      	cmp	r2, r3
 801e1ec:	d006      	beq.n	801e1fc <kern_pair_16_compare+0x2c>
 801e1ee:	68fb      	ldr	r3, [r7, #12]
 801e1f0:	881b      	ldrh	r3, [r3, #0]
 801e1f2:	461a      	mov	r2, r3
 801e1f4:	68bb      	ldr	r3, [r7, #8]
 801e1f6:	881b      	ldrh	r3, [r3, #0]
 801e1f8:	1ad3      	subs	r3, r2, r3
 801e1fa:	e007      	b.n	801e20c <kern_pair_16_compare+0x3c>
    else return (int32_t) ref16_p[1] - element16_p[1];
 801e1fc:	68fb      	ldr	r3, [r7, #12]
 801e1fe:	3302      	adds	r3, #2
 801e200:	881b      	ldrh	r3, [r3, #0]
 801e202:	461a      	mov	r2, r3
 801e204:	68bb      	ldr	r3, [r7, #8]
 801e206:	3302      	adds	r3, #2
 801e208:	881b      	ldrh	r3, [r3, #0]
 801e20a:	1ad3      	subs	r3, r2, r3
}
 801e20c:	4618      	mov	r0, r3
 801e20e:	3714      	adds	r7, #20
 801e210:	46bd      	mov	sp, r7
 801e212:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e216:	4770      	bx	lr

0801e218 <decompress>:
 * @param px_num number of pixels in the glyph (width * height)
 * @param bpp bit per pixel (bpp = 3 will be converted to bpp = 4)
 * @param prefilter true: the lines are XORed
 */
static void decompress(const uint8_t * in, uint8_t * out, lv_coord_t w, lv_coord_t h, uint8_t bpp, bool prefilter)
{
 801e218:	b580      	push	{r7, lr}
 801e21a:	b08a      	sub	sp, #40	; 0x28
 801e21c:	af00      	add	r7, sp, #0
 801e21e:	60f8      	str	r0, [r7, #12]
 801e220:	60b9      	str	r1, [r7, #8]
 801e222:	4611      	mov	r1, r2
 801e224:	461a      	mov	r2, r3
 801e226:	460b      	mov	r3, r1
 801e228:	80fb      	strh	r3, [r7, #6]
 801e22a:	4613      	mov	r3, r2
 801e22c:	80bb      	strh	r3, [r7, #4]
    uint32_t wrp = 0;
 801e22e:	2300      	movs	r3, #0
 801e230:	627b      	str	r3, [r7, #36]	; 0x24
    uint8_t wr_size = bpp;
 801e232:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801e236:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    if(bpp == 3) wr_size = 4;
 801e23a:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801e23e:	2b03      	cmp	r3, #3
 801e240:	d102      	bne.n	801e248 <decompress+0x30>
 801e242:	2304      	movs	r3, #4
 801e244:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

    rle_init(in, bpp);
 801e248:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801e24c:	4619      	mov	r1, r3
 801e24e:	68f8      	ldr	r0, [r7, #12]
 801e250:	f000 f9c4 	bl	801e5dc <rle_init>

    uint8_t * line_buf1 = _lv_mem_buf_get(w);
 801e254:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e258:	4618      	mov	r0, r3
 801e25a:	f002 fe19 	bl	8020e90 <_lv_mem_buf_get>
 801e25e:	6178      	str	r0, [r7, #20]

    uint8_t * line_buf2 = NULL;
 801e260:	2300      	movs	r3, #0
 801e262:	61fb      	str	r3, [r7, #28]

    if(prefilter) {
 801e264:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 801e268:	2b00      	cmp	r3, #0
 801e26a:	d005      	beq.n	801e278 <decompress+0x60>
        line_buf2 = _lv_mem_buf_get(w);
 801e26c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e270:	4618      	mov	r0, r3
 801e272:	f002 fe0d 	bl	8020e90 <_lv_mem_buf_get>
 801e276:	61f8      	str	r0, [r7, #28]
    }

    decompress_line(line_buf1, w);
 801e278:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e27c:	4619      	mov	r1, r3
 801e27e:	6978      	ldr	r0, [r7, #20]
 801e280:	f000 f898 	bl	801e3b4 <decompress_line>

    lv_coord_t y;
    lv_coord_t x;

    for(x = 0; x < w; x++) {
 801e284:	2300      	movs	r3, #0
 801e286:	833b      	strh	r3, [r7, #24]
 801e288:	e015      	b.n	801e2b6 <decompress+0x9e>
        bits_write(out, wrp, line_buf1[x], bpp);
 801e28a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801e28e:	697a      	ldr	r2, [r7, #20]
 801e290:	4413      	add	r3, r2
 801e292:	781a      	ldrb	r2, [r3, #0]
 801e294:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801e298:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801e29a:	68b8      	ldr	r0, [r7, #8]
 801e29c:	f000 f922 	bl	801e4e4 <bits_write>
        wrp += wr_size;
 801e2a0:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801e2a4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801e2a6:	4413      	add	r3, r2
 801e2a8:	627b      	str	r3, [r7, #36]	; 0x24
    for(x = 0; x < w; x++) {
 801e2aa:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801e2ae:	b29b      	uxth	r3, r3
 801e2b0:	3301      	adds	r3, #1
 801e2b2:	b29b      	uxth	r3, r3
 801e2b4:	833b      	strh	r3, [r7, #24]
 801e2b6:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 801e2ba:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e2be:	429a      	cmp	r2, r3
 801e2c0:	dbe3      	blt.n	801e28a <decompress+0x72>
    }

    for(y = 1; y < h; y++) {
 801e2c2:	2301      	movs	r3, #1
 801e2c4:	837b      	strh	r3, [r7, #26]
 801e2c6:	e065      	b.n	801e394 <decompress+0x17c>
        if(prefilter) {
 801e2c8:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 801e2cc:	2b00      	cmp	r3, #0
 801e2ce:	d036      	beq.n	801e33e <decompress+0x126>
            decompress_line(line_buf2, w);
 801e2d0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e2d4:	4619      	mov	r1, r3
 801e2d6:	69f8      	ldr	r0, [r7, #28]
 801e2d8:	f000 f86c 	bl	801e3b4 <decompress_line>

            for(x = 0; x < w; x++) {
 801e2dc:	2300      	movs	r3, #0
 801e2de:	833b      	strh	r3, [r7, #24]
 801e2e0:	e026      	b.n	801e330 <decompress+0x118>
                line_buf1[x] = line_buf2[x] ^ line_buf1[x];
 801e2e2:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801e2e6:	69fa      	ldr	r2, [r7, #28]
 801e2e8:	4413      	add	r3, r2
 801e2ea:	7819      	ldrb	r1, [r3, #0]
 801e2ec:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801e2f0:	697a      	ldr	r2, [r7, #20]
 801e2f2:	4413      	add	r3, r2
 801e2f4:	781a      	ldrb	r2, [r3, #0]
 801e2f6:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801e2fa:	6978      	ldr	r0, [r7, #20]
 801e2fc:	4403      	add	r3, r0
 801e2fe:	404a      	eors	r2, r1
 801e300:	b2d2      	uxtb	r2, r2
 801e302:	701a      	strb	r2, [r3, #0]
                bits_write(out, wrp, line_buf1[x], bpp);
 801e304:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801e308:	697a      	ldr	r2, [r7, #20]
 801e30a:	4413      	add	r3, r2
 801e30c:	781a      	ldrb	r2, [r3, #0]
 801e30e:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801e312:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801e314:	68b8      	ldr	r0, [r7, #8]
 801e316:	f000 f8e5 	bl	801e4e4 <bits_write>
                wrp += wr_size;
 801e31a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801e31e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801e320:	4413      	add	r3, r2
 801e322:	627b      	str	r3, [r7, #36]	; 0x24
            for(x = 0; x < w; x++) {
 801e324:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801e328:	b29b      	uxth	r3, r3
 801e32a:	3301      	adds	r3, #1
 801e32c:	b29b      	uxth	r3, r3
 801e32e:	833b      	strh	r3, [r7, #24]
 801e330:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 801e334:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e338:	429a      	cmp	r2, r3
 801e33a:	dbd2      	blt.n	801e2e2 <decompress+0xca>
 801e33c:	e024      	b.n	801e388 <decompress+0x170>
            }
        }
        else {
            decompress_line(line_buf1, w);
 801e33e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e342:	4619      	mov	r1, r3
 801e344:	6978      	ldr	r0, [r7, #20]
 801e346:	f000 f835 	bl	801e3b4 <decompress_line>

            for(x = 0; x < w; x++) {
 801e34a:	2300      	movs	r3, #0
 801e34c:	833b      	strh	r3, [r7, #24]
 801e34e:	e015      	b.n	801e37c <decompress+0x164>
                bits_write(out, wrp, line_buf1[x], bpp);
 801e350:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801e354:	697a      	ldr	r2, [r7, #20]
 801e356:	4413      	add	r3, r2
 801e358:	781a      	ldrb	r2, [r3, #0]
 801e35a:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801e35e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801e360:	68b8      	ldr	r0, [r7, #8]
 801e362:	f000 f8bf 	bl	801e4e4 <bits_write>
                wrp += wr_size;
 801e366:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801e36a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801e36c:	4413      	add	r3, r2
 801e36e:	627b      	str	r3, [r7, #36]	; 0x24
            for(x = 0; x < w; x++) {
 801e370:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801e374:	b29b      	uxth	r3, r3
 801e376:	3301      	adds	r3, #1
 801e378:	b29b      	uxth	r3, r3
 801e37a:	833b      	strh	r3, [r7, #24]
 801e37c:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 801e380:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e384:	429a      	cmp	r2, r3
 801e386:	dbe3      	blt.n	801e350 <decompress+0x138>
    for(y = 1; y < h; y++) {
 801e388:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801e38c:	b29b      	uxth	r3, r3
 801e38e:	3301      	adds	r3, #1
 801e390:	b29b      	uxth	r3, r3
 801e392:	837b      	strh	r3, [r7, #26]
 801e394:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 801e398:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801e39c:	429a      	cmp	r2, r3
 801e39e:	db93      	blt.n	801e2c8 <decompress+0xb0>
            }
        }
    }

    _lv_mem_buf_release(line_buf1);
 801e3a0:	6978      	ldr	r0, [r7, #20]
 801e3a2:	f002 fe55 	bl	8021050 <_lv_mem_buf_release>
    _lv_mem_buf_release(line_buf2);
 801e3a6:	69f8      	ldr	r0, [r7, #28]
 801e3a8:	f002 fe52 	bl	8021050 <_lv_mem_buf_release>
}
 801e3ac:	bf00      	nop
 801e3ae:	3728      	adds	r7, #40	; 0x28
 801e3b0:	46bd      	mov	sp, r7
 801e3b2:	bd80      	pop	{r7, pc}

0801e3b4 <decompress_line>:
 * Decompress one line. Store one pixel per byte
 * @param out output buffer
 * @param w width of the line in pixel count
 */
static inline void decompress_line(uint8_t * out, lv_coord_t w)
{
 801e3b4:	b590      	push	{r4, r7, lr}
 801e3b6:	b085      	sub	sp, #20
 801e3b8:	af00      	add	r7, sp, #0
 801e3ba:	6078      	str	r0, [r7, #4]
 801e3bc:	460b      	mov	r3, r1
 801e3be:	807b      	strh	r3, [r7, #2]
    lv_coord_t i;
    for(i = 0; i < w; i++) {
 801e3c0:	2300      	movs	r3, #0
 801e3c2:	81fb      	strh	r3, [r7, #14]
 801e3c4:	e00d      	b.n	801e3e2 <decompress_line+0x2e>
        out[i] = rle_next();
 801e3c6:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 801e3ca:	687a      	ldr	r2, [r7, #4]
 801e3cc:	18d4      	adds	r4, r2, r3
 801e3ce:	f000 f92f 	bl	801e630 <rle_next>
 801e3d2:	4603      	mov	r3, r0
 801e3d4:	7023      	strb	r3, [r4, #0]
    for(i = 0; i < w; i++) {
 801e3d6:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 801e3da:	b29b      	uxth	r3, r3
 801e3dc:	3301      	adds	r3, #1
 801e3de:	b29b      	uxth	r3, r3
 801e3e0:	81fb      	strh	r3, [r7, #14]
 801e3e2:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 801e3e6:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801e3ea:	429a      	cmp	r2, r3
 801e3ec:	dbeb      	blt.n	801e3c6 <decompress_line+0x12>
    }
}
 801e3ee:	bf00      	nop
 801e3f0:	bf00      	nop
 801e3f2:	3714      	adds	r7, #20
 801e3f4:	46bd      	mov	sp, r7
 801e3f6:	bd90      	pop	{r4, r7, pc}

0801e3f8 <get_bits>:
 * @param bit_pos index of the first bit to read.
 * @param len number of bits to read (must be <= 8).
 * @return the read bits
 */
static inline uint8_t get_bits(const uint8_t * in, uint32_t bit_pos, uint8_t len)
{
 801e3f8:	b480      	push	{r7}
 801e3fa:	b089      	sub	sp, #36	; 0x24
 801e3fc:	af00      	add	r7, sp, #0
 801e3fe:	60f8      	str	r0, [r7, #12]
 801e400:	60b9      	str	r1, [r7, #8]
 801e402:	4613      	mov	r3, r2
 801e404:	71fb      	strb	r3, [r7, #7]
    uint8_t bit_mask;
    switch(len) {
 801e406:	79fb      	ldrb	r3, [r7, #7]
 801e408:	3b01      	subs	r3, #1
 801e40a:	2b07      	cmp	r3, #7
 801e40c:	d821      	bhi.n	801e452 <get_bits+0x5a>
 801e40e:	a201      	add	r2, pc, #4	; (adr r2, 801e414 <get_bits+0x1c>)
 801e410:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e414:	0801e435 	.word	0x0801e435
 801e418:	0801e43b 	.word	0x0801e43b
 801e41c:	0801e441 	.word	0x0801e441
 801e420:	0801e447 	.word	0x0801e447
 801e424:	0801e453 	.word	0x0801e453
 801e428:	0801e453 	.word	0x0801e453
 801e42c:	0801e453 	.word	0x0801e453
 801e430:	0801e44d 	.word	0x0801e44d
        case 1:
            bit_mask = 0x1;
 801e434:	2301      	movs	r3, #1
 801e436:	77fb      	strb	r3, [r7, #31]
            break;
 801e438:	e012      	b.n	801e460 <get_bits+0x68>
        case 2:
            bit_mask = 0x3;
 801e43a:	2303      	movs	r3, #3
 801e43c:	77fb      	strb	r3, [r7, #31]
            break;
 801e43e:	e00f      	b.n	801e460 <get_bits+0x68>
        case 3:
            bit_mask = 0x7;
 801e440:	2307      	movs	r3, #7
 801e442:	77fb      	strb	r3, [r7, #31]
            break;
 801e444:	e00c      	b.n	801e460 <get_bits+0x68>
        case 4:
            bit_mask = 0xF;
 801e446:	230f      	movs	r3, #15
 801e448:	77fb      	strb	r3, [r7, #31]
            break;
 801e44a:	e009      	b.n	801e460 <get_bits+0x68>
        case 8:
            bit_mask = 0xFF;
 801e44c:	23ff      	movs	r3, #255	; 0xff
 801e44e:	77fb      	strb	r3, [r7, #31]
            break;
 801e450:	e006      	b.n	801e460 <get_bits+0x68>
        default:
            bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
 801e452:	79fb      	ldrb	r3, [r7, #7]
 801e454:	2201      	movs	r2, #1
 801e456:	fa02 f303 	lsl.w	r3, r2, r3
 801e45a:	b2db      	uxtb	r3, r3
 801e45c:	3b01      	subs	r3, #1
 801e45e:	77fb      	strb	r3, [r7, #31]
    }

    uint32_t byte_pos = bit_pos >> 3;
 801e460:	68bb      	ldr	r3, [r7, #8]
 801e462:	08db      	lsrs	r3, r3, #3
 801e464:	61bb      	str	r3, [r7, #24]
    bit_pos = bit_pos & 0x7;
 801e466:	68bb      	ldr	r3, [r7, #8]
 801e468:	f003 0307 	and.w	r3, r3, #7
 801e46c:	60bb      	str	r3, [r7, #8]

    if(bit_pos + len >= 8) {
 801e46e:	79fa      	ldrb	r2, [r7, #7]
 801e470:	68bb      	ldr	r3, [r7, #8]
 801e472:	4413      	add	r3, r2
 801e474:	2b07      	cmp	r3, #7
 801e476:	d91d      	bls.n	801e4b4 <get_bits+0xbc>
        uint16_t in16 = (in[byte_pos] << 8) + in[byte_pos + 1];
 801e478:	68fa      	ldr	r2, [r7, #12]
 801e47a:	69bb      	ldr	r3, [r7, #24]
 801e47c:	4413      	add	r3, r2
 801e47e:	781b      	ldrb	r3, [r3, #0]
 801e480:	b29b      	uxth	r3, r3
 801e482:	021b      	lsls	r3, r3, #8
 801e484:	b29a      	uxth	r2, r3
 801e486:	69bb      	ldr	r3, [r7, #24]
 801e488:	3301      	adds	r3, #1
 801e48a:	68f9      	ldr	r1, [r7, #12]
 801e48c:	440b      	add	r3, r1
 801e48e:	781b      	ldrb	r3, [r3, #0]
 801e490:	b29b      	uxth	r3, r3
 801e492:	4413      	add	r3, r2
 801e494:	82fb      	strh	r3, [r7, #22]
        return (in16 >> (16 - bit_pos - len)) & bit_mask;
 801e496:	8afa      	ldrh	r2, [r7, #22]
 801e498:	79f9      	ldrb	r1, [r7, #7]
 801e49a:	68bb      	ldr	r3, [r7, #8]
 801e49c:	440b      	add	r3, r1
 801e49e:	f1c3 0310 	rsb	r3, r3, #16
 801e4a2:	fa42 f303 	asr.w	r3, r2, r3
 801e4a6:	b25a      	sxtb	r2, r3
 801e4a8:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801e4ac:	4013      	ands	r3, r2
 801e4ae:	b25b      	sxtb	r3, r3
 801e4b0:	b2db      	uxtb	r3, r3
 801e4b2:	e011      	b.n	801e4d8 <get_bits+0xe0>
    }
    else {
        return (in[byte_pos] >> (8 - bit_pos - len)) & bit_mask;
 801e4b4:	68fa      	ldr	r2, [r7, #12]
 801e4b6:	69bb      	ldr	r3, [r7, #24]
 801e4b8:	4413      	add	r3, r2
 801e4ba:	781b      	ldrb	r3, [r3, #0]
 801e4bc:	4619      	mov	r1, r3
 801e4be:	79fa      	ldrb	r2, [r7, #7]
 801e4c0:	68bb      	ldr	r3, [r7, #8]
 801e4c2:	4413      	add	r3, r2
 801e4c4:	f1c3 0308 	rsb	r3, r3, #8
 801e4c8:	fa41 f303 	asr.w	r3, r1, r3
 801e4cc:	b25a      	sxtb	r2, r3
 801e4ce:	f997 301f 	ldrsb.w	r3, [r7, #31]
 801e4d2:	4013      	ands	r3, r2
 801e4d4:	b25b      	sxtb	r3, r3
 801e4d6:	b2db      	uxtb	r3, r3
    }
}
 801e4d8:	4618      	mov	r0, r3
 801e4da:	3724      	adds	r7, #36	; 0x24
 801e4dc:	46bd      	mov	sp, r7
 801e4de:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e4e2:	4770      	bx	lr

0801e4e4 <bits_write>:
 * @param val value to write
 * @param len length of bits to write from `val`. (Counted from the LSB).
 * @note `len == 3` will be converted to `len = 4` and `val` will be upscaled too
 */
static inline void bits_write(uint8_t * out, uint32_t bit_pos, uint8_t val, uint8_t len)
{
 801e4e4:	b480      	push	{r7}
 801e4e6:	b087      	sub	sp, #28
 801e4e8:	af00      	add	r7, sp, #0
 801e4ea:	60f8      	str	r0, [r7, #12]
 801e4ec:	60b9      	str	r1, [r7, #8]
 801e4ee:	4611      	mov	r1, r2
 801e4f0:	461a      	mov	r2, r3
 801e4f2:	460b      	mov	r3, r1
 801e4f4:	71fb      	strb	r3, [r7, #7]
 801e4f6:	4613      	mov	r3, r2
 801e4f8:	71bb      	strb	r3, [r7, #6]
    if(len == 3) {
 801e4fa:	79bb      	ldrb	r3, [r7, #6]
 801e4fc:	2b03      	cmp	r3, #3
 801e4fe:	d12f      	bne.n	801e560 <bits_write+0x7c>
        len = 4;
 801e500:	2304      	movs	r3, #4
 801e502:	71bb      	strb	r3, [r7, #6]
        switch(val) {
 801e504:	79fb      	ldrb	r3, [r7, #7]
 801e506:	2b07      	cmp	r3, #7
 801e508:	d82a      	bhi.n	801e560 <bits_write+0x7c>
 801e50a:	a201      	add	r2, pc, #4	; (adr r2, 801e510 <bits_write+0x2c>)
 801e50c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e510:	0801e531 	.word	0x0801e531
 801e514:	0801e537 	.word	0x0801e537
 801e518:	0801e53d 	.word	0x0801e53d
 801e51c:	0801e543 	.word	0x0801e543
 801e520:	0801e549 	.word	0x0801e549
 801e524:	0801e54f 	.word	0x0801e54f
 801e528:	0801e555 	.word	0x0801e555
 801e52c:	0801e55b 	.word	0x0801e55b
            case 0:
                val = 0;
 801e530:	2300      	movs	r3, #0
 801e532:	71fb      	strb	r3, [r7, #7]
                break;
 801e534:	e014      	b.n	801e560 <bits_write+0x7c>
            case 1:
                val = 2;
 801e536:	2302      	movs	r3, #2
 801e538:	71fb      	strb	r3, [r7, #7]
                break;
 801e53a:	e011      	b.n	801e560 <bits_write+0x7c>
            case 2:
                val = 4;
 801e53c:	2304      	movs	r3, #4
 801e53e:	71fb      	strb	r3, [r7, #7]
                break;
 801e540:	e00e      	b.n	801e560 <bits_write+0x7c>
            case 3:
                val = 6;
 801e542:	2306      	movs	r3, #6
 801e544:	71fb      	strb	r3, [r7, #7]
                break;
 801e546:	e00b      	b.n	801e560 <bits_write+0x7c>
            case 4:
                val = 9;
 801e548:	2309      	movs	r3, #9
 801e54a:	71fb      	strb	r3, [r7, #7]
                break;
 801e54c:	e008      	b.n	801e560 <bits_write+0x7c>
            case 5:
                val = 11;
 801e54e:	230b      	movs	r3, #11
 801e550:	71fb      	strb	r3, [r7, #7]
                break;
 801e552:	e005      	b.n	801e560 <bits_write+0x7c>
            case 6:
                val = 13;
 801e554:	230d      	movs	r3, #13
 801e556:	71fb      	strb	r3, [r7, #7]
                break;
 801e558:	e002      	b.n	801e560 <bits_write+0x7c>
            case 7:
                val = 15;
 801e55a:	230f      	movs	r3, #15
 801e55c:	71fb      	strb	r3, [r7, #7]
                break;
 801e55e:	bf00      	nop
        }
    }

    uint16_t byte_pos = bit_pos >> 3;
 801e560:	68bb      	ldr	r3, [r7, #8]
 801e562:	08db      	lsrs	r3, r3, #3
 801e564:	82fb      	strh	r3, [r7, #22]
    bit_pos = bit_pos & 0x7;
 801e566:	68bb      	ldr	r3, [r7, #8]
 801e568:	f003 0307 	and.w	r3, r3, #7
 801e56c:	60bb      	str	r3, [r7, #8]
    bit_pos = 8 - bit_pos - len;
 801e56e:	79ba      	ldrb	r2, [r7, #6]
 801e570:	68bb      	ldr	r3, [r7, #8]
 801e572:	4413      	add	r3, r2
 801e574:	f1c3 0308 	rsb	r3, r3, #8
 801e578:	60bb      	str	r3, [r7, #8]

    uint8_t bit_mask = (uint16_t)((uint16_t) 1 << len) - 1;
 801e57a:	79bb      	ldrb	r3, [r7, #6]
 801e57c:	2201      	movs	r2, #1
 801e57e:	fa02 f303 	lsl.w	r3, r2, r3
 801e582:	b2db      	uxtb	r3, r3
 801e584:	3b01      	subs	r3, #1
 801e586:	757b      	strb	r3, [r7, #21]
    out[byte_pos] &= ((~bit_mask) << bit_pos);
 801e588:	8afb      	ldrh	r3, [r7, #22]
 801e58a:	68fa      	ldr	r2, [r7, #12]
 801e58c:	4413      	add	r3, r2
 801e58e:	781b      	ldrb	r3, [r3, #0]
 801e590:	b25a      	sxtb	r2, r3
 801e592:	7d7b      	ldrb	r3, [r7, #21]
 801e594:	43d9      	mvns	r1, r3
 801e596:	68bb      	ldr	r3, [r7, #8]
 801e598:	fa01 f303 	lsl.w	r3, r1, r3
 801e59c:	b25b      	sxtb	r3, r3
 801e59e:	4013      	ands	r3, r2
 801e5a0:	b259      	sxtb	r1, r3
 801e5a2:	8afb      	ldrh	r3, [r7, #22]
 801e5a4:	68fa      	ldr	r2, [r7, #12]
 801e5a6:	4413      	add	r3, r2
 801e5a8:	b2ca      	uxtb	r2, r1
 801e5aa:	701a      	strb	r2, [r3, #0]
    out[byte_pos] |= (val << bit_pos);
 801e5ac:	8afb      	ldrh	r3, [r7, #22]
 801e5ae:	68fa      	ldr	r2, [r7, #12]
 801e5b0:	4413      	add	r3, r2
 801e5b2:	781b      	ldrb	r3, [r3, #0]
 801e5b4:	b25a      	sxtb	r2, r3
 801e5b6:	79f9      	ldrb	r1, [r7, #7]
 801e5b8:	68bb      	ldr	r3, [r7, #8]
 801e5ba:	fa01 f303 	lsl.w	r3, r1, r3
 801e5be:	b25b      	sxtb	r3, r3
 801e5c0:	4313      	orrs	r3, r2
 801e5c2:	b259      	sxtb	r1, r3
 801e5c4:	8afb      	ldrh	r3, [r7, #22]
 801e5c6:	68fa      	ldr	r2, [r7, #12]
 801e5c8:	4413      	add	r3, r2
 801e5ca:	b2ca      	uxtb	r2, r1
 801e5cc:	701a      	strb	r2, [r3, #0]
}
 801e5ce:	bf00      	nop
 801e5d0:	371c      	adds	r7, #28
 801e5d2:	46bd      	mov	sp, r7
 801e5d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e5d8:	4770      	bx	lr
 801e5da:	bf00      	nop

0801e5dc <rle_init>:

static inline void rle_init(const uint8_t * in,  uint8_t bpp)
{
 801e5dc:	b480      	push	{r7}
 801e5de:	b083      	sub	sp, #12
 801e5e0:	af00      	add	r7, sp, #0
 801e5e2:	6078      	str	r0, [r7, #4]
 801e5e4:	460b      	mov	r3, r1
 801e5e6:	70fb      	strb	r3, [r7, #3]
    rle_in = in;
 801e5e8:	4a0b      	ldr	r2, [pc, #44]	; (801e618 <rle_init+0x3c>)
 801e5ea:	687b      	ldr	r3, [r7, #4]
 801e5ec:	6013      	str	r3, [r2, #0]
    rle_bpp = bpp;
 801e5ee:	4a0b      	ldr	r2, [pc, #44]	; (801e61c <rle_init+0x40>)
 801e5f0:	78fb      	ldrb	r3, [r7, #3]
 801e5f2:	7013      	strb	r3, [r2, #0]
    rle_state = RLE_STATE_SINGLE;
 801e5f4:	4b0a      	ldr	r3, [pc, #40]	; (801e620 <rle_init+0x44>)
 801e5f6:	2200      	movs	r2, #0
 801e5f8:	701a      	strb	r2, [r3, #0]
    rle_rdp = 0;
 801e5fa:	4b0a      	ldr	r3, [pc, #40]	; (801e624 <rle_init+0x48>)
 801e5fc:	2200      	movs	r2, #0
 801e5fe:	601a      	str	r2, [r3, #0]
    rle_prev_v = 0;
 801e600:	4b09      	ldr	r3, [pc, #36]	; (801e628 <rle_init+0x4c>)
 801e602:	2200      	movs	r2, #0
 801e604:	701a      	strb	r2, [r3, #0]
    rle_cnt = 0;
 801e606:	4b09      	ldr	r3, [pc, #36]	; (801e62c <rle_init+0x50>)
 801e608:	2200      	movs	r2, #0
 801e60a:	701a      	strb	r2, [r3, #0]
}
 801e60c:	bf00      	nop
 801e60e:	370c      	adds	r7, #12
 801e610:	46bd      	mov	sp, r7
 801e612:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e616:	4770      	bx	lr
 801e618:	2000a154 	.word	0x2000a154
 801e61c:	2000a158 	.word	0x2000a158
 801e620:	2000a15b 	.word	0x2000a15b
 801e624:	2000a150 	.word	0x2000a150
 801e628:	2000a159 	.word	0x2000a159
 801e62c:	2000a15a 	.word	0x2000a15a

0801e630 <rle_next>:

static inline uint8_t rle_next(void)
{
 801e630:	b580      	push	{r7, lr}
 801e632:	b082      	sub	sp, #8
 801e634:	af00      	add	r7, sp, #0
    uint8_t v = 0;
 801e636:	2300      	movs	r3, #0
 801e638:	71bb      	strb	r3, [r7, #6]
    uint8_t ret = 0;
 801e63a:	2300      	movs	r3, #0
 801e63c:	71fb      	strb	r3, [r7, #7]

    if(rle_state == RLE_STATE_SINGLE) {
 801e63e:	4b64      	ldr	r3, [pc, #400]	; (801e7d0 <rle_next+0x1a0>)
 801e640:	781b      	ldrb	r3, [r3, #0]
 801e642:	2b00      	cmp	r3, #0
 801e644:	d125      	bne.n	801e692 <rle_next+0x62>
        ret = get_bits(rle_in, rle_rdp, rle_bpp);
 801e646:	4b63      	ldr	r3, [pc, #396]	; (801e7d4 <rle_next+0x1a4>)
 801e648:	681b      	ldr	r3, [r3, #0]
 801e64a:	4a63      	ldr	r2, [pc, #396]	; (801e7d8 <rle_next+0x1a8>)
 801e64c:	6811      	ldr	r1, [r2, #0]
 801e64e:	4a63      	ldr	r2, [pc, #396]	; (801e7dc <rle_next+0x1ac>)
 801e650:	7812      	ldrb	r2, [r2, #0]
 801e652:	4618      	mov	r0, r3
 801e654:	f7ff fed0 	bl	801e3f8 <get_bits>
 801e658:	4603      	mov	r3, r0
 801e65a:	71fb      	strb	r3, [r7, #7]
        if(rle_rdp != 0 && rle_prev_v == ret) {
 801e65c:	4b5e      	ldr	r3, [pc, #376]	; (801e7d8 <rle_next+0x1a8>)
 801e65e:	681b      	ldr	r3, [r3, #0]
 801e660:	2b00      	cmp	r3, #0
 801e662:	d00a      	beq.n	801e67a <rle_next+0x4a>
 801e664:	4b5e      	ldr	r3, [pc, #376]	; (801e7e0 <rle_next+0x1b0>)
 801e666:	781b      	ldrb	r3, [r3, #0]
 801e668:	79fa      	ldrb	r2, [r7, #7]
 801e66a:	429a      	cmp	r2, r3
 801e66c:	d105      	bne.n	801e67a <rle_next+0x4a>
            rle_cnt = 0;
 801e66e:	4b5d      	ldr	r3, [pc, #372]	; (801e7e4 <rle_next+0x1b4>)
 801e670:	2200      	movs	r2, #0
 801e672:	701a      	strb	r2, [r3, #0]
            rle_state = RLE_STATE_REPEATE;
 801e674:	4b56      	ldr	r3, [pc, #344]	; (801e7d0 <rle_next+0x1a0>)
 801e676:	2201      	movs	r2, #1
 801e678:	701a      	strb	r2, [r3, #0]
        }

        rle_prev_v = ret;
 801e67a:	4a59      	ldr	r2, [pc, #356]	; (801e7e0 <rle_next+0x1b0>)
 801e67c:	79fb      	ldrb	r3, [r7, #7]
 801e67e:	7013      	strb	r3, [r2, #0]
        rle_rdp += rle_bpp;
 801e680:	4b56      	ldr	r3, [pc, #344]	; (801e7dc <rle_next+0x1ac>)
 801e682:	781b      	ldrb	r3, [r3, #0]
 801e684:	461a      	mov	r2, r3
 801e686:	4b54      	ldr	r3, [pc, #336]	; (801e7d8 <rle_next+0x1a8>)
 801e688:	681b      	ldr	r3, [r3, #0]
 801e68a:	4413      	add	r3, r2
 801e68c:	4a52      	ldr	r2, [pc, #328]	; (801e7d8 <rle_next+0x1a8>)
 801e68e:	6013      	str	r3, [r2, #0]
 801e690:	e099      	b.n	801e7c6 <rle_next+0x196>
    }
    else if(rle_state == RLE_STATE_REPEATE) {
 801e692:	4b4f      	ldr	r3, [pc, #316]	; (801e7d0 <rle_next+0x1a0>)
 801e694:	781b      	ldrb	r3, [r3, #0]
 801e696:	2b01      	cmp	r3, #1
 801e698:	d16b      	bne.n	801e772 <rle_next+0x142>
        v = get_bits(rle_in, rle_rdp, 1);
 801e69a:	4b4e      	ldr	r3, [pc, #312]	; (801e7d4 <rle_next+0x1a4>)
 801e69c:	681b      	ldr	r3, [r3, #0]
 801e69e:	4a4e      	ldr	r2, [pc, #312]	; (801e7d8 <rle_next+0x1a8>)
 801e6a0:	6811      	ldr	r1, [r2, #0]
 801e6a2:	2201      	movs	r2, #1
 801e6a4:	4618      	mov	r0, r3
 801e6a6:	f7ff fea7 	bl	801e3f8 <get_bits>
 801e6aa:	4603      	mov	r3, r0
 801e6ac:	71bb      	strb	r3, [r7, #6]
        rle_cnt++;
 801e6ae:	4b4d      	ldr	r3, [pc, #308]	; (801e7e4 <rle_next+0x1b4>)
 801e6b0:	781b      	ldrb	r3, [r3, #0]
 801e6b2:	3301      	adds	r3, #1
 801e6b4:	b2da      	uxtb	r2, r3
 801e6b6:	4b4b      	ldr	r3, [pc, #300]	; (801e7e4 <rle_next+0x1b4>)
 801e6b8:	701a      	strb	r2, [r3, #0]
        rle_rdp += 1;
 801e6ba:	4b47      	ldr	r3, [pc, #284]	; (801e7d8 <rle_next+0x1a8>)
 801e6bc:	681b      	ldr	r3, [r3, #0]
 801e6be:	3301      	adds	r3, #1
 801e6c0:	4a45      	ldr	r2, [pc, #276]	; (801e7d8 <rle_next+0x1a8>)
 801e6c2:	6013      	str	r3, [r2, #0]
        if(v == 1) {
 801e6c4:	79bb      	ldrb	r3, [r7, #6]
 801e6c6:	2b01      	cmp	r3, #1
 801e6c8:	d139      	bne.n	801e73e <rle_next+0x10e>
            ret = rle_prev_v;
 801e6ca:	4b45      	ldr	r3, [pc, #276]	; (801e7e0 <rle_next+0x1b0>)
 801e6cc:	781b      	ldrb	r3, [r3, #0]
 801e6ce:	71fb      	strb	r3, [r7, #7]
            if(rle_cnt == 11) {
 801e6d0:	4b44      	ldr	r3, [pc, #272]	; (801e7e4 <rle_next+0x1b4>)
 801e6d2:	781b      	ldrb	r3, [r3, #0]
 801e6d4:	2b0b      	cmp	r3, #11
 801e6d6:	d176      	bne.n	801e7c6 <rle_next+0x196>
                rle_cnt = get_bits(rle_in, rle_rdp, 6);
 801e6d8:	4b3e      	ldr	r3, [pc, #248]	; (801e7d4 <rle_next+0x1a4>)
 801e6da:	681b      	ldr	r3, [r3, #0]
 801e6dc:	4a3e      	ldr	r2, [pc, #248]	; (801e7d8 <rle_next+0x1a8>)
 801e6de:	6811      	ldr	r1, [r2, #0]
 801e6e0:	2206      	movs	r2, #6
 801e6e2:	4618      	mov	r0, r3
 801e6e4:	f7ff fe88 	bl	801e3f8 <get_bits>
 801e6e8:	4603      	mov	r3, r0
 801e6ea:	461a      	mov	r2, r3
 801e6ec:	4b3d      	ldr	r3, [pc, #244]	; (801e7e4 <rle_next+0x1b4>)
 801e6ee:	701a      	strb	r2, [r3, #0]
                rle_rdp += 6;
 801e6f0:	4b39      	ldr	r3, [pc, #228]	; (801e7d8 <rle_next+0x1a8>)
 801e6f2:	681b      	ldr	r3, [r3, #0]
 801e6f4:	3306      	adds	r3, #6
 801e6f6:	4a38      	ldr	r2, [pc, #224]	; (801e7d8 <rle_next+0x1a8>)
 801e6f8:	6013      	str	r3, [r2, #0]
                if(rle_cnt != 0) {
 801e6fa:	4b3a      	ldr	r3, [pc, #232]	; (801e7e4 <rle_next+0x1b4>)
 801e6fc:	781b      	ldrb	r3, [r3, #0]
 801e6fe:	2b00      	cmp	r3, #0
 801e700:	d003      	beq.n	801e70a <rle_next+0xda>
                    rle_state = RLE_STATE_COUNTER;
 801e702:	4b33      	ldr	r3, [pc, #204]	; (801e7d0 <rle_next+0x1a0>)
 801e704:	2202      	movs	r2, #2
 801e706:	701a      	strb	r2, [r3, #0]
 801e708:	e05d      	b.n	801e7c6 <rle_next+0x196>
                }
                else {
                    ret = get_bits(rle_in, rle_rdp, rle_bpp);
 801e70a:	4b32      	ldr	r3, [pc, #200]	; (801e7d4 <rle_next+0x1a4>)
 801e70c:	681b      	ldr	r3, [r3, #0]
 801e70e:	4a32      	ldr	r2, [pc, #200]	; (801e7d8 <rle_next+0x1a8>)
 801e710:	6811      	ldr	r1, [r2, #0]
 801e712:	4a32      	ldr	r2, [pc, #200]	; (801e7dc <rle_next+0x1ac>)
 801e714:	7812      	ldrb	r2, [r2, #0]
 801e716:	4618      	mov	r0, r3
 801e718:	f7ff fe6e 	bl	801e3f8 <get_bits>
 801e71c:	4603      	mov	r3, r0
 801e71e:	71fb      	strb	r3, [r7, #7]
                    rle_prev_v = ret;
 801e720:	4a2f      	ldr	r2, [pc, #188]	; (801e7e0 <rle_next+0x1b0>)
 801e722:	79fb      	ldrb	r3, [r7, #7]
 801e724:	7013      	strb	r3, [r2, #0]
                    rle_rdp += rle_bpp;
 801e726:	4b2d      	ldr	r3, [pc, #180]	; (801e7dc <rle_next+0x1ac>)
 801e728:	781b      	ldrb	r3, [r3, #0]
 801e72a:	461a      	mov	r2, r3
 801e72c:	4b2a      	ldr	r3, [pc, #168]	; (801e7d8 <rle_next+0x1a8>)
 801e72e:	681b      	ldr	r3, [r3, #0]
 801e730:	4413      	add	r3, r2
 801e732:	4a29      	ldr	r2, [pc, #164]	; (801e7d8 <rle_next+0x1a8>)
 801e734:	6013      	str	r3, [r2, #0]
                    rle_state = RLE_STATE_SINGLE;
 801e736:	4b26      	ldr	r3, [pc, #152]	; (801e7d0 <rle_next+0x1a0>)
 801e738:	2200      	movs	r2, #0
 801e73a:	701a      	strb	r2, [r3, #0]
 801e73c:	e043      	b.n	801e7c6 <rle_next+0x196>
                }
            }
        }
        else {
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
 801e73e:	4b25      	ldr	r3, [pc, #148]	; (801e7d4 <rle_next+0x1a4>)
 801e740:	681b      	ldr	r3, [r3, #0]
 801e742:	4a25      	ldr	r2, [pc, #148]	; (801e7d8 <rle_next+0x1a8>)
 801e744:	6811      	ldr	r1, [r2, #0]
 801e746:	4a25      	ldr	r2, [pc, #148]	; (801e7dc <rle_next+0x1ac>)
 801e748:	7812      	ldrb	r2, [r2, #0]
 801e74a:	4618      	mov	r0, r3
 801e74c:	f7ff fe54 	bl	801e3f8 <get_bits>
 801e750:	4603      	mov	r3, r0
 801e752:	71fb      	strb	r3, [r7, #7]
            rle_prev_v = ret;
 801e754:	4a22      	ldr	r2, [pc, #136]	; (801e7e0 <rle_next+0x1b0>)
 801e756:	79fb      	ldrb	r3, [r7, #7]
 801e758:	7013      	strb	r3, [r2, #0]
            rle_rdp += rle_bpp;
 801e75a:	4b20      	ldr	r3, [pc, #128]	; (801e7dc <rle_next+0x1ac>)
 801e75c:	781b      	ldrb	r3, [r3, #0]
 801e75e:	461a      	mov	r2, r3
 801e760:	4b1d      	ldr	r3, [pc, #116]	; (801e7d8 <rle_next+0x1a8>)
 801e762:	681b      	ldr	r3, [r3, #0]
 801e764:	4413      	add	r3, r2
 801e766:	4a1c      	ldr	r2, [pc, #112]	; (801e7d8 <rle_next+0x1a8>)
 801e768:	6013      	str	r3, [r2, #0]
            rle_state = RLE_STATE_SINGLE;
 801e76a:	4b19      	ldr	r3, [pc, #100]	; (801e7d0 <rle_next+0x1a0>)
 801e76c:	2200      	movs	r2, #0
 801e76e:	701a      	strb	r2, [r3, #0]
 801e770:	e029      	b.n	801e7c6 <rle_next+0x196>
        }


    }
    else if(rle_state == RLE_STATE_COUNTER) {
 801e772:	4b17      	ldr	r3, [pc, #92]	; (801e7d0 <rle_next+0x1a0>)
 801e774:	781b      	ldrb	r3, [r3, #0]
 801e776:	2b02      	cmp	r3, #2
 801e778:	d125      	bne.n	801e7c6 <rle_next+0x196>
        ret = rle_prev_v;
 801e77a:	4b19      	ldr	r3, [pc, #100]	; (801e7e0 <rle_next+0x1b0>)
 801e77c:	781b      	ldrb	r3, [r3, #0]
 801e77e:	71fb      	strb	r3, [r7, #7]
        rle_cnt--;
 801e780:	4b18      	ldr	r3, [pc, #96]	; (801e7e4 <rle_next+0x1b4>)
 801e782:	781b      	ldrb	r3, [r3, #0]
 801e784:	3b01      	subs	r3, #1
 801e786:	b2da      	uxtb	r2, r3
 801e788:	4b16      	ldr	r3, [pc, #88]	; (801e7e4 <rle_next+0x1b4>)
 801e78a:	701a      	strb	r2, [r3, #0]
        if(rle_cnt == 0) {
 801e78c:	4b15      	ldr	r3, [pc, #84]	; (801e7e4 <rle_next+0x1b4>)
 801e78e:	781b      	ldrb	r3, [r3, #0]
 801e790:	2b00      	cmp	r3, #0
 801e792:	d118      	bne.n	801e7c6 <rle_next+0x196>
            ret = get_bits(rle_in, rle_rdp, rle_bpp);
 801e794:	4b0f      	ldr	r3, [pc, #60]	; (801e7d4 <rle_next+0x1a4>)
 801e796:	681b      	ldr	r3, [r3, #0]
 801e798:	4a0f      	ldr	r2, [pc, #60]	; (801e7d8 <rle_next+0x1a8>)
 801e79a:	6811      	ldr	r1, [r2, #0]
 801e79c:	4a0f      	ldr	r2, [pc, #60]	; (801e7dc <rle_next+0x1ac>)
 801e79e:	7812      	ldrb	r2, [r2, #0]
 801e7a0:	4618      	mov	r0, r3
 801e7a2:	f7ff fe29 	bl	801e3f8 <get_bits>
 801e7a6:	4603      	mov	r3, r0
 801e7a8:	71fb      	strb	r3, [r7, #7]
            rle_prev_v = ret;
 801e7aa:	4a0d      	ldr	r2, [pc, #52]	; (801e7e0 <rle_next+0x1b0>)
 801e7ac:	79fb      	ldrb	r3, [r7, #7]
 801e7ae:	7013      	strb	r3, [r2, #0]
            rle_rdp += rle_bpp;
 801e7b0:	4b0a      	ldr	r3, [pc, #40]	; (801e7dc <rle_next+0x1ac>)
 801e7b2:	781b      	ldrb	r3, [r3, #0]
 801e7b4:	461a      	mov	r2, r3
 801e7b6:	4b08      	ldr	r3, [pc, #32]	; (801e7d8 <rle_next+0x1a8>)
 801e7b8:	681b      	ldr	r3, [r3, #0]
 801e7ba:	4413      	add	r3, r2
 801e7bc:	4a06      	ldr	r2, [pc, #24]	; (801e7d8 <rle_next+0x1a8>)
 801e7be:	6013      	str	r3, [r2, #0]
            rle_state = RLE_STATE_SINGLE;
 801e7c0:	4b03      	ldr	r3, [pc, #12]	; (801e7d0 <rle_next+0x1a0>)
 801e7c2:	2200      	movs	r2, #0
 801e7c4:	701a      	strb	r2, [r3, #0]
        }
    }

    return ret;
 801e7c6:	79fb      	ldrb	r3, [r7, #7]
}
 801e7c8:	4618      	mov	r0, r3
 801e7ca:	3708      	adds	r7, #8
 801e7cc:	46bd      	mov	sp, r7
 801e7ce:	bd80      	pop	{r7, pc}
 801e7d0:	2000a15b 	.word	0x2000a15b
 801e7d4:	2000a154 	.word	0x2000a154
 801e7d8:	2000a150 	.word	0x2000a150
 801e7dc:	2000a158 	.word	0x2000a158
 801e7e0:	2000a159 	.word	0x2000a159
 801e7e4:	2000a15a 	.word	0x2000a15a

0801e7e8 <unicode_list_compare>:
 *  @retval = 0   Reference is equal to element.
 *  @retval > 0   Reference is less than element.
 *
 */
static int32_t unicode_list_compare(const void * ref, const void * element)
{
 801e7e8:	b480      	push	{r7}
 801e7ea:	b083      	sub	sp, #12
 801e7ec:	af00      	add	r7, sp, #0
 801e7ee:	6078      	str	r0, [r7, #4]
 801e7f0:	6039      	str	r1, [r7, #0]
    return ((int32_t)(*(uint16_t *)ref)) - ((int32_t)(*(uint16_t *)element));
 801e7f2:	687b      	ldr	r3, [r7, #4]
 801e7f4:	881b      	ldrh	r3, [r3, #0]
 801e7f6:	461a      	mov	r2, r3
 801e7f8:	683b      	ldr	r3, [r7, #0]
 801e7fa:	881b      	ldrh	r3, [r3, #0]
 801e7fc:	1ad3      	subs	r3, r2, r3
}
 801e7fe:	4618      	mov	r0, r3
 801e800:	370c      	adds	r7, #12
 801e802:	46bd      	mov	sp, r7
 801e804:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e808:	4770      	bx	lr

0801e80a <lv_disp_drv_init>:
 * It is used to surly have known values in the fields ant not memory junk.
 * After it you can set the fields.
 * @param driver pointer to driver variable to initialize
 */
void lv_disp_drv_init(lv_disp_drv_t * driver)
{
 801e80a:	b580      	push	{r7, lr}
 801e80c:	b082      	sub	sp, #8
 801e80e:	af00      	add	r7, sp, #0
 801e810:	6078      	str	r0, [r7, #4]
    _lv_memset_00(driver, sizeof(lv_disp_drv_t));
 801e812:	212c      	movs	r1, #44	; 0x2c
 801e814:	6878      	ldr	r0, [r7, #4]
 801e816:	f002 ff47 	bl	80216a8 <_lv_memset_00>

    driver->flush_cb         = NULL;
 801e81a:	687b      	ldr	r3, [r7, #4]
 801e81c:	2200      	movs	r2, #0
 801e81e:	60da      	str	r2, [r3, #12]
    driver->hor_res          = LV_HOR_RES_MAX;
 801e820:	687b      	ldr	r3, [r7, #4]
 801e822:	f44f 7248 	mov.w	r2, #800	; 0x320
 801e826:	801a      	strh	r2, [r3, #0]
    driver->ver_res          = LV_VER_RES_MAX;
 801e828:	687b      	ldr	r3, [r7, #4]
 801e82a:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 801e82e:	805a      	strh	r2, [r3, #2]
    driver->buffer           = NULL;
 801e830:	687b      	ldr	r3, [r7, #4]
 801e832:	2200      	movs	r2, #0
 801e834:	605a      	str	r2, [r3, #4]
    driver->rotated          = 0;
 801e836:	687a      	ldr	r2, [r7, #4]
 801e838:	7a13      	ldrb	r3, [r2, #8]
 801e83a:	f36f 0341 	bfc	r3, #1, #1
 801e83e:	7213      	strb	r3, [r2, #8]
    driver->color_chroma_key = LV_COLOR_TRANSP;
 801e840:	687a      	ldr	r2, [r7, #4]
 801e842:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 801e846:	f36f 0304 	bfc	r3, #0, #5
 801e84a:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 801e84e:	687a      	ldr	r2, [r7, #4]
 801e850:	8d13      	ldrh	r3, [r2, #40]	; 0x28
 801e852:	f443 63fc 	orr.w	r3, r3, #2016	; 0x7e0
 801e856:	8513      	strh	r3, [r2, #40]	; 0x28
 801e858:	687a      	ldr	r2, [r7, #4]
 801e85a:	f892 3029 	ldrb.w	r3, [r2, #41]	; 0x29
 801e85e:	f36f 03c7 	bfc	r3, #3, #5
 801e862:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
    driver->dpi = LV_DPI;
 801e866:	687a      	ldr	r2, [r7, #4]
 801e868:	8913      	ldrh	r3, [r2, #8]
 801e86a:	2182      	movs	r1, #130	; 0x82
 801e86c:	f361 038b 	bfi	r3, r1, #2, #10
 801e870:	8113      	strh	r3, [r2, #8]

#if LV_ANTIALIAS
    driver->antialiasing = true;
 801e872:	687a      	ldr	r2, [r7, #4]
 801e874:	7a13      	ldrb	r3, [r2, #8]
 801e876:	f043 0301 	orr.w	r3, r3, #1
 801e87a:	7213      	strb	r3, [r2, #8]
#if LV_COLOR_SCREEN_TRANSP
    driver->screen_transp = 1;
#endif

#if LV_USE_GPU
    driver->gpu_blend_cb = NULL;
 801e87c:	687b      	ldr	r3, [r7, #4]
 801e87e:	2200      	movs	r2, #0
 801e880:	621a      	str	r2, [r3, #32]
    driver->gpu_fill_cb  = NULL;
 801e882:	687b      	ldr	r3, [r7, #4]
 801e884:	2200      	movs	r2, #0
 801e886:	625a      	str	r2, [r3, #36]	; 0x24

#if LV_USE_USER_DATA
    driver->user_data = NULL;
#endif

    driver->set_px_cb = NULL;
 801e888:	687b      	ldr	r3, [r7, #4]
 801e88a:	2200      	movs	r2, #0
 801e88c:	615a      	str	r2, [r3, #20]
}
 801e88e:	bf00      	nop
 801e890:	3708      	adds	r7, #8
 801e892:	46bd      	mov	sp, r7
 801e894:	bd80      	pop	{r7, pc}

0801e896 <lv_disp_buf_init>:
 *             It lets LVGL to render next frame into the other buffer while previous is being
 * sent. Set to `NULL` if unused.
 * @param size_in_px_cnt size of the `buf1` and `buf2` in pixel count.
 */
void lv_disp_buf_init(lv_disp_buf_t * disp_buf, void * buf1, void * buf2, uint32_t size_in_px_cnt)
{
 801e896:	b580      	push	{r7, lr}
 801e898:	b084      	sub	sp, #16
 801e89a:	af00      	add	r7, sp, #0
 801e89c:	60f8      	str	r0, [r7, #12]
 801e89e:	60b9      	str	r1, [r7, #8]
 801e8a0:	607a      	str	r2, [r7, #4]
 801e8a2:	603b      	str	r3, [r7, #0]
    _lv_memset_00(disp_buf, sizeof(lv_disp_buf_t));
 801e8a4:	2124      	movs	r1, #36	; 0x24
 801e8a6:	68f8      	ldr	r0, [r7, #12]
 801e8a8:	f002 fefe 	bl	80216a8 <_lv_memset_00>

    disp_buf->buf1    = buf1;
 801e8ac:	68fb      	ldr	r3, [r7, #12]
 801e8ae:	68ba      	ldr	r2, [r7, #8]
 801e8b0:	601a      	str	r2, [r3, #0]
    disp_buf->buf2    = buf2;
 801e8b2:	68fb      	ldr	r3, [r7, #12]
 801e8b4:	687a      	ldr	r2, [r7, #4]
 801e8b6:	605a      	str	r2, [r3, #4]
    disp_buf->buf_act = disp_buf->buf1;
 801e8b8:	68fb      	ldr	r3, [r7, #12]
 801e8ba:	681a      	ldr	r2, [r3, #0]
 801e8bc:	68fb      	ldr	r3, [r7, #12]
 801e8be:	609a      	str	r2, [r3, #8]
    disp_buf->size    = size_in_px_cnt;
 801e8c0:	68fb      	ldr	r3, [r7, #12]
 801e8c2:	683a      	ldr	r2, [r7, #0]
 801e8c4:	60da      	str	r2, [r3, #12]
}
 801e8c6:	bf00      	nop
 801e8c8:	3710      	adds	r7, #16
 801e8ca:	46bd      	mov	sp, r7
 801e8cc:	bd80      	pop	{r7, pc}
	...

0801e8d0 <lv_disp_drv_register>:
 * Automatically set the first display as active.
 * @param driver pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)
 * @return pointer to the new display or NULL on error
 */
lv_disp_t * lv_disp_drv_register(lv_disp_drv_t * driver)
{
 801e8d0:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 801e8d4:	b084      	sub	sp, #16
 801e8d6:	af00      	add	r7, sp, #0
 801e8d8:	6078      	str	r0, [r7, #4]
    lv_disp_t * disp = _lv_ll_ins_head(&LV_GC_ROOT(_lv_disp_ll));
 801e8da:	4861      	ldr	r0, [pc, #388]	; (801ea60 <lv_disp_drv_register+0x190>)
 801e8dc:	f001 fe61 	bl	80205a2 <_lv_ll_ins_head>
 801e8e0:	60f8      	str	r0, [r7, #12]
    if(!disp) {
 801e8e2:	68fb      	ldr	r3, [r7, #12]
 801e8e4:	2b00      	cmp	r3, #0
 801e8e6:	d114      	bne.n	801e912 <lv_disp_drv_register+0x42>
        LV_ASSERT_MEM(disp);
 801e8e8:	68f8      	ldr	r0, [r7, #12]
 801e8ea:	f001 fc01 	bl	80200f0 <lv_debug_check_null>
 801e8ee:	4603      	mov	r3, r0
 801e8f0:	f083 0301 	eor.w	r3, r3, #1
 801e8f4:	b2db      	uxtb	r3, r3
 801e8f6:	2b00      	cmp	r3, #0
 801e8f8:	d009      	beq.n	801e90e <lv_disp_drv_register+0x3e>
 801e8fa:	68fb      	ldr	r3, [r7, #12]
 801e8fc:	2200      	movs	r2, #0
 801e8fe:	4698      	mov	r8, r3
 801e900:	4691      	mov	r9, r2
 801e902:	4642      	mov	r2, r8
 801e904:	464b      	mov	r3, r9
 801e906:	4857      	ldr	r0, [pc, #348]	; (801ea64 <lv_disp_drv_register+0x194>)
 801e908:	f001 fc02 	bl	8020110 <lv_debug_log_error>
 801e90c:	e7fe      	b.n	801e90c <lv_disp_drv_register+0x3c>
        return NULL;
 801e90e:	2300      	movs	r3, #0
 801e910:	e0a1      	b.n	801ea56 <lv_disp_drv_register+0x186>
    }

    _lv_memset_00(disp, sizeof(lv_disp_t));
 801e912:	f44f 71be 	mov.w	r1, #380	; 0x17c
 801e916:	68f8      	ldr	r0, [r7, #12]
 801e918:	f002 fec6 	bl	80216a8 <_lv_memset_00>
    _lv_memcpy(&disp->driver, driver, sizeof(lv_disp_drv_t));
 801e91c:	68fb      	ldr	r3, [r7, #12]
 801e91e:	222c      	movs	r2, #44	; 0x2c
 801e920:	6879      	ldr	r1, [r7, #4]
 801e922:	4618      	mov	r0, r3
 801e924:	f002 fc1a 	bl	802115c <_lv_memcpy>

    _lv_ll_init(&disp->scr_ll, sizeof(lv_obj_t));
 801e928:	68fb      	ldr	r3, [r7, #12]
 801e92a:	3330      	adds	r3, #48	; 0x30
 801e92c:	214c      	movs	r1, #76	; 0x4c
 801e92e:	4618      	mov	r0, r3
 801e930:	f001 fe1e 	bl	8020570 <_lv_ll_init>
    disp->last_activity_time = 0;
 801e934:	68fb      	ldr	r3, [r7, #12]
 801e936:	2200      	movs	r2, #0
 801e938:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178

    if(disp_def == NULL) disp_def = disp;
 801e93c:	4b4a      	ldr	r3, [pc, #296]	; (801ea68 <lv_disp_drv_register+0x198>)
 801e93e:	681b      	ldr	r3, [r3, #0]
 801e940:	2b00      	cmp	r3, #0
 801e942:	d102      	bne.n	801e94a <lv_disp_drv_register+0x7a>
 801e944:	4a48      	ldr	r2, [pc, #288]	; (801ea68 <lv_disp_drv_register+0x198>)
 801e946:	68fb      	ldr	r3, [r7, #12]
 801e948:	6013      	str	r3, [r2, #0]

    lv_disp_t * disp_def_tmp = disp_def;
 801e94a:	4b47      	ldr	r3, [pc, #284]	; (801ea68 <lv_disp_drv_register+0x198>)
 801e94c:	681b      	ldr	r3, [r3, #0]
 801e94e:	60bb      	str	r3, [r7, #8]
    disp_def                 = disp; /*Temporarily change the default screen to create the default screens on the
 801e950:	4a45      	ldr	r2, [pc, #276]	; (801ea68 <lv_disp_drv_register+0x198>)
 801e952:	68fb      	ldr	r3, [r7, #12]
 801e954:	6013      	str	r3, [r2, #0]
                                        new display*/
    /*Create a refresh task*/
    disp->refr_task = lv_task_create(_lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_REFR_TASK_PRIO, disp);
 801e956:	68fb      	ldr	r3, [r7, #12]
 801e958:	2203      	movs	r2, #3
 801e95a:	211e      	movs	r1, #30
 801e95c:	4843      	ldr	r0, [pc, #268]	; (801ea6c <lv_disp_drv_register+0x19c>)
 801e95e:	f003 fa45 	bl	8021dec <lv_task_create>
 801e962:	4602      	mov	r2, r0
 801e964:	68fb      	ldr	r3, [r7, #12]
 801e966:	62da      	str	r2, [r3, #44]	; 0x2c
    LV_ASSERT_MEM(disp->refr_task);
 801e968:	68fb      	ldr	r3, [r7, #12]
 801e96a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801e96c:	4618      	mov	r0, r3
 801e96e:	f001 fbbf 	bl	80200f0 <lv_debug_check_null>
 801e972:	4603      	mov	r3, r0
 801e974:	f083 0301 	eor.w	r3, r3, #1
 801e978:	b2db      	uxtb	r3, r3
 801e97a:	2b00      	cmp	r3, #0
 801e97c:	d00b      	beq.n	801e996 <lv_disp_drv_register+0xc6>
 801e97e:	68fb      	ldr	r3, [r7, #12]
 801e980:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801e982:	461a      	mov	r2, r3
 801e984:	2300      	movs	r3, #0
 801e986:	4614      	mov	r4, r2
 801e988:	461d      	mov	r5, r3
 801e98a:	4622      	mov	r2, r4
 801e98c:	462b      	mov	r3, r5
 801e98e:	4835      	ldr	r0, [pc, #212]	; (801ea64 <lv_disp_drv_register+0x194>)
 801e990:	f001 fbbe 	bl	8020110 <lv_debug_log_error>
 801e994:	e7fe      	b.n	801e994 <lv_disp_drv_register+0xc4>
    if(disp->refr_task == NULL) return NULL;
 801e996:	68fb      	ldr	r3, [r7, #12]
 801e998:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801e99a:	2b00      	cmp	r3, #0
 801e99c:	d101      	bne.n	801e9a2 <lv_disp_drv_register+0xd2>
 801e99e:	2300      	movs	r3, #0
 801e9a0:	e059      	b.n	801ea56 <lv_disp_drv_register+0x186>

    disp->inv_p = 0;
 801e9a2:	68fa      	ldr	r2, [r7, #12]
 801e9a4:	f8b2 3176 	ldrh.w	r3, [r2, #374]	; 0x176
 801e9a8:	f36f 0309 	bfc	r3, #0, #10
 801e9ac:	f8a2 3176 	strh.w	r3, [r2, #374]	; 0x176
    disp->last_activity_time = 0;
 801e9b0:	68fb      	ldr	r3, [r7, #12]
 801e9b2:	2200      	movs	r2, #0
 801e9b4:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178

    disp->bg_color = LV_COLOR_WHITE;
 801e9b8:	68fb      	ldr	r3, [r7, #12]
 801e9ba:	4a2d      	ldr	r2, [pc, #180]	; (801ea70 <lv_disp_drv_register+0x1a0>)
 801e9bc:	8812      	ldrh	r2, [r2, #0]
 801e9be:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    disp->bg_img = NULL;
 801e9c2:	68fb      	ldr	r3, [r7, #12]
 801e9c4:	2200      	movs	r2, #0
 801e9c6:	651a      	str	r2, [r3, #80]	; 0x50
#if LV_COLOR_SCREEN_TRANSP
    disp->bg_opa = LV_OPA_TRANSP;
#else
    disp->bg_opa = LV_OPA_COVER;
 801e9c8:	68fb      	ldr	r3, [r7, #12]
 801e9ca:	22ff      	movs	r2, #255	; 0xff
 801e9cc:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
#endif

    disp->prev_scr  = NULL;
 801e9d0:	68fb      	ldr	r3, [r7, #12]
 801e9d2:	2200      	movs	r2, #0
 801e9d4:	641a      	str	r2, [r3, #64]	; 0x40
    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
 801e9d6:	2100      	movs	r1, #0
 801e9d8:	2000      	movs	r0, #0
 801e9da:	f7ea fca9 	bl	8009330 <lv_obj_create>
 801e9de:	4602      	mov	r2, r0
 801e9e0:	68fb      	ldr	r3, [r7, #12]
 801e9e2:	63da      	str	r2, [r3, #60]	; 0x3c
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
 801e9e4:	2100      	movs	r1, #0
 801e9e6:	2000      	movs	r0, #0
 801e9e8:	f7ea fca2 	bl	8009330 <lv_obj_create>
 801e9ec:	4602      	mov	r2, r0
 801e9ee:	68fb      	ldr	r3, [r7, #12]
 801e9f0:	645a      	str	r2, [r3, #68]	; 0x44
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
 801e9f2:	2100      	movs	r1, #0
 801e9f4:	2000      	movs	r0, #0
 801e9f6:	f7ea fc9b 	bl	8009330 <lv_obj_create>
 801e9fa:	4602      	mov	r2, r0
 801e9fc:	68fb      	ldr	r3, [r7, #12]
 801e9fe:	649a      	str	r2, [r3, #72]	; 0x48
    lv_obj_reset_style_list(disp->top_layer, LV_OBJ_PART_MAIN);
 801ea00:	68fb      	ldr	r3, [r7, #12]
 801ea02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801ea04:	2100      	movs	r1, #0
 801ea06:	4618      	mov	r0, r3
 801ea08:	f7eb fc3d 	bl	800a286 <lv_obj_reset_style_list>
    lv_obj_reset_style_list(disp->sys_layer, LV_OBJ_PART_MAIN);
 801ea0c:	68fb      	ldr	r3, [r7, #12]
 801ea0e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801ea10:	2100      	movs	r1, #0
 801ea12:	4618      	mov	r0, r3
 801ea14:	f7eb fc37 	bl	800a286 <lv_obj_reset_style_list>
    lv_obj_set_click(disp->top_layer, false);
 801ea18:	68fb      	ldr	r3, [r7, #12]
 801ea1a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801ea1c:	2100      	movs	r1, #0
 801ea1e:	4618      	mov	r0, r3
 801ea20:	f7eb fd76 	bl	800a510 <lv_obj_set_click>
    lv_obj_set_click(disp->sys_layer, false);
 801ea24:	68fb      	ldr	r3, [r7, #12]
 801ea26:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 801ea28:	2100      	movs	r1, #0
 801ea2a:	4618      	mov	r0, r3
 801ea2c:	f7eb fd70 	bl	800a510 <lv_obj_set_click>

    lv_obj_invalidate(disp->act_scr);
 801ea30:	68fb      	ldr	r3, [r7, #12]
 801ea32:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801ea34:	4618      	mov	r0, r3
 801ea36:	f7ea ffe3 	bl	8009a00 <lv_obj_invalidate>

    disp_def = disp_def_tmp; /*Revert the default display*/
 801ea3a:	4a0b      	ldr	r2, [pc, #44]	; (801ea68 <lv_disp_drv_register+0x198>)
 801ea3c:	68bb      	ldr	r3, [r7, #8]
 801ea3e:	6013      	str	r3, [r2, #0]

    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
 801ea40:	68fb      	ldr	r3, [r7, #12]
 801ea42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801ea44:	4618      	mov	r0, r3
 801ea46:	f003 fa97 	bl	8021f78 <lv_task_ready>

    /*Can't handle this case later so add an error*/
    if(lv_disp_is_true_double_buf(disp) && disp->driver.set_px_cb) {
 801ea4a:	68f8      	ldr	r0, [r7, #12]
 801ea4c:	f000 f901 	bl	801ec52 <lv_disp_is_true_double_buf>
 801ea50:	4603      	mov	r3, r0
 801ea52:	2b00      	cmp	r3, #0
        LV_LOG_ERROR("Can't handle 2 screen sized buffers with set_px_cb. Display will not be refreshed.");
    }

    return disp;
 801ea54:	68fb      	ldr	r3, [r7, #12]
}
 801ea56:	4618      	mov	r0, r3
 801ea58:	3710      	adds	r7, #16
 801ea5a:	46bd      	mov	sp, r7
 801ea5c:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 801ea60:	2000a180 	.word	0x2000a180
 801ea64:	0802e4bc 	.word	0x0802e4bc
 801ea68:	2000a15c 	.word	0x2000a15c
 801ea6c:	0800e3f9 	.word	0x0800e3f9
 801ea70:	0802e4cc 	.word	0x0802e4cc

0801ea74 <lv_disp_get_default>:
/**
 * Get the default display
 * @return pointer to the default display
 */
lv_disp_t * lv_disp_get_default(void)
{
 801ea74:	b480      	push	{r7}
 801ea76:	af00      	add	r7, sp, #0
    return disp_def;
 801ea78:	4b03      	ldr	r3, [pc, #12]	; (801ea88 <lv_disp_get_default+0x14>)
 801ea7a:	681b      	ldr	r3, [r3, #0]
}
 801ea7c:	4618      	mov	r0, r3
 801ea7e:	46bd      	mov	sp, r7
 801ea80:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ea84:	4770      	bx	lr
 801ea86:	bf00      	nop
 801ea88:	2000a15c 	.word	0x2000a15c

0801ea8c <lv_disp_get_hor_res>:
 * Get the horizontal resolution of a display
 * @param disp pointer to a display (NULL to use the default display)
 * @return the horizontal resolution of the display
 */
lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)
{
 801ea8c:	b580      	push	{r7, lr}
 801ea8e:	b082      	sub	sp, #8
 801ea90:	af00      	add	r7, sp, #0
 801ea92:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_disp_get_default();
 801ea94:	687b      	ldr	r3, [r7, #4]
 801ea96:	2b00      	cmp	r3, #0
 801ea98:	d102      	bne.n	801eaa0 <lv_disp_get_hor_res+0x14>
 801ea9a:	f7ff ffeb 	bl	801ea74 <lv_disp_get_default>
 801ea9e:	6078      	str	r0, [r7, #4]

    if(disp == NULL)
 801eaa0:	687b      	ldr	r3, [r7, #4]
 801eaa2:	2b00      	cmp	r3, #0
 801eaa4:	d102      	bne.n	801eaac <lv_disp_get_hor_res+0x20>
        return LV_HOR_RES_MAX;
 801eaa6:	f44f 7348 	mov.w	r3, #800	; 0x320
 801eaaa:	e00d      	b.n	801eac8 <lv_disp_get_hor_res+0x3c>
    else
        return disp->driver.rotated == 0 ? disp->driver.hor_res : disp->driver.ver_res;
 801eaac:	687b      	ldr	r3, [r7, #4]
 801eaae:	7a1b      	ldrb	r3, [r3, #8]
 801eab0:	f003 0302 	and.w	r3, r3, #2
 801eab4:	b2db      	uxtb	r3, r3
 801eab6:	2b00      	cmp	r3, #0
 801eab8:	d103      	bne.n	801eac2 <lv_disp_get_hor_res+0x36>
 801eaba:	687b      	ldr	r3, [r7, #4]
 801eabc:	f9b3 3000 	ldrsh.w	r3, [r3]
 801eac0:	e002      	b.n	801eac8 <lv_disp_get_hor_res+0x3c>
 801eac2:	687b      	ldr	r3, [r7, #4]
 801eac4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
}
 801eac8:	4618      	mov	r0, r3
 801eaca:	3708      	adds	r7, #8
 801eacc:	46bd      	mov	sp, r7
 801eace:	bd80      	pop	{r7, pc}

0801ead0 <lv_disp_get_ver_res>:
 * Get the vertical resolution of a display
 * @param disp pointer to a display (NULL to use the default display)
 * @return the vertical resolution of the display
 */
lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)
{
 801ead0:	b580      	push	{r7, lr}
 801ead2:	b082      	sub	sp, #8
 801ead4:	af00      	add	r7, sp, #0
 801ead6:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_disp_get_default();
 801ead8:	687b      	ldr	r3, [r7, #4]
 801eada:	2b00      	cmp	r3, #0
 801eadc:	d102      	bne.n	801eae4 <lv_disp_get_ver_res+0x14>
 801eade:	f7ff ffc9 	bl	801ea74 <lv_disp_get_default>
 801eae2:	6078      	str	r0, [r7, #4]

    if(disp == NULL)
 801eae4:	687b      	ldr	r3, [r7, #4]
 801eae6:	2b00      	cmp	r3, #0
 801eae8:	d102      	bne.n	801eaf0 <lv_disp_get_ver_res+0x20>
        return LV_VER_RES_MAX;
 801eaea:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 801eaee:	e00d      	b.n	801eb0c <lv_disp_get_ver_res+0x3c>
    else
        return disp->driver.rotated == 0 ? disp->driver.ver_res : disp->driver.hor_res;
 801eaf0:	687b      	ldr	r3, [r7, #4]
 801eaf2:	7a1b      	ldrb	r3, [r3, #8]
 801eaf4:	f003 0302 	and.w	r3, r3, #2
 801eaf8:	b2db      	uxtb	r3, r3
 801eafa:	2b00      	cmp	r3, #0
 801eafc:	d103      	bne.n	801eb06 <lv_disp_get_ver_res+0x36>
 801eafe:	687b      	ldr	r3, [r7, #4]
 801eb00:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801eb04:	e002      	b.n	801eb0c <lv_disp_get_ver_res+0x3c>
 801eb06:	687b      	ldr	r3, [r7, #4]
 801eb08:	f9b3 3000 	ldrsh.w	r3, [r3]
}
 801eb0c:	4618      	mov	r0, r3
 801eb0e:	3708      	adds	r7, #8
 801eb10:	46bd      	mov	sp, r7
 801eb12:	bd80      	pop	{r7, pc}

0801eb14 <lv_disp_get_dpi>:
 * Get the DPI of the display
 * @param disp pointer to a display (NULL to use the default display)
 * @return dpi of the display
 */
lv_coord_t lv_disp_get_dpi(lv_disp_t * disp)
{
 801eb14:	b580      	push	{r7, lr}
 801eb16:	b082      	sub	sp, #8
 801eb18:	af00      	add	r7, sp, #0
 801eb1a:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_disp_get_default();
 801eb1c:	687b      	ldr	r3, [r7, #4]
 801eb1e:	2b00      	cmp	r3, #0
 801eb20:	d102      	bne.n	801eb28 <lv_disp_get_dpi+0x14>
 801eb22:	f7ff ffa7 	bl	801ea74 <lv_disp_get_default>
 801eb26:	6078      	str	r0, [r7, #4]
    if(disp == NULL) return LV_DPI;  /*Do not return 0 because it might be a divider*/
 801eb28:	687b      	ldr	r3, [r7, #4]
 801eb2a:	2b00      	cmp	r3, #0
 801eb2c:	d101      	bne.n	801eb32 <lv_disp_get_dpi+0x1e>
 801eb2e:	2382      	movs	r3, #130	; 0x82
 801eb30:	e005      	b.n	801eb3e <lv_disp_get_dpi+0x2a>
    return disp->driver.dpi;
 801eb32:	687b      	ldr	r3, [r7, #4]
 801eb34:	891b      	ldrh	r3, [r3, #8]
 801eb36:	f3c3 0389 	ubfx	r3, r3, #2, #10
 801eb3a:	b29b      	uxth	r3, r3
 801eb3c:	b21b      	sxth	r3, r3
}
 801eb3e:	4618      	mov	r0, r3
 801eb40:	3708      	adds	r7, #8
 801eb42:	46bd      	mov	sp, r7
 801eb44:	bd80      	pop	{r7, pc}

0801eb46 <lv_disp_get_size_category>:
 * Get the size category of the display based on it's hor. res. and dpi.
 * @param disp pointer to a display (NULL to use the default display)
 * @return LV_DISP_SIZE_SMALL/MEDIUM/LARGE/EXTRA_LARGE
 */
lv_disp_size_t lv_disp_get_size_category(lv_disp_t * disp)
{
 801eb46:	b580      	push	{r7, lr}
 801eb48:	b084      	sub	sp, #16
 801eb4a:	af00      	add	r7, sp, #0
 801eb4c:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_disp_get_default();
 801eb4e:	687b      	ldr	r3, [r7, #4]
 801eb50:	2b00      	cmp	r3, #0
 801eb52:	d102      	bne.n	801eb5a <lv_disp_get_size_category+0x14>
 801eb54:	f7ff ff8e 	bl	801ea74 <lv_disp_get_default>
 801eb58:	6078      	str	r0, [r7, #4]

    uint32_t w;
    if(disp == NULL) w = LV_HOR_RES_MAX;
 801eb5a:	687b      	ldr	r3, [r7, #4]
 801eb5c:	2b00      	cmp	r3, #0
 801eb5e:	d103      	bne.n	801eb68 <lv_disp_get_size_category+0x22>
 801eb60:	f44f 7348 	mov.w	r3, #800	; 0x320
 801eb64:	60fb      	str	r3, [r7, #12]
 801eb66:	e004      	b.n	801eb72 <lv_disp_get_size_category+0x2c>
    else w = lv_disp_get_hor_res(disp);
 801eb68:	6878      	ldr	r0, [r7, #4]
 801eb6a:	f7ff ff8f 	bl	801ea8c <lv_disp_get_hor_res>
 801eb6e:	4603      	mov	r3, r0
 801eb70:	60fb      	str	r3, [r7, #12]

    uint32_t dpi = lv_disp_get_dpi(disp);
 801eb72:	6878      	ldr	r0, [r7, #4]
 801eb74:	f7ff ffce 	bl	801eb14 <lv_disp_get_dpi>
 801eb78:	4603      	mov	r3, r0
 801eb7a:	60bb      	str	r3, [r7, #8]

    w = w * 10 / dpi;
 801eb7c:	68fa      	ldr	r2, [r7, #12]
 801eb7e:	4613      	mov	r3, r2
 801eb80:	009b      	lsls	r3, r3, #2
 801eb82:	4413      	add	r3, r2
 801eb84:	005b      	lsls	r3, r3, #1
 801eb86:	461a      	mov	r2, r3
 801eb88:	68bb      	ldr	r3, [r7, #8]
 801eb8a:	fbb2 f3f3 	udiv	r3, r2, r3
 801eb8e:	60fb      	str	r3, [r7, #12]

    if(w < LV_DISP_SMALL_LIMIT) return LV_DISP_SIZE_SMALL;
 801eb90:	68fb      	ldr	r3, [r7, #12]
 801eb92:	2b1d      	cmp	r3, #29
 801eb94:	d801      	bhi.n	801eb9a <lv_disp_get_size_category+0x54>
 801eb96:	2300      	movs	r3, #0
 801eb98:	e00a      	b.n	801ebb0 <lv_disp_get_size_category+0x6a>
    if(w < LV_DISP_MEDIUM_LIMIT) return LV_DISP_SIZE_MEDIUM;
 801eb9a:	68fb      	ldr	r3, [r7, #12]
 801eb9c:	2b31      	cmp	r3, #49	; 0x31
 801eb9e:	d801      	bhi.n	801eba4 <lv_disp_get_size_category+0x5e>
 801eba0:	2301      	movs	r3, #1
 801eba2:	e005      	b.n	801ebb0 <lv_disp_get_size_category+0x6a>
    if(w < LV_DISP_LARGE_LIMIT) return LV_DISP_SIZE_LARGE;
 801eba4:	68fb      	ldr	r3, [r7, #12]
 801eba6:	2b45      	cmp	r3, #69	; 0x45
 801eba8:	d801      	bhi.n	801ebae <lv_disp_get_size_category+0x68>
 801ebaa:	2302      	movs	r3, #2
 801ebac:	e000      	b.n	801ebb0 <lv_disp_get_size_category+0x6a>
    else return LV_DISP_SIZE_EXTRA_LARGE;
 801ebae:	2303      	movs	r3, #3
}
 801ebb0:	4618      	mov	r0, r3
 801ebb2:	3710      	adds	r7, #16
 801ebb4:	46bd      	mov	sp, r7
 801ebb6:	bd80      	pop	{r7, pc}

0801ebb8 <lv_disp_flush_ready>:
/**
 * Call in the display driver's `flush_cb` function when the flushing is finished
 * @param disp_drv pointer to display driver in `flush_cb` where this function is called
 */
LV_ATTRIBUTE_FLUSH_READY void lv_disp_flush_ready(lv_disp_drv_t * disp_drv)
{
 801ebb8:	b480      	push	{r7}
 801ebba:	b083      	sub	sp, #12
 801ebbc:	af00      	add	r7, sp, #0
 801ebbe:	6078      	str	r0, [r7, #4]
    if(disp_drv->screen_transp) {
        _lv_memset_00(disp_drv->buffer->buf_act, disp_drv->buffer->size * sizeof(lv_color32_t));
    }
#endif

    disp_drv->buffer->flushing = 0;
 801ebc0:	687b      	ldr	r3, [r7, #4]
 801ebc2:	685b      	ldr	r3, [r3, #4]
 801ebc4:	2200      	movs	r2, #0
 801ebc6:	619a      	str	r2, [r3, #24]
    disp_drv->buffer->flushing_last = 0;
 801ebc8:	687b      	ldr	r3, [r7, #4]
 801ebca:	685b      	ldr	r3, [r3, #4]
 801ebcc:	2200      	movs	r2, #0
 801ebce:	61da      	str	r2, [r3, #28]
}
 801ebd0:	bf00      	nop
 801ebd2:	370c      	adds	r7, #12
 801ebd4:	46bd      	mov	sp, r7
 801ebd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ebda:	4770      	bx	lr

0801ebdc <lv_disp_get_next>:
 * Get the next display.
 * @param disp pointer to the current display. NULL to initialize.
 * @return the next display or NULL if no more. Give the first display when the parameter is NULL
 */
lv_disp_t * lv_disp_get_next(lv_disp_t * disp)
{
 801ebdc:	b580      	push	{r7, lr}
 801ebde:	b082      	sub	sp, #8
 801ebe0:	af00      	add	r7, sp, #0
 801ebe2:	6078      	str	r0, [r7, #4]
    if(disp == NULL)
 801ebe4:	687b      	ldr	r3, [r7, #4]
 801ebe6:	2b00      	cmp	r3, #0
 801ebe8:	d104      	bne.n	801ebf4 <lv_disp_get_next+0x18>
        return _lv_ll_get_head(&LV_GC_ROOT(_lv_disp_ll));
 801ebea:	4807      	ldr	r0, [pc, #28]	; (801ec08 <lv_disp_get_next+0x2c>)
 801ebec:	f001 fe36 	bl	802085c <_lv_ll_get_head>
 801ebf0:	4603      	mov	r3, r0
 801ebf2:	e004      	b.n	801ebfe <lv_disp_get_next+0x22>
    else
        return _lv_ll_get_next(&LV_GC_ROOT(_lv_disp_ll), disp);
 801ebf4:	6879      	ldr	r1, [r7, #4]
 801ebf6:	4804      	ldr	r0, [pc, #16]	; (801ec08 <lv_disp_get_next+0x2c>)
 801ebf8:	f001 fe56 	bl	80208a8 <_lv_ll_get_next>
 801ebfc:	4603      	mov	r3, r0
}
 801ebfe:	4618      	mov	r0, r3
 801ec00:	3708      	adds	r7, #8
 801ec02:	46bd      	mov	sp, r7
 801ec04:	bd80      	pop	{r7, pc}
 801ec06:	bf00      	nop
 801ec08:	2000a180 	.word	0x2000a180

0801ec0c <lv_disp_get_buf>:
 * Get the internal buffer of a display
 * @param disp pointer to a display
 * @return pointer to the internal buffers
 */
lv_disp_buf_t * lv_disp_get_buf(lv_disp_t * disp)
{
 801ec0c:	b480      	push	{r7}
 801ec0e:	b083      	sub	sp, #12
 801ec10:	af00      	add	r7, sp, #0
 801ec12:	6078      	str	r0, [r7, #4]
    return disp->driver.buffer;
 801ec14:	687b      	ldr	r3, [r7, #4]
 801ec16:	685b      	ldr	r3, [r3, #4]
}
 801ec18:	4618      	mov	r0, r3
 801ec1a:	370c      	adds	r7, #12
 801ec1c:	46bd      	mov	sp, r7
 801ec1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ec22:	4770      	bx	lr

0801ec24 <lv_disp_is_double_buf>:
 * Check the driver configuration if it's double buffered (both `buf1` and `buf2` are set)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_double_buf(lv_disp_t * disp)
{
 801ec24:	b480      	push	{r7}
 801ec26:	b083      	sub	sp, #12
 801ec28:	af00      	add	r7, sp, #0
 801ec2a:	6078      	str	r0, [r7, #4]
    if(disp->driver.buffer->buf1 && disp->driver.buffer->buf2)
 801ec2c:	687b      	ldr	r3, [r7, #4]
 801ec2e:	685b      	ldr	r3, [r3, #4]
 801ec30:	681b      	ldr	r3, [r3, #0]
 801ec32:	2b00      	cmp	r3, #0
 801ec34:	d006      	beq.n	801ec44 <lv_disp_is_double_buf+0x20>
 801ec36:	687b      	ldr	r3, [r7, #4]
 801ec38:	685b      	ldr	r3, [r3, #4]
 801ec3a:	685b      	ldr	r3, [r3, #4]
 801ec3c:	2b00      	cmp	r3, #0
 801ec3e:	d001      	beq.n	801ec44 <lv_disp_is_double_buf+0x20>
        return true;
 801ec40:	2301      	movs	r3, #1
 801ec42:	e000      	b.n	801ec46 <lv_disp_is_double_buf+0x22>
    else
        return false;
 801ec44:	2300      	movs	r3, #0
}
 801ec46:	4618      	mov	r0, r3
 801ec48:	370c      	adds	r7, #12
 801ec4a:	46bd      	mov	sp, r7
 801ec4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ec50:	4770      	bx	lr

0801ec52 <lv_disp_is_true_double_buf>:
 * `size` is screen sized)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_true_double_buf(lv_disp_t * disp)
{
 801ec52:	b580      	push	{r7, lr}
 801ec54:	b084      	sub	sp, #16
 801ec56:	af00      	add	r7, sp, #0
 801ec58:	6078      	str	r0, [r7, #4]
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;
 801ec5a:	687b      	ldr	r3, [r7, #4]
 801ec5c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ec60:	461a      	mov	r2, r3
 801ec62:	687b      	ldr	r3, [r7, #4]
 801ec64:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801ec68:	fb02 f303 	mul.w	r3, r2, r3
 801ec6c:	60fb      	str	r3, [r7, #12]

    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
 801ec6e:	6878      	ldr	r0, [r7, #4]
 801ec70:	f7ff ffd8 	bl	801ec24 <lv_disp_is_double_buf>
 801ec74:	4603      	mov	r3, r0
 801ec76:	2b00      	cmp	r3, #0
 801ec78:	d007      	beq.n	801ec8a <lv_disp_is_true_double_buf+0x38>
 801ec7a:	687b      	ldr	r3, [r7, #4]
 801ec7c:	685b      	ldr	r3, [r3, #4]
 801ec7e:	68db      	ldr	r3, [r3, #12]
 801ec80:	68fa      	ldr	r2, [r7, #12]
 801ec82:	429a      	cmp	r2, r3
 801ec84:	d101      	bne.n	801ec8a <lv_disp_is_true_double_buf+0x38>
        return true;
 801ec86:	2301      	movs	r3, #1
 801ec88:	e000      	b.n	801ec8c <lv_disp_is_true_double_buf+0x3a>
    }
    else {
        return false;
 801ec8a:	2300      	movs	r3, #0
    }
}
 801ec8c:	4618      	mov	r0, r3
 801ec8e:	3710      	adds	r7, #16
 801ec90:	46bd      	mov	sp, r7
 801ec92:	bd80      	pop	{r7, pc}

0801ec94 <lv_indev_get_next>:
 * @param indev pointer to the current input device. NULL to initialize.
 * @return the next input devise or NULL if no more. Give the first input device when the parameter
 * is NULL
 */
lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
{
 801ec94:	b580      	push	{r7, lr}
 801ec96:	b082      	sub	sp, #8
 801ec98:	af00      	add	r7, sp, #0
 801ec9a:	6078      	str	r0, [r7, #4]
    if(indev == NULL)
 801ec9c:	687b      	ldr	r3, [r7, #4]
 801ec9e:	2b00      	cmp	r3, #0
 801eca0:	d104      	bne.n	801ecac <lv_indev_get_next+0x18>
        return _lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
 801eca2:	4807      	ldr	r0, [pc, #28]	; (801ecc0 <lv_indev_get_next+0x2c>)
 801eca4:	f001 fdda 	bl	802085c <_lv_ll_get_head>
 801eca8:	4603      	mov	r3, r0
 801ecaa:	e004      	b.n	801ecb6 <lv_indev_get_next+0x22>
    else
        return _lv_ll_get_next(&LV_GC_ROOT(_lv_indev_ll), indev);
 801ecac:	6879      	ldr	r1, [r7, #4]
 801ecae:	4804      	ldr	r0, [pc, #16]	; (801ecc0 <lv_indev_get_next+0x2c>)
 801ecb0:	f001 fdfa 	bl	80208a8 <_lv_ll_get_next>
 801ecb4:	4603      	mov	r3, r0
}
 801ecb6:	4618      	mov	r0, r3
 801ecb8:	3708      	adds	r7, #8
 801ecba:	46bd      	mov	sp, r7
 801ecbc:	bd80      	pop	{r7, pc}
 801ecbe:	bf00      	nop
 801ecc0:	2000a18c 	.word	0x2000a18c

0801ecc4 <lv_tick_inc>:
/**
 * You have to call this function periodically
 * @param tick_period the call period of this function in milliseconds
 */
LV_ATTRIBUTE_TICK_INC void lv_tick_inc(uint32_t tick_period)
{
 801ecc4:	b480      	push	{r7}
 801ecc6:	b083      	sub	sp, #12
 801ecc8:	af00      	add	r7, sp, #0
 801ecca:	6078      	str	r0, [r7, #4]
    tick_irq_flag = 0;
 801eccc:	4b07      	ldr	r3, [pc, #28]	; (801ecec <lv_tick_inc+0x28>)
 801ecce:	2200      	movs	r2, #0
 801ecd0:	701a      	strb	r2, [r3, #0]
    sys_time += tick_period;
 801ecd2:	4b07      	ldr	r3, [pc, #28]	; (801ecf0 <lv_tick_inc+0x2c>)
 801ecd4:	681a      	ldr	r2, [r3, #0]
 801ecd6:	687b      	ldr	r3, [r7, #4]
 801ecd8:	4413      	add	r3, r2
 801ecda:	4a05      	ldr	r2, [pc, #20]	; (801ecf0 <lv_tick_inc+0x2c>)
 801ecdc:	6013      	str	r3, [r2, #0]
}
 801ecde:	bf00      	nop
 801ece0:	370c      	adds	r7, #12
 801ece2:	46bd      	mov	sp, r7
 801ece4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ece8:	4770      	bx	lr
 801ecea:	bf00      	nop
 801ecec:	2000a164 	.word	0x2000a164
 801ecf0:	2000a160 	.word	0x2000a160

0801ecf4 <lv_tick_get>:
/**
 * Get the elapsed milliseconds since start up
 * @return the elapsed milliseconds
 */
uint32_t lv_tick_get(void)
{
 801ecf4:	b480      	push	{r7}
 801ecf6:	b083      	sub	sp, #12
 801ecf8:	af00      	add	r7, sp, #0
     * This loop detects if `lv_tick_inc` was called while reading `sys_time`.
     * If `tick_irq_flag` was cleared in `lv_tick_inc` try to read again
     * until `tick_irq_flag` remains `1`. */
    uint32_t result;
    do {
        tick_irq_flag = 1;
 801ecfa:	4b09      	ldr	r3, [pc, #36]	; (801ed20 <lv_tick_get+0x2c>)
 801ecfc:	2201      	movs	r2, #1
 801ecfe:	701a      	strb	r2, [r3, #0]
        result        = sys_time;
 801ed00:	4b08      	ldr	r3, [pc, #32]	; (801ed24 <lv_tick_get+0x30>)
 801ed02:	681b      	ldr	r3, [r3, #0]
 801ed04:	607b      	str	r3, [r7, #4]
    } while(!tick_irq_flag); /*Continue until see a non interrupted cycle */
 801ed06:	4b06      	ldr	r3, [pc, #24]	; (801ed20 <lv_tick_get+0x2c>)
 801ed08:	781b      	ldrb	r3, [r3, #0]
 801ed0a:	b2db      	uxtb	r3, r3
 801ed0c:	2b00      	cmp	r3, #0
 801ed0e:	d0f4      	beq.n	801ecfa <lv_tick_get+0x6>

    return result;
 801ed10:	687b      	ldr	r3, [r7, #4]
#else
    return LV_TICK_CUSTOM_SYS_TIME_EXPR;
#endif
}
 801ed12:	4618      	mov	r0, r3
 801ed14:	370c      	adds	r7, #12
 801ed16:	46bd      	mov	sp, r7
 801ed18:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ed1c:	4770      	bx	lr
 801ed1e:	bf00      	nop
 801ed20:	2000a164 	.word	0x2000a164
 801ed24:	2000a160 	.word	0x2000a160

0801ed28 <lv_tick_elaps>:
 * Get the elapsed milliseconds since a previous time stamp
 * @param prev_tick a previous time stamp (return value of systick_get() )
 * @return the elapsed milliseconds since 'prev_tick'
 */
uint32_t lv_tick_elaps(uint32_t prev_tick)
{
 801ed28:	b580      	push	{r7, lr}
 801ed2a:	b084      	sub	sp, #16
 801ed2c:	af00      	add	r7, sp, #0
 801ed2e:	6078      	str	r0, [r7, #4]
    uint32_t act_time = lv_tick_get();
 801ed30:	f7ff ffe0 	bl	801ecf4 <lv_tick_get>
 801ed34:	60f8      	str	r0, [r7, #12]

    /*If there is no overflow in sys_time simple subtract*/
    if(act_time >= prev_tick) {
 801ed36:	68fa      	ldr	r2, [r7, #12]
 801ed38:	687b      	ldr	r3, [r7, #4]
 801ed3a:	429a      	cmp	r2, r3
 801ed3c:	d304      	bcc.n	801ed48 <lv_tick_elaps+0x20>
        prev_tick = act_time - prev_tick;
 801ed3e:	68fa      	ldr	r2, [r7, #12]
 801ed40:	687b      	ldr	r3, [r7, #4]
 801ed42:	1ad3      	subs	r3, r2, r3
 801ed44:	607b      	str	r3, [r7, #4]
 801ed46:	e006      	b.n	801ed56 <lv_tick_elaps+0x2e>
    }
    else {
        prev_tick = UINT32_MAX - prev_tick + 1;
 801ed48:	687b      	ldr	r3, [r7, #4]
 801ed4a:	425b      	negs	r3, r3
 801ed4c:	607b      	str	r3, [r7, #4]
        prev_tick += act_time;
 801ed4e:	687a      	ldr	r2, [r7, #4]
 801ed50:	68fb      	ldr	r3, [r7, #12]
 801ed52:	4413      	add	r3, r2
 801ed54:	607b      	str	r3, [r7, #4]
    }

    return prev_tick;
 801ed56:	687b      	ldr	r3, [r7, #4]
}
 801ed58:	4618      	mov	r0, r3
 801ed5a:	3710      	adds	r7, #16
 801ed5c:	46bd      	mov	sp, r7
 801ed5e:	bd80      	pop	{r7, pc}

0801ed60 <_lv_memcpy_small>:
 * @param dst pointer to the destination buffer
 * @param src pointer to the source buffer
 * @param len number of byte to copy
 */
LV_ATTRIBUTE_FAST_MEM static inline void * _lv_memcpy_small(void * dst, const void * src, size_t len)
{
 801ed60:	b480      	push	{r7}
 801ed62:	b087      	sub	sp, #28
 801ed64:	af00      	add	r7, sp, #0
 801ed66:	60f8      	str	r0, [r7, #12]
 801ed68:	60b9      	str	r1, [r7, #8]
 801ed6a:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 801ed6c:	68fb      	ldr	r3, [r7, #12]
 801ed6e:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 801ed70:	68bb      	ldr	r3, [r7, #8]
 801ed72:	613b      	str	r3, [r7, #16]

    while(len) {
 801ed74:	e00c      	b.n	801ed90 <_lv_memcpy_small+0x30>
        *d8 = *s8;
 801ed76:	693b      	ldr	r3, [r7, #16]
 801ed78:	781a      	ldrb	r2, [r3, #0]
 801ed7a:	697b      	ldr	r3, [r7, #20]
 801ed7c:	701a      	strb	r2, [r3, #0]
        d8++;
 801ed7e:	697b      	ldr	r3, [r7, #20]
 801ed80:	3301      	adds	r3, #1
 801ed82:	617b      	str	r3, [r7, #20]
        s8++;
 801ed84:	693b      	ldr	r3, [r7, #16]
 801ed86:	3301      	adds	r3, #1
 801ed88:	613b      	str	r3, [r7, #16]
        len--;
 801ed8a:	687b      	ldr	r3, [r7, #4]
 801ed8c:	3b01      	subs	r3, #1
 801ed8e:	607b      	str	r3, [r7, #4]
    while(len) {
 801ed90:	687b      	ldr	r3, [r7, #4]
 801ed92:	2b00      	cmp	r3, #0
 801ed94:	d1ef      	bne.n	801ed76 <_lv_memcpy_small+0x16>
    }

    return dst;
 801ed96:	68fb      	ldr	r3, [r7, #12]
}
 801ed98:	4618      	mov	r0, r3
 801ed9a:	371c      	adds	r7, #28
 801ed9c:	46bd      	mov	sp, r7
 801ed9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eda2:	4770      	bx	lr

0801eda4 <_lv_anim_core_init>:

/**
 * Init. the animation module
 */
void _lv_anim_core_init(void)
{
 801eda4:	b580      	push	{r7, lr}
 801eda6:	af00      	add	r7, sp, #0
    _lv_ll_init(&LV_GC_ROOT(_lv_anim_ll), sizeof(lv_anim_t));
 801eda8:	2144      	movs	r1, #68	; 0x44
 801edaa:	480c      	ldr	r0, [pc, #48]	; (801eddc <_lv_anim_core_init+0x38>)
 801edac:	f001 fbe0 	bl	8020570 <_lv_ll_init>
    last_task_run = lv_tick_get();
 801edb0:	f7ff ffa0 	bl	801ecf4 <lv_tick_get>
 801edb4:	4603      	mov	r3, r0
 801edb6:	4a0a      	ldr	r2, [pc, #40]	; (801ede0 <_lv_anim_core_init+0x3c>)
 801edb8:	6013      	str	r3, [r2, #0]
    _lv_anim_task = lv_task_create(anim_task, LV_DISP_DEF_REFR_PERIOD, LV_ANIM_TASK_PRIO, NULL);
 801edba:	2300      	movs	r3, #0
 801edbc:	2204      	movs	r2, #4
 801edbe:	211e      	movs	r1, #30
 801edc0:	4808      	ldr	r0, [pc, #32]	; (801ede4 <_lv_anim_core_init+0x40>)
 801edc2:	f003 f813 	bl	8021dec <lv_task_create>
 801edc6:	4603      	mov	r3, r0
 801edc8:	4a07      	ldr	r2, [pc, #28]	; (801ede8 <_lv_anim_core_init+0x44>)
 801edca:	6013      	str	r3, [r2, #0]
    anim_mark_list_change(); /*Turn off the animation task*/
 801edcc:	f000 faa8 	bl	801f320 <anim_mark_list_change>
    anim_list_changed = false; /*The list has not actually changed*/
 801edd0:	4b06      	ldr	r3, [pc, #24]	; (801edec <_lv_anim_core_init+0x48>)
 801edd2:	2200      	movs	r2, #0
 801edd4:	701a      	strb	r2, [r3, #0]
}
 801edd6:	bf00      	nop
 801edd8:	bd80      	pop	{r7, pc}
 801edda:	bf00      	nop
 801eddc:	2000a1a4 	.word	0x2000a1a4
 801ede0:	2000a168 	.word	0x2000a168
 801ede4:	0801f089 	.word	0x0801f089
 801ede8:	2000a170 	.word	0x2000a170
 801edec:	2000a16c 	.word	0x2000a16c

0801edf0 <lv_anim_init>:
 * lv_anim_init(&a);
 * lv_anim_set_...(&a);
 * @param a pointer to an `lv_anim_t` variable to initialize
 */
void lv_anim_init(lv_anim_t * a)
{
 801edf0:	b580      	push	{r7, lr}
 801edf2:	b082      	sub	sp, #8
 801edf4:	af00      	add	r7, sp, #0
 801edf6:	6078      	str	r0, [r7, #4]
    _lv_memset_00(a, sizeof(lv_anim_t));
 801edf8:	2144      	movs	r1, #68	; 0x44
 801edfa:	6878      	ldr	r0, [r7, #4]
 801edfc:	f002 fc54 	bl	80216a8 <_lv_memset_00>
    a->time    = 500;
 801ee00:	687b      	ldr	r3, [r7, #4]
 801ee02:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 801ee06:	625a      	str	r2, [r3, #36]	; 0x24
    a->start   = 0;
 801ee08:	687b      	ldr	r3, [r7, #4]
 801ee0a:	2200      	movs	r2, #0
 801ee0c:	619a      	str	r2, [r3, #24]
    a->end     = 100;
 801ee0e:	687b      	ldr	r3, [r7, #4]
 801ee10:	2264      	movs	r2, #100	; 0x64
 801ee12:	621a      	str	r2, [r3, #32]
    _lv_memcpy_small(&a->path, &lv_anim_path_def, sizeof(lv_anim_path_cb_t));
 801ee14:	687b      	ldr	r3, [r7, #4]
 801ee16:	3310      	adds	r3, #16
 801ee18:	2204      	movs	r2, #4
 801ee1a:	4909      	ldr	r1, [pc, #36]	; (801ee40 <lv_anim_init+0x50>)
 801ee1c:	4618      	mov	r0, r3
 801ee1e:	f7ff ff9f 	bl	801ed60 <_lv_memcpy_small>
    a->repeat_cnt = 1;
 801ee22:	687b      	ldr	r3, [r7, #4]
 801ee24:	2201      	movs	r2, #1
 801ee26:	871a      	strh	r2, [r3, #56]	; 0x38
    a->early_apply = 1;
 801ee28:	687a      	ldr	r2, [r7, #4]
 801ee2a:	f892 303a 	ldrb.w	r3, [r2, #58]	; 0x3a
 801ee2e:	f043 0301 	orr.w	r3, r3, #1
 801ee32:	f882 303a 	strb.w	r3, [r2, #58]	; 0x3a
}
 801ee36:	bf00      	nop
 801ee38:	3708      	adds	r7, #8
 801ee3a:	46bd      	mov	sp, r7
 801ee3c:	bd80      	pop	{r7, pc}
 801ee3e:	bf00      	nop
 801ee40:	080f2308 	.word	0x080f2308

0801ee44 <lv_anim_start>:
/**
 * Create an animation
 * @param a an initialized 'anim_t' variable. Not required after call.
 */
void lv_anim_start(lv_anim_t * a)
{
 801ee44:	b5b0      	push	{r4, r5, r7, lr}
 801ee46:	b084      	sub	sp, #16
 801ee48:	af00      	add	r7, sp, #0
 801ee4a:	6078      	str	r0, [r7, #4]
    LV_LOG_TRACE("animation create started")
    /* Do not let two animations for the  same 'var' with the same 'fp'*/
    if(a->exec_cb != NULL) lv_anim_del(a->var, a->exec_cb); /*fp == NULL would delete all animations of var*/
 801ee4c:	687b      	ldr	r3, [r7, #4]
 801ee4e:	685b      	ldr	r3, [r3, #4]
 801ee50:	2b00      	cmp	r3, #0
 801ee52:	d007      	beq.n	801ee64 <lv_anim_start+0x20>
 801ee54:	687b      	ldr	r3, [r7, #4]
 801ee56:	681a      	ldr	r2, [r3, #0]
 801ee58:	687b      	ldr	r3, [r7, #4]
 801ee5a:	685b      	ldr	r3, [r3, #4]
 801ee5c:	4619      	mov	r1, r3
 801ee5e:	4610      	mov	r0, r2
 801ee60:	f000 f856 	bl	801ef10 <lv_anim_del>

    /*If the list is empty the anim task was suspended and it's last run measure is invalid*/
    if(_lv_ll_is_empty(&LV_GC_ROOT(_lv_anim_ll))) {
 801ee64:	4827      	ldr	r0, [pc, #156]	; (801ef04 <lv_anim_start+0xc0>)
 801ee66:	f001 fd98 	bl	802099a <_lv_ll_is_empty>
 801ee6a:	4603      	mov	r3, r0
 801ee6c:	2b00      	cmp	r3, #0
 801ee6e:	d005      	beq.n	801ee7c <lv_anim_start+0x38>
        last_task_run = lv_tick_get() - 1;
 801ee70:	f7ff ff40 	bl	801ecf4 <lv_tick_get>
 801ee74:	4603      	mov	r3, r0
 801ee76:	3b01      	subs	r3, #1
 801ee78:	4a23      	ldr	r2, [pc, #140]	; (801ef08 <lv_anim_start+0xc4>)
 801ee7a:	6013      	str	r3, [r2, #0]
    }

    /*Add the new animation to the animation linked list*/
    lv_anim_t * new_anim = _lv_ll_ins_head(&LV_GC_ROOT(_lv_anim_ll));
 801ee7c:	4821      	ldr	r0, [pc, #132]	; (801ef04 <lv_anim_start+0xc0>)
 801ee7e:	f001 fb90 	bl	80205a2 <_lv_ll_ins_head>
 801ee82:	60f8      	str	r0, [r7, #12]
    LV_ASSERT_MEM(new_anim);
 801ee84:	68f8      	ldr	r0, [r7, #12]
 801ee86:	f001 f933 	bl	80200f0 <lv_debug_check_null>
 801ee8a:	4603      	mov	r3, r0
 801ee8c:	f083 0301 	eor.w	r3, r3, #1
 801ee90:	b2db      	uxtb	r3, r3
 801ee92:	2b00      	cmp	r3, #0
 801ee94:	d009      	beq.n	801eeaa <lv_anim_start+0x66>
 801ee96:	68fb      	ldr	r3, [r7, #12]
 801ee98:	2200      	movs	r2, #0
 801ee9a:	461c      	mov	r4, r3
 801ee9c:	4615      	mov	r5, r2
 801ee9e:	4622      	mov	r2, r4
 801eea0:	462b      	mov	r3, r5
 801eea2:	481a      	ldr	r0, [pc, #104]	; (801ef0c <lv_anim_start+0xc8>)
 801eea4:	f001 f934 	bl	8020110 <lv_debug_log_error>
 801eea8:	e7fe      	b.n	801eea8 <lv_anim_start+0x64>
    if(new_anim == NULL) return;
 801eeaa:	68fb      	ldr	r3, [r7, #12]
 801eeac:	2b00      	cmp	r3, #0
 801eeae:	d025      	beq.n	801eefc <lv_anim_start+0xb8>

    /*Initialize the animation descriptor*/
    a->time_orig = a->time;
 801eeb0:	687b      	ldr	r3, [r7, #4]
 801eeb2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801eeb4:	461a      	mov	r2, r3
 801eeb6:	687b      	ldr	r3, [r7, #4]
 801eeb8:	63da      	str	r2, [r3, #60]	; 0x3c
    _lv_memcpy(new_anim, a, sizeof(lv_anim_t));
 801eeba:	2244      	movs	r2, #68	; 0x44
 801eebc:	6879      	ldr	r1, [r7, #4]
 801eebe:	68f8      	ldr	r0, [r7, #12]
 801eec0:	f002 f94c 	bl	802115c <_lv_memcpy>

    /*Set the start value*/
    if(new_anim->early_apply) {
 801eec4:	68fb      	ldr	r3, [r7, #12]
 801eec6:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
 801eeca:	f003 0301 	and.w	r3, r3, #1
 801eece:	b2db      	uxtb	r3, r3
 801eed0:	2b00      	cmp	r3, #0
 801eed2:	d010      	beq.n	801eef6 <lv_anim_start+0xb2>
        if(new_anim->exec_cb && new_anim->var) new_anim->exec_cb(new_anim->var, new_anim->start);
 801eed4:	68fb      	ldr	r3, [r7, #12]
 801eed6:	685b      	ldr	r3, [r3, #4]
 801eed8:	2b00      	cmp	r3, #0
 801eeda:	d00c      	beq.n	801eef6 <lv_anim_start+0xb2>
 801eedc:	68fb      	ldr	r3, [r7, #12]
 801eede:	681b      	ldr	r3, [r3, #0]
 801eee0:	2b00      	cmp	r3, #0
 801eee2:	d008      	beq.n	801eef6 <lv_anim_start+0xb2>
 801eee4:	68fb      	ldr	r3, [r7, #12]
 801eee6:	685b      	ldr	r3, [r3, #4]
 801eee8:	68fa      	ldr	r2, [r7, #12]
 801eeea:	6810      	ldr	r0, [r2, #0]
 801eeec:	68fa      	ldr	r2, [r7, #12]
 801eeee:	6992      	ldr	r2, [r2, #24]
 801eef0:	b212      	sxth	r2, r2
 801eef2:	4611      	mov	r1, r2
 801eef4:	4798      	blx	r3
    }

    /* Creating an animation changed the linked list.
     * It's important if it happens in a ready callback. (see `anim_task`)*/
    anim_mark_list_change();
 801eef6:	f000 fa13 	bl	801f320 <anim_mark_list_change>
 801eefa:	e000      	b.n	801eefe <lv_anim_start+0xba>
    if(new_anim == NULL) return;
 801eefc:	bf00      	nop

    LV_LOG_TRACE("animation created")
}
 801eefe:	3710      	adds	r7, #16
 801ef00:	46bd      	mov	sp, r7
 801ef02:	bdb0      	pop	{r4, r5, r7, pc}
 801ef04:	2000a1a4 	.word	0x2000a1a4
 801ef08:	2000a168 	.word	0x2000a168
 801ef0c:	0802e4d0 	.word	0x0802e4d0

0801ef10 <lv_anim_del>:
 * @param exec_cb a function pointer which is animating 'var',
 *           or NULL to delete all the animations of 'var'
 * @return true: at least 1 animation is deleted, false: no animation is deleted
 */
bool lv_anim_del(void * var, lv_anim_exec_xcb_t exec_cb)
{
 801ef10:	b580      	push	{r7, lr}
 801ef12:	b086      	sub	sp, #24
 801ef14:	af00      	add	r7, sp, #0
 801ef16:	6078      	str	r0, [r7, #4]
 801ef18:	6039      	str	r1, [r7, #0]
    lv_anim_t * a;
    lv_anim_t * a_next;
    bool del = false;
 801ef1a:	2300      	movs	r3, #0
 801ef1c:	74fb      	strb	r3, [r7, #19]
    a        = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 801ef1e:	4816      	ldr	r0, [pc, #88]	; (801ef78 <lv_anim_del+0x68>)
 801ef20:	f001 fc9c 	bl	802085c <_lv_ll_get_head>
 801ef24:	6178      	str	r0, [r7, #20]
    while(a != NULL) {
 801ef26:	e01e      	b.n	801ef66 <lv_anim_del+0x56>
        /*'a' might be deleted, so get the next object while 'a' is valid*/
        a_next = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
 801ef28:	6979      	ldr	r1, [r7, #20]
 801ef2a:	4813      	ldr	r0, [pc, #76]	; (801ef78 <lv_anim_del+0x68>)
 801ef2c:	f001 fcbc 	bl	80208a8 <_lv_ll_get_next>
 801ef30:	60f8      	str	r0, [r7, #12]

        if(a->var == var && (a->exec_cb == exec_cb || exec_cb == NULL)) {
 801ef32:	697b      	ldr	r3, [r7, #20]
 801ef34:	681b      	ldr	r3, [r3, #0]
 801ef36:	687a      	ldr	r2, [r7, #4]
 801ef38:	429a      	cmp	r2, r3
 801ef3a:	d112      	bne.n	801ef62 <lv_anim_del+0x52>
 801ef3c:	697b      	ldr	r3, [r7, #20]
 801ef3e:	685b      	ldr	r3, [r3, #4]
 801ef40:	683a      	ldr	r2, [r7, #0]
 801ef42:	429a      	cmp	r2, r3
 801ef44:	d002      	beq.n	801ef4c <lv_anim_del+0x3c>
 801ef46:	683b      	ldr	r3, [r7, #0]
 801ef48:	2b00      	cmp	r3, #0
 801ef4a:	d10a      	bne.n	801ef62 <lv_anim_del+0x52>
            _lv_ll_remove(&LV_GC_ROOT(_lv_anim_ll), a);
 801ef4c:	6979      	ldr	r1, [r7, #20]
 801ef4e:	480a      	ldr	r0, [pc, #40]	; (801ef78 <lv_anim_del+0x68>)
 801ef50:	f001 fbd6 	bl	8020700 <_lv_ll_remove>
            lv_mem_free(a);
 801ef54:	6978      	ldr	r0, [r7, #20]
 801ef56:	f001 fe87 	bl	8020c68 <lv_mem_free>
            anim_mark_list_change(); /*Read by `anim_task`. It need to know if a delete occurred in
 801ef5a:	f000 f9e1 	bl	801f320 <anim_mark_list_change>
                                         the linked list*/
            del = true;
 801ef5e:	2301      	movs	r3, #1
 801ef60:	74fb      	strb	r3, [r7, #19]
        }

        a = a_next;
 801ef62:	68fb      	ldr	r3, [r7, #12]
 801ef64:	617b      	str	r3, [r7, #20]
    while(a != NULL) {
 801ef66:	697b      	ldr	r3, [r7, #20]
 801ef68:	2b00      	cmp	r3, #0
 801ef6a:	d1dd      	bne.n	801ef28 <lv_anim_del+0x18>
    }

    return del;
 801ef6c:	7cfb      	ldrb	r3, [r7, #19]
}
 801ef6e:	4618      	mov	r0, r3
 801ef70:	3718      	adds	r7, #24
 801ef72:	46bd      	mov	sp, r7
 801ef74:	bd80      	pop	{r7, pc}
 801ef76:	bf00      	nop
 801ef78:	2000a1a4 	.word	0x2000a1a4

0801ef7c <lv_anim_get>:
 * @param exec_cb a function pointer which is animating 'var',
 *           or NULL to delete all the animations of 'var'
 * @return pointer to the animation.
 */
lv_anim_t * lv_anim_get(void * var, lv_anim_exec_xcb_t exec_cb)
{
 801ef7c:	b580      	push	{r7, lr}
 801ef7e:	b084      	sub	sp, #16
 801ef80:	af00      	add	r7, sp, #0
 801ef82:	6078      	str	r0, [r7, #4]
 801ef84:	6039      	str	r1, [r7, #0]
    lv_anim_t * a;
    _LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a) {
 801ef86:	480f      	ldr	r0, [pc, #60]	; (801efc4 <lv_anim_get+0x48>)
 801ef88:	f001 fc68 	bl	802085c <_lv_ll_get_head>
 801ef8c:	60f8      	str	r0, [r7, #12]
 801ef8e:	e010      	b.n	801efb2 <lv_anim_get+0x36>
        if(a->var == var && a->exec_cb == exec_cb) {
 801ef90:	68fb      	ldr	r3, [r7, #12]
 801ef92:	681b      	ldr	r3, [r3, #0]
 801ef94:	687a      	ldr	r2, [r7, #4]
 801ef96:	429a      	cmp	r2, r3
 801ef98:	d106      	bne.n	801efa8 <lv_anim_get+0x2c>
 801ef9a:	68fb      	ldr	r3, [r7, #12]
 801ef9c:	685b      	ldr	r3, [r3, #4]
 801ef9e:	683a      	ldr	r2, [r7, #0]
 801efa0:	429a      	cmp	r2, r3
 801efa2:	d101      	bne.n	801efa8 <lv_anim_get+0x2c>
            return a;
 801efa4:	68fb      	ldr	r3, [r7, #12]
 801efa6:	e008      	b.n	801efba <lv_anim_get+0x3e>
    _LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a) {
 801efa8:	68f9      	ldr	r1, [r7, #12]
 801efaa:	4806      	ldr	r0, [pc, #24]	; (801efc4 <lv_anim_get+0x48>)
 801efac:	f001 fc7c 	bl	80208a8 <_lv_ll_get_next>
 801efb0:	60f8      	str	r0, [r7, #12]
 801efb2:	68fb      	ldr	r3, [r7, #12]
 801efb4:	2b00      	cmp	r3, #0
 801efb6:	d1eb      	bne.n	801ef90 <lv_anim_get+0x14>
        }
    }

    return NULL;
 801efb8:	2300      	movs	r3, #0
}
 801efba:	4618      	mov	r0, r3
 801efbc:	3710      	adds	r7, #16
 801efbe:	46bd      	mov	sp, r7
 801efc0:	bd80      	pop	{r7, pc}
 801efc2:	bf00      	nop
 801efc4:	2000a1a4 	.word	0x2000a1a4

0801efc8 <lv_anim_speed_to_time>:
 * @param start start value of the animation
 * @param end end value of the animation
 * @return the required time [ms] for the animation with the given parameters
 */
uint16_t lv_anim_speed_to_time(uint16_t speed, lv_anim_value_t start, lv_anim_value_t end)
{
 801efc8:	b480      	push	{r7}
 801efca:	b085      	sub	sp, #20
 801efcc:	af00      	add	r7, sp, #0
 801efce:	4603      	mov	r3, r0
 801efd0:	80fb      	strh	r3, [r7, #6]
 801efd2:	460b      	mov	r3, r1
 801efd4:	80bb      	strh	r3, [r7, #4]
 801efd6:	4613      	mov	r3, r2
 801efd8:	807b      	strh	r3, [r7, #2]
    int32_t d     = LV_MATH_ABS((int32_t)start - end);
 801efda:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801efde:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801efe2:	1ad3      	subs	r3, r2, r3
 801efe4:	2b00      	cmp	r3, #0
 801efe6:	bfb8      	it	lt
 801efe8:	425b      	neglt	r3, r3
 801efea:	60bb      	str	r3, [r7, #8]
    uint32_t time = (int32_t)((int32_t)(d * 1000) / speed);
 801efec:	68bb      	ldr	r3, [r7, #8]
 801efee:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801eff2:	fb03 f202 	mul.w	r2, r3, r2
 801eff6:	88fb      	ldrh	r3, [r7, #6]
 801eff8:	fb92 f3f3 	sdiv	r3, r2, r3
 801effc:	60fb      	str	r3, [r7, #12]

    if(time > UINT16_MAX) time = UINT16_MAX;
 801effe:	68fb      	ldr	r3, [r7, #12]
 801f000:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 801f004:	d302      	bcc.n	801f00c <lv_anim_speed_to_time+0x44>
 801f006:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801f00a:	60fb      	str	r3, [r7, #12]

    if(time == 0) {
 801f00c:	68fb      	ldr	r3, [r7, #12]
 801f00e:	2b00      	cmp	r3, #0
 801f010:	d102      	bne.n	801f018 <lv_anim_speed_to_time+0x50>
        time++;
 801f012:	68fb      	ldr	r3, [r7, #12]
 801f014:	3301      	adds	r3, #1
 801f016:	60fb      	str	r3, [r7, #12]
    }

    return time;
 801f018:	68fb      	ldr	r3, [r7, #12]
 801f01a:	b29b      	uxth	r3, r3
}
 801f01c:	4618      	mov	r0, r3
 801f01e:	3714      	adds	r7, #20
 801f020:	46bd      	mov	sp, r7
 801f022:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f026:	4770      	bx	lr

0801f028 <lv_anim_path_linear>:
 * Calculate the current value of an animation applying linear characteristic
 * @param a pointer to an animation
 * @return the current value to set
 */
lv_anim_value_t lv_anim_path_linear(const lv_anim_path_t * path, const lv_anim_t * a)
{
 801f028:	b480      	push	{r7}
 801f02a:	b085      	sub	sp, #20
 801f02c:	af00      	add	r7, sp, #0
 801f02e:	6078      	str	r0, [r7, #4]
 801f030:	6039      	str	r1, [r7, #0]
    LV_UNUSED(path);

    /*Calculate the current step*/
    uint32_t step;
    if(a->time == a->act_time) {
 801f032:	683b      	ldr	r3, [r7, #0]
 801f034:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801f036:	683b      	ldr	r3, [r7, #0]
 801f038:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f03a:	429a      	cmp	r2, r3
 801f03c:	d103      	bne.n	801f046 <lv_anim_path_linear+0x1e>
        step = LV_ANIM_RESOLUTION; /*Use the last value if the time fully elapsed*/
 801f03e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801f042:	60fb      	str	r3, [r7, #12]
 801f044:	e007      	b.n	801f056 <lv_anim_path_linear+0x2e>
    }
    else {
        step = ((int32_t)a->act_time * LV_ANIM_RESOLUTION) / a->time;
 801f046:	683b      	ldr	r3, [r7, #0]
 801f048:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f04a:	029a      	lsls	r2, r3, #10
 801f04c:	683b      	ldr	r3, [r7, #0]
 801f04e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801f050:	fb92 f3f3 	sdiv	r3, r2, r3
 801f054:	60fb      	str	r3, [r7, #12]
    }

    /* Get the new value which will be proportional to `step`
     * and the `start` and `end` values*/
    int32_t new_value;
    new_value = (int32_t)step * (a->end - a->start);
 801f056:	683b      	ldr	r3, [r7, #0]
 801f058:	6a1a      	ldr	r2, [r3, #32]
 801f05a:	683b      	ldr	r3, [r7, #0]
 801f05c:	699b      	ldr	r3, [r3, #24]
 801f05e:	1ad3      	subs	r3, r2, r3
 801f060:	68fa      	ldr	r2, [r7, #12]
 801f062:	fb02 f303 	mul.w	r3, r2, r3
 801f066:	60bb      	str	r3, [r7, #8]
    new_value = new_value >> LV_ANIM_RES_SHIFT;
 801f068:	68bb      	ldr	r3, [r7, #8]
 801f06a:	129b      	asrs	r3, r3, #10
 801f06c:	60bb      	str	r3, [r7, #8]
    new_value += a->start;
 801f06e:	683b      	ldr	r3, [r7, #0]
 801f070:	699b      	ldr	r3, [r3, #24]
 801f072:	68ba      	ldr	r2, [r7, #8]
 801f074:	4413      	add	r3, r2
 801f076:	60bb      	str	r3, [r7, #8]

    return (lv_anim_value_t)new_value;
 801f078:	68bb      	ldr	r3, [r7, #8]
 801f07a:	b21b      	sxth	r3, r3
}
 801f07c:	4618      	mov	r0, r3
 801f07e:	3714      	adds	r7, #20
 801f080:	46bd      	mov	sp, r7
 801f082:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f086:	4770      	bx	lr

0801f088 <anim_task>:
/**
 * Periodically handle the animations.
 * @param param unused
 */
static void anim_task(lv_task_t * param)
{
 801f088:	b580      	push	{r7, lr}
 801f08a:	b086      	sub	sp, #24
 801f08c:	af00      	add	r7, sp, #0
 801f08e:	6078      	str	r0, [r7, #4]
    (void)param;

    lv_anim_t * a;
    _LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a) {
 801f090:	4854      	ldr	r0, [pc, #336]	; (801f1e4 <anim_task+0x15c>)
 801f092:	f001 fbe3 	bl	802085c <_lv_ll_get_head>
 801f096:	6178      	str	r0, [r7, #20]
 801f098:	e00b      	b.n	801f0b2 <anim_task+0x2a>
        a->has_run = 0;
 801f09a:	697a      	ldr	r2, [r7, #20]
 801f09c:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 801f0a0:	f36f 0341 	bfc	r3, #1, #1
 801f0a4:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
    _LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a) {
 801f0a8:	6979      	ldr	r1, [r7, #20]
 801f0aa:	484e      	ldr	r0, [pc, #312]	; (801f1e4 <anim_task+0x15c>)
 801f0ac:	f001 fbfc 	bl	80208a8 <_lv_ll_get_next>
 801f0b0:	6178      	str	r0, [r7, #20]
 801f0b2:	697b      	ldr	r3, [r7, #20]
 801f0b4:	2b00      	cmp	r3, #0
 801f0b6:	d1f0      	bne.n	801f09a <anim_task+0x12>
    }

    uint32_t elaps = lv_tick_elaps(last_task_run);
 801f0b8:	4b4b      	ldr	r3, [pc, #300]	; (801f1e8 <anim_task+0x160>)
 801f0ba:	681b      	ldr	r3, [r3, #0]
 801f0bc:	4618      	mov	r0, r3
 801f0be:	f7ff fe33 	bl	801ed28 <lv_tick_elaps>
 801f0c2:	60f8      	str	r0, [r7, #12]

    a = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 801f0c4:	4847      	ldr	r0, [pc, #284]	; (801f1e4 <anim_task+0x15c>)
 801f0c6:	f001 fbc9 	bl	802085c <_lv_ll_get_head>
 801f0ca:	6178      	str	r0, [r7, #20]

    while(a != NULL) {
 801f0cc:	e07d      	b.n	801f1ca <anim_task+0x142>
        /*It can be set by `lv_anim_del()` typically in `end_cb`. If set then an animation delete
         * happened in `anim_ready_handler` which could make this linked list reading corrupt
         * because the list is changed meanwhile
         */
        anim_list_changed = false;
 801f0ce:	4b47      	ldr	r3, [pc, #284]	; (801f1ec <anim_task+0x164>)
 801f0d0:	2200      	movs	r2, #0
 801f0d2:	701a      	strb	r2, [r3, #0]

        if(!a->has_run) {
 801f0d4:	697b      	ldr	r3, [r7, #20]
 801f0d6:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801f0da:	f003 0302 	and.w	r3, r3, #2
 801f0de:	b2db      	uxtb	r3, r3
 801f0e0:	2b00      	cmp	r3, #0
 801f0e2:	d164      	bne.n	801f1ae <anim_task+0x126>
            a->has_run = 1; /*The list readying might be reseted so need to know which anim has run already*/
 801f0e4:	697a      	ldr	r2, [r7, #20]
 801f0e6:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 801f0ea:	f043 0302 	orr.w	r3, r3, #2
 801f0ee:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40

            /*The animation will run now for the first time. Call `start_cb`*/
            int32_t new_act_time = a->act_time + elaps;
 801f0f2:	697b      	ldr	r3, [r7, #20]
 801f0f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f0f6:	461a      	mov	r2, r3
 801f0f8:	68fb      	ldr	r3, [r7, #12]
 801f0fa:	4413      	add	r3, r2
 801f0fc:	60bb      	str	r3, [r7, #8]
            if(a->act_time <= 0 && new_act_time >= 0) {
 801f0fe:	697b      	ldr	r3, [r7, #20]
 801f100:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f102:	2b00      	cmp	r3, #0
 801f104:	dc0a      	bgt.n	801f11c <anim_task+0x94>
 801f106:	68bb      	ldr	r3, [r7, #8]
 801f108:	2b00      	cmp	r3, #0
 801f10a:	db07      	blt.n	801f11c <anim_task+0x94>
                if(a->start_cb) a->start_cb(a);
 801f10c:	697b      	ldr	r3, [r7, #20]
 801f10e:	689b      	ldr	r3, [r3, #8]
 801f110:	2b00      	cmp	r3, #0
 801f112:	d003      	beq.n	801f11c <anim_task+0x94>
 801f114:	697b      	ldr	r3, [r7, #20]
 801f116:	689b      	ldr	r3, [r3, #8]
 801f118:	6978      	ldr	r0, [r7, #20]
 801f11a:	4798      	blx	r3
            }
            a->act_time += elaps;
 801f11c:	697b      	ldr	r3, [r7, #20]
 801f11e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f120:	461a      	mov	r2, r3
 801f122:	68fb      	ldr	r3, [r7, #12]
 801f124:	4413      	add	r3, r2
 801f126:	461a      	mov	r2, r3
 801f128:	697b      	ldr	r3, [r7, #20]
 801f12a:	629a      	str	r2, [r3, #40]	; 0x28
            if(a->act_time >= 0) {
 801f12c:	697b      	ldr	r3, [r7, #20]
 801f12e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801f130:	2b00      	cmp	r3, #0
 801f132:	db3c      	blt.n	801f1ae <anim_task+0x126>
                if(a->act_time > a->time) a->act_time = a->time;
 801f134:	697b      	ldr	r3, [r7, #20]
 801f136:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801f138:	697b      	ldr	r3, [r7, #20]
 801f13a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801f13c:	429a      	cmp	r2, r3
 801f13e:	dd03      	ble.n	801f148 <anim_task+0xc0>
 801f140:	697b      	ldr	r3, [r7, #20]
 801f142:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801f144:	697b      	ldr	r3, [r7, #20]
 801f146:	629a      	str	r2, [r3, #40]	; 0x28

                int32_t new_value;
                if(a->path.cb) new_value = a->path.cb(&a->path, a);
 801f148:	697b      	ldr	r3, [r7, #20]
 801f14a:	691b      	ldr	r3, [r3, #16]
 801f14c:	2b00      	cmp	r3, #0
 801f14e:	d009      	beq.n	801f164 <anim_task+0xdc>
 801f150:	697b      	ldr	r3, [r7, #20]
 801f152:	691b      	ldr	r3, [r3, #16]
 801f154:	697a      	ldr	r2, [r7, #20]
 801f156:	3210      	adds	r2, #16
 801f158:	6979      	ldr	r1, [r7, #20]
 801f15a:	4610      	mov	r0, r2
 801f15c:	4798      	blx	r3
 801f15e:	4603      	mov	r3, r0
 801f160:	613b      	str	r3, [r7, #16]
 801f162:	e007      	b.n	801f174 <anim_task+0xec>
                else new_value = lv_anim_path_linear(&a->path, a);
 801f164:	697b      	ldr	r3, [r7, #20]
 801f166:	3310      	adds	r3, #16
 801f168:	6979      	ldr	r1, [r7, #20]
 801f16a:	4618      	mov	r0, r3
 801f16c:	f7ff ff5c 	bl	801f028 <lv_anim_path_linear>
 801f170:	4603      	mov	r3, r0
 801f172:	613b      	str	r3, [r7, #16]

                if(new_value != a->current) {
 801f174:	697b      	ldr	r3, [r7, #20]
 801f176:	69db      	ldr	r3, [r3, #28]
 801f178:	693a      	ldr	r2, [r7, #16]
 801f17a:	429a      	cmp	r2, r3
 801f17c:	d00e      	beq.n	801f19c <anim_task+0x114>
                    a->current = new_value;
 801f17e:	697b      	ldr	r3, [r7, #20]
 801f180:	693a      	ldr	r2, [r7, #16]
 801f182:	61da      	str	r2, [r3, #28]
                    /*Apply the calculated value*/
                    if(a->exec_cb) a->exec_cb(a->var, new_value);
 801f184:	697b      	ldr	r3, [r7, #20]
 801f186:	685b      	ldr	r3, [r3, #4]
 801f188:	2b00      	cmp	r3, #0
 801f18a:	d007      	beq.n	801f19c <anim_task+0x114>
 801f18c:	697b      	ldr	r3, [r7, #20]
 801f18e:	685b      	ldr	r3, [r3, #4]
 801f190:	697a      	ldr	r2, [r7, #20]
 801f192:	6812      	ldr	r2, [r2, #0]
 801f194:	6939      	ldr	r1, [r7, #16]
 801f196:	b209      	sxth	r1, r1
 801f198:	4610      	mov	r0, r2
 801f19a:	4798      	blx	r3
                }

                /*If the time is elapsed the animation is ready*/
                if(a->act_time >= a->time) {
 801f19c:	697b      	ldr	r3, [r7, #20]
 801f19e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801f1a0:	697b      	ldr	r3, [r7, #20]
 801f1a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801f1a4:	429a      	cmp	r2, r3
 801f1a6:	db02      	blt.n	801f1ae <anim_task+0x126>
                    anim_ready_handler(a);
 801f1a8:	6978      	ldr	r0, [r7, #20]
 801f1aa:	f000 f821 	bl	801f1f0 <anim_ready_handler>
            }
        }

        /* If the linked list changed due to anim. delete then it's not safe to continue
         * the reading of the list from here -> start from the head*/
        if(anim_list_changed)
 801f1ae:	4b0f      	ldr	r3, [pc, #60]	; (801f1ec <anim_task+0x164>)
 801f1b0:	781b      	ldrb	r3, [r3, #0]
 801f1b2:	2b00      	cmp	r3, #0
 801f1b4:	d004      	beq.n	801f1c0 <anim_task+0x138>
            a = _lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 801f1b6:	480b      	ldr	r0, [pc, #44]	; (801f1e4 <anim_task+0x15c>)
 801f1b8:	f001 fb50 	bl	802085c <_lv_ll_get_head>
 801f1bc:	6178      	str	r0, [r7, #20]
 801f1be:	e004      	b.n	801f1ca <anim_task+0x142>
        else
            a = _lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
 801f1c0:	6979      	ldr	r1, [r7, #20]
 801f1c2:	4808      	ldr	r0, [pc, #32]	; (801f1e4 <anim_task+0x15c>)
 801f1c4:	f001 fb70 	bl	80208a8 <_lv_ll_get_next>
 801f1c8:	6178      	str	r0, [r7, #20]
    while(a != NULL) {
 801f1ca:	697b      	ldr	r3, [r7, #20]
 801f1cc:	2b00      	cmp	r3, #0
 801f1ce:	f47f af7e 	bne.w	801f0ce <anim_task+0x46>
    }

    last_task_run = lv_tick_get();
 801f1d2:	f7ff fd8f 	bl	801ecf4 <lv_tick_get>
 801f1d6:	4603      	mov	r3, r0
 801f1d8:	4a03      	ldr	r2, [pc, #12]	; (801f1e8 <anim_task+0x160>)
 801f1da:	6013      	str	r3, [r2, #0]
}
 801f1dc:	bf00      	nop
 801f1de:	3718      	adds	r7, #24
 801f1e0:	46bd      	mov	sp, r7
 801f1e2:	bd80      	pop	{r7, pc}
 801f1e4:	2000a1a4 	.word	0x2000a1a4
 801f1e8:	2000a168 	.word	0x2000a168
 801f1ec:	2000a16c 	.word	0x2000a16c

0801f1f0 <anim_ready_handler>:
 * e.g. repeat, play back, delete etc.
 * @param a pointer to an animation descriptor
 * @return true: animation delete occurred and the `LV_GC_ROOT(_lv_anim_ll)` has changed
 * */
static bool anim_ready_handler(lv_anim_t * a)
{
 801f1f0:	b580      	push	{r7, lr}
 801f1f2:	b094      	sub	sp, #80	; 0x50
 801f1f4:	af00      	add	r7, sp, #0
 801f1f6:	6078      	str	r0, [r7, #4]
    /*In the end of a forward anim decrement repeat cnt.*/
    if(a->playback_now == 0 && a->repeat_cnt > 0 && a->repeat_cnt != LV_ANIM_REPEAT_INFINITE) {
 801f1f8:	687b      	ldr	r3, [r7, #4]
 801f1fa:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801f1fe:	f003 0301 	and.w	r3, r3, #1
 801f202:	b2db      	uxtb	r3, r3
 801f204:	2b00      	cmp	r3, #0
 801f206:	d10f      	bne.n	801f228 <anim_ready_handler+0x38>
 801f208:	687b      	ldr	r3, [r7, #4]
 801f20a:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 801f20c:	2b00      	cmp	r3, #0
 801f20e:	d00b      	beq.n	801f228 <anim_ready_handler+0x38>
 801f210:	687b      	ldr	r3, [r7, #4]
 801f212:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 801f214:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801f218:	4293      	cmp	r3, r2
 801f21a:	d005      	beq.n	801f228 <anim_ready_handler+0x38>
        a->repeat_cnt--;
 801f21c:	687b      	ldr	r3, [r7, #4]
 801f21e:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 801f220:	3b01      	subs	r3, #1
 801f222:	b29a      	uxth	r2, r3
 801f224:	687b      	ldr	r3, [r7, #4]
 801f226:	871a      	strh	r2, [r3, #56]	; 0x38
    }

    /*Delete the animation if
     * - no repeat left and no play back (simple one shot animation)
     * - no repeat, play back is enabled and play back is ready */
    if(a->repeat_cnt == 0 && ((a->playback_time == 0) || (a->playback_time && a->playback_now == 1))) {
 801f228:	687b      	ldr	r3, [r7, #4]
 801f22a:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 801f22c:	2b00      	cmp	r3, #0
 801f22e:	d128      	bne.n	801f282 <anim_ready_handler+0x92>
 801f230:	687b      	ldr	r3, [r7, #4]
 801f232:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801f234:	2b00      	cmp	r3, #0
 801f236:	d00b      	beq.n	801f250 <anim_ready_handler+0x60>
 801f238:	687b      	ldr	r3, [r7, #4]
 801f23a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801f23c:	2b00      	cmp	r3, #0
 801f23e:	d020      	beq.n	801f282 <anim_ready_handler+0x92>
 801f240:	687b      	ldr	r3, [r7, #4]
 801f242:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801f246:	f003 0301 	and.w	r3, r3, #1
 801f24a:	b2db      	uxtb	r3, r3
 801f24c:	2b00      	cmp	r3, #0
 801f24e:	d018      	beq.n	801f282 <anim_ready_handler+0x92>

        /*Create copy from the animation and delete the animation from the list.
         * This way the `ready_cb` will see the animations like it's animation is ready deleted*/
        lv_anim_t a_tmp;
        _lv_memcpy(&a_tmp, a, sizeof(lv_anim_t));
 801f250:	f107 0308 	add.w	r3, r7, #8
 801f254:	2244      	movs	r2, #68	; 0x44
 801f256:	6879      	ldr	r1, [r7, #4]
 801f258:	4618      	mov	r0, r3
 801f25a:	f001 ff7f 	bl	802115c <_lv_memcpy>
        _lv_ll_remove(&LV_GC_ROOT(_lv_anim_ll), a);
 801f25e:	6879      	ldr	r1, [r7, #4]
 801f260:	482d      	ldr	r0, [pc, #180]	; (801f318 <anim_ready_handler+0x128>)
 801f262:	f001 fa4d 	bl	8020700 <_lv_ll_remove>
        lv_mem_free(a);
 801f266:	6878      	ldr	r0, [r7, #4]
 801f268:	f001 fcfe 	bl	8020c68 <lv_mem_free>
        /*Flag that the list has changed */
        anim_mark_list_change();
 801f26c:	f000 f858 	bl	801f320 <anim_mark_list_change>

        /* Call the callback function at the end*/
        if(a_tmp.ready_cb != NULL) a_tmp.ready_cb(&a_tmp);
 801f270:	697b      	ldr	r3, [r7, #20]
 801f272:	2b00      	cmp	r3, #0
 801f274:	d049      	beq.n	801f30a <anim_ready_handler+0x11a>
 801f276:	697b      	ldr	r3, [r7, #20]
 801f278:	f107 0208 	add.w	r2, r7, #8
 801f27c:	4610      	mov	r0, r2
 801f27e:	4798      	blx	r3
    if(a->repeat_cnt == 0 && ((a->playback_time == 0) || (a->playback_time && a->playback_now == 1))) {
 801f280:	e043      	b.n	801f30a <anim_ready_handler+0x11a>
    }
    /*If the animation is not deleted then restart it*/
    else {
        a->act_time = -(int32_t)(a->repeat_delay); /*Restart the animation*/
 801f282:	687b      	ldr	r3, [r7, #4]
 801f284:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801f286:	425a      	negs	r2, r3
 801f288:	687b      	ldr	r3, [r7, #4]
 801f28a:	629a      	str	r2, [r3, #40]	; 0x28
        /*Swap the start and end values in play back mode*/
        if(a->playback_time != 0) {
 801f28c:	687b      	ldr	r3, [r7, #4]
 801f28e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801f290:	2b00      	cmp	r3, #0
 801f292:	d03b      	beq.n	801f30c <anim_ready_handler+0x11c>
            /*If now turning back use the 'playback_pause*/
            if(a->playback_now == 0) a->act_time = -(int32_t)(a->playback_delay);
 801f294:	687b      	ldr	r3, [r7, #4]
 801f296:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801f29a:	f003 0301 	and.w	r3, r3, #1
 801f29e:	b2db      	uxtb	r3, r3
 801f2a0:	2b00      	cmp	r3, #0
 801f2a2:	d104      	bne.n	801f2ae <anim_ready_handler+0xbe>
 801f2a4:	687b      	ldr	r3, [r7, #4]
 801f2a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801f2a8:	425a      	negs	r2, r3
 801f2aa:	687b      	ldr	r3, [r7, #4]
 801f2ac:	629a      	str	r2, [r3, #40]	; 0x28

            /*Toggle the play back state*/
            a->playback_now = a->playback_now == 0 ? 1 : 0;
 801f2ae:	687b      	ldr	r3, [r7, #4]
 801f2b0:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801f2b4:	f003 0301 	and.w	r3, r3, #1
 801f2b8:	b2db      	uxtb	r3, r3
 801f2ba:	2b00      	cmp	r3, #0
 801f2bc:	bf0c      	ite	eq
 801f2be:	2301      	moveq	r3, #1
 801f2c0:	2300      	movne	r3, #0
 801f2c2:	b2d9      	uxtb	r1, r3
 801f2c4:	687a      	ldr	r2, [r7, #4]
 801f2c6:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 801f2ca:	f361 0300 	bfi	r3, r1, #0, #1
 801f2ce:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
            /*Swap the start and end values*/
            int32_t tmp;
            tmp      = a->start;
 801f2d2:	687b      	ldr	r3, [r7, #4]
 801f2d4:	699b      	ldr	r3, [r3, #24]
 801f2d6:	64fb      	str	r3, [r7, #76]	; 0x4c
            a->start = a->end;
 801f2d8:	687b      	ldr	r3, [r7, #4]
 801f2da:	6a1a      	ldr	r2, [r3, #32]
 801f2dc:	687b      	ldr	r3, [r7, #4]
 801f2de:	619a      	str	r2, [r3, #24]
            a->end   = tmp;
 801f2e0:	687b      	ldr	r3, [r7, #4]
 801f2e2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801f2e4:	621a      	str	r2, [r3, #32]

            a->time = a->playback_now == 0 ? a->time_orig : a->playback_time;
 801f2e6:	687b      	ldr	r3, [r7, #4]
 801f2e8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 801f2ec:	f003 0301 	and.w	r3, r3, #1
 801f2f0:	b2db      	uxtb	r3, r3
 801f2f2:	2b00      	cmp	r3, #0
 801f2f4:	d103      	bne.n	801f2fe <anim_ready_handler+0x10e>
 801f2f6:	687b      	ldr	r3, [r7, #4]
 801f2f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801f2fa:	461a      	mov	r2, r3
 801f2fc:	e002      	b.n	801f304 <anim_ready_handler+0x114>
 801f2fe:	687b      	ldr	r3, [r7, #4]
 801f300:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801f302:	461a      	mov	r2, r3
 801f304:	687b      	ldr	r3, [r7, #4]
 801f306:	625a      	str	r2, [r3, #36]	; 0x24
 801f308:	e000      	b.n	801f30c <anim_ready_handler+0x11c>
    if(a->repeat_cnt == 0 && ((a->playback_time == 0) || (a->playback_time && a->playback_now == 1))) {
 801f30a:	bf00      	nop
        }
    }

    return anim_list_changed;
 801f30c:	4b03      	ldr	r3, [pc, #12]	; (801f31c <anim_ready_handler+0x12c>)
 801f30e:	781b      	ldrb	r3, [r3, #0]
}
 801f310:	4618      	mov	r0, r3
 801f312:	3750      	adds	r7, #80	; 0x50
 801f314:	46bd      	mov	sp, r7
 801f316:	bd80      	pop	{r7, pc}
 801f318:	2000a1a4 	.word	0x2000a1a4
 801f31c:	2000a16c 	.word	0x2000a16c

0801f320 <anim_mark_list_change>:
static void anim_mark_list_change(void)
{
 801f320:	b580      	push	{r7, lr}
 801f322:	af00      	add	r7, sp, #0
    anim_list_changed = true;
 801f324:	4b0b      	ldr	r3, [pc, #44]	; (801f354 <anim_mark_list_change+0x34>)
 801f326:	2201      	movs	r2, #1
 801f328:	701a      	strb	r2, [r3, #0]
    if(_lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll)) == NULL)
 801f32a:	480b      	ldr	r0, [pc, #44]	; (801f358 <anim_mark_list_change+0x38>)
 801f32c:	f001 fa96 	bl	802085c <_lv_ll_get_head>
 801f330:	4603      	mov	r3, r0
 801f332:	2b00      	cmp	r3, #0
 801f334:	d106      	bne.n	801f344 <anim_mark_list_change+0x24>
        lv_task_set_prio(_lv_anim_task, LV_TASK_PRIO_OFF);
 801f336:	4b09      	ldr	r3, [pc, #36]	; (801f35c <anim_mark_list_change+0x3c>)
 801f338:	681b      	ldr	r3, [r3, #0]
 801f33a:	2100      	movs	r1, #0
 801f33c:	4618      	mov	r0, r3
 801f33e:	f002 fdbf 	bl	8021ec0 <lv_task_set_prio>
    else
        lv_task_set_prio(_lv_anim_task, LV_ANIM_TASK_PRIO);
}
 801f342:	e005      	b.n	801f350 <anim_mark_list_change+0x30>
        lv_task_set_prio(_lv_anim_task, LV_ANIM_TASK_PRIO);
 801f344:	4b05      	ldr	r3, [pc, #20]	; (801f35c <anim_mark_list_change+0x3c>)
 801f346:	681b      	ldr	r3, [r3, #0]
 801f348:	2104      	movs	r1, #4
 801f34a:	4618      	mov	r0, r3
 801f34c:	f002 fdb8 	bl	8021ec0 <lv_task_set_prio>
}
 801f350:	bf00      	nop
 801f352:	bd80      	pop	{r7, pc}
 801f354:	2000a16c 	.word	0x2000a16c
 801f358:	2000a1a4 	.word	0x2000a1a4
 801f35c:	2000a170 	.word	0x2000a170

0801f360 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 801f360:	b480      	push	{r7}
 801f362:	b083      	sub	sp, #12
 801f364:	af00      	add	r7, sp, #0
 801f366:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 801f368:	687b      	ldr	r3, [r7, #4]
 801f36a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f36e:	b29a      	uxth	r2, r3
 801f370:	687b      	ldr	r3, [r7, #4]
 801f372:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f376:	b29b      	uxth	r3, r3
 801f378:	1ad3      	subs	r3, r2, r3
 801f37a:	b29b      	uxth	r3, r3
 801f37c:	3301      	adds	r3, #1
 801f37e:	b29b      	uxth	r3, r3
 801f380:	b21b      	sxth	r3, r3
}
 801f382:	4618      	mov	r0, r3
 801f384:	370c      	adds	r7, #12
 801f386:	46bd      	mov	sp, r7
 801f388:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f38c:	4770      	bx	lr

0801f38e <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 801f38e:	b480      	push	{r7}
 801f390:	b083      	sub	sp, #12
 801f392:	af00      	add	r7, sp, #0
 801f394:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 801f396:	687b      	ldr	r3, [r7, #4]
 801f398:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f39c:	b29a      	uxth	r2, r3
 801f39e:	687b      	ldr	r3, [r7, #4]
 801f3a0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f3a4:	b29b      	uxth	r3, r3
 801f3a6:	1ad3      	subs	r3, r2, r3
 801f3a8:	b29b      	uxth	r3, r3
 801f3aa:	3301      	adds	r3, #1
 801f3ac:	b29b      	uxth	r3, r3
 801f3ae:	b21b      	sxth	r3, r3
}
 801f3b0:	4618      	mov	r0, r3
 801f3b2:	370c      	adds	r7, #12
 801f3b4:	46bd      	mov	sp, r7
 801f3b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f3ba:	4770      	bx	lr

0801f3bc <lv_area_set>:
 * @param y1 top coordinate of the area
 * @param x2 right coordinate of the area
 * @param y2 bottom coordinate of the area
 */
void lv_area_set(lv_area_t * area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)
{
 801f3bc:	b480      	push	{r7}
 801f3be:	b085      	sub	sp, #20
 801f3c0:	af00      	add	r7, sp, #0
 801f3c2:	60f8      	str	r0, [r7, #12]
 801f3c4:	4608      	mov	r0, r1
 801f3c6:	4611      	mov	r1, r2
 801f3c8:	461a      	mov	r2, r3
 801f3ca:	4603      	mov	r3, r0
 801f3cc:	817b      	strh	r3, [r7, #10]
 801f3ce:	460b      	mov	r3, r1
 801f3d0:	813b      	strh	r3, [r7, #8]
 801f3d2:	4613      	mov	r3, r2
 801f3d4:	80fb      	strh	r3, [r7, #6]
    area_p->x1 = x1;
 801f3d6:	68fb      	ldr	r3, [r7, #12]
 801f3d8:	897a      	ldrh	r2, [r7, #10]
 801f3da:	801a      	strh	r2, [r3, #0]
    area_p->y1 = y1;
 801f3dc:	68fb      	ldr	r3, [r7, #12]
 801f3de:	893a      	ldrh	r2, [r7, #8]
 801f3e0:	805a      	strh	r2, [r3, #2]
    area_p->x2 = x2;
 801f3e2:	68fb      	ldr	r3, [r7, #12]
 801f3e4:	88fa      	ldrh	r2, [r7, #6]
 801f3e6:	809a      	strh	r2, [r3, #4]
    area_p->y2 = y2;
 801f3e8:	68fb      	ldr	r3, [r7, #12]
 801f3ea:	8b3a      	ldrh	r2, [r7, #24]
 801f3ec:	80da      	strh	r2, [r3, #6]
}
 801f3ee:	bf00      	nop
 801f3f0:	3714      	adds	r7, #20
 801f3f2:	46bd      	mov	sp, r7
 801f3f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f3f8:	4770      	bx	lr

0801f3fa <lv_area_set_height>:
 * Set the height of an area
 * @param area_p pointer to an area
 * @param h the new height of the area (h == 1 makes y1 == y2)
 */
void lv_area_set_height(lv_area_t * area_p, lv_coord_t h)
{
 801f3fa:	b480      	push	{r7}
 801f3fc:	b083      	sub	sp, #12
 801f3fe:	af00      	add	r7, sp, #0
 801f400:	6078      	str	r0, [r7, #4]
 801f402:	460b      	mov	r3, r1
 801f404:	807b      	strh	r3, [r7, #2]
    area_p->y2 = area_p->y1 + h - 1;
 801f406:	687b      	ldr	r3, [r7, #4]
 801f408:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f40c:	b29a      	uxth	r2, r3
 801f40e:	887b      	ldrh	r3, [r7, #2]
 801f410:	4413      	add	r3, r2
 801f412:	b29b      	uxth	r3, r3
 801f414:	3b01      	subs	r3, #1
 801f416:	b29b      	uxth	r3, r3
 801f418:	b21a      	sxth	r2, r3
 801f41a:	687b      	ldr	r3, [r7, #4]
 801f41c:	80da      	strh	r2, [r3, #6]
}
 801f41e:	bf00      	nop
 801f420:	370c      	adds	r7, #12
 801f422:	46bd      	mov	sp, r7
 801f424:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f428:	4770      	bx	lr

0801f42a <lv_area_get_size>:
 * Return with area of an area (x * y)
 * @param area_p pointer to an area
 * @return size of area
 */
uint32_t lv_area_get_size(const lv_area_t * area_p)
{
 801f42a:	b480      	push	{r7}
 801f42c:	b085      	sub	sp, #20
 801f42e:	af00      	add	r7, sp, #0
 801f430:	6078      	str	r0, [r7, #4]
    uint32_t size;

    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);
 801f432:	687b      	ldr	r3, [r7, #4]
 801f434:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f438:	461a      	mov	r2, r3
 801f43a:	687b      	ldr	r3, [r7, #4]
 801f43c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f440:	1ad3      	subs	r3, r2, r3
 801f442:	3301      	adds	r3, #1
 801f444:	461a      	mov	r2, r3
 801f446:	687b      	ldr	r3, [r7, #4]
 801f448:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f44c:	4619      	mov	r1, r3
 801f44e:	687b      	ldr	r3, [r7, #4]
 801f450:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f454:	1acb      	subs	r3, r1, r3
 801f456:	3301      	adds	r3, #1
 801f458:	fb02 f303 	mul.w	r3, r2, r3
 801f45c:	60fb      	str	r3, [r7, #12]

    return size;
 801f45e:	68fb      	ldr	r3, [r7, #12]
}
 801f460:	4618      	mov	r0, r3
 801f462:	3714      	adds	r7, #20
 801f464:	46bd      	mov	sp, r7
 801f466:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f46a:	4770      	bx	lr

0801f46c <_lv_area_intersect>:
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 * @return false: the two area has NO common parts, res_p is invalid
 */
bool _lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 801f46c:	b480      	push	{r7}
 801f46e:	b087      	sub	sp, #28
 801f470:	af00      	add	r7, sp, #0
 801f472:	60f8      	str	r0, [r7, #12]
 801f474:	60b9      	str	r1, [r7, #8]
 801f476:	607a      	str	r2, [r7, #4]
    /* Get the smaller area from 'a1_p' and 'a2_p' */
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
 801f478:	687b      	ldr	r3, [r7, #4]
 801f47a:	f9b3 2000 	ldrsh.w	r2, [r3]
 801f47e:	68bb      	ldr	r3, [r7, #8]
 801f480:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f484:	4293      	cmp	r3, r2
 801f486:	bfb8      	it	lt
 801f488:	4613      	movlt	r3, r2
 801f48a:	b21a      	sxth	r2, r3
 801f48c:	68fb      	ldr	r3, [r7, #12]
 801f48e:	801a      	strh	r2, [r3, #0]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
 801f490:	687b      	ldr	r3, [r7, #4]
 801f492:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801f496:	68bb      	ldr	r3, [r7, #8]
 801f498:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f49c:	4293      	cmp	r3, r2
 801f49e:	bfb8      	it	lt
 801f4a0:	4613      	movlt	r3, r2
 801f4a2:	b21a      	sxth	r2, r3
 801f4a4:	68fb      	ldr	r3, [r7, #12]
 801f4a6:	805a      	strh	r2, [r3, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
 801f4a8:	687b      	ldr	r3, [r7, #4]
 801f4aa:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801f4ae:	68bb      	ldr	r3, [r7, #8]
 801f4b0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f4b4:	4293      	cmp	r3, r2
 801f4b6:	bfa8      	it	ge
 801f4b8:	4613      	movge	r3, r2
 801f4ba:	b21a      	sxth	r2, r3
 801f4bc:	68fb      	ldr	r3, [r7, #12]
 801f4be:	809a      	strh	r2, [r3, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
 801f4c0:	687b      	ldr	r3, [r7, #4]
 801f4c2:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801f4c6:	68bb      	ldr	r3, [r7, #8]
 801f4c8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f4cc:	4293      	cmp	r3, r2
 801f4ce:	bfa8      	it	ge
 801f4d0:	4613      	movge	r3, r2
 801f4d2:	b21a      	sxth	r2, r3
 801f4d4:	68fb      	ldr	r3, [r7, #12]
 801f4d6:	80da      	strh	r2, [r3, #6]

    /*If x1 or y1 greater then x2 or y2 then the areas union is empty*/
    bool union_ok = true;
 801f4d8:	2301      	movs	r3, #1
 801f4da:	75fb      	strb	r3, [r7, #23]
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
 801f4dc:	68fb      	ldr	r3, [r7, #12]
 801f4de:	f9b3 2000 	ldrsh.w	r2, [r3]
 801f4e2:	68fb      	ldr	r3, [r7, #12]
 801f4e4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f4e8:	429a      	cmp	r2, r3
 801f4ea:	dc07      	bgt.n	801f4fc <_lv_area_intersect+0x90>
 801f4ec:	68fb      	ldr	r3, [r7, #12]
 801f4ee:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801f4f2:	68fb      	ldr	r3, [r7, #12]
 801f4f4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f4f8:	429a      	cmp	r2, r3
 801f4fa:	dd01      	ble.n	801f500 <_lv_area_intersect+0x94>
        union_ok = false;
 801f4fc:	2300      	movs	r3, #0
 801f4fe:	75fb      	strb	r3, [r7, #23]
    }

    return union_ok;
 801f500:	7dfb      	ldrb	r3, [r7, #23]
}
 801f502:	4618      	mov	r0, r3
 801f504:	371c      	adds	r7, #28
 801f506:	46bd      	mov	sp, r7
 801f508:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f50c:	4770      	bx	lr

0801f50e <_lv_area_join>:
 * @param res_p pointer to an area, the result will be stored here
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 */
void _lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 801f50e:	b480      	push	{r7}
 801f510:	b085      	sub	sp, #20
 801f512:	af00      	add	r7, sp, #0
 801f514:	60f8      	str	r0, [r7, #12]
 801f516:	60b9      	str	r1, [r7, #8]
 801f518:	607a      	str	r2, [r7, #4]
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
 801f51a:	687b      	ldr	r3, [r7, #4]
 801f51c:	f9b3 2000 	ldrsh.w	r2, [r3]
 801f520:	68bb      	ldr	r3, [r7, #8]
 801f522:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f526:	4293      	cmp	r3, r2
 801f528:	bfa8      	it	ge
 801f52a:	4613      	movge	r3, r2
 801f52c:	b21a      	sxth	r2, r3
 801f52e:	68fb      	ldr	r3, [r7, #12]
 801f530:	801a      	strh	r2, [r3, #0]
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
 801f532:	687b      	ldr	r3, [r7, #4]
 801f534:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801f538:	68bb      	ldr	r3, [r7, #8]
 801f53a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f53e:	4293      	cmp	r3, r2
 801f540:	bfa8      	it	ge
 801f542:	4613      	movge	r3, r2
 801f544:	b21a      	sxth	r2, r3
 801f546:	68fb      	ldr	r3, [r7, #12]
 801f548:	805a      	strh	r2, [r3, #2]
    a_res_p->x2 = LV_MATH_MAX(a1_p->x2, a2_p->x2);
 801f54a:	687b      	ldr	r3, [r7, #4]
 801f54c:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801f550:	68bb      	ldr	r3, [r7, #8]
 801f552:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f556:	4293      	cmp	r3, r2
 801f558:	bfb8      	it	lt
 801f55a:	4613      	movlt	r3, r2
 801f55c:	b21a      	sxth	r2, r3
 801f55e:	68fb      	ldr	r3, [r7, #12]
 801f560:	809a      	strh	r2, [r3, #4]
    a_res_p->y2 = LV_MATH_MAX(a1_p->y2, a2_p->y2);
 801f562:	687b      	ldr	r3, [r7, #4]
 801f564:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801f568:	68bb      	ldr	r3, [r7, #8]
 801f56a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f56e:	4293      	cmp	r3, r2
 801f570:	bfb8      	it	lt
 801f572:	4613      	movlt	r3, r2
 801f574:	b21a      	sxth	r2, r3
 801f576:	68fb      	ldr	r3, [r7, #12]
 801f578:	80da      	strh	r2, [r3, #6]
}
 801f57a:	bf00      	nop
 801f57c:	3714      	adds	r7, #20
 801f57e:	46bd      	mov	sp, r7
 801f580:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f584:	4770      	bx	lr

0801f586 <_lv_area_is_point_on>:
 * @param p_p pointer to a point
 * @param radius radius of area (e.g. for rounded rectangle)
 * @return false:the point is out of the area
 */
bool _lv_area_is_point_on(const lv_area_t * a_p, const lv_point_t * p_p, lv_coord_t radius)
{
 801f586:	b580      	push	{r7, lr}
 801f588:	b088      	sub	sp, #32
 801f58a:	af00      	add	r7, sp, #0
 801f58c:	60f8      	str	r0, [r7, #12]
 801f58e:	60b9      	str	r1, [r7, #8]
 801f590:	4613      	mov	r3, r2
 801f592:	80fb      	strh	r3, [r7, #6]
    /*First check the basic area*/
    bool is_on_rect = false;
 801f594:	2300      	movs	r3, #0
 801f596:	77fb      	strb	r3, [r7, #31]
    if((p_p->x >= a_p->x1 && p_p->x <= a_p->x2) && ((p_p->y >= a_p->y1 && p_p->y <= a_p->y2))) {
 801f598:	68bb      	ldr	r3, [r7, #8]
 801f59a:	f9b3 2000 	ldrsh.w	r2, [r3]
 801f59e:	68fb      	ldr	r3, [r7, #12]
 801f5a0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f5a4:	429a      	cmp	r2, r3
 801f5a6:	db19      	blt.n	801f5dc <_lv_area_is_point_on+0x56>
 801f5a8:	68bb      	ldr	r3, [r7, #8]
 801f5aa:	f9b3 2000 	ldrsh.w	r2, [r3]
 801f5ae:	68fb      	ldr	r3, [r7, #12]
 801f5b0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f5b4:	429a      	cmp	r2, r3
 801f5b6:	dc11      	bgt.n	801f5dc <_lv_area_is_point_on+0x56>
 801f5b8:	68bb      	ldr	r3, [r7, #8]
 801f5ba:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801f5be:	68fb      	ldr	r3, [r7, #12]
 801f5c0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f5c4:	429a      	cmp	r2, r3
 801f5c6:	db09      	blt.n	801f5dc <_lv_area_is_point_on+0x56>
 801f5c8:	68bb      	ldr	r3, [r7, #8]
 801f5ca:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801f5ce:	68fb      	ldr	r3, [r7, #12]
 801f5d0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f5d4:	429a      	cmp	r2, r3
 801f5d6:	dc01      	bgt.n	801f5dc <_lv_area_is_point_on+0x56>
        is_on_rect = true;
 801f5d8:	2301      	movs	r3, #1
 801f5da:	77fb      	strb	r3, [r7, #31]
    }
    if(!is_on_rect)
 801f5dc:	7ffb      	ldrb	r3, [r7, #31]
 801f5de:	f083 0301 	eor.w	r3, r3, #1
 801f5e2:	b2db      	uxtb	r3, r3
 801f5e4:	2b00      	cmp	r3, #0
 801f5e6:	d001      	beq.n	801f5ec <_lv_area_is_point_on+0x66>
        return false;
 801f5e8:	2300      	movs	r3, #0
 801f5ea:	e0ef      	b.n	801f7cc <_lv_area_is_point_on+0x246>
    /*Now handle potential rounded rectangles*/
    if(radius <= 0) {
 801f5ec:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801f5f0:	2b00      	cmp	r3, #0
 801f5f2:	dc01      	bgt.n	801f5f8 <_lv_area_is_point_on+0x72>
        /*No radius, it is within the rectangle*/
        return true;
 801f5f4:	2301      	movs	r3, #1
 801f5f6:	e0e9      	b.n	801f7cc <_lv_area_is_point_on+0x246>
    }
    lv_coord_t w = lv_area_get_width(a_p) / 2;
 801f5f8:	68f8      	ldr	r0, [r7, #12]
 801f5fa:	f7ff feb1 	bl	801f360 <lv_area_get_width>
 801f5fe:	4603      	mov	r3, r0
 801f600:	0fda      	lsrs	r2, r3, #31
 801f602:	4413      	add	r3, r2
 801f604:	105b      	asrs	r3, r3, #1
 801f606:	83bb      	strh	r3, [r7, #28]
    lv_coord_t h = lv_area_get_height(a_p) / 2;
 801f608:	68f8      	ldr	r0, [r7, #12]
 801f60a:	f7ff fec0 	bl	801f38e <lv_area_get_height>
 801f60e:	4603      	mov	r3, r0
 801f610:	0fda      	lsrs	r2, r3, #31
 801f612:	4413      	add	r3, r2
 801f614:	105b      	asrs	r3, r3, #1
 801f616:	837b      	strh	r3, [r7, #26]
    lv_coord_t max_radius = LV_MATH_MIN(w, h);
 801f618:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 801f61c:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 801f620:	4293      	cmp	r3, r2
 801f622:	bfa8      	it	ge
 801f624:	4613      	movge	r3, r2
 801f626:	833b      	strh	r3, [r7, #24]
    if(radius > max_radius)
 801f628:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801f62c:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801f630:	429a      	cmp	r2, r3
 801f632:	dd01      	ble.n	801f638 <_lv_area_is_point_on+0xb2>
        radius = max_radius;
 801f634:	8b3b      	ldrh	r3, [r7, #24]
 801f636:	80fb      	strh	r3, [r7, #6]

    /*Check if it's in one of the corners*/
    lv_area_t corner_area;
    /*Top left*/
    corner_area.x1 = a_p->x1;
 801f638:	68fb      	ldr	r3, [r7, #12]
 801f63a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f63e:	823b      	strh	r3, [r7, #16]
    corner_area.x2 = a_p->x1 + radius;
 801f640:	68fb      	ldr	r3, [r7, #12]
 801f642:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f646:	b29a      	uxth	r2, r3
 801f648:	88fb      	ldrh	r3, [r7, #6]
 801f64a:	4413      	add	r3, r2
 801f64c:	b29b      	uxth	r3, r3
 801f64e:	b21b      	sxth	r3, r3
 801f650:	82bb      	strh	r3, [r7, #20]
    corner_area.y1 = a_p->y1;
 801f652:	68fb      	ldr	r3, [r7, #12]
 801f654:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f658:	827b      	strh	r3, [r7, #18]
    corner_area.y2 = a_p->y1 + radius;
 801f65a:	68fb      	ldr	r3, [r7, #12]
 801f65c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f660:	b29a      	uxth	r2, r3
 801f662:	88fb      	ldrh	r3, [r7, #6]
 801f664:	4413      	add	r3, r2
 801f666:	b29b      	uxth	r3, r3
 801f668:	b21b      	sxth	r3, r3
 801f66a:	82fb      	strh	r3, [r7, #22]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
 801f66c:	f107 0310 	add.w	r3, r7, #16
 801f670:	2200      	movs	r2, #0
 801f672:	68b9      	ldr	r1, [r7, #8]
 801f674:	4618      	mov	r0, r3
 801f676:	f7ff ff86 	bl	801f586 <_lv_area_is_point_on>
 801f67a:	4603      	mov	r3, r0
 801f67c:	2b00      	cmp	r3, #0
 801f67e:	d017      	beq.n	801f6b0 <_lv_area_is_point_on+0x12a>
        corner_area.x2 += radius;
 801f680:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801f684:	b29a      	uxth	r2, r3
 801f686:	88fb      	ldrh	r3, [r7, #6]
 801f688:	4413      	add	r3, r2
 801f68a:	b29b      	uxth	r3, r3
 801f68c:	b21b      	sxth	r3, r3
 801f68e:	82bb      	strh	r3, [r7, #20]
        corner_area.y2 += radius;
 801f690:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801f694:	b29a      	uxth	r2, r3
 801f696:	88fb      	ldrh	r3, [r7, #6]
 801f698:	4413      	add	r3, r2
 801f69a:	b29b      	uxth	r3, r3
 801f69c:	b21b      	sxth	r3, r3
 801f69e:	82fb      	strh	r3, [r7, #22]
        return lv_point_within_circle(&corner_area, p_p);
 801f6a0:	f107 0310 	add.w	r3, r7, #16
 801f6a4:	68b9      	ldr	r1, [r7, #8]
 801f6a6:	4618      	mov	r0, r3
 801f6a8:	f000 fbc6 	bl	801fe38 <lv_point_within_circle>
 801f6ac:	4603      	mov	r3, r0
 801f6ae:	e08d      	b.n	801f7cc <_lv_area_is_point_on+0x246>
    }
    /*Bottom left*/
    corner_area.y1 = a_p->y2 - radius;
 801f6b0:	68fb      	ldr	r3, [r7, #12]
 801f6b2:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f6b6:	b29a      	uxth	r2, r3
 801f6b8:	88fb      	ldrh	r3, [r7, #6]
 801f6ba:	1ad3      	subs	r3, r2, r3
 801f6bc:	b29b      	uxth	r3, r3
 801f6be:	b21b      	sxth	r3, r3
 801f6c0:	827b      	strh	r3, [r7, #18]
    corner_area.y2 = a_p->y2;
 801f6c2:	68fb      	ldr	r3, [r7, #12]
 801f6c4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f6c8:	82fb      	strh	r3, [r7, #22]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
 801f6ca:	f107 0310 	add.w	r3, r7, #16
 801f6ce:	2200      	movs	r2, #0
 801f6d0:	68b9      	ldr	r1, [r7, #8]
 801f6d2:	4618      	mov	r0, r3
 801f6d4:	f7ff ff57 	bl	801f586 <_lv_area_is_point_on>
 801f6d8:	4603      	mov	r3, r0
 801f6da:	2b00      	cmp	r3, #0
 801f6dc:	d017      	beq.n	801f70e <_lv_area_is_point_on+0x188>
        corner_area.x2 += radius;
 801f6de:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801f6e2:	b29a      	uxth	r2, r3
 801f6e4:	88fb      	ldrh	r3, [r7, #6]
 801f6e6:	4413      	add	r3, r2
 801f6e8:	b29b      	uxth	r3, r3
 801f6ea:	b21b      	sxth	r3, r3
 801f6ec:	82bb      	strh	r3, [r7, #20]
        corner_area.y1 -= radius;
 801f6ee:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801f6f2:	b29a      	uxth	r2, r3
 801f6f4:	88fb      	ldrh	r3, [r7, #6]
 801f6f6:	1ad3      	subs	r3, r2, r3
 801f6f8:	b29b      	uxth	r3, r3
 801f6fa:	b21b      	sxth	r3, r3
 801f6fc:	827b      	strh	r3, [r7, #18]
        return lv_point_within_circle(&corner_area, p_p);
 801f6fe:	f107 0310 	add.w	r3, r7, #16
 801f702:	68b9      	ldr	r1, [r7, #8]
 801f704:	4618      	mov	r0, r3
 801f706:	f000 fb97 	bl	801fe38 <lv_point_within_circle>
 801f70a:	4603      	mov	r3, r0
 801f70c:	e05e      	b.n	801f7cc <_lv_area_is_point_on+0x246>
    }
    /*Bottom right*/
    corner_area.x1 = a_p->x2 - radius;
 801f70e:	68fb      	ldr	r3, [r7, #12]
 801f710:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f714:	b29a      	uxth	r2, r3
 801f716:	88fb      	ldrh	r3, [r7, #6]
 801f718:	1ad3      	subs	r3, r2, r3
 801f71a:	b29b      	uxth	r3, r3
 801f71c:	b21b      	sxth	r3, r3
 801f71e:	823b      	strh	r3, [r7, #16]
    corner_area.x2 = a_p->x2;
 801f720:	68fb      	ldr	r3, [r7, #12]
 801f722:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f726:	82bb      	strh	r3, [r7, #20]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
 801f728:	f107 0310 	add.w	r3, r7, #16
 801f72c:	2200      	movs	r2, #0
 801f72e:	68b9      	ldr	r1, [r7, #8]
 801f730:	4618      	mov	r0, r3
 801f732:	f7ff ff28 	bl	801f586 <_lv_area_is_point_on>
 801f736:	4603      	mov	r3, r0
 801f738:	2b00      	cmp	r3, #0
 801f73a:	d017      	beq.n	801f76c <_lv_area_is_point_on+0x1e6>
        corner_area.x1 -= radius;
 801f73c:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801f740:	b29a      	uxth	r2, r3
 801f742:	88fb      	ldrh	r3, [r7, #6]
 801f744:	1ad3      	subs	r3, r2, r3
 801f746:	b29b      	uxth	r3, r3
 801f748:	b21b      	sxth	r3, r3
 801f74a:	823b      	strh	r3, [r7, #16]
        corner_area.y1 -= radius;
 801f74c:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801f750:	b29a      	uxth	r2, r3
 801f752:	88fb      	ldrh	r3, [r7, #6]
 801f754:	1ad3      	subs	r3, r2, r3
 801f756:	b29b      	uxth	r3, r3
 801f758:	b21b      	sxth	r3, r3
 801f75a:	827b      	strh	r3, [r7, #18]
        return lv_point_within_circle(&corner_area, p_p);
 801f75c:	f107 0310 	add.w	r3, r7, #16
 801f760:	68b9      	ldr	r1, [r7, #8]
 801f762:	4618      	mov	r0, r3
 801f764:	f000 fb68 	bl	801fe38 <lv_point_within_circle>
 801f768:	4603      	mov	r3, r0
 801f76a:	e02f      	b.n	801f7cc <_lv_area_is_point_on+0x246>
    }
    /*Top right*/
    corner_area.y1 = a_p->y1;
 801f76c:	68fb      	ldr	r3, [r7, #12]
 801f76e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f772:	827b      	strh	r3, [r7, #18]
    corner_area.y2 = a_p->y1 + radius;
 801f774:	68fb      	ldr	r3, [r7, #12]
 801f776:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f77a:	b29a      	uxth	r2, r3
 801f77c:	88fb      	ldrh	r3, [r7, #6]
 801f77e:	4413      	add	r3, r2
 801f780:	b29b      	uxth	r3, r3
 801f782:	b21b      	sxth	r3, r3
 801f784:	82fb      	strh	r3, [r7, #22]
    if(_lv_area_is_point_on(&corner_area, p_p, 0)) {
 801f786:	f107 0310 	add.w	r3, r7, #16
 801f78a:	2200      	movs	r2, #0
 801f78c:	68b9      	ldr	r1, [r7, #8]
 801f78e:	4618      	mov	r0, r3
 801f790:	f7ff fef9 	bl	801f586 <_lv_area_is_point_on>
 801f794:	4603      	mov	r3, r0
 801f796:	2b00      	cmp	r3, #0
 801f798:	d017      	beq.n	801f7ca <_lv_area_is_point_on+0x244>
        corner_area.x1 -= radius;
 801f79a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801f79e:	b29a      	uxth	r2, r3
 801f7a0:	88fb      	ldrh	r3, [r7, #6]
 801f7a2:	1ad3      	subs	r3, r2, r3
 801f7a4:	b29b      	uxth	r3, r3
 801f7a6:	b21b      	sxth	r3, r3
 801f7a8:	823b      	strh	r3, [r7, #16]
        corner_area.y2 += radius;
 801f7aa:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801f7ae:	b29a      	uxth	r2, r3
 801f7b0:	88fb      	ldrh	r3, [r7, #6]
 801f7b2:	4413      	add	r3, r2
 801f7b4:	b29b      	uxth	r3, r3
 801f7b6:	b21b      	sxth	r3, r3
 801f7b8:	82fb      	strh	r3, [r7, #22]
        return lv_point_within_circle(&corner_area, p_p);
 801f7ba:	f107 0310 	add.w	r3, r7, #16
 801f7be:	68b9      	ldr	r1, [r7, #8]
 801f7c0:	4618      	mov	r0, r3
 801f7c2:	f000 fb39 	bl	801fe38 <lv_point_within_circle>
 801f7c6:	4603      	mov	r3, r0
 801f7c8:	e000      	b.n	801f7cc <_lv_area_is_point_on+0x246>
    }
    /*Not within corners*/
    return true;
 801f7ca:	2301      	movs	r3, #1
}
 801f7cc:	4618      	mov	r0, r3
 801f7ce:	3720      	adds	r7, #32
 801f7d0:	46bd      	mov	sp, r7
 801f7d2:	bd80      	pop	{r7, pc}

0801f7d4 <_lv_area_is_on>:
 * @param a1_p pointer to an area.
 * @param a2_p pointer to an other area
 * @return false: a1_p and a2_p has no common parts
 */
bool _lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 801f7d4:	b480      	push	{r7}
 801f7d6:	b083      	sub	sp, #12
 801f7d8:	af00      	add	r7, sp, #0
 801f7da:	6078      	str	r0, [r7, #4]
 801f7dc:	6039      	str	r1, [r7, #0]
    if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {
 801f7de:	687b      	ldr	r3, [r7, #4]
 801f7e0:	f9b3 2000 	ldrsh.w	r2, [r3]
 801f7e4:	683b      	ldr	r3, [r7, #0]
 801f7e6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f7ea:	429a      	cmp	r2, r3
 801f7ec:	dc19      	bgt.n	801f822 <_lv_area_is_on+0x4e>
 801f7ee:	687b      	ldr	r3, [r7, #4]
 801f7f0:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801f7f4:	683b      	ldr	r3, [r7, #0]
 801f7f6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f7fa:	429a      	cmp	r2, r3
 801f7fc:	db11      	blt.n	801f822 <_lv_area_is_on+0x4e>
 801f7fe:	687b      	ldr	r3, [r7, #4]
 801f800:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801f804:	683b      	ldr	r3, [r7, #0]
 801f806:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f80a:	429a      	cmp	r2, r3
 801f80c:	dc09      	bgt.n	801f822 <_lv_area_is_on+0x4e>
 801f80e:	687b      	ldr	r3, [r7, #4]
 801f810:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801f814:	683b      	ldr	r3, [r7, #0]
 801f816:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f81a:	429a      	cmp	r2, r3
 801f81c:	db01      	blt.n	801f822 <_lv_area_is_on+0x4e>
        return true;
 801f81e:	2301      	movs	r3, #1
 801f820:	e000      	b.n	801f824 <_lv_area_is_on+0x50>
    }
    else {
        return false;
 801f822:	2300      	movs	r3, #0
    }
}
 801f824:	4618      	mov	r0, r3
 801f826:	370c      	adds	r7, #12
 801f828:	46bd      	mov	sp, r7
 801f82a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f82e:	4770      	bx	lr

0801f830 <_lv_area_is_in>:
 * @param aholder_p pointer to an area which could involve 'ain_p'
 * @param radius radius of `aholder_p` (e.g. for rounded rectangle)
 * @return true: `ain_p` is fully inside `aholder_p`
 */
bool _lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p, lv_coord_t radius)
{
 801f830:	b580      	push	{r7, lr}
 801f832:	b086      	sub	sp, #24
 801f834:	af00      	add	r7, sp, #0
 801f836:	60f8      	str	r0, [r7, #12]
 801f838:	60b9      	str	r1, [r7, #8]
 801f83a:	4613      	mov	r3, r2
 801f83c:	80fb      	strh	r3, [r7, #6]
    bool is_in = false;
 801f83e:	2300      	movs	r3, #0
 801f840:	75fb      	strb	r3, [r7, #23]

    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
 801f842:	68fb      	ldr	r3, [r7, #12]
 801f844:	f9b3 2000 	ldrsh.w	r2, [r3]
 801f848:	68bb      	ldr	r3, [r7, #8]
 801f84a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f84e:	429a      	cmp	r2, r3
 801f850:	db19      	blt.n	801f886 <_lv_area_is_in+0x56>
 801f852:	68fb      	ldr	r3, [r7, #12]
 801f854:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801f858:	68bb      	ldr	r3, [r7, #8]
 801f85a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f85e:	429a      	cmp	r2, r3
 801f860:	db11      	blt.n	801f886 <_lv_area_is_in+0x56>
 801f862:	68fb      	ldr	r3, [r7, #12]
 801f864:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801f868:	68bb      	ldr	r3, [r7, #8]
 801f86a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f86e:	429a      	cmp	r2, r3
 801f870:	dc09      	bgt.n	801f886 <_lv_area_is_in+0x56>
       ain_p->y2 <= aholder_p->y2) {
 801f872:	68fb      	ldr	r3, [r7, #12]
 801f874:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801f878:	68bb      	ldr	r3, [r7, #8]
 801f87a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
 801f87e:	429a      	cmp	r2, r3
 801f880:	dc01      	bgt.n	801f886 <_lv_area_is_in+0x56>
        is_in = true;
 801f882:	2301      	movs	r3, #1
 801f884:	75fb      	strb	r3, [r7, #23]
    }

    if(radius == 0) return is_in;
 801f886:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801f88a:	2b00      	cmp	r3, #0
 801f88c:	d101      	bne.n	801f892 <_lv_area_is_in+0x62>
 801f88e:	7dfb      	ldrb	r3, [r7, #23]
 801f890:	e060      	b.n	801f954 <_lv_area_is_in+0x124>

    /*Check if the corner points are inside the radius or not*/
    lv_point_t p;

    p.x = ain_p->x1;
 801f892:	68fb      	ldr	r3, [r7, #12]
 801f894:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f898:	823b      	strh	r3, [r7, #16]
    p.y = ain_p->y1;
 801f89a:	68fb      	ldr	r3, [r7, #12]
 801f89c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f8a0:	827b      	strh	r3, [r7, #18]
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
 801f8a2:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801f8a6:	f107 0310 	add.w	r3, r7, #16
 801f8aa:	4619      	mov	r1, r3
 801f8ac:	68b8      	ldr	r0, [r7, #8]
 801f8ae:	f7ff fe6a 	bl	801f586 <_lv_area_is_point_on>
 801f8b2:	4603      	mov	r3, r0
 801f8b4:	f083 0301 	eor.w	r3, r3, #1
 801f8b8:	b2db      	uxtb	r3, r3
 801f8ba:	2b00      	cmp	r3, #0
 801f8bc:	d001      	beq.n	801f8c2 <_lv_area_is_in+0x92>
 801f8be:	2300      	movs	r3, #0
 801f8c0:	e048      	b.n	801f954 <_lv_area_is_in+0x124>

    p.x = ain_p->x2;
 801f8c2:	68fb      	ldr	r3, [r7, #12]
 801f8c4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f8c8:	823b      	strh	r3, [r7, #16]
    p.y = ain_p->y1;
 801f8ca:	68fb      	ldr	r3, [r7, #12]
 801f8cc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f8d0:	827b      	strh	r3, [r7, #18]
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
 801f8d2:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801f8d6:	f107 0310 	add.w	r3, r7, #16
 801f8da:	4619      	mov	r1, r3
 801f8dc:	68b8      	ldr	r0, [r7, #8]
 801f8de:	f7ff fe52 	bl	801f586 <_lv_area_is_point_on>
 801f8e2:	4603      	mov	r3, r0
 801f8e4:	f083 0301 	eor.w	r3, r3, #1
 801f8e8:	b2db      	uxtb	r3, r3
 801f8ea:	2b00      	cmp	r3, #0
 801f8ec:	d001      	beq.n	801f8f2 <_lv_area_is_in+0xc2>
 801f8ee:	2300      	movs	r3, #0
 801f8f0:	e030      	b.n	801f954 <_lv_area_is_in+0x124>

    p.x = ain_p->x1;
 801f8f2:	68fb      	ldr	r3, [r7, #12]
 801f8f4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f8f8:	823b      	strh	r3, [r7, #16]
    p.y = ain_p->y2;
 801f8fa:	68fb      	ldr	r3, [r7, #12]
 801f8fc:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f900:	827b      	strh	r3, [r7, #18]
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
 801f902:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801f906:	f107 0310 	add.w	r3, r7, #16
 801f90a:	4619      	mov	r1, r3
 801f90c:	68b8      	ldr	r0, [r7, #8]
 801f90e:	f7ff fe3a 	bl	801f586 <_lv_area_is_point_on>
 801f912:	4603      	mov	r3, r0
 801f914:	f083 0301 	eor.w	r3, r3, #1
 801f918:	b2db      	uxtb	r3, r3
 801f91a:	2b00      	cmp	r3, #0
 801f91c:	d001      	beq.n	801f922 <_lv_area_is_in+0xf2>
 801f91e:	2300      	movs	r3, #0
 801f920:	e018      	b.n	801f954 <_lv_area_is_in+0x124>

    p.x = ain_p->x2;
 801f922:	68fb      	ldr	r3, [r7, #12]
 801f924:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f928:	823b      	strh	r3, [r7, #16]
    p.y = ain_p->y2;
 801f92a:	68fb      	ldr	r3, [r7, #12]
 801f92c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f930:	827b      	strh	r3, [r7, #18]
    if(_lv_area_is_point_on(aholder_p, &p, radius) == false) return false;
 801f932:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801f936:	f107 0310 	add.w	r3, r7, #16
 801f93a:	4619      	mov	r1, r3
 801f93c:	68b8      	ldr	r0, [r7, #8]
 801f93e:	f7ff fe22 	bl	801f586 <_lv_area_is_point_on>
 801f942:	4603      	mov	r3, r0
 801f944:	f083 0301 	eor.w	r3, r3, #1
 801f948:	b2db      	uxtb	r3, r3
 801f94a:	2b00      	cmp	r3, #0
 801f94c:	d001      	beq.n	801f952 <_lv_area_is_in+0x122>
 801f94e:	2300      	movs	r3, #0
 801f950:	e000      	b.n	801f954 <_lv_area_is_in+0x124>

    return true;
 801f952:	2301      	movs	r3, #1
}
 801f954:	4618      	mov	r0, r3
 801f956:	3718      	adds	r7, #24
 801f958:	46bd      	mov	sp, r7
 801f95a:	bd80      	pop	{r7, pc}

0801f95c <_lv_area_align>:
 * @param to_align the area to align
 * @param align `LV_ALIGN_...`
 * @param res x/y coordinates where `to_align` align area should be placed
 */
void _lv_area_align(const lv_area_t * base, const lv_area_t * to_align, lv_align_t align, lv_point_t * res)
{
 801f95c:	b590      	push	{r4, r7, lr}
 801f95e:	b085      	sub	sp, #20
 801f960:	af00      	add	r7, sp, #0
 801f962:	60f8      	str	r0, [r7, #12]
 801f964:	60b9      	str	r1, [r7, #8]
 801f966:	603b      	str	r3, [r7, #0]
 801f968:	4613      	mov	r3, r2
 801f96a:	71fb      	strb	r3, [r7, #7]

    switch(align) {
 801f96c:	79fb      	ldrb	r3, [r7, #7]
 801f96e:	2b14      	cmp	r3, #20
 801f970:	f200 8243 	bhi.w	801fdfa <_lv_area_align+0x49e>
 801f974:	a201      	add	r2, pc, #4	; (adr r2, 801f97c <_lv_area_align+0x20>)
 801f976:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801f97a:	bf00      	nop
 801f97c:	0801f9d1 	.word	0x0801f9d1
 801f980:	0801fa2f 	.word	0x0801fa2f
 801f984:	0801fa3d 	.word	0x0801fa3d
 801f988:	0801fa73 	.word	0x0801fa73
 801f98c:	0801fa99 	.word	0x0801fa99
 801f990:	0801fabf 	.word	0x0801fabf
 801f994:	0801fb0d 	.word	0x0801fb0d
 801f998:	0801fb4b 	.word	0x0801fb4b
 801f99c:	0801fb81 	.word	0x0801fb81
 801f9a0:	0801fbcf 	.word	0x0801fbcf
 801f9a4:	0801fbeb 	.word	0x0801fbeb
 801f9a8:	0801fc2f 	.word	0x0801fc2f
 801f9ac:	0801fc63 	.word	0x0801fc63
 801f9b0:	0801fc79 	.word	0x0801fc79
 801f9b4:	0801fcb7 	.word	0x0801fcb7
 801f9b8:	0801fce5 	.word	0x0801fce5
 801f9bc:	0801fd01 	.word	0x0801fd01
 801f9c0:	0801fd45 	.word	0x0801fd45
 801f9c4:	0801fd79 	.word	0x0801fd79
 801f9c8:	0801fd8f 	.word	0x0801fd8f
 801f9cc:	0801fdcd 	.word	0x0801fdcd
        case LV_ALIGN_CENTER:
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
 801f9d0:	68f8      	ldr	r0, [r7, #12]
 801f9d2:	f7ff fcc5 	bl	801f360 <lv_area_get_width>
 801f9d6:	4603      	mov	r3, r0
 801f9d8:	0fda      	lsrs	r2, r3, #31
 801f9da:	4413      	add	r3, r2
 801f9dc:	105b      	asrs	r3, r3, #1
 801f9de:	b21b      	sxth	r3, r3
 801f9e0:	b29c      	uxth	r4, r3
 801f9e2:	68b8      	ldr	r0, [r7, #8]
 801f9e4:	f7ff fcbc 	bl	801f360 <lv_area_get_width>
 801f9e8:	4603      	mov	r3, r0
 801f9ea:	0fda      	lsrs	r2, r3, #31
 801f9ec:	4413      	add	r3, r2
 801f9ee:	105b      	asrs	r3, r3, #1
 801f9f0:	b21b      	sxth	r3, r3
 801f9f2:	b29b      	uxth	r3, r3
 801f9f4:	1ae3      	subs	r3, r4, r3
 801f9f6:	b29b      	uxth	r3, r3
 801f9f8:	b21a      	sxth	r2, r3
 801f9fa:	683b      	ldr	r3, [r7, #0]
 801f9fc:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
 801f9fe:	68f8      	ldr	r0, [r7, #12]
 801fa00:	f7ff fcc5 	bl	801f38e <lv_area_get_height>
 801fa04:	4603      	mov	r3, r0
 801fa06:	0fda      	lsrs	r2, r3, #31
 801fa08:	4413      	add	r3, r2
 801fa0a:	105b      	asrs	r3, r3, #1
 801fa0c:	b21b      	sxth	r3, r3
 801fa0e:	b29c      	uxth	r4, r3
 801fa10:	68b8      	ldr	r0, [r7, #8]
 801fa12:	f7ff fcbc 	bl	801f38e <lv_area_get_height>
 801fa16:	4603      	mov	r3, r0
 801fa18:	0fda      	lsrs	r2, r3, #31
 801fa1a:	4413      	add	r3, r2
 801fa1c:	105b      	asrs	r3, r3, #1
 801fa1e:	b21b      	sxth	r3, r3
 801fa20:	b29b      	uxth	r3, r3
 801fa22:	1ae3      	subs	r3, r4, r3
 801fa24:	b29b      	uxth	r3, r3
 801fa26:	b21a      	sxth	r2, r3
 801fa28:	683b      	ldr	r3, [r7, #0]
 801fa2a:	805a      	strh	r2, [r3, #2]
            break;
 801fa2c:	e1e5      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_IN_TOP_LEFT:
            res->x = 0;
 801fa2e:	683b      	ldr	r3, [r7, #0]
 801fa30:	2200      	movs	r2, #0
 801fa32:	801a      	strh	r2, [r3, #0]
            res->y = 0;
 801fa34:	683b      	ldr	r3, [r7, #0]
 801fa36:	2200      	movs	r2, #0
 801fa38:	805a      	strh	r2, [r3, #2]
            break;
 801fa3a:	e1de      	b.n	801fdfa <_lv_area_align+0x49e>
        case LV_ALIGN_IN_TOP_MID:
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
 801fa3c:	68f8      	ldr	r0, [r7, #12]
 801fa3e:	f7ff fc8f 	bl	801f360 <lv_area_get_width>
 801fa42:	4603      	mov	r3, r0
 801fa44:	0fda      	lsrs	r2, r3, #31
 801fa46:	4413      	add	r3, r2
 801fa48:	105b      	asrs	r3, r3, #1
 801fa4a:	b21b      	sxth	r3, r3
 801fa4c:	b29c      	uxth	r4, r3
 801fa4e:	68b8      	ldr	r0, [r7, #8]
 801fa50:	f7ff fc86 	bl	801f360 <lv_area_get_width>
 801fa54:	4603      	mov	r3, r0
 801fa56:	0fda      	lsrs	r2, r3, #31
 801fa58:	4413      	add	r3, r2
 801fa5a:	105b      	asrs	r3, r3, #1
 801fa5c:	b21b      	sxth	r3, r3
 801fa5e:	b29b      	uxth	r3, r3
 801fa60:	1ae3      	subs	r3, r4, r3
 801fa62:	b29b      	uxth	r3, r3
 801fa64:	b21a      	sxth	r2, r3
 801fa66:	683b      	ldr	r3, [r7, #0]
 801fa68:	801a      	strh	r2, [r3, #0]
            res->y = 0;
 801fa6a:	683b      	ldr	r3, [r7, #0]
 801fa6c:	2200      	movs	r2, #0
 801fa6e:	805a      	strh	r2, [r3, #2]
            break;
 801fa70:	e1c3      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_IN_TOP_RIGHT:
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
 801fa72:	68f8      	ldr	r0, [r7, #12]
 801fa74:	f7ff fc74 	bl	801f360 <lv_area_get_width>
 801fa78:	4603      	mov	r3, r0
 801fa7a:	b29c      	uxth	r4, r3
 801fa7c:	68b8      	ldr	r0, [r7, #8]
 801fa7e:	f7ff fc6f 	bl	801f360 <lv_area_get_width>
 801fa82:	4603      	mov	r3, r0
 801fa84:	b29b      	uxth	r3, r3
 801fa86:	1ae3      	subs	r3, r4, r3
 801fa88:	b29b      	uxth	r3, r3
 801fa8a:	b21a      	sxth	r2, r3
 801fa8c:	683b      	ldr	r3, [r7, #0]
 801fa8e:	801a      	strh	r2, [r3, #0]
            res->y = 0;
 801fa90:	683b      	ldr	r3, [r7, #0]
 801fa92:	2200      	movs	r2, #0
 801fa94:	805a      	strh	r2, [r3, #2]
            break;
 801fa96:	e1b0      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_IN_BOTTOM_LEFT:
            res->x = 0;
 801fa98:	683b      	ldr	r3, [r7, #0]
 801fa9a:	2200      	movs	r2, #0
 801fa9c:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) - lv_area_get_height(to_align);
 801fa9e:	68f8      	ldr	r0, [r7, #12]
 801faa0:	f7ff fc75 	bl	801f38e <lv_area_get_height>
 801faa4:	4603      	mov	r3, r0
 801faa6:	b29c      	uxth	r4, r3
 801faa8:	68b8      	ldr	r0, [r7, #8]
 801faaa:	f7ff fc70 	bl	801f38e <lv_area_get_height>
 801faae:	4603      	mov	r3, r0
 801fab0:	b29b      	uxth	r3, r3
 801fab2:	1ae3      	subs	r3, r4, r3
 801fab4:	b29b      	uxth	r3, r3
 801fab6:	b21a      	sxth	r2, r3
 801fab8:	683b      	ldr	r3, [r7, #0]
 801faba:	805a      	strh	r2, [r3, #2]
            break;
 801fabc:	e19d      	b.n	801fdfa <_lv_area_align+0x49e>
        case LV_ALIGN_IN_BOTTOM_MID:
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
 801fabe:	68f8      	ldr	r0, [r7, #12]
 801fac0:	f7ff fc4e 	bl	801f360 <lv_area_get_width>
 801fac4:	4603      	mov	r3, r0
 801fac6:	0fda      	lsrs	r2, r3, #31
 801fac8:	4413      	add	r3, r2
 801faca:	105b      	asrs	r3, r3, #1
 801facc:	b21b      	sxth	r3, r3
 801face:	b29c      	uxth	r4, r3
 801fad0:	68b8      	ldr	r0, [r7, #8]
 801fad2:	f7ff fc45 	bl	801f360 <lv_area_get_width>
 801fad6:	4603      	mov	r3, r0
 801fad8:	0fda      	lsrs	r2, r3, #31
 801fada:	4413      	add	r3, r2
 801fadc:	105b      	asrs	r3, r3, #1
 801fade:	b21b      	sxth	r3, r3
 801fae0:	b29b      	uxth	r3, r3
 801fae2:	1ae3      	subs	r3, r4, r3
 801fae4:	b29b      	uxth	r3, r3
 801fae6:	b21a      	sxth	r2, r3
 801fae8:	683b      	ldr	r3, [r7, #0]
 801faea:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) - lv_area_get_height(to_align);
 801faec:	68f8      	ldr	r0, [r7, #12]
 801faee:	f7ff fc4e 	bl	801f38e <lv_area_get_height>
 801faf2:	4603      	mov	r3, r0
 801faf4:	b29c      	uxth	r4, r3
 801faf6:	68b8      	ldr	r0, [r7, #8]
 801faf8:	f7ff fc49 	bl	801f38e <lv_area_get_height>
 801fafc:	4603      	mov	r3, r0
 801fafe:	b29b      	uxth	r3, r3
 801fb00:	1ae3      	subs	r3, r4, r3
 801fb02:	b29b      	uxth	r3, r3
 801fb04:	b21a      	sxth	r2, r3
 801fb06:	683b      	ldr	r3, [r7, #0]
 801fb08:	805a      	strh	r2, [r3, #2]
            break;
 801fb0a:	e176      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_IN_BOTTOM_RIGHT:
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
 801fb0c:	68f8      	ldr	r0, [r7, #12]
 801fb0e:	f7ff fc27 	bl	801f360 <lv_area_get_width>
 801fb12:	4603      	mov	r3, r0
 801fb14:	b29c      	uxth	r4, r3
 801fb16:	68b8      	ldr	r0, [r7, #8]
 801fb18:	f7ff fc22 	bl	801f360 <lv_area_get_width>
 801fb1c:	4603      	mov	r3, r0
 801fb1e:	b29b      	uxth	r3, r3
 801fb20:	1ae3      	subs	r3, r4, r3
 801fb22:	b29b      	uxth	r3, r3
 801fb24:	b21a      	sxth	r2, r3
 801fb26:	683b      	ldr	r3, [r7, #0]
 801fb28:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) - lv_area_get_height(to_align);
 801fb2a:	68f8      	ldr	r0, [r7, #12]
 801fb2c:	f7ff fc2f 	bl	801f38e <lv_area_get_height>
 801fb30:	4603      	mov	r3, r0
 801fb32:	b29c      	uxth	r4, r3
 801fb34:	68b8      	ldr	r0, [r7, #8]
 801fb36:	f7ff fc2a 	bl	801f38e <lv_area_get_height>
 801fb3a:	4603      	mov	r3, r0
 801fb3c:	b29b      	uxth	r3, r3
 801fb3e:	1ae3      	subs	r3, r4, r3
 801fb40:	b29b      	uxth	r3, r3
 801fb42:	b21a      	sxth	r2, r3
 801fb44:	683b      	ldr	r3, [r7, #0]
 801fb46:	805a      	strh	r2, [r3, #2]
            break;
 801fb48:	e157      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_IN_LEFT_MID:
            res->x = 0;
 801fb4a:	683b      	ldr	r3, [r7, #0]
 801fb4c:	2200      	movs	r2, #0
 801fb4e:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
 801fb50:	68f8      	ldr	r0, [r7, #12]
 801fb52:	f7ff fc1c 	bl	801f38e <lv_area_get_height>
 801fb56:	4603      	mov	r3, r0
 801fb58:	0fda      	lsrs	r2, r3, #31
 801fb5a:	4413      	add	r3, r2
 801fb5c:	105b      	asrs	r3, r3, #1
 801fb5e:	b21b      	sxth	r3, r3
 801fb60:	b29c      	uxth	r4, r3
 801fb62:	68b8      	ldr	r0, [r7, #8]
 801fb64:	f7ff fc13 	bl	801f38e <lv_area_get_height>
 801fb68:	4603      	mov	r3, r0
 801fb6a:	0fda      	lsrs	r2, r3, #31
 801fb6c:	4413      	add	r3, r2
 801fb6e:	105b      	asrs	r3, r3, #1
 801fb70:	b21b      	sxth	r3, r3
 801fb72:	b29b      	uxth	r3, r3
 801fb74:	1ae3      	subs	r3, r4, r3
 801fb76:	b29b      	uxth	r3, r3
 801fb78:	b21a      	sxth	r2, r3
 801fb7a:	683b      	ldr	r3, [r7, #0]
 801fb7c:	805a      	strh	r2, [r3, #2]
            break;
 801fb7e:	e13c      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_IN_RIGHT_MID:
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
 801fb80:	68f8      	ldr	r0, [r7, #12]
 801fb82:	f7ff fbed 	bl	801f360 <lv_area_get_width>
 801fb86:	4603      	mov	r3, r0
 801fb88:	b29c      	uxth	r4, r3
 801fb8a:	68b8      	ldr	r0, [r7, #8]
 801fb8c:	f7ff fbe8 	bl	801f360 <lv_area_get_width>
 801fb90:	4603      	mov	r3, r0
 801fb92:	b29b      	uxth	r3, r3
 801fb94:	1ae3      	subs	r3, r4, r3
 801fb96:	b29b      	uxth	r3, r3
 801fb98:	b21a      	sxth	r2, r3
 801fb9a:	683b      	ldr	r3, [r7, #0]
 801fb9c:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
 801fb9e:	68f8      	ldr	r0, [r7, #12]
 801fba0:	f7ff fbf5 	bl	801f38e <lv_area_get_height>
 801fba4:	4603      	mov	r3, r0
 801fba6:	0fda      	lsrs	r2, r3, #31
 801fba8:	4413      	add	r3, r2
 801fbaa:	105b      	asrs	r3, r3, #1
 801fbac:	b21b      	sxth	r3, r3
 801fbae:	b29c      	uxth	r4, r3
 801fbb0:	68b8      	ldr	r0, [r7, #8]
 801fbb2:	f7ff fbec 	bl	801f38e <lv_area_get_height>
 801fbb6:	4603      	mov	r3, r0
 801fbb8:	0fda      	lsrs	r2, r3, #31
 801fbba:	4413      	add	r3, r2
 801fbbc:	105b      	asrs	r3, r3, #1
 801fbbe:	b21b      	sxth	r3, r3
 801fbc0:	b29b      	uxth	r3, r3
 801fbc2:	1ae3      	subs	r3, r4, r3
 801fbc4:	b29b      	uxth	r3, r3
 801fbc6:	b21a      	sxth	r2, r3
 801fbc8:	683b      	ldr	r3, [r7, #0]
 801fbca:	805a      	strh	r2, [r3, #2]
            break;
 801fbcc:	e115      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_TOP_LEFT:
            res->x = 0;
 801fbce:	683b      	ldr	r3, [r7, #0]
 801fbd0:	2200      	movs	r2, #0
 801fbd2:	801a      	strh	r2, [r3, #0]
            res->y = -lv_area_get_height(to_align);
 801fbd4:	68b8      	ldr	r0, [r7, #8]
 801fbd6:	f7ff fbda 	bl	801f38e <lv_area_get_height>
 801fbda:	4603      	mov	r3, r0
 801fbdc:	b29b      	uxth	r3, r3
 801fbde:	425b      	negs	r3, r3
 801fbe0:	b29b      	uxth	r3, r3
 801fbe2:	b21a      	sxth	r2, r3
 801fbe4:	683b      	ldr	r3, [r7, #0]
 801fbe6:	805a      	strh	r2, [r3, #2]
            break;
 801fbe8:	e107      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_TOP_MID:
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
 801fbea:	68f8      	ldr	r0, [r7, #12]
 801fbec:	f7ff fbb8 	bl	801f360 <lv_area_get_width>
 801fbf0:	4603      	mov	r3, r0
 801fbf2:	0fda      	lsrs	r2, r3, #31
 801fbf4:	4413      	add	r3, r2
 801fbf6:	105b      	asrs	r3, r3, #1
 801fbf8:	b21b      	sxth	r3, r3
 801fbfa:	b29c      	uxth	r4, r3
 801fbfc:	68b8      	ldr	r0, [r7, #8]
 801fbfe:	f7ff fbaf 	bl	801f360 <lv_area_get_width>
 801fc02:	4603      	mov	r3, r0
 801fc04:	0fda      	lsrs	r2, r3, #31
 801fc06:	4413      	add	r3, r2
 801fc08:	105b      	asrs	r3, r3, #1
 801fc0a:	b21b      	sxth	r3, r3
 801fc0c:	b29b      	uxth	r3, r3
 801fc0e:	1ae3      	subs	r3, r4, r3
 801fc10:	b29b      	uxth	r3, r3
 801fc12:	b21a      	sxth	r2, r3
 801fc14:	683b      	ldr	r3, [r7, #0]
 801fc16:	801a      	strh	r2, [r3, #0]
            res->y = -lv_area_get_height(to_align);
 801fc18:	68b8      	ldr	r0, [r7, #8]
 801fc1a:	f7ff fbb8 	bl	801f38e <lv_area_get_height>
 801fc1e:	4603      	mov	r3, r0
 801fc20:	b29b      	uxth	r3, r3
 801fc22:	425b      	negs	r3, r3
 801fc24:	b29b      	uxth	r3, r3
 801fc26:	b21a      	sxth	r2, r3
 801fc28:	683b      	ldr	r3, [r7, #0]
 801fc2a:	805a      	strh	r2, [r3, #2]
            break;
 801fc2c:	e0e5      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_TOP_RIGHT:
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
 801fc2e:	68f8      	ldr	r0, [r7, #12]
 801fc30:	f7ff fb96 	bl	801f360 <lv_area_get_width>
 801fc34:	4603      	mov	r3, r0
 801fc36:	b29c      	uxth	r4, r3
 801fc38:	68b8      	ldr	r0, [r7, #8]
 801fc3a:	f7ff fb91 	bl	801f360 <lv_area_get_width>
 801fc3e:	4603      	mov	r3, r0
 801fc40:	b29b      	uxth	r3, r3
 801fc42:	1ae3      	subs	r3, r4, r3
 801fc44:	b29b      	uxth	r3, r3
 801fc46:	b21a      	sxth	r2, r3
 801fc48:	683b      	ldr	r3, [r7, #0]
 801fc4a:	801a      	strh	r2, [r3, #0]
            res->y = -lv_area_get_height(to_align);
 801fc4c:	68b8      	ldr	r0, [r7, #8]
 801fc4e:	f7ff fb9e 	bl	801f38e <lv_area_get_height>
 801fc52:	4603      	mov	r3, r0
 801fc54:	b29b      	uxth	r3, r3
 801fc56:	425b      	negs	r3, r3
 801fc58:	b29b      	uxth	r3, r3
 801fc5a:	b21a      	sxth	r2, r3
 801fc5c:	683b      	ldr	r3, [r7, #0]
 801fc5e:	805a      	strh	r2, [r3, #2]
            break;
 801fc60:	e0cb      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_BOTTOM_LEFT:
            res->x = 0;
 801fc62:	683b      	ldr	r3, [r7, #0]
 801fc64:	2200      	movs	r2, #0
 801fc66:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base);
 801fc68:	68f8      	ldr	r0, [r7, #12]
 801fc6a:	f7ff fb90 	bl	801f38e <lv_area_get_height>
 801fc6e:	4603      	mov	r3, r0
 801fc70:	461a      	mov	r2, r3
 801fc72:	683b      	ldr	r3, [r7, #0]
 801fc74:	805a      	strh	r2, [r3, #2]
            break;
 801fc76:	e0c0      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_BOTTOM_MID:
            res->x = lv_area_get_width(base) / 2 - lv_area_get_width(to_align) / 2;
 801fc78:	68f8      	ldr	r0, [r7, #12]
 801fc7a:	f7ff fb71 	bl	801f360 <lv_area_get_width>
 801fc7e:	4603      	mov	r3, r0
 801fc80:	0fda      	lsrs	r2, r3, #31
 801fc82:	4413      	add	r3, r2
 801fc84:	105b      	asrs	r3, r3, #1
 801fc86:	b21b      	sxth	r3, r3
 801fc88:	b29c      	uxth	r4, r3
 801fc8a:	68b8      	ldr	r0, [r7, #8]
 801fc8c:	f7ff fb68 	bl	801f360 <lv_area_get_width>
 801fc90:	4603      	mov	r3, r0
 801fc92:	0fda      	lsrs	r2, r3, #31
 801fc94:	4413      	add	r3, r2
 801fc96:	105b      	asrs	r3, r3, #1
 801fc98:	b21b      	sxth	r3, r3
 801fc9a:	b29b      	uxth	r3, r3
 801fc9c:	1ae3      	subs	r3, r4, r3
 801fc9e:	b29b      	uxth	r3, r3
 801fca0:	b21a      	sxth	r2, r3
 801fca2:	683b      	ldr	r3, [r7, #0]
 801fca4:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base);
 801fca6:	68f8      	ldr	r0, [r7, #12]
 801fca8:	f7ff fb71 	bl	801f38e <lv_area_get_height>
 801fcac:	4603      	mov	r3, r0
 801fcae:	461a      	mov	r2, r3
 801fcb0:	683b      	ldr	r3, [r7, #0]
 801fcb2:	805a      	strh	r2, [r3, #2]
            break;
 801fcb4:	e0a1      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_BOTTOM_RIGHT:
            res->x = lv_area_get_width(base) - lv_area_get_width(to_align);
 801fcb6:	68f8      	ldr	r0, [r7, #12]
 801fcb8:	f7ff fb52 	bl	801f360 <lv_area_get_width>
 801fcbc:	4603      	mov	r3, r0
 801fcbe:	b29c      	uxth	r4, r3
 801fcc0:	68b8      	ldr	r0, [r7, #8]
 801fcc2:	f7ff fb4d 	bl	801f360 <lv_area_get_width>
 801fcc6:	4603      	mov	r3, r0
 801fcc8:	b29b      	uxth	r3, r3
 801fcca:	1ae3      	subs	r3, r4, r3
 801fccc:	b29b      	uxth	r3, r3
 801fcce:	b21a      	sxth	r2, r3
 801fcd0:	683b      	ldr	r3, [r7, #0]
 801fcd2:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base);
 801fcd4:	68f8      	ldr	r0, [r7, #12]
 801fcd6:	f7ff fb5a 	bl	801f38e <lv_area_get_height>
 801fcda:	4603      	mov	r3, r0
 801fcdc:	461a      	mov	r2, r3
 801fcde:	683b      	ldr	r3, [r7, #0]
 801fce0:	805a      	strh	r2, [r3, #2]
            break;
 801fce2:	e08a      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_LEFT_TOP:
            res->x = -lv_area_get_width(to_align);
 801fce4:	68b8      	ldr	r0, [r7, #8]
 801fce6:	f7ff fb3b 	bl	801f360 <lv_area_get_width>
 801fcea:	4603      	mov	r3, r0
 801fcec:	b29b      	uxth	r3, r3
 801fcee:	425b      	negs	r3, r3
 801fcf0:	b29b      	uxth	r3, r3
 801fcf2:	b21a      	sxth	r2, r3
 801fcf4:	683b      	ldr	r3, [r7, #0]
 801fcf6:	801a      	strh	r2, [r3, #0]
            res->y = 0;
 801fcf8:	683b      	ldr	r3, [r7, #0]
 801fcfa:	2200      	movs	r2, #0
 801fcfc:	805a      	strh	r2, [r3, #2]
            break;
 801fcfe:	e07c      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_LEFT_MID:
            res->x = -lv_area_get_width(to_align);
 801fd00:	68b8      	ldr	r0, [r7, #8]
 801fd02:	f7ff fb2d 	bl	801f360 <lv_area_get_width>
 801fd06:	4603      	mov	r3, r0
 801fd08:	b29b      	uxth	r3, r3
 801fd0a:	425b      	negs	r3, r3
 801fd0c:	b29b      	uxth	r3, r3
 801fd0e:	b21a      	sxth	r2, r3
 801fd10:	683b      	ldr	r3, [r7, #0]
 801fd12:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
 801fd14:	68f8      	ldr	r0, [r7, #12]
 801fd16:	f7ff fb3a 	bl	801f38e <lv_area_get_height>
 801fd1a:	4603      	mov	r3, r0
 801fd1c:	0fda      	lsrs	r2, r3, #31
 801fd1e:	4413      	add	r3, r2
 801fd20:	105b      	asrs	r3, r3, #1
 801fd22:	b21b      	sxth	r3, r3
 801fd24:	b29c      	uxth	r4, r3
 801fd26:	68b8      	ldr	r0, [r7, #8]
 801fd28:	f7ff fb31 	bl	801f38e <lv_area_get_height>
 801fd2c:	4603      	mov	r3, r0
 801fd2e:	0fda      	lsrs	r2, r3, #31
 801fd30:	4413      	add	r3, r2
 801fd32:	105b      	asrs	r3, r3, #1
 801fd34:	b21b      	sxth	r3, r3
 801fd36:	b29b      	uxth	r3, r3
 801fd38:	1ae3      	subs	r3, r4, r3
 801fd3a:	b29b      	uxth	r3, r3
 801fd3c:	b21a      	sxth	r2, r3
 801fd3e:	683b      	ldr	r3, [r7, #0]
 801fd40:	805a      	strh	r2, [r3, #2]
            break;
 801fd42:	e05a      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_LEFT_BOTTOM:
            res->x = -lv_area_get_width(to_align);
 801fd44:	68b8      	ldr	r0, [r7, #8]
 801fd46:	f7ff fb0b 	bl	801f360 <lv_area_get_width>
 801fd4a:	4603      	mov	r3, r0
 801fd4c:	b29b      	uxth	r3, r3
 801fd4e:	425b      	negs	r3, r3
 801fd50:	b29b      	uxth	r3, r3
 801fd52:	b21a      	sxth	r2, r3
 801fd54:	683b      	ldr	r3, [r7, #0]
 801fd56:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) - lv_area_get_height(to_align);
 801fd58:	68f8      	ldr	r0, [r7, #12]
 801fd5a:	f7ff fb18 	bl	801f38e <lv_area_get_height>
 801fd5e:	4603      	mov	r3, r0
 801fd60:	b29c      	uxth	r4, r3
 801fd62:	68b8      	ldr	r0, [r7, #8]
 801fd64:	f7ff fb13 	bl	801f38e <lv_area_get_height>
 801fd68:	4603      	mov	r3, r0
 801fd6a:	b29b      	uxth	r3, r3
 801fd6c:	1ae3      	subs	r3, r4, r3
 801fd6e:	b29b      	uxth	r3, r3
 801fd70:	b21a      	sxth	r2, r3
 801fd72:	683b      	ldr	r3, [r7, #0]
 801fd74:	805a      	strh	r2, [r3, #2]
            break;
 801fd76:	e040      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_RIGHT_TOP:
            res->x = lv_area_get_width(base);
 801fd78:	68f8      	ldr	r0, [r7, #12]
 801fd7a:	f7ff faf1 	bl	801f360 <lv_area_get_width>
 801fd7e:	4603      	mov	r3, r0
 801fd80:	461a      	mov	r2, r3
 801fd82:	683b      	ldr	r3, [r7, #0]
 801fd84:	801a      	strh	r2, [r3, #0]
            res->y = 0;
 801fd86:	683b      	ldr	r3, [r7, #0]
 801fd88:	2200      	movs	r2, #0
 801fd8a:	805a      	strh	r2, [r3, #2]
            break;
 801fd8c:	e035      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_RIGHT_MID:
            res->x = lv_area_get_width(base);
 801fd8e:	68f8      	ldr	r0, [r7, #12]
 801fd90:	f7ff fae6 	bl	801f360 <lv_area_get_width>
 801fd94:	4603      	mov	r3, r0
 801fd96:	461a      	mov	r2, r3
 801fd98:	683b      	ldr	r3, [r7, #0]
 801fd9a:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) / 2 - lv_area_get_height(to_align) / 2;
 801fd9c:	68f8      	ldr	r0, [r7, #12]
 801fd9e:	f7ff faf6 	bl	801f38e <lv_area_get_height>
 801fda2:	4603      	mov	r3, r0
 801fda4:	0fda      	lsrs	r2, r3, #31
 801fda6:	4413      	add	r3, r2
 801fda8:	105b      	asrs	r3, r3, #1
 801fdaa:	b21b      	sxth	r3, r3
 801fdac:	b29c      	uxth	r4, r3
 801fdae:	68b8      	ldr	r0, [r7, #8]
 801fdb0:	f7ff faed 	bl	801f38e <lv_area_get_height>
 801fdb4:	4603      	mov	r3, r0
 801fdb6:	0fda      	lsrs	r2, r3, #31
 801fdb8:	4413      	add	r3, r2
 801fdba:	105b      	asrs	r3, r3, #1
 801fdbc:	b21b      	sxth	r3, r3
 801fdbe:	b29b      	uxth	r3, r3
 801fdc0:	1ae3      	subs	r3, r4, r3
 801fdc2:	b29b      	uxth	r3, r3
 801fdc4:	b21a      	sxth	r2, r3
 801fdc6:	683b      	ldr	r3, [r7, #0]
 801fdc8:	805a      	strh	r2, [r3, #2]
            break;
 801fdca:	e016      	b.n	801fdfa <_lv_area_align+0x49e>

        case LV_ALIGN_OUT_RIGHT_BOTTOM:
            res->x = lv_area_get_width(base);
 801fdcc:	68f8      	ldr	r0, [r7, #12]
 801fdce:	f7ff fac7 	bl	801f360 <lv_area_get_width>
 801fdd2:	4603      	mov	r3, r0
 801fdd4:	461a      	mov	r2, r3
 801fdd6:	683b      	ldr	r3, [r7, #0]
 801fdd8:	801a      	strh	r2, [r3, #0]
            res->y = lv_area_get_height(base) - lv_area_get_height(to_align);
 801fdda:	68f8      	ldr	r0, [r7, #12]
 801fddc:	f7ff fad7 	bl	801f38e <lv_area_get_height>
 801fde0:	4603      	mov	r3, r0
 801fde2:	b29c      	uxth	r4, r3
 801fde4:	68b8      	ldr	r0, [r7, #8]
 801fde6:	f7ff fad2 	bl	801f38e <lv_area_get_height>
 801fdea:	4603      	mov	r3, r0
 801fdec:	b29b      	uxth	r3, r3
 801fdee:	1ae3      	subs	r3, r4, r3
 801fdf0:	b29b      	uxth	r3, r3
 801fdf2:	b21a      	sxth	r2, r3
 801fdf4:	683b      	ldr	r3, [r7, #0]
 801fdf6:	805a      	strh	r2, [r3, #2]
            break;
 801fdf8:	bf00      	nop
    }

    res->x += base->x1;
 801fdfa:	683b      	ldr	r3, [r7, #0]
 801fdfc:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fe00:	b29a      	uxth	r2, r3
 801fe02:	68fb      	ldr	r3, [r7, #12]
 801fe04:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fe08:	b29b      	uxth	r3, r3
 801fe0a:	4413      	add	r3, r2
 801fe0c:	b29b      	uxth	r3, r3
 801fe0e:	b21a      	sxth	r2, r3
 801fe10:	683b      	ldr	r3, [r7, #0]
 801fe12:	801a      	strh	r2, [r3, #0]
    res->y += base->y1;
 801fe14:	683b      	ldr	r3, [r7, #0]
 801fe16:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801fe1a:	b29a      	uxth	r2, r3
 801fe1c:	68fb      	ldr	r3, [r7, #12]
 801fe1e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801fe22:	b29b      	uxth	r3, r3
 801fe24:	4413      	add	r3, r2
 801fe26:	b29b      	uxth	r3, r3
 801fe28:	b21a      	sxth	r2, r3
 801fe2a:	683b      	ldr	r3, [r7, #0]
 801fe2c:	805a      	strh	r2, [r3, #2]
}
 801fe2e:	bf00      	nop
 801fe30:	3714      	adds	r7, #20
 801fe32:	46bd      	mov	sp, r7
 801fe34:	bd90      	pop	{r4, r7, pc}
 801fe36:	bf00      	nop

0801fe38 <lv_point_within_circle>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static bool lv_point_within_circle(const lv_area_t * area, const lv_point_t * p)
{
 801fe38:	b480      	push	{r7}
 801fe3a:	b089      	sub	sp, #36	; 0x24
 801fe3c:	af00      	add	r7, sp, #0
 801fe3e:	6078      	str	r0, [r7, #4]
 801fe40:	6039      	str	r1, [r7, #0]
    lv_coord_t r = (area->x2 - area->x1) / 2;
 801fe42:	687b      	ldr	r3, [r7, #4]
 801fe44:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801fe48:	461a      	mov	r2, r3
 801fe4a:	687b      	ldr	r3, [r7, #4]
 801fe4c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fe50:	1ad3      	subs	r3, r2, r3
 801fe52:	0fda      	lsrs	r2, r3, #31
 801fe54:	4413      	add	r3, r2
 801fe56:	105b      	asrs	r3, r3, #1
 801fe58:	83fb      	strh	r3, [r7, #30]

    /* Circle center */
    lv_coord_t cx = area->x1 + r;
 801fe5a:	687b      	ldr	r3, [r7, #4]
 801fe5c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fe60:	b29a      	uxth	r2, r3
 801fe62:	8bfb      	ldrh	r3, [r7, #30]
 801fe64:	4413      	add	r3, r2
 801fe66:	b29b      	uxth	r3, r3
 801fe68:	83bb      	strh	r3, [r7, #28]
    lv_coord_t cy = area->y1 + r;
 801fe6a:	687b      	ldr	r3, [r7, #4]
 801fe6c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801fe70:	b29a      	uxth	r2, r3
 801fe72:	8bfb      	ldrh	r3, [r7, #30]
 801fe74:	4413      	add	r3, r2
 801fe76:	b29b      	uxth	r3, r3
 801fe78:	837b      	strh	r3, [r7, #26]

    /*Simplify the code by moving everything to (0, 0) */
    lv_coord_t px = p->x - cx;
 801fe7a:	683b      	ldr	r3, [r7, #0]
 801fe7c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fe80:	b29a      	uxth	r2, r3
 801fe82:	8bbb      	ldrh	r3, [r7, #28]
 801fe84:	1ad3      	subs	r3, r2, r3
 801fe86:	b29b      	uxth	r3, r3
 801fe88:	833b      	strh	r3, [r7, #24]
    lv_coord_t py = p->y - cy;
 801fe8a:	683b      	ldr	r3, [r7, #0]
 801fe8c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801fe90:	b29a      	uxth	r2, r3
 801fe92:	8b7b      	ldrh	r3, [r7, #26]
 801fe94:	1ad3      	subs	r3, r2, r3
 801fe96:	b29b      	uxth	r3, r3
 801fe98:	82fb      	strh	r3, [r7, #22]

    int32_t r_sqrd = r * r;
 801fe9a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801fe9e:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 801fea2:	fb02 f303 	mul.w	r3, r2, r3
 801fea6:	613b      	str	r3, [r7, #16]
    int32_t dist = (px * px) + (py * py);
 801fea8:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801feac:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 801feb0:	fb03 f202 	mul.w	r2, r3, r2
 801feb4:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801feb8:	f9b7 1016 	ldrsh.w	r1, [r7, #22]
 801febc:	fb01 f303 	mul.w	r3, r1, r3
 801fec0:	4413      	add	r3, r2
 801fec2:	60fb      	str	r3, [r7, #12]

    if(dist <= r_sqrd)
 801fec4:	68fa      	ldr	r2, [r7, #12]
 801fec6:	693b      	ldr	r3, [r7, #16]
 801fec8:	429a      	cmp	r2, r3
 801feca:	dc01      	bgt.n	801fed0 <lv_point_within_circle+0x98>
        return true;
 801fecc:	2301      	movs	r3, #1
 801fece:	e000      	b.n	801fed2 <lv_point_within_circle+0x9a>
    else
        return false;
 801fed0:	2300      	movs	r3, #0
}
 801fed2:	4618      	mov	r0, r3
 801fed4:	3724      	adds	r7, #36	; 0x24
 801fed6:	46bd      	mov	sp, r7
 801fed8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fedc:	4770      	bx	lr

0801fede <lv_color_mix>:
 * @param c2 the second color to mix (usually the background)
 * @param mix The ratio of the colors. 0: full `c2`, 255: full `c1`, 127: half `c1` and half`c2`
 * @return the mixed color
 */
LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
 801fede:	b480      	push	{r7}
 801fee0:	b085      	sub	sp, #20
 801fee2:	af00      	add	r7, sp, #0
 801fee4:	80b8      	strh	r0, [r7, #4]
 801fee6:	8039      	strh	r1, [r7, #0]
 801fee8:	4613      	mov	r3, r2
 801feea:	70fb      	strb	r3, [r7, #3]
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
 801feec:	797b      	ldrb	r3, [r7, #5]
 801feee:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801fef2:	b2db      	uxtb	r3, r3
 801fef4:	461a      	mov	r2, r3
 801fef6:	78fb      	ldrb	r3, [r7, #3]
 801fef8:	fb03 f202 	mul.w	r2, r3, r2
 801fefc:	787b      	ldrb	r3, [r7, #1]
 801fefe:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801ff02:	b2db      	uxtb	r3, r3
 801ff04:	4619      	mov	r1, r3
 801ff06:	78fb      	ldrb	r3, [r7, #3]
 801ff08:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801ff0c:	fb01 f303 	mul.w	r3, r1, r3
 801ff10:	4413      	add	r3, r2
 801ff12:	3380      	adds	r3, #128	; 0x80
 801ff14:	461a      	mov	r2, r3
 801ff16:	4613      	mov	r3, r2
 801ff18:	021b      	lsls	r3, r3, #8
 801ff1a:	4413      	add	r3, r2
 801ff1c:	01db      	lsls	r3, r3, #7
 801ff1e:	4413      	add	r3, r2
 801ff20:	0ddb      	lsrs	r3, r3, #23
 801ff22:	f003 031f 	and.w	r3, r3, #31
 801ff26:	b2da      	uxtb	r2, r3
 801ff28:	7b7b      	ldrb	r3, [r7, #13]
 801ff2a:	f362 03c7 	bfi	r3, r2, #3, #5
 801ff2e:	737b      	strb	r3, [r7, #13]
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
 801ff30:	88bb      	ldrh	r3, [r7, #4]
 801ff32:	f3c3 1345 	ubfx	r3, r3, #5, #6
 801ff36:	b2db      	uxtb	r3, r3
 801ff38:	461a      	mov	r2, r3
 801ff3a:	78fb      	ldrb	r3, [r7, #3]
 801ff3c:	fb03 f202 	mul.w	r2, r3, r2
 801ff40:	883b      	ldrh	r3, [r7, #0]
 801ff42:	f3c3 1345 	ubfx	r3, r3, #5, #6
 801ff46:	b2db      	uxtb	r3, r3
 801ff48:	4619      	mov	r1, r3
 801ff4a:	78fb      	ldrb	r3, [r7, #3]
 801ff4c:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801ff50:	fb01 f303 	mul.w	r3, r1, r3
 801ff54:	4413      	add	r3, r2
 801ff56:	3380      	adds	r3, #128	; 0x80
 801ff58:	461a      	mov	r2, r3
 801ff5a:	4613      	mov	r3, r2
 801ff5c:	021b      	lsls	r3, r3, #8
 801ff5e:	4413      	add	r3, r2
 801ff60:	01db      	lsls	r3, r3, #7
 801ff62:	4413      	add	r3, r2
 801ff64:	0ddb      	lsrs	r3, r3, #23
 801ff66:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801ff6a:	b2da      	uxtb	r2, r3
 801ff6c:	89bb      	ldrh	r3, [r7, #12]
 801ff6e:	f362 134a 	bfi	r3, r2, #5, #6
 801ff72:	81bb      	strh	r3, [r7, #12]
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
 801ff74:	793b      	ldrb	r3, [r7, #4]
 801ff76:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801ff7a:	b2db      	uxtb	r3, r3
 801ff7c:	461a      	mov	r2, r3
 801ff7e:	78fb      	ldrb	r3, [r7, #3]
 801ff80:	fb03 f202 	mul.w	r2, r3, r2
 801ff84:	783b      	ldrb	r3, [r7, #0]
 801ff86:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801ff8a:	b2db      	uxtb	r3, r3
 801ff8c:	4619      	mov	r1, r3
 801ff8e:	78fb      	ldrb	r3, [r7, #3]
 801ff90:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801ff94:	fb01 f303 	mul.w	r3, r1, r3
 801ff98:	4413      	add	r3, r2
 801ff9a:	3380      	adds	r3, #128	; 0x80
 801ff9c:	461a      	mov	r2, r3
 801ff9e:	4613      	mov	r3, r2
 801ffa0:	021b      	lsls	r3, r3, #8
 801ffa2:	4413      	add	r3, r2
 801ffa4:	01db      	lsls	r3, r3, #7
 801ffa6:	4413      	add	r3, r2
 801ffa8:	0ddb      	lsrs	r3, r3, #23
 801ffaa:	f003 031f 	and.w	r3, r3, #31
 801ffae:	b2da      	uxtb	r2, r3
 801ffb0:	7b3b      	ldrb	r3, [r7, #12]
 801ffb2:	f362 0304 	bfi	r3, r2, #0, #5
 801ffb6:	733b      	strb	r3, [r7, #12]
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
 801ffb8:	89bb      	ldrh	r3, [r7, #12]
}
 801ffba:	4618      	mov	r0, r3
 801ffbc:	3714      	adds	r7, #20
 801ffbe:	46bd      	mov	sp, r7
 801ffc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ffc4:	4770      	bx	lr

0801ffc6 <lv_color_fill>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

LV_ATTRIBUTE_FAST_MEM void lv_color_fill(lv_color_t * buf, lv_color_t color, uint32_t px_num)
{
 801ffc6:	b480      	push	{r7}
 801ffc8:	b089      	sub	sp, #36	; 0x24
 801ffca:	af00      	add	r7, sp, #0
 801ffcc:	60f8      	str	r0, [r7, #12]
 801ffce:	8139      	strh	r1, [r7, #8]
 801ffd0:	607a      	str	r2, [r7, #4]
#if LV_COLOR_DEPTH == 16
    uintptr_t buf_int = (uintptr_t) buf;
 801ffd2:	68fb      	ldr	r3, [r7, #12]
 801ffd4:	61bb      	str	r3, [r7, #24]
    if(buf_int & 0x3) {
 801ffd6:	69bb      	ldr	r3, [r7, #24]
 801ffd8:	f003 0303 	and.w	r3, r3, #3
 801ffdc:	2b00      	cmp	r3, #0
 801ffde:	d008      	beq.n	801fff2 <lv_color_fill+0x2c>
        *buf = color;
 801ffe0:	68fb      	ldr	r3, [r7, #12]
 801ffe2:	893a      	ldrh	r2, [r7, #8]
 801ffe4:	801a      	strh	r2, [r3, #0]
        buf++;
 801ffe6:	68fb      	ldr	r3, [r7, #12]
 801ffe8:	3302      	adds	r3, #2
 801ffea:	60fb      	str	r3, [r7, #12]
        px_num--;
 801ffec:	687b      	ldr	r3, [r7, #4]
 801ffee:	3b01      	subs	r3, #1
 801fff0:	607b      	str	r3, [r7, #4]
    }

    uint32_t c32 = color.full + (color.full << 16);
 801fff2:	893b      	ldrh	r3, [r7, #8]
 801fff4:	461a      	mov	r2, r3
 801fff6:	893b      	ldrh	r3, [r7, #8]
 801fff8:	041b      	lsls	r3, r3, #16
 801fffa:	4413      	add	r3, r2
 801fffc:	617b      	str	r3, [r7, #20]
    uint32_t * buf32 = (uint32_t *)buf;
 801fffe:	68fb      	ldr	r3, [r7, #12]
 8020000:	61fb      	str	r3, [r7, #28]

    while(px_num > 16) {
 8020002:	e032      	b.n	802006a <lv_color_fill+0xa4>
        *buf32 = c32;
 8020004:	69fb      	ldr	r3, [r7, #28]
 8020006:	697a      	ldr	r2, [r7, #20]
 8020008:	601a      	str	r2, [r3, #0]
        buf32++;
 802000a:	69fb      	ldr	r3, [r7, #28]
 802000c:	3304      	adds	r3, #4
 802000e:	61fb      	str	r3, [r7, #28]
        *buf32 = c32;
 8020010:	69fb      	ldr	r3, [r7, #28]
 8020012:	697a      	ldr	r2, [r7, #20]
 8020014:	601a      	str	r2, [r3, #0]
        buf32++;
 8020016:	69fb      	ldr	r3, [r7, #28]
 8020018:	3304      	adds	r3, #4
 802001a:	61fb      	str	r3, [r7, #28]
        *buf32 = c32;
 802001c:	69fb      	ldr	r3, [r7, #28]
 802001e:	697a      	ldr	r2, [r7, #20]
 8020020:	601a      	str	r2, [r3, #0]
        buf32++;
 8020022:	69fb      	ldr	r3, [r7, #28]
 8020024:	3304      	adds	r3, #4
 8020026:	61fb      	str	r3, [r7, #28]
        *buf32 = c32;
 8020028:	69fb      	ldr	r3, [r7, #28]
 802002a:	697a      	ldr	r2, [r7, #20]
 802002c:	601a      	str	r2, [r3, #0]
        buf32++;
 802002e:	69fb      	ldr	r3, [r7, #28]
 8020030:	3304      	adds	r3, #4
 8020032:	61fb      	str	r3, [r7, #28]

        *buf32 = c32;
 8020034:	69fb      	ldr	r3, [r7, #28]
 8020036:	697a      	ldr	r2, [r7, #20]
 8020038:	601a      	str	r2, [r3, #0]
        buf32++;
 802003a:	69fb      	ldr	r3, [r7, #28]
 802003c:	3304      	adds	r3, #4
 802003e:	61fb      	str	r3, [r7, #28]
        *buf32 = c32;
 8020040:	69fb      	ldr	r3, [r7, #28]
 8020042:	697a      	ldr	r2, [r7, #20]
 8020044:	601a      	str	r2, [r3, #0]
        buf32++;
 8020046:	69fb      	ldr	r3, [r7, #28]
 8020048:	3304      	adds	r3, #4
 802004a:	61fb      	str	r3, [r7, #28]
        *buf32 = c32;
 802004c:	69fb      	ldr	r3, [r7, #28]
 802004e:	697a      	ldr	r2, [r7, #20]
 8020050:	601a      	str	r2, [r3, #0]
        buf32++;
 8020052:	69fb      	ldr	r3, [r7, #28]
 8020054:	3304      	adds	r3, #4
 8020056:	61fb      	str	r3, [r7, #28]
        *buf32 = c32;
 8020058:	69fb      	ldr	r3, [r7, #28]
 802005a:	697a      	ldr	r2, [r7, #20]
 802005c:	601a      	str	r2, [r3, #0]
        buf32++;
 802005e:	69fb      	ldr	r3, [r7, #28]
 8020060:	3304      	adds	r3, #4
 8020062:	61fb      	str	r3, [r7, #28]

        px_num -= 16;
 8020064:	687b      	ldr	r3, [r7, #4]
 8020066:	3b10      	subs	r3, #16
 8020068:	607b      	str	r3, [r7, #4]
    while(px_num > 16) {
 802006a:	687b      	ldr	r3, [r7, #4]
 802006c:	2b10      	cmp	r3, #16
 802006e:	d8c9      	bhi.n	8020004 <lv_color_fill+0x3e>
    }

    buf = (lv_color_t *)buf32;
 8020070:	69fb      	ldr	r3, [r7, #28]
 8020072:	60fb      	str	r3, [r7, #12]

    while(px_num) {
 8020074:	e008      	b.n	8020088 <lv_color_fill+0xc2>
        *buf = color;
 8020076:	68fb      	ldr	r3, [r7, #12]
 8020078:	893a      	ldrh	r2, [r7, #8]
 802007a:	801a      	strh	r2, [r3, #0]
        buf++;
 802007c:	68fb      	ldr	r3, [r7, #12]
 802007e:	3302      	adds	r3, #2
 8020080:	60fb      	str	r3, [r7, #12]
        px_num --;
 8020082:	687b      	ldr	r3, [r7, #4]
 8020084:	3b01      	subs	r3, #1
 8020086:	607b      	str	r3, [r7, #4]
    while(px_num) {
 8020088:	687b      	ldr	r3, [r7, #4]
 802008a:	2b00      	cmp	r3, #0
 802008c:	d1f3      	bne.n	8020076 <lv_color_fill+0xb0>
        *buf = color;
        buf++;
        px_num --;
    }
#endif
}
 802008e:	bf00      	nop
 8020090:	bf00      	nop
 8020092:	3724      	adds	r7, #36	; 0x24
 8020094:	46bd      	mov	sp, r7
 8020096:	f85d 7b04 	ldr.w	r7, [sp], #4
 802009a:	4770      	bx	lr

0802009c <lv_color_lighten>:


lv_color_t lv_color_lighten(lv_color_t c, lv_opa_t lvl)
{
 802009c:	b580      	push	{r7, lr}
 802009e:	b082      	sub	sp, #8
 80200a0:	af00      	add	r7, sp, #0
 80200a2:	80b8      	strh	r0, [r7, #4]
 80200a4:	460b      	mov	r3, r1
 80200a6:	71fb      	strb	r3, [r7, #7]
    return lv_color_mix(LV_COLOR_WHITE, c, lvl);
 80200a8:	4b05      	ldr	r3, [pc, #20]	; (80200c0 <lv_color_lighten+0x24>)
 80200aa:	881b      	ldrh	r3, [r3, #0]
 80200ac:	79fa      	ldrb	r2, [r7, #7]
 80200ae:	88b9      	ldrh	r1, [r7, #4]
 80200b0:	4618      	mov	r0, r3
 80200b2:	f7ff ff14 	bl	801fede <lv_color_mix>
 80200b6:	4603      	mov	r3, r0
}
 80200b8:	4618      	mov	r0, r3
 80200ba:	3708      	adds	r7, #8
 80200bc:	46bd      	mov	sp, r7
 80200be:	bd80      	pop	{r7, pc}
 80200c0:	0802e4e0 	.word	0x0802e4e0

080200c4 <lv_color_darken>:


lv_color_t lv_color_darken(lv_color_t c, lv_opa_t lvl)
{
 80200c4:	b580      	push	{r7, lr}
 80200c6:	b082      	sub	sp, #8
 80200c8:	af00      	add	r7, sp, #0
 80200ca:	80b8      	strh	r0, [r7, #4]
 80200cc:	460a      	mov	r2, r1
 80200ce:	71fa      	strb	r2, [r7, #7]
    return lv_color_mix(LV_COLOR_BLACK, c, lvl);
 80200d0:	f36f 0304 	bfc	r3, #0, #5
 80200d4:	f36f 134a 	bfc	r3, #5, #6
 80200d8:	f36f 23cf 	bfc	r3, #11, #5
 80200dc:	79fa      	ldrb	r2, [r7, #7]
 80200de:	88b9      	ldrh	r1, [r7, #4]
 80200e0:	4618      	mov	r0, r3
 80200e2:	f7ff fefc 	bl	801fede <lv_color_mix>
 80200e6:	4603      	mov	r3, r0
}
 80200e8:	4618      	mov	r0, r3
 80200ea:	3708      	adds	r7, #8
 80200ec:	46bd      	mov	sp, r7
 80200ee:	bd80      	pop	{r7, pc}

080200f0 <lv_debug_check_null>:
/**********************
 *   GLOBAL FUNCTIONS
 **********************/

bool lv_debug_check_null(const void * p)
{
 80200f0:	b480      	push	{r7}
 80200f2:	b083      	sub	sp, #12
 80200f4:	af00      	add	r7, sp, #0
 80200f6:	6078      	str	r0, [r7, #4]
    if(p) return true;
 80200f8:	687b      	ldr	r3, [r7, #4]
 80200fa:	2b00      	cmp	r3, #0
 80200fc:	d001      	beq.n	8020102 <lv_debug_check_null+0x12>
 80200fe:	2301      	movs	r3, #1
 8020100:	e000      	b.n	8020104 <lv_debug_check_null+0x14>

    return false;
 8020102:	2300      	movs	r3, #0
}
 8020104:	4618      	mov	r0, r3
 8020106:	370c      	adds	r7, #12
 8020108:	46bd      	mov	sp, r7
 802010a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802010e:	4770      	bx	lr

08020110 <lv_debug_log_error>:
    LV_LOG_WARN("lv_debug_check_str: string is longer than LV_DEBUG_STR_MAX_LENGTH");
    return false;
}

void lv_debug_log_error(const char * msg, uint64_t value)
{
 8020110:	b580      	push	{r7, lr}
 8020112:	b0c8      	sub	sp, #288	; 0x120
 8020114:	af00      	add	r7, sp, #0
 8020116:	f507 7190 	add.w	r1, r7, #288	; 0x120
 802011a:	f5a1 718a 	sub.w	r1, r1, #276	; 0x114
 802011e:	6008      	str	r0, [r1, #0]
 8020120:	e9c7 2300 	strd	r2, r3, [r7]
    static const char hex[] = "0123456789ABCDEF";

    size_t msg_len = strlen(msg);
 8020124:	f507 7390 	add.w	r3, r7, #288	; 0x120
 8020128:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 802012c:	6818      	ldr	r0, [r3, #0]
 802012e:	f7e0 f867 	bl	8000200 <strlen>
 8020132:	f8c7 0114 	str.w	r0, [r7, #276]	; 0x114
    uint32_t value_len = sizeof(unsigned long int);
 8020136:	2304      	movs	r3, #4
 8020138:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110

    if(msg_len < 230) {
 802013c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8020140:	2be5      	cmp	r3, #229	; 0xe5
 8020142:	d876      	bhi.n	8020232 <lv_debug_log_error+0x122>
        char buf[255];
        char * bufp = buf;
 8020144:	f107 0310 	add.w	r3, r7, #16
 8020148:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

        /*Add the function name*/
        _lv_memcpy(bufp, msg, msg_len);
 802014c:	f507 7390 	add.w	r3, r7, #288	; 0x120
 8020150:	f5a3 738a 	sub.w	r3, r3, #276	; 0x114
 8020154:	f8d7 2114 	ldr.w	r2, [r7, #276]	; 0x114
 8020158:	6819      	ldr	r1, [r3, #0]
 802015a:	f8d7 011c 	ldr.w	r0, [r7, #284]	; 0x11c
 802015e:	f000 fffd 	bl	802115c <_lv_memcpy>
        bufp += msg_len;
 8020162:	f8d7 211c 	ldr.w	r2, [r7, #284]	; 0x11c
 8020166:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 802016a:	4413      	add	r3, r2
 802016c:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

        /*Add value in hey*/
        *bufp = ' ';
 8020170:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020174:	2220      	movs	r2, #32
 8020176:	701a      	strb	r2, [r3, #0]
        bufp ++;
 8020178:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 802017c:	3301      	adds	r3, #1
 802017e:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
        *bufp = '(';
 8020182:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020186:	2228      	movs	r2, #40	; 0x28
 8020188:	701a      	strb	r2, [r3, #0]
        bufp ++;
 802018a:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 802018e:	3301      	adds	r3, #1
 8020190:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
        *bufp = '0';
 8020194:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020198:	2230      	movs	r2, #48	; 0x30
 802019a:	701a      	strb	r2, [r3, #0]
        bufp ++;
 802019c:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80201a0:	3301      	adds	r3, #1
 80201a2:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
        *bufp = 'x';
 80201a6:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80201aa:	2278      	movs	r2, #120	; 0x78
 80201ac:	701a      	strb	r2, [r3, #0]
        bufp ++;
 80201ae:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80201b2:	3301      	adds	r3, #1
 80201b4:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

        int8_t i;
        for(i = value_len * 2 - 1; i >= 0; i--) {
 80201b8:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 80201bc:	b2db      	uxtb	r3, r3
 80201be:	005b      	lsls	r3, r3, #1
 80201c0:	b2db      	uxtb	r3, r3
 80201c2:	3b01      	subs	r3, #1
 80201c4:	b2db      	uxtb	r3, r3
 80201c6:	f887 311b 	strb.w	r3, [r7, #283]	; 0x11b
 80201ca:	e021      	b.n	8020210 <lv_debug_log_error+0x100>
            uint8_t x = (unsigned long int)((unsigned long int)value >> (i * 4)) & 0xF;
 80201cc:	f507 7390 	add.w	r3, r7, #288	; 0x120
 80201d0:	f5a3 7390 	sub.w	r3, r3, #288	; 0x120
 80201d4:	681a      	ldr	r2, [r3, #0]
 80201d6:	f997 311b 	ldrsb.w	r3, [r7, #283]	; 0x11b
 80201da:	009b      	lsls	r3, r3, #2
 80201dc:	fa22 f303 	lsr.w	r3, r2, r3
 80201e0:	b2db      	uxtb	r3, r3
 80201e2:	f003 030f 	and.w	r3, r3, #15
 80201e6:	f887 310f 	strb.w	r3, [r7, #271]	; 0x10f

            *bufp = hex[x];
 80201ea:	f897 310f 	ldrb.w	r3, [r7, #271]	; 0x10f
 80201ee:	4a13      	ldr	r2, [pc, #76]	; (802023c <lv_debug_log_error+0x12c>)
 80201f0:	5cd2      	ldrb	r2, [r2, r3]
 80201f2:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80201f6:	701a      	strb	r2, [r3, #0]
            bufp++;
 80201f8:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 80201fc:	3301      	adds	r3, #1
 80201fe:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
        for(i = value_len * 2 - 1; i >= 0; i--) {
 8020202:	f997 311b 	ldrsb.w	r3, [r7, #283]	; 0x11b
 8020206:	b2db      	uxtb	r3, r3
 8020208:	3b01      	subs	r3, #1
 802020a:	b2db      	uxtb	r3, r3
 802020c:	f887 311b 	strb.w	r3, [r7, #283]	; 0x11b
 8020210:	f997 311b 	ldrsb.w	r3, [r7, #283]	; 0x11b
 8020214:	2b00      	cmp	r3, #0
 8020216:	dad9      	bge.n	80201cc <lv_debug_log_error+0xbc>
        }

        *bufp = ')';
 8020218:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 802021c:	2229      	movs	r2, #41	; 0x29
 802021e:	701a      	strb	r2, [r3, #0]
        bufp ++;
 8020220:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8020224:	3301      	adds	r3, #1
 8020226:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c

        *bufp = '\0';
 802022a:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 802022e:	2200      	movs	r2, #0
 8020230:	701a      	strb	r2, [r3, #0]
        LV_LOG_ERROR(buf);
    }
    else {
        LV_LOG_ERROR(msg);
    }
}
 8020232:	bf00      	nop
 8020234:	f507 7790 	add.w	r7, r7, #288	; 0x120
 8020238:	46bd      	mov	sp, r7
 802023a:	bd80      	pop	{r7, pc}
 802023c:	080f2310 	.word	0x080f2310

08020240 <_lv_fs_init>:

/**
 * Initialize the File system interface
 */
void _lv_fs_init(void)
{
 8020240:	b580      	push	{r7, lr}
 8020242:	af00      	add	r7, sp, #0
    _lv_ll_init(&LV_GC_ROOT(_lv_drv_ll), sizeof(lv_fs_drv_t));
 8020244:	2144      	movs	r1, #68	; 0x44
 8020246:	4802      	ldr	r0, [pc, #8]	; (8020250 <_lv_fs_init+0x10>)
 8020248:	f000 f992 	bl	8020570 <_lv_ll_init>
}
 802024c:	bf00      	nop
 802024e:	bd80      	pop	{r7, pc}
 8020250:	2000a198 	.word	0x2000a198

08020254 <lv_fs_open>:
 * @param path path to the file beginning with the driver letter (e.g. S:/folder/file.txt)
 * @param mode read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR
 * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_open(lv_fs_file_t * file_p, const char * path, lv_fs_mode_t mode)
{
 8020254:	b5b0      	push	{r4, r5, r7, lr}
 8020256:	b088      	sub	sp, #32
 8020258:	af00      	add	r7, sp, #0
 802025a:	60f8      	str	r0, [r7, #12]
 802025c:	60b9      	str	r1, [r7, #8]
 802025e:	4613      	mov	r3, r2
 8020260:	71fb      	strb	r3, [r7, #7]
    file_p->drv    = NULL;
 8020262:	68fb      	ldr	r3, [r7, #12]
 8020264:	2200      	movs	r2, #0
 8020266:	605a      	str	r2, [r3, #4]
    file_p->file_d = NULL;
 8020268:	68fb      	ldr	r3, [r7, #12]
 802026a:	2200      	movs	r2, #0
 802026c:	601a      	str	r2, [r3, #0]

    if(path == NULL) return LV_FS_RES_INV_PARAM;
 802026e:	68bb      	ldr	r3, [r7, #8]
 8020270:	2b00      	cmp	r3, #0
 8020272:	d101      	bne.n	8020278 <lv_fs_open+0x24>
 8020274:	230b      	movs	r3, #11
 8020276:	e07b      	b.n	8020370 <lv_fs_open+0x11c>

    char letter = path[0];
 8020278:	68bb      	ldr	r3, [r7, #8]
 802027a:	781b      	ldrb	r3, [r3, #0]
 802027c:	77fb      	strb	r3, [r7, #31]

    file_p->drv = lv_fs_get_drv(letter);
 802027e:	7ffb      	ldrb	r3, [r7, #31]
 8020280:	4618      	mov	r0, r3
 8020282:	f000 f903 	bl	802048c <lv_fs_get_drv>
 8020286:	4602      	mov	r2, r0
 8020288:	68fb      	ldr	r3, [r7, #12]
 802028a:	605a      	str	r2, [r3, #4]

    if(file_p->drv == NULL) {
 802028c:	68fb      	ldr	r3, [r7, #12]
 802028e:	685b      	ldr	r3, [r3, #4]
 8020290:	2b00      	cmp	r3, #0
 8020292:	d104      	bne.n	802029e <lv_fs_open+0x4a>
        file_p->file_d = NULL;
 8020294:	68fb      	ldr	r3, [r7, #12]
 8020296:	2200      	movs	r2, #0
 8020298:	601a      	str	r2, [r3, #0]
        return LV_FS_RES_NOT_EX;
 802029a:	2303      	movs	r3, #3
 802029c:	e068      	b.n	8020370 <lv_fs_open+0x11c>
    }

    if(file_p->drv->ready_cb != NULL) {
 802029e:	68fb      	ldr	r3, [r7, #12]
 80202a0:	685b      	ldr	r3, [r3, #4]
 80202a2:	689b      	ldr	r3, [r3, #8]
 80202a4:	2b00      	cmp	r3, #0
 80202a6:	d014      	beq.n	80202d2 <lv_fs_open+0x7e>
        if(file_p->drv->ready_cb(file_p->drv) == false) {
 80202a8:	68fb      	ldr	r3, [r7, #12]
 80202aa:	685b      	ldr	r3, [r3, #4]
 80202ac:	689b      	ldr	r3, [r3, #8]
 80202ae:	68fa      	ldr	r2, [r7, #12]
 80202b0:	6852      	ldr	r2, [r2, #4]
 80202b2:	4610      	mov	r0, r2
 80202b4:	4798      	blx	r3
 80202b6:	4603      	mov	r3, r0
 80202b8:	f083 0301 	eor.w	r3, r3, #1
 80202bc:	b2db      	uxtb	r3, r3
 80202be:	2b00      	cmp	r3, #0
 80202c0:	d007      	beq.n	80202d2 <lv_fs_open+0x7e>
            file_p->drv    = NULL;
 80202c2:	68fb      	ldr	r3, [r7, #12]
 80202c4:	2200      	movs	r2, #0
 80202c6:	605a      	str	r2, [r3, #4]
            file_p->file_d = NULL;
 80202c8:	68fb      	ldr	r3, [r7, #12]
 80202ca:	2200      	movs	r2, #0
 80202cc:	601a      	str	r2, [r3, #0]
            return LV_FS_RES_HW_ERR;
 80202ce:	2301      	movs	r3, #1
 80202d0:	e04e      	b.n	8020370 <lv_fs_open+0x11c>
        }
    }

    file_p->file_d = lv_mem_alloc(file_p->drv->file_size);
 80202d2:	68fb      	ldr	r3, [r7, #12]
 80202d4:	685b      	ldr	r3, [r3, #4]
 80202d6:	885b      	ldrh	r3, [r3, #2]
 80202d8:	4618      	mov	r0, r3
 80202da:	f000 fc7b 	bl	8020bd4 <lv_mem_alloc>
 80202de:	4602      	mov	r2, r0
 80202e0:	68fb      	ldr	r3, [r7, #12]
 80202e2:	601a      	str	r2, [r3, #0]
    LV_ASSERT_MEM(file_p->file_d);
 80202e4:	68fb      	ldr	r3, [r7, #12]
 80202e6:	681b      	ldr	r3, [r3, #0]
 80202e8:	4618      	mov	r0, r3
 80202ea:	f7ff ff01 	bl	80200f0 <lv_debug_check_null>
 80202ee:	4603      	mov	r3, r0
 80202f0:	f083 0301 	eor.w	r3, r3, #1
 80202f4:	b2db      	uxtb	r3, r3
 80202f6:	2b00      	cmp	r3, #0
 80202f8:	d00b      	beq.n	8020312 <lv_fs_open+0xbe>
 80202fa:	68fb      	ldr	r3, [r7, #12]
 80202fc:	681b      	ldr	r3, [r3, #0]
 80202fe:	461a      	mov	r2, r3
 8020300:	2300      	movs	r3, #0
 8020302:	4614      	mov	r4, r2
 8020304:	461d      	mov	r5, r3
 8020306:	4622      	mov	r2, r4
 8020308:	462b      	mov	r3, r5
 802030a:	481b      	ldr	r0, [pc, #108]	; (8020378 <lv_fs_open+0x124>)
 802030c:	f7ff ff00 	bl	8020110 <lv_debug_log_error>
 8020310:	e7fe      	b.n	8020310 <lv_fs_open+0xbc>
    if(file_p->file_d == NULL) {
 8020312:	68fb      	ldr	r3, [r7, #12]
 8020314:	681b      	ldr	r3, [r3, #0]
 8020316:	2b00      	cmp	r3, #0
 8020318:	d104      	bne.n	8020324 <lv_fs_open+0xd0>
        file_p->drv = NULL;
 802031a:	68fb      	ldr	r3, [r7, #12]
 802031c:	2200      	movs	r2, #0
 802031e:	605a      	str	r2, [r3, #4]
        return LV_FS_RES_OUT_OF_MEM; /* Out of memory */
 8020320:	230a      	movs	r3, #10
 8020322:	e025      	b.n	8020370 <lv_fs_open+0x11c>
    }

    if(file_p->drv->open_cb == NULL) {
 8020324:	68fb      	ldr	r3, [r7, #12]
 8020326:	685b      	ldr	r3, [r3, #4]
 8020328:	68db      	ldr	r3, [r3, #12]
 802032a:	2b00      	cmp	r3, #0
 802032c:	d101      	bne.n	8020332 <lv_fs_open+0xde>
        return LV_FS_RES_NOT_IMP;
 802032e:	2309      	movs	r3, #9
 8020330:	e01e      	b.n	8020370 <lv_fs_open+0x11c>
    }

    const char * real_path = lv_fs_get_real_path(path);
 8020332:	68b8      	ldr	r0, [r7, #8]
 8020334:	f000 f8fa 	bl	802052c <lv_fs_get_real_path>
 8020338:	61b8      	str	r0, [r7, #24]
    lv_fs_res_t res        = file_p->drv->open_cb(file_p->drv, file_p->file_d, real_path, mode);
 802033a:	68fb      	ldr	r3, [r7, #12]
 802033c:	685b      	ldr	r3, [r3, #4]
 802033e:	68dc      	ldr	r4, [r3, #12]
 8020340:	68fb      	ldr	r3, [r7, #12]
 8020342:	6858      	ldr	r0, [r3, #4]
 8020344:	68fb      	ldr	r3, [r7, #12]
 8020346:	6819      	ldr	r1, [r3, #0]
 8020348:	79fb      	ldrb	r3, [r7, #7]
 802034a:	69ba      	ldr	r2, [r7, #24]
 802034c:	47a0      	blx	r4
 802034e:	4603      	mov	r3, r0
 8020350:	75fb      	strb	r3, [r7, #23]

    if(res != LV_FS_RES_OK) {
 8020352:	7dfb      	ldrb	r3, [r7, #23]
 8020354:	2b00      	cmp	r3, #0
 8020356:	d00a      	beq.n	802036e <lv_fs_open+0x11a>
        lv_mem_free(file_p->file_d);
 8020358:	68fb      	ldr	r3, [r7, #12]
 802035a:	681b      	ldr	r3, [r3, #0]
 802035c:	4618      	mov	r0, r3
 802035e:	f000 fc83 	bl	8020c68 <lv_mem_free>
        file_p->file_d = NULL;
 8020362:	68fb      	ldr	r3, [r7, #12]
 8020364:	2200      	movs	r2, #0
 8020366:	601a      	str	r2, [r3, #0]
        file_p->drv    = NULL;
 8020368:	68fb      	ldr	r3, [r7, #12]
 802036a:	2200      	movs	r2, #0
 802036c:	605a      	str	r2, [r3, #4]
    }

    return res;
 802036e:	7dfb      	ldrb	r3, [r7, #23]
}
 8020370:	4618      	mov	r0, r3
 8020372:	3720      	adds	r7, #32
 8020374:	46bd      	mov	sp, r7
 8020376:	bdb0      	pop	{r4, r5, r7, pc}
 8020378:	0802e4e4 	.word	0x0802e4e4

0802037c <lv_fs_close>:
 * Close an already opened file
 * @param file_p pointer to a lv_fs_file_t variable
 * @return  LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_close(lv_fs_file_t * file_p)
{
 802037c:	b580      	push	{r7, lr}
 802037e:	b084      	sub	sp, #16
 8020380:	af00      	add	r7, sp, #0
 8020382:	6078      	str	r0, [r7, #4]
    if(file_p->drv == NULL) {
 8020384:	687b      	ldr	r3, [r7, #4]
 8020386:	685b      	ldr	r3, [r3, #4]
 8020388:	2b00      	cmp	r3, #0
 802038a:	d101      	bne.n	8020390 <lv_fs_close+0x14>
        return LV_FS_RES_INV_PARAM;
 802038c:	230b      	movs	r3, #11
 802038e:	e020      	b.n	80203d2 <lv_fs_close+0x56>
    }

    if(file_p->drv->close_cb == NULL) {
 8020390:	687b      	ldr	r3, [r7, #4]
 8020392:	685b      	ldr	r3, [r3, #4]
 8020394:	691b      	ldr	r3, [r3, #16]
 8020396:	2b00      	cmp	r3, #0
 8020398:	d101      	bne.n	802039e <lv_fs_close+0x22>
        return LV_FS_RES_NOT_IMP;
 802039a:	2309      	movs	r3, #9
 802039c:	e019      	b.n	80203d2 <lv_fs_close+0x56>
    }

    lv_fs_res_t res = file_p->drv->close_cb(file_p->drv, file_p->file_d);
 802039e:	687b      	ldr	r3, [r7, #4]
 80203a0:	685b      	ldr	r3, [r3, #4]
 80203a2:	691b      	ldr	r3, [r3, #16]
 80203a4:	687a      	ldr	r2, [r7, #4]
 80203a6:	6850      	ldr	r0, [r2, #4]
 80203a8:	687a      	ldr	r2, [r7, #4]
 80203aa:	6812      	ldr	r2, [r2, #0]
 80203ac:	4611      	mov	r1, r2
 80203ae:	4798      	blx	r3
 80203b0:	4603      	mov	r3, r0
 80203b2:	73fb      	strb	r3, [r7, #15]

    lv_mem_free(file_p->file_d); /*Clean up*/
 80203b4:	687b      	ldr	r3, [r7, #4]
 80203b6:	681b      	ldr	r3, [r3, #0]
 80203b8:	4618      	mov	r0, r3
 80203ba:	f000 fc55 	bl	8020c68 <lv_mem_free>
    file_p->file_d = NULL;
 80203be:	687b      	ldr	r3, [r7, #4]
 80203c0:	2200      	movs	r2, #0
 80203c2:	601a      	str	r2, [r3, #0]
    file_p->drv    = NULL;
 80203c4:	687b      	ldr	r3, [r7, #4]
 80203c6:	2200      	movs	r2, #0
 80203c8:	605a      	str	r2, [r3, #4]
    file_p->file_d = NULL;
 80203ca:	687b      	ldr	r3, [r7, #4]
 80203cc:	2200      	movs	r2, #0
 80203ce:	601a      	str	r2, [r3, #0]

    return res;
 80203d0:	7bfb      	ldrb	r3, [r7, #15]
}
 80203d2:	4618      	mov	r0, r3
 80203d4:	3710      	adds	r7, #16
 80203d6:	46bd      	mov	sp, r7
 80203d8:	bd80      	pop	{r7, pc}

080203da <lv_fs_read>:
 * @param btr Bytes To Read
 * @param br the number of real read bytes (Bytes Read). NULL if unused.
 * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_read(lv_fs_file_t * file_p, void * buf, uint32_t btr, uint32_t * br)
{
 80203da:	b590      	push	{r4, r7, lr}
 80203dc:	b089      	sub	sp, #36	; 0x24
 80203de:	af02      	add	r7, sp, #8
 80203e0:	60f8      	str	r0, [r7, #12]
 80203e2:	60b9      	str	r1, [r7, #8]
 80203e4:	607a      	str	r2, [r7, #4]
 80203e6:	603b      	str	r3, [r7, #0]
    if(br != NULL) *br = 0;
 80203e8:	683b      	ldr	r3, [r7, #0]
 80203ea:	2b00      	cmp	r3, #0
 80203ec:	d002      	beq.n	80203f4 <lv_fs_read+0x1a>
 80203ee:	683b      	ldr	r3, [r7, #0]
 80203f0:	2200      	movs	r2, #0
 80203f2:	601a      	str	r2, [r3, #0]
    if(file_p->drv == NULL) return LV_FS_RES_INV_PARAM;
 80203f4:	68fb      	ldr	r3, [r7, #12]
 80203f6:	685b      	ldr	r3, [r3, #4]
 80203f8:	2b00      	cmp	r3, #0
 80203fa:	d101      	bne.n	8020400 <lv_fs_read+0x26>
 80203fc:	230b      	movs	r3, #11
 80203fe:	e01e      	b.n	802043e <lv_fs_read+0x64>
    if(file_p->drv->read_cb == NULL) return LV_FS_RES_NOT_IMP;
 8020400:	68fb      	ldr	r3, [r7, #12]
 8020402:	685b      	ldr	r3, [r3, #4]
 8020404:	699b      	ldr	r3, [r3, #24]
 8020406:	2b00      	cmp	r3, #0
 8020408:	d101      	bne.n	802040e <lv_fs_read+0x34>
 802040a:	2309      	movs	r3, #9
 802040c:	e017      	b.n	802043e <lv_fs_read+0x64>

    uint32_t br_tmp = 0;
 802040e:	2300      	movs	r3, #0
 8020410:	613b      	str	r3, [r7, #16]
    lv_fs_res_t res = file_p->drv->read_cb(file_p->drv, file_p->file_d, buf, btr, &br_tmp);
 8020412:	68fb      	ldr	r3, [r7, #12]
 8020414:	685b      	ldr	r3, [r3, #4]
 8020416:	699c      	ldr	r4, [r3, #24]
 8020418:	68fb      	ldr	r3, [r7, #12]
 802041a:	6858      	ldr	r0, [r3, #4]
 802041c:	68fb      	ldr	r3, [r7, #12]
 802041e:	6819      	ldr	r1, [r3, #0]
 8020420:	f107 0310 	add.w	r3, r7, #16
 8020424:	9300      	str	r3, [sp, #0]
 8020426:	687b      	ldr	r3, [r7, #4]
 8020428:	68ba      	ldr	r2, [r7, #8]
 802042a:	47a0      	blx	r4
 802042c:	4603      	mov	r3, r0
 802042e:	75fb      	strb	r3, [r7, #23]
    if(br != NULL) *br = br_tmp;
 8020430:	683b      	ldr	r3, [r7, #0]
 8020432:	2b00      	cmp	r3, #0
 8020434:	d002      	beq.n	802043c <lv_fs_read+0x62>
 8020436:	693a      	ldr	r2, [r7, #16]
 8020438:	683b      	ldr	r3, [r7, #0]
 802043a:	601a      	str	r2, [r3, #0]

    return res;
 802043c:	7dfb      	ldrb	r3, [r7, #23]
}
 802043e:	4618      	mov	r0, r3
 8020440:	371c      	adds	r7, #28
 8020442:	46bd      	mov	sp, r7
 8020444:	bd90      	pop	{r4, r7, pc}

08020446 <lv_fs_seek>:
 * @param file_p pointer to a lv_fs_file_t variable
 * @param pos the new position expressed in bytes index (0: start of file)
 * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_seek(lv_fs_file_t * file_p, uint32_t pos)
{
 8020446:	b580      	push	{r7, lr}
 8020448:	b084      	sub	sp, #16
 802044a:	af00      	add	r7, sp, #0
 802044c:	6078      	str	r0, [r7, #4]
 802044e:	6039      	str	r1, [r7, #0]
    if(file_p->drv == NULL) {
 8020450:	687b      	ldr	r3, [r7, #4]
 8020452:	685b      	ldr	r3, [r3, #4]
 8020454:	2b00      	cmp	r3, #0
 8020456:	d101      	bne.n	802045c <lv_fs_seek+0x16>
        return LV_FS_RES_INV_PARAM;
 8020458:	230b      	movs	r3, #11
 802045a:	e012      	b.n	8020482 <lv_fs_seek+0x3c>
    }

    if(file_p->drv->seek_cb == NULL) {
 802045c:	687b      	ldr	r3, [r7, #4]
 802045e:	685b      	ldr	r3, [r3, #4]
 8020460:	6a1b      	ldr	r3, [r3, #32]
 8020462:	2b00      	cmp	r3, #0
 8020464:	d101      	bne.n	802046a <lv_fs_seek+0x24>
        return LV_FS_RES_NOT_IMP;
 8020466:	2309      	movs	r3, #9
 8020468:	e00b      	b.n	8020482 <lv_fs_seek+0x3c>
    }

    lv_fs_res_t res = file_p->drv->seek_cb(file_p->drv, file_p->file_d, pos);
 802046a:	687b      	ldr	r3, [r7, #4]
 802046c:	685b      	ldr	r3, [r3, #4]
 802046e:	6a1b      	ldr	r3, [r3, #32]
 8020470:	687a      	ldr	r2, [r7, #4]
 8020472:	6850      	ldr	r0, [r2, #4]
 8020474:	687a      	ldr	r2, [r7, #4]
 8020476:	6811      	ldr	r1, [r2, #0]
 8020478:	683a      	ldr	r2, [r7, #0]
 802047a:	4798      	blx	r3
 802047c:	4603      	mov	r3, r0
 802047e:	73fb      	strb	r3, [r7, #15]

    return res;
 8020480:	7bfb      	ldrb	r3, [r7, #15]
}
 8020482:	4618      	mov	r0, r3
 8020484:	3710      	adds	r7, #16
 8020486:	46bd      	mov	sp, r7
 8020488:	bd80      	pop	{r7, pc}
	...

0802048c <lv_fs_get_drv>:
 * Give a pointer to a driver from its letter
 * @param letter the driver letter
 * @return pointer to a driver or NULL if not found
 */
lv_fs_drv_t * lv_fs_get_drv(char letter)
{
 802048c:	b580      	push	{r7, lr}
 802048e:	b084      	sub	sp, #16
 8020490:	af00      	add	r7, sp, #0
 8020492:	4603      	mov	r3, r0
 8020494:	71fb      	strb	r3, [r7, #7]
    lv_fs_drv_t * drv;

    _LV_LL_READ(LV_GC_ROOT(_lv_drv_ll), drv) {
 8020496:	480c      	ldr	r0, [pc, #48]	; (80204c8 <lv_fs_get_drv+0x3c>)
 8020498:	f000 f9e0 	bl	802085c <_lv_ll_get_head>
 802049c:	60f8      	str	r0, [r7, #12]
 802049e:	e00b      	b.n	80204b8 <lv_fs_get_drv+0x2c>
        if(drv->letter == letter) {
 80204a0:	68fb      	ldr	r3, [r7, #12]
 80204a2:	781b      	ldrb	r3, [r3, #0]
 80204a4:	79fa      	ldrb	r2, [r7, #7]
 80204a6:	429a      	cmp	r2, r3
 80204a8:	d101      	bne.n	80204ae <lv_fs_get_drv+0x22>
            return drv;
 80204aa:	68fb      	ldr	r3, [r7, #12]
 80204ac:	e008      	b.n	80204c0 <lv_fs_get_drv+0x34>
    _LV_LL_READ(LV_GC_ROOT(_lv_drv_ll), drv) {
 80204ae:	68f9      	ldr	r1, [r7, #12]
 80204b0:	4805      	ldr	r0, [pc, #20]	; (80204c8 <lv_fs_get_drv+0x3c>)
 80204b2:	f000 f9f9 	bl	80208a8 <_lv_ll_get_next>
 80204b6:	60f8      	str	r0, [r7, #12]
 80204b8:	68fb      	ldr	r3, [r7, #12]
 80204ba:	2b00      	cmp	r3, #0
 80204bc:	d1f0      	bne.n	80204a0 <lv_fs_get_drv+0x14>
        }
    }

    return NULL;
 80204be:	2300      	movs	r3, #0
}
 80204c0:	4618      	mov	r0, r3
 80204c2:	3710      	adds	r7, #16
 80204c4:	46bd      	mov	sp, r7
 80204c6:	bd80      	pop	{r7, pc}
 80204c8:	2000a198 	.word	0x2000a198

080204cc <lv_fs_get_ext>:
 * Return with the extension of the filename
 * @param fn string with a filename
 * @return pointer to the beginning extension or empty string if no extension
 */
const char * lv_fs_get_ext(const char * fn)
{
 80204cc:	b580      	push	{r7, lr}
 80204ce:	b084      	sub	sp, #16
 80204d0:	af00      	add	r7, sp, #0
 80204d2:	6078      	str	r0, [r7, #4]
    size_t i;
    for(i = strlen(fn); i > 0; i--) {
 80204d4:	6878      	ldr	r0, [r7, #4]
 80204d6:	f7df fe93 	bl	8000200 <strlen>
 80204da:	60f8      	str	r0, [r7, #12]
 80204dc:	e01b      	b.n	8020516 <lv_fs_get_ext+0x4a>
        if(fn[i] == '.') {
 80204de:	687a      	ldr	r2, [r7, #4]
 80204e0:	68fb      	ldr	r3, [r7, #12]
 80204e2:	4413      	add	r3, r2
 80204e4:	781b      	ldrb	r3, [r3, #0]
 80204e6:	2b2e      	cmp	r3, #46	; 0x2e
 80204e8:	d104      	bne.n	80204f4 <lv_fs_get_ext+0x28>
            return &fn[i + 1];
 80204ea:	68fb      	ldr	r3, [r7, #12]
 80204ec:	3301      	adds	r3, #1
 80204ee:	687a      	ldr	r2, [r7, #4]
 80204f0:	4413      	add	r3, r2
 80204f2:	e014      	b.n	802051e <lv_fs_get_ext+0x52>
        }
        else if(fn[i] == '/' || fn[i] == '\\') {
 80204f4:	687a      	ldr	r2, [r7, #4]
 80204f6:	68fb      	ldr	r3, [r7, #12]
 80204f8:	4413      	add	r3, r2
 80204fa:	781b      	ldrb	r3, [r3, #0]
 80204fc:	2b2f      	cmp	r3, #47	; 0x2f
 80204fe:	d005      	beq.n	802050c <lv_fs_get_ext+0x40>
 8020500:	687a      	ldr	r2, [r7, #4]
 8020502:	68fb      	ldr	r3, [r7, #12]
 8020504:	4413      	add	r3, r2
 8020506:	781b      	ldrb	r3, [r3, #0]
 8020508:	2b5c      	cmp	r3, #92	; 0x5c
 802050a:	d101      	bne.n	8020510 <lv_fs_get_ext+0x44>
            return ""; /*No extension if a '\' or '/' found*/
 802050c:	4b06      	ldr	r3, [pc, #24]	; (8020528 <lv_fs_get_ext+0x5c>)
 802050e:	e006      	b.n	802051e <lv_fs_get_ext+0x52>
    for(i = strlen(fn); i > 0; i--) {
 8020510:	68fb      	ldr	r3, [r7, #12]
 8020512:	3b01      	subs	r3, #1
 8020514:	60fb      	str	r3, [r7, #12]
 8020516:	68fb      	ldr	r3, [r7, #12]
 8020518:	2b00      	cmp	r3, #0
 802051a:	d1e0      	bne.n	80204de <lv_fs_get_ext+0x12>
        }
    }

    return ""; /*Empty string if no '.' in the file name. */
 802051c:	4b02      	ldr	r3, [pc, #8]	; (8020528 <lv_fs_get_ext+0x5c>)
}
 802051e:	4618      	mov	r0, r3
 8020520:	3710      	adds	r7, #16
 8020522:	46bd      	mov	sp, r7
 8020524:	bd80      	pop	{r7, pc}
 8020526:	bf00      	nop
 8020528:	0802e4f4 	.word	0x0802e4f4

0802052c <lv_fs_get_real_path>:
 * Leave the driver letters and / or \ letters from beginning of the path
 * @param path path string (E.g. S:/folder/file.txt)
 * @return pointer to the beginning of the real path (E.g. folder/file.txt)
 */
static const char * lv_fs_get_real_path(const char * path)
{
 802052c:	b480      	push	{r7}
 802052e:	b083      	sub	sp, #12
 8020530:	af00      	add	r7, sp, #0
 8020532:	6078      	str	r0, [r7, #4]
    /* Example path: "S:/folder/file.txt"
     * Leave the letter and the : / \ characters*/

    path++; /*Ignore the driver letter*/
 8020534:	687b      	ldr	r3, [r7, #4]
 8020536:	3301      	adds	r3, #1
 8020538:	607b      	str	r3, [r7, #4]

    while(*path != '\0') {
 802053a:	e00e      	b.n	802055a <lv_fs_get_real_path+0x2e>
        if(*path == ':' || *path == '\\' || *path == '/') {
 802053c:	687b      	ldr	r3, [r7, #4]
 802053e:	781b      	ldrb	r3, [r3, #0]
 8020540:	2b3a      	cmp	r3, #58	; 0x3a
 8020542:	d007      	beq.n	8020554 <lv_fs_get_real_path+0x28>
 8020544:	687b      	ldr	r3, [r7, #4]
 8020546:	781b      	ldrb	r3, [r3, #0]
 8020548:	2b5c      	cmp	r3, #92	; 0x5c
 802054a:	d003      	beq.n	8020554 <lv_fs_get_real_path+0x28>
 802054c:	687b      	ldr	r3, [r7, #4]
 802054e:	781b      	ldrb	r3, [r3, #0]
 8020550:	2b2f      	cmp	r3, #47	; 0x2f
 8020552:	d106      	bne.n	8020562 <lv_fs_get_real_path+0x36>
            path++;
 8020554:	687b      	ldr	r3, [r7, #4]
 8020556:	3301      	adds	r3, #1
 8020558:	607b      	str	r3, [r7, #4]
    while(*path != '\0') {
 802055a:	687b      	ldr	r3, [r7, #4]
 802055c:	781b      	ldrb	r3, [r3, #0]
 802055e:	2b00      	cmp	r3, #0
 8020560:	d1ec      	bne.n	802053c <lv_fs_get_real_path+0x10>
        else {
            break;
        }
    }

    return path;
 8020562:	687b      	ldr	r3, [r7, #4]
}
 8020564:	4618      	mov	r0, r3
 8020566:	370c      	adds	r7, #12
 8020568:	46bd      	mov	sp, r7
 802056a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802056e:	4770      	bx	lr

08020570 <_lv_ll_init>:
 * Initialize linked list
 * @param ll_dsc pointer to ll_dsc variable
 * @param node_size the size of 1 node in bytes
 */
void _lv_ll_init(lv_ll_t * ll_p, uint32_t node_size)
{
 8020570:	b480      	push	{r7}
 8020572:	b083      	sub	sp, #12
 8020574:	af00      	add	r7, sp, #0
 8020576:	6078      	str	r0, [r7, #4]
 8020578:	6039      	str	r1, [r7, #0]
    ll_p->head = NULL;
 802057a:	687b      	ldr	r3, [r7, #4]
 802057c:	2200      	movs	r2, #0
 802057e:	605a      	str	r2, [r3, #4]
    ll_p->tail = NULL;
 8020580:	687b      	ldr	r3, [r7, #4]
 8020582:	2200      	movs	r2, #0
 8020584:	609a      	str	r2, [r3, #8]
#ifdef LV_ARCH_64
    /*Round the size up to 8*/
    node_size = (node_size + 7) & (~0x7);
#else
    /*Round the size up to 4*/
    node_size = (node_size + 3) & (~0x3);
 8020586:	683b      	ldr	r3, [r7, #0]
 8020588:	3303      	adds	r3, #3
 802058a:	f023 0303 	bic.w	r3, r3, #3
 802058e:	603b      	str	r3, [r7, #0]
#endif

    ll_p->n_size = node_size;
 8020590:	687b      	ldr	r3, [r7, #4]
 8020592:	683a      	ldr	r2, [r7, #0]
 8020594:	601a      	str	r2, [r3, #0]
}
 8020596:	bf00      	nop
 8020598:	370c      	adds	r7, #12
 802059a:	46bd      	mov	sp, r7
 802059c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80205a0:	4770      	bx	lr

080205a2 <_lv_ll_ins_head>:
 * Add a new head to a linked list
 * @param ll_p pointer to linked list
 * @return pointer to the new head
 */
void * _lv_ll_ins_head(lv_ll_t * ll_p)
{
 80205a2:	b580      	push	{r7, lr}
 80205a4:	b084      	sub	sp, #16
 80205a6:	af00      	add	r7, sp, #0
 80205a8:	6078      	str	r0, [r7, #4]
    lv_ll_node_t * n_new;

    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 80205aa:	687b      	ldr	r3, [r7, #4]
 80205ac:	681b      	ldr	r3, [r3, #0]
 80205ae:	3308      	adds	r3, #8
 80205b0:	4618      	mov	r0, r3
 80205b2:	f000 fb0f 	bl	8020bd4 <lv_mem_alloc>
 80205b6:	60f8      	str	r0, [r7, #12]

    if(n_new != NULL) {
 80205b8:	68fb      	ldr	r3, [r7, #12]
 80205ba:	2b00      	cmp	r3, #0
 80205bc:	d020      	beq.n	8020600 <_lv_ll_ins_head+0x5e>
        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/
 80205be:	2200      	movs	r2, #0
 80205c0:	68f9      	ldr	r1, [r7, #12]
 80205c2:	6878      	ldr	r0, [r7, #4]
 80205c4:	f000 fa03 	bl	80209ce <node_set_prev>
        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/
 80205c8:	687b      	ldr	r3, [r7, #4]
 80205ca:	685b      	ldr	r3, [r3, #4]
 80205cc:	461a      	mov	r2, r3
 80205ce:	68f9      	ldr	r1, [r7, #12]
 80205d0:	6878      	ldr	r0, [r7, #4]
 80205d2:	f000 fa1b 	bl	8020a0c <node_set_next>

        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/
 80205d6:	687b      	ldr	r3, [r7, #4]
 80205d8:	685b      	ldr	r3, [r3, #4]
 80205da:	2b00      	cmp	r3, #0
 80205dc:	d006      	beq.n	80205ec <_lv_ll_ins_head+0x4a>
            node_set_prev(ll_p, ll_p->head, n_new);
 80205de:	687b      	ldr	r3, [r7, #4]
 80205e0:	685b      	ldr	r3, [r3, #4]
 80205e2:	68fa      	ldr	r2, [r7, #12]
 80205e4:	4619      	mov	r1, r3
 80205e6:	6878      	ldr	r0, [r7, #4]
 80205e8:	f000 f9f1 	bl	80209ce <node_set_prev>
        }

        ll_p->head = n_new;      /*Set the new head in the dsc.*/
 80205ec:	687b      	ldr	r3, [r7, #4]
 80205ee:	68fa      	ldr	r2, [r7, #12]
 80205f0:	605a      	str	r2, [r3, #4]
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
 80205f2:	687b      	ldr	r3, [r7, #4]
 80205f4:	689b      	ldr	r3, [r3, #8]
 80205f6:	2b00      	cmp	r3, #0
 80205f8:	d102      	bne.n	8020600 <_lv_ll_ins_head+0x5e>
            ll_p->tail = n_new;
 80205fa:	687b      	ldr	r3, [r7, #4]
 80205fc:	68fa      	ldr	r2, [r7, #12]
 80205fe:	609a      	str	r2, [r3, #8]
        }
    }

    return n_new;
 8020600:	68fb      	ldr	r3, [r7, #12]
}
 8020602:	4618      	mov	r0, r3
 8020604:	3710      	adds	r7, #16
 8020606:	46bd      	mov	sp, r7
 8020608:	bd80      	pop	{r7, pc}

0802060a <_lv_ll_ins_prev>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the new head
 */
void * _lv_ll_ins_prev(lv_ll_t * ll_p, void * n_act)
{
 802060a:	b580      	push	{r7, lr}
 802060c:	b084      	sub	sp, #16
 802060e:	af00      	add	r7, sp, #0
 8020610:	6078      	str	r0, [r7, #4]
 8020612:	6039      	str	r1, [r7, #0]
    lv_ll_node_t * n_new;

    if(NULL == ll_p || NULL == n_act) return NULL;
 8020614:	687b      	ldr	r3, [r7, #4]
 8020616:	2b00      	cmp	r3, #0
 8020618:	d002      	beq.n	8020620 <_lv_ll_ins_prev+0x16>
 802061a:	683b      	ldr	r3, [r7, #0]
 802061c:	2b00      	cmp	r3, #0
 802061e:	d101      	bne.n	8020624 <_lv_ll_ins_prev+0x1a>
 8020620:	2300      	movs	r3, #0
 8020622:	e035      	b.n	8020690 <_lv_ll_ins_prev+0x86>

    if(_lv_ll_get_head(ll_p) == n_act) {
 8020624:	6878      	ldr	r0, [r7, #4]
 8020626:	f000 f919 	bl	802085c <_lv_ll_get_head>
 802062a:	4602      	mov	r2, r0
 802062c:	683b      	ldr	r3, [r7, #0]
 802062e:	4293      	cmp	r3, r2
 8020630:	d108      	bne.n	8020644 <_lv_ll_ins_prev+0x3a>
        n_new = _lv_ll_ins_head(ll_p);
 8020632:	6878      	ldr	r0, [r7, #4]
 8020634:	f7ff ffb5 	bl	80205a2 <_lv_ll_ins_head>
 8020638:	60f8      	str	r0, [r7, #12]
        if(n_new == NULL) return NULL;
 802063a:	68fb      	ldr	r3, [r7, #12]
 802063c:	2b00      	cmp	r3, #0
 802063e:	d126      	bne.n	802068e <_lv_ll_ins_prev+0x84>
 8020640:	2300      	movs	r3, #0
 8020642:	e025      	b.n	8020690 <_lv_ll_ins_prev+0x86>
    }
    else {
        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 8020644:	687b      	ldr	r3, [r7, #4]
 8020646:	681b      	ldr	r3, [r3, #0]
 8020648:	3308      	adds	r3, #8
 802064a:	4618      	mov	r0, r3
 802064c:	f000 fac2 	bl	8020bd4 <lv_mem_alloc>
 8020650:	60f8      	str	r0, [r7, #12]
        if(n_new == NULL) return NULL;
 8020652:	68fb      	ldr	r3, [r7, #12]
 8020654:	2b00      	cmp	r3, #0
 8020656:	d101      	bne.n	802065c <_lv_ll_ins_prev+0x52>
 8020658:	2300      	movs	r3, #0
 802065a:	e019      	b.n	8020690 <_lv_ll_ins_prev+0x86>

        lv_ll_node_t * n_prev;
        n_prev = _lv_ll_get_prev(ll_p, n_act);
 802065c:	6839      	ldr	r1, [r7, #0]
 802065e:	6878      	ldr	r0, [r7, #4]
 8020660:	f000 f93c 	bl	80208dc <_lv_ll_get_prev>
 8020664:	60b8      	str	r0, [r7, #8]
        node_set_next(ll_p, n_prev, n_new);
 8020666:	68fa      	ldr	r2, [r7, #12]
 8020668:	68b9      	ldr	r1, [r7, #8]
 802066a:	6878      	ldr	r0, [r7, #4]
 802066c:	f000 f9ce 	bl	8020a0c <node_set_next>
        node_set_prev(ll_p, n_new, n_prev);
 8020670:	68ba      	ldr	r2, [r7, #8]
 8020672:	68f9      	ldr	r1, [r7, #12]
 8020674:	6878      	ldr	r0, [r7, #4]
 8020676:	f000 f9aa 	bl	80209ce <node_set_prev>
        node_set_prev(ll_p, n_act, n_new);
 802067a:	68fa      	ldr	r2, [r7, #12]
 802067c:	6839      	ldr	r1, [r7, #0]
 802067e:	6878      	ldr	r0, [r7, #4]
 8020680:	f000 f9a5 	bl	80209ce <node_set_prev>
        node_set_next(ll_p, n_new, n_act);
 8020684:	683a      	ldr	r2, [r7, #0]
 8020686:	68f9      	ldr	r1, [r7, #12]
 8020688:	6878      	ldr	r0, [r7, #4]
 802068a:	f000 f9bf 	bl	8020a0c <node_set_next>
    }

    return n_new;
 802068e:	68fb      	ldr	r3, [r7, #12]
}
 8020690:	4618      	mov	r0, r3
 8020692:	3710      	adds	r7, #16
 8020694:	46bd      	mov	sp, r7
 8020696:	bd80      	pop	{r7, pc}

08020698 <_lv_ll_ins_tail>:
 * Add a new tail to a linked list
 * @param ll_p pointer to linked list
 * @return pointer to the new tail
 */
void * _lv_ll_ins_tail(lv_ll_t * ll_p)
{
 8020698:	b580      	push	{r7, lr}
 802069a:	b084      	sub	sp, #16
 802069c:	af00      	add	r7, sp, #0
 802069e:	6078      	str	r0, [r7, #4]
    lv_ll_node_t * n_new;

    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 80206a0:	687b      	ldr	r3, [r7, #4]
 80206a2:	681b      	ldr	r3, [r3, #0]
 80206a4:	3308      	adds	r3, #8
 80206a6:	4618      	mov	r0, r3
 80206a8:	f000 fa94 	bl	8020bd4 <lv_mem_alloc>
 80206ac:	60f8      	str	r0, [r7, #12]

    if(n_new != NULL) {
 80206ae:	68fb      	ldr	r3, [r7, #12]
 80206b0:	2b00      	cmp	r3, #0
 80206b2:	d020      	beq.n	80206f6 <_lv_ll_ins_tail+0x5e>
        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/
 80206b4:	2200      	movs	r2, #0
 80206b6:	68f9      	ldr	r1, [r7, #12]
 80206b8:	6878      	ldr	r0, [r7, #4]
 80206ba:	f000 f9a7 	bl	8020a0c <node_set_next>
        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is the old tail*/
 80206be:	687b      	ldr	r3, [r7, #4]
 80206c0:	689b      	ldr	r3, [r3, #8]
 80206c2:	461a      	mov	r2, r3
 80206c4:	68f9      	ldr	r1, [r7, #12]
 80206c6:	6878      	ldr	r0, [r7, #4]
 80206c8:	f000 f981 	bl	80209ce <node_set_prev>
        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/
 80206cc:	687b      	ldr	r3, [r7, #4]
 80206ce:	689b      	ldr	r3, [r3, #8]
 80206d0:	2b00      	cmp	r3, #0
 80206d2:	d006      	beq.n	80206e2 <_lv_ll_ins_tail+0x4a>
            node_set_next(ll_p, ll_p->tail, n_new);
 80206d4:	687b      	ldr	r3, [r7, #4]
 80206d6:	689b      	ldr	r3, [r3, #8]
 80206d8:	68fa      	ldr	r2, [r7, #12]
 80206da:	4619      	mov	r1, r3
 80206dc:	6878      	ldr	r0, [r7, #4]
 80206de:	f000 f995 	bl	8020a0c <node_set_next>
        }

        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/
 80206e2:	687b      	ldr	r3, [r7, #4]
 80206e4:	68fa      	ldr	r2, [r7, #12]
 80206e6:	609a      	str	r2, [r3, #8]
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
 80206e8:	687b      	ldr	r3, [r7, #4]
 80206ea:	685b      	ldr	r3, [r3, #4]
 80206ec:	2b00      	cmp	r3, #0
 80206ee:	d102      	bne.n	80206f6 <_lv_ll_ins_tail+0x5e>
            ll_p->head = n_new;
 80206f0:	687b      	ldr	r3, [r7, #4]
 80206f2:	68fa      	ldr	r2, [r7, #12]
 80206f4:	605a      	str	r2, [r3, #4]
        }
    }

    return n_new;
 80206f6:	68fb      	ldr	r3, [r7, #12]
}
 80206f8:	4618      	mov	r0, r3
 80206fa:	3710      	adds	r7, #16
 80206fc:	46bd      	mov	sp, r7
 80206fe:	bd80      	pop	{r7, pc}

08020700 <_lv_ll_remove>:
 * It does not free the the memory of node.
 * @param ll_p pointer to the linked list of 'node_p'
 * @param node_p pointer to node in 'll_p' linked list
 */
void _lv_ll_remove(lv_ll_t * ll_p, void * node_p)
{
 8020700:	b580      	push	{r7, lr}
 8020702:	b084      	sub	sp, #16
 8020704:	af00      	add	r7, sp, #0
 8020706:	6078      	str	r0, [r7, #4]
 8020708:	6039      	str	r1, [r7, #0]
    if(_lv_ll_get_head(ll_p) == node_p) {
 802070a:	6878      	ldr	r0, [r7, #4]
 802070c:	f000 f8a6 	bl	802085c <_lv_ll_get_head>
 8020710:	4602      	mov	r2, r0
 8020712:	683b      	ldr	r3, [r7, #0]
 8020714:	4293      	cmp	r3, r2
 8020716:	d116      	bne.n	8020746 <_lv_ll_remove+0x46>
        /*The new head will be the node after 'n_act'*/
        ll_p->head = _lv_ll_get_next(ll_p, node_p);
 8020718:	6839      	ldr	r1, [r7, #0]
 802071a:	6878      	ldr	r0, [r7, #4]
 802071c:	f000 f8c4 	bl	80208a8 <_lv_ll_get_next>
 8020720:	4602      	mov	r2, r0
 8020722:	687b      	ldr	r3, [r7, #4]
 8020724:	605a      	str	r2, [r3, #4]
        if(ll_p->head == NULL) {
 8020726:	687b      	ldr	r3, [r7, #4]
 8020728:	685b      	ldr	r3, [r3, #4]
 802072a:	2b00      	cmp	r3, #0
 802072c:	d103      	bne.n	8020736 <_lv_ll_remove+0x36>
            ll_p->tail = NULL;
 802072e:	687b      	ldr	r3, [r7, #4]
 8020730:	2200      	movs	r2, #0
 8020732:	609a      	str	r2, [r3, #8]
        lv_ll_node_t * n_next = _lv_ll_get_next(ll_p, node_p);

        node_set_next(ll_p, n_prev, n_next);
        node_set_prev(ll_p, n_next, n_prev);
    }
}
 8020734:	e039      	b.n	80207aa <_lv_ll_remove+0xaa>
            node_set_prev(ll_p, ll_p->head, NULL);
 8020736:	687b      	ldr	r3, [r7, #4]
 8020738:	685b      	ldr	r3, [r3, #4]
 802073a:	2200      	movs	r2, #0
 802073c:	4619      	mov	r1, r3
 802073e:	6878      	ldr	r0, [r7, #4]
 8020740:	f000 f945 	bl	80209ce <node_set_prev>
}
 8020744:	e031      	b.n	80207aa <_lv_ll_remove+0xaa>
    else if(_lv_ll_get_tail(ll_p) == node_p) {
 8020746:	6878      	ldr	r0, [r7, #4]
 8020748:	f000 f89b 	bl	8020882 <_lv_ll_get_tail>
 802074c:	4602      	mov	r2, r0
 802074e:	683b      	ldr	r3, [r7, #0]
 8020750:	4293      	cmp	r3, r2
 8020752:	d116      	bne.n	8020782 <_lv_ll_remove+0x82>
        ll_p->tail = _lv_ll_get_prev(ll_p, node_p);
 8020754:	6839      	ldr	r1, [r7, #0]
 8020756:	6878      	ldr	r0, [r7, #4]
 8020758:	f000 f8c0 	bl	80208dc <_lv_ll_get_prev>
 802075c:	4602      	mov	r2, r0
 802075e:	687b      	ldr	r3, [r7, #4]
 8020760:	609a      	str	r2, [r3, #8]
        if(ll_p->tail == NULL) {
 8020762:	687b      	ldr	r3, [r7, #4]
 8020764:	689b      	ldr	r3, [r3, #8]
 8020766:	2b00      	cmp	r3, #0
 8020768:	d103      	bne.n	8020772 <_lv_ll_remove+0x72>
            ll_p->head = NULL;
 802076a:	687b      	ldr	r3, [r7, #4]
 802076c:	2200      	movs	r2, #0
 802076e:	605a      	str	r2, [r3, #4]
}
 8020770:	e01b      	b.n	80207aa <_lv_ll_remove+0xaa>
            node_set_next(ll_p, ll_p->tail, NULL);
 8020772:	687b      	ldr	r3, [r7, #4]
 8020774:	689b      	ldr	r3, [r3, #8]
 8020776:	2200      	movs	r2, #0
 8020778:	4619      	mov	r1, r3
 802077a:	6878      	ldr	r0, [r7, #4]
 802077c:	f000 f946 	bl	8020a0c <node_set_next>
}
 8020780:	e013      	b.n	80207aa <_lv_ll_remove+0xaa>
        lv_ll_node_t * n_prev = _lv_ll_get_prev(ll_p, node_p);
 8020782:	6839      	ldr	r1, [r7, #0]
 8020784:	6878      	ldr	r0, [r7, #4]
 8020786:	f000 f8a9 	bl	80208dc <_lv_ll_get_prev>
 802078a:	60f8      	str	r0, [r7, #12]
        lv_ll_node_t * n_next = _lv_ll_get_next(ll_p, node_p);
 802078c:	6839      	ldr	r1, [r7, #0]
 802078e:	6878      	ldr	r0, [r7, #4]
 8020790:	f000 f88a 	bl	80208a8 <_lv_ll_get_next>
 8020794:	60b8      	str	r0, [r7, #8]
        node_set_next(ll_p, n_prev, n_next);
 8020796:	68ba      	ldr	r2, [r7, #8]
 8020798:	68f9      	ldr	r1, [r7, #12]
 802079a:	6878      	ldr	r0, [r7, #4]
 802079c:	f000 f936 	bl	8020a0c <node_set_next>
        node_set_prev(ll_p, n_next, n_prev);
 80207a0:	68fa      	ldr	r2, [r7, #12]
 80207a2:	68b9      	ldr	r1, [r7, #8]
 80207a4:	6878      	ldr	r0, [r7, #4]
 80207a6:	f000 f912 	bl	80209ce <node_set_prev>
}
 80207aa:	bf00      	nop
 80207ac:	3710      	adds	r7, #16
 80207ae:	46bd      	mov	sp, r7
 80207b0:	bd80      	pop	{r7, pc}

080207b2 <_lv_ll_chg_list>:
 * @param node pointer to a node
 * @param head true: be the head in the new list
 *             false be the head in the new list
 */
void _lv_ll_chg_list(lv_ll_t * ll_ori_p, lv_ll_t * ll_new_p, void * node, bool head)
{
 80207b2:	b580      	push	{r7, lr}
 80207b4:	b084      	sub	sp, #16
 80207b6:	af00      	add	r7, sp, #0
 80207b8:	60f8      	str	r0, [r7, #12]
 80207ba:	60b9      	str	r1, [r7, #8]
 80207bc:	607a      	str	r2, [r7, #4]
 80207be:	70fb      	strb	r3, [r7, #3]
    _lv_ll_remove(ll_ori_p, node);
 80207c0:	6879      	ldr	r1, [r7, #4]
 80207c2:	68f8      	ldr	r0, [r7, #12]
 80207c4:	f7ff ff9c 	bl	8020700 <_lv_ll_remove>

    if(head) {
 80207c8:	78fb      	ldrb	r3, [r7, #3]
 80207ca:	2b00      	cmp	r3, #0
 80207cc:	d021      	beq.n	8020812 <_lv_ll_chg_list+0x60>
        /*Set node as head*/
        node_set_prev(ll_new_p, node, NULL);
 80207ce:	2200      	movs	r2, #0
 80207d0:	6879      	ldr	r1, [r7, #4]
 80207d2:	68b8      	ldr	r0, [r7, #8]
 80207d4:	f000 f8fb 	bl	80209ce <node_set_prev>
        node_set_next(ll_new_p, node, ll_new_p->head);
 80207d8:	68bb      	ldr	r3, [r7, #8]
 80207da:	685b      	ldr	r3, [r3, #4]
 80207dc:	461a      	mov	r2, r3
 80207de:	6879      	ldr	r1, [r7, #4]
 80207e0:	68b8      	ldr	r0, [r7, #8]
 80207e2:	f000 f913 	bl	8020a0c <node_set_next>

        if(ll_new_p->head != NULL) { /*If there is old head then before it goes the new*/
 80207e6:	68bb      	ldr	r3, [r7, #8]
 80207e8:	685b      	ldr	r3, [r3, #4]
 80207ea:	2b00      	cmp	r3, #0
 80207ec:	d006      	beq.n	80207fc <_lv_ll_chg_list+0x4a>
            node_set_prev(ll_new_p, ll_new_p->head, node);
 80207ee:	68bb      	ldr	r3, [r7, #8]
 80207f0:	685b      	ldr	r3, [r3, #4]
 80207f2:	687a      	ldr	r2, [r7, #4]
 80207f4:	4619      	mov	r1, r3
 80207f6:	68b8      	ldr	r0, [r7, #8]
 80207f8:	f000 f8e9 	bl	80209ce <node_set_prev>
        }

        ll_new_p->head = node;       /*Set the new head in the dsc.*/
 80207fc:	68bb      	ldr	r3, [r7, #8]
 80207fe:	687a      	ldr	r2, [r7, #4]
 8020800:	605a      	str	r2, [r3, #4]
        if(ll_new_p->tail == NULL) { /*If there is no tail (first node) set the tail too*/
 8020802:	68bb      	ldr	r3, [r7, #8]
 8020804:	689b      	ldr	r3, [r3, #8]
 8020806:	2b00      	cmp	r3, #0
 8020808:	d124      	bne.n	8020854 <_lv_ll_chg_list+0xa2>
            ll_new_p->tail = node;
 802080a:	68bb      	ldr	r3, [r7, #8]
 802080c:	687a      	ldr	r2, [r7, #4]
 802080e:	609a      	str	r2, [r3, #8]
        ll_new_p->tail = node;       /*Set the new tail in the dsc.*/
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
            ll_new_p->head = node;
        }
    }
}
 8020810:	e020      	b.n	8020854 <_lv_ll_chg_list+0xa2>
        node_set_prev(ll_new_p, node, ll_new_p->tail);
 8020812:	68bb      	ldr	r3, [r7, #8]
 8020814:	689b      	ldr	r3, [r3, #8]
 8020816:	461a      	mov	r2, r3
 8020818:	6879      	ldr	r1, [r7, #4]
 802081a:	68b8      	ldr	r0, [r7, #8]
 802081c:	f000 f8d7 	bl	80209ce <node_set_prev>
        node_set_next(ll_new_p, node, NULL);
 8020820:	2200      	movs	r2, #0
 8020822:	6879      	ldr	r1, [r7, #4]
 8020824:	68b8      	ldr	r0, [r7, #8]
 8020826:	f000 f8f1 	bl	8020a0c <node_set_next>
        if(ll_new_p->tail != NULL) { /*If there is old tail then after it goes the new*/
 802082a:	68bb      	ldr	r3, [r7, #8]
 802082c:	689b      	ldr	r3, [r3, #8]
 802082e:	2b00      	cmp	r3, #0
 8020830:	d006      	beq.n	8020840 <_lv_ll_chg_list+0x8e>
            node_set_next(ll_new_p, ll_new_p->tail, node);
 8020832:	68bb      	ldr	r3, [r7, #8]
 8020834:	689b      	ldr	r3, [r3, #8]
 8020836:	687a      	ldr	r2, [r7, #4]
 8020838:	4619      	mov	r1, r3
 802083a:	68b8      	ldr	r0, [r7, #8]
 802083c:	f000 f8e6 	bl	8020a0c <node_set_next>
        ll_new_p->tail = node;       /*Set the new tail in the dsc.*/
 8020840:	68bb      	ldr	r3, [r7, #8]
 8020842:	687a      	ldr	r2, [r7, #4]
 8020844:	609a      	str	r2, [r3, #8]
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
 8020846:	68bb      	ldr	r3, [r7, #8]
 8020848:	685b      	ldr	r3, [r3, #4]
 802084a:	2b00      	cmp	r3, #0
 802084c:	d102      	bne.n	8020854 <_lv_ll_chg_list+0xa2>
            ll_new_p->head = node;
 802084e:	68bb      	ldr	r3, [r7, #8]
 8020850:	687a      	ldr	r2, [r7, #4]
 8020852:	605a      	str	r2, [r3, #4]
}
 8020854:	bf00      	nop
 8020856:	3710      	adds	r7, #16
 8020858:	46bd      	mov	sp, r7
 802085a:	bd80      	pop	{r7, pc}

0802085c <_lv_ll_get_head>:
 * Return with head node of the linked list
 * @param ll_p pointer to linked list
 * @return pointer to the head of 'll_p'
 */
void * _lv_ll_get_head(const lv_ll_t * ll_p)
{
 802085c:	b480      	push	{r7}
 802085e:	b085      	sub	sp, #20
 8020860:	af00      	add	r7, sp, #0
 8020862:	6078      	str	r0, [r7, #4]
    void * head = NULL;
 8020864:	2300      	movs	r3, #0
 8020866:	60fb      	str	r3, [r7, #12]

    if(ll_p != NULL) {
 8020868:	687b      	ldr	r3, [r7, #4]
 802086a:	2b00      	cmp	r3, #0
 802086c:	d002      	beq.n	8020874 <_lv_ll_get_head+0x18>
        head = ll_p->head;
 802086e:	687b      	ldr	r3, [r7, #4]
 8020870:	685b      	ldr	r3, [r3, #4]
 8020872:	60fb      	str	r3, [r7, #12]
    }

    return head;
 8020874:	68fb      	ldr	r3, [r7, #12]
}
 8020876:	4618      	mov	r0, r3
 8020878:	3714      	adds	r7, #20
 802087a:	46bd      	mov	sp, r7
 802087c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020880:	4770      	bx	lr

08020882 <_lv_ll_get_tail>:
 * Return with tail node of the linked list
 * @param ll_p pointer to linked list
 * @return pointer to the head of 'll_p'
 */
void * _lv_ll_get_tail(const lv_ll_t * ll_p)
{
 8020882:	b480      	push	{r7}
 8020884:	b085      	sub	sp, #20
 8020886:	af00      	add	r7, sp, #0
 8020888:	6078      	str	r0, [r7, #4]
    void * tail = NULL;
 802088a:	2300      	movs	r3, #0
 802088c:	60fb      	str	r3, [r7, #12]

    if(ll_p != NULL) {
 802088e:	687b      	ldr	r3, [r7, #4]
 8020890:	2b00      	cmp	r3, #0
 8020892:	d002      	beq.n	802089a <_lv_ll_get_tail+0x18>
        tail = ll_p->tail;
 8020894:	687b      	ldr	r3, [r7, #4]
 8020896:	689b      	ldr	r3, [r3, #8]
 8020898:	60fb      	str	r3, [r7, #12]
    }

    return tail;
 802089a:	68fb      	ldr	r3, [r7, #12]
}
 802089c:	4618      	mov	r0, r3
 802089e:	3714      	adds	r7, #20
 80208a0:	46bd      	mov	sp, r7
 80208a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80208a6:	4770      	bx	lr

080208a8 <_lv_ll_get_next>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the next node
 */
void * _lv_ll_get_next(const lv_ll_t * ll_p, const void * n_act)
{
 80208a8:	b480      	push	{r7}
 80208aa:	b085      	sub	sp, #20
 80208ac:	af00      	add	r7, sp, #0
 80208ae:	6078      	str	r0, [r7, #4]
 80208b0:	6039      	str	r1, [r7, #0]
    if(ll_p == NULL) return NULL;
 80208b2:	687b      	ldr	r3, [r7, #4]
 80208b4:	2b00      	cmp	r3, #0
 80208b6:	d101      	bne.n	80208bc <_lv_ll_get_next+0x14>
 80208b8:	2300      	movs	r3, #0
 80208ba:	e009      	b.n	80208d0 <_lv_ll_get_next+0x28>

    /* Pointer to the next node is stored in the end of this node.
     * Go there and return the address found there */
    const lv_ll_node_t * n_act_d = n_act;
 80208bc:	683b      	ldr	r3, [r7, #0]
 80208be:	60fb      	str	r3, [r7, #12]
    n_act_d += LL_NEXT_P_OFFSET(ll_p);
 80208c0:	687b      	ldr	r3, [r7, #4]
 80208c2:	681b      	ldr	r3, [r3, #0]
 80208c4:	3304      	adds	r3, #4
 80208c6:	68fa      	ldr	r2, [r7, #12]
 80208c8:	4413      	add	r3, r2
 80208ca:	60fb      	str	r3, [r7, #12]
    return *((lv_ll_node_t **)n_act_d);
 80208cc:	68fb      	ldr	r3, [r7, #12]
 80208ce:	681b      	ldr	r3, [r3, #0]
}
 80208d0:	4618      	mov	r0, r3
 80208d2:	3714      	adds	r7, #20
 80208d4:	46bd      	mov	sp, r7
 80208d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80208da:	4770      	bx	lr

080208dc <_lv_ll_get_prev>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the previous node
 */
void * _lv_ll_get_prev(const lv_ll_t * ll_p, const void * n_act)
{
 80208dc:	b480      	push	{r7}
 80208de:	b085      	sub	sp, #20
 80208e0:	af00      	add	r7, sp, #0
 80208e2:	6078      	str	r0, [r7, #4]
 80208e4:	6039      	str	r1, [r7, #0]
    if(ll_p == NULL) return NULL;
 80208e6:	687b      	ldr	r3, [r7, #4]
 80208e8:	2b00      	cmp	r3, #0
 80208ea:	d101      	bne.n	80208f0 <_lv_ll_get_prev+0x14>
 80208ec:	2300      	movs	r3, #0
 80208ee:	e008      	b.n	8020902 <_lv_ll_get_prev+0x26>

    /* Pointer to the prev. node is stored in the end of this node.
     * Go there and return the address found there */
    const lv_ll_node_t * n_act_d = n_act;
 80208f0:	683b      	ldr	r3, [r7, #0]
 80208f2:	60fb      	str	r3, [r7, #12]
    n_act_d += LL_PREV_P_OFFSET(ll_p);
 80208f4:	687b      	ldr	r3, [r7, #4]
 80208f6:	681b      	ldr	r3, [r3, #0]
 80208f8:	68fa      	ldr	r2, [r7, #12]
 80208fa:	4413      	add	r3, r2
 80208fc:	60fb      	str	r3, [r7, #12]
    return *((lv_ll_node_t **)n_act_d);
 80208fe:	68fb      	ldr	r3, [r7, #12]
 8020900:	681b      	ldr	r3, [r3, #0]
}
 8020902:	4618      	mov	r0, r3
 8020904:	3714      	adds	r7, #20
 8020906:	46bd      	mov	sp, r7
 8020908:	f85d 7b04 	ldr.w	r7, [sp], #4
 802090c:	4770      	bx	lr

0802090e <_lv_ll_move_before>:
 * @param ll_p pointer to a linked list
 * @param n_act pointer to node to move
 * @param n_after pointer to a node which should be after `n_act`
 */
void _lv_ll_move_before(lv_ll_t * ll_p, void * n_act, void * n_after)
{
 802090e:	b580      	push	{r7, lr}
 8020910:	b086      	sub	sp, #24
 8020912:	af00      	add	r7, sp, #0
 8020914:	60f8      	str	r0, [r7, #12]
 8020916:	60b9      	str	r1, [r7, #8]
 8020918:	607a      	str	r2, [r7, #4]
    if(n_act == n_after) return; /*Can't move before itself*/
 802091a:	68ba      	ldr	r2, [r7, #8]
 802091c:	687b      	ldr	r3, [r7, #4]
 802091e:	429a      	cmp	r2, r3
 8020920:	d035      	beq.n	802098e <_lv_ll_move_before+0x80>

    void * n_before;
    if(n_after != NULL)
 8020922:	687b      	ldr	r3, [r7, #4]
 8020924:	2b00      	cmp	r3, #0
 8020926:	d005      	beq.n	8020934 <_lv_ll_move_before+0x26>
        n_before = _lv_ll_get_prev(ll_p, n_after);
 8020928:	6879      	ldr	r1, [r7, #4]
 802092a:	68f8      	ldr	r0, [r7, #12]
 802092c:	f7ff ffd6 	bl	80208dc <_lv_ll_get_prev>
 8020930:	6178      	str	r0, [r7, #20]
 8020932:	e003      	b.n	802093c <_lv_ll_move_before+0x2e>
    else
        n_before = _lv_ll_get_tail(ll_p); /*if `n_after` is NULL `n_act` should be the new tail*/
 8020934:	68f8      	ldr	r0, [r7, #12]
 8020936:	f7ff ffa4 	bl	8020882 <_lv_ll_get_tail>
 802093a:	6178      	str	r0, [r7, #20]

    if(n_act == n_before) return; /*Already before `n_after`*/
 802093c:	68ba      	ldr	r2, [r7, #8]
 802093e:	697b      	ldr	r3, [r7, #20]
 8020940:	429a      	cmp	r2, r3
 8020942:	d026      	beq.n	8020992 <_lv_ll_move_before+0x84>

    /*It's much easier to remove from the list and add again*/
    _lv_ll_remove(ll_p, n_act);
 8020944:	68b9      	ldr	r1, [r7, #8]
 8020946:	68f8      	ldr	r0, [r7, #12]
 8020948:	f7ff feda 	bl	8020700 <_lv_ll_remove>

    /*Add again by setting the prev. and next nodes*/
    node_set_next(ll_p, n_before, n_act);
 802094c:	68ba      	ldr	r2, [r7, #8]
 802094e:	6979      	ldr	r1, [r7, #20]
 8020950:	68f8      	ldr	r0, [r7, #12]
 8020952:	f000 f85b 	bl	8020a0c <node_set_next>
    node_set_prev(ll_p, n_act, n_before);
 8020956:	697a      	ldr	r2, [r7, #20]
 8020958:	68b9      	ldr	r1, [r7, #8]
 802095a:	68f8      	ldr	r0, [r7, #12]
 802095c:	f000 f837 	bl	80209ce <node_set_prev>
    node_set_prev(ll_p, n_after, n_act);
 8020960:	68ba      	ldr	r2, [r7, #8]
 8020962:	6879      	ldr	r1, [r7, #4]
 8020964:	68f8      	ldr	r0, [r7, #12]
 8020966:	f000 f832 	bl	80209ce <node_set_prev>
    node_set_next(ll_p, n_act, n_after);
 802096a:	687a      	ldr	r2, [r7, #4]
 802096c:	68b9      	ldr	r1, [r7, #8]
 802096e:	68f8      	ldr	r0, [r7, #12]
 8020970:	f000 f84c 	bl	8020a0c <node_set_next>

    /*If `n_act` was moved before NULL then it become the new tail*/
    if(n_after == NULL) ll_p->tail = n_act;
 8020974:	687b      	ldr	r3, [r7, #4]
 8020976:	2b00      	cmp	r3, #0
 8020978:	d102      	bne.n	8020980 <_lv_ll_move_before+0x72>
 802097a:	68fb      	ldr	r3, [r7, #12]
 802097c:	68ba      	ldr	r2, [r7, #8]
 802097e:	609a      	str	r2, [r3, #8]

    /*If `n_act` was moved before `NULL` then it's the new head*/
    if(n_before == NULL) ll_p->head = n_act;
 8020980:	697b      	ldr	r3, [r7, #20]
 8020982:	2b00      	cmp	r3, #0
 8020984:	d106      	bne.n	8020994 <_lv_ll_move_before+0x86>
 8020986:	68fb      	ldr	r3, [r7, #12]
 8020988:	68ba      	ldr	r2, [r7, #8]
 802098a:	605a      	str	r2, [r3, #4]
 802098c:	e002      	b.n	8020994 <_lv_ll_move_before+0x86>
    if(n_act == n_after) return; /*Can't move before itself*/
 802098e:	bf00      	nop
 8020990:	e000      	b.n	8020994 <_lv_ll_move_before+0x86>
    if(n_act == n_before) return; /*Already before `n_after`*/
 8020992:	bf00      	nop
}
 8020994:	3718      	adds	r7, #24
 8020996:	46bd      	mov	sp, r7
 8020998:	bd80      	pop	{r7, pc}

0802099a <_lv_ll_is_empty>:
 * Check if a linked list is empty
 * @param ll_p pointer to a linked list
 * @return true: the linked list is empty; false: not empty
 */
bool _lv_ll_is_empty(lv_ll_t * ll_p)
{
 802099a:	b480      	push	{r7}
 802099c:	b083      	sub	sp, #12
 802099e:	af00      	add	r7, sp, #0
 80209a0:	6078      	str	r0, [r7, #4]
    if(ll_p == NULL) return true;
 80209a2:	687b      	ldr	r3, [r7, #4]
 80209a4:	2b00      	cmp	r3, #0
 80209a6:	d101      	bne.n	80209ac <_lv_ll_is_empty+0x12>
 80209a8:	2301      	movs	r3, #1
 80209aa:	e00a      	b.n	80209c2 <_lv_ll_is_empty+0x28>

    if(ll_p->head == NULL && ll_p->tail == NULL) return true;
 80209ac:	687b      	ldr	r3, [r7, #4]
 80209ae:	685b      	ldr	r3, [r3, #4]
 80209b0:	2b00      	cmp	r3, #0
 80209b2:	d105      	bne.n	80209c0 <_lv_ll_is_empty+0x26>
 80209b4:	687b      	ldr	r3, [r7, #4]
 80209b6:	689b      	ldr	r3, [r3, #8]
 80209b8:	2b00      	cmp	r3, #0
 80209ba:	d101      	bne.n	80209c0 <_lv_ll_is_empty+0x26>
 80209bc:	2301      	movs	r3, #1
 80209be:	e000      	b.n	80209c2 <_lv_ll_is_empty+0x28>

    return false;
 80209c0:	2300      	movs	r3, #0
}
 80209c2:	4618      	mov	r0, r3
 80209c4:	370c      	adds	r7, #12
 80209c6:	46bd      	mov	sp, r7
 80209c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80209cc:	4770      	bx	lr

080209ce <node_set_prev>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which prev. node pointer should be set
 * @param prev pointer to a node which should be the previous node before 'act'
 */
static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)
{
 80209ce:	b480      	push	{r7}
 80209d0:	b089      	sub	sp, #36	; 0x24
 80209d2:	af00      	add	r7, sp, #0
 80209d4:	60f8      	str	r0, [r7, #12]
 80209d6:	60b9      	str	r1, [r7, #8]
 80209d8:	607a      	str	r2, [r7, #4]
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
 80209da:	68bb      	ldr	r3, [r7, #8]
 80209dc:	2b00      	cmp	r3, #0
 80209de:	d00f      	beq.n	8020a00 <node_set_prev+0x32>

    uint8_t * act8 = (uint8_t *) act;
 80209e0:	68bb      	ldr	r3, [r7, #8]
 80209e2:	61fb      	str	r3, [r7, #28]

    act8 += LL_PREV_P_OFFSET(ll_p);
 80209e4:	68fb      	ldr	r3, [r7, #12]
 80209e6:	681b      	ldr	r3, [r3, #0]
 80209e8:	69fa      	ldr	r2, [r7, #28]
 80209ea:	4413      	add	r3, r2
 80209ec:	61fb      	str	r3, [r7, #28]

    lv_ll_node_t ** act_node_p = (lv_ll_node_t **) act8;
 80209ee:	69fb      	ldr	r3, [r7, #28]
 80209f0:	61bb      	str	r3, [r7, #24]
    lv_ll_node_t ** prev_node_p = (lv_ll_node_t **) &prev;
 80209f2:	1d3b      	adds	r3, r7, #4
 80209f4:	617b      	str	r3, [r7, #20]

    *act_node_p = *prev_node_p;
 80209f6:	697b      	ldr	r3, [r7, #20]
 80209f8:	681a      	ldr	r2, [r3, #0]
 80209fa:	69bb      	ldr	r3, [r7, #24]
 80209fc:	601a      	str	r2, [r3, #0]
 80209fe:	e000      	b.n	8020a02 <node_set_prev+0x34>
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
 8020a00:	bf00      	nop
}
 8020a02:	3724      	adds	r7, #36	; 0x24
 8020a04:	46bd      	mov	sp, r7
 8020a06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020a0a:	4770      	bx	lr

08020a0c <node_set_next>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
{
 8020a0c:	b480      	push	{r7}
 8020a0e:	b089      	sub	sp, #36	; 0x24
 8020a10:	af00      	add	r7, sp, #0
 8020a12:	60f8      	str	r0, [r7, #12]
 8020a14:	60b9      	str	r1, [r7, #8]
 8020a16:	607a      	str	r2, [r7, #4]
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
 8020a18:	68bb      	ldr	r3, [r7, #8]
 8020a1a:	2b00      	cmp	r3, #0
 8020a1c:	d010      	beq.n	8020a40 <node_set_next+0x34>
    uint8_t * act8 = (uint8_t *) act;
 8020a1e:	68bb      	ldr	r3, [r7, #8]
 8020a20:	61fb      	str	r3, [r7, #28]

    act8 += LL_NEXT_P_OFFSET(ll_p);
 8020a22:	68fb      	ldr	r3, [r7, #12]
 8020a24:	681b      	ldr	r3, [r3, #0]
 8020a26:	3304      	adds	r3, #4
 8020a28:	69fa      	ldr	r2, [r7, #28]
 8020a2a:	4413      	add	r3, r2
 8020a2c:	61fb      	str	r3, [r7, #28]
    lv_ll_node_t ** act_node_p = (lv_ll_node_t **) act8;
 8020a2e:	69fb      	ldr	r3, [r7, #28]
 8020a30:	61bb      	str	r3, [r7, #24]
    lv_ll_node_t ** next_node_p = (lv_ll_node_t **) &next;
 8020a32:	1d3b      	adds	r3, r7, #4
 8020a34:	617b      	str	r3, [r7, #20]

    *act_node_p = *next_node_p;
 8020a36:	697b      	ldr	r3, [r7, #20]
 8020a38:	681a      	ldr	r2, [r3, #0]
 8020a3a:	69bb      	ldr	r3, [r7, #24]
 8020a3c:	601a      	str	r2, [r3, #0]
 8020a3e:	e000      	b.n	8020a42 <node_set_next+0x36>
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
 8020a40:	bf00      	nop
}
 8020a42:	3724      	adds	r7, #36	; 0x24
 8020a44:	46bd      	mov	sp, r7
 8020a46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020a4a:	4770      	bx	lr

08020a4c <_lv_trigo_sin>:
 * Return with sinus of an angle
 * @param angle
 * @return sinus of 'angle'. sin(-90) = -32767, sin(90) = 32767
 */
LV_ATTRIBUTE_FAST_MEM int16_t _lv_trigo_sin(int16_t angle)
{
 8020a4c:	b480      	push	{r7}
 8020a4e:	b085      	sub	sp, #20
 8020a50:	af00      	add	r7, sp, #0
 8020a52:	4603      	mov	r3, r0
 8020a54:	80fb      	strh	r3, [r7, #6]
    int16_t ret = 0;
 8020a56:	2300      	movs	r3, #0
 8020a58:	81fb      	strh	r3, [r7, #14]
    angle       = angle % 360;
 8020a5a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8020a5e:	4a31      	ldr	r2, [pc, #196]	; (8020b24 <_lv_trigo_sin+0xd8>)
 8020a60:	fb82 1203 	smull	r1, r2, r2, r3
 8020a64:	441a      	add	r2, r3
 8020a66:	1211      	asrs	r1, r2, #8
 8020a68:	17da      	asrs	r2, r3, #31
 8020a6a:	1a8a      	subs	r2, r1, r2
 8020a6c:	f44f 71b4 	mov.w	r1, #360	; 0x168
 8020a70:	fb01 f202 	mul.w	r2, r1, r2
 8020a74:	1a9b      	subs	r3, r3, r2
 8020a76:	80fb      	strh	r3, [r7, #6]

    if(angle < 0) angle = 360 + angle;
 8020a78:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8020a7c:	2b00      	cmp	r3, #0
 8020a7e:	da04      	bge.n	8020a8a <_lv_trigo_sin+0x3e>
 8020a80:	88fb      	ldrh	r3, [r7, #6]
 8020a82:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 8020a86:	b29b      	uxth	r3, r3
 8020a88:	80fb      	strh	r3, [r7, #6]

    if(angle < 90) {
 8020a8a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8020a8e:	2b59      	cmp	r3, #89	; 0x59
 8020a90:	dc06      	bgt.n	8020aa0 <_lv_trigo_sin+0x54>
        ret = sin0_90_table[angle];
 8020a92:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8020a96:	4a24      	ldr	r2, [pc, #144]	; (8020b28 <_lv_trigo_sin+0xdc>)
 8020a98:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8020a9c:	81fb      	strh	r3, [r7, #14]
 8020a9e:	e038      	b.n	8020b12 <_lv_trigo_sin+0xc6>
    }
    else if(angle >= 90 && angle < 180) {
 8020aa0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8020aa4:	2b59      	cmp	r3, #89	; 0x59
 8020aa6:	dd0f      	ble.n	8020ac8 <_lv_trigo_sin+0x7c>
 8020aa8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8020aac:	2bb3      	cmp	r3, #179	; 0xb3
 8020aae:	dc0b      	bgt.n	8020ac8 <_lv_trigo_sin+0x7c>
        angle = 180 - angle;
 8020ab0:	88fb      	ldrh	r3, [r7, #6]
 8020ab2:	f1c3 03b4 	rsb	r3, r3, #180	; 0xb4
 8020ab6:	b29b      	uxth	r3, r3
 8020ab8:	80fb      	strh	r3, [r7, #6]
        ret   = sin0_90_table[angle];
 8020aba:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8020abe:	4a1a      	ldr	r2, [pc, #104]	; (8020b28 <_lv_trigo_sin+0xdc>)
 8020ac0:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8020ac4:	81fb      	strh	r3, [r7, #14]
 8020ac6:	e024      	b.n	8020b12 <_lv_trigo_sin+0xc6>
    }
    else if(angle >= 180 && angle < 270) {
 8020ac8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8020acc:	2bb3      	cmp	r3, #179	; 0xb3
 8020ace:	dd12      	ble.n	8020af6 <_lv_trigo_sin+0xaa>
 8020ad0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8020ad4:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 8020ad8:	da0d      	bge.n	8020af6 <_lv_trigo_sin+0xaa>
        angle = angle - 180;
 8020ada:	88fb      	ldrh	r3, [r7, #6]
 8020adc:	3bb4      	subs	r3, #180	; 0xb4
 8020ade:	b29b      	uxth	r3, r3
 8020ae0:	80fb      	strh	r3, [r7, #6]
        ret   = -sin0_90_table[angle];
 8020ae2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8020ae6:	4a10      	ldr	r2, [pc, #64]	; (8020b28 <_lv_trigo_sin+0xdc>)
 8020ae8:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
 8020aec:	b29b      	uxth	r3, r3
 8020aee:	425b      	negs	r3, r3
 8020af0:	b29b      	uxth	r3, r3
 8020af2:	81fb      	strh	r3, [r7, #14]
 8020af4:	e00d      	b.n	8020b12 <_lv_trigo_sin+0xc6>
    }
    else {   /*angle >=270*/
        angle = 360 - angle;
 8020af6:	88fb      	ldrh	r3, [r7, #6]
 8020af8:	f5c3 73b4 	rsb	r3, r3, #360	; 0x168
 8020afc:	b29b      	uxth	r3, r3
 8020afe:	80fb      	strh	r3, [r7, #6]
        ret   = -sin0_90_table[angle];
 8020b00:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8020b04:	4a08      	ldr	r2, [pc, #32]	; (8020b28 <_lv_trigo_sin+0xdc>)
 8020b06:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
 8020b0a:	b29b      	uxth	r3, r3
 8020b0c:	425b      	negs	r3, r3
 8020b0e:	b29b      	uxth	r3, r3
 8020b10:	81fb      	strh	r3, [r7, #14]
    }

    return ret;
 8020b12:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
 8020b16:	4618      	mov	r0, r3
 8020b18:	3714      	adds	r7, #20
 8020b1a:	46bd      	mov	sp, r7
 8020b1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b20:	4770      	bx	lr
 8020b22:	bf00      	nop
 8020b24:	b60b60b7 	.word	0xb60b60b7
 8020b28:	080f2324 	.word	0x080f2324

08020b2c <_lv_sqrt>:
 * If root < 16: mask = 0x80
 * If root < 256: mask = 0x800
 * Else: mask = 0x8000
 */
LV_ATTRIBUTE_FAST_MEM void _lv_sqrt(uint32_t x, lv_sqrt_res_t * q, uint32_t mask)
{
 8020b2c:	b480      	push	{r7}
 8020b2e:	b087      	sub	sp, #28
 8020b30:	af00      	add	r7, sp, #0
 8020b32:	60f8      	str	r0, [r7, #12]
 8020b34:	60b9      	str	r1, [r7, #8]
 8020b36:	607a      	str	r2, [r7, #4]
    x = x << 8; /*To get 4 bit precision. (sqrt(256) = 16 = 4 bit)*/
 8020b38:	68fb      	ldr	r3, [r7, #12]
 8020b3a:	021b      	lsls	r3, r3, #8
 8020b3c:	60fb      	str	r3, [r7, #12]

    uint32_t root = 0;
 8020b3e:	2300      	movs	r3, #0
 8020b40:	617b      	str	r3, [r7, #20]
    uint32_t trial;
    // http://ww1.microchip.com/...en/AppNotes/91040a.pdf
    do {
        trial = root + mask;
 8020b42:	697a      	ldr	r2, [r7, #20]
 8020b44:	687b      	ldr	r3, [r7, #4]
 8020b46:	4413      	add	r3, r2
 8020b48:	613b      	str	r3, [r7, #16]
        if((uint32_t)trial * trial <= x) root = trial;
 8020b4a:	693b      	ldr	r3, [r7, #16]
 8020b4c:	fb03 f303 	mul.w	r3, r3, r3
 8020b50:	68fa      	ldr	r2, [r7, #12]
 8020b52:	429a      	cmp	r2, r3
 8020b54:	d301      	bcc.n	8020b5a <_lv_sqrt+0x2e>
 8020b56:	693b      	ldr	r3, [r7, #16]
 8020b58:	617b      	str	r3, [r7, #20]
        mask = mask >> 1;
 8020b5a:	687b      	ldr	r3, [r7, #4]
 8020b5c:	085b      	lsrs	r3, r3, #1
 8020b5e:	607b      	str	r3, [r7, #4]
    } while(mask);
 8020b60:	687b      	ldr	r3, [r7, #4]
 8020b62:	2b00      	cmp	r3, #0
 8020b64:	d1ed      	bne.n	8020b42 <_lv_sqrt+0x16>

    q->i = (uint32_t) root >> 4;
 8020b66:	697b      	ldr	r3, [r7, #20]
 8020b68:	091b      	lsrs	r3, r3, #4
 8020b6a:	b29a      	uxth	r2, r3
 8020b6c:	68bb      	ldr	r3, [r7, #8]
 8020b6e:	801a      	strh	r2, [r3, #0]
    q->f = (uint32_t)(root & 0xf) << 4;
 8020b70:	697b      	ldr	r3, [r7, #20]
 8020b72:	b29b      	uxth	r3, r3
 8020b74:	011b      	lsls	r3, r3, #4
 8020b76:	b29b      	uxth	r3, r3
 8020b78:	b2db      	uxtb	r3, r3
 8020b7a:	b29a      	uxth	r2, r3
 8020b7c:	68bb      	ldr	r3, [r7, #8]
 8020b7e:	805a      	strh	r2, [r3, #2]
}
 8020b80:	bf00      	nop
 8020b82:	371c      	adds	r7, #28
 8020b84:	46bd      	mov	sp, r7
 8020b86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020b8a:	4770      	bx	lr

08020b8c <_lv_mem_init>:

/**
 * Initialize the dyn_mem module (work memory and other variables)
 */
void _lv_mem_init(void)
{
 8020b8c:	b480      	push	{r7}
 8020b8e:	b083      	sub	sp, #12
 8020b90:	af00      	add	r7, sp, #0
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
 8020b92:	4b0d      	ldr	r3, [pc, #52]	; (8020bc8 <_lv_mem_init+0x3c>)
 8020b94:	4a0d      	ldr	r2, [pc, #52]	; (8020bcc <_lv_mem_init+0x40>)
 8020b96:	601a      	str	r2, [r3, #0]
    mem_max_size = 0;
 8020b98:	4b0d      	ldr	r3, [pc, #52]	; (8020bd0 <_lv_mem_init+0x44>)
 8020b9a:	2200      	movs	r2, #0
 8020b9c:	601a      	str	r2, [r3, #0]
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
 8020b9e:	4b0a      	ldr	r3, [pc, #40]	; (8020bc8 <_lv_mem_init+0x3c>)
 8020ba0:	681b      	ldr	r3, [r3, #0]
 8020ba2:	607b      	str	r3, [r7, #4]
    full->header.s.used = 0;
 8020ba4:	687a      	ldr	r2, [r7, #4]
 8020ba6:	7813      	ldrb	r3, [r2, #0]
 8020ba8:	f36f 0300 	bfc	r3, #0, #1
 8020bac:	7013      	strb	r3, [r2, #0]
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
 8020bae:	687a      	ldr	r2, [r7, #4]
 8020bb0:	6813      	ldr	r3, [r2, #0]
 8020bb2:	f647 71fc 	movw	r1, #32764	; 0x7ffc
 8020bb6:	f361 035f 	bfi	r3, r1, #1, #31
 8020bba:	6013      	str	r3, [r2, #0]
#endif
}
 8020bbc:	bf00      	nop
 8020bbe:	370c      	adds	r7, #12
 8020bc0:	46bd      	mov	sp, r7
 8020bc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020bc6:	4770      	bx	lr
 8020bc8:	2000a2e0 	.word	0x2000a2e0
 8020bcc:	2000a30c 	.word	0x2000a30c
 8020bd0:	2000a2e8 	.word	0x2000a2e8

08020bd4 <lv_mem_alloc>:
 * Allocate a memory dynamically
 * @param size size of the memory to allocate in bytes
 * @return pointer to the allocated memory
 */
void * lv_mem_alloc(size_t size)
{
 8020bd4:	b580      	push	{r7, lr}
 8020bd6:	b084      	sub	sp, #16
 8020bd8:	af00      	add	r7, sp, #0
 8020bda:	6078      	str	r0, [r7, #4]
    if(size == 0) {
 8020bdc:	687b      	ldr	r3, [r7, #4]
 8020bde:	2b00      	cmp	r3, #0
 8020be0:	d101      	bne.n	8020be6 <lv_mem_alloc+0x12>
        return &zero_mem;
 8020be2:	4b1e      	ldr	r3, [pc, #120]	; (8020c5c <lv_mem_alloc+0x88>)
 8020be4:	e035      	b.n	8020c52 <lv_mem_alloc+0x7e>
#ifdef LV_ARCH_64
    /*Round the size up to 8*/
    size = (size + 7) & (~0x7);
#else
    /*Round the size up to 4*/
    size = (size + 3) & (~0x3);
 8020be6:	687b      	ldr	r3, [r7, #4]
 8020be8:	3303      	adds	r3, #3
 8020bea:	f023 0303 	bic.w	r3, r3, #3
 8020bee:	607b      	str	r3, [r7, #4]
#endif
    void * alloc = NULL;
 8020bf0:	2300      	movs	r3, #0
 8020bf2:	60fb      	str	r3, [r7, #12]

#if LV_MEM_CUSTOM == 0
    /*Use the built-in allocators*/
    lv_mem_ent_t * e = NULL;
 8020bf4:	2300      	movs	r3, #0
 8020bf6:	60bb      	str	r3, [r7, #8]

    /* Search for a appropriate entry*/
    do {
        /* Get the next entry*/
        e = ent_get_next(e);
 8020bf8:	68b8      	ldr	r0, [r7, #8]
 8020bfa:	f000 fe61 	bl	80218c0 <ent_get_next>
 8020bfe:	60b8      	str	r0, [r7, #8]

        /*If there is next entry then try to allocate there*/
        if(e != NULL) {
 8020c00:	68bb      	ldr	r3, [r7, #8]
 8020c02:	2b00      	cmp	r3, #0
 8020c04:	d004      	beq.n	8020c10 <lv_mem_alloc+0x3c>
            alloc = ent_alloc(e, size);
 8020c06:	6879      	ldr	r1, [r7, #4]
 8020c08:	68b8      	ldr	r0, [r7, #8]
 8020c0a:	f000 fe85 	bl	8021918 <ent_alloc>
 8020c0e:	60f8      	str	r0, [r7, #12]
        }
        /* End if there is not next entry OR the alloc. is successful*/
    } while(e != NULL && alloc == NULL);
 8020c10:	68bb      	ldr	r3, [r7, #8]
 8020c12:	2b00      	cmp	r3, #0
 8020c14:	d002      	beq.n	8020c1c <lv_mem_alloc+0x48>
 8020c16:	68fb      	ldr	r3, [r7, #12]
 8020c18:	2b00      	cmp	r3, #0
 8020c1a:	d0ed      	beq.n	8020bf8 <lv_mem_alloc+0x24>

#if LV_MEM_ADD_JUNK
    if(alloc != NULL) _lv_memset(alloc, 0xaa, size);
#endif

    if(alloc == NULL) {
 8020c1c:	68fb      	ldr	r3, [r7, #12]
 8020c1e:	2b00      	cmp	r3, #0
 8020c20:	d016      	beq.n	8020c50 <lv_mem_alloc+0x7c>
        LV_LOG_WARN("Couldn't allocate memory");
    }
    else {
#if LV_MEM_CUSTOM == 0
        /* just a safety check, should always be true */
        if((uintptr_t) alloc > (uintptr_t) work_mem) {
 8020c22:	68fb      	ldr	r3, [r7, #12]
 8020c24:	4a0e      	ldr	r2, [pc, #56]	; (8020c60 <lv_mem_alloc+0x8c>)
 8020c26:	6812      	ldr	r2, [r2, #0]
 8020c28:	4293      	cmp	r3, r2
 8020c2a:	d911      	bls.n	8020c50 <lv_mem_alloc+0x7c>
            if((((uintptr_t) alloc - (uintptr_t) work_mem) + size) > mem_max_size) {
 8020c2c:	68fb      	ldr	r3, [r7, #12]
 8020c2e:	4a0c      	ldr	r2, [pc, #48]	; (8020c60 <lv_mem_alloc+0x8c>)
 8020c30:	6812      	ldr	r2, [r2, #0]
 8020c32:	1a9a      	subs	r2, r3, r2
 8020c34:	687b      	ldr	r3, [r7, #4]
 8020c36:	441a      	add	r2, r3
 8020c38:	4b0a      	ldr	r3, [pc, #40]	; (8020c64 <lv_mem_alloc+0x90>)
 8020c3a:	681b      	ldr	r3, [r3, #0]
 8020c3c:	429a      	cmp	r2, r3
 8020c3e:	d907      	bls.n	8020c50 <lv_mem_alloc+0x7c>
                mem_max_size = ((uintptr_t) alloc - (uintptr_t) work_mem) + size;
 8020c40:	68fb      	ldr	r3, [r7, #12]
 8020c42:	4a07      	ldr	r2, [pc, #28]	; (8020c60 <lv_mem_alloc+0x8c>)
 8020c44:	6812      	ldr	r2, [r2, #0]
 8020c46:	1a9a      	subs	r2, r3, r2
 8020c48:	687b      	ldr	r3, [r7, #4]
 8020c4a:	4413      	add	r3, r2
 8020c4c:	4a05      	ldr	r2, [pc, #20]	; (8020c64 <lv_mem_alloc+0x90>)
 8020c4e:	6013      	str	r3, [r2, #0]
            }
        }
#endif
    }

    return alloc;
 8020c50:	68fb      	ldr	r3, [r7, #12]
}
 8020c52:	4618      	mov	r0, r3
 8020c54:	3710      	adds	r7, #16
 8020c56:	46bd      	mov	sp, r7
 8020c58:	bd80      	pop	{r7, pc}
 8020c5a:	bf00      	nop
 8020c5c:	2000a2e4 	.word	0x2000a2e4
 8020c60:	2000a2e0 	.word	0x2000a2e0
 8020c64:	2000a2e8 	.word	0x2000a2e8

08020c68 <lv_mem_free>:
/**
 * Free an allocated data
 * @param data pointer to an allocated memory
 */
void lv_mem_free(const void * data)
{
 8020c68:	b580      	push	{r7, lr}
 8020c6a:	b084      	sub	sp, #16
 8020c6c:	af00      	add	r7, sp, #0
 8020c6e:	6078      	str	r0, [r7, #4]
    if(data == &zero_mem) return;
 8020c70:	687b      	ldr	r3, [r7, #4]
 8020c72:	4a26      	ldr	r2, [pc, #152]	; (8020d0c <lv_mem_free+0xa4>)
 8020c74:	4293      	cmp	r3, r2
 8020c76:	d040      	beq.n	8020cfa <lv_mem_free+0x92>
    if(data == NULL) return;
 8020c78:	687b      	ldr	r3, [r7, #4]
 8020c7a:	2b00      	cmp	r3, #0
 8020c7c:	d03f      	beq.n	8020cfe <lv_mem_free+0x96>
    _lv_memset((void *)data, 0xbb, _lv_mem_get_size(data));
#endif

#if LV_ENABLE_GC == 0
    /*e points to the header*/
    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
 8020c7e:	687b      	ldr	r3, [r7, #4]
 8020c80:	3b04      	subs	r3, #4
 8020c82:	60bb      	str	r3, [r7, #8]
    e->header.s.used = 0;
 8020c84:	68ba      	ldr	r2, [r7, #8]
 8020c86:	7813      	ldrb	r3, [r2, #0]
 8020c88:	f36f 0300 	bfc	r3, #0, #1
 8020c8c:	7013      	strb	r3, [r2, #0]
#endif

#if LV_MEM_CUSTOM == 0
#if LV_MEM_AUTO_DEFRAG
    static uint16_t full_defrag_cnt = 0;
    full_defrag_cnt++;
 8020c8e:	4b20      	ldr	r3, [pc, #128]	; (8020d10 <lv_mem_free+0xa8>)
 8020c90:	881b      	ldrh	r3, [r3, #0]
 8020c92:	3301      	adds	r3, #1
 8020c94:	b29a      	uxth	r2, r3
 8020c96:	4b1e      	ldr	r3, [pc, #120]	; (8020d10 <lv_mem_free+0xa8>)
 8020c98:	801a      	strh	r2, [r3, #0]
    if(full_defrag_cnt < LV_MEM_FULL_DEFRAG_CNT) {
 8020c9a:	4b1d      	ldr	r3, [pc, #116]	; (8020d10 <lv_mem_free+0xa8>)
 8020c9c:	881b      	ldrh	r3, [r3, #0]
 8020c9e:	2b0f      	cmp	r3, #15
 8020ca0:	d825      	bhi.n	8020cee <lv_mem_free+0x86>
        /* Make a simple defrag.
         * Join the following free entries after this*/
        lv_mem_ent_t * e_next;
        e_next = ent_get_next(e);
 8020ca2:	68b8      	ldr	r0, [r7, #8]
 8020ca4:	f000 fe0c 	bl	80218c0 <ent_get_next>
 8020ca8:	60f8      	str	r0, [r7, #12]
        while(e_next != NULL) {
 8020caa:	e01c      	b.n	8020ce6 <lv_mem_free+0x7e>
            if(e_next->header.s.used == 0) {
 8020cac:	68fb      	ldr	r3, [r7, #12]
 8020cae:	781b      	ldrb	r3, [r3, #0]
 8020cb0:	f003 0301 	and.w	r3, r3, #1
 8020cb4:	b2db      	uxtb	r3, r3
 8020cb6:	2b00      	cmp	r3, #0
 8020cb8:	d123      	bne.n	8020d02 <lv_mem_free+0x9a>
                e->header.s.d_size += e_next->header.s.d_size + sizeof(e->header);
 8020cba:	68bb      	ldr	r3, [r7, #8]
 8020cbc:	681b      	ldr	r3, [r3, #0]
 8020cbe:	f3c3 035e 	ubfx	r3, r3, #1, #31
 8020cc2:	461a      	mov	r2, r3
 8020cc4:	68fb      	ldr	r3, [r7, #12]
 8020cc6:	681b      	ldr	r3, [r3, #0]
 8020cc8:	f3c3 035e 	ubfx	r3, r3, #1, #31
 8020ccc:	4413      	add	r3, r2
 8020cce:	3304      	adds	r3, #4
 8020cd0:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 8020cd4:	68ba      	ldr	r2, [r7, #8]
 8020cd6:	6813      	ldr	r3, [r2, #0]
 8020cd8:	f361 035f 	bfi	r3, r1, #1, #31
 8020cdc:	6013      	str	r3, [r2, #0]
            }
            else {
                break;
            }
            e_next = ent_get_next(e_next);
 8020cde:	68f8      	ldr	r0, [r7, #12]
 8020ce0:	f000 fdee 	bl	80218c0 <ent_get_next>
 8020ce4:	60f8      	str	r0, [r7, #12]
        while(e_next != NULL) {
 8020ce6:	68fb      	ldr	r3, [r7, #12]
 8020ce8:	2b00      	cmp	r3, #0
 8020cea:	d1df      	bne.n	8020cac <lv_mem_free+0x44>
 8020cec:	e00a      	b.n	8020d04 <lv_mem_free+0x9c>
        }
    }
    else {
        full_defrag_cnt = 0;
 8020cee:	4b08      	ldr	r3, [pc, #32]	; (8020d10 <lv_mem_free+0xa8>)
 8020cf0:	2200      	movs	r2, #0
 8020cf2:	801a      	strh	r2, [r3, #0]
        lv_mem_defrag();
 8020cf4:	f000 f860 	bl	8020db8 <lv_mem_defrag>
 8020cf8:	e004      	b.n	8020d04 <lv_mem_free+0x9c>
    if(data == &zero_mem) return;
 8020cfa:	bf00      	nop
 8020cfc:	e002      	b.n	8020d04 <lv_mem_free+0x9c>
    if(data == NULL) return;
 8020cfe:	bf00      	nop
 8020d00:	e000      	b.n	8020d04 <lv_mem_free+0x9c>
                break;
 8020d02:	bf00      	nop
    LV_MEM_CUSTOM_FREE(e);
#else
    LV_MEM_CUSTOM_FREE((void *)data);
#endif /*LV_ENABLE_GC*/
#endif
}
 8020d04:	3710      	adds	r7, #16
 8020d06:	46bd      	mov	sp, r7
 8020d08:	bd80      	pop	{r7, pc}
 8020d0a:	bf00      	nop
 8020d0c:	2000a2e4 	.word	0x2000a2e4
 8020d10:	2001230c 	.word	0x2001230c

08020d14 <lv_mem_realloc>:
 */

#if LV_ENABLE_GC == 0

void * lv_mem_realloc(void * data_p, size_t new_size)
{
 8020d14:	b580      	push	{r7, lr}
 8020d16:	b086      	sub	sp, #24
 8020d18:	af00      	add	r7, sp, #0
 8020d1a:	6078      	str	r0, [r7, #4]
 8020d1c:	6039      	str	r1, [r7, #0]
#ifdef LV_ARCH_64
    /*Round the size up to 8*/
    new_size = (new_size + 7) & (~0x7);
#else
    /*Round the size up to 4*/
    new_size = (new_size + 3) & (~0x3);
 8020d1e:	683b      	ldr	r3, [r7, #0]
 8020d20:	3303      	adds	r3, #3
 8020d22:	f023 0303 	bic.w	r3, r3, #3
 8020d26:	603b      	str	r3, [r7, #0]
#endif

    /*data_p could be previously freed pointer (in this case it is invalid)*/
    if(data_p != NULL) {
 8020d28:	687b      	ldr	r3, [r7, #4]
 8020d2a:	2b00      	cmp	r3, #0
 8020d2c:	d00b      	beq.n	8020d46 <lv_mem_realloc+0x32>
        lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data_p - sizeof(lv_mem_header_t));
 8020d2e:	687b      	ldr	r3, [r7, #4]
 8020d30:	3b04      	subs	r3, #4
 8020d32:	617b      	str	r3, [r7, #20]
        if(e->header.s.used == 0) {
 8020d34:	697b      	ldr	r3, [r7, #20]
 8020d36:	781b      	ldrb	r3, [r3, #0]
 8020d38:	f003 0301 	and.w	r3, r3, #1
 8020d3c:	b2db      	uxtb	r3, r3
 8020d3e:	2b00      	cmp	r3, #0
 8020d40:	d101      	bne.n	8020d46 <lv_mem_realloc+0x32>
            data_p = NULL;
 8020d42:	2300      	movs	r3, #0
 8020d44:	607b      	str	r3, [r7, #4]
        }
    }

    uint32_t old_size = _lv_mem_get_size(data_p);
 8020d46:	6878      	ldr	r0, [r7, #4]
 8020d48:	f000 f884 	bl	8020e54 <_lv_mem_get_size>
 8020d4c:	6138      	str	r0, [r7, #16]
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
 8020d4e:	693a      	ldr	r2, [r7, #16]
 8020d50:	683b      	ldr	r3, [r7, #0]
 8020d52:	429a      	cmp	r2, r3
 8020d54:	d101      	bne.n	8020d5a <lv_mem_realloc+0x46>
 8020d56:	687b      	ldr	r3, [r7, #4]
 8020d58:	e02a      	b.n	8020db0 <lv_mem_realloc+0x9c>

#if LV_MEM_CUSTOM == 0
    /* Truncate the memory if the new size is smaller. */
    if(new_size < old_size) {
 8020d5a:	683a      	ldr	r2, [r7, #0]
 8020d5c:	693b      	ldr	r3, [r7, #16]
 8020d5e:	429a      	cmp	r2, r3
 8020d60:	d209      	bcs.n	8020d76 <lv_mem_realloc+0x62>
        lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data_p - sizeof(lv_mem_header_t));
 8020d62:	687b      	ldr	r3, [r7, #4]
 8020d64:	3b04      	subs	r3, #4
 8020d66:	60bb      	str	r3, [r7, #8]
        ent_trunc(e, new_size);
 8020d68:	6839      	ldr	r1, [r7, #0]
 8020d6a:	68b8      	ldr	r0, [r7, #8]
 8020d6c:	f000 fdfb 	bl	8021966 <ent_trunc>
        return &e->first_data;
 8020d70:	68bb      	ldr	r3, [r7, #8]
 8020d72:	3304      	adds	r3, #4
 8020d74:	e01c      	b.n	8020db0 <lv_mem_realloc+0x9c>
    }
#endif

    void * new_p;
    new_p = lv_mem_alloc(new_size);
 8020d76:	6838      	ldr	r0, [r7, #0]
 8020d78:	f7ff ff2c 	bl	8020bd4 <lv_mem_alloc>
 8020d7c:	60f8      	str	r0, [r7, #12]
    if(new_p == NULL) {
 8020d7e:	68fb      	ldr	r3, [r7, #12]
 8020d80:	2b00      	cmp	r3, #0
 8020d82:	d101      	bne.n	8020d88 <lv_mem_realloc+0x74>
        LV_LOG_WARN("Couldn't allocate memory");
        return NULL;
 8020d84:	2300      	movs	r3, #0
 8020d86:	e013      	b.n	8020db0 <lv_mem_realloc+0x9c>
    }

    if(data_p != NULL) {
 8020d88:	687b      	ldr	r3, [r7, #4]
 8020d8a:	2b00      	cmp	r3, #0
 8020d8c:	d00f      	beq.n	8020dae <lv_mem_realloc+0x9a>
        /*Copy the old data to the new. Use the smaller size*/
        if(old_size != 0) {
 8020d8e:	693b      	ldr	r3, [r7, #16]
 8020d90:	2b00      	cmp	r3, #0
 8020d92:	d00c      	beq.n	8020dae <lv_mem_realloc+0x9a>
            _lv_memcpy(new_p, data_p, LV_MATH_MIN(new_size, old_size));
 8020d94:	693a      	ldr	r2, [r7, #16]
 8020d96:	683b      	ldr	r3, [r7, #0]
 8020d98:	4293      	cmp	r3, r2
 8020d9a:	bf28      	it	cs
 8020d9c:	4613      	movcs	r3, r2
 8020d9e:	461a      	mov	r2, r3
 8020da0:	6879      	ldr	r1, [r7, #4]
 8020da2:	68f8      	ldr	r0, [r7, #12]
 8020da4:	f000 f9da 	bl	802115c <_lv_memcpy>
            lv_mem_free(data_p);
 8020da8:	6878      	ldr	r0, [r7, #4]
 8020daa:	f7ff ff5d 	bl	8020c68 <lv_mem_free>
        }
    }


    return new_p;
 8020dae:	68fb      	ldr	r3, [r7, #12]
}
 8020db0:	4618      	mov	r0, r3
 8020db2:	3718      	adds	r7, #24
 8020db4:	46bd      	mov	sp, r7
 8020db6:	bd80      	pop	{r7, pc}

08020db8 <lv_mem_defrag>:

/**
 * Join the adjacent free memory blocks
 */
void lv_mem_defrag(void)
{
 8020db8:	b580      	push	{r7, lr}
 8020dba:	b082      	sub	sp, #8
 8020dbc:	af00      	add	r7, sp, #0
#if LV_MEM_CUSTOM == 0
    lv_mem_ent_t * e_free;
    lv_mem_ent_t * e_next;
    e_free = ent_get_next(NULL);
 8020dbe:	2000      	movs	r0, #0
 8020dc0:	f000 fd7e 	bl	80218c0 <ent_get_next>
 8020dc4:	6078      	str	r0, [r7, #4]

    while(1) {
        /*Search the next free entry*/
        while(e_free != NULL) {
 8020dc6:	e00a      	b.n	8020dde <lv_mem_defrag+0x26>
            if(e_free->header.s.used != 0) {
 8020dc8:	687b      	ldr	r3, [r7, #4]
 8020dca:	781b      	ldrb	r3, [r3, #0]
 8020dcc:	f003 0301 	and.w	r3, r3, #1
 8020dd0:	b2db      	uxtb	r3, r3
 8020dd2:	2b00      	cmp	r3, #0
 8020dd4:	d007      	beq.n	8020de6 <lv_mem_defrag+0x2e>
                e_free = ent_get_next(e_free);
 8020dd6:	6878      	ldr	r0, [r7, #4]
 8020dd8:	f000 fd72 	bl	80218c0 <ent_get_next>
 8020ddc:	6078      	str	r0, [r7, #4]
        while(e_free != NULL) {
 8020dde:	687b      	ldr	r3, [r7, #4]
 8020de0:	2b00      	cmp	r3, #0
 8020de2:	d1f1      	bne.n	8020dc8 <lv_mem_defrag+0x10>
 8020de4:	e000      	b.n	8020de8 <lv_mem_defrag+0x30>
            }
            else {
                break;
 8020de6:	bf00      	nop
            }
        }

        if(e_free == NULL) return;
 8020de8:	687b      	ldr	r3, [r7, #4]
 8020dea:	2b00      	cmp	r3, #0
 8020dec:	d02c      	beq.n	8020e48 <lv_mem_defrag+0x90>

        /*Joint the following free entries to the free*/
        e_next = ent_get_next(e_free);
 8020dee:	6878      	ldr	r0, [r7, #4]
 8020df0:	f000 fd66 	bl	80218c0 <ent_get_next>
 8020df4:	6038      	str	r0, [r7, #0]
        while(e_next != NULL) {
 8020df6:	e01c      	b.n	8020e32 <lv_mem_defrag+0x7a>
            if(e_next->header.s.used == 0) {
 8020df8:	683b      	ldr	r3, [r7, #0]
 8020dfa:	781b      	ldrb	r3, [r3, #0]
 8020dfc:	f003 0301 	and.w	r3, r3, #1
 8020e00:	b2db      	uxtb	r3, r3
 8020e02:	2b00      	cmp	r3, #0
 8020e04:	d119      	bne.n	8020e3a <lv_mem_defrag+0x82>
                e_free->header.s.d_size += e_next->header.s.d_size + sizeof(e_next->header);
 8020e06:	687b      	ldr	r3, [r7, #4]
 8020e08:	681b      	ldr	r3, [r3, #0]
 8020e0a:	f3c3 035e 	ubfx	r3, r3, #1, #31
 8020e0e:	461a      	mov	r2, r3
 8020e10:	683b      	ldr	r3, [r7, #0]
 8020e12:	681b      	ldr	r3, [r3, #0]
 8020e14:	f3c3 035e 	ubfx	r3, r3, #1, #31
 8020e18:	4413      	add	r3, r2
 8020e1a:	3304      	adds	r3, #4
 8020e1c:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 8020e20:	687a      	ldr	r2, [r7, #4]
 8020e22:	6813      	ldr	r3, [r2, #0]
 8020e24:	f361 035f 	bfi	r3, r1, #1, #31
 8020e28:	6013      	str	r3, [r2, #0]
            }
            else {
                break;
            }

            e_next = ent_get_next(e_next);
 8020e2a:	6838      	ldr	r0, [r7, #0]
 8020e2c:	f000 fd48 	bl	80218c0 <ent_get_next>
 8020e30:	6038      	str	r0, [r7, #0]
        while(e_next != NULL) {
 8020e32:	683b      	ldr	r3, [r7, #0]
 8020e34:	2b00      	cmp	r3, #0
 8020e36:	d1df      	bne.n	8020df8 <lv_mem_defrag+0x40>
 8020e38:	e000      	b.n	8020e3c <lv_mem_defrag+0x84>
                break;
 8020e3a:	bf00      	nop
        }

        if(e_next == NULL) return;
 8020e3c:	683b      	ldr	r3, [r7, #0]
 8020e3e:	2b00      	cmp	r3, #0
 8020e40:	d004      	beq.n	8020e4c <lv_mem_defrag+0x94>

        /*Continue from the lastly checked entry*/
        e_free = e_next;
 8020e42:	683b      	ldr	r3, [r7, #0]
 8020e44:	607b      	str	r3, [r7, #4]
        while(e_free != NULL) {
 8020e46:	e7ca      	b.n	8020dde <lv_mem_defrag+0x26>
        if(e_free == NULL) return;
 8020e48:	bf00      	nop
 8020e4a:	e000      	b.n	8020e4e <lv_mem_defrag+0x96>
        if(e_next == NULL) return;
 8020e4c:	bf00      	nop
    }
#endif
}
 8020e4e:	3708      	adds	r7, #8
 8020e50:	46bd      	mov	sp, r7
 8020e52:	bd80      	pop	{r7, pc}

08020e54 <_lv_mem_get_size>:
 */

#if LV_ENABLE_GC == 0

uint32_t _lv_mem_get_size(const void * data)
{
 8020e54:	b480      	push	{r7}
 8020e56:	b085      	sub	sp, #20
 8020e58:	af00      	add	r7, sp, #0
 8020e5a:	6078      	str	r0, [r7, #4]
    if(data == NULL) return 0;
 8020e5c:	687b      	ldr	r3, [r7, #4]
 8020e5e:	2b00      	cmp	r3, #0
 8020e60:	d101      	bne.n	8020e66 <_lv_mem_get_size+0x12>
 8020e62:	2300      	movs	r3, #0
 8020e64:	e00c      	b.n	8020e80 <_lv_mem_get_size+0x2c>
    if(data == &zero_mem) return 0;
 8020e66:	687b      	ldr	r3, [r7, #4]
 8020e68:	4a08      	ldr	r2, [pc, #32]	; (8020e8c <_lv_mem_get_size+0x38>)
 8020e6a:	4293      	cmp	r3, r2
 8020e6c:	d101      	bne.n	8020e72 <_lv_mem_get_size+0x1e>
 8020e6e:	2300      	movs	r3, #0
 8020e70:	e006      	b.n	8020e80 <_lv_mem_get_size+0x2c>

    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
 8020e72:	687b      	ldr	r3, [r7, #4]
 8020e74:	3b04      	subs	r3, #4
 8020e76:	60fb      	str	r3, [r7, #12]

    return e->header.s.d_size;
 8020e78:	68fb      	ldr	r3, [r7, #12]
 8020e7a:	681b      	ldr	r3, [r3, #0]
 8020e7c:	f3c3 035e 	ubfx	r3, r3, #1, #31
}
 8020e80:	4618      	mov	r0, r3
 8020e82:	3714      	adds	r7, #20
 8020e84:	46bd      	mov	sp, r7
 8020e86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020e8a:	4770      	bx	lr
 8020e8c:	2000a2e4 	.word	0x2000a2e4

08020e90 <_lv_mem_buf_get>:
/**
 * Get a temporal buffer with the given size.
 * @param size the required size
 */
void * _lv_mem_buf_get(uint32_t size)
{
 8020e90:	b590      	push	{r4, r7, lr}
 8020e92:	b085      	sub	sp, #20
 8020e94:	af00      	add	r7, sp, #0
 8020e96:	6078      	str	r0, [r7, #4]
    if(size == 0) return NULL;
 8020e98:	687b      	ldr	r3, [r7, #4]
 8020e9a:	2b00      	cmp	r3, #0
 8020e9c:	d101      	bne.n	8020ea2 <_lv_mem_buf_get+0x12>
 8020e9e:	2300      	movs	r3, #0
 8020ea0:	e0ca      	b.n	8021038 <_lv_mem_buf_get+0x1a8>

    /*Try small static buffers first*/
    uint8_t i;
    if(size <= MEM_BUF_SMALL_SIZE) {
 8020ea2:	687b      	ldr	r3, [r7, #4]
 8020ea4:	2b10      	cmp	r3, #16
 8020ea6:	d81f      	bhi.n	8020ee8 <_lv_mem_buf_get+0x58>
        for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
 8020ea8:	2300      	movs	r3, #0
 8020eaa:	73fb      	strb	r3, [r7, #15]
 8020eac:	e019      	b.n	8020ee2 <_lv_mem_buf_get+0x52>
            if(mem_buf_small[i].used == 0) {
 8020eae:	7bfb      	ldrb	r3, [r7, #15]
 8020eb0:	4a63      	ldr	r2, [pc, #396]	; (8021040 <_lv_mem_buf_get+0x1b0>)
 8020eb2:	00db      	lsls	r3, r3, #3
 8020eb4:	4413      	add	r3, r2
 8020eb6:	799b      	ldrb	r3, [r3, #6]
 8020eb8:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8020ebc:	b2db      	uxtb	r3, r3
 8020ebe:	2b00      	cmp	r3, #0
 8020ec0:	d10c      	bne.n	8020edc <_lv_mem_buf_get+0x4c>
                mem_buf_small[i].used = 1;
 8020ec2:	7bfb      	ldrb	r3, [r7, #15]
 8020ec4:	4a5e      	ldr	r2, [pc, #376]	; (8021040 <_lv_mem_buf_get+0x1b0>)
 8020ec6:	00db      	lsls	r3, r3, #3
 8020ec8:	4413      	add	r3, r2
 8020eca:	799a      	ldrb	r2, [r3, #6]
 8020ecc:	f042 0201 	orr.w	r2, r2, #1
 8020ed0:	719a      	strb	r2, [r3, #6]
                return mem_buf_small[i].p;
 8020ed2:	7bfb      	ldrb	r3, [r7, #15]
 8020ed4:	4a5a      	ldr	r2, [pc, #360]	; (8021040 <_lv_mem_buf_get+0x1b0>)
 8020ed6:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8020eda:	e0ad      	b.n	8021038 <_lv_mem_buf_get+0x1a8>
        for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
 8020edc:	7bfb      	ldrb	r3, [r7, #15]
 8020ede:	3301      	adds	r3, #1
 8020ee0:	73fb      	strb	r3, [r7, #15]
 8020ee2:	7bfb      	ldrb	r3, [r7, #15]
 8020ee4:	2b01      	cmp	r3, #1
 8020ee6:	d9e2      	bls.n	8020eae <_lv_mem_buf_get+0x1e>
            }
        }
    }

    /*Try to find a free buffer with suitable size */
    int8_t i_guess = -1;
 8020ee8:	23ff      	movs	r3, #255	; 0xff
 8020eea:	73bb      	strb	r3, [r7, #14]
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
 8020eec:	2300      	movs	r3, #0
 8020eee:	73fb      	strb	r3, [r7, #15]
 8020ef0:	e041      	b.n	8020f76 <_lv_mem_buf_get+0xe6>
        if(LV_GC_ROOT(_lv_mem_buf[i]).used == 0 && LV_GC_ROOT(_lv_mem_buf[i]).size >= size) {
 8020ef2:	7bfb      	ldrb	r3, [r7, #15]
 8020ef4:	4a53      	ldr	r2, [pc, #332]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020ef6:	00db      	lsls	r3, r3, #3
 8020ef8:	4413      	add	r3, r2
 8020efa:	799b      	ldrb	r3, [r3, #6]
 8020efc:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8020f00:	b2db      	uxtb	r3, r3
 8020f02:	2b00      	cmp	r3, #0
 8020f04:	d134      	bne.n	8020f70 <_lv_mem_buf_get+0xe0>
 8020f06:	7bfb      	ldrb	r3, [r7, #15]
 8020f08:	4a4e      	ldr	r2, [pc, #312]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020f0a:	00db      	lsls	r3, r3, #3
 8020f0c:	4413      	add	r3, r2
 8020f0e:	889b      	ldrh	r3, [r3, #4]
 8020f10:	461a      	mov	r2, r3
 8020f12:	687b      	ldr	r3, [r7, #4]
 8020f14:	4293      	cmp	r3, r2
 8020f16:	d82b      	bhi.n	8020f70 <_lv_mem_buf_get+0xe0>
            if(LV_GC_ROOT(_lv_mem_buf[i]).size == size) {
 8020f18:	7bfb      	ldrb	r3, [r7, #15]
 8020f1a:	4a4a      	ldr	r2, [pc, #296]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020f1c:	00db      	lsls	r3, r3, #3
 8020f1e:	4413      	add	r3, r2
 8020f20:	889b      	ldrh	r3, [r3, #4]
 8020f22:	461a      	mov	r2, r3
 8020f24:	687b      	ldr	r3, [r7, #4]
 8020f26:	4293      	cmp	r3, r2
 8020f28:	d10c      	bne.n	8020f44 <_lv_mem_buf_get+0xb4>
                LV_GC_ROOT(_lv_mem_buf[i]).used = 1;
 8020f2a:	7bfb      	ldrb	r3, [r7, #15]
 8020f2c:	4a45      	ldr	r2, [pc, #276]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020f2e:	00db      	lsls	r3, r3, #3
 8020f30:	4413      	add	r3, r2
 8020f32:	799a      	ldrb	r2, [r3, #6]
 8020f34:	f042 0201 	orr.w	r2, r2, #1
 8020f38:	719a      	strb	r2, [r3, #6]
                return LV_GC_ROOT(_lv_mem_buf[i]).p;
 8020f3a:	7bfb      	ldrb	r3, [r7, #15]
 8020f3c:	4a41      	ldr	r2, [pc, #260]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020f3e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8020f42:	e079      	b.n	8021038 <_lv_mem_buf_get+0x1a8>
            }
            else if(i_guess < 0) {
 8020f44:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8020f48:	2b00      	cmp	r3, #0
 8020f4a:	da02      	bge.n	8020f52 <_lv_mem_buf_get+0xc2>
                i_guess = i;
 8020f4c:	7bfb      	ldrb	r3, [r7, #15]
 8020f4e:	73bb      	strb	r3, [r7, #14]
 8020f50:	e00e      	b.n	8020f70 <_lv_mem_buf_get+0xe0>
            }
            /*If size of `i` is closer to `size` prefer it*/
            else if(LV_GC_ROOT(_lv_mem_buf[i]).size < LV_GC_ROOT(_lv_mem_buf[i_guess]).size) {
 8020f52:	7bfb      	ldrb	r3, [r7, #15]
 8020f54:	4a3b      	ldr	r2, [pc, #236]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020f56:	00db      	lsls	r3, r3, #3
 8020f58:	4413      	add	r3, r2
 8020f5a:	889a      	ldrh	r2, [r3, #4]
 8020f5c:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8020f60:	4938      	ldr	r1, [pc, #224]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020f62:	00db      	lsls	r3, r3, #3
 8020f64:	440b      	add	r3, r1
 8020f66:	889b      	ldrh	r3, [r3, #4]
 8020f68:	429a      	cmp	r2, r3
 8020f6a:	d201      	bcs.n	8020f70 <_lv_mem_buf_get+0xe0>
                i_guess = i;
 8020f6c:	7bfb      	ldrb	r3, [r7, #15]
 8020f6e:	73bb      	strb	r3, [r7, #14]
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
 8020f70:	7bfb      	ldrb	r3, [r7, #15]
 8020f72:	3301      	adds	r3, #1
 8020f74:	73fb      	strb	r3, [r7, #15]
 8020f76:	7bfb      	ldrb	r3, [r7, #15]
 8020f78:	2b0f      	cmp	r3, #15
 8020f7a:	d9ba      	bls.n	8020ef2 <_lv_mem_buf_get+0x62>
            }
        }
    }

    if(i_guess >= 0) {
 8020f7c:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8020f80:	2b00      	cmp	r3, #0
 8020f82:	db0e      	blt.n	8020fa2 <_lv_mem_buf_get+0x112>
        LV_GC_ROOT(_lv_mem_buf[i_guess]).used = 1;
 8020f84:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8020f88:	4a2e      	ldr	r2, [pc, #184]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020f8a:	00db      	lsls	r3, r3, #3
 8020f8c:	4413      	add	r3, r2
 8020f8e:	799a      	ldrb	r2, [r3, #6]
 8020f90:	f042 0201 	orr.w	r2, r2, #1
 8020f94:	719a      	strb	r2, [r3, #6]
        return LV_GC_ROOT(_lv_mem_buf[i_guess]).p;
 8020f96:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8020f9a:	4a2a      	ldr	r2, [pc, #168]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020f9c:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8020fa0:	e04a      	b.n	8021038 <_lv_mem_buf_get+0x1a8>
    }


    /*Reallocate a free buffer*/
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
 8020fa2:	2300      	movs	r3, #0
 8020fa4:	73fb      	strb	r3, [r7, #15]
 8020fa6:	e03c      	b.n	8021022 <_lv_mem_buf_get+0x192>
        if(LV_GC_ROOT(_lv_mem_buf[i]).used == 0) {
 8020fa8:	7bfb      	ldrb	r3, [r7, #15]
 8020faa:	4a26      	ldr	r2, [pc, #152]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020fac:	00db      	lsls	r3, r3, #3
 8020fae:	4413      	add	r3, r2
 8020fb0:	799b      	ldrb	r3, [r3, #6]
 8020fb2:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8020fb6:	b2db      	uxtb	r3, r3
 8020fb8:	2b00      	cmp	r3, #0
 8020fba:	d12f      	bne.n	802101c <_lv_mem_buf_get+0x18c>
            LV_GC_ROOT(_lv_mem_buf[i]).used = 1;
 8020fbc:	7bfb      	ldrb	r3, [r7, #15]
 8020fbe:	4a21      	ldr	r2, [pc, #132]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020fc0:	00db      	lsls	r3, r3, #3
 8020fc2:	4413      	add	r3, r2
 8020fc4:	799a      	ldrb	r2, [r3, #6]
 8020fc6:	f042 0201 	orr.w	r2, r2, #1
 8020fca:	719a      	strb	r2, [r3, #6]
            LV_GC_ROOT(_lv_mem_buf[i]).size = size;
 8020fcc:	7bfb      	ldrb	r3, [r7, #15]
 8020fce:	687a      	ldr	r2, [r7, #4]
 8020fd0:	b291      	uxth	r1, r2
 8020fd2:	4a1c      	ldr	r2, [pc, #112]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020fd4:	00db      	lsls	r3, r3, #3
 8020fd6:	4413      	add	r3, r2
 8020fd8:	460a      	mov	r2, r1
 8020fda:	809a      	strh	r2, [r3, #4]
            /*if this fails you probably need to increase your LV_MEM_SIZE/heap size*/
            LV_GC_ROOT(_lv_mem_buf[i]).p = lv_mem_realloc(LV_GC_ROOT(_lv_mem_buf[i]).p, size);
 8020fdc:	7bfb      	ldrb	r3, [r7, #15]
 8020fde:	4a19      	ldr	r2, [pc, #100]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020fe0:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8020fe4:	7bfc      	ldrb	r4, [r7, #15]
 8020fe6:	6879      	ldr	r1, [r7, #4]
 8020fe8:	4618      	mov	r0, r3
 8020fea:	f7ff fe93 	bl	8020d14 <lv_mem_realloc>
 8020fee:	4603      	mov	r3, r0
 8020ff0:	4a14      	ldr	r2, [pc, #80]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020ff2:	f842 3034 	str.w	r3, [r2, r4, lsl #3]
            if(LV_GC_ROOT(_lv_mem_buf[i]).p == NULL) {
 8020ff6:	7bfb      	ldrb	r3, [r7, #15]
 8020ff8:	4a12      	ldr	r2, [pc, #72]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8020ffa:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8020ffe:	2b00      	cmp	r3, #0
 8021000:	d107      	bne.n	8021012 <_lv_mem_buf_get+0x182>
                LV_DEBUG_ASSERT(false, "Out of memory, can't allocate a new  buffer (increase your LV_MEM_SIZE/heap size", 0x00);
 8021002:	f04f 0200 	mov.w	r2, #0
 8021006:	f04f 0300 	mov.w	r3, #0
 802100a:	480f      	ldr	r0, [pc, #60]	; (8021048 <_lv_mem_buf_get+0x1b8>)
 802100c:	f7ff f880 	bl	8020110 <lv_debug_log_error>
 8021010:	e7fe      	b.n	8021010 <_lv_mem_buf_get+0x180>
            }
            return  LV_GC_ROOT(_lv_mem_buf[i]).p;
 8021012:	7bfb      	ldrb	r3, [r7, #15]
 8021014:	4a0b      	ldr	r2, [pc, #44]	; (8021044 <_lv_mem_buf_get+0x1b4>)
 8021016:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 802101a:	e00d      	b.n	8021038 <_lv_mem_buf_get+0x1a8>
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
 802101c:	7bfb      	ldrb	r3, [r7, #15]
 802101e:	3301      	adds	r3, #1
 8021020:	73fb      	strb	r3, [r7, #15]
 8021022:	7bfb      	ldrb	r3, [r7, #15]
 8021024:	2b0f      	cmp	r3, #15
 8021026:	d9bf      	bls.n	8020fa8 <_lv_mem_buf_get+0x118>
        }
    }

    LV_DEBUG_ASSERT(false, "No free buffer. Increase LV_DRAW_BUF_MAX_NUM.", 0x00);
 8021028:	f04f 0200 	mov.w	r2, #0
 802102c:	f04f 0300 	mov.w	r3, #0
 8021030:	4806      	ldr	r0, [pc, #24]	; (802104c <_lv_mem_buf_get+0x1bc>)
 8021032:	f7ff f86d 	bl	8020110 <lv_debug_log_error>
 8021036:	e7fe      	b.n	8021036 <_lv_mem_buf_get+0x1a6>
    return NULL;
}
 8021038:	4618      	mov	r0, r3
 802103a:	3714      	adds	r7, #20
 802103c:	46bd      	mov	sp, r7
 802103e:	bd90      	pop	{r4, r7, pc}
 8021040:	200001f0 	.word	0x200001f0
 8021044:	2000a1dc 	.word	0x2000a1dc
 8021048:	0802e4f8 	.word	0x0802e4f8
 802104c:	0802e54c 	.word	0x0802e54c

08021050 <_lv_mem_buf_release>:
/**
 * Release a memory buffer
 * @param p buffer to release
 */
void _lv_mem_buf_release(void * p)
{
 8021050:	b480      	push	{r7}
 8021052:	b085      	sub	sp, #20
 8021054:	af00      	add	r7, sp, #0
 8021056:	6078      	str	r0, [r7, #4]
    uint8_t i;

    /*Try small static buffers first*/
    for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
 8021058:	2300      	movs	r3, #0
 802105a:	73fb      	strb	r3, [r7, #15]
 802105c:	e012      	b.n	8021084 <_lv_mem_buf_release+0x34>
        if(mem_buf_small[i].p == p) {
 802105e:	7bfb      	ldrb	r3, [r7, #15]
 8021060:	4a19      	ldr	r2, [pc, #100]	; (80210c8 <_lv_mem_buf_release+0x78>)
 8021062:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8021066:	687a      	ldr	r2, [r7, #4]
 8021068:	429a      	cmp	r2, r3
 802106a:	d108      	bne.n	802107e <_lv_mem_buf_release+0x2e>
            mem_buf_small[i].used = 0;
 802106c:	7bfb      	ldrb	r3, [r7, #15]
 802106e:	4a16      	ldr	r2, [pc, #88]	; (80210c8 <_lv_mem_buf_release+0x78>)
 8021070:	00db      	lsls	r3, r3, #3
 8021072:	4413      	add	r3, r2
 8021074:	799a      	ldrb	r2, [r3, #6]
 8021076:	f36f 0200 	bfc	r2, #0, #1
 802107a:	719a      	strb	r2, [r3, #6]
            return;
 802107c:	e01e      	b.n	80210bc <_lv_mem_buf_release+0x6c>
    for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
 802107e:	7bfb      	ldrb	r3, [r7, #15]
 8021080:	3301      	adds	r3, #1
 8021082:	73fb      	strb	r3, [r7, #15]
 8021084:	7bfb      	ldrb	r3, [r7, #15]
 8021086:	2b01      	cmp	r3, #1
 8021088:	d9e9      	bls.n	802105e <_lv_mem_buf_release+0xe>
        }
    }

    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
 802108a:	2300      	movs	r3, #0
 802108c:	73fb      	strb	r3, [r7, #15]
 802108e:	e012      	b.n	80210b6 <_lv_mem_buf_release+0x66>
        if(LV_GC_ROOT(_lv_mem_buf[i]).p == p) {
 8021090:	7bfb      	ldrb	r3, [r7, #15]
 8021092:	4a0e      	ldr	r2, [pc, #56]	; (80210cc <_lv_mem_buf_release+0x7c>)
 8021094:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8021098:	687a      	ldr	r2, [r7, #4]
 802109a:	429a      	cmp	r2, r3
 802109c:	d108      	bne.n	80210b0 <_lv_mem_buf_release+0x60>
            LV_GC_ROOT(_lv_mem_buf[i]).used = 0;
 802109e:	7bfb      	ldrb	r3, [r7, #15]
 80210a0:	4a0a      	ldr	r2, [pc, #40]	; (80210cc <_lv_mem_buf_release+0x7c>)
 80210a2:	00db      	lsls	r3, r3, #3
 80210a4:	4413      	add	r3, r2
 80210a6:	799a      	ldrb	r2, [r3, #6]
 80210a8:	f36f 0200 	bfc	r2, #0, #1
 80210ac:	719a      	strb	r2, [r3, #6]
            return;
 80210ae:	e005      	b.n	80210bc <_lv_mem_buf_release+0x6c>
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
 80210b0:	7bfb      	ldrb	r3, [r7, #15]
 80210b2:	3301      	adds	r3, #1
 80210b4:	73fb      	strb	r3, [r7, #15]
 80210b6:	7bfb      	ldrb	r3, [r7, #15]
 80210b8:	2b0f      	cmp	r3, #15
 80210ba:	d9e9      	bls.n	8021090 <_lv_mem_buf_release+0x40>
        }
    }

    LV_LOG_ERROR("lv_mem_buf_release: p is not a known buffer")
}
 80210bc:	3714      	adds	r7, #20
 80210be:	46bd      	mov	sp, r7
 80210c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80210c4:	4770      	bx	lr
 80210c6:	bf00      	nop
 80210c8:	200001f0 	.word	0x200001f0
 80210cc:	2000a1dc 	.word	0x2000a1dc

080210d0 <_lv_mem_buf_free_all>:

/**
 * Free all memory buffers
 */
void _lv_mem_buf_free_all(void)
{
 80210d0:	b580      	push	{r7, lr}
 80210d2:	b082      	sub	sp, #8
 80210d4:	af00      	add	r7, sp, #0
    uint8_t i;
    for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
 80210d6:	2300      	movs	r3, #0
 80210d8:	71fb      	strb	r3, [r7, #7]
 80210da:	e00a      	b.n	80210f2 <_lv_mem_buf_free_all+0x22>
        mem_buf_small[i].used = 0;
 80210dc:	79fb      	ldrb	r3, [r7, #7]
 80210de:	4a1d      	ldr	r2, [pc, #116]	; (8021154 <_lv_mem_buf_free_all+0x84>)
 80210e0:	00db      	lsls	r3, r3, #3
 80210e2:	4413      	add	r3, r2
 80210e4:	799a      	ldrb	r2, [r3, #6]
 80210e6:	f36f 0200 	bfc	r2, #0, #1
 80210ea:	719a      	strb	r2, [r3, #6]
    for(i = 0; i < sizeof(mem_buf_small) / sizeof(mem_buf_small[0]); i++) {
 80210ec:	79fb      	ldrb	r3, [r7, #7]
 80210ee:	3301      	adds	r3, #1
 80210f0:	71fb      	strb	r3, [r7, #7]
 80210f2:	79fb      	ldrb	r3, [r7, #7]
 80210f4:	2b01      	cmp	r3, #1
 80210f6:	d9f1      	bls.n	80210dc <_lv_mem_buf_free_all+0xc>
    }

    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
 80210f8:	2300      	movs	r3, #0
 80210fa:	71fb      	strb	r3, [r7, #7]
 80210fc:	e022      	b.n	8021144 <_lv_mem_buf_free_all+0x74>
        if(LV_GC_ROOT(_lv_mem_buf[i]).p) {
 80210fe:	79fb      	ldrb	r3, [r7, #7]
 8021100:	4a15      	ldr	r2, [pc, #84]	; (8021158 <_lv_mem_buf_free_all+0x88>)
 8021102:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8021106:	2b00      	cmp	r3, #0
 8021108:	d019      	beq.n	802113e <_lv_mem_buf_free_all+0x6e>
            lv_mem_free(LV_GC_ROOT(_lv_mem_buf[i]).p);
 802110a:	79fb      	ldrb	r3, [r7, #7]
 802110c:	4a12      	ldr	r2, [pc, #72]	; (8021158 <_lv_mem_buf_free_all+0x88>)
 802110e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8021112:	4618      	mov	r0, r3
 8021114:	f7ff fda8 	bl	8020c68 <lv_mem_free>
            LV_GC_ROOT(_lv_mem_buf[i]).p = NULL;
 8021118:	79fb      	ldrb	r3, [r7, #7]
 802111a:	4a0f      	ldr	r2, [pc, #60]	; (8021158 <_lv_mem_buf_free_all+0x88>)
 802111c:	2100      	movs	r1, #0
 802111e:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
            LV_GC_ROOT(_lv_mem_buf[i]).used = 0;
 8021122:	79fb      	ldrb	r3, [r7, #7]
 8021124:	4a0c      	ldr	r2, [pc, #48]	; (8021158 <_lv_mem_buf_free_all+0x88>)
 8021126:	00db      	lsls	r3, r3, #3
 8021128:	4413      	add	r3, r2
 802112a:	799a      	ldrb	r2, [r3, #6]
 802112c:	f36f 0200 	bfc	r2, #0, #1
 8021130:	719a      	strb	r2, [r3, #6]
            LV_GC_ROOT(_lv_mem_buf[i]).size = 0;
 8021132:	79fb      	ldrb	r3, [r7, #7]
 8021134:	4a08      	ldr	r2, [pc, #32]	; (8021158 <_lv_mem_buf_free_all+0x88>)
 8021136:	00db      	lsls	r3, r3, #3
 8021138:	4413      	add	r3, r2
 802113a:	2200      	movs	r2, #0
 802113c:	809a      	strh	r2, [r3, #4]
    for(i = 0; i < LV_MEM_BUF_MAX_NUM; i++) {
 802113e:	79fb      	ldrb	r3, [r7, #7]
 8021140:	3301      	adds	r3, #1
 8021142:	71fb      	strb	r3, [r7, #7]
 8021144:	79fb      	ldrb	r3, [r7, #7]
 8021146:	2b0f      	cmp	r3, #15
 8021148:	d9d9      	bls.n	80210fe <_lv_mem_buf_free_all+0x2e>
        }
    }
}
 802114a:	bf00      	nop
 802114c:	bf00      	nop
 802114e:	3708      	adds	r7, #8
 8021150:	46bd      	mov	sp, r7
 8021152:	bd80      	pop	{r7, pc}
 8021154:	200001f0 	.word	0x200001f0
 8021158:	2000a1dc 	.word	0x2000a1dc

0802115c <_lv_memcpy>:
 * @param dst pointer to the destination buffer
 * @param src pointer to the source buffer
 * @param len number of byte to copy
 */
LV_ATTRIBUTE_FAST_MEM void * _lv_memcpy(void * dst, const void * src, size_t len)
{
 802115c:	b480      	push	{r7}
 802115e:	b08b      	sub	sp, #44	; 0x2c
 8021160:	af00      	add	r7, sp, #0
 8021162:	60f8      	str	r0, [r7, #12]
 8021164:	60b9      	str	r1, [r7, #8]
 8021166:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = dst;
 8021168:	68fb      	ldr	r3, [r7, #12]
 802116a:	627b      	str	r3, [r7, #36]	; 0x24
    const uint8_t * s8 = src;
 802116c:	68bb      	ldr	r3, [r7, #8]
 802116e:	623b      	str	r3, [r7, #32]

    lv_uintptr_t d_align = (lv_uintptr_t)d8 & ALIGN_MASK;
 8021170:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021172:	f003 0303 	and.w	r3, r3, #3
 8021176:	61fb      	str	r3, [r7, #28]
    lv_uintptr_t s_align = (lv_uintptr_t)s8 & ALIGN_MASK;
 8021178:	6a3b      	ldr	r3, [r7, #32]
 802117a:	f003 0303 	and.w	r3, r3, #3
 802117e:	613b      	str	r3, [r7, #16]

    /*Byte copy for unaligned memories*/
    if(s_align != d_align) {
 8021180:	693a      	ldr	r2, [r7, #16]
 8021182:	69fb      	ldr	r3, [r7, #28]
 8021184:	429a      	cmp	r2, r3
 8021186:	f000 815b 	beq.w	8021440 <_lv_memcpy+0x2e4>
        while(len > 32) {
 802118a:	e142      	b.n	8021412 <_lv_memcpy+0x2b6>
            REPEAT8(COPY8);
 802118c:	6a3b      	ldr	r3, [r7, #32]
 802118e:	781a      	ldrb	r2, [r3, #0]
 8021190:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021192:	701a      	strb	r2, [r3, #0]
 8021194:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021196:	3301      	adds	r3, #1
 8021198:	627b      	str	r3, [r7, #36]	; 0x24
 802119a:	6a3b      	ldr	r3, [r7, #32]
 802119c:	3301      	adds	r3, #1
 802119e:	623b      	str	r3, [r7, #32]
 80211a0:	6a3b      	ldr	r3, [r7, #32]
 80211a2:	781a      	ldrb	r2, [r3, #0]
 80211a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80211a6:	701a      	strb	r2, [r3, #0]
 80211a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80211aa:	3301      	adds	r3, #1
 80211ac:	627b      	str	r3, [r7, #36]	; 0x24
 80211ae:	6a3b      	ldr	r3, [r7, #32]
 80211b0:	3301      	adds	r3, #1
 80211b2:	623b      	str	r3, [r7, #32]
 80211b4:	6a3b      	ldr	r3, [r7, #32]
 80211b6:	781a      	ldrb	r2, [r3, #0]
 80211b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80211ba:	701a      	strb	r2, [r3, #0]
 80211bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80211be:	3301      	adds	r3, #1
 80211c0:	627b      	str	r3, [r7, #36]	; 0x24
 80211c2:	6a3b      	ldr	r3, [r7, #32]
 80211c4:	3301      	adds	r3, #1
 80211c6:	623b      	str	r3, [r7, #32]
 80211c8:	6a3b      	ldr	r3, [r7, #32]
 80211ca:	781a      	ldrb	r2, [r3, #0]
 80211cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80211ce:	701a      	strb	r2, [r3, #0]
 80211d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80211d2:	3301      	adds	r3, #1
 80211d4:	627b      	str	r3, [r7, #36]	; 0x24
 80211d6:	6a3b      	ldr	r3, [r7, #32]
 80211d8:	3301      	adds	r3, #1
 80211da:	623b      	str	r3, [r7, #32]
 80211dc:	6a3b      	ldr	r3, [r7, #32]
 80211de:	781a      	ldrb	r2, [r3, #0]
 80211e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80211e2:	701a      	strb	r2, [r3, #0]
 80211e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80211e6:	3301      	adds	r3, #1
 80211e8:	627b      	str	r3, [r7, #36]	; 0x24
 80211ea:	6a3b      	ldr	r3, [r7, #32]
 80211ec:	3301      	adds	r3, #1
 80211ee:	623b      	str	r3, [r7, #32]
 80211f0:	6a3b      	ldr	r3, [r7, #32]
 80211f2:	781a      	ldrb	r2, [r3, #0]
 80211f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80211f6:	701a      	strb	r2, [r3, #0]
 80211f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80211fa:	3301      	adds	r3, #1
 80211fc:	627b      	str	r3, [r7, #36]	; 0x24
 80211fe:	6a3b      	ldr	r3, [r7, #32]
 8021200:	3301      	adds	r3, #1
 8021202:	623b      	str	r3, [r7, #32]
 8021204:	6a3b      	ldr	r3, [r7, #32]
 8021206:	781a      	ldrb	r2, [r3, #0]
 8021208:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802120a:	701a      	strb	r2, [r3, #0]
 802120c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802120e:	3301      	adds	r3, #1
 8021210:	627b      	str	r3, [r7, #36]	; 0x24
 8021212:	6a3b      	ldr	r3, [r7, #32]
 8021214:	3301      	adds	r3, #1
 8021216:	623b      	str	r3, [r7, #32]
 8021218:	6a3b      	ldr	r3, [r7, #32]
 802121a:	781a      	ldrb	r2, [r3, #0]
 802121c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802121e:	701a      	strb	r2, [r3, #0]
 8021220:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021222:	3301      	adds	r3, #1
 8021224:	627b      	str	r3, [r7, #36]	; 0x24
 8021226:	6a3b      	ldr	r3, [r7, #32]
 8021228:	3301      	adds	r3, #1
 802122a:	623b      	str	r3, [r7, #32]
            REPEAT8(COPY8);
 802122c:	6a3b      	ldr	r3, [r7, #32]
 802122e:	781a      	ldrb	r2, [r3, #0]
 8021230:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021232:	701a      	strb	r2, [r3, #0]
 8021234:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021236:	3301      	adds	r3, #1
 8021238:	627b      	str	r3, [r7, #36]	; 0x24
 802123a:	6a3b      	ldr	r3, [r7, #32]
 802123c:	3301      	adds	r3, #1
 802123e:	623b      	str	r3, [r7, #32]
 8021240:	6a3b      	ldr	r3, [r7, #32]
 8021242:	781a      	ldrb	r2, [r3, #0]
 8021244:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021246:	701a      	strb	r2, [r3, #0]
 8021248:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802124a:	3301      	adds	r3, #1
 802124c:	627b      	str	r3, [r7, #36]	; 0x24
 802124e:	6a3b      	ldr	r3, [r7, #32]
 8021250:	3301      	adds	r3, #1
 8021252:	623b      	str	r3, [r7, #32]
 8021254:	6a3b      	ldr	r3, [r7, #32]
 8021256:	781a      	ldrb	r2, [r3, #0]
 8021258:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802125a:	701a      	strb	r2, [r3, #0]
 802125c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802125e:	3301      	adds	r3, #1
 8021260:	627b      	str	r3, [r7, #36]	; 0x24
 8021262:	6a3b      	ldr	r3, [r7, #32]
 8021264:	3301      	adds	r3, #1
 8021266:	623b      	str	r3, [r7, #32]
 8021268:	6a3b      	ldr	r3, [r7, #32]
 802126a:	781a      	ldrb	r2, [r3, #0]
 802126c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802126e:	701a      	strb	r2, [r3, #0]
 8021270:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021272:	3301      	adds	r3, #1
 8021274:	627b      	str	r3, [r7, #36]	; 0x24
 8021276:	6a3b      	ldr	r3, [r7, #32]
 8021278:	3301      	adds	r3, #1
 802127a:	623b      	str	r3, [r7, #32]
 802127c:	6a3b      	ldr	r3, [r7, #32]
 802127e:	781a      	ldrb	r2, [r3, #0]
 8021280:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021282:	701a      	strb	r2, [r3, #0]
 8021284:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021286:	3301      	adds	r3, #1
 8021288:	627b      	str	r3, [r7, #36]	; 0x24
 802128a:	6a3b      	ldr	r3, [r7, #32]
 802128c:	3301      	adds	r3, #1
 802128e:	623b      	str	r3, [r7, #32]
 8021290:	6a3b      	ldr	r3, [r7, #32]
 8021292:	781a      	ldrb	r2, [r3, #0]
 8021294:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021296:	701a      	strb	r2, [r3, #0]
 8021298:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802129a:	3301      	adds	r3, #1
 802129c:	627b      	str	r3, [r7, #36]	; 0x24
 802129e:	6a3b      	ldr	r3, [r7, #32]
 80212a0:	3301      	adds	r3, #1
 80212a2:	623b      	str	r3, [r7, #32]
 80212a4:	6a3b      	ldr	r3, [r7, #32]
 80212a6:	781a      	ldrb	r2, [r3, #0]
 80212a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80212aa:	701a      	strb	r2, [r3, #0]
 80212ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80212ae:	3301      	adds	r3, #1
 80212b0:	627b      	str	r3, [r7, #36]	; 0x24
 80212b2:	6a3b      	ldr	r3, [r7, #32]
 80212b4:	3301      	adds	r3, #1
 80212b6:	623b      	str	r3, [r7, #32]
 80212b8:	6a3b      	ldr	r3, [r7, #32]
 80212ba:	781a      	ldrb	r2, [r3, #0]
 80212bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80212be:	701a      	strb	r2, [r3, #0]
 80212c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80212c2:	3301      	adds	r3, #1
 80212c4:	627b      	str	r3, [r7, #36]	; 0x24
 80212c6:	6a3b      	ldr	r3, [r7, #32]
 80212c8:	3301      	adds	r3, #1
 80212ca:	623b      	str	r3, [r7, #32]
            REPEAT8(COPY8);
 80212cc:	6a3b      	ldr	r3, [r7, #32]
 80212ce:	781a      	ldrb	r2, [r3, #0]
 80212d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80212d2:	701a      	strb	r2, [r3, #0]
 80212d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80212d6:	3301      	adds	r3, #1
 80212d8:	627b      	str	r3, [r7, #36]	; 0x24
 80212da:	6a3b      	ldr	r3, [r7, #32]
 80212dc:	3301      	adds	r3, #1
 80212de:	623b      	str	r3, [r7, #32]
 80212e0:	6a3b      	ldr	r3, [r7, #32]
 80212e2:	781a      	ldrb	r2, [r3, #0]
 80212e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80212e6:	701a      	strb	r2, [r3, #0]
 80212e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80212ea:	3301      	adds	r3, #1
 80212ec:	627b      	str	r3, [r7, #36]	; 0x24
 80212ee:	6a3b      	ldr	r3, [r7, #32]
 80212f0:	3301      	adds	r3, #1
 80212f2:	623b      	str	r3, [r7, #32]
 80212f4:	6a3b      	ldr	r3, [r7, #32]
 80212f6:	781a      	ldrb	r2, [r3, #0]
 80212f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80212fa:	701a      	strb	r2, [r3, #0]
 80212fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80212fe:	3301      	adds	r3, #1
 8021300:	627b      	str	r3, [r7, #36]	; 0x24
 8021302:	6a3b      	ldr	r3, [r7, #32]
 8021304:	3301      	adds	r3, #1
 8021306:	623b      	str	r3, [r7, #32]
 8021308:	6a3b      	ldr	r3, [r7, #32]
 802130a:	781a      	ldrb	r2, [r3, #0]
 802130c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802130e:	701a      	strb	r2, [r3, #0]
 8021310:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021312:	3301      	adds	r3, #1
 8021314:	627b      	str	r3, [r7, #36]	; 0x24
 8021316:	6a3b      	ldr	r3, [r7, #32]
 8021318:	3301      	adds	r3, #1
 802131a:	623b      	str	r3, [r7, #32]
 802131c:	6a3b      	ldr	r3, [r7, #32]
 802131e:	781a      	ldrb	r2, [r3, #0]
 8021320:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021322:	701a      	strb	r2, [r3, #0]
 8021324:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021326:	3301      	adds	r3, #1
 8021328:	627b      	str	r3, [r7, #36]	; 0x24
 802132a:	6a3b      	ldr	r3, [r7, #32]
 802132c:	3301      	adds	r3, #1
 802132e:	623b      	str	r3, [r7, #32]
 8021330:	6a3b      	ldr	r3, [r7, #32]
 8021332:	781a      	ldrb	r2, [r3, #0]
 8021334:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021336:	701a      	strb	r2, [r3, #0]
 8021338:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802133a:	3301      	adds	r3, #1
 802133c:	627b      	str	r3, [r7, #36]	; 0x24
 802133e:	6a3b      	ldr	r3, [r7, #32]
 8021340:	3301      	adds	r3, #1
 8021342:	623b      	str	r3, [r7, #32]
 8021344:	6a3b      	ldr	r3, [r7, #32]
 8021346:	781a      	ldrb	r2, [r3, #0]
 8021348:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802134a:	701a      	strb	r2, [r3, #0]
 802134c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802134e:	3301      	adds	r3, #1
 8021350:	627b      	str	r3, [r7, #36]	; 0x24
 8021352:	6a3b      	ldr	r3, [r7, #32]
 8021354:	3301      	adds	r3, #1
 8021356:	623b      	str	r3, [r7, #32]
 8021358:	6a3b      	ldr	r3, [r7, #32]
 802135a:	781a      	ldrb	r2, [r3, #0]
 802135c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802135e:	701a      	strb	r2, [r3, #0]
 8021360:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021362:	3301      	adds	r3, #1
 8021364:	627b      	str	r3, [r7, #36]	; 0x24
 8021366:	6a3b      	ldr	r3, [r7, #32]
 8021368:	3301      	adds	r3, #1
 802136a:	623b      	str	r3, [r7, #32]
            REPEAT8(COPY8);
 802136c:	6a3b      	ldr	r3, [r7, #32]
 802136e:	781a      	ldrb	r2, [r3, #0]
 8021370:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021372:	701a      	strb	r2, [r3, #0]
 8021374:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021376:	3301      	adds	r3, #1
 8021378:	627b      	str	r3, [r7, #36]	; 0x24
 802137a:	6a3b      	ldr	r3, [r7, #32]
 802137c:	3301      	adds	r3, #1
 802137e:	623b      	str	r3, [r7, #32]
 8021380:	6a3b      	ldr	r3, [r7, #32]
 8021382:	781a      	ldrb	r2, [r3, #0]
 8021384:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021386:	701a      	strb	r2, [r3, #0]
 8021388:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802138a:	3301      	adds	r3, #1
 802138c:	627b      	str	r3, [r7, #36]	; 0x24
 802138e:	6a3b      	ldr	r3, [r7, #32]
 8021390:	3301      	adds	r3, #1
 8021392:	623b      	str	r3, [r7, #32]
 8021394:	6a3b      	ldr	r3, [r7, #32]
 8021396:	781a      	ldrb	r2, [r3, #0]
 8021398:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802139a:	701a      	strb	r2, [r3, #0]
 802139c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802139e:	3301      	adds	r3, #1
 80213a0:	627b      	str	r3, [r7, #36]	; 0x24
 80213a2:	6a3b      	ldr	r3, [r7, #32]
 80213a4:	3301      	adds	r3, #1
 80213a6:	623b      	str	r3, [r7, #32]
 80213a8:	6a3b      	ldr	r3, [r7, #32]
 80213aa:	781a      	ldrb	r2, [r3, #0]
 80213ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80213ae:	701a      	strb	r2, [r3, #0]
 80213b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80213b2:	3301      	adds	r3, #1
 80213b4:	627b      	str	r3, [r7, #36]	; 0x24
 80213b6:	6a3b      	ldr	r3, [r7, #32]
 80213b8:	3301      	adds	r3, #1
 80213ba:	623b      	str	r3, [r7, #32]
 80213bc:	6a3b      	ldr	r3, [r7, #32]
 80213be:	781a      	ldrb	r2, [r3, #0]
 80213c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80213c2:	701a      	strb	r2, [r3, #0]
 80213c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80213c6:	3301      	adds	r3, #1
 80213c8:	627b      	str	r3, [r7, #36]	; 0x24
 80213ca:	6a3b      	ldr	r3, [r7, #32]
 80213cc:	3301      	adds	r3, #1
 80213ce:	623b      	str	r3, [r7, #32]
 80213d0:	6a3b      	ldr	r3, [r7, #32]
 80213d2:	781a      	ldrb	r2, [r3, #0]
 80213d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80213d6:	701a      	strb	r2, [r3, #0]
 80213d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80213da:	3301      	adds	r3, #1
 80213dc:	627b      	str	r3, [r7, #36]	; 0x24
 80213de:	6a3b      	ldr	r3, [r7, #32]
 80213e0:	3301      	adds	r3, #1
 80213e2:	623b      	str	r3, [r7, #32]
 80213e4:	6a3b      	ldr	r3, [r7, #32]
 80213e6:	781a      	ldrb	r2, [r3, #0]
 80213e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80213ea:	701a      	strb	r2, [r3, #0]
 80213ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80213ee:	3301      	adds	r3, #1
 80213f0:	627b      	str	r3, [r7, #36]	; 0x24
 80213f2:	6a3b      	ldr	r3, [r7, #32]
 80213f4:	3301      	adds	r3, #1
 80213f6:	623b      	str	r3, [r7, #32]
 80213f8:	6a3b      	ldr	r3, [r7, #32]
 80213fa:	781a      	ldrb	r2, [r3, #0]
 80213fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80213fe:	701a      	strb	r2, [r3, #0]
 8021400:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021402:	3301      	adds	r3, #1
 8021404:	627b      	str	r3, [r7, #36]	; 0x24
 8021406:	6a3b      	ldr	r3, [r7, #32]
 8021408:	3301      	adds	r3, #1
 802140a:	623b      	str	r3, [r7, #32]
            len -= 32;
 802140c:	687b      	ldr	r3, [r7, #4]
 802140e:	3b20      	subs	r3, #32
 8021410:	607b      	str	r3, [r7, #4]
        while(len > 32) {
 8021412:	687b      	ldr	r3, [r7, #4]
 8021414:	2b20      	cmp	r3, #32
 8021416:	f63f aeb9 	bhi.w	802118c <_lv_memcpy+0x30>
        }
        while(len) {
 802141a:	e00c      	b.n	8021436 <_lv_memcpy+0x2da>
            COPY8
 802141c:	6a3b      	ldr	r3, [r7, #32]
 802141e:	781a      	ldrb	r2, [r3, #0]
 8021420:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021422:	701a      	strb	r2, [r3, #0]
 8021424:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021426:	3301      	adds	r3, #1
 8021428:	627b      	str	r3, [r7, #36]	; 0x24
 802142a:	6a3b      	ldr	r3, [r7, #32]
 802142c:	3301      	adds	r3, #1
 802142e:	623b      	str	r3, [r7, #32]
            len--;
 8021430:	687b      	ldr	r3, [r7, #4]
 8021432:	3b01      	subs	r3, #1
 8021434:	607b      	str	r3, [r7, #4]
        while(len) {
 8021436:	687b      	ldr	r3, [r7, #4]
 8021438:	2b00      	cmp	r3, #0
 802143a:	d1ef      	bne.n	802141c <_lv_memcpy+0x2c0>
        }
        return dst;
 802143c:	68fb      	ldr	r3, [r7, #12]
 802143e:	e09f      	b.n	8021580 <_lv_memcpy+0x424>
    }


    /*Make the memories aligned*/
    if(d_align) {
 8021440:	69fb      	ldr	r3, [r7, #28]
 8021442:	2b00      	cmp	r3, #0
 8021444:	d01a      	beq.n	802147c <_lv_memcpy+0x320>
        d_align = ALIGN_MASK + 1 - d_align;
 8021446:	69fb      	ldr	r3, [r7, #28]
 8021448:	f1c3 0304 	rsb	r3, r3, #4
 802144c:	61fb      	str	r3, [r7, #28]
        while(d_align && len) {
 802144e:	e00f      	b.n	8021470 <_lv_memcpy+0x314>
            COPY8;
 8021450:	6a3b      	ldr	r3, [r7, #32]
 8021452:	781a      	ldrb	r2, [r3, #0]
 8021454:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021456:	701a      	strb	r2, [r3, #0]
 8021458:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802145a:	3301      	adds	r3, #1
 802145c:	627b      	str	r3, [r7, #36]	; 0x24
 802145e:	6a3b      	ldr	r3, [r7, #32]
 8021460:	3301      	adds	r3, #1
 8021462:	623b      	str	r3, [r7, #32]
            d_align--;
 8021464:	69fb      	ldr	r3, [r7, #28]
 8021466:	3b01      	subs	r3, #1
 8021468:	61fb      	str	r3, [r7, #28]
            len--;
 802146a:	687b      	ldr	r3, [r7, #4]
 802146c:	3b01      	subs	r3, #1
 802146e:	607b      	str	r3, [r7, #4]
        while(d_align && len) {
 8021470:	69fb      	ldr	r3, [r7, #28]
 8021472:	2b00      	cmp	r3, #0
 8021474:	d002      	beq.n	802147c <_lv_memcpy+0x320>
 8021476:	687b      	ldr	r3, [r7, #4]
 8021478:	2b00      	cmp	r3, #0
 802147a:	d1e9      	bne.n	8021450 <_lv_memcpy+0x2f4>
        }
    }

    uint32_t * d32 = (uint32_t *)d8;
 802147c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802147e:	61bb      	str	r3, [r7, #24]
    const uint32_t * s32 = (uint32_t *)s8;
 8021480:	6a3b      	ldr	r3, [r7, #32]
 8021482:	617b      	str	r3, [r7, #20]
    while(len > 32) {
 8021484:	e052      	b.n	802152c <_lv_memcpy+0x3d0>
        REPEAT8(COPY32)
 8021486:	697b      	ldr	r3, [r7, #20]
 8021488:	681a      	ldr	r2, [r3, #0]
 802148a:	69bb      	ldr	r3, [r7, #24]
 802148c:	601a      	str	r2, [r3, #0]
 802148e:	69bb      	ldr	r3, [r7, #24]
 8021490:	3304      	adds	r3, #4
 8021492:	61bb      	str	r3, [r7, #24]
 8021494:	697b      	ldr	r3, [r7, #20]
 8021496:	3304      	adds	r3, #4
 8021498:	617b      	str	r3, [r7, #20]
 802149a:	697b      	ldr	r3, [r7, #20]
 802149c:	681a      	ldr	r2, [r3, #0]
 802149e:	69bb      	ldr	r3, [r7, #24]
 80214a0:	601a      	str	r2, [r3, #0]
 80214a2:	69bb      	ldr	r3, [r7, #24]
 80214a4:	3304      	adds	r3, #4
 80214a6:	61bb      	str	r3, [r7, #24]
 80214a8:	697b      	ldr	r3, [r7, #20]
 80214aa:	3304      	adds	r3, #4
 80214ac:	617b      	str	r3, [r7, #20]
 80214ae:	697b      	ldr	r3, [r7, #20]
 80214b0:	681a      	ldr	r2, [r3, #0]
 80214b2:	69bb      	ldr	r3, [r7, #24]
 80214b4:	601a      	str	r2, [r3, #0]
 80214b6:	69bb      	ldr	r3, [r7, #24]
 80214b8:	3304      	adds	r3, #4
 80214ba:	61bb      	str	r3, [r7, #24]
 80214bc:	697b      	ldr	r3, [r7, #20]
 80214be:	3304      	adds	r3, #4
 80214c0:	617b      	str	r3, [r7, #20]
 80214c2:	697b      	ldr	r3, [r7, #20]
 80214c4:	681a      	ldr	r2, [r3, #0]
 80214c6:	69bb      	ldr	r3, [r7, #24]
 80214c8:	601a      	str	r2, [r3, #0]
 80214ca:	69bb      	ldr	r3, [r7, #24]
 80214cc:	3304      	adds	r3, #4
 80214ce:	61bb      	str	r3, [r7, #24]
 80214d0:	697b      	ldr	r3, [r7, #20]
 80214d2:	3304      	adds	r3, #4
 80214d4:	617b      	str	r3, [r7, #20]
 80214d6:	697b      	ldr	r3, [r7, #20]
 80214d8:	681a      	ldr	r2, [r3, #0]
 80214da:	69bb      	ldr	r3, [r7, #24]
 80214dc:	601a      	str	r2, [r3, #0]
 80214de:	69bb      	ldr	r3, [r7, #24]
 80214e0:	3304      	adds	r3, #4
 80214e2:	61bb      	str	r3, [r7, #24]
 80214e4:	697b      	ldr	r3, [r7, #20]
 80214e6:	3304      	adds	r3, #4
 80214e8:	617b      	str	r3, [r7, #20]
 80214ea:	697b      	ldr	r3, [r7, #20]
 80214ec:	681a      	ldr	r2, [r3, #0]
 80214ee:	69bb      	ldr	r3, [r7, #24]
 80214f0:	601a      	str	r2, [r3, #0]
 80214f2:	69bb      	ldr	r3, [r7, #24]
 80214f4:	3304      	adds	r3, #4
 80214f6:	61bb      	str	r3, [r7, #24]
 80214f8:	697b      	ldr	r3, [r7, #20]
 80214fa:	3304      	adds	r3, #4
 80214fc:	617b      	str	r3, [r7, #20]
 80214fe:	697b      	ldr	r3, [r7, #20]
 8021500:	681a      	ldr	r2, [r3, #0]
 8021502:	69bb      	ldr	r3, [r7, #24]
 8021504:	601a      	str	r2, [r3, #0]
 8021506:	69bb      	ldr	r3, [r7, #24]
 8021508:	3304      	adds	r3, #4
 802150a:	61bb      	str	r3, [r7, #24]
 802150c:	697b      	ldr	r3, [r7, #20]
 802150e:	3304      	adds	r3, #4
 8021510:	617b      	str	r3, [r7, #20]
 8021512:	697b      	ldr	r3, [r7, #20]
 8021514:	681a      	ldr	r2, [r3, #0]
 8021516:	69bb      	ldr	r3, [r7, #24]
 8021518:	601a      	str	r2, [r3, #0]
 802151a:	69bb      	ldr	r3, [r7, #24]
 802151c:	3304      	adds	r3, #4
 802151e:	61bb      	str	r3, [r7, #24]
 8021520:	697b      	ldr	r3, [r7, #20]
 8021522:	3304      	adds	r3, #4
 8021524:	617b      	str	r3, [r7, #20]
        len -= 32;
 8021526:	687b      	ldr	r3, [r7, #4]
 8021528:	3b20      	subs	r3, #32
 802152a:	607b      	str	r3, [r7, #4]
    while(len > 32) {
 802152c:	687b      	ldr	r3, [r7, #4]
 802152e:	2b20      	cmp	r3, #32
 8021530:	d8a9      	bhi.n	8021486 <_lv_memcpy+0x32a>
    }

    while(len > 4) {
 8021532:	e00c      	b.n	802154e <_lv_memcpy+0x3f2>
        COPY32;
 8021534:	697b      	ldr	r3, [r7, #20]
 8021536:	681a      	ldr	r2, [r3, #0]
 8021538:	69bb      	ldr	r3, [r7, #24]
 802153a:	601a      	str	r2, [r3, #0]
 802153c:	69bb      	ldr	r3, [r7, #24]
 802153e:	3304      	adds	r3, #4
 8021540:	61bb      	str	r3, [r7, #24]
 8021542:	697b      	ldr	r3, [r7, #20]
 8021544:	3304      	adds	r3, #4
 8021546:	617b      	str	r3, [r7, #20]
        len -= 4;
 8021548:	687b      	ldr	r3, [r7, #4]
 802154a:	3b04      	subs	r3, #4
 802154c:	607b      	str	r3, [r7, #4]
    while(len > 4) {
 802154e:	687b      	ldr	r3, [r7, #4]
 8021550:	2b04      	cmp	r3, #4
 8021552:	d8ef      	bhi.n	8021534 <_lv_memcpy+0x3d8>
    }

    d8 = (uint8_t *)d32;
 8021554:	69bb      	ldr	r3, [r7, #24]
 8021556:	627b      	str	r3, [r7, #36]	; 0x24
    s8 = (const uint8_t *)s32;
 8021558:	697b      	ldr	r3, [r7, #20]
 802155a:	623b      	str	r3, [r7, #32]
    while(len) {
 802155c:	e00c      	b.n	8021578 <_lv_memcpy+0x41c>
        COPY8
 802155e:	6a3b      	ldr	r3, [r7, #32]
 8021560:	781a      	ldrb	r2, [r3, #0]
 8021562:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021564:	701a      	strb	r2, [r3, #0]
 8021566:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021568:	3301      	adds	r3, #1
 802156a:	627b      	str	r3, [r7, #36]	; 0x24
 802156c:	6a3b      	ldr	r3, [r7, #32]
 802156e:	3301      	adds	r3, #1
 8021570:	623b      	str	r3, [r7, #32]
        len--;
 8021572:	687b      	ldr	r3, [r7, #4]
 8021574:	3b01      	subs	r3, #1
 8021576:	607b      	str	r3, [r7, #4]
    while(len) {
 8021578:	687b      	ldr	r3, [r7, #4]
 802157a:	2b00      	cmp	r3, #0
 802157c:	d1ef      	bne.n	802155e <_lv_memcpy+0x402>
    }

    return dst;
 802157e:	68fb      	ldr	r3, [r7, #12]
}
 8021580:	4618      	mov	r0, r3
 8021582:	372c      	adds	r7, #44	; 0x2c
 8021584:	46bd      	mov	sp, r7
 8021586:	f85d 7b04 	ldr.w	r7, [sp], #4
 802158a:	4770      	bx	lr

0802158c <_lv_memset>:
 * @param dst pointer to the destination buffer
 * @param v value to set [0..255]
 * @param len number of byte to set
 */
LV_ATTRIBUTE_FAST_MEM void _lv_memset(void * dst, uint8_t v, size_t len)
{
 802158c:	b480      	push	{r7}
 802158e:	b089      	sub	sp, #36	; 0x24
 8021590:	af00      	add	r7, sp, #0
 8021592:	60f8      	str	r0, [r7, #12]
 8021594:	460b      	mov	r3, r1
 8021596:	607a      	str	r2, [r7, #4]
 8021598:	72fb      	strb	r3, [r7, #11]

    uint8_t * d8 = (uint8_t *) dst;
 802159a:	68fb      	ldr	r3, [r7, #12]
 802159c:	61fb      	str	r3, [r7, #28]

    uintptr_t d_align = (lv_uintptr_t) d8 & ALIGN_MASK;
 802159e:	69fb      	ldr	r3, [r7, #28]
 80215a0:	f003 0303 	and.w	r3, r3, #3
 80215a4:	61bb      	str	r3, [r7, #24]

    /*Make the address aligned*/
    if(d_align) {
 80215a6:	69bb      	ldr	r3, [r7, #24]
 80215a8:	2b00      	cmp	r3, #0
 80215aa:	d016      	beq.n	80215da <_lv_memset+0x4e>
        d_align = ALIGN_MASK + 1 - d_align;
 80215ac:	69bb      	ldr	r3, [r7, #24]
 80215ae:	f1c3 0304 	rsb	r3, r3, #4
 80215b2:	61bb      	str	r3, [r7, #24]
        while(d_align && len) {
 80215b4:	e00b      	b.n	80215ce <_lv_memset+0x42>
            *d8 = v;
 80215b6:	69fb      	ldr	r3, [r7, #28]
 80215b8:	7afa      	ldrb	r2, [r7, #11]
 80215ba:	701a      	strb	r2, [r3, #0]
            d8++;
 80215bc:	69fb      	ldr	r3, [r7, #28]
 80215be:	3301      	adds	r3, #1
 80215c0:	61fb      	str	r3, [r7, #28]
            len--;
 80215c2:	687b      	ldr	r3, [r7, #4]
 80215c4:	3b01      	subs	r3, #1
 80215c6:	607b      	str	r3, [r7, #4]
            d_align--;
 80215c8:	69bb      	ldr	r3, [r7, #24]
 80215ca:	3b01      	subs	r3, #1
 80215cc:	61bb      	str	r3, [r7, #24]
        while(d_align && len) {
 80215ce:	69bb      	ldr	r3, [r7, #24]
 80215d0:	2b00      	cmp	r3, #0
 80215d2:	d002      	beq.n	80215da <_lv_memset+0x4e>
 80215d4:	687b      	ldr	r3, [r7, #4]
 80215d6:	2b00      	cmp	r3, #0
 80215d8:	d1ed      	bne.n	80215b6 <_lv_memset+0x2a>
        }
    }

    uint32_t v32 = v + (v << 8) + (v << 16) + (v << 24);
 80215da:	7afa      	ldrb	r2, [r7, #11]
 80215dc:	7afb      	ldrb	r3, [r7, #11]
 80215de:	021b      	lsls	r3, r3, #8
 80215e0:	441a      	add	r2, r3
 80215e2:	7afb      	ldrb	r3, [r7, #11]
 80215e4:	041b      	lsls	r3, r3, #16
 80215e6:	441a      	add	r2, r3
 80215e8:	7afb      	ldrb	r3, [r7, #11]
 80215ea:	061b      	lsls	r3, r3, #24
 80215ec:	4413      	add	r3, r2
 80215ee:	613b      	str	r3, [r7, #16]

    uint32_t * d32 = (uint32_t *)d8;
 80215f0:	69fb      	ldr	r3, [r7, #28]
 80215f2:	617b      	str	r3, [r7, #20]

    while(len > 32) {
 80215f4:	e032      	b.n	802165c <_lv_memset+0xd0>
        SET32(v32);
 80215f6:	697b      	ldr	r3, [r7, #20]
 80215f8:	693a      	ldr	r2, [r7, #16]
 80215fa:	601a      	str	r2, [r3, #0]
 80215fc:	697b      	ldr	r3, [r7, #20]
 80215fe:	3304      	adds	r3, #4
 8021600:	617b      	str	r3, [r7, #20]
        SET32(v32);
 8021602:	697b      	ldr	r3, [r7, #20]
 8021604:	693a      	ldr	r2, [r7, #16]
 8021606:	601a      	str	r2, [r3, #0]
 8021608:	697b      	ldr	r3, [r7, #20]
 802160a:	3304      	adds	r3, #4
 802160c:	617b      	str	r3, [r7, #20]
        SET32(v32);
 802160e:	697b      	ldr	r3, [r7, #20]
 8021610:	693a      	ldr	r2, [r7, #16]
 8021612:	601a      	str	r2, [r3, #0]
 8021614:	697b      	ldr	r3, [r7, #20]
 8021616:	3304      	adds	r3, #4
 8021618:	617b      	str	r3, [r7, #20]
        SET32(v32);
 802161a:	697b      	ldr	r3, [r7, #20]
 802161c:	693a      	ldr	r2, [r7, #16]
 802161e:	601a      	str	r2, [r3, #0]
 8021620:	697b      	ldr	r3, [r7, #20]
 8021622:	3304      	adds	r3, #4
 8021624:	617b      	str	r3, [r7, #20]
        SET32(v32);
 8021626:	697b      	ldr	r3, [r7, #20]
 8021628:	693a      	ldr	r2, [r7, #16]
 802162a:	601a      	str	r2, [r3, #0]
 802162c:	697b      	ldr	r3, [r7, #20]
 802162e:	3304      	adds	r3, #4
 8021630:	617b      	str	r3, [r7, #20]
        SET32(v32);
 8021632:	697b      	ldr	r3, [r7, #20]
 8021634:	693a      	ldr	r2, [r7, #16]
 8021636:	601a      	str	r2, [r3, #0]
 8021638:	697b      	ldr	r3, [r7, #20]
 802163a:	3304      	adds	r3, #4
 802163c:	617b      	str	r3, [r7, #20]
        SET32(v32);
 802163e:	697b      	ldr	r3, [r7, #20]
 8021640:	693a      	ldr	r2, [r7, #16]
 8021642:	601a      	str	r2, [r3, #0]
 8021644:	697b      	ldr	r3, [r7, #20]
 8021646:	3304      	adds	r3, #4
 8021648:	617b      	str	r3, [r7, #20]
        SET32(v32);
 802164a:	697b      	ldr	r3, [r7, #20]
 802164c:	693a      	ldr	r2, [r7, #16]
 802164e:	601a      	str	r2, [r3, #0]
 8021650:	697b      	ldr	r3, [r7, #20]
 8021652:	3304      	adds	r3, #4
 8021654:	617b      	str	r3, [r7, #20]
        len -= 32;
 8021656:	687b      	ldr	r3, [r7, #4]
 8021658:	3b20      	subs	r3, #32
 802165a:	607b      	str	r3, [r7, #4]
    while(len > 32) {
 802165c:	687b      	ldr	r3, [r7, #4]
 802165e:	2b20      	cmp	r3, #32
 8021660:	d8c9      	bhi.n	80215f6 <_lv_memset+0x6a>
    }

    while(len > 4) {
 8021662:	e008      	b.n	8021676 <_lv_memset+0xea>
        SET32(v32);
 8021664:	697b      	ldr	r3, [r7, #20]
 8021666:	693a      	ldr	r2, [r7, #16]
 8021668:	601a      	str	r2, [r3, #0]
 802166a:	697b      	ldr	r3, [r7, #20]
 802166c:	3304      	adds	r3, #4
 802166e:	617b      	str	r3, [r7, #20]
        len -= 4;
 8021670:	687b      	ldr	r3, [r7, #4]
 8021672:	3b04      	subs	r3, #4
 8021674:	607b      	str	r3, [r7, #4]
    while(len > 4) {
 8021676:	687b      	ldr	r3, [r7, #4]
 8021678:	2b04      	cmp	r3, #4
 802167a:	d8f3      	bhi.n	8021664 <_lv_memset+0xd8>
    }


    d8 = (uint8_t *)d32;
 802167c:	697b      	ldr	r3, [r7, #20]
 802167e:	61fb      	str	r3, [r7, #28]
    while(len) {
 8021680:	e008      	b.n	8021694 <_lv_memset+0x108>
        *d8 = v;
 8021682:	69fb      	ldr	r3, [r7, #28]
 8021684:	7afa      	ldrb	r2, [r7, #11]
 8021686:	701a      	strb	r2, [r3, #0]
        d8++;
 8021688:	69fb      	ldr	r3, [r7, #28]
 802168a:	3301      	adds	r3, #1
 802168c:	61fb      	str	r3, [r7, #28]
        len--;
 802168e:	687b      	ldr	r3, [r7, #4]
 8021690:	3b01      	subs	r3, #1
 8021692:	607b      	str	r3, [r7, #4]
    while(len) {
 8021694:	687b      	ldr	r3, [r7, #4]
 8021696:	2b00      	cmp	r3, #0
 8021698:	d1f3      	bne.n	8021682 <_lv_memset+0xf6>
    }
}
 802169a:	bf00      	nop
 802169c:	bf00      	nop
 802169e:	3724      	adds	r7, #36	; 0x24
 80216a0:	46bd      	mov	sp, r7
 80216a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80216a6:	4770      	bx	lr

080216a8 <_lv_memset_00>:
 * Same as `memset(dst, 0x00, len)` but optimized for 4 byte operation.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
LV_ATTRIBUTE_FAST_MEM void _lv_memset_00(void * dst, size_t len)
{
 80216a8:	b480      	push	{r7}
 80216aa:	b087      	sub	sp, #28
 80216ac:	af00      	add	r7, sp, #0
 80216ae:	6078      	str	r0, [r7, #4]
 80216b0:	6039      	str	r1, [r7, #0]
    uint8_t * d8 = (uint8_t *) dst;
 80216b2:	687b      	ldr	r3, [r7, #4]
 80216b4:	617b      	str	r3, [r7, #20]
    uintptr_t d_align = (lv_uintptr_t) d8 & ALIGN_MASK;
 80216b6:	697b      	ldr	r3, [r7, #20]
 80216b8:	f003 0303 	and.w	r3, r3, #3
 80216bc:	613b      	str	r3, [r7, #16]


    /*Make the address aligned*/
    if(d_align) {
 80216be:	693b      	ldr	r3, [r7, #16]
 80216c0:	2b00      	cmp	r3, #0
 80216c2:	d016      	beq.n	80216f2 <_lv_memset_00+0x4a>
        d_align = ALIGN_MASK + 1 - d_align;
 80216c4:	693b      	ldr	r3, [r7, #16]
 80216c6:	f1c3 0304 	rsb	r3, r3, #4
 80216ca:	613b      	str	r3, [r7, #16]
        while(d_align && len) {
 80216cc:	e00b      	b.n	80216e6 <_lv_memset_00+0x3e>
            *d8 = 0x00;
 80216ce:	697b      	ldr	r3, [r7, #20]
 80216d0:	2200      	movs	r2, #0
 80216d2:	701a      	strb	r2, [r3, #0]
            d8++;
 80216d4:	697b      	ldr	r3, [r7, #20]
 80216d6:	3301      	adds	r3, #1
 80216d8:	617b      	str	r3, [r7, #20]
            len--;
 80216da:	683b      	ldr	r3, [r7, #0]
 80216dc:	3b01      	subs	r3, #1
 80216de:	603b      	str	r3, [r7, #0]
            d_align--;
 80216e0:	693b      	ldr	r3, [r7, #16]
 80216e2:	3b01      	subs	r3, #1
 80216e4:	613b      	str	r3, [r7, #16]
        while(d_align && len) {
 80216e6:	693b      	ldr	r3, [r7, #16]
 80216e8:	2b00      	cmp	r3, #0
 80216ea:	d002      	beq.n	80216f2 <_lv_memset_00+0x4a>
 80216ec:	683b      	ldr	r3, [r7, #0]
 80216ee:	2b00      	cmp	r3, #0
 80216f0:	d1ed      	bne.n	80216ce <_lv_memset_00+0x26>
        }
    }

    uint32_t * d32 = (uint32_t *)d8;
 80216f2:	697b      	ldr	r3, [r7, #20]
 80216f4:	60fb      	str	r3, [r7, #12]
    while(len > 32) {
 80216f6:	e032      	b.n	802175e <_lv_memset_00+0xb6>
        SET32(0);
 80216f8:	68fb      	ldr	r3, [r7, #12]
 80216fa:	2200      	movs	r2, #0
 80216fc:	601a      	str	r2, [r3, #0]
 80216fe:	68fb      	ldr	r3, [r7, #12]
 8021700:	3304      	adds	r3, #4
 8021702:	60fb      	str	r3, [r7, #12]
        SET32(0);
 8021704:	68fb      	ldr	r3, [r7, #12]
 8021706:	2200      	movs	r2, #0
 8021708:	601a      	str	r2, [r3, #0]
 802170a:	68fb      	ldr	r3, [r7, #12]
 802170c:	3304      	adds	r3, #4
 802170e:	60fb      	str	r3, [r7, #12]
        SET32(0);
 8021710:	68fb      	ldr	r3, [r7, #12]
 8021712:	2200      	movs	r2, #0
 8021714:	601a      	str	r2, [r3, #0]
 8021716:	68fb      	ldr	r3, [r7, #12]
 8021718:	3304      	adds	r3, #4
 802171a:	60fb      	str	r3, [r7, #12]
        SET32(0);
 802171c:	68fb      	ldr	r3, [r7, #12]
 802171e:	2200      	movs	r2, #0
 8021720:	601a      	str	r2, [r3, #0]
 8021722:	68fb      	ldr	r3, [r7, #12]
 8021724:	3304      	adds	r3, #4
 8021726:	60fb      	str	r3, [r7, #12]
        SET32(0);
 8021728:	68fb      	ldr	r3, [r7, #12]
 802172a:	2200      	movs	r2, #0
 802172c:	601a      	str	r2, [r3, #0]
 802172e:	68fb      	ldr	r3, [r7, #12]
 8021730:	3304      	adds	r3, #4
 8021732:	60fb      	str	r3, [r7, #12]
        SET32(0);
 8021734:	68fb      	ldr	r3, [r7, #12]
 8021736:	2200      	movs	r2, #0
 8021738:	601a      	str	r2, [r3, #0]
 802173a:	68fb      	ldr	r3, [r7, #12]
 802173c:	3304      	adds	r3, #4
 802173e:	60fb      	str	r3, [r7, #12]
        SET32(0);
 8021740:	68fb      	ldr	r3, [r7, #12]
 8021742:	2200      	movs	r2, #0
 8021744:	601a      	str	r2, [r3, #0]
 8021746:	68fb      	ldr	r3, [r7, #12]
 8021748:	3304      	adds	r3, #4
 802174a:	60fb      	str	r3, [r7, #12]
        SET32(0);
 802174c:	68fb      	ldr	r3, [r7, #12]
 802174e:	2200      	movs	r2, #0
 8021750:	601a      	str	r2, [r3, #0]
 8021752:	68fb      	ldr	r3, [r7, #12]
 8021754:	3304      	adds	r3, #4
 8021756:	60fb      	str	r3, [r7, #12]
        len -= 32;
 8021758:	683b      	ldr	r3, [r7, #0]
 802175a:	3b20      	subs	r3, #32
 802175c:	603b      	str	r3, [r7, #0]
    while(len > 32) {
 802175e:	683b      	ldr	r3, [r7, #0]
 8021760:	2b20      	cmp	r3, #32
 8021762:	d8c9      	bhi.n	80216f8 <_lv_memset_00+0x50>
    }

    while(len > 4) {
 8021764:	e008      	b.n	8021778 <_lv_memset_00+0xd0>
        SET32(0);
 8021766:	68fb      	ldr	r3, [r7, #12]
 8021768:	2200      	movs	r2, #0
 802176a:	601a      	str	r2, [r3, #0]
 802176c:	68fb      	ldr	r3, [r7, #12]
 802176e:	3304      	adds	r3, #4
 8021770:	60fb      	str	r3, [r7, #12]
        len -= 4;
 8021772:	683b      	ldr	r3, [r7, #0]
 8021774:	3b04      	subs	r3, #4
 8021776:	603b      	str	r3, [r7, #0]
    while(len > 4) {
 8021778:	683b      	ldr	r3, [r7, #0]
 802177a:	2b04      	cmp	r3, #4
 802177c:	d8f3      	bhi.n	8021766 <_lv_memset_00+0xbe>
    }


    d8 = (uint8_t *)d32;
 802177e:	68fb      	ldr	r3, [r7, #12]
 8021780:	617b      	str	r3, [r7, #20]
    while(len) {
 8021782:	e008      	b.n	8021796 <_lv_memset_00+0xee>
        *d8 = 0;
 8021784:	697b      	ldr	r3, [r7, #20]
 8021786:	2200      	movs	r2, #0
 8021788:	701a      	strb	r2, [r3, #0]
        d8++;
 802178a:	697b      	ldr	r3, [r7, #20]
 802178c:	3301      	adds	r3, #1
 802178e:	617b      	str	r3, [r7, #20]
        len--;
 8021790:	683b      	ldr	r3, [r7, #0]
 8021792:	3b01      	subs	r3, #1
 8021794:	603b      	str	r3, [r7, #0]
    while(len) {
 8021796:	683b      	ldr	r3, [r7, #0]
 8021798:	2b00      	cmp	r3, #0
 802179a:	d1f3      	bne.n	8021784 <_lv_memset_00+0xdc>
    }
}
 802179c:	bf00      	nop
 802179e:	bf00      	nop
 80217a0:	371c      	adds	r7, #28
 80217a2:	46bd      	mov	sp, r7
 80217a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80217a8:	4770      	bx	lr

080217aa <_lv_memset_ff>:
 * Same as `memset(dst, 0xFF, len)` but optimized for 4 byte operation.
 * @param dst pointer to the destination buffer
 * @param len number of byte to set
 */
LV_ATTRIBUTE_FAST_MEM void _lv_memset_ff(void * dst, size_t len)
{
 80217aa:	b480      	push	{r7}
 80217ac:	b087      	sub	sp, #28
 80217ae:	af00      	add	r7, sp, #0
 80217b0:	6078      	str	r0, [r7, #4]
 80217b2:	6039      	str	r1, [r7, #0]
    uint8_t * d8 = (uint8_t *) dst;
 80217b4:	687b      	ldr	r3, [r7, #4]
 80217b6:	617b      	str	r3, [r7, #20]
    uintptr_t d_align = (lv_uintptr_t) d8 & ALIGN_MASK;
 80217b8:	697b      	ldr	r3, [r7, #20]
 80217ba:	f003 0303 	and.w	r3, r3, #3
 80217be:	613b      	str	r3, [r7, #16]


    /*Make the address aligned*/
    if(d_align) {
 80217c0:	693b      	ldr	r3, [r7, #16]
 80217c2:	2b00      	cmp	r3, #0
 80217c4:	d016      	beq.n	80217f4 <_lv_memset_ff+0x4a>
        d_align = ALIGN_MASK + 1 - d_align;
 80217c6:	693b      	ldr	r3, [r7, #16]
 80217c8:	f1c3 0304 	rsb	r3, r3, #4
 80217cc:	613b      	str	r3, [r7, #16]
        while(d_align && len) {
 80217ce:	e00b      	b.n	80217e8 <_lv_memset_ff+0x3e>
            *d8 = 0xFF;
 80217d0:	697b      	ldr	r3, [r7, #20]
 80217d2:	22ff      	movs	r2, #255	; 0xff
 80217d4:	701a      	strb	r2, [r3, #0]
            d8++;
 80217d6:	697b      	ldr	r3, [r7, #20]
 80217d8:	3301      	adds	r3, #1
 80217da:	617b      	str	r3, [r7, #20]
            len--;
 80217dc:	683b      	ldr	r3, [r7, #0]
 80217de:	3b01      	subs	r3, #1
 80217e0:	603b      	str	r3, [r7, #0]
            d_align--;
 80217e2:	693b      	ldr	r3, [r7, #16]
 80217e4:	3b01      	subs	r3, #1
 80217e6:	613b      	str	r3, [r7, #16]
        while(d_align && len) {
 80217e8:	693b      	ldr	r3, [r7, #16]
 80217ea:	2b00      	cmp	r3, #0
 80217ec:	d002      	beq.n	80217f4 <_lv_memset_ff+0x4a>
 80217ee:	683b      	ldr	r3, [r7, #0]
 80217f0:	2b00      	cmp	r3, #0
 80217f2:	d1ed      	bne.n	80217d0 <_lv_memset_ff+0x26>
        }
    }

    uint32_t * d32 = (uint32_t *)d8;
 80217f4:	697b      	ldr	r3, [r7, #20]
 80217f6:	60fb      	str	r3, [r7, #12]
    while(len > 32) {
 80217f8:	e03a      	b.n	8021870 <_lv_memset_ff+0xc6>
        SET32(0xFFFFFFFF);
 80217fa:	68fb      	ldr	r3, [r7, #12]
 80217fc:	f04f 32ff 	mov.w	r2, #4294967295
 8021800:	601a      	str	r2, [r3, #0]
 8021802:	68fb      	ldr	r3, [r7, #12]
 8021804:	3304      	adds	r3, #4
 8021806:	60fb      	str	r3, [r7, #12]
        SET32(0xFFFFFFFF);
 8021808:	68fb      	ldr	r3, [r7, #12]
 802180a:	f04f 32ff 	mov.w	r2, #4294967295
 802180e:	601a      	str	r2, [r3, #0]
 8021810:	68fb      	ldr	r3, [r7, #12]
 8021812:	3304      	adds	r3, #4
 8021814:	60fb      	str	r3, [r7, #12]
        SET32(0xFFFFFFFF);
 8021816:	68fb      	ldr	r3, [r7, #12]
 8021818:	f04f 32ff 	mov.w	r2, #4294967295
 802181c:	601a      	str	r2, [r3, #0]
 802181e:	68fb      	ldr	r3, [r7, #12]
 8021820:	3304      	adds	r3, #4
 8021822:	60fb      	str	r3, [r7, #12]
        SET32(0xFFFFFFFF);
 8021824:	68fb      	ldr	r3, [r7, #12]
 8021826:	f04f 32ff 	mov.w	r2, #4294967295
 802182a:	601a      	str	r2, [r3, #0]
 802182c:	68fb      	ldr	r3, [r7, #12]
 802182e:	3304      	adds	r3, #4
 8021830:	60fb      	str	r3, [r7, #12]
        SET32(0xFFFFFFFF);
 8021832:	68fb      	ldr	r3, [r7, #12]
 8021834:	f04f 32ff 	mov.w	r2, #4294967295
 8021838:	601a      	str	r2, [r3, #0]
 802183a:	68fb      	ldr	r3, [r7, #12]
 802183c:	3304      	adds	r3, #4
 802183e:	60fb      	str	r3, [r7, #12]
        SET32(0xFFFFFFFF);
 8021840:	68fb      	ldr	r3, [r7, #12]
 8021842:	f04f 32ff 	mov.w	r2, #4294967295
 8021846:	601a      	str	r2, [r3, #0]
 8021848:	68fb      	ldr	r3, [r7, #12]
 802184a:	3304      	adds	r3, #4
 802184c:	60fb      	str	r3, [r7, #12]
        SET32(0xFFFFFFFF);
 802184e:	68fb      	ldr	r3, [r7, #12]
 8021850:	f04f 32ff 	mov.w	r2, #4294967295
 8021854:	601a      	str	r2, [r3, #0]
 8021856:	68fb      	ldr	r3, [r7, #12]
 8021858:	3304      	adds	r3, #4
 802185a:	60fb      	str	r3, [r7, #12]
        SET32(0xFFFFFFFF);
 802185c:	68fb      	ldr	r3, [r7, #12]
 802185e:	f04f 32ff 	mov.w	r2, #4294967295
 8021862:	601a      	str	r2, [r3, #0]
 8021864:	68fb      	ldr	r3, [r7, #12]
 8021866:	3304      	adds	r3, #4
 8021868:	60fb      	str	r3, [r7, #12]
        len -= 32;
 802186a:	683b      	ldr	r3, [r7, #0]
 802186c:	3b20      	subs	r3, #32
 802186e:	603b      	str	r3, [r7, #0]
    while(len > 32) {
 8021870:	683b      	ldr	r3, [r7, #0]
 8021872:	2b20      	cmp	r3, #32
 8021874:	d8c1      	bhi.n	80217fa <_lv_memset_ff+0x50>
    }

    while(len > 4) {
 8021876:	e009      	b.n	802188c <_lv_memset_ff+0xe2>
        SET32(0xFFFFFFFF);
 8021878:	68fb      	ldr	r3, [r7, #12]
 802187a:	f04f 32ff 	mov.w	r2, #4294967295
 802187e:	601a      	str	r2, [r3, #0]
 8021880:	68fb      	ldr	r3, [r7, #12]
 8021882:	3304      	adds	r3, #4
 8021884:	60fb      	str	r3, [r7, #12]
        len -= 4;
 8021886:	683b      	ldr	r3, [r7, #0]
 8021888:	3b04      	subs	r3, #4
 802188a:	603b      	str	r3, [r7, #0]
    while(len > 4) {
 802188c:	683b      	ldr	r3, [r7, #0]
 802188e:	2b04      	cmp	r3, #4
 8021890:	d8f2      	bhi.n	8021878 <_lv_memset_ff+0xce>
    }


    d8 = (uint8_t *)d32;
 8021892:	68fb      	ldr	r3, [r7, #12]
 8021894:	617b      	str	r3, [r7, #20]
    while(len) {
 8021896:	e008      	b.n	80218aa <_lv_memset_ff+0x100>
        *d8 = 0xFF;
 8021898:	697b      	ldr	r3, [r7, #20]
 802189a:	22ff      	movs	r2, #255	; 0xff
 802189c:	701a      	strb	r2, [r3, #0]
        d8++;
 802189e:	697b      	ldr	r3, [r7, #20]
 80218a0:	3301      	adds	r3, #1
 80218a2:	617b      	str	r3, [r7, #20]
        len--;
 80218a4:	683b      	ldr	r3, [r7, #0]
 80218a6:	3b01      	subs	r3, #1
 80218a8:	603b      	str	r3, [r7, #0]
    while(len) {
 80218aa:	683b      	ldr	r3, [r7, #0]
 80218ac:	2b00      	cmp	r3, #0
 80218ae:	d1f3      	bne.n	8021898 <_lv_memset_ff+0xee>
    }
}
 80218b0:	bf00      	nop
 80218b2:	bf00      	nop
 80218b4:	371c      	adds	r7, #28
 80218b6:	46bd      	mov	sp, r7
 80218b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80218bc:	4770      	bx	lr
	...

080218c0 <ent_get_next>:
 * Give the next entry after 'act_e'
 * @param act_e pointer to an entry
 * @return pointer to an entry after 'act_e'
 */
static lv_mem_ent_t * ent_get_next(lv_mem_ent_t * act_e)
{
 80218c0:	b480      	push	{r7}
 80218c2:	b085      	sub	sp, #20
 80218c4:	af00      	add	r7, sp, #0
 80218c6:	6078      	str	r0, [r7, #4]
    lv_mem_ent_t * next_e = NULL;
 80218c8:	2300      	movs	r3, #0
 80218ca:	60fb      	str	r3, [r7, #12]

    if(act_e == NULL) { /*NULL means: get the first entry*/
 80218cc:	687b      	ldr	r3, [r7, #4]
 80218ce:	2b00      	cmp	r3, #0
 80218d0:	d103      	bne.n	80218da <ent_get_next+0x1a>
        next_e = (lv_mem_ent_t *)work_mem;
 80218d2:	4b10      	ldr	r3, [pc, #64]	; (8021914 <ent_get_next+0x54>)
 80218d4:	681b      	ldr	r3, [r3, #0]
 80218d6:	60fb      	str	r3, [r7, #12]
 80218d8:	e014      	b.n	8021904 <ent_get_next+0x44>
    }
    else {   /*Get the next entry */
        uint8_t * data = &act_e->first_data;
 80218da:	687b      	ldr	r3, [r7, #4]
 80218dc:	3304      	adds	r3, #4
 80218de:	60bb      	str	r3, [r7, #8]
        next_e         = (lv_mem_ent_t *)&data[act_e->header.s.d_size];
 80218e0:	687b      	ldr	r3, [r7, #4]
 80218e2:	681b      	ldr	r3, [r3, #0]
 80218e4:	f3c3 035e 	ubfx	r3, r3, #1, #31
 80218e8:	461a      	mov	r2, r3
 80218ea:	68bb      	ldr	r3, [r7, #8]
 80218ec:	4413      	add	r3, r2
 80218ee:	60fb      	str	r3, [r7, #12]

        if(&next_e->first_data >= &work_mem[LV_MEM_SIZE]) next_e = NULL;
 80218f0:	68fb      	ldr	r3, [r7, #12]
 80218f2:	1d1a      	adds	r2, r3, #4
 80218f4:	4b07      	ldr	r3, [pc, #28]	; (8021914 <ent_get_next+0x54>)
 80218f6:	681b      	ldr	r3, [r3, #0]
 80218f8:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 80218fc:	429a      	cmp	r2, r3
 80218fe:	d301      	bcc.n	8021904 <ent_get_next+0x44>
 8021900:	2300      	movs	r3, #0
 8021902:	60fb      	str	r3, [r7, #12]
    }

    return next_e;
 8021904:	68fb      	ldr	r3, [r7, #12]
}
 8021906:	4618      	mov	r0, r3
 8021908:	3714      	adds	r7, #20
 802190a:	46bd      	mov	sp, r7
 802190c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021910:	4770      	bx	lr
 8021912:	bf00      	nop
 8021914:	2000a2e0 	.word	0x2000a2e0

08021918 <ent_alloc>:
 * @param e try to allocate to this entry
 * @param size size of the new memory in bytes
 * @return pointer to the allocated memory or NULL if not enough memory in the entry
 */
static void * ent_alloc(lv_mem_ent_t * e, size_t size)
{
 8021918:	b580      	push	{r7, lr}
 802191a:	b084      	sub	sp, #16
 802191c:	af00      	add	r7, sp, #0
 802191e:	6078      	str	r0, [r7, #4]
 8021920:	6039      	str	r1, [r7, #0]
    void * alloc = NULL;
 8021922:	2300      	movs	r3, #0
 8021924:	60fb      	str	r3, [r7, #12]
    /*If the memory is free and big enough then use it */
    if(e->header.s.used == 0 && e->header.s.d_size >= size) {
 8021926:	687b      	ldr	r3, [r7, #4]
 8021928:	781b      	ldrb	r3, [r3, #0]
 802192a:	f003 0301 	and.w	r3, r3, #1
 802192e:	b2db      	uxtb	r3, r3
 8021930:	2b00      	cmp	r3, #0
 8021932:	d113      	bne.n	802195c <ent_alloc+0x44>
 8021934:	687b      	ldr	r3, [r7, #4]
 8021936:	681b      	ldr	r3, [r3, #0]
 8021938:	f3c3 035e 	ubfx	r3, r3, #1, #31
 802193c:	461a      	mov	r2, r3
 802193e:	683b      	ldr	r3, [r7, #0]
 8021940:	4293      	cmp	r3, r2
 8021942:	d80b      	bhi.n	802195c <ent_alloc+0x44>
        /*Truncate the entry to the desired size */
        ent_trunc(e, size);
 8021944:	6839      	ldr	r1, [r7, #0]
 8021946:	6878      	ldr	r0, [r7, #4]
 8021948:	f000 f80d 	bl	8021966 <ent_trunc>
        e->header.s.used = 1;
 802194c:	687a      	ldr	r2, [r7, #4]
 802194e:	7813      	ldrb	r3, [r2, #0]
 8021950:	f043 0301 	orr.w	r3, r3, #1
 8021954:	7013      	strb	r3, [r2, #0]

        /*Save the allocated data*/
        alloc = &e->first_data;
 8021956:	687b      	ldr	r3, [r7, #4]
 8021958:	3304      	adds	r3, #4
 802195a:	60fb      	str	r3, [r7, #12]
    }

    return alloc;
 802195c:	68fb      	ldr	r3, [r7, #12]
}
 802195e:	4618      	mov	r0, r3
 8021960:	3710      	adds	r7, #16
 8021962:	46bd      	mov	sp, r7
 8021964:	bd80      	pop	{r7, pc}

08021966 <ent_trunc>:
 * Truncate the data of entry to the given size
 * @param e Pointer to an entry
 * @param size new size in bytes
 */
static void ent_trunc(lv_mem_ent_t * e, size_t size)
{
 8021966:	b480      	push	{r7}
 8021968:	b085      	sub	sp, #20
 802196a:	af00      	add	r7, sp, #0
 802196c:	6078      	str	r0, [r7, #4]
 802196e:	6039      	str	r1, [r7, #0]
#ifdef LV_ARCH_64
    /*Round the size up to 8*/
    size = (size + 7) & (~0x7);
#else
    /*Round the size up to 4*/
    size = (size + 3) & (~0x3);
 8021970:	683b      	ldr	r3, [r7, #0]
 8021972:	3303      	adds	r3, #3
 8021974:	f023 0303 	bic.w	r3, r3, #3
 8021978:	603b      	str	r3, [r7, #0]
#endif

    /*Don't let empty space only for a header without data*/
    if(e->header.s.d_size == size + sizeof(lv_mem_header_t)) {
 802197a:	687b      	ldr	r3, [r7, #4]
 802197c:	681b      	ldr	r3, [r3, #0]
 802197e:	f3c3 035e 	ubfx	r3, r3, #1, #31
 8021982:	461a      	mov	r2, r3
 8021984:	683b      	ldr	r3, [r7, #0]
 8021986:	3304      	adds	r3, #4
 8021988:	429a      	cmp	r2, r3
 802198a:	d104      	bne.n	8021996 <ent_trunc+0x30>
        size = e->header.s.d_size;
 802198c:	687b      	ldr	r3, [r7, #4]
 802198e:	681b      	ldr	r3, [r3, #0]
 8021990:	f3c3 035e 	ubfx	r3, r3, #1, #31
 8021994:	603b      	str	r3, [r7, #0]
    }

    /* Create the new entry after the current if there is space for it */
    if(e->header.s.d_size != size) {
 8021996:	687b      	ldr	r3, [r7, #4]
 8021998:	681b      	ldr	r3, [r3, #0]
 802199a:	f3c3 035e 	ubfx	r3, r3, #1, #31
 802199e:	461a      	mov	r2, r3
 80219a0:	683b      	ldr	r3, [r7, #0]
 80219a2:	4293      	cmp	r3, r2
 80219a4:	d01a      	beq.n	80219dc <ent_trunc+0x76>
        uint8_t * e_data             = &e->first_data;
 80219a6:	687b      	ldr	r3, [r7, #4]
 80219a8:	3304      	adds	r3, #4
 80219aa:	60fb      	str	r3, [r7, #12]
        lv_mem_ent_t * after_new_e   = (lv_mem_ent_t *)&e_data[size];
 80219ac:	68fa      	ldr	r2, [r7, #12]
 80219ae:	683b      	ldr	r3, [r7, #0]
 80219b0:	4413      	add	r3, r2
 80219b2:	60bb      	str	r3, [r7, #8]
        after_new_e->header.s.used   = 0;
 80219b4:	68ba      	ldr	r2, [r7, #8]
 80219b6:	7813      	ldrb	r3, [r2, #0]
 80219b8:	f36f 0300 	bfc	r3, #0, #1
 80219bc:	7013      	strb	r3, [r2, #0]
        after_new_e->header.s.d_size = (uint32_t)e->header.s.d_size - size - sizeof(lv_mem_header_t);
 80219be:	687b      	ldr	r3, [r7, #4]
 80219c0:	681b      	ldr	r3, [r3, #0]
 80219c2:	f3c3 035e 	ubfx	r3, r3, #1, #31
 80219c6:	461a      	mov	r2, r3
 80219c8:	683b      	ldr	r3, [r7, #0]
 80219ca:	1ad3      	subs	r3, r2, r3
 80219cc:	3b04      	subs	r3, #4
 80219ce:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 80219d2:	68ba      	ldr	r2, [r7, #8]
 80219d4:	6813      	ldr	r3, [r2, #0]
 80219d6:	f361 035f 	bfi	r3, r1, #1, #31
 80219da:	6013      	str	r3, [r2, #0]
    }

    /* Set the new size for the original entry */
    e->header.s.d_size = (uint32_t)size;
 80219dc:	683b      	ldr	r3, [r7, #0]
 80219de:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 80219e2:	687a      	ldr	r2, [r7, #4]
 80219e4:	6813      	ldr	r3, [r2, #0]
 80219e6:	f361 035f 	bfi	r3, r1, #1, #31
 80219ea:	6013      	str	r3, [r2, #0]
}
 80219ec:	bf00      	nop
 80219ee:	3714      	adds	r7, #20
 80219f0:	46bd      	mov	sp, r7
 80219f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80219f6:	4770      	bx	lr

080219f8 <_lv_task_core_init>:

/**
 * Init the lv_task module
 */
void _lv_task_core_init(void)
{
 80219f8:	b580      	push	{r7, lr}
 80219fa:	af00      	add	r7, sp, #0
    _lv_ll_init(&LV_GC_ROOT(_lv_task_ll), sizeof(lv_task_t));
 80219fc:	2118      	movs	r1, #24
 80219fe:	4805      	ldr	r0, [pc, #20]	; (8021a14 <_lv_task_core_init+0x1c>)
 8021a00:	f7fe fdb6 	bl	8020570 <_lv_ll_init>

    task_list_changed = false;
 8021a04:	4b04      	ldr	r3, [pc, #16]	; (8021a18 <_lv_task_core_init+0x20>)
 8021a06:	2200      	movs	r2, #0
 8021a08:	701a      	strb	r2, [r3, #0]
    /*Initially enable the lv_task handling*/
    lv_task_enable(true);
 8021a0a:	2001      	movs	r0, #1
 8021a0c:	f000 fac6 	bl	8021f9c <lv_task_enable>
}
 8021a10:	bf00      	nop
 8021a12:	bd80      	pop	{r7, pc}
 8021a14:	2000a174 	.word	0x2000a174
 8021a18:	20012311 	.word	0x20012311

08021a1c <lv_task_handler>:
/**
 * Call it  periodically to handle lv_tasks.
 * @return the time after which it must be called again
 */
LV_ATTRIBUTE_TASK_HANDLER uint32_t lv_task_handler(void)
{
 8021a1c:	b580      	push	{r7, lr}
 8021a1e:	b086      	sub	sp, #24
 8021a20:	af00      	add	r7, sp, #0

    LV_LOG_TRACE("lv_task_handler started");

    /*Avoid concurrent running of the task handler*/
    static bool already_running = false;
    if(already_running) return 1;
 8021a22:	4b93      	ldr	r3, [pc, #588]	; (8021c70 <lv_task_handler+0x254>)
 8021a24:	781b      	ldrb	r3, [r3, #0]
 8021a26:	2b00      	cmp	r3, #0
 8021a28:	d001      	beq.n	8021a2e <lv_task_handler+0x12>
 8021a2a:	2301      	movs	r3, #1
 8021a2c:	e11c      	b.n	8021c68 <lv_task_handler+0x24c>
    already_running = true;
 8021a2e:	4b90      	ldr	r3, [pc, #576]	; (8021c70 <lv_task_handler+0x254>)
 8021a30:	2201      	movs	r2, #1
 8021a32:	701a      	strb	r2, [r3, #0]
    static uint32_t idle_period_start = 0;
    static uint32_t handler_start     = 0;
    static uint32_t busy_time         = 0;
    static uint32_t time_till_next;

    if(lv_task_run == false) {
 8021a34:	4b8f      	ldr	r3, [pc, #572]	; (8021c74 <lv_task_handler+0x258>)
 8021a36:	781b      	ldrb	r3, [r3, #0]
 8021a38:	f083 0301 	eor.w	r3, r3, #1
 8021a3c:	b2db      	uxtb	r3, r3
 8021a3e:	2b00      	cmp	r3, #0
 8021a40:	d004      	beq.n	8021a4c <lv_task_handler+0x30>
        already_running = false; /*Release mutex*/
 8021a42:	4b8b      	ldr	r3, [pc, #556]	; (8021c70 <lv_task_handler+0x254>)
 8021a44:	2200      	movs	r2, #0
 8021a46:	701a      	strb	r2, [r3, #0]
        return 1;
 8021a48:	2301      	movs	r3, #1
 8021a4a:	e10d      	b.n	8021c68 <lv_task_handler+0x24c>
    }

    handler_start = lv_tick_get();
 8021a4c:	f7fd f952 	bl	801ecf4 <lv_tick_get>
 8021a50:	4603      	mov	r3, r0
 8021a52:	4a89      	ldr	r2, [pc, #548]	; (8021c78 <lv_task_handler+0x25c>)
 8021a54:	6013      	str	r3, [r2, #0]

    /* Run all task from the highest to the lowest priority
     * If a lower priority task is executed check task again from the highest priority
     * but on the priority of executed tasks don't run tasks before the executed*/
    lv_task_t * task_interrupter = NULL;
 8021a56:	2300      	movs	r3, #0
 8021a58:	617b      	str	r3, [r7, #20]
    lv_task_t * next;
    bool end_flag;
    do {
        end_flag                 = true;
 8021a5a:	2301      	movs	r3, #1
 8021a5c:	73fb      	strb	r3, [r7, #15]
        task_deleted             = false;
 8021a5e:	4b87      	ldr	r3, [pc, #540]	; (8021c7c <lv_task_handler+0x260>)
 8021a60:	2200      	movs	r2, #0
 8021a62:	701a      	strb	r2, [r3, #0]
        task_created             = false;
 8021a64:	4b86      	ldr	r3, [pc, #536]	; (8021c80 <lv_task_handler+0x264>)
 8021a66:	2200      	movs	r2, #0
 8021a68:	701a      	strb	r2, [r3, #0]
        LV_GC_ROOT(_lv_task_act) = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 8021a6a:	4886      	ldr	r0, [pc, #536]	; (8021c84 <lv_task_handler+0x268>)
 8021a6c:	f7fe fef6 	bl	802085c <_lv_ll_get_head>
 8021a70:	4603      	mov	r3, r0
 8021a72:	4a85      	ldr	r2, [pc, #532]	; (8021c88 <lv_task_handler+0x26c>)
 8021a74:	6013      	str	r3, [r2, #0]
        while(LV_GC_ROOT(_lv_task_act)) {
 8021a76:	e08a      	b.n	8021b8e <lv_task_handler+0x172>
            /* The task might be deleted if it runs only once ('once = 1')
             * So get next element until the current is surely valid*/
            next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
 8021a78:	4b83      	ldr	r3, [pc, #524]	; (8021c88 <lv_task_handler+0x26c>)
 8021a7a:	681b      	ldr	r3, [r3, #0]
 8021a7c:	4619      	mov	r1, r3
 8021a7e:	4881      	ldr	r0, [pc, #516]	; (8021c84 <lv_task_handler+0x268>)
 8021a80:	f7fe ff12 	bl	80208a8 <_lv_ll_get_next>
 8021a84:	6138      	str	r0, [r7, #16]

            /*We reach priority of the turned off task. There is nothing more to do.*/
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_OFF) {
 8021a86:	4b80      	ldr	r3, [pc, #512]	; (8021c88 <lv_task_handler+0x26c>)
 8021a88:	681b      	ldr	r3, [r3, #0]
 8021a8a:	7d1b      	ldrb	r3, [r3, #20]
 8021a8c:	f003 0307 	and.w	r3, r3, #7
 8021a90:	b2db      	uxtb	r3, r3
 8021a92:	2b00      	cmp	r3, #0
 8021a94:	f000 8081 	beq.w	8021b9a <lv_task_handler+0x17e>
                break;
            }

            /*Here is the interrupter task. Don't execute it again.*/
            if(LV_GC_ROOT(_lv_task_act) == task_interrupter) {
 8021a98:	4b7b      	ldr	r3, [pc, #492]	; (8021c88 <lv_task_handler+0x26c>)
 8021a9a:	681b      	ldr	r3, [r3, #0]
 8021a9c:	697a      	ldr	r2, [r7, #20]
 8021a9e:	429a      	cmp	r2, r3
 8021aa0:	d105      	bne.n	8021aae <lv_task_handler+0x92>
                task_interrupter = NULL; /*From this point only task after the interrupter comes, so
 8021aa2:	2300      	movs	r3, #0
 8021aa4:	617b      	str	r3, [r7, #20]
                                            the interrupter is not interesting anymore*/
                LV_GC_ROOT(_lv_task_act) = next;
 8021aa6:	4a78      	ldr	r2, [pc, #480]	; (8021c88 <lv_task_handler+0x26c>)
 8021aa8:	693b      	ldr	r3, [r7, #16]
 8021aaa:	6013      	str	r3, [r2, #0]
                continue; /*Load the next task*/
 8021aac:	e06f      	b.n	8021b8e <lv_task_handler+0x172>
            }

            /*Just try to run the tasks with highest priority.*/
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_HIGHEST) {
 8021aae:	4b76      	ldr	r3, [pc, #472]	; (8021c88 <lv_task_handler+0x26c>)
 8021ab0:	681b      	ldr	r3, [r3, #0]
 8021ab2:	7d1b      	ldrb	r3, [r3, #20]
 8021ab4:	f003 0307 	and.w	r3, r3, #7
 8021ab8:	b2db      	uxtb	r3, r3
 8021aba:	2b05      	cmp	r3, #5
 8021abc:	d105      	bne.n	8021aca <lv_task_handler+0xae>
                lv_task_exec(LV_GC_ROOT(_lv_task_act));
 8021abe:	4b72      	ldr	r3, [pc, #456]	; (8021c88 <lv_task_handler+0x26c>)
 8021ac0:	681b      	ldr	r3, [r3, #0]
 8021ac2:	4618      	mov	r0, r3
 8021ac4:	f000 fa7a 	bl	8021fbc <lv_task_exec>
 8021ac8:	e047      	b.n	8021b5a <lv_task_handler+0x13e>
            }
            /*Tasks with higher priority than the interrupted shall be run in every case*/
            else if(task_interrupter) {
 8021aca:	697b      	ldr	r3, [r7, #20]
 8021acc:	2b00      	cmp	r3, #0
 8021ace:	d028      	beq.n	8021b22 <lv_task_handler+0x106>
                if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio > task_interrupter->prio) {
 8021ad0:	4b6d      	ldr	r3, [pc, #436]	; (8021c88 <lv_task_handler+0x26c>)
 8021ad2:	681b      	ldr	r3, [r3, #0]
 8021ad4:	7d1b      	ldrb	r3, [r3, #20]
 8021ad6:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8021ada:	b2da      	uxtb	r2, r3
 8021adc:	697b      	ldr	r3, [r7, #20]
 8021ade:	7d1b      	ldrb	r3, [r3, #20]
 8021ae0:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8021ae4:	b2db      	uxtb	r3, r3
 8021ae6:	429a      	cmp	r2, r3
 8021ae8:	d937      	bls.n	8021b5a <lv_task_handler+0x13e>
                    if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
 8021aea:	4b67      	ldr	r3, [pc, #412]	; (8021c88 <lv_task_handler+0x26c>)
 8021aec:	681b      	ldr	r3, [r3, #0]
 8021aee:	4618      	mov	r0, r3
 8021af0:	f000 fa64 	bl	8021fbc <lv_task_exec>
 8021af4:	4603      	mov	r3, r0
 8021af6:	2b00      	cmp	r3, #0
 8021af8:	d02f      	beq.n	8021b5a <lv_task_handler+0x13e>
                        if(!task_created && !task_deleted) {
 8021afa:	4b61      	ldr	r3, [pc, #388]	; (8021c80 <lv_task_handler+0x264>)
 8021afc:	781b      	ldrb	r3, [r3, #0]
 8021afe:	f083 0301 	eor.w	r3, r3, #1
 8021b02:	b2db      	uxtb	r3, r3
 8021b04:	2b00      	cmp	r3, #0
 8021b06:	d028      	beq.n	8021b5a <lv_task_handler+0x13e>
 8021b08:	4b5c      	ldr	r3, [pc, #368]	; (8021c7c <lv_task_handler+0x260>)
 8021b0a:	781b      	ldrb	r3, [r3, #0]
 8021b0c:	f083 0301 	eor.w	r3, r3, #1
 8021b10:	b2db      	uxtb	r3, r3
 8021b12:	2b00      	cmp	r3, #0
 8021b14:	d021      	beq.n	8021b5a <lv_task_handler+0x13e>
                            /*Check all tasks again from the highest priority */
                            task_interrupter = LV_GC_ROOT(_lv_task_act);
 8021b16:	4b5c      	ldr	r3, [pc, #368]	; (8021c88 <lv_task_handler+0x26c>)
 8021b18:	681b      	ldr	r3, [r3, #0]
 8021b1a:	617b      	str	r3, [r7, #20]
                            end_flag = false;
 8021b1c:	2300      	movs	r3, #0
 8021b1e:	73fb      	strb	r3, [r7, #15]
                            break;
 8021b20:	e03c      	b.n	8021b9c <lv_task_handler+0x180>
                }
            }
            /* It is no interrupter task or we already reached it earlier.
             * Just run the remaining tasks*/
            else {
                if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
 8021b22:	4b59      	ldr	r3, [pc, #356]	; (8021c88 <lv_task_handler+0x26c>)
 8021b24:	681b      	ldr	r3, [r3, #0]
 8021b26:	4618      	mov	r0, r3
 8021b28:	f000 fa48 	bl	8021fbc <lv_task_exec>
 8021b2c:	4603      	mov	r3, r0
 8021b2e:	2b00      	cmp	r3, #0
 8021b30:	d013      	beq.n	8021b5a <lv_task_handler+0x13e>
                    if(!task_created && !task_deleted) {
 8021b32:	4b53      	ldr	r3, [pc, #332]	; (8021c80 <lv_task_handler+0x264>)
 8021b34:	781b      	ldrb	r3, [r3, #0]
 8021b36:	f083 0301 	eor.w	r3, r3, #1
 8021b3a:	b2db      	uxtb	r3, r3
 8021b3c:	2b00      	cmp	r3, #0
 8021b3e:	d00c      	beq.n	8021b5a <lv_task_handler+0x13e>
 8021b40:	4b4e      	ldr	r3, [pc, #312]	; (8021c7c <lv_task_handler+0x260>)
 8021b42:	781b      	ldrb	r3, [r3, #0]
 8021b44:	f083 0301 	eor.w	r3, r3, #1
 8021b48:	b2db      	uxtb	r3, r3
 8021b4a:	2b00      	cmp	r3, #0
 8021b4c:	d005      	beq.n	8021b5a <lv_task_handler+0x13e>
                        task_interrupter = LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
 8021b4e:	4b4e      	ldr	r3, [pc, #312]	; (8021c88 <lv_task_handler+0x26c>)
 8021b50:	681b      	ldr	r3, [r3, #0]
 8021b52:	617b      	str	r3, [r7, #20]
                        end_flag         = false;
 8021b54:	2300      	movs	r3, #0
 8021b56:	73fb      	strb	r3, [r7, #15]
                        break;
 8021b58:	e020      	b.n	8021b9c <lv_task_handler+0x180>
                    }
                }
            }

            /*If a task was created or deleted then this or the next item might be corrupted*/
            if(task_created || task_deleted) {
 8021b5a:	4b49      	ldr	r3, [pc, #292]	; (8021c80 <lv_task_handler+0x264>)
 8021b5c:	781b      	ldrb	r3, [r3, #0]
 8021b5e:	2b00      	cmp	r3, #0
 8021b60:	d103      	bne.n	8021b6a <lv_task_handler+0x14e>
 8021b62:	4b46      	ldr	r3, [pc, #280]	; (8021c7c <lv_task_handler+0x260>)
 8021b64:	781b      	ldrb	r3, [r3, #0]
 8021b66:	2b00      	cmp	r3, #0
 8021b68:	d002      	beq.n	8021b70 <lv_task_handler+0x154>
                task_interrupter = NULL;
 8021b6a:	2300      	movs	r3, #0
 8021b6c:	617b      	str	r3, [r7, #20]
                break;
 8021b6e:	e015      	b.n	8021b9c <lv_task_handler+0x180>
            }

            if(task_list_changed) {
 8021b70:	4b46      	ldr	r3, [pc, #280]	; (8021c8c <lv_task_handler+0x270>)
 8021b72:	781b      	ldrb	r3, [r3, #0]
 8021b74:	2b00      	cmp	r3, #0
 8021b76:	d007      	beq.n	8021b88 <lv_task_handler+0x16c>
                task_interrupter = NULL;
 8021b78:	2300      	movs	r3, #0
 8021b7a:	617b      	str	r3, [r7, #20]
                end_flag = false;
 8021b7c:	2300      	movs	r3, #0
 8021b7e:	73fb      	strb	r3, [r7, #15]
                task_list_changed = false;
 8021b80:	4b42      	ldr	r3, [pc, #264]	; (8021c8c <lv_task_handler+0x270>)
 8021b82:	2200      	movs	r2, #0
 8021b84:	701a      	strb	r2, [r3, #0]
                break;
 8021b86:	e009      	b.n	8021b9c <lv_task_handler+0x180>
            }

            LV_GC_ROOT(_lv_task_act) = next; /*Load the next task*/
 8021b88:	4a3f      	ldr	r2, [pc, #252]	; (8021c88 <lv_task_handler+0x26c>)
 8021b8a:	693b      	ldr	r3, [r7, #16]
 8021b8c:	6013      	str	r3, [r2, #0]
        while(LV_GC_ROOT(_lv_task_act)) {
 8021b8e:	4b3e      	ldr	r3, [pc, #248]	; (8021c88 <lv_task_handler+0x26c>)
 8021b90:	681b      	ldr	r3, [r3, #0]
 8021b92:	2b00      	cmp	r3, #0
 8021b94:	f47f af70 	bne.w	8021a78 <lv_task_handler+0x5c>
 8021b98:	e000      	b.n	8021b9c <lv_task_handler+0x180>
                break;
 8021b9a:	bf00      	nop
        }
    } while(!end_flag);
 8021b9c:	7bfb      	ldrb	r3, [r7, #15]
 8021b9e:	f083 0301 	eor.w	r3, r3, #1
 8021ba2:	b2db      	uxtb	r3, r3
 8021ba4:	2b00      	cmp	r3, #0
 8021ba6:	f47f af58 	bne.w	8021a5a <lv_task_handler+0x3e>

    busy_time += lv_tick_elaps(handler_start);
 8021baa:	4b33      	ldr	r3, [pc, #204]	; (8021c78 <lv_task_handler+0x25c>)
 8021bac:	681b      	ldr	r3, [r3, #0]
 8021bae:	4618      	mov	r0, r3
 8021bb0:	f7fd f8ba 	bl	801ed28 <lv_tick_elaps>
 8021bb4:	4602      	mov	r2, r0
 8021bb6:	4b36      	ldr	r3, [pc, #216]	; (8021c90 <lv_task_handler+0x274>)
 8021bb8:	681b      	ldr	r3, [r3, #0]
 8021bba:	4413      	add	r3, r2
 8021bbc:	4a34      	ldr	r2, [pc, #208]	; (8021c90 <lv_task_handler+0x274>)
 8021bbe:	6013      	str	r3, [r2, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
 8021bc0:	4b34      	ldr	r3, [pc, #208]	; (8021c94 <lv_task_handler+0x278>)
 8021bc2:	681b      	ldr	r3, [r3, #0]
 8021bc4:	4618      	mov	r0, r3
 8021bc6:	f7fd f8af 	bl	801ed28 <lv_tick_elaps>
 8021bca:	60b8      	str	r0, [r7, #8]
    if(idle_period_time >= IDLE_MEAS_PERIOD) {
 8021bcc:	68bb      	ldr	r3, [r7, #8]
 8021bce:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8021bd2:	d320      	bcc.n	8021c16 <lv_task_handler+0x1fa>

        idle_last         = (uint32_t)((uint32_t)busy_time * 100) / IDLE_MEAS_PERIOD; /*Calculate the busy percentage*/
 8021bd4:	4b2e      	ldr	r3, [pc, #184]	; (8021c90 <lv_task_handler+0x274>)
 8021bd6:	681b      	ldr	r3, [r3, #0]
 8021bd8:	2264      	movs	r2, #100	; 0x64
 8021bda:	fb02 f303 	mul.w	r3, r2, r3
 8021bde:	4a2e      	ldr	r2, [pc, #184]	; (8021c98 <lv_task_handler+0x27c>)
 8021be0:	fba2 2303 	umull	r2, r3, r2, r3
 8021be4:	095b      	lsrs	r3, r3, #5
 8021be6:	b2da      	uxtb	r2, r3
 8021be8:	4b2c      	ldr	r3, [pc, #176]	; (8021c9c <lv_task_handler+0x280>)
 8021bea:	701a      	strb	r2, [r3, #0]
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last;                    /*But we need idle time*/
 8021bec:	4b2b      	ldr	r3, [pc, #172]	; (8021c9c <lv_task_handler+0x280>)
 8021bee:	781b      	ldrb	r3, [r3, #0]
 8021bf0:	2b64      	cmp	r3, #100	; 0x64
 8021bf2:	d805      	bhi.n	8021c00 <lv_task_handler+0x1e4>
 8021bf4:	4b29      	ldr	r3, [pc, #164]	; (8021c9c <lv_task_handler+0x280>)
 8021bf6:	781b      	ldrb	r3, [r3, #0]
 8021bf8:	f1c3 0364 	rsb	r3, r3, #100	; 0x64
 8021bfc:	b2db      	uxtb	r3, r3
 8021bfe:	e000      	b.n	8021c02 <lv_task_handler+0x1e6>
 8021c00:	2300      	movs	r3, #0
 8021c02:	4a26      	ldr	r2, [pc, #152]	; (8021c9c <lv_task_handler+0x280>)
 8021c04:	7013      	strb	r3, [r2, #0]
        busy_time         = 0;
 8021c06:	4b22      	ldr	r3, [pc, #136]	; (8021c90 <lv_task_handler+0x274>)
 8021c08:	2200      	movs	r2, #0
 8021c0a:	601a      	str	r2, [r3, #0]
        idle_period_start = lv_tick_get();
 8021c0c:	f7fd f872 	bl	801ecf4 <lv_tick_get>
 8021c10:	4603      	mov	r3, r0
 8021c12:	4a20      	ldr	r2, [pc, #128]	; (8021c94 <lv_task_handler+0x278>)
 8021c14:	6013      	str	r3, [r2, #0]
    }

    time_till_next = LV_NO_TASK_READY;
 8021c16:	4b22      	ldr	r3, [pc, #136]	; (8021ca0 <lv_task_handler+0x284>)
 8021c18:	f04f 32ff 	mov.w	r2, #4294967295
 8021c1c:	601a      	str	r2, [r3, #0]
    next = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 8021c1e:	4819      	ldr	r0, [pc, #100]	; (8021c84 <lv_task_handler+0x268>)
 8021c20:	f7fe fe1c 	bl	802085c <_lv_ll_get_head>
 8021c24:	6138      	str	r0, [r7, #16]
    while(next) {
 8021c26:	e017      	b.n	8021c58 <lv_task_handler+0x23c>
        if(next->prio != LV_TASK_PRIO_OFF) {
 8021c28:	693b      	ldr	r3, [r7, #16]
 8021c2a:	7d1b      	ldrb	r3, [r3, #20]
 8021c2c:	f003 0307 	and.w	r3, r3, #7
 8021c30:	b2db      	uxtb	r3, r3
 8021c32:	2b00      	cmp	r3, #0
 8021c34:	d00b      	beq.n	8021c4e <lv_task_handler+0x232>
            uint32_t delay = lv_task_time_remaining(next);
 8021c36:	6938      	ldr	r0, [r7, #16]
 8021c38:	f000 fa02 	bl	8022040 <lv_task_time_remaining>
 8021c3c:	6078      	str	r0, [r7, #4]
            if(delay < time_till_next)
 8021c3e:	4b18      	ldr	r3, [pc, #96]	; (8021ca0 <lv_task_handler+0x284>)
 8021c40:	681b      	ldr	r3, [r3, #0]
 8021c42:	687a      	ldr	r2, [r7, #4]
 8021c44:	429a      	cmp	r2, r3
 8021c46:	d202      	bcs.n	8021c4e <lv_task_handler+0x232>
                time_till_next = delay;
 8021c48:	4a15      	ldr	r2, [pc, #84]	; (8021ca0 <lv_task_handler+0x284>)
 8021c4a:	687b      	ldr	r3, [r7, #4]
 8021c4c:	6013      	str	r3, [r2, #0]
        }

        next = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), next); /*Find the next task*/
 8021c4e:	6939      	ldr	r1, [r7, #16]
 8021c50:	480c      	ldr	r0, [pc, #48]	; (8021c84 <lv_task_handler+0x268>)
 8021c52:	f7fe fe29 	bl	80208a8 <_lv_ll_get_next>
 8021c56:	6138      	str	r0, [r7, #16]
    while(next) {
 8021c58:	693b      	ldr	r3, [r7, #16]
 8021c5a:	2b00      	cmp	r3, #0
 8021c5c:	d1e4      	bne.n	8021c28 <lv_task_handler+0x20c>
    }

    already_running = false; /*Release the mutex*/
 8021c5e:	4b04      	ldr	r3, [pc, #16]	; (8021c70 <lv_task_handler+0x254>)
 8021c60:	2200      	movs	r2, #0
 8021c62:	701a      	strb	r2, [r3, #0]

    LV_LOG_TRACE("lv_task_handler ready");
    return time_till_next;
 8021c64:	4b0e      	ldr	r3, [pc, #56]	; (8021ca0 <lv_task_handler+0x284>)
 8021c66:	681b      	ldr	r3, [r3, #0]
}
 8021c68:	4618      	mov	r0, r3
 8021c6a:	3718      	adds	r7, #24
 8021c6c:	46bd      	mov	sp, r7
 8021c6e:	bd80      	pop	{r7, pc}
 8021c70:	20012313 	.word	0x20012313
 8021c74:	2001230e 	.word	0x2001230e
 8021c78:	20012314 	.word	0x20012314
 8021c7c:	20012310 	.word	0x20012310
 8021c80:	20012312 	.word	0x20012312
 8021c84:	2000a174 	.word	0x2000a174
 8021c88:	2000a1d8 	.word	0x2000a1d8
 8021c8c:	20012311 	.word	0x20012311
 8021c90:	20012318 	.word	0x20012318
 8021c94:	2001231c 	.word	0x2001231c
 8021c98:	10624dd3 	.word	0x10624dd3
 8021c9c:	2001230f 	.word	0x2001230f
 8021ca0:	20012320 	.word	0x20012320

08021ca4 <lv_task_create_basic>:
 * Create an "empty" task. It needs to initialized with at least
 * `lv_task_set_cb` and `lv_task_set_period`
 * @return pointer to the created task
 */
lv_task_t * lv_task_create_basic(void)
{
 8021ca4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8021ca8:	b082      	sub	sp, #8
 8021caa:	af00      	add	r7, sp, #0
    lv_task_t * new_task = NULL;
 8021cac:	2300      	movs	r3, #0
 8021cae:	607b      	str	r3, [r7, #4]
    lv_task_t * tmp;

    /*Create task lists in order of priority from high to low*/
    tmp = _lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 8021cb0:	484a      	ldr	r0, [pc, #296]	; (8021ddc <lv_task_create_basic+0x138>)
 8021cb2:	f7fe fdd3 	bl	802085c <_lv_ll_get_head>
 8021cb6:	6038      	str	r0, [r7, #0]

    /*It's the first task*/
    if(NULL == tmp) {
 8021cb8:	683b      	ldr	r3, [r7, #0]
 8021cba:	2b00      	cmp	r3, #0
 8021cbc:	d11b      	bne.n	8021cf6 <lv_task_create_basic+0x52>
        new_task = _lv_ll_ins_head(&LV_GC_ROOT(_lv_task_ll));
 8021cbe:	4847      	ldr	r0, [pc, #284]	; (8021ddc <lv_task_create_basic+0x138>)
 8021cc0:	f7fe fc6f 	bl	80205a2 <_lv_ll_ins_head>
 8021cc4:	6078      	str	r0, [r7, #4]
        LV_ASSERT_MEM(new_task);
 8021cc6:	6878      	ldr	r0, [r7, #4]
 8021cc8:	f7fe fa12 	bl	80200f0 <lv_debug_check_null>
 8021ccc:	4603      	mov	r3, r0
 8021cce:	f083 0301 	eor.w	r3, r3, #1
 8021cd2:	b2db      	uxtb	r3, r3
 8021cd4:	2b00      	cmp	r3, #0
 8021cd6:	d009      	beq.n	8021cec <lv_task_create_basic+0x48>
 8021cd8:	687b      	ldr	r3, [r7, #4]
 8021cda:	2200      	movs	r2, #0
 8021cdc:	469a      	mov	sl, r3
 8021cde:	4693      	mov	fp, r2
 8021ce0:	4652      	mov	r2, sl
 8021ce2:	465b      	mov	r3, fp
 8021ce4:	483e      	ldr	r0, [pc, #248]	; (8021de0 <lv_task_create_basic+0x13c>)
 8021ce6:	f7fe fa13 	bl	8020110 <lv_debug_log_error>
 8021cea:	e7fe      	b.n	8021cea <lv_task_create_basic+0x46>
        if(new_task == NULL) return NULL;
 8021cec:	687b      	ldr	r3, [r7, #4]
 8021cee:	2b00      	cmp	r3, #0
 8021cf0:	d14e      	bne.n	8021d90 <lv_task_create_basic+0xec>
 8021cf2:	2300      	movs	r3, #0
 8021cf4:	e06c      	b.n	8021dd0 <lv_task_create_basic+0x12c>
    }
    /*Insert the new task to proper place according to its priority*/
    else {
        do {
            if(tmp->prio <= DEF_PRIO) {
 8021cf6:	683b      	ldr	r3, [r7, #0]
 8021cf8:	7d1b      	ldrb	r3, [r3, #20]
 8021cfa:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8021cfe:	b2db      	uxtb	r3, r3
 8021d00:	2b03      	cmp	r3, #3
 8021d02:	d81c      	bhi.n	8021d3e <lv_task_create_basic+0x9a>
                new_task = _lv_ll_ins_prev(&LV_GC_ROOT(_lv_task_ll), tmp);
 8021d04:	6839      	ldr	r1, [r7, #0]
 8021d06:	4835      	ldr	r0, [pc, #212]	; (8021ddc <lv_task_create_basic+0x138>)
 8021d08:	f7fe fc7f 	bl	802060a <_lv_ll_ins_prev>
 8021d0c:	6078      	str	r0, [r7, #4]
                LV_ASSERT_MEM(new_task);
 8021d0e:	6878      	ldr	r0, [r7, #4]
 8021d10:	f7fe f9ee 	bl	80200f0 <lv_debug_check_null>
 8021d14:	4603      	mov	r3, r0
 8021d16:	f083 0301 	eor.w	r3, r3, #1
 8021d1a:	b2db      	uxtb	r3, r3
 8021d1c:	2b00      	cmp	r3, #0
 8021d1e:	d009      	beq.n	8021d34 <lv_task_create_basic+0x90>
 8021d20:	687b      	ldr	r3, [r7, #4]
 8021d22:	2200      	movs	r2, #0
 8021d24:	4698      	mov	r8, r3
 8021d26:	4691      	mov	r9, r2
 8021d28:	4642      	mov	r2, r8
 8021d2a:	464b      	mov	r3, r9
 8021d2c:	482c      	ldr	r0, [pc, #176]	; (8021de0 <lv_task_create_basic+0x13c>)
 8021d2e:	f7fe f9ef 	bl	8020110 <lv_debug_log_error>
 8021d32:	e7fe      	b.n	8021d32 <lv_task_create_basic+0x8e>
                if(new_task == NULL) return NULL;
 8021d34:	687b      	ldr	r3, [r7, #4]
 8021d36:	2b00      	cmp	r3, #0
 8021d38:	d10a      	bne.n	8021d50 <lv_task_create_basic+0xac>
 8021d3a:	2300      	movs	r3, #0
 8021d3c:	e048      	b.n	8021dd0 <lv_task_create_basic+0x12c>
                break;
            }
            tmp = _lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
 8021d3e:	6839      	ldr	r1, [r7, #0]
 8021d40:	4826      	ldr	r0, [pc, #152]	; (8021ddc <lv_task_create_basic+0x138>)
 8021d42:	f7fe fdb1 	bl	80208a8 <_lv_ll_get_next>
 8021d46:	6038      	str	r0, [r7, #0]
        } while(tmp != NULL);
 8021d48:	683b      	ldr	r3, [r7, #0]
 8021d4a:	2b00      	cmp	r3, #0
 8021d4c:	d1d3      	bne.n	8021cf6 <lv_task_create_basic+0x52>
 8021d4e:	e000      	b.n	8021d52 <lv_task_create_basic+0xae>
                break;
 8021d50:	bf00      	nop

        /*Only too high priority tasks were found. Add the task to the end*/
        if(tmp == NULL) {
 8021d52:	683b      	ldr	r3, [r7, #0]
 8021d54:	2b00      	cmp	r3, #0
 8021d56:	d11b      	bne.n	8021d90 <lv_task_create_basic+0xec>
            new_task = _lv_ll_ins_tail(&LV_GC_ROOT(_lv_task_ll));
 8021d58:	4820      	ldr	r0, [pc, #128]	; (8021ddc <lv_task_create_basic+0x138>)
 8021d5a:	f7fe fc9d 	bl	8020698 <_lv_ll_ins_tail>
 8021d5e:	6078      	str	r0, [r7, #4]
            LV_ASSERT_MEM(new_task);
 8021d60:	6878      	ldr	r0, [r7, #4]
 8021d62:	f7fe f9c5 	bl	80200f0 <lv_debug_check_null>
 8021d66:	4603      	mov	r3, r0
 8021d68:	f083 0301 	eor.w	r3, r3, #1
 8021d6c:	b2db      	uxtb	r3, r3
 8021d6e:	2b00      	cmp	r3, #0
 8021d70:	d009      	beq.n	8021d86 <lv_task_create_basic+0xe2>
 8021d72:	687b      	ldr	r3, [r7, #4]
 8021d74:	2200      	movs	r2, #0
 8021d76:	461c      	mov	r4, r3
 8021d78:	4615      	mov	r5, r2
 8021d7a:	4622      	mov	r2, r4
 8021d7c:	462b      	mov	r3, r5
 8021d7e:	4818      	ldr	r0, [pc, #96]	; (8021de0 <lv_task_create_basic+0x13c>)
 8021d80:	f7fe f9c6 	bl	8020110 <lv_debug_log_error>
 8021d84:	e7fe      	b.n	8021d84 <lv_task_create_basic+0xe0>
            if(new_task == NULL) return NULL;
 8021d86:	687b      	ldr	r3, [r7, #4]
 8021d88:	2b00      	cmp	r3, #0
 8021d8a:	d101      	bne.n	8021d90 <lv_task_create_basic+0xec>
 8021d8c:	2300      	movs	r3, #0
 8021d8e:	e01f      	b.n	8021dd0 <lv_task_create_basic+0x12c>
        }
    }
    task_list_changed = true;
 8021d90:	4b14      	ldr	r3, [pc, #80]	; (8021de4 <lv_task_create_basic+0x140>)
 8021d92:	2201      	movs	r2, #1
 8021d94:	701a      	strb	r2, [r3, #0]

    new_task->period  = DEF_PERIOD;
 8021d96:	687b      	ldr	r3, [r7, #4]
 8021d98:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8021d9c:	601a      	str	r2, [r3, #0]
    new_task->task_cb = NULL;
 8021d9e:	687b      	ldr	r3, [r7, #4]
 8021da0:	2200      	movs	r2, #0
 8021da2:	609a      	str	r2, [r3, #8]
    new_task->prio    = DEF_PRIO;
 8021da4:	687a      	ldr	r2, [r7, #4]
 8021da6:	7d13      	ldrb	r3, [r2, #20]
 8021da8:	2103      	movs	r1, #3
 8021daa:	f361 0302 	bfi	r3, r1, #0, #3
 8021dae:	7513      	strb	r3, [r2, #20]

    new_task->repeat_count = -1;
 8021db0:	687b      	ldr	r3, [r7, #4]
 8021db2:	f04f 32ff 	mov.w	r2, #4294967295
 8021db6:	611a      	str	r2, [r3, #16]
    new_task->last_run = lv_tick_get();
 8021db8:	f7fc ff9c 	bl	801ecf4 <lv_tick_get>
 8021dbc:	4602      	mov	r2, r0
 8021dbe:	687b      	ldr	r3, [r7, #4]
 8021dc0:	605a      	str	r2, [r3, #4]

    new_task->user_data = NULL;
 8021dc2:	687b      	ldr	r3, [r7, #4]
 8021dc4:	2200      	movs	r2, #0
 8021dc6:	60da      	str	r2, [r3, #12]

    task_created = true;
 8021dc8:	4b07      	ldr	r3, [pc, #28]	; (8021de8 <lv_task_create_basic+0x144>)
 8021dca:	2201      	movs	r2, #1
 8021dcc:	701a      	strb	r2, [r3, #0]

    return new_task;
 8021dce:	687b      	ldr	r3, [r7, #4]
}
 8021dd0:	4618      	mov	r0, r3
 8021dd2:	3708      	adds	r7, #8
 8021dd4:	46bd      	mov	sp, r7
 8021dd6:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8021dda:	bf00      	nop
 8021ddc:	2000a174 	.word	0x2000a174
 8021de0:	0802e57c 	.word	0x0802e57c
 8021de4:	20012311 	.word	0x20012311
 8021de8:	20012312 	.word	0x20012312

08021dec <lv_task_create>:
 * @param prio priority of the task (LV_TASK_PRIO_OFF means the task is stopped)
 * @param user_data custom parameter
 * @return pointer to the new task
 */
lv_task_t * lv_task_create(lv_task_cb_t task_xcb, uint32_t period, lv_task_prio_t prio, void * user_data)
{
 8021dec:	b5b0      	push	{r4, r5, r7, lr}
 8021dee:	b086      	sub	sp, #24
 8021df0:	af00      	add	r7, sp, #0
 8021df2:	60f8      	str	r0, [r7, #12]
 8021df4:	60b9      	str	r1, [r7, #8]
 8021df6:	603b      	str	r3, [r7, #0]
 8021df8:	4613      	mov	r3, r2
 8021dfa:	71fb      	strb	r3, [r7, #7]
    lv_task_t * new_task = lv_task_create_basic();
 8021dfc:	f7ff ff52 	bl	8021ca4 <lv_task_create_basic>
 8021e00:	6178      	str	r0, [r7, #20]
    LV_ASSERT_MEM(new_task);
 8021e02:	6978      	ldr	r0, [r7, #20]
 8021e04:	f7fe f974 	bl	80200f0 <lv_debug_check_null>
 8021e08:	4603      	mov	r3, r0
 8021e0a:	f083 0301 	eor.w	r3, r3, #1
 8021e0e:	b2db      	uxtb	r3, r3
 8021e10:	2b00      	cmp	r3, #0
 8021e12:	d009      	beq.n	8021e28 <lv_task_create+0x3c>
 8021e14:	697b      	ldr	r3, [r7, #20]
 8021e16:	2200      	movs	r2, #0
 8021e18:	461c      	mov	r4, r3
 8021e1a:	4615      	mov	r5, r2
 8021e1c:	4622      	mov	r2, r4
 8021e1e:	462b      	mov	r3, r5
 8021e20:	480e      	ldr	r0, [pc, #56]	; (8021e5c <lv_task_create+0x70>)
 8021e22:	f7fe f975 	bl	8020110 <lv_debug_log_error>
 8021e26:	e7fe      	b.n	8021e26 <lv_task_create+0x3a>
    if(new_task == NULL) return NULL;
 8021e28:	697b      	ldr	r3, [r7, #20]
 8021e2a:	2b00      	cmp	r3, #0
 8021e2c:	d101      	bne.n	8021e32 <lv_task_create+0x46>
 8021e2e:	2300      	movs	r3, #0
 8021e30:	e010      	b.n	8021e54 <lv_task_create+0x68>

    lv_task_set_cb(new_task, task_xcb);
 8021e32:	68f9      	ldr	r1, [r7, #12]
 8021e34:	6978      	ldr	r0, [r7, #20]
 8021e36:	f000 f813 	bl	8021e60 <lv_task_set_cb>
    lv_task_set_period(new_task, period);
 8021e3a:	68b9      	ldr	r1, [r7, #8]
 8021e3c:	6978      	ldr	r0, [r7, #20]
 8021e3e:	f000 f88d 	bl	8021f5c <lv_task_set_period>
    lv_task_set_prio(new_task, prio);
 8021e42:	79fb      	ldrb	r3, [r7, #7]
 8021e44:	4619      	mov	r1, r3
 8021e46:	6978      	ldr	r0, [r7, #20]
 8021e48:	f000 f83a 	bl	8021ec0 <lv_task_set_prio>
    new_task->user_data = user_data;
 8021e4c:	697b      	ldr	r3, [r7, #20]
 8021e4e:	683a      	ldr	r2, [r7, #0]
 8021e50:	60da      	str	r2, [r3, #12]

    return new_task;
 8021e52:	697b      	ldr	r3, [r7, #20]
}
 8021e54:	4618      	mov	r0, r3
 8021e56:	3718      	adds	r7, #24
 8021e58:	46bd      	mov	sp, r7
 8021e5a:	bdb0      	pop	{r4, r5, r7, pc}
 8021e5c:	0802e57c 	.word	0x0802e57c

08021e60 <lv_task_set_cb>:
 * Set the callback the task (the function to call periodically)
 * @param task pointer to a task
 * @param task_cb the function to call periodically
 */
void lv_task_set_cb(lv_task_t * task, lv_task_cb_t task_cb)
{
 8021e60:	b480      	push	{r7}
 8021e62:	b083      	sub	sp, #12
 8021e64:	af00      	add	r7, sp, #0
 8021e66:	6078      	str	r0, [r7, #4]
 8021e68:	6039      	str	r1, [r7, #0]
    task->task_cb = task_cb;
 8021e6a:	687b      	ldr	r3, [r7, #4]
 8021e6c:	683a      	ldr	r2, [r7, #0]
 8021e6e:	609a      	str	r2, [r3, #8]
}
 8021e70:	bf00      	nop
 8021e72:	370c      	adds	r7, #12
 8021e74:	46bd      	mov	sp, r7
 8021e76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021e7a:	4770      	bx	lr

08021e7c <lv_task_del>:
/**
 * Delete a lv_task
 * @param task pointer to task created by task
 */
void lv_task_del(lv_task_t * task)
{
 8021e7c:	b580      	push	{r7, lr}
 8021e7e:	b082      	sub	sp, #8
 8021e80:	af00      	add	r7, sp, #0
 8021e82:	6078      	str	r0, [r7, #4]
    _lv_ll_remove(&LV_GC_ROOT(_lv_task_ll), task);
 8021e84:	6879      	ldr	r1, [r7, #4]
 8021e86:	480a      	ldr	r0, [pc, #40]	; (8021eb0 <lv_task_del+0x34>)
 8021e88:	f7fe fc3a 	bl	8020700 <_lv_ll_remove>
    task_list_changed = true;
 8021e8c:	4b09      	ldr	r3, [pc, #36]	; (8021eb4 <lv_task_del+0x38>)
 8021e8e:	2201      	movs	r2, #1
 8021e90:	701a      	strb	r2, [r3, #0]

    lv_mem_free(task);
 8021e92:	6878      	ldr	r0, [r7, #4]
 8021e94:	f7fe fee8 	bl	8020c68 <lv_mem_free>

    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
 8021e98:	4b07      	ldr	r3, [pc, #28]	; (8021eb8 <lv_task_del+0x3c>)
 8021e9a:	681b      	ldr	r3, [r3, #0]
 8021e9c:	687a      	ldr	r2, [r7, #4]
 8021e9e:	429a      	cmp	r2, r3
 8021ea0:	d102      	bne.n	8021ea8 <lv_task_del+0x2c>
 8021ea2:	4b06      	ldr	r3, [pc, #24]	; (8021ebc <lv_task_del+0x40>)
 8021ea4:	2201      	movs	r2, #1
 8021ea6:	701a      	strb	r2, [r3, #0]
}
 8021ea8:	bf00      	nop
 8021eaa:	3708      	adds	r7, #8
 8021eac:	46bd      	mov	sp, r7
 8021eae:	bd80      	pop	{r7, pc}
 8021eb0:	2000a174 	.word	0x2000a174
 8021eb4:	20012311 	.word	0x20012311
 8021eb8:	2000a1d8 	.word	0x2000a1d8
 8021ebc:	20012310 	.word	0x20012310

08021ec0 <lv_task_set_prio>:
 * Set new priority for a lv_task
 * @param task pointer to a lv_task
 * @param prio the new priority
 */
void lv_task_set_prio(lv_task_t * task, lv_task_prio_t prio)
{
 8021ec0:	b580      	push	{r7, lr}
 8021ec2:	b084      	sub	sp, #16
 8021ec4:	af00      	add	r7, sp, #0
 8021ec6:	6078      	str	r0, [r7, #4]
 8021ec8:	460b      	mov	r3, r1
 8021eca:	70fb      	strb	r3, [r7, #3]
    if(task->prio == prio) return;
 8021ecc:	687b      	ldr	r3, [r7, #4]
 8021ece:	7d1b      	ldrb	r3, [r3, #20]
 8021ed0:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8021ed4:	b2db      	uxtb	r3, r3
 8021ed6:	461a      	mov	r2, r3
 8021ed8:	78fb      	ldrb	r3, [r7, #3]
 8021eda:	429a      	cmp	r2, r3
 8021edc:	d036      	beq.n	8021f4c <lv_task_set_prio+0x8c>

    /*Find the tasks with new priority*/
    lv_task_t * i;
    _LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i) {
 8021ede:	481d      	ldr	r0, [pc, #116]	; (8021f54 <lv_task_set_prio+0x94>)
 8021ee0:	f7fe fcbc 	bl	802085c <_lv_ll_get_head>
 8021ee4:	60f8      	str	r0, [r7, #12]
 8021ee6:	e017      	b.n	8021f18 <lv_task_set_prio+0x58>
        if(i->prio <= prio) {
 8021ee8:	68fb      	ldr	r3, [r7, #12]
 8021eea:	7d1b      	ldrb	r3, [r3, #20]
 8021eec:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8021ef0:	b2db      	uxtb	r3, r3
 8021ef2:	461a      	mov	r2, r3
 8021ef4:	78fb      	ldrb	r3, [r7, #3]
 8021ef6:	429a      	cmp	r2, r3
 8021ef8:	dc09      	bgt.n	8021f0e <lv_task_set_prio+0x4e>
            if(i != task) _lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, i);
 8021efa:	68fa      	ldr	r2, [r7, #12]
 8021efc:	687b      	ldr	r3, [r7, #4]
 8021efe:	429a      	cmp	r2, r3
 8021f00:	d00e      	beq.n	8021f20 <lv_task_set_prio+0x60>
 8021f02:	68fa      	ldr	r2, [r7, #12]
 8021f04:	6879      	ldr	r1, [r7, #4]
 8021f06:	4813      	ldr	r0, [pc, #76]	; (8021f54 <lv_task_set_prio+0x94>)
 8021f08:	f7fe fd01 	bl	802090e <_lv_ll_move_before>
            break;
 8021f0c:	e008      	b.n	8021f20 <lv_task_set_prio+0x60>
    _LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i) {
 8021f0e:	68f9      	ldr	r1, [r7, #12]
 8021f10:	4810      	ldr	r0, [pc, #64]	; (8021f54 <lv_task_set_prio+0x94>)
 8021f12:	f7fe fcc9 	bl	80208a8 <_lv_ll_get_next>
 8021f16:	60f8      	str	r0, [r7, #12]
 8021f18:	68fb      	ldr	r3, [r7, #12]
 8021f1a:	2b00      	cmp	r3, #0
 8021f1c:	d1e4      	bne.n	8021ee8 <lv_task_set_prio+0x28>
 8021f1e:	e000      	b.n	8021f22 <lv_task_set_prio+0x62>
            break;
 8021f20:	bf00      	nop
        }
    }

    /*There was no such a low priority so far then add the node to the tail*/
    if(i == NULL) {
 8021f22:	68fb      	ldr	r3, [r7, #12]
 8021f24:	2b00      	cmp	r3, #0
 8021f26:	d104      	bne.n	8021f32 <lv_task_set_prio+0x72>
        _lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, NULL);
 8021f28:	2200      	movs	r2, #0
 8021f2a:	6879      	ldr	r1, [r7, #4]
 8021f2c:	4809      	ldr	r0, [pc, #36]	; (8021f54 <lv_task_set_prio+0x94>)
 8021f2e:	f7fe fcee 	bl	802090e <_lv_ll_move_before>
    }
    task_list_changed = true;
 8021f32:	4b09      	ldr	r3, [pc, #36]	; (8021f58 <lv_task_set_prio+0x98>)
 8021f34:	2201      	movs	r2, #1
 8021f36:	701a      	strb	r2, [r3, #0]

    task->prio = prio;
 8021f38:	78fb      	ldrb	r3, [r7, #3]
 8021f3a:	f003 0307 	and.w	r3, r3, #7
 8021f3e:	b2d9      	uxtb	r1, r3
 8021f40:	687a      	ldr	r2, [r7, #4]
 8021f42:	7d13      	ldrb	r3, [r2, #20]
 8021f44:	f361 0302 	bfi	r3, r1, #0, #3
 8021f48:	7513      	strb	r3, [r2, #20]
 8021f4a:	e000      	b.n	8021f4e <lv_task_set_prio+0x8e>
    if(task->prio == prio) return;
 8021f4c:	bf00      	nop
}
 8021f4e:	3710      	adds	r7, #16
 8021f50:	46bd      	mov	sp, r7
 8021f52:	bd80      	pop	{r7, pc}
 8021f54:	2000a174 	.word	0x2000a174
 8021f58:	20012311 	.word	0x20012311

08021f5c <lv_task_set_period>:
 * Set new period for a lv_task
 * @param task pointer to a lv_task
 * @param period the new period
 */
void lv_task_set_period(lv_task_t * task, uint32_t period)
{
 8021f5c:	b480      	push	{r7}
 8021f5e:	b083      	sub	sp, #12
 8021f60:	af00      	add	r7, sp, #0
 8021f62:	6078      	str	r0, [r7, #4]
 8021f64:	6039      	str	r1, [r7, #0]
    task->period = period;
 8021f66:	687b      	ldr	r3, [r7, #4]
 8021f68:	683a      	ldr	r2, [r7, #0]
 8021f6a:	601a      	str	r2, [r3, #0]
}
 8021f6c:	bf00      	nop
 8021f6e:	370c      	adds	r7, #12
 8021f70:	46bd      	mov	sp, r7
 8021f72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021f76:	4770      	bx	lr

08021f78 <lv_task_ready>:
/**
 * Make a lv_task ready. It will not wait its period.
 * @param task pointer to a lv_task.
 */
void lv_task_ready(lv_task_t * task)
{
 8021f78:	b580      	push	{r7, lr}
 8021f7a:	b082      	sub	sp, #8
 8021f7c:	af00      	add	r7, sp, #0
 8021f7e:	6078      	str	r0, [r7, #4]
    task->last_run = lv_tick_get() - task->period - 1;
 8021f80:	f7fc feb8 	bl	801ecf4 <lv_tick_get>
 8021f84:	4602      	mov	r2, r0
 8021f86:	687b      	ldr	r3, [r7, #4]
 8021f88:	681b      	ldr	r3, [r3, #0]
 8021f8a:	1ad3      	subs	r3, r2, r3
 8021f8c:	1e5a      	subs	r2, r3, #1
 8021f8e:	687b      	ldr	r3, [r7, #4]
 8021f90:	605a      	str	r2, [r3, #4]
}
 8021f92:	bf00      	nop
 8021f94:	3708      	adds	r7, #8
 8021f96:	46bd      	mov	sp, r7
 8021f98:	bd80      	pop	{r7, pc}
	...

08021f9c <lv_task_enable>:
/**
 * Enable or disable the whole lv_task handling
 * @param en: true: lv_task handling is running, false: lv_task handling is suspended
 */
void lv_task_enable(bool en)
{
 8021f9c:	b480      	push	{r7}
 8021f9e:	b083      	sub	sp, #12
 8021fa0:	af00      	add	r7, sp, #0
 8021fa2:	4603      	mov	r3, r0
 8021fa4:	71fb      	strb	r3, [r7, #7]
    lv_task_run = en;
 8021fa6:	4a04      	ldr	r2, [pc, #16]	; (8021fb8 <lv_task_enable+0x1c>)
 8021fa8:	79fb      	ldrb	r3, [r7, #7]
 8021faa:	7013      	strb	r3, [r2, #0]
}
 8021fac:	bf00      	nop
 8021fae:	370c      	adds	r7, #12
 8021fb0:	46bd      	mov	sp, r7
 8021fb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021fb6:	4770      	bx	lr
 8021fb8:	2001230e 	.word	0x2001230e

08021fbc <lv_task_exec>:
 * Execute task if its the priority is appropriate
 * @param task pointer to lv_task
 * @return true: execute, false: not executed
 */
static bool lv_task_exec(lv_task_t * task)
{
 8021fbc:	b580      	push	{r7, lr}
 8021fbe:	b084      	sub	sp, #16
 8021fc0:	af00      	add	r7, sp, #0
 8021fc2:	6078      	str	r0, [r7, #4]
    bool exec = false;
 8021fc4:	2300      	movs	r3, #0
 8021fc6:	73fb      	strb	r3, [r7, #15]

    if(lv_task_time_remaining(task) == 0) {
 8021fc8:	6878      	ldr	r0, [r7, #4]
 8021fca:	f000 f839 	bl	8022040 <lv_task_time_remaining>
 8021fce:	4603      	mov	r3, r0
 8021fd0:	2b00      	cmp	r3, #0
 8021fd2:	d12b      	bne.n	802202c <lv_task_exec+0x70>
        task->last_run = lv_tick_get();
 8021fd4:	f7fc fe8e 	bl	801ecf4 <lv_tick_get>
 8021fd8:	4602      	mov	r2, r0
 8021fda:	687b      	ldr	r3, [r7, #4]
 8021fdc:	605a      	str	r2, [r3, #4]
        task_deleted   = false;
 8021fde:	4b16      	ldr	r3, [pc, #88]	; (8022038 <lv_task_exec+0x7c>)
 8021fe0:	2200      	movs	r2, #0
 8021fe2:	701a      	strb	r2, [r3, #0]
        task_created   = false;
 8021fe4:	4b15      	ldr	r3, [pc, #84]	; (802203c <lv_task_exec+0x80>)
 8021fe6:	2200      	movs	r2, #0
 8021fe8:	701a      	strb	r2, [r3, #0]
        if(task->task_cb) task->task_cb(task);
 8021fea:	687b      	ldr	r3, [r7, #4]
 8021fec:	689b      	ldr	r3, [r3, #8]
 8021fee:	2b00      	cmp	r3, #0
 8021ff0:	d003      	beq.n	8021ffa <lv_task_exec+0x3e>
 8021ff2:	687b      	ldr	r3, [r7, #4]
 8021ff4:	689b      	ldr	r3, [r3, #8]
 8021ff6:	6878      	ldr	r0, [r7, #4]
 8021ff8:	4798      	blx	r3

        /*Delete if it was a one shot lv_task*/
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
 8021ffa:	4b0f      	ldr	r3, [pc, #60]	; (8022038 <lv_task_exec+0x7c>)
 8021ffc:	781b      	ldrb	r3, [r3, #0]
 8021ffe:	f083 0301 	eor.w	r3, r3, #1
 8022002:	b2db      	uxtb	r3, r3
 8022004:	2b00      	cmp	r3, #0
 8022006:	d00f      	beq.n	8022028 <lv_task_exec+0x6c>
            if(task->repeat_count > 0) {
 8022008:	687b      	ldr	r3, [r7, #4]
 802200a:	691b      	ldr	r3, [r3, #16]
 802200c:	2b00      	cmp	r3, #0
 802200e:	dd04      	ble.n	802201a <lv_task_exec+0x5e>
                task->repeat_count--;
 8022010:	687b      	ldr	r3, [r7, #4]
 8022012:	691b      	ldr	r3, [r3, #16]
 8022014:	1e5a      	subs	r2, r3, #1
 8022016:	687b      	ldr	r3, [r7, #4]
 8022018:	611a      	str	r2, [r3, #16]
            }
            if(task->repeat_count == 0) {
 802201a:	687b      	ldr	r3, [r7, #4]
 802201c:	691b      	ldr	r3, [r3, #16]
 802201e:	2b00      	cmp	r3, #0
 8022020:	d102      	bne.n	8022028 <lv_task_exec+0x6c>
                lv_task_del(task);
 8022022:	6878      	ldr	r0, [r7, #4]
 8022024:	f7ff ff2a 	bl	8021e7c <lv_task_del>
            }
        }
        exec = true;
 8022028:	2301      	movs	r3, #1
 802202a:	73fb      	strb	r3, [r7, #15]
    }

    return exec;
 802202c:	7bfb      	ldrb	r3, [r7, #15]
}
 802202e:	4618      	mov	r0, r3
 8022030:	3710      	adds	r7, #16
 8022032:	46bd      	mov	sp, r7
 8022034:	bd80      	pop	{r7, pc}
 8022036:	bf00      	nop
 8022038:	20012310 	.word	0x20012310
 802203c:	20012312 	.word	0x20012312

08022040 <lv_task_time_remaining>:
 * Find out how much time remains before a task must be run.
 * @param task pointer to lv_task
 * @return the time remaining, or 0 if it needs to be run again
 */
static uint32_t lv_task_time_remaining(lv_task_t * task)
{
 8022040:	b580      	push	{r7, lr}
 8022042:	b084      	sub	sp, #16
 8022044:	af00      	add	r7, sp, #0
 8022046:	6078      	str	r0, [r7, #4]
    /*Check if at least 'period' time elapsed*/
    uint32_t elp = lv_tick_elaps(task->last_run);
 8022048:	687b      	ldr	r3, [r7, #4]
 802204a:	685b      	ldr	r3, [r3, #4]
 802204c:	4618      	mov	r0, r3
 802204e:	f7fc fe6b 	bl	801ed28 <lv_tick_elaps>
 8022052:	60f8      	str	r0, [r7, #12]
    if(elp >= task->period)
 8022054:	687b      	ldr	r3, [r7, #4]
 8022056:	681b      	ldr	r3, [r3, #0]
 8022058:	68fa      	ldr	r2, [r7, #12]
 802205a:	429a      	cmp	r2, r3
 802205c:	d301      	bcc.n	8022062 <lv_task_time_remaining+0x22>
        return 0;
 802205e:	2300      	movs	r3, #0
 8022060:	e003      	b.n	802206a <lv_task_time_remaining+0x2a>
    return task->period - elp;
 8022062:	687b      	ldr	r3, [r7, #4]
 8022064:	681a      	ldr	r2, [r3, #0]
 8022066:	68fb      	ldr	r3, [r7, #12]
 8022068:	1ad3      	subs	r3, r2, r3
}
 802206a:	4618      	mov	r0, r3
 802206c:	3710      	adds	r7, #16
 802206e:	46bd      	mov	sp, r7
 8022070:	bd80      	pop	{r7, pc}

08022072 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline lv_coord_t lv_font_get_line_height(const lv_font_t * font_p)
{
 8022072:	b480      	push	{r7}
 8022074:	b083      	sub	sp, #12
 8022076:	af00      	add	r7, sp, #0
 8022078:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 802207a:	687b      	ldr	r3, [r7, #4]
 802207c:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
}
 8022080:	4618      	mov	r0, r3
 8022082:	370c      	adds	r7, #12
 8022084:	46bd      	mov	sp, r7
 8022086:	f85d 7b04 	ldr.w	r7, [sp], #4
 802208a:	4770      	bx	lr

0802208c <_lv_txt_get_size>:
 * @param max_width max with of the text (break the lines to fit this size) Set CORD_MAX to avoid
 * line breaks
 */
void _lv_txt_get_size(lv_point_t * size_res, const char * text, const lv_font_t * font, lv_coord_t letter_space,
                      lv_coord_t line_space, lv_coord_t max_width, lv_txt_flag_t flag)
{
 802208c:	b580      	push	{r7, lr}
 802208e:	b08a      	sub	sp, #40	; 0x28
 8022090:	af02      	add	r7, sp, #8
 8022092:	60f8      	str	r0, [r7, #12]
 8022094:	60b9      	str	r1, [r7, #8]
 8022096:	607a      	str	r2, [r7, #4]
 8022098:	807b      	strh	r3, [r7, #2]
    size_res->x = 0;
 802209a:	68fb      	ldr	r3, [r7, #12]
 802209c:	2200      	movs	r2, #0
 802209e:	801a      	strh	r2, [r3, #0]
    size_res->y = 0;
 80220a0:	68fb      	ldr	r3, [r7, #12]
 80220a2:	2200      	movs	r2, #0
 80220a4:	805a      	strh	r2, [r3, #2]

    if(text == NULL) return;
 80220a6:	68bb      	ldr	r3, [r7, #8]
 80220a8:	2b00      	cmp	r3, #0
 80220aa:	f000 80a0 	beq.w	80221ee <_lv_txt_get_size+0x162>
    if(font == NULL) return;
 80220ae:	687b      	ldr	r3, [r7, #4]
 80220b0:	2b00      	cmp	r3, #0
 80220b2:	f000 809e 	beq.w	80221f2 <_lv_txt_get_size+0x166>

    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 80220b6:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 80220ba:	f003 0302 	and.w	r3, r3, #2
 80220be:	2b00      	cmp	r3, #0
 80220c0:	d002      	beq.n	80220c8 <_lv_txt_get_size+0x3c>
 80220c2:	f647 4318 	movw	r3, #31768	; 0x7c18
 80220c6:	85bb      	strh	r3, [r7, #44]	; 0x2c

    uint32_t line_start     = 0;
 80220c8:	2300      	movs	r3, #0
 80220ca:	61fb      	str	r3, [r7, #28]
    uint32_t new_line_start = 0;
 80220cc:	2300      	movs	r3, #0
 80220ce:	61bb      	str	r3, [r7, #24]
    uint16_t letter_height = lv_font_get_line_height(font);
 80220d0:	6878      	ldr	r0, [r7, #4]
 80220d2:	f7ff ffce 	bl	8022072 <lv_font_get_line_height>
 80220d6:	4603      	mov	r3, r0
 80220d8:	82fb      	strh	r3, [r7, #22]

    /*Calc. the height and longest line*/
    while(text[line_start] != '\0') {
 80220da:	e04f      	b.n	802217c <_lv_txt_get_size+0xf0>
        new_line_start += _lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
 80220dc:	68ba      	ldr	r2, [r7, #8]
 80220de:	69fb      	ldr	r3, [r7, #28]
 80220e0:	18d0      	adds	r0, r2, r3
 80220e2:	f9b7 102c 	ldrsh.w	r1, [r7, #44]	; 0x2c
 80220e6:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 80220ea:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 80220ee:	9300      	str	r3, [sp, #0]
 80220f0:	460b      	mov	r3, r1
 80220f2:	6879      	ldr	r1, [r7, #4]
 80220f4:	f000 f964 	bl	80223c0 <_lv_txt_get_next_line>
 80220f8:	4602      	mov	r2, r0
 80220fa:	69bb      	ldr	r3, [r7, #24]
 80220fc:	4413      	add	r3, r2
 80220fe:	61bb      	str	r3, [r7, #24]

        if((unsigned long)size_res->y + (unsigned long)letter_height + (unsigned long)line_space > LV_MAX_OF(lv_coord_t)) {
 8022100:	68fb      	ldr	r3, [r7, #12]
 8022102:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8022106:	461a      	mov	r2, r3
 8022108:	8afb      	ldrh	r3, [r7, #22]
 802210a:	441a      	add	r2, r3
 802210c:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8022110:	4413      	add	r3, r2
 8022112:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8022116:	d26e      	bcs.n	80221f6 <_lv_txt_get_size+0x16a>
            LV_LOG_WARN("lv_txt_get_size: integer overflow while calculating text height");
            return;
        }
        else {
            size_res->y += letter_height;
 8022118:	68fb      	ldr	r3, [r7, #12]
 802211a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 802211e:	b29a      	uxth	r2, r3
 8022120:	8afb      	ldrh	r3, [r7, #22]
 8022122:	4413      	add	r3, r2
 8022124:	b29b      	uxth	r3, r3
 8022126:	b21a      	sxth	r2, r3
 8022128:	68fb      	ldr	r3, [r7, #12]
 802212a:	805a      	strh	r2, [r3, #2]
            size_res->y += line_space;
 802212c:	68fb      	ldr	r3, [r7, #12]
 802212e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8022132:	b29a      	uxth	r2, r3
 8022134:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8022136:	4413      	add	r3, r2
 8022138:	b29b      	uxth	r3, r3
 802213a:	b21a      	sxth	r2, r3
 802213c:	68fb      	ldr	r3, [r7, #12]
 802213e:	805a      	strh	r2, [r3, #2]
        }

        /*Calculate the the longest line*/
        lv_coord_t act_line_length = _lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space,
 8022140:	68ba      	ldr	r2, [r7, #8]
 8022142:	69fb      	ldr	r3, [r7, #28]
 8022144:	18d0      	adds	r0, r2, r3
 8022146:	69ba      	ldr	r2, [r7, #24]
 8022148:	69fb      	ldr	r3, [r7, #28]
 802214a:	1ad1      	subs	r1, r2, r3
 802214c:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 8022150:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8022154:	9300      	str	r3, [sp, #0]
 8022156:	4613      	mov	r3, r2
 8022158:	687a      	ldr	r2, [r7, #4]
 802215a:	f000 f9ef 	bl	802253c <_lv_txt_get_width>
 802215e:	4603      	mov	r3, r0
 8022160:	82bb      	strh	r3, [r7, #20]
                                                       flag);

        size_res->x = LV_MATH_MAX(act_line_length, size_res->x);
 8022162:	68fb      	ldr	r3, [r7, #12]
 8022164:	f9b3 3000 	ldrsh.w	r3, [r3]
 8022168:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 802216c:	4293      	cmp	r3, r2
 802216e:	bfb8      	it	lt
 8022170:	4613      	movlt	r3, r2
 8022172:	b21a      	sxth	r2, r3
 8022174:	68fb      	ldr	r3, [r7, #12]
 8022176:	801a      	strh	r2, [r3, #0]
        line_start  = new_line_start;
 8022178:	69bb      	ldr	r3, [r7, #24]
 802217a:	61fb      	str	r3, [r7, #28]
    while(text[line_start] != '\0') {
 802217c:	68ba      	ldr	r2, [r7, #8]
 802217e:	69fb      	ldr	r3, [r7, #28]
 8022180:	4413      	add	r3, r2
 8022182:	781b      	ldrb	r3, [r3, #0]
 8022184:	2b00      	cmp	r3, #0
 8022186:	d1a9      	bne.n	80220dc <_lv_txt_get_size+0x50>
    }

    /*Make the text one line taller if the last character is '\n' or '\r'*/
    if((line_start != 0) && (text[line_start - 1] == '\n' || text[line_start - 1] == '\r')) {
 8022188:	69fb      	ldr	r3, [r7, #28]
 802218a:	2b00      	cmp	r3, #0
 802218c:	d01a      	beq.n	80221c4 <_lv_txt_get_size+0x138>
 802218e:	69fb      	ldr	r3, [r7, #28]
 8022190:	3b01      	subs	r3, #1
 8022192:	68ba      	ldr	r2, [r7, #8]
 8022194:	4413      	add	r3, r2
 8022196:	781b      	ldrb	r3, [r3, #0]
 8022198:	2b0a      	cmp	r3, #10
 802219a:	d006      	beq.n	80221aa <_lv_txt_get_size+0x11e>
 802219c:	69fb      	ldr	r3, [r7, #28]
 802219e:	3b01      	subs	r3, #1
 80221a0:	68ba      	ldr	r2, [r7, #8]
 80221a2:	4413      	add	r3, r2
 80221a4:	781b      	ldrb	r3, [r3, #0]
 80221a6:	2b0d      	cmp	r3, #13
 80221a8:	d10c      	bne.n	80221c4 <_lv_txt_get_size+0x138>
        size_res->y += letter_height + line_space;
 80221aa:	68fb      	ldr	r3, [r7, #12]
 80221ac:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80221b0:	b29a      	uxth	r2, r3
 80221b2:	8d39      	ldrh	r1, [r7, #40]	; 0x28
 80221b4:	8afb      	ldrh	r3, [r7, #22]
 80221b6:	440b      	add	r3, r1
 80221b8:	b29b      	uxth	r3, r3
 80221ba:	4413      	add	r3, r2
 80221bc:	b29b      	uxth	r3, r3
 80221be:	b21a      	sxth	r2, r3
 80221c0:	68fb      	ldr	r3, [r7, #12]
 80221c2:	805a      	strh	r2, [r3, #2]
    }

    /*Correction with the last line space or set the height manually if the text is empty*/
    if(size_res->y == 0)
 80221c4:	68fb      	ldr	r3, [r7, #12]
 80221c6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80221ca:	2b00      	cmp	r3, #0
 80221cc:	d104      	bne.n	80221d8 <_lv_txt_get_size+0x14c>
        size_res->y = letter_height;
 80221ce:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 80221d2:	68fb      	ldr	r3, [r7, #12]
 80221d4:	805a      	strh	r2, [r3, #2]
 80221d6:	e00f      	b.n	80221f8 <_lv_txt_get_size+0x16c>
    else
        size_res->y -= line_space;
 80221d8:	68fb      	ldr	r3, [r7, #12]
 80221da:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80221de:	b29a      	uxth	r2, r3
 80221e0:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80221e2:	1ad3      	subs	r3, r2, r3
 80221e4:	b29b      	uxth	r3, r3
 80221e6:	b21a      	sxth	r2, r3
 80221e8:	68fb      	ldr	r3, [r7, #12]
 80221ea:	805a      	strh	r2, [r3, #2]
 80221ec:	e004      	b.n	80221f8 <_lv_txt_get_size+0x16c>
    if(text == NULL) return;
 80221ee:	bf00      	nop
 80221f0:	e002      	b.n	80221f8 <_lv_txt_get_size+0x16c>
    if(font == NULL) return;
 80221f2:	bf00      	nop
 80221f4:	e000      	b.n	80221f8 <_lv_txt_get_size+0x16c>
            return;
 80221f6:	bf00      	nop
}
 80221f8:	3720      	adds	r7, #32
 80221fa:	46bd      	mov	sp, r7
 80221fc:	bd80      	pop	{r7, pc}
	...

08022200 <lv_txt_get_next_word>:
 * @return the index of the first char of the next word (in byte index not letter index. With UTF-8 they are different)
 */
static uint32_t lv_txt_get_next_word(const char * txt, const lv_font_t * font,
                                     lv_coord_t letter_space, lv_coord_t max_width,
                                     lv_txt_flag_t flag, uint32_t * word_w_ptr, lv_txt_cmd_state_t * cmd_state, bool force)
{
 8022200:	b580      	push	{r7, lr}
 8022202:	b08e      	sub	sp, #56	; 0x38
 8022204:	af00      	add	r7, sp, #0
 8022206:	60f8      	str	r0, [r7, #12]
 8022208:	60b9      	str	r1, [r7, #8]
 802220a:	4611      	mov	r1, r2
 802220c:	461a      	mov	r2, r3
 802220e:	460b      	mov	r3, r1
 8022210:	80fb      	strh	r3, [r7, #6]
 8022212:	4613      	mov	r3, r2
 8022214:	80bb      	strh	r3, [r7, #4]
    if(txt == NULL || txt[0] == '\0') return 0;
 8022216:	68fb      	ldr	r3, [r7, #12]
 8022218:	2b00      	cmp	r3, #0
 802221a:	d003      	beq.n	8022224 <lv_txt_get_next_word+0x24>
 802221c:	68fb      	ldr	r3, [r7, #12]
 802221e:	781b      	ldrb	r3, [r3, #0]
 8022220:	2b00      	cmp	r3, #0
 8022222:	d101      	bne.n	8022228 <lv_txt_get_next_word+0x28>
 8022224:	2300      	movs	r3, #0
 8022226:	e0c4      	b.n	80223b2 <lv_txt_get_next_word+0x1b2>
    if(font == NULL) return 0;
 8022228:	68bb      	ldr	r3, [r7, #8]
 802222a:	2b00      	cmp	r3, #0
 802222c:	d101      	bne.n	8022232 <lv_txt_get_next_word+0x32>
 802222e:	2300      	movs	r3, #0
 8022230:	e0bf      	b.n	80223b2 <lv_txt_get_next_word+0x1b2>

    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 8022232:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 8022236:	f003 0302 	and.w	r3, r3, #2
 802223a:	2b00      	cmp	r3, #0
 802223c:	d002      	beq.n	8022244 <lv_txt_get_next_word+0x44>
 802223e:	f647 4318 	movw	r3, #31768	; 0x7c18
 8022242:	80bb      	strh	r3, [r7, #4]

    uint32_t i = 0, i_next = 0, i_next_next = 0;  /* Iterating index into txt */
 8022244:	2300      	movs	r3, #0
 8022246:	637b      	str	r3, [r7, #52]	; 0x34
 8022248:	2300      	movs	r3, #0
 802224a:	617b      	str	r3, [r7, #20]
 802224c:	2300      	movs	r3, #0
 802224e:	613b      	str	r3, [r7, #16]
    uint32_t letter = 0;      /* Letter at i */
 8022250:	2300      	movs	r3, #0
 8022252:	633b      	str	r3, [r7, #48]	; 0x30
    uint32_t letter_next = 0; /* Letter at i_next */
 8022254:	2300      	movs	r3, #0
 8022256:	62fb      	str	r3, [r7, #44]	; 0x2c
    lv_coord_t letter_w;
    lv_coord_t cur_w = 0;  /* Pixel Width of transversed string */
 8022258:	2300      	movs	r3, #0
 802225a:	857b      	strh	r3, [r7, #42]	; 0x2a
    uint32_t word_len = 0;   /* Number of characters in the transversed word */
 802225c:	2300      	movs	r3, #0
 802225e:	627b      	str	r3, [r7, #36]	; 0x24
    uint32_t break_index = NO_BREAK_FOUND; /* only used for "long" words */
 8022260:	f04f 33ff 	mov.w	r3, #4294967295
 8022264:	623b      	str	r3, [r7, #32]
    uint32_t break_letter_count = 0; /* Number of characters up to the long word break point */
 8022266:	2300      	movs	r3, #0
 8022268:	61fb      	str	r3, [r7, #28]

    letter = _lv_txt_encoded_next(txt, &i_next);
 802226a:	4b54      	ldr	r3, [pc, #336]	; (80223bc <lv_txt_get_next_word+0x1bc>)
 802226c:	681b      	ldr	r3, [r3, #0]
 802226e:	f107 0214 	add.w	r2, r7, #20
 8022272:	4611      	mov	r1, r2
 8022274:	68f8      	ldr	r0, [r7, #12]
 8022276:	4798      	blx	r3
 8022278:	6338      	str	r0, [r7, #48]	; 0x30
    i_next_next = i_next;
 802227a:	697b      	ldr	r3, [r7, #20]
 802227c:	613b      	str	r3, [r7, #16]

    /* Obtain the full word, regardless if it fits or not in max_width */
    while(txt[i] != '\0') {
 802227e:	e074      	b.n	802236a <lv_txt_get_next_word+0x16a>
        letter_next = _lv_txt_encoded_next(txt, &i_next_next);
 8022280:	4b4e      	ldr	r3, [pc, #312]	; (80223bc <lv_txt_get_next_word+0x1bc>)
 8022282:	681b      	ldr	r3, [r3, #0]
 8022284:	f107 0210 	add.w	r2, r7, #16
 8022288:	4611      	mov	r1, r2
 802228a:	68f8      	ldr	r0, [r7, #12]
 802228c:	4798      	blx	r3
 802228e:	62f8      	str	r0, [r7, #44]	; 0x2c
        word_len++;
 8022290:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022292:	3301      	adds	r3, #1
 8022294:	627b      	str	r3, [r7, #36]	; 0x24

        /*Handle the recolor command*/
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 8022296:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
 802229a:	f003 0301 	and.w	r3, r3, #1
 802229e:	2b00      	cmp	r3, #0
 80222a0:	d00d      	beq.n	80222be <lv_txt_get_next_word+0xbe>
            if(_lv_txt_is_cmd(cmd_state, letter) != false) {
 80222a2:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80222a4:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 80222a6:	f000 f9af 	bl	8022608 <_lv_txt_is_cmd>
 80222aa:	4603      	mov	r3, r0
 80222ac:	2b00      	cmp	r3, #0
 80222ae:	d006      	beq.n	80222be <lv_txt_get_next_word+0xbe>
                i = i_next;
 80222b0:	697b      	ldr	r3, [r7, #20]
 80222b2:	637b      	str	r3, [r7, #52]	; 0x34
                i_next = i_next_next;
 80222b4:	693b      	ldr	r3, [r7, #16]
 80222b6:	617b      	str	r3, [r7, #20]
                letter = letter_next;
 80222b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80222ba:	633b      	str	r3, [r7, #48]	; 0x30
                continue;   /*Skip the letter is it is part of a command*/
 80222bc:	e055      	b.n	802236a <lv_txt_get_next_word+0x16a>
            }
        }

        letter_w = lv_font_get_glyph_width(font, letter, letter_next);
 80222be:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80222c0:	6b39      	ldr	r1, [r7, #48]	; 0x30
 80222c2:	68b8      	ldr	r0, [r7, #8]
 80222c4:	f7fb fc02 	bl	801dacc <lv_font_get_glyph_width>
 80222c8:	4603      	mov	r3, r0
 80222ca:	837b      	strh	r3, [r7, #26]
        cur_w += letter_w;
 80222cc:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 80222ce:	8b7b      	ldrh	r3, [r7, #26]
 80222d0:	4413      	add	r3, r2
 80222d2:	b29b      	uxth	r3, r3
 80222d4:	857b      	strh	r3, [r7, #42]	; 0x2a

        if(letter_w > 0) {
 80222d6:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80222da:	2b00      	cmp	r3, #0
 80222dc:	dd04      	ble.n	80222e8 <lv_txt_get_next_word+0xe8>
            cur_w += letter_space;
 80222de:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 80222e0:	88fb      	ldrh	r3, [r7, #6]
 80222e2:	4413      	add	r3, r2
 80222e4:	b29b      	uxth	r3, r3
 80222e6:	857b      	strh	r3, [r7, #42]	; 0x2a
        }

        /* Test if this character fits within max_width */
        if(break_index == NO_BREAK_FOUND && (cur_w - letter_space) > max_width) {
 80222e8:	6a3b      	ldr	r3, [r7, #32]
 80222ea:	f1b3 3fff 	cmp.w	r3, #4294967295
 80222ee:	d10d      	bne.n	802230c <lv_txt_get_next_word+0x10c>
 80222f0:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 80222f4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80222f8:	1ad2      	subs	r2, r2, r3
 80222fa:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 80222fe:	429a      	cmp	r2, r3
 8022300:	dd04      	ble.n	802230c <lv_txt_get_next_word+0x10c>
            break_index = i;
 8022302:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8022304:	623b      	str	r3, [r7, #32]
            break_letter_count = word_len - 1;
 8022306:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022308:	3b01      	subs	r3, #1
 802230a:	61fb      	str	r3, [r7, #28]
            /* break_index is now pointing at the character that doesn't fit */
        }

        /*Check for new line chars and breakchars*/
        if(letter == '\n' || letter == '\r' || is_break_char(letter)) {
 802230c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802230e:	2b0a      	cmp	r3, #10
 8022310:	d008      	beq.n	8022324 <lv_txt_get_next_word+0x124>
 8022312:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022314:	2b0d      	cmp	r3, #13
 8022316:	d005      	beq.n	8022324 <lv_txt_get_next_word+0x124>
 8022318:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802231a:	f000 fb9d 	bl	8022a58 <is_break_char>
 802231e:	4603      	mov	r3, r0
 8022320:	2b00      	cmp	r3, #0
 8022322:	d011      	beq.n	8022348 <lv_txt_get_next_word+0x148>
            /* Update the output width on the first character if it fits.
             * Must do this here incase first letter is a break character. */
            if(i == 0 && break_index == NO_BREAK_FOUND && word_w_ptr != NULL) *word_w_ptr = cur_w;
 8022324:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8022326:	2b00      	cmp	r3, #0
 8022328:	d10a      	bne.n	8022340 <lv_txt_get_next_word+0x140>
 802232a:	6a3b      	ldr	r3, [r7, #32]
 802232c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8022330:	d106      	bne.n	8022340 <lv_txt_get_next_word+0x140>
 8022332:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8022334:	2b00      	cmp	r3, #0
 8022336:	d003      	beq.n	8022340 <lv_txt_get_next_word+0x140>
 8022338:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 802233c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802233e:	601a      	str	r2, [r3, #0]
            word_len--;
 8022340:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022342:	3b01      	subs	r3, #1
 8022344:	627b      	str	r3, [r7, #36]	; 0x24
            break;
 8022346:	e016      	b.n	8022376 <lv_txt_get_next_word+0x176>
        }

        /* Update the output width */
        if(word_w_ptr != NULL && break_index == NO_BREAK_FOUND) *word_w_ptr = cur_w;
 8022348:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802234a:	2b00      	cmp	r3, #0
 802234c:	d007      	beq.n	802235e <lv_txt_get_next_word+0x15e>
 802234e:	6a3b      	ldr	r3, [r7, #32]
 8022350:	f1b3 3fff 	cmp.w	r3, #4294967295
 8022354:	d103      	bne.n	802235e <lv_txt_get_next_word+0x15e>
 8022356:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 802235a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802235c:	601a      	str	r2, [r3, #0]


        i = i_next;
 802235e:	697b      	ldr	r3, [r7, #20]
 8022360:	637b      	str	r3, [r7, #52]	; 0x34
        i_next = i_next_next;
 8022362:	693b      	ldr	r3, [r7, #16]
 8022364:	617b      	str	r3, [r7, #20]
        letter = letter_next;
 8022366:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8022368:	633b      	str	r3, [r7, #48]	; 0x30
    while(txt[i] != '\0') {
 802236a:	68fa      	ldr	r2, [r7, #12]
 802236c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802236e:	4413      	add	r3, r2
 8022370:	781b      	ldrb	r3, [r3, #0]
 8022372:	2b00      	cmp	r3, #0
 8022374:	d184      	bne.n	8022280 <lv_txt_get_next_word+0x80>
    }

    /* Entire Word fits in the provided space */
    if(break_index == NO_BREAK_FOUND) {
 8022376:	6a3b      	ldr	r3, [r7, #32]
 8022378:	f1b3 3fff 	cmp.w	r3, #4294967295
 802237c:	d10c      	bne.n	8022398 <lv_txt_get_next_word+0x198>
        if(word_len == 0 || (letter == '\r' && letter_next == '\n')) i = i_next;
 802237e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022380:	2b00      	cmp	r3, #0
 8022382:	d005      	beq.n	8022390 <lv_txt_get_next_word+0x190>
 8022384:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022386:	2b0d      	cmp	r3, #13
 8022388:	d104      	bne.n	8022394 <lv_txt_get_next_word+0x194>
 802238a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802238c:	2b0a      	cmp	r3, #10
 802238e:	d101      	bne.n	8022394 <lv_txt_get_next_word+0x194>
 8022390:	697b      	ldr	r3, [r7, #20]
 8022392:	637b      	str	r3, [r7, #52]	; 0x34
        return i;
 8022394:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8022396:	e00c      	b.n	80223b2 <lv_txt_get_next_word+0x1b2>
            // However, in current usage, this doesn't impact anything.
        }
    }
    return i;
#else
    if(force) return break_index;
 8022398:	f897 304c 	ldrb.w	r3, [r7, #76]	; 0x4c
 802239c:	2b00      	cmp	r3, #0
 802239e:	d001      	beq.n	80223a4 <lv_txt_get_next_word+0x1a4>
 80223a0:	6a3b      	ldr	r3, [r7, #32]
 80223a2:	e006      	b.n	80223b2 <lv_txt_get_next_word+0x1b2>
    if(word_w_ptr != NULL) *word_w_ptr = 0; /* Return no word */
 80223a4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80223a6:	2b00      	cmp	r3, #0
 80223a8:	d002      	beq.n	80223b0 <lv_txt_get_next_word+0x1b0>
 80223aa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80223ac:	2200      	movs	r2, #0
 80223ae:	601a      	str	r2, [r3, #0]
    (void) break_letter_count;
    return 0;
 80223b0:	2300      	movs	r3, #0
#endif
}
 80223b2:	4618      	mov	r0, r3
 80223b4:	3738      	adds	r7, #56	; 0x38
 80223b6:	46bd      	mov	sp, r7
 80223b8:	bd80      	pop	{r7, pc}
 80223ba:	bf00      	nop
 80223bc:	20000204 	.word	0x20000204

080223c0 <_lv_txt_get_next_line>:
 * @param flags settings for the text from 'txt_flag_type' enum
 * @return the index of the first char of the new line (in byte index not letter index. With UTF-8 they are different)
 */
uint32_t _lv_txt_get_next_line(const char * txt, const lv_font_t * font,
                               lv_coord_t letter_space, lv_coord_t max_width, lv_txt_flag_t flag)
{
 80223c0:	b580      	push	{r7, lr}
 80223c2:	b08e      	sub	sp, #56	; 0x38
 80223c4:	af04      	add	r7, sp, #16
 80223c6:	60f8      	str	r0, [r7, #12]
 80223c8:	60b9      	str	r1, [r7, #8]
 80223ca:	4611      	mov	r1, r2
 80223cc:	461a      	mov	r2, r3
 80223ce:	460b      	mov	r3, r1
 80223d0:	80fb      	strh	r3, [r7, #6]
 80223d2:	4613      	mov	r3, r2
 80223d4:	80bb      	strh	r3, [r7, #4]
    if(txt == NULL) return 0;
 80223d6:	68fb      	ldr	r3, [r7, #12]
 80223d8:	2b00      	cmp	r3, #0
 80223da:	d101      	bne.n	80223e0 <_lv_txt_get_next_line+0x20>
 80223dc:	2300      	movs	r3, #0
 80223de:	e0a6      	b.n	802252e <_lv_txt_get_next_line+0x16e>
    if(font == NULL) return 0;
 80223e0:	68bb      	ldr	r3, [r7, #8]
 80223e2:	2b00      	cmp	r3, #0
 80223e4:	d101      	bne.n	80223ea <_lv_txt_get_next_line+0x2a>
 80223e6:	2300      	movs	r3, #0
 80223e8:	e0a1      	b.n	802252e <_lv_txt_get_next_line+0x16e>

    /* If max_width doesn't mater simply find the new line character
     * without thinking about word wrapping*/
    if((flag & LV_TXT_FLAG_EXPAND) || (flag & LV_TXT_FLAG_FIT)) {
 80223ea:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 80223ee:	f003 0302 	and.w	r3, r3, #2
 80223f2:	2b00      	cmp	r3, #0
 80223f4:	d105      	bne.n	8022402 <_lv_txt_get_next_line+0x42>
 80223f6:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 80223fa:	f003 0310 	and.w	r3, r3, #16
 80223fe:	2b00      	cmp	r3, #0
 8022400:	d022      	beq.n	8022448 <_lv_txt_get_next_line+0x88>
        uint32_t i;
        for(i = 0; txt[i] != '\n' && txt[i] != '\r' && txt[i] != '\0'; i++) {
 8022402:	2300      	movs	r3, #0
 8022404:	627b      	str	r3, [r7, #36]	; 0x24
 8022406:	e002      	b.n	802240e <_lv_txt_get_next_line+0x4e>
 8022408:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802240a:	3301      	adds	r3, #1
 802240c:	627b      	str	r3, [r7, #36]	; 0x24
 802240e:	68fa      	ldr	r2, [r7, #12]
 8022410:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022412:	4413      	add	r3, r2
 8022414:	781b      	ldrb	r3, [r3, #0]
 8022416:	2b0a      	cmp	r3, #10
 8022418:	d00b      	beq.n	8022432 <_lv_txt_get_next_line+0x72>
 802241a:	68fa      	ldr	r2, [r7, #12]
 802241c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802241e:	4413      	add	r3, r2
 8022420:	781b      	ldrb	r3, [r3, #0]
 8022422:	2b0d      	cmp	r3, #13
 8022424:	d005      	beq.n	8022432 <_lv_txt_get_next_line+0x72>
 8022426:	68fa      	ldr	r2, [r7, #12]
 8022428:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802242a:	4413      	add	r3, r2
 802242c:	781b      	ldrb	r3, [r3, #0]
 802242e:	2b00      	cmp	r3, #0
 8022430:	d1ea      	bne.n	8022408 <_lv_txt_get_next_line+0x48>
            /*Just find the new line chars or string ends by incrementing `i`*/
        }
        if(txt[i] != '\0') i++;    /*To go beyond `\n`*/
 8022432:	68fa      	ldr	r2, [r7, #12]
 8022434:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022436:	4413      	add	r3, r2
 8022438:	781b      	ldrb	r3, [r3, #0]
 802243a:	2b00      	cmp	r3, #0
 802243c:	d002      	beq.n	8022444 <_lv_txt_get_next_line+0x84>
 802243e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022440:	3301      	adds	r3, #1
 8022442:	627b      	str	r3, [r7, #36]	; 0x24
        return i;
 8022444:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022446:	e072      	b.n	802252e <_lv_txt_get_next_line+0x16e>
    }

    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 8022448:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 802244c:	f003 0302 	and.w	r3, r3, #2
 8022450:	2b00      	cmp	r3, #0
 8022452:	d002      	beq.n	802245a <_lv_txt_get_next_line+0x9a>
 8022454:	f647 4318 	movw	r3, #31768	; 0x7c18
 8022458:	80bb      	strh	r3, [r7, #4]
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 802245a:	2300      	movs	r3, #0
 802245c:	77fb      	strb	r3, [r7, #31]
    uint32_t i = 0;                                        /* Iterating index into txt */
 802245e:	2300      	movs	r3, #0
 8022460:	61bb      	str	r3, [r7, #24]

    while(txt[i] != '\0' && max_width > 0) {
 8022462:	e04d      	b.n	8022500 <_lv_txt_get_next_line+0x140>
        uint32_t word_w = 0;
 8022464:	2300      	movs	r3, #0
 8022466:	617b      	str	r3, [r7, #20]
        uint32_t advance = lv_txt_get_next_word(&txt[i], font, letter_space, max_width, flag, &word_w, &cmd_state, i == 0);
 8022468:	69bb      	ldr	r3, [r7, #24]
 802246a:	68fa      	ldr	r2, [r7, #12]
 802246c:	18d0      	adds	r0, r2, r3
 802246e:	69bb      	ldr	r3, [r7, #24]
 8022470:	2b00      	cmp	r3, #0
 8022472:	bf0c      	ite	eq
 8022474:	2301      	moveq	r3, #1
 8022476:	2300      	movne	r3, #0
 8022478:	b2db      	uxtb	r3, r3
 802247a:	f9b7 1004 	ldrsh.w	r1, [r7, #4]
 802247e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8022482:	9303      	str	r3, [sp, #12]
 8022484:	f107 031f 	add.w	r3, r7, #31
 8022488:	9302      	str	r3, [sp, #8]
 802248a:	f107 0314 	add.w	r3, r7, #20
 802248e:	9301      	str	r3, [sp, #4]
 8022490:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8022494:	9300      	str	r3, [sp, #0]
 8022496:	460b      	mov	r3, r1
 8022498:	68b9      	ldr	r1, [r7, #8]
 802249a:	f7ff feb1 	bl	8022200 <lv_txt_get_next_word>
 802249e:	6238      	str	r0, [r7, #32]
        max_width -= word_w;
 80224a0:	88ba      	ldrh	r2, [r7, #4]
 80224a2:	697b      	ldr	r3, [r7, #20]
 80224a4:	b29b      	uxth	r3, r3
 80224a6:	1ad3      	subs	r3, r2, r3
 80224a8:	b29b      	uxth	r3, r3
 80224aa:	80bb      	strh	r3, [r7, #4]

        if(advance == 0) {
 80224ac:	6a3b      	ldr	r3, [r7, #32]
 80224ae:	2b00      	cmp	r3, #0
 80224b0:	d10a      	bne.n	80224c8 <_lv_txt_get_next_line+0x108>
            if(i == 0) _lv_txt_encoded_next(txt, &i); // prevent inf loops
 80224b2:	69bb      	ldr	r3, [r7, #24]
 80224b4:	2b00      	cmp	r3, #0
 80224b6:	d12e      	bne.n	8022516 <_lv_txt_get_next_line+0x156>
 80224b8:	4b1f      	ldr	r3, [pc, #124]	; (8022538 <_lv_txt_get_next_line+0x178>)
 80224ba:	681b      	ldr	r3, [r3, #0]
 80224bc:	f107 0218 	add.w	r2, r7, #24
 80224c0:	4611      	mov	r1, r2
 80224c2:	68f8      	ldr	r0, [r7, #12]
 80224c4:	4798      	blx	r3
            break;
 80224c6:	e026      	b.n	8022516 <_lv_txt_get_next_line+0x156>
        }

        i += advance;
 80224c8:	69ba      	ldr	r2, [r7, #24]
 80224ca:	6a3b      	ldr	r3, [r7, #32]
 80224cc:	4413      	add	r3, r2
 80224ce:	61bb      	str	r3, [r7, #24]

        if(txt[0] == '\n' || txt[0] == '\r') break;
 80224d0:	68fb      	ldr	r3, [r7, #12]
 80224d2:	781b      	ldrb	r3, [r3, #0]
 80224d4:	2b0a      	cmp	r3, #10
 80224d6:	d01e      	beq.n	8022516 <_lv_txt_get_next_line+0x156>
 80224d8:	68fb      	ldr	r3, [r7, #12]
 80224da:	781b      	ldrb	r3, [r3, #0]
 80224dc:	2b0d      	cmp	r3, #13
 80224de:	d01a      	beq.n	8022516 <_lv_txt_get_next_line+0x156>

        if(txt[i] == '\n' || txt[i] == '\r') {
 80224e0:	69bb      	ldr	r3, [r7, #24]
 80224e2:	68fa      	ldr	r2, [r7, #12]
 80224e4:	4413      	add	r3, r2
 80224e6:	781b      	ldrb	r3, [r3, #0]
 80224e8:	2b0a      	cmp	r3, #10
 80224ea:	d005      	beq.n	80224f8 <_lv_txt_get_next_line+0x138>
 80224ec:	69bb      	ldr	r3, [r7, #24]
 80224ee:	68fa      	ldr	r2, [r7, #12]
 80224f0:	4413      	add	r3, r2
 80224f2:	781b      	ldrb	r3, [r3, #0]
 80224f4:	2b0d      	cmp	r3, #13
 80224f6:	d103      	bne.n	8022500 <_lv_txt_get_next_line+0x140>
            i++;  /* Include the following newline in the current line */
 80224f8:	69bb      	ldr	r3, [r7, #24]
 80224fa:	3301      	adds	r3, #1
 80224fc:	61bb      	str	r3, [r7, #24]
            break;
 80224fe:	e00b      	b.n	8022518 <_lv_txt_get_next_line+0x158>
    while(txt[i] != '\0' && max_width > 0) {
 8022500:	69bb      	ldr	r3, [r7, #24]
 8022502:	68fa      	ldr	r2, [r7, #12]
 8022504:	4413      	add	r3, r2
 8022506:	781b      	ldrb	r3, [r3, #0]
 8022508:	2b00      	cmp	r3, #0
 802250a:	d005      	beq.n	8022518 <_lv_txt_get_next_line+0x158>
 802250c:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8022510:	2b00      	cmp	r3, #0
 8022512:	dca7      	bgt.n	8022464 <_lv_txt_get_next_line+0xa4>
 8022514:	e000      	b.n	8022518 <_lv_txt_get_next_line+0x158>
            break;
 8022516:	bf00      	nop
        }

    }

    /* Always step at least one to avoid infinite loops */
    if(i == 0) {
 8022518:	69bb      	ldr	r3, [r7, #24]
 802251a:	2b00      	cmp	r3, #0
 802251c:	d106      	bne.n	802252c <_lv_txt_get_next_line+0x16c>
        _lv_txt_encoded_next(txt, &i);
 802251e:	4b06      	ldr	r3, [pc, #24]	; (8022538 <_lv_txt_get_next_line+0x178>)
 8022520:	681b      	ldr	r3, [r3, #0]
 8022522:	f107 0218 	add.w	r2, r7, #24
 8022526:	4611      	mov	r1, r2
 8022528:	68f8      	ldr	r0, [r7, #12]
 802252a:	4798      	blx	r3
    }

    return i;
 802252c:	69bb      	ldr	r3, [r7, #24]
}
 802252e:	4618      	mov	r0, r3
 8022530:	3728      	adds	r7, #40	; 0x28
 8022532:	46bd      	mov	sp, r7
 8022534:	bd80      	pop	{r7, pc}
 8022536:	bf00      	nop
 8022538:	20000204 	.word	0x20000204

0802253c <_lv_txt_get_width>:
 * @param flags settings for the text from 'txt_flag_t' enum
 * @return length of a char_num long text
 */
lv_coord_t _lv_txt_get_width(const char * txt, uint32_t length, const lv_font_t * font, lv_coord_t letter_space,
                             lv_txt_flag_t flag)
{
 802253c:	b580      	push	{r7, lr}
 802253e:	b08a      	sub	sp, #40	; 0x28
 8022540:	af00      	add	r7, sp, #0
 8022542:	60f8      	str	r0, [r7, #12]
 8022544:	60b9      	str	r1, [r7, #8]
 8022546:	607a      	str	r2, [r7, #4]
 8022548:	807b      	strh	r3, [r7, #2]
    if(txt == NULL) return 0;
 802254a:	68fb      	ldr	r3, [r7, #12]
 802254c:	2b00      	cmp	r3, #0
 802254e:	d101      	bne.n	8022554 <_lv_txt_get_width+0x18>
 8022550:	2300      	movs	r3, #0
 8022552:	e053      	b.n	80225fc <_lv_txt_get_width+0xc0>
    if(font == NULL) return 0;
 8022554:	687b      	ldr	r3, [r7, #4]
 8022556:	2b00      	cmp	r3, #0
 8022558:	d101      	bne.n	802255e <_lv_txt_get_width+0x22>
 802255a:	2300      	movs	r3, #0
 802255c:	e04e      	b.n	80225fc <_lv_txt_get_width+0xc0>

    uint32_t i                   = 0;
 802255e:	2300      	movs	r3, #0
 8022560:	617b      	str	r3, [r7, #20]
    lv_coord_t width             = 0;
 8022562:	2300      	movs	r3, #0
 8022564:	84fb      	strh	r3, [r7, #38]	; 0x26
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 8022566:	2300      	movs	r3, #0
 8022568:	74fb      	strb	r3, [r7, #19]

    if(length != 0) {
 802256a:	68bb      	ldr	r3, [r7, #8]
 802256c:	2b00      	cmp	r3, #0
 802256e:	d043      	beq.n	80225f8 <_lv_txt_get_width+0xbc>
        while(i < length) {
 8022570:	e035      	b.n	80225de <_lv_txt_get_width+0xa2>
            uint32_t letter      = _lv_txt_encoded_next(txt, &i);
 8022572:	4b24      	ldr	r3, [pc, #144]	; (8022604 <_lv_txt_get_width+0xc8>)
 8022574:	681b      	ldr	r3, [r3, #0]
 8022576:	f107 0214 	add.w	r2, r7, #20
 802257a:	4611      	mov	r1, r2
 802257c:	68f8      	ldr	r0, [r7, #12]
 802257e:	4798      	blx	r3
 8022580:	6238      	str	r0, [r7, #32]
            uint32_t letter_next = _lv_txt_encoded_next(&txt[i], NULL);
 8022582:	4b20      	ldr	r3, [pc, #128]	; (8022604 <_lv_txt_get_width+0xc8>)
 8022584:	681b      	ldr	r3, [r3, #0]
 8022586:	697a      	ldr	r2, [r7, #20]
 8022588:	68f9      	ldr	r1, [r7, #12]
 802258a:	440a      	add	r2, r1
 802258c:	2100      	movs	r1, #0
 802258e:	4610      	mov	r0, r2
 8022590:	4798      	blx	r3
 8022592:	61f8      	str	r0, [r7, #28]
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 8022594:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8022598:	f003 0301 	and.w	r3, r3, #1
 802259c:	2b00      	cmp	r3, #0
 802259e:	d009      	beq.n	80225b4 <_lv_txt_get_width+0x78>
                if(_lv_txt_is_cmd(&cmd_state, letter) != false) {
 80225a0:	f107 0313 	add.w	r3, r7, #19
 80225a4:	6a39      	ldr	r1, [r7, #32]
 80225a6:	4618      	mov	r0, r3
 80225a8:	f000 f82e 	bl	8022608 <_lv_txt_is_cmd>
 80225ac:	4603      	mov	r3, r0
 80225ae:	2b00      	cmp	r3, #0
 80225b0:	d000      	beq.n	80225b4 <_lv_txt_get_width+0x78>
                    continue;
 80225b2:	e014      	b.n	80225de <_lv_txt_get_width+0xa2>
                }
            }

            lv_coord_t char_width = lv_font_get_glyph_width(font, letter, letter_next);
 80225b4:	69fa      	ldr	r2, [r7, #28]
 80225b6:	6a39      	ldr	r1, [r7, #32]
 80225b8:	6878      	ldr	r0, [r7, #4]
 80225ba:	f7fb fa87 	bl	801dacc <lv_font_get_glyph_width>
 80225be:	4603      	mov	r3, r0
 80225c0:	837b      	strh	r3, [r7, #26]
            if(char_width > 0) {
 80225c2:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80225c6:	2b00      	cmp	r3, #0
 80225c8:	dd09      	ble.n	80225de <_lv_txt_get_width+0xa2>
                width += char_width;
 80225ca:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80225cc:	8b7b      	ldrh	r3, [r7, #26]
 80225ce:	4413      	add	r3, r2
 80225d0:	b29b      	uxth	r3, r3
 80225d2:	84fb      	strh	r3, [r7, #38]	; 0x26
                width += letter_space;
 80225d4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80225d6:	887b      	ldrh	r3, [r7, #2]
 80225d8:	4413      	add	r3, r2
 80225da:	b29b      	uxth	r3, r3
 80225dc:	84fb      	strh	r3, [r7, #38]	; 0x26
        while(i < length) {
 80225de:	697b      	ldr	r3, [r7, #20]
 80225e0:	68ba      	ldr	r2, [r7, #8]
 80225e2:	429a      	cmp	r2, r3
 80225e4:	d8c5      	bhi.n	8022572 <_lv_txt_get_width+0x36>
            }
        }

        if(width > 0) {
 80225e6:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 80225ea:	2b00      	cmp	r3, #0
 80225ec:	dd04      	ble.n	80225f8 <_lv_txt_get_width+0xbc>
            width -= letter_space; /*Trim the last letter space. Important if the text is center
 80225ee:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80225f0:	887b      	ldrh	r3, [r7, #2]
 80225f2:	1ad3      	subs	r3, r2, r3
 80225f4:	b29b      	uxth	r3, r3
 80225f6:	84fb      	strh	r3, [r7, #38]	; 0x26
                                      aligned */
        }
    }

    return width;
 80225f8:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
}
 80225fc:	4618      	mov	r0, r3
 80225fe:	3728      	adds	r7, #40	; 0x28
 8022600:	46bd      	mov	sp, r7
 8022602:	bd80      	pop	{r7, pc}
 8022604:	20000204 	.word	0x20000204

08022608 <_lv_txt_is_cmd>:
 * @param c the current character
 * @return true: the character is part of a command and should not be written,
 *         false: the character should be written
 */
bool _lv_txt_is_cmd(lv_txt_cmd_state_t * state, uint32_t c)
{
 8022608:	b480      	push	{r7}
 802260a:	b085      	sub	sp, #20
 802260c:	af00      	add	r7, sp, #0
 802260e:	6078      	str	r0, [r7, #4]
 8022610:	6039      	str	r1, [r7, #0]
    bool ret = false;
 8022612:	2300      	movs	r3, #0
 8022614:	73fb      	strb	r3, [r7, #15]

    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
 8022616:	2323      	movs	r3, #35	; 0x23
 8022618:	461a      	mov	r2, r3
 802261a:	683b      	ldr	r3, [r7, #0]
 802261c:	4293      	cmp	r3, r2
 802261e:	d11a      	bne.n	8022656 <_lv_txt_is_cmd+0x4e>
        if(*state == LV_TXT_CMD_STATE_WAIT) { /*Start char*/
 8022620:	687b      	ldr	r3, [r7, #4]
 8022622:	781b      	ldrb	r3, [r3, #0]
 8022624:	2b00      	cmp	r3, #0
 8022626:	d105      	bne.n	8022634 <_lv_txt_is_cmd+0x2c>
            *state = LV_TXT_CMD_STATE_PAR;
 8022628:	687b      	ldr	r3, [r7, #4]
 802262a:	2201      	movs	r2, #1
 802262c:	701a      	strb	r2, [r3, #0]
            ret    = true;
 802262e:	2301      	movs	r3, #1
 8022630:	73fb      	strb	r3, [r7, #15]
 8022632:	e010      	b.n	8022656 <_lv_txt_is_cmd+0x4e>
        }
        /*Other start char in parameter is escaped cmd. char */
        else if(*state == LV_TXT_CMD_STATE_PAR) {
 8022634:	687b      	ldr	r3, [r7, #4]
 8022636:	781b      	ldrb	r3, [r3, #0]
 8022638:	2b01      	cmp	r3, #1
 802263a:	d103      	bne.n	8022644 <_lv_txt_is_cmd+0x3c>
            *state = LV_TXT_CMD_STATE_WAIT;
 802263c:	687b      	ldr	r3, [r7, #4]
 802263e:	2200      	movs	r2, #0
 8022640:	701a      	strb	r2, [r3, #0]
 8022642:	e008      	b.n	8022656 <_lv_txt_is_cmd+0x4e>
        }
        /*Command end */
        else if(*state == LV_TXT_CMD_STATE_IN) {
 8022644:	687b      	ldr	r3, [r7, #4]
 8022646:	781b      	ldrb	r3, [r3, #0]
 8022648:	2b02      	cmp	r3, #2
 802264a:	d104      	bne.n	8022656 <_lv_txt_is_cmd+0x4e>
            *state = LV_TXT_CMD_STATE_WAIT;
 802264c:	687b      	ldr	r3, [r7, #4]
 802264e:	2200      	movs	r2, #0
 8022650:	701a      	strb	r2, [r3, #0]
            ret    = true;
 8022652:	2301      	movs	r3, #1
 8022654:	73fb      	strb	r3, [r7, #15]
        }
    }

    /*Skip the color parameter and wait the space after it*/
    if(*state == LV_TXT_CMD_STATE_PAR) {
 8022656:	687b      	ldr	r3, [r7, #4]
 8022658:	781b      	ldrb	r3, [r3, #0]
 802265a:	2b01      	cmp	r3, #1
 802265c:	d107      	bne.n	802266e <_lv_txt_is_cmd+0x66>
        if(c == ' ') {
 802265e:	683b      	ldr	r3, [r7, #0]
 8022660:	2b20      	cmp	r3, #32
 8022662:	d102      	bne.n	802266a <_lv_txt_is_cmd+0x62>
            *state = LV_TXT_CMD_STATE_IN; /*After the parameter the text is in the command*/
 8022664:	687b      	ldr	r3, [r7, #4]
 8022666:	2202      	movs	r2, #2
 8022668:	701a      	strb	r2, [r3, #0]
        }
        ret = true;
 802266a:	2301      	movs	r3, #1
 802266c:	73fb      	strb	r3, [r7, #15]
    }

    return ret;
 802266e:	7bfb      	ldrb	r3, [r7, #15]
}
 8022670:	4618      	mov	r0, r3
 8022672:	3714      	adds	r7, #20
 8022674:	46bd      	mov	sp, r7
 8022676:	f85d 7b04 	ldr.w	r7, [sp], #4
 802267a:	4770      	bx	lr

0802267c <lv_txt_utf8_size>:
 * Give the size of an UTF-8 coded character
 * @param str pointer to a character in a string
 * @return length of the UTF-8 character (1,2,3 or 4). O on invalid code
 */
static uint8_t lv_txt_utf8_size(const char * str)
{
 802267c:	b480      	push	{r7}
 802267e:	b083      	sub	sp, #12
 8022680:	af00      	add	r7, sp, #0
 8022682:	6078      	str	r0, [r7, #4]
    if((str[0] & 0x80) == 0)
 8022684:	687b      	ldr	r3, [r7, #4]
 8022686:	781b      	ldrb	r3, [r3, #0]
 8022688:	b25b      	sxtb	r3, r3
 802268a:	2b00      	cmp	r3, #0
 802268c:	db01      	blt.n	8022692 <lv_txt_utf8_size+0x16>
        return 1;
 802268e:	2301      	movs	r3, #1
 8022690:	e018      	b.n	80226c4 <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xE0) == 0xC0)
 8022692:	687b      	ldr	r3, [r7, #4]
 8022694:	781b      	ldrb	r3, [r3, #0]
 8022696:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 802269a:	2bc0      	cmp	r3, #192	; 0xc0
 802269c:	d101      	bne.n	80226a2 <lv_txt_utf8_size+0x26>
        return 2;
 802269e:	2302      	movs	r3, #2
 80226a0:	e010      	b.n	80226c4 <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xF0) == 0xE0)
 80226a2:	687b      	ldr	r3, [r7, #4]
 80226a4:	781b      	ldrb	r3, [r3, #0]
 80226a6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80226aa:	2be0      	cmp	r3, #224	; 0xe0
 80226ac:	d101      	bne.n	80226b2 <lv_txt_utf8_size+0x36>
        return 3;
 80226ae:	2303      	movs	r3, #3
 80226b0:	e008      	b.n	80226c4 <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xF8) == 0xF0)
 80226b2:	687b      	ldr	r3, [r7, #4]
 80226b4:	781b      	ldrb	r3, [r3, #0]
 80226b6:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
 80226ba:	2bf0      	cmp	r3, #240	; 0xf0
 80226bc:	d101      	bne.n	80226c2 <lv_txt_utf8_size+0x46>
        return 4;
 80226be:	2304      	movs	r3, #4
 80226c0:	e000      	b.n	80226c4 <lv_txt_utf8_size+0x48>
    return 0; /*If the char was invalid tell it's 1 byte long*/
 80226c2:	2300      	movs	r3, #0
}
 80226c4:	4618      	mov	r0, r3
 80226c6:	370c      	adds	r7, #12
 80226c8:	46bd      	mov	sp, r7
 80226ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80226ce:	4770      	bx	lr

080226d0 <lv_txt_utf8_next>:
 *          After call it will point to the next UTF-8 char in 'txt'.
 *          NULL to use txt[0] as index
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_txt_utf8_next(const char * txt, uint32_t * i)
{
 80226d0:	b480      	push	{r7}
 80226d2:	b085      	sub	sp, #20
 80226d4:	af00      	add	r7, sp, #0
 80226d6:	6078      	str	r0, [r7, #4]
 80226d8:	6039      	str	r1, [r7, #0]
     * 00000000 00000000 00000yyy yyxxxxxx -> 110yyyyy 10xxxxxx
     * 00000000 00000000 zzzzyyyy yyxxxxxx -> 1110zzzz 10yyyyyy 10xxxxxx
     * 00000000 000wwwzz zzzzyyyy yyxxxxxx -> 11110www 10zzzzzz 10yyyyyy 10xxxxxx
     * */

    uint32_t result = 0;
 80226da:	2300      	movs	r3, #0
 80226dc:	60fb      	str	r3, [r7, #12]

    /*Dummy 'i' pointer is required*/
    uint32_t i_tmp = 0;
 80226de:	2300      	movs	r3, #0
 80226e0:	60bb      	str	r3, [r7, #8]
    if(i == NULL) i = &i_tmp;
 80226e2:	683b      	ldr	r3, [r7, #0]
 80226e4:	2b00      	cmp	r3, #0
 80226e6:	d102      	bne.n	80226ee <lv_txt_utf8_next+0x1e>
 80226e8:	f107 0308 	add.w	r3, r7, #8
 80226ec:	603b      	str	r3, [r7, #0]

    /*Normal ASCII*/
    if((txt[*i] & 0x80) == 0) {
 80226ee:	683b      	ldr	r3, [r7, #0]
 80226f0:	681b      	ldr	r3, [r3, #0]
 80226f2:	687a      	ldr	r2, [r7, #4]
 80226f4:	4413      	add	r3, r2
 80226f6:	781b      	ldrb	r3, [r3, #0]
 80226f8:	b25b      	sxtb	r3, r3
 80226fa:	2b00      	cmp	r3, #0
 80226fc:	db0b      	blt.n	8022716 <lv_txt_utf8_next+0x46>
        result = txt[*i];
 80226fe:	683b      	ldr	r3, [r7, #0]
 8022700:	681b      	ldr	r3, [r3, #0]
 8022702:	687a      	ldr	r2, [r7, #4]
 8022704:	4413      	add	r3, r2
 8022706:	781b      	ldrb	r3, [r3, #0]
 8022708:	60fb      	str	r3, [r7, #12]
        (*i)++;
 802270a:	683b      	ldr	r3, [r7, #0]
 802270c:	681b      	ldr	r3, [r3, #0]
 802270e:	1c5a      	adds	r2, r3, #1
 8022710:	683b      	ldr	r3, [r7, #0]
 8022712:	601a      	str	r2, [r3, #0]
 8022714:	e0ea      	b.n	80228ec <lv_txt_utf8_next+0x21c>
    }
    /*Real UTF-8 decode*/
    else {
        /*2 bytes UTF-8 code*/
        if((txt[*i] & 0xE0) == 0xC0) {
 8022716:	683b      	ldr	r3, [r7, #0]
 8022718:	681b      	ldr	r3, [r3, #0]
 802271a:	687a      	ldr	r2, [r7, #4]
 802271c:	4413      	add	r3, r2
 802271e:	781b      	ldrb	r3, [r3, #0]
 8022720:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 8022724:	2bc0      	cmp	r3, #192	; 0xc0
 8022726:	d128      	bne.n	802277a <lv_txt_utf8_next+0xaa>
            result = (uint32_t)(txt[*i] & 0x1F) << 6;
 8022728:	683b      	ldr	r3, [r7, #0]
 802272a:	681b      	ldr	r3, [r3, #0]
 802272c:	687a      	ldr	r2, [r7, #4]
 802272e:	4413      	add	r3, r2
 8022730:	781b      	ldrb	r3, [r3, #0]
 8022732:	019b      	lsls	r3, r3, #6
 8022734:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 8022738:	60fb      	str	r3, [r7, #12]
            (*i)++;
 802273a:	683b      	ldr	r3, [r7, #0]
 802273c:	681b      	ldr	r3, [r3, #0]
 802273e:	1c5a      	adds	r2, r3, #1
 8022740:	683b      	ldr	r3, [r7, #0]
 8022742:	601a      	str	r2, [r3, #0]
            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 8022744:	683b      	ldr	r3, [r7, #0]
 8022746:	681b      	ldr	r3, [r3, #0]
 8022748:	687a      	ldr	r2, [r7, #4]
 802274a:	4413      	add	r3, r2
 802274c:	781b      	ldrb	r3, [r3, #0]
 802274e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8022752:	2b80      	cmp	r3, #128	; 0x80
 8022754:	d001      	beq.n	802275a <lv_txt_utf8_next+0x8a>
 8022756:	2300      	movs	r3, #0
 8022758:	e0c9      	b.n	80228ee <lv_txt_utf8_next+0x21e>
            result += (txt[*i] & 0x3F);
 802275a:	683b      	ldr	r3, [r7, #0]
 802275c:	681b      	ldr	r3, [r3, #0]
 802275e:	687a      	ldr	r2, [r7, #4]
 8022760:	4413      	add	r3, r2
 8022762:	781b      	ldrb	r3, [r3, #0]
 8022764:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8022768:	68fa      	ldr	r2, [r7, #12]
 802276a:	4413      	add	r3, r2
 802276c:	60fb      	str	r3, [r7, #12]
            (*i)++;
 802276e:	683b      	ldr	r3, [r7, #0]
 8022770:	681b      	ldr	r3, [r3, #0]
 8022772:	1c5a      	adds	r2, r3, #1
 8022774:	683b      	ldr	r3, [r7, #0]
 8022776:	601a      	str	r2, [r3, #0]
 8022778:	e0b8      	b.n	80228ec <lv_txt_utf8_next+0x21c>
        }
        /*3 bytes UTF-8 code*/
        else if((txt[*i] & 0xF0) == 0xE0) {
 802277a:	683b      	ldr	r3, [r7, #0]
 802277c:	681b      	ldr	r3, [r3, #0]
 802277e:	687a      	ldr	r2, [r7, #4]
 8022780:	4413      	add	r3, r2
 8022782:	781b      	ldrb	r3, [r3, #0]
 8022784:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8022788:	2be0      	cmp	r3, #224	; 0xe0
 802278a:	d142      	bne.n	8022812 <lv_txt_utf8_next+0x142>
            result = (uint32_t)(txt[*i] & 0x0F) << 12;
 802278c:	683b      	ldr	r3, [r7, #0]
 802278e:	681b      	ldr	r3, [r3, #0]
 8022790:	687a      	ldr	r2, [r7, #4]
 8022792:	4413      	add	r3, r2
 8022794:	781b      	ldrb	r3, [r3, #0]
 8022796:	031b      	lsls	r3, r3, #12
 8022798:	b29b      	uxth	r3, r3
 802279a:	60fb      	str	r3, [r7, #12]
            (*i)++;
 802279c:	683b      	ldr	r3, [r7, #0]
 802279e:	681b      	ldr	r3, [r3, #0]
 80227a0:	1c5a      	adds	r2, r3, #1
 80227a2:	683b      	ldr	r3, [r7, #0]
 80227a4:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 80227a6:	683b      	ldr	r3, [r7, #0]
 80227a8:	681b      	ldr	r3, [r3, #0]
 80227aa:	687a      	ldr	r2, [r7, #4]
 80227ac:	4413      	add	r3, r2
 80227ae:	781b      	ldrb	r3, [r3, #0]
 80227b0:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 80227b4:	2b80      	cmp	r3, #128	; 0x80
 80227b6:	d001      	beq.n	80227bc <lv_txt_utf8_next+0xec>
 80227b8:	2300      	movs	r3, #0
 80227ba:	e098      	b.n	80228ee <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
 80227bc:	683b      	ldr	r3, [r7, #0]
 80227be:	681b      	ldr	r3, [r3, #0]
 80227c0:	687a      	ldr	r2, [r7, #4]
 80227c2:	4413      	add	r3, r2
 80227c4:	781b      	ldrb	r3, [r3, #0]
 80227c6:	019b      	lsls	r3, r3, #6
 80227c8:	f403 637c 	and.w	r3, r3, #4032	; 0xfc0
 80227cc:	68fa      	ldr	r2, [r7, #12]
 80227ce:	4413      	add	r3, r2
 80227d0:	60fb      	str	r3, [r7, #12]
            (*i)++;
 80227d2:	683b      	ldr	r3, [r7, #0]
 80227d4:	681b      	ldr	r3, [r3, #0]
 80227d6:	1c5a      	adds	r2, r3, #1
 80227d8:	683b      	ldr	r3, [r7, #0]
 80227da:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 80227dc:	683b      	ldr	r3, [r7, #0]
 80227de:	681b      	ldr	r3, [r3, #0]
 80227e0:	687a      	ldr	r2, [r7, #4]
 80227e2:	4413      	add	r3, r2
 80227e4:	781b      	ldrb	r3, [r3, #0]
 80227e6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 80227ea:	2b80      	cmp	r3, #128	; 0x80
 80227ec:	d001      	beq.n	80227f2 <lv_txt_utf8_next+0x122>
 80227ee:	2300      	movs	r3, #0
 80227f0:	e07d      	b.n	80228ee <lv_txt_utf8_next+0x21e>
            result += (txt[*i] & 0x3F);
 80227f2:	683b      	ldr	r3, [r7, #0]
 80227f4:	681b      	ldr	r3, [r3, #0]
 80227f6:	687a      	ldr	r2, [r7, #4]
 80227f8:	4413      	add	r3, r2
 80227fa:	781b      	ldrb	r3, [r3, #0]
 80227fc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8022800:	68fa      	ldr	r2, [r7, #12]
 8022802:	4413      	add	r3, r2
 8022804:	60fb      	str	r3, [r7, #12]
            (*i)++;
 8022806:	683b      	ldr	r3, [r7, #0]
 8022808:	681b      	ldr	r3, [r3, #0]
 802280a:	1c5a      	adds	r2, r3, #1
 802280c:	683b      	ldr	r3, [r7, #0]
 802280e:	601a      	str	r2, [r3, #0]
 8022810:	e06c      	b.n	80228ec <lv_txt_utf8_next+0x21c>
        }
        /*4 bytes UTF-8 code*/
        else if((txt[*i] & 0xF8) == 0xF0) {
 8022812:	683b      	ldr	r3, [r7, #0]
 8022814:	681b      	ldr	r3, [r3, #0]
 8022816:	687a      	ldr	r2, [r7, #4]
 8022818:	4413      	add	r3, r2
 802281a:	781b      	ldrb	r3, [r3, #0]
 802281c:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
 8022820:	2bf0      	cmp	r3, #240	; 0xf0
 8022822:	d15e      	bne.n	80228e2 <lv_txt_utf8_next+0x212>
            result = (uint32_t)(txt[*i] & 0x07) << 18;
 8022824:	683b      	ldr	r3, [r7, #0]
 8022826:	681b      	ldr	r3, [r3, #0]
 8022828:	687a      	ldr	r2, [r7, #4]
 802282a:	4413      	add	r3, r2
 802282c:	781b      	ldrb	r3, [r3, #0]
 802282e:	049b      	lsls	r3, r3, #18
 8022830:	f403 13e0 	and.w	r3, r3, #1835008	; 0x1c0000
 8022834:	60fb      	str	r3, [r7, #12]
            (*i)++;
 8022836:	683b      	ldr	r3, [r7, #0]
 8022838:	681b      	ldr	r3, [r3, #0]
 802283a:	1c5a      	adds	r2, r3, #1
 802283c:	683b      	ldr	r3, [r7, #0]
 802283e:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 8022840:	683b      	ldr	r3, [r7, #0]
 8022842:	681b      	ldr	r3, [r3, #0]
 8022844:	687a      	ldr	r2, [r7, #4]
 8022846:	4413      	add	r3, r2
 8022848:	781b      	ldrb	r3, [r3, #0]
 802284a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 802284e:	2b80      	cmp	r3, #128	; 0x80
 8022850:	d001      	beq.n	8022856 <lv_txt_utf8_next+0x186>
 8022852:	2300      	movs	r3, #0
 8022854:	e04b      	b.n	80228ee <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 12;
 8022856:	683b      	ldr	r3, [r7, #0]
 8022858:	681b      	ldr	r3, [r3, #0]
 802285a:	687a      	ldr	r2, [r7, #4]
 802285c:	4413      	add	r3, r2
 802285e:	781b      	ldrb	r3, [r3, #0]
 8022860:	031b      	lsls	r3, r3, #12
 8022862:	f403 337c 	and.w	r3, r3, #258048	; 0x3f000
 8022866:	68fa      	ldr	r2, [r7, #12]
 8022868:	4413      	add	r3, r2
 802286a:	60fb      	str	r3, [r7, #12]
            (*i)++;
 802286c:	683b      	ldr	r3, [r7, #0]
 802286e:	681b      	ldr	r3, [r3, #0]
 8022870:	1c5a      	adds	r2, r3, #1
 8022872:	683b      	ldr	r3, [r7, #0]
 8022874:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 8022876:	683b      	ldr	r3, [r7, #0]
 8022878:	681b      	ldr	r3, [r3, #0]
 802287a:	687a      	ldr	r2, [r7, #4]
 802287c:	4413      	add	r3, r2
 802287e:	781b      	ldrb	r3, [r3, #0]
 8022880:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8022884:	2b80      	cmp	r3, #128	; 0x80
 8022886:	d001      	beq.n	802288c <lv_txt_utf8_next+0x1bc>
 8022888:	2300      	movs	r3, #0
 802288a:	e030      	b.n	80228ee <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
 802288c:	683b      	ldr	r3, [r7, #0]
 802288e:	681b      	ldr	r3, [r3, #0]
 8022890:	687a      	ldr	r2, [r7, #4]
 8022892:	4413      	add	r3, r2
 8022894:	781b      	ldrb	r3, [r3, #0]
 8022896:	019b      	lsls	r3, r3, #6
 8022898:	f403 637c 	and.w	r3, r3, #4032	; 0xfc0
 802289c:	68fa      	ldr	r2, [r7, #12]
 802289e:	4413      	add	r3, r2
 80228a0:	60fb      	str	r3, [r7, #12]
            (*i)++;
 80228a2:	683b      	ldr	r3, [r7, #0]
 80228a4:	681b      	ldr	r3, [r3, #0]
 80228a6:	1c5a      	adds	r2, r3, #1
 80228a8:	683b      	ldr	r3, [r7, #0]
 80228aa:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 80228ac:	683b      	ldr	r3, [r7, #0]
 80228ae:	681b      	ldr	r3, [r3, #0]
 80228b0:	687a      	ldr	r2, [r7, #4]
 80228b2:	4413      	add	r3, r2
 80228b4:	781b      	ldrb	r3, [r3, #0]
 80228b6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 80228ba:	2b80      	cmp	r3, #128	; 0x80
 80228bc:	d001      	beq.n	80228c2 <lv_txt_utf8_next+0x1f2>
 80228be:	2300      	movs	r3, #0
 80228c0:	e015      	b.n	80228ee <lv_txt_utf8_next+0x21e>
            result += txt[*i] & 0x3F;
 80228c2:	683b      	ldr	r3, [r7, #0]
 80228c4:	681b      	ldr	r3, [r3, #0]
 80228c6:	687a      	ldr	r2, [r7, #4]
 80228c8:	4413      	add	r3, r2
 80228ca:	781b      	ldrb	r3, [r3, #0]
 80228cc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80228d0:	68fa      	ldr	r2, [r7, #12]
 80228d2:	4413      	add	r3, r2
 80228d4:	60fb      	str	r3, [r7, #12]
            (*i)++;
 80228d6:	683b      	ldr	r3, [r7, #0]
 80228d8:	681b      	ldr	r3, [r3, #0]
 80228da:	1c5a      	adds	r2, r3, #1
 80228dc:	683b      	ldr	r3, [r7, #0]
 80228de:	601a      	str	r2, [r3, #0]
 80228e0:	e004      	b.n	80228ec <lv_txt_utf8_next+0x21c>
        }
        else {
            (*i)++; /*Not UTF-8 char. Go the next.*/
 80228e2:	683b      	ldr	r3, [r7, #0]
 80228e4:	681b      	ldr	r3, [r3, #0]
 80228e6:	1c5a      	adds	r2, r3, #1
 80228e8:	683b      	ldr	r3, [r7, #0]
 80228ea:	601a      	str	r2, [r3, #0]
        }
    }
    return result;
 80228ec:	68fb      	ldr	r3, [r7, #12]
}
 80228ee:	4618      	mov	r0, r3
 80228f0:	3714      	adds	r7, #20
 80228f2:	46bd      	mov	sp, r7
 80228f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80228f8:	4770      	bx	lr
	...

080228fc <lv_txt_utf8_prev>:
 * @param i start byte index in 'txt' where to start. After the call it will point to the previous
 * UTF-8 char in 'txt'.
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_txt_utf8_prev(const char * txt, uint32_t * i)
{
 80228fc:	b580      	push	{r7, lr}
 80228fe:	b086      	sub	sp, #24
 8022900:	af00      	add	r7, sp, #0
 8022902:	6078      	str	r0, [r7, #4]
 8022904:	6039      	str	r1, [r7, #0]
    uint8_t c_size;
    uint8_t cnt = 0;
 8022906:	2300      	movs	r3, #0
 8022908:	75fb      	strb	r3, [r7, #23]

    /*Try to find a !0 long UTF-8 char by stepping one character back*/
    (*i)--;
 802290a:	683b      	ldr	r3, [r7, #0]
 802290c:	681b      	ldr	r3, [r3, #0]
 802290e:	1e5a      	subs	r2, r3, #1
 8022910:	683b      	ldr	r3, [r7, #0]
 8022912:	601a      	str	r2, [r3, #0]
    do {
        if(cnt >= 4) return 0; /*No UTF-8 char found before the initial*/
 8022914:	7dfb      	ldrb	r3, [r7, #23]
 8022916:	2b03      	cmp	r3, #3
 8022918:	d901      	bls.n	802291e <lv_txt_utf8_prev+0x22>
 802291a:	2300      	movs	r3, #0
 802291c:	e02a      	b.n	8022974 <lv_txt_utf8_prev+0x78>

        c_size = _lv_txt_encoded_size(&txt[*i]);
 802291e:	4b17      	ldr	r3, [pc, #92]	; (802297c <lv_txt_utf8_prev+0x80>)
 8022920:	681b      	ldr	r3, [r3, #0]
 8022922:	683a      	ldr	r2, [r7, #0]
 8022924:	6812      	ldr	r2, [r2, #0]
 8022926:	6879      	ldr	r1, [r7, #4]
 8022928:	440a      	add	r2, r1
 802292a:	4610      	mov	r0, r2
 802292c:	4798      	blx	r3
 802292e:	4603      	mov	r3, r0
 8022930:	75bb      	strb	r3, [r7, #22]
        if(c_size == 0) {
 8022932:	7dbb      	ldrb	r3, [r7, #22]
 8022934:	2b00      	cmp	r3, #0
 8022936:	d10b      	bne.n	8022950 <lv_txt_utf8_prev+0x54>
            if(*i != 0)
 8022938:	683b      	ldr	r3, [r7, #0]
 802293a:	681b      	ldr	r3, [r3, #0]
 802293c:	2b00      	cmp	r3, #0
 802293e:	d005      	beq.n	802294c <lv_txt_utf8_prev+0x50>
                (*i)--;
 8022940:	683b      	ldr	r3, [r7, #0]
 8022942:	681b      	ldr	r3, [r3, #0]
 8022944:	1e5a      	subs	r2, r3, #1
 8022946:	683b      	ldr	r3, [r7, #0]
 8022948:	601a      	str	r2, [r3, #0]
 802294a:	e001      	b.n	8022950 <lv_txt_utf8_prev+0x54>
            else
                return 0;
 802294c:	2300      	movs	r3, #0
 802294e:	e011      	b.n	8022974 <lv_txt_utf8_prev+0x78>
        }
        cnt++;
 8022950:	7dfb      	ldrb	r3, [r7, #23]
 8022952:	3301      	adds	r3, #1
 8022954:	75fb      	strb	r3, [r7, #23]
    } while(c_size == 0);
 8022956:	7dbb      	ldrb	r3, [r7, #22]
 8022958:	2b00      	cmp	r3, #0
 802295a:	d0db      	beq.n	8022914 <lv_txt_utf8_prev+0x18>

    uint32_t i_tmp  = *i;
 802295c:	683b      	ldr	r3, [r7, #0]
 802295e:	681b      	ldr	r3, [r3, #0]
 8022960:	60fb      	str	r3, [r7, #12]
    uint32_t letter = _lv_txt_encoded_next(txt, &i_tmp); /*Character found, get it*/
 8022962:	4b07      	ldr	r3, [pc, #28]	; (8022980 <lv_txt_utf8_prev+0x84>)
 8022964:	681b      	ldr	r3, [r3, #0]
 8022966:	f107 020c 	add.w	r2, r7, #12
 802296a:	4611      	mov	r1, r2
 802296c:	6878      	ldr	r0, [r7, #4]
 802296e:	4798      	blx	r3
 8022970:	6138      	str	r0, [r7, #16]

    return letter;
 8022972:	693b      	ldr	r3, [r7, #16]
}
 8022974:	4618      	mov	r0, r3
 8022976:	3718      	adds	r7, #24
 8022978:	46bd      	mov	sp, r7
 802297a:	bd80      	pop	{r7, pc}
 802297c:	20000200 	.word	0x20000200
 8022980:	20000204 	.word	0x20000204

08022984 <lv_txt_utf8_get_byte_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param utf8_id character index
 * @return byte index of the 'utf8_id'th letter
 */
static uint32_t lv_txt_utf8_get_byte_id(const char * txt, uint32_t utf8_id)
{
 8022984:	b580      	push	{r7, lr}
 8022986:	b086      	sub	sp, #24
 8022988:	af00      	add	r7, sp, #0
 802298a:	6078      	str	r0, [r7, #4]
 802298c:	6039      	str	r1, [r7, #0]
    uint32_t i;
    uint32_t byte_cnt = 0;
 802298e:	2300      	movs	r3, #0
 8022990:	613b      	str	r3, [r7, #16]
    for(i = 0; i < utf8_id; i++) {
 8022992:	2300      	movs	r3, #0
 8022994:	617b      	str	r3, [r7, #20]
 8022996:	e014      	b.n	80229c2 <lv_txt_utf8_get_byte_id+0x3e>
        uint8_t c_size = _lv_txt_encoded_size(&txt[byte_cnt]);
 8022998:	4b0e      	ldr	r3, [pc, #56]	; (80229d4 <lv_txt_utf8_get_byte_id+0x50>)
 802299a:	681b      	ldr	r3, [r3, #0]
 802299c:	6879      	ldr	r1, [r7, #4]
 802299e:	693a      	ldr	r2, [r7, #16]
 80229a0:	440a      	add	r2, r1
 80229a2:	4610      	mov	r0, r2
 80229a4:	4798      	blx	r3
 80229a6:	4603      	mov	r3, r0
 80229a8:	73fb      	strb	r3, [r7, #15]
        byte_cnt += c_size > 0 ? c_size : 1;
 80229aa:	7bfb      	ldrb	r3, [r7, #15]
 80229ac:	2b00      	cmp	r3, #0
 80229ae:	d001      	beq.n	80229b4 <lv_txt_utf8_get_byte_id+0x30>
 80229b0:	7bfb      	ldrb	r3, [r7, #15]
 80229b2:	e000      	b.n	80229b6 <lv_txt_utf8_get_byte_id+0x32>
 80229b4:	2301      	movs	r3, #1
 80229b6:	693a      	ldr	r2, [r7, #16]
 80229b8:	4413      	add	r3, r2
 80229ba:	613b      	str	r3, [r7, #16]
    for(i = 0; i < utf8_id; i++) {
 80229bc:	697b      	ldr	r3, [r7, #20]
 80229be:	3301      	adds	r3, #1
 80229c0:	617b      	str	r3, [r7, #20]
 80229c2:	697a      	ldr	r2, [r7, #20]
 80229c4:	683b      	ldr	r3, [r7, #0]
 80229c6:	429a      	cmp	r2, r3
 80229c8:	d3e6      	bcc.n	8022998 <lv_txt_utf8_get_byte_id+0x14>
    }

    return byte_cnt;
 80229ca:	693b      	ldr	r3, [r7, #16]
}
 80229cc:	4618      	mov	r0, r3
 80229ce:	3718      	adds	r7, #24
 80229d0:	46bd      	mov	sp, r7
 80229d2:	bd80      	pop	{r7, pc}
 80229d4:	20000200 	.word	0x20000200

080229d8 <lv_txt_utf8_get_char_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param byte_id byte index
 * @return character index of the letter at 'byte_id'th position
 */
static uint32_t lv_txt_utf8_get_char_id(const char * txt, uint32_t byte_id)
{
 80229d8:	b580      	push	{r7, lr}
 80229da:	b084      	sub	sp, #16
 80229dc:	af00      	add	r7, sp, #0
 80229de:	6078      	str	r0, [r7, #4]
 80229e0:	6039      	str	r1, [r7, #0]
    uint32_t i        = 0;
 80229e2:	2300      	movs	r3, #0
 80229e4:	60bb      	str	r3, [r7, #8]
    uint32_t char_cnt = 0;
 80229e6:	2300      	movs	r3, #0
 80229e8:	60fb      	str	r3, [r7, #12]

    while(i < byte_id) {
 80229ea:	e009      	b.n	8022a00 <lv_txt_utf8_get_char_id+0x28>
        _lv_txt_encoded_next(txt, &i); /*'i' points to the next letter so use the prev. value*/
 80229ec:	4b09      	ldr	r3, [pc, #36]	; (8022a14 <lv_txt_utf8_get_char_id+0x3c>)
 80229ee:	681b      	ldr	r3, [r3, #0]
 80229f0:	f107 0208 	add.w	r2, r7, #8
 80229f4:	4611      	mov	r1, r2
 80229f6:	6878      	ldr	r0, [r7, #4]
 80229f8:	4798      	blx	r3
        char_cnt++;
 80229fa:	68fb      	ldr	r3, [r7, #12]
 80229fc:	3301      	adds	r3, #1
 80229fe:	60fb      	str	r3, [r7, #12]
    while(i < byte_id) {
 8022a00:	68bb      	ldr	r3, [r7, #8]
 8022a02:	683a      	ldr	r2, [r7, #0]
 8022a04:	429a      	cmp	r2, r3
 8022a06:	d8f1      	bhi.n	80229ec <lv_txt_utf8_get_char_id+0x14>
    }

    return char_cnt;
 8022a08:	68fb      	ldr	r3, [r7, #12]
}
 8022a0a:	4618      	mov	r0, r3
 8022a0c:	3710      	adds	r7, #16
 8022a0e:	46bd      	mov	sp, r7
 8022a10:	bd80      	pop	{r7, pc}
 8022a12:	bf00      	nop
 8022a14:	20000204 	.word	0x20000204

08022a18 <lv_txt_utf8_get_length>:
 * E.g.: "ÁBC" is 3 characters (but 4 bytes)
 * @param txt a '\0' terminated char string
 * @return number of characters
 */
static uint32_t lv_txt_utf8_get_length(const char * txt)
{
 8022a18:	b580      	push	{r7, lr}
 8022a1a:	b084      	sub	sp, #16
 8022a1c:	af00      	add	r7, sp, #0
 8022a1e:	6078      	str	r0, [r7, #4]
    uint32_t len = 0;
 8022a20:	2300      	movs	r3, #0
 8022a22:	60fb      	str	r3, [r7, #12]
    uint32_t i   = 0;
 8022a24:	2300      	movs	r3, #0
 8022a26:	60bb      	str	r3, [r7, #8]

    while(txt[i] != '\0') {
 8022a28:	e009      	b.n	8022a3e <lv_txt_utf8_get_length+0x26>
        _lv_txt_encoded_next(txt, &i);
 8022a2a:	4b0a      	ldr	r3, [pc, #40]	; (8022a54 <lv_txt_utf8_get_length+0x3c>)
 8022a2c:	681b      	ldr	r3, [r3, #0]
 8022a2e:	f107 0208 	add.w	r2, r7, #8
 8022a32:	4611      	mov	r1, r2
 8022a34:	6878      	ldr	r0, [r7, #4]
 8022a36:	4798      	blx	r3
        len++;
 8022a38:	68fb      	ldr	r3, [r7, #12]
 8022a3a:	3301      	adds	r3, #1
 8022a3c:	60fb      	str	r3, [r7, #12]
    while(txt[i] != '\0') {
 8022a3e:	68bb      	ldr	r3, [r7, #8]
 8022a40:	687a      	ldr	r2, [r7, #4]
 8022a42:	4413      	add	r3, r2
 8022a44:	781b      	ldrb	r3, [r3, #0]
 8022a46:	2b00      	cmp	r3, #0
 8022a48:	d1ef      	bne.n	8022a2a <lv_txt_utf8_get_length+0x12>
    }

    return len;
 8022a4a:	68fb      	ldr	r3, [r7, #12]
}
 8022a4c:	4618      	mov	r0, r3
 8022a4e:	3710      	adds	r7, #16
 8022a50:	46bd      	mov	sp, r7
 8022a52:	bd80      	pop	{r7, pc}
 8022a54:	20000204 	.word	0x20000204

08022a58 <is_break_char>:
 * Test if char is break char or not (a text can broken here or not)
 * @param letter a letter
 * @return false: 'letter' is not break char
 */
static inline bool is_break_char(uint32_t letter)
{
 8022a58:	b480      	push	{r7}
 8022a5a:	b085      	sub	sp, #20
 8022a5c:	af00      	add	r7, sp, #0
 8022a5e:	6078      	str	r0, [r7, #4]
    uint8_t i;
    bool ret = false;
 8022a60:	2300      	movs	r3, #0
 8022a62:	73bb      	strb	r3, [r7, #14]

    /*Compare the letter to TXT_BREAK_CHARS*/
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
 8022a64:	2300      	movs	r3, #0
 8022a66:	73fb      	strb	r3, [r7, #15]
 8022a68:	e00c      	b.n	8022a84 <is_break_char+0x2c>
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
 8022a6a:	7bfb      	ldrb	r3, [r7, #15]
 8022a6c:	4a0b      	ldr	r2, [pc, #44]	; (8022a9c <is_break_char+0x44>)
 8022a6e:	5cd3      	ldrb	r3, [r2, r3]
 8022a70:	461a      	mov	r2, r3
 8022a72:	687b      	ldr	r3, [r7, #4]
 8022a74:	4293      	cmp	r3, r2
 8022a76:	d102      	bne.n	8022a7e <is_break_char+0x26>
            ret = true; /*If match then it is break char*/
 8022a78:	2301      	movs	r3, #1
 8022a7a:	73bb      	strb	r3, [r7, #14]
            break;
 8022a7c:	e007      	b.n	8022a8e <is_break_char+0x36>
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
 8022a7e:	7bfb      	ldrb	r3, [r7, #15]
 8022a80:	3301      	adds	r3, #1
 8022a82:	73fb      	strb	r3, [r7, #15]
 8022a84:	7bfb      	ldrb	r3, [r7, #15]
 8022a86:	4a05      	ldr	r2, [pc, #20]	; (8022a9c <is_break_char+0x44>)
 8022a88:	5cd3      	ldrb	r3, [r2, r3]
 8022a8a:	2b00      	cmp	r3, #0
 8022a8c:	d1ed      	bne.n	8022a6a <is_break_char+0x12>
        }
    }

    return ret;
 8022a8e:	7bbb      	ldrb	r3, [r7, #14]
}
 8022a90:	4618      	mov	r0, r3
 8022a92:	3714      	adds	r7, #20
 8022a94:	46bd      	mov	sp, r7
 8022a96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022a9a:	4770      	bx	lr
 8022a9c:	0802e58c 	.word	0x0802e58c

08022aa0 <_lv_utils_bsearch>:
 *
 * @return a pointer to a matching item, or NULL if none exists.
 */
void * _lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,
                         int32_t (*cmp)(const void * pRef, const void * pElement))
{
 8022aa0:	b580      	push	{r7, lr}
 8022aa2:	b086      	sub	sp, #24
 8022aa4:	af00      	add	r7, sp, #0
 8022aa6:	60f8      	str	r0, [r7, #12]
 8022aa8:	60b9      	str	r1, [r7, #8]
 8022aaa:	607a      	str	r2, [r7, #4]
 8022aac:	603b      	str	r3, [r7, #0]
    const char * middle;
    int32_t c;

    for(middle = base; n != 0;) {
 8022aae:	68bb      	ldr	r3, [r7, #8]
 8022ab0:	617b      	str	r3, [r7, #20]
 8022ab2:	e02d      	b.n	8022b10 <_lv_utils_bsearch+0x70>
        middle += (n / 2) * size;
 8022ab4:	687b      	ldr	r3, [r7, #4]
 8022ab6:	085b      	lsrs	r3, r3, #1
 8022ab8:	683a      	ldr	r2, [r7, #0]
 8022aba:	fb02 f303 	mul.w	r3, r2, r3
 8022abe:	697a      	ldr	r2, [r7, #20]
 8022ac0:	4413      	add	r3, r2
 8022ac2:	617b      	str	r3, [r7, #20]
        if((c = (*cmp)(key, middle)) > 0) {
 8022ac4:	6a3b      	ldr	r3, [r7, #32]
 8022ac6:	6979      	ldr	r1, [r7, #20]
 8022ac8:	68f8      	ldr	r0, [r7, #12]
 8022aca:	4798      	blx	r3
 8022acc:	6138      	str	r0, [r7, #16]
 8022ace:	693b      	ldr	r3, [r7, #16]
 8022ad0:	2b00      	cmp	r3, #0
 8022ad2:	dd12      	ble.n	8022afa <_lv_utils_bsearch+0x5a>
            n    = (n / 2) - ((n & 1) == 0);
 8022ad4:	687b      	ldr	r3, [r7, #4]
 8022ad6:	085b      	lsrs	r3, r3, #1
 8022ad8:	687a      	ldr	r2, [r7, #4]
 8022ada:	f002 0201 	and.w	r2, r2, #1
 8022ade:	2a00      	cmp	r2, #0
 8022ae0:	bf0c      	ite	eq
 8022ae2:	2201      	moveq	r2, #1
 8022ae4:	2200      	movne	r2, #0
 8022ae6:	b2d2      	uxtb	r2, r2
 8022ae8:	1a9b      	subs	r3, r3, r2
 8022aea:	607b      	str	r3, [r7, #4]
            base = (middle += size);
 8022aec:	697a      	ldr	r2, [r7, #20]
 8022aee:	683b      	ldr	r3, [r7, #0]
 8022af0:	4413      	add	r3, r2
 8022af2:	617b      	str	r3, [r7, #20]
 8022af4:	697b      	ldr	r3, [r7, #20]
 8022af6:	60bb      	str	r3, [r7, #8]
 8022af8:	e00a      	b.n	8022b10 <_lv_utils_bsearch+0x70>
        }
        else if(c < 0) {
 8022afa:	693b      	ldr	r3, [r7, #16]
 8022afc:	2b00      	cmp	r3, #0
 8022afe:	da05      	bge.n	8022b0c <_lv_utils_bsearch+0x6c>
            n /= 2;
 8022b00:	687b      	ldr	r3, [r7, #4]
 8022b02:	085b      	lsrs	r3, r3, #1
 8022b04:	607b      	str	r3, [r7, #4]
            middle = base;
 8022b06:	68bb      	ldr	r3, [r7, #8]
 8022b08:	617b      	str	r3, [r7, #20]
 8022b0a:	e001      	b.n	8022b10 <_lv_utils_bsearch+0x70>
        }
        else {
            return (char *)middle;
 8022b0c:	697b      	ldr	r3, [r7, #20]
 8022b0e:	e003      	b.n	8022b18 <_lv_utils_bsearch+0x78>
    for(middle = base; n != 0;) {
 8022b10:	687b      	ldr	r3, [r7, #4]
 8022b12:	2b00      	cmp	r3, #0
 8022b14:	d1ce      	bne.n	8022ab4 <_lv_utils_bsearch+0x14>
        }
    }
    return NULL;
 8022b16:	2300      	movs	r3, #0
}
 8022b18:	4618      	mov	r0, r3
 8022b1a:	3718      	adds	r7, #24
 8022b1c:	46bd      	mov	sp, r7
 8022b1e:	bd80      	pop	{r7, pc}

08022b20 <lv_theme_set_act>:
 * Set a theme for the system.
 * From now, all the created objects will use styles from this theme by default
 * @param th pointer to theme (return value of: 'lv_theme_init_xxx()')
 */
void lv_theme_set_act(lv_theme_t * th)
{
 8022b20:	b480      	push	{r7}
 8022b22:	b083      	sub	sp, #12
 8022b24:	af00      	add	r7, sp, #0
 8022b26:	6078      	str	r0, [r7, #4]
    act_theme = th;
 8022b28:	4a04      	ldr	r2, [pc, #16]	; (8022b3c <lv_theme_set_act+0x1c>)
 8022b2a:	687b      	ldr	r3, [r7, #4]
 8022b2c:	6013      	str	r3, [r2, #0]
}
 8022b2e:	bf00      	nop
 8022b30:	370c      	adds	r7, #12
 8022b32:	46bd      	mov	sp, r7
 8022b34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022b38:	4770      	bx	lr
 8022b3a:	bf00      	nop
 8022b3c:	20012324 	.word	0x20012324

08022b40 <lv_theme_apply>:
 * Apply the active theme on an object
 * @param obj pointer to an object
 * @param name the name of the theme element to apply. E.g. `LV_THEME_BTN`
 */
void lv_theme_apply(lv_obj_t * obj, lv_theme_style_t name)
{
 8022b40:	b580      	push	{r7, lr}
 8022b42:	b082      	sub	sp, #8
 8022b44:	af00      	add	r7, sp, #0
 8022b46:	6078      	str	r0, [r7, #4]
 8022b48:	460b      	mov	r3, r1
 8022b4a:	807b      	strh	r3, [r7, #2]
    /* Remove the existing styles from all part of the object. */
    clear_styles(obj, name);
 8022b4c:	887b      	ldrh	r3, [r7, #2]
 8022b4e:	4619      	mov	r1, r3
 8022b50:	6878      	ldr	r0, [r7, #4]
 8022b52:	f000 f847 	bl	8022be4 <clear_styles>

    /*Apply the theme including the base theme(s)*/

    apply_theme(act_theme, obj, name);
 8022b56:	4b05      	ldr	r3, [pc, #20]	; (8022b6c <lv_theme_apply+0x2c>)
 8022b58:	681b      	ldr	r3, [r3, #0]
 8022b5a:	887a      	ldrh	r2, [r7, #2]
 8022b5c:	6879      	ldr	r1, [r7, #4]
 8022b5e:	4618      	mov	r0, r3
 8022b60:	f000 f812 	bl	8022b88 <apply_theme>
}
 8022b64:	bf00      	nop
 8022b66:	3708      	adds	r7, #8
 8022b68:	46bd      	mov	sp, r7
 8022b6a:	bd80      	pop	{r7, pc}
 8022b6c:	20012324 	.word	0x20012324

08022b70 <lv_theme_get_font_normal>:
/**
 * Get the normal font of the theme
 * @return pointer to the font
 */
const lv_font_t * lv_theme_get_font_normal(void)
{
 8022b70:	b480      	push	{r7}
 8022b72:	af00      	add	r7, sp, #0
    return act_theme->font_normal;
 8022b74:	4b03      	ldr	r3, [pc, #12]	; (8022b84 <lv_theme_get_font_normal+0x14>)
 8022b76:	681b      	ldr	r3, [r3, #0]
 8022b78:	695b      	ldr	r3, [r3, #20]
}
 8022b7a:	4618      	mov	r0, r3
 8022b7c:	46bd      	mov	sp, r7
 8022b7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022b82:	4770      	bx	lr
 8022b84:	20012324 	.word	0x20012324

08022b88 <apply_theme>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void apply_theme(lv_theme_t * th, lv_obj_t * obj, lv_theme_style_t name)
{
 8022b88:	b580      	push	{r7, lr}
 8022b8a:	b084      	sub	sp, #16
 8022b8c:	af00      	add	r7, sp, #0
 8022b8e:	60f8      	str	r0, [r7, #12]
 8022b90:	60b9      	str	r1, [r7, #8]
 8022b92:	4613      	mov	r3, r2
 8022b94:	80fb      	strh	r3, [r7, #6]
    if(th->base) {
 8022b96:	68fb      	ldr	r3, [r7, #12]
 8022b98:	689b      	ldr	r3, [r3, #8]
 8022b9a:	2b00      	cmp	r3, #0
 8022b9c:	d006      	beq.n	8022bac <apply_theme+0x24>
        apply_theme(th->base, obj, name);
 8022b9e:	68fb      	ldr	r3, [r7, #12]
 8022ba0:	689b      	ldr	r3, [r3, #8]
 8022ba2:	88fa      	ldrh	r2, [r7, #6]
 8022ba4:	68b9      	ldr	r1, [r7, #8]
 8022ba6:	4618      	mov	r0, r3
 8022ba8:	f7ff ffee 	bl	8022b88 <apply_theme>
    }

    /*apply_xcb is deprecated, use apply_cb instead*/
    if(th->apply_xcb) {
 8022bac:	68fb      	ldr	r3, [r7, #12]
 8022bae:	685b      	ldr	r3, [r3, #4]
 8022bb0:	2b00      	cmp	r3, #0
 8022bb2:	d006      	beq.n	8022bc2 <apply_theme+0x3a>
        th->apply_xcb(obj, name);
 8022bb4:	68fb      	ldr	r3, [r7, #12]
 8022bb6:	685b      	ldr	r3, [r3, #4]
 8022bb8:	88fa      	ldrh	r2, [r7, #6]
 8022bba:	4611      	mov	r1, r2
 8022bbc:	68b8      	ldr	r0, [r7, #8]
 8022bbe:	4798      	blx	r3
    }
    else if(th->apply_cb) {
        th->apply_cb(act_theme, obj, name);
    }
}
 8022bc0:	e00a      	b.n	8022bd8 <apply_theme+0x50>
    else if(th->apply_cb) {
 8022bc2:	68fb      	ldr	r3, [r7, #12]
 8022bc4:	681b      	ldr	r3, [r3, #0]
 8022bc6:	2b00      	cmp	r3, #0
 8022bc8:	d006      	beq.n	8022bd8 <apply_theme+0x50>
        th->apply_cb(act_theme, obj, name);
 8022bca:	68fb      	ldr	r3, [r7, #12]
 8022bcc:	681b      	ldr	r3, [r3, #0]
 8022bce:	4a04      	ldr	r2, [pc, #16]	; (8022be0 <apply_theme+0x58>)
 8022bd0:	6810      	ldr	r0, [r2, #0]
 8022bd2:	88fa      	ldrh	r2, [r7, #6]
 8022bd4:	68b9      	ldr	r1, [r7, #8]
 8022bd6:	4798      	blx	r3
}
 8022bd8:	bf00      	nop
 8022bda:	3710      	adds	r7, #16
 8022bdc:	46bd      	mov	sp, r7
 8022bde:	bd80      	pop	{r7, pc}
 8022be0:	20012324 	.word	0x20012324

08022be4 <clear_styles>:

static void clear_styles(lv_obj_t * obj, lv_theme_style_t name)
{
 8022be4:	b580      	push	{r7, lr}
 8022be6:	b082      	sub	sp, #8
 8022be8:	af00      	add	r7, sp, #0
 8022bea:	6078      	str	r0, [r7, #4]
 8022bec:	460b      	mov	r3, r1
 8022bee:	807b      	strh	r3, [r7, #2]
    switch(name) {
 8022bf0:	887b      	ldrh	r3, [r7, #2]
 8022bf2:	2b29      	cmp	r3, #41	; 0x29
 8022bf4:	f200 81d4 	bhi.w	8022fa0 <clear_styles+0x3bc>
 8022bf8:	a201      	add	r2, pc, #4	; (adr r2, 8022c00 <clear_styles+0x1c>)
 8022bfa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8022bfe:	bf00      	nop
 8022c00:	08022fa1 	.word	0x08022fa1
 8022c04:	08022ca9 	.word	0x08022ca9
 8022c08:	08022cb3 	.word	0x08022cb3
 8022c0c:	08022d53 	.word	0x08022d53
 8022c10:	08022cf5 	.word	0x08022cf5
 8022c14:	08022cc7 	.word	0x08022cc7
 8022c18:	08022cd1 	.word	0x08022cd1
 8022c1c:	08022f49 	.word	0x08022f49
 8022c20:	08022d21 	.word	0x08022d21
 8022c24:	08022d91 	.word	0x08022d91
 8022c28:	08022e9b 	.word	0x08022e9b
 8022c2c:	08022cbd 	.word	0x08022cbd
 8022c30:	08022f6b 	.word	0x08022f6b
 8022c34:	08022e79 	.word	0x08022e79
 8022c38:	08022f87 	.word	0x08022f87
 8022c3c:	08022d2b 	.word	0x08022d2b
 8022c40:	08022d35 	.word	0x08022d35
 8022c44:	08022ce3 	.word	0x08022ce3
 8022c48:	08022d3f 	.word	0x08022d3f
 8022c4c:	08022dbf 	.word	0x08022dbf
 8022c50:	08022d49 	.word	0x08022d49
 8022c54:	08022e55 	.word	0x08022e55
 8022c58:	08022e6f 	.word	0x08022e6f
 8022c5c:	08022f7d 	.word	0x08022f7d
 8022c60:	08022da3 	.word	0x08022da3
 8022c64:	08022dad 	.word	0x08022dad
 8022c68:	08022e4b 	.word	0x08022e4b
 8022c6c:	08022dc9 	.word	0x08022dc9
 8022c70:	08022e39 	.word	0x08022e39
 8022c74:	08022fa1 	.word	0x08022fa1
 8022c78:	08022d77 	.word	0x08022d77
 8022c7c:	08022f2d 	.word	0x08022f2d
 8022c80:	08022f3f 	.word	0x08022f3f
 8022c84:	08022d65 	.word	0x08022d65
 8022c88:	08022d07 	.word	0x08022d07
 8022c8c:	08022eb5 	.word	0x08022eb5
 8022c90:	08022de3 	.word	0x08022de3
 8022c94:	08022e0d 	.word	0x08022e0d
 8022c98:	08022f0b 	.word	0x08022f0b
 8022c9c:	08022e1f 	.word	0x08022e1f
 8022ca0:	08022edf 	.word	0x08022edf
 8022ca4:	08022f01 	.word	0x08022f01
        case LV_THEME_NONE:
            break;

        case LV_THEME_SCR:
            lv_obj_clean_style_list(obj, LV_OBJ_PART_MAIN);
 8022ca8:	2100      	movs	r1, #0
 8022caa:	6878      	ldr	r0, [r7, #4]
 8022cac:	f7e7 face 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022cb0:	e177      	b.n	8022fa2 <clear_styles+0x3be>
        case LV_THEME_OBJ:
            lv_obj_clean_style_list(obj, LV_OBJ_PART_MAIN);
 8022cb2:	2100      	movs	r1, #0
 8022cb4:	6878      	ldr	r0, [r7, #4]
 8022cb6:	f7e7 fac9 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022cba:	e172      	b.n	8022fa2 <clear_styles+0x3be>
#if LV_USE_CONT
        case LV_THEME_CONT:
            lv_obj_clean_style_list(obj, LV_OBJ_PART_MAIN);
 8022cbc:	2100      	movs	r1, #0
 8022cbe:	6878      	ldr	r0, [r7, #4]
 8022cc0:	f7e7 fac4 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022cc4:	e16d      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_BTN
        case LV_THEME_BTN:
            lv_obj_clean_style_list(obj, LV_BTN_PART_MAIN);
 8022cc6:	2100      	movs	r1, #0
 8022cc8:	6878      	ldr	r0, [r7, #4]
 8022cca:	f7e7 fabf 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022cce:	e168      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_BTNMATRIX
        case LV_THEME_BTNMATRIX:
            lv_obj_clean_style_list(obj, LV_BTNMATRIX_PART_BG);
 8022cd0:	2100      	movs	r1, #0
 8022cd2:	6878      	ldr	r0, [r7, #4]
 8022cd4:	f7e7 faba 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_BTNMATRIX_PART_BTN);
 8022cd8:	2101      	movs	r1, #1
 8022cda:	6878      	ldr	r0, [r7, #4]
 8022cdc:	f7e7 fab6 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022ce0:	e15f      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_KEYBOARD
        case LV_THEME_KEYBOARD:
            lv_obj_clean_style_list(obj, LV_KEYBOARD_PART_BG);
 8022ce2:	2100      	movs	r1, #0
 8022ce4:	6878      	ldr	r0, [r7, #4]
 8022ce6:	f7e7 fab1 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_KEYBOARD_PART_BTN);
 8022cea:	2101      	movs	r1, #1
 8022cec:	6878      	ldr	r0, [r7, #4]
 8022cee:	f7e7 faad 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022cf2:	e156      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_BAR
        case LV_THEME_BAR:
            lv_obj_clean_style_list(obj, LV_BAR_PART_BG);
 8022cf4:	2100      	movs	r1, #0
 8022cf6:	6878      	ldr	r0, [r7, #4]
 8022cf8:	f7e7 faa8 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_BAR_PART_INDIC);
 8022cfc:	2101      	movs	r1, #1
 8022cfe:	6878      	ldr	r0, [r7, #4]
 8022d00:	f7e7 faa4 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022d04:	e14d      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_SWITCH
        case LV_THEME_SWITCH:
            lv_obj_clean_style_list(obj, LV_SWITCH_PART_BG);
 8022d06:	2100      	movs	r1, #0
 8022d08:	6878      	ldr	r0, [r7, #4]
 8022d0a:	f7e7 fa9f 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_SWITCH_PART_INDIC);
 8022d0e:	2101      	movs	r1, #1
 8022d10:	6878      	ldr	r0, [r7, #4]
 8022d12:	f7e7 fa9b 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_SWITCH_PART_KNOB);
 8022d16:	2102      	movs	r1, #2
 8022d18:	6878      	ldr	r0, [r7, #4]
 8022d1a:	f7e7 fa97 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022d1e:	e140      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_CANVAS
        case LV_THEME_CANVAS:
            lv_obj_clean_style_list(obj, LV_CANVAS_PART_MAIN);
 8022d20:	2100      	movs	r1, #0
 8022d22:	6878      	ldr	r0, [r7, #4]
 8022d24:	f7e7 fa92 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022d28:	e13b      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_IMG
        case LV_THEME_IMAGE:
            lv_obj_clean_style_list(obj, LV_IMG_PART_MAIN);
 8022d2a:	2100      	movs	r1, #0
 8022d2c:	6878      	ldr	r0, [r7, #4]
 8022d2e:	f7e7 fa8d 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022d32:	e136      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_IMGBTN
        case LV_THEME_IMGBTN:
            lv_obj_clean_style_list(obj, LV_IMG_PART_MAIN);
 8022d34:	2100      	movs	r1, #0
 8022d36:	6878      	ldr	r0, [r7, #4]
 8022d38:	f7e7 fa88 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022d3c:	e131      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_LABEL
        case LV_THEME_LABEL:
            lv_obj_clean_style_list(obj, LV_LABEL_PART_MAIN);
 8022d3e:	2100      	movs	r1, #0
 8022d40:	6878      	ldr	r0, [r7, #4]
 8022d42:	f7e7 fa83 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022d46:	e12c      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_LINE
        case LV_THEME_LINE:
            lv_obj_clean_style_list(obj, LV_LABEL_PART_MAIN);
 8022d48:	2100      	movs	r1, #0
 8022d4a:	6878      	ldr	r0, [r7, #4]
 8022d4c:	f7e7 fa7e 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022d50:	e127      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_ARC
        case LV_THEME_ARC:
            lv_obj_clean_style_list(obj, LV_ARC_PART_BG);
 8022d52:	2100      	movs	r1, #0
 8022d54:	6878      	ldr	r0, [r7, #4]
 8022d56:	f7e7 fa79 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_ARC_PART_INDIC);
 8022d5a:	2101      	movs	r1, #1
 8022d5c:	6878      	ldr	r0, [r7, #4]
 8022d5e:	f7e7 fa75 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022d62:	e11e      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_SPINNER
        case LV_THEME_SPINNER:
            lv_obj_clean_style_list(obj, LV_SPINNER_PART_BG);
 8022d64:	2100      	movs	r1, #0
 8022d66:	6878      	ldr	r0, [r7, #4]
 8022d68:	f7e7 fa70 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_SPINNER_PART_INDIC);
 8022d6c:	2101      	movs	r1, #1
 8022d6e:	6878      	ldr	r0, [r7, #4]
 8022d70:	f7e7 fa6c 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022d74:	e115      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_SLIDER
        case LV_THEME_SLIDER:
            lv_obj_clean_style_list(obj, LV_SLIDER_PART_BG);
 8022d76:	2100      	movs	r1, #0
 8022d78:	6878      	ldr	r0, [r7, #4]
 8022d7a:	f7e7 fa67 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_SLIDER_PART_INDIC);
 8022d7e:	2101      	movs	r1, #1
 8022d80:	6878      	ldr	r0, [r7, #4]
 8022d82:	f7e7 fa63 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_SLIDER_PART_KNOB);
 8022d86:	2102      	movs	r1, #2
 8022d88:	6878      	ldr	r0, [r7, #4]
 8022d8a:	f7e7 fa5f 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022d8e:	e108      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_CHECKBOX
        case LV_THEME_CHECKBOX:
            lv_obj_clean_style_list(obj, LV_CHECKBOX_PART_BG);
 8022d90:	2100      	movs	r1, #0
 8022d92:	6878      	ldr	r0, [r7, #4]
 8022d94:	f7e7 fa5a 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_CHECKBOX_PART_BULLET);
 8022d98:	2140      	movs	r1, #64	; 0x40
 8022d9a:	6878      	ldr	r0, [r7, #4]
 8022d9c:	f7e7 fa56 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022da0:	e0ff      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_MSGBOX
        case LV_THEME_MSGBOX:
            lv_obj_clean_style_list(obj, LV_MSGBOX_PART_BG);
 8022da2:	2100      	movs	r1, #0
 8022da4:	6878      	ldr	r0, [r7, #4]
 8022da6:	f7e7 fa51 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022daa:	e0fa      	b.n	8022fa2 <clear_styles+0x3be>

        case LV_THEME_MSGBOX_BTNS:
            lv_obj_clean_style_list(obj, LV_MSGBOX_PART_BTN_BG);
 8022dac:	2140      	movs	r1, #64	; 0x40
 8022dae:	6878      	ldr	r0, [r7, #4]
 8022db0:	f7e7 fa4c 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_MSGBOX_PART_BTN);
 8022db4:	2141      	movs	r1, #65	; 0x41
 8022db6:	6878      	ldr	r0, [r7, #4]
 8022db8:	f7e7 fa48 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022dbc:	e0f1      	b.n	8022fa2 <clear_styles+0x3be>

#endif
#if LV_USE_LED
        case LV_THEME_LED:
            lv_obj_clean_style_list(obj, LV_LED_PART_MAIN);
 8022dbe:	2100      	movs	r1, #0
 8022dc0:	6878      	ldr	r0, [r7, #4]
 8022dc2:	f7e7 fa43 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022dc6:	e0ec      	b.n	8022fa2 <clear_styles+0x3be>
#endif
#if LV_USE_PAGE
        case LV_THEME_PAGE:
            lv_obj_clean_style_list(obj, LV_PAGE_PART_BG);
 8022dc8:	2100      	movs	r1, #0
 8022dca:	6878      	ldr	r0, [r7, #4]
 8022dcc:	f7e7 fa3e 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_PAGE_PART_SCROLLABLE);
 8022dd0:	2140      	movs	r1, #64	; 0x40
 8022dd2:	6878      	ldr	r0, [r7, #4]
 8022dd4:	f7e7 fa3a 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_PAGE_PART_SCROLLBAR);
 8022dd8:	2101      	movs	r1, #1
 8022dda:	6878      	ldr	r0, [r7, #4]
 8022ddc:	f7e7 fa36 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022de0:	e0df      	b.n	8022fa2 <clear_styles+0x3be>
#endif
#if LV_USE_TABVIEW
        case LV_THEME_TABVIEW:
            lv_obj_clean_style_list(obj, LV_TABVIEW_PART_BG);
 8022de2:	2100      	movs	r1, #0
 8022de4:	6878      	ldr	r0, [r7, #4]
 8022de6:	f7e7 fa31 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TABVIEW_PART_BG_SCRLLABLE);
 8022dea:	2140      	movs	r1, #64	; 0x40
 8022dec:	6878      	ldr	r0, [r7, #4]
 8022dee:	f7e7 fa2d 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TABVIEW_PART_TAB_BG);
 8022df2:	2141      	movs	r1, #65	; 0x41
 8022df4:	6878      	ldr	r0, [r7, #4]
 8022df6:	f7e7 fa29 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TABVIEW_PART_INDIC);
 8022dfa:	2143      	movs	r1, #67	; 0x43
 8022dfc:	6878      	ldr	r0, [r7, #4]
 8022dfe:	f7e7 fa25 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TABVIEW_PART_TAB_BTN);
 8022e02:	2142      	movs	r1, #66	; 0x42
 8022e04:	6878      	ldr	r0, [r7, #4]
 8022e06:	f7e7 fa21 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022e0a:	e0ca      	b.n	8022fa2 <clear_styles+0x3be>

        case LV_THEME_TABVIEW_PAGE:
            lv_obj_clean_style_list(obj, LV_PAGE_PART_BG);
 8022e0c:	2100      	movs	r1, #0
 8022e0e:	6878      	ldr	r0, [r7, #4]
 8022e10:	f7e7 fa1c 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_PAGE_PART_SCROLLABLE);
 8022e14:	2140      	movs	r1, #64	; 0x40
 8022e16:	6878      	ldr	r0, [r7, #4]
 8022e18:	f7e7 fa18 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022e1c:	e0c1      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_TILEVIEW
        case LV_THEME_TILEVIEW:
            lv_obj_clean_style_list(obj, LV_TILEVIEW_PART_BG);
 8022e1e:	2100      	movs	r1, #0
 8022e20:	6878      	ldr	r0, [r7, #4]
 8022e22:	f7e7 fa13 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TILEVIEW_PART_SCROLLBAR);
 8022e26:	2101      	movs	r1, #1
 8022e28:	6878      	ldr	r0, [r7, #4]
 8022e2a:	f7e7 fa0f 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TILEVIEW_PART_EDGE_FLASH);
 8022e2e:	2102      	movs	r1, #2
 8022e30:	6878      	ldr	r0, [r7, #4]
 8022e32:	f7e7 fa0b 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022e36:	e0b4      	b.n	8022fa2 <clear_styles+0x3be>
#endif


#if LV_USE_ROLLER
        case LV_THEME_ROLLER:
            lv_obj_clean_style_list(obj, LV_ROLLER_PART_BG);
 8022e38:	2100      	movs	r1, #0
 8022e3a:	6878      	ldr	r0, [r7, #4]
 8022e3c:	f7e7 fa06 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_ROLLER_PART_SELECTED);
 8022e40:	2103      	movs	r1, #3
 8022e42:	6878      	ldr	r0, [r7, #4]
 8022e44:	f7e7 fa02 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022e48:	e0ab      	b.n	8022fa2 <clear_styles+0x3be>
#endif


#if LV_USE_OBJMASK
        case LV_THEME_OBJMASK:
            lv_obj_clean_style_list(obj, LV_OBJMASK_PART_MAIN);
 8022e4a:	2100      	movs	r1, #0
 8022e4c:	6878      	ldr	r0, [r7, #4]
 8022e4e:	f7e7 f9fd 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022e52:	e0a6      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_LIST
        case LV_THEME_LIST:
            lv_obj_clean_style_list(obj, LV_LIST_PART_BG);
 8022e54:	2100      	movs	r1, #0
 8022e56:	6878      	ldr	r0, [r7, #4]
 8022e58:	f7e7 f9f8 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_LIST_PART_SCROLLABLE);
 8022e5c:	2140      	movs	r1, #64	; 0x40
 8022e5e:	6878      	ldr	r0, [r7, #4]
 8022e60:	f7e7 f9f4 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_LIST_PART_SCROLLBAR);
 8022e64:	2101      	movs	r1, #1
 8022e66:	6878      	ldr	r0, [r7, #4]
 8022e68:	f7e7 f9f0 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022e6c:	e099      	b.n	8022fa2 <clear_styles+0x3be>

        case LV_THEME_LIST_BTN:
            lv_obj_clean_style_list(obj, LV_BTN_PART_MAIN);
 8022e6e:	2100      	movs	r1, #0
 8022e70:	6878      	ldr	r0, [r7, #4]
 8022e72:	f7e7 f9eb 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022e76:	e094      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_DROPDOWN
        case LV_THEME_DROPDOWN:
            lv_obj_clean_style_list(obj, LV_DROPDOWN_PART_MAIN);
 8022e78:	2100      	movs	r1, #0
 8022e7a:	6878      	ldr	r0, [r7, #4]
 8022e7c:	f7e7 f9e6 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_DROPDOWN_PART_LIST);
 8022e80:	2140      	movs	r1, #64	; 0x40
 8022e82:	6878      	ldr	r0, [r7, #4]
 8022e84:	f7e7 f9e2 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_DROPDOWN_PART_SCROLLBAR);
 8022e88:	2141      	movs	r1, #65	; 0x41
 8022e8a:	6878      	ldr	r0, [r7, #4]
 8022e8c:	f7e7 f9de 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_DROPDOWN_PART_SELECTED);
 8022e90:	2142      	movs	r1, #66	; 0x42
 8022e92:	6878      	ldr	r0, [r7, #4]
 8022e94:	f7e7 f9da 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022e98:	e083      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_CHART
        case LV_THEME_CHART:
            lv_obj_clean_style_list(obj, LV_CHART_PART_BG);
 8022e9a:	2100      	movs	r1, #0
 8022e9c:	6878      	ldr	r0, [r7, #4]
 8022e9e:	f7e7 f9d5 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_CHART_PART_SERIES_BG);
 8022ea2:	2101      	movs	r1, #1
 8022ea4:	6878      	ldr	r0, [r7, #4]
 8022ea6:	f7e7 f9d1 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_CHART_PART_SERIES);
 8022eaa:	2102      	movs	r1, #2
 8022eac:	6878      	ldr	r0, [r7, #4]
 8022eae:	f7e7 f9cd 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022eb2:	e076      	b.n	8022fa2 <clear_styles+0x3be>
#endif
#if LV_USE_TABLE
        case LV_THEME_TABLE:
            lv_obj_clean_style_list(obj, LV_TABLE_PART_BG);
 8022eb4:	2100      	movs	r1, #0
 8022eb6:	6878      	ldr	r0, [r7, #4]
 8022eb8:	f7e7 f9c8 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TABLE_PART_CELL1);
 8022ebc:	2101      	movs	r1, #1
 8022ebe:	6878      	ldr	r0, [r7, #4]
 8022ec0:	f7e7 f9c4 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TABLE_PART_CELL2);
 8022ec4:	2102      	movs	r1, #2
 8022ec6:	6878      	ldr	r0, [r7, #4]
 8022ec8:	f7e7 f9c0 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TABLE_PART_CELL3);
 8022ecc:	2103      	movs	r1, #3
 8022ece:	6878      	ldr	r0, [r7, #4]
 8022ed0:	f7e7 f9bc 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TABLE_PART_CELL4);
 8022ed4:	2104      	movs	r1, #4
 8022ed6:	6878      	ldr	r0, [r7, #4]
 8022ed8:	f7e7 f9b8 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022edc:	e061      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_WIN
        case LV_THEME_WIN:
            lv_obj_clean_style_list(obj, LV_WIN_PART_BG);
 8022ede:	2100      	movs	r1, #0
 8022ee0:	6878      	ldr	r0, [r7, #4]
 8022ee2:	f7e7 f9b3 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_WIN_PART_SCROLLBAR);
 8022ee6:	2142      	movs	r1, #66	; 0x42
 8022ee8:	6878      	ldr	r0, [r7, #4]
 8022eea:	f7e7 f9af 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_WIN_PART_CONTENT_SCROLLABLE);
 8022eee:	2141      	movs	r1, #65	; 0x41
 8022ef0:	6878      	ldr	r0, [r7, #4]
 8022ef2:	f7e7 f9ab 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_WIN_PART_HEADER);
 8022ef6:	2140      	movs	r1, #64	; 0x40
 8022ef8:	6878      	ldr	r0, [r7, #4]
 8022efa:	f7e7 f9a7 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022efe:	e050      	b.n	8022fa2 <clear_styles+0x3be>

        case LV_THEME_WIN_BTN:
            lv_obj_clean_style_list(obj, LV_BTN_PART_MAIN);
 8022f00:	2100      	movs	r1, #0
 8022f02:	6878      	ldr	r0, [r7, #4]
 8022f04:	f7e7 f9a2 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022f08:	e04b      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_TEXTAREA
        case LV_THEME_TEXTAREA:
            lv_obj_clean_style_list(obj, LV_TEXTAREA_PART_BG);
 8022f0a:	2100      	movs	r1, #0
 8022f0c:	6878      	ldr	r0, [r7, #4]
 8022f0e:	f7e7 f99d 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TEXTAREA_PART_PLACEHOLDER);
 8022f12:	2104      	movs	r1, #4
 8022f14:	6878      	ldr	r0, [r7, #4]
 8022f16:	f7e7 f999 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TEXTAREA_PART_CURSOR);
 8022f1a:	2103      	movs	r1, #3
 8022f1c:	6878      	ldr	r0, [r7, #4]
 8022f1e:	f7e7 f995 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_TEXTAREA_PART_SCROLLBAR);
 8022f22:	2101      	movs	r1, #1
 8022f24:	6878      	ldr	r0, [r7, #4]
 8022f26:	f7e7 f991 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022f2a:	e03a      	b.n	8022fa2 <clear_styles+0x3be>
#endif


#if LV_USE_SPINBOX
        case LV_THEME_SPINBOX:
            lv_obj_clean_style_list(obj, LV_SPINBOX_PART_BG);
 8022f2c:	2100      	movs	r1, #0
 8022f2e:	6878      	ldr	r0, [r7, #4]
 8022f30:	f7e7 f98c 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_SPINBOX_PART_CURSOR);
 8022f34:	2103      	movs	r1, #3
 8022f36:	6878      	ldr	r0, [r7, #4]
 8022f38:	f7e7 f988 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022f3c:	e031      	b.n	8022fa2 <clear_styles+0x3be>

        case LV_THEME_SPINBOX_BTN:
            lv_obj_clean_style_list(obj, LV_BTN_PART_MAIN);
 8022f3e:	2100      	movs	r1, #0
 8022f40:	6878      	ldr	r0, [r7, #4]
 8022f42:	f7e7 f983 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022f46:	e02c      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_CALENDAR
        case LV_THEME_CALENDAR:
            lv_obj_clean_style_list(obj, LV_CALENDAR_PART_BG);
 8022f48:	2100      	movs	r1, #0
 8022f4a:	6878      	ldr	r0, [r7, #4]
 8022f4c:	f7e7 f97e 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_CALENDAR_PART_DATE);
 8022f50:	2103      	movs	r1, #3
 8022f52:	6878      	ldr	r0, [r7, #4]
 8022f54:	f7e7 f97a 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_CALENDAR_PART_HEADER);
 8022f58:	2101      	movs	r1, #1
 8022f5a:	6878      	ldr	r0, [r7, #4]
 8022f5c:	f7e7 f976 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_CALENDAR_PART_DAY_NAMES);
 8022f60:	2102      	movs	r1, #2
 8022f62:	6878      	ldr	r0, [r7, #4]
 8022f64:	f7e7 f972 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022f68:	e01b      	b.n	8022fa2 <clear_styles+0x3be>
#endif
#if LV_USE_CPICKER
        case LV_THEME_CPICKER:
            lv_obj_clean_style_list(obj, LV_CPICKER_PART_MAIN);
 8022f6a:	2100      	movs	r1, #0
 8022f6c:	6878      	ldr	r0, [r7, #4]
 8022f6e:	f7e7 f96d 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_CPICKER_PART_KNOB);
 8022f72:	2101      	movs	r1, #1
 8022f74:	6878      	ldr	r0, [r7, #4]
 8022f76:	f7e7 f969 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022f7a:	e012      	b.n	8022fa2 <clear_styles+0x3be>
#endif

#if LV_USE_LINEMETER
        case LV_THEME_LINEMETER:
            lv_obj_clean_style_list(obj, LV_LINEMETER_PART_MAIN);
 8022f7c:	2100      	movs	r1, #0
 8022f7e:	6878      	ldr	r0, [r7, #4]
 8022f80:	f7e7 f964 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022f84:	e00d      	b.n	8022fa2 <clear_styles+0x3be>
#endif
#if LV_USE_GAUGE
        case LV_THEME_GAUGE:
            lv_obj_clean_style_list(obj, LV_GAUGE_PART_MAIN);
 8022f86:	2100      	movs	r1, #0
 8022f88:	6878      	ldr	r0, [r7, #4]
 8022f8a:	f7e7 f95f 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_GAUGE_PART_MAJOR);
 8022f8e:	2101      	movs	r1, #1
 8022f90:	6878      	ldr	r0, [r7, #4]
 8022f92:	f7e7 f95b 	bl	800a24c <lv_obj_clean_style_list>
            lv_obj_clean_style_list(obj, LV_GAUGE_PART_NEEDLE);
 8022f96:	2102      	movs	r1, #2
 8022f98:	6878      	ldr	r0, [r7, #4]
 8022f9a:	f7e7 f957 	bl	800a24c <lv_obj_clean_style_list>
            break;
 8022f9e:	e000      	b.n	8022fa2 <clear_styles+0x3be>
#endif
        default:
            break;
 8022fa0:	bf00      	nop
    }

}
 8022fa2:	bf00      	nop
 8022fa4:	3708      	adds	r7, #8
 8022fa6:	46bd      	mov	sp, r7
 8022fa8:	bd80      	pop	{r7, pc}
 8022faa:	bf00      	nop

08022fac <lv_color_mix>:
 * @param c2 the second color to mix (usually the background)
 * @param mix The ratio of the colors. 0: full `c2`, 255: full `c1`, 127: half `c1` and half`c2`
 * @return the mixed color
 */
LV_ATTRIBUTE_FAST_MEM static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
 8022fac:	b480      	push	{r7}
 8022fae:	b085      	sub	sp, #20
 8022fb0:	af00      	add	r7, sp, #0
 8022fb2:	80b8      	strh	r0, [r7, #4]
 8022fb4:	8039      	strh	r1, [r7, #0]
 8022fb6:	4613      	mov	r3, r2
 8022fb8:	70fb      	strb	r3, [r7, #3]
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    LV_COLOR_SET_R(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_R(c1) * mix + LV_COLOR_GET_R(c2) *
 8022fba:	797b      	ldrb	r3, [r7, #5]
 8022fbc:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8022fc0:	b2db      	uxtb	r3, r3
 8022fc2:	461a      	mov	r2, r3
 8022fc4:	78fb      	ldrb	r3, [r7, #3]
 8022fc6:	fb03 f202 	mul.w	r2, r3, r2
 8022fca:	787b      	ldrb	r3, [r7, #1]
 8022fcc:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8022fd0:	b2db      	uxtb	r3, r3
 8022fd2:	4619      	mov	r1, r3
 8022fd4:	78fb      	ldrb	r3, [r7, #3]
 8022fd6:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8022fda:	fb01 f303 	mul.w	r3, r1, r3
 8022fde:	4413      	add	r3, r2
 8022fe0:	3380      	adds	r3, #128	; 0x80
 8022fe2:	461a      	mov	r2, r3
 8022fe4:	4613      	mov	r3, r2
 8022fe6:	021b      	lsls	r3, r3, #8
 8022fe8:	4413      	add	r3, r2
 8022fea:	01db      	lsls	r3, r3, #7
 8022fec:	4413      	add	r3, r2
 8022fee:	0ddb      	lsrs	r3, r3, #23
 8022ff0:	f003 031f 	and.w	r3, r3, #31
 8022ff4:	b2da      	uxtb	r2, r3
 8022ff6:	7b7b      	ldrb	r3, [r7, #13]
 8022ff8:	f362 03c7 	bfi	r3, r2, #3, #5
 8022ffc:	737b      	strb	r3, [r7, #13]
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_G(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_G(c1) * mix + LV_COLOR_GET_G(c2) *
 8022ffe:	88bb      	ldrh	r3, [r7, #4]
 8023000:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8023004:	b2db      	uxtb	r3, r3
 8023006:	461a      	mov	r2, r3
 8023008:	78fb      	ldrb	r3, [r7, #3]
 802300a:	fb03 f202 	mul.w	r2, r3, r2
 802300e:	883b      	ldrh	r3, [r7, #0]
 8023010:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8023014:	b2db      	uxtb	r3, r3
 8023016:	4619      	mov	r1, r3
 8023018:	78fb      	ldrb	r3, [r7, #3]
 802301a:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 802301e:	fb01 f303 	mul.w	r3, r1, r3
 8023022:	4413      	add	r3, r2
 8023024:	3380      	adds	r3, #128	; 0x80
 8023026:	461a      	mov	r2, r3
 8023028:	4613      	mov	r3, r2
 802302a:	021b      	lsls	r3, r3, #8
 802302c:	4413      	add	r3, r2
 802302e:	01db      	lsls	r3, r3, #7
 8023030:	4413      	add	r3, r2
 8023032:	0ddb      	lsrs	r3, r3, #23
 8023034:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8023038:	b2da      	uxtb	r2, r3
 802303a:	89bb      	ldrh	r3, [r7, #12]
 802303c:	f362 134a 	bfi	r3, r2, #5, #6
 8023040:	81bb      	strh	r3, [r7, #12]
                                        (255 - mix) + LV_COLOR_MIX_ROUND_OFS));
    LV_COLOR_SET_B(ret, LV_MATH_UDIV255((uint16_t) LV_COLOR_GET_B(c1) * mix + LV_COLOR_GET_B(c2) *
 8023042:	793b      	ldrb	r3, [r7, #4]
 8023044:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8023048:	b2db      	uxtb	r3, r3
 802304a:	461a      	mov	r2, r3
 802304c:	78fb      	ldrb	r3, [r7, #3]
 802304e:	fb03 f202 	mul.w	r2, r3, r2
 8023052:	783b      	ldrb	r3, [r7, #0]
 8023054:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8023058:	b2db      	uxtb	r3, r3
 802305a:	4619      	mov	r1, r3
 802305c:	78fb      	ldrb	r3, [r7, #3]
 802305e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8023062:	fb01 f303 	mul.w	r3, r1, r3
 8023066:	4413      	add	r3, r2
 8023068:	3380      	adds	r3, #128	; 0x80
 802306a:	461a      	mov	r2, r3
 802306c:	4613      	mov	r3, r2
 802306e:	021b      	lsls	r3, r3, #8
 8023070:	4413      	add	r3, r2
 8023072:	01db      	lsls	r3, r3, #7
 8023074:	4413      	add	r3, r2
 8023076:	0ddb      	lsrs	r3, r3, #23
 8023078:	f003 031f 	and.w	r3, r3, #31
 802307c:	b2da      	uxtb	r2, r3
 802307e:	7b3b      	ldrb	r3, [r7, #12]
 8023080:	f362 0304 	bfi	r3, r2, #0, #5
 8023084:	733b      	strb	r3, [r7, #12]
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
 8023086:	89bb      	ldrh	r3, [r7, #12]
}
 8023088:	4618      	mov	r0, r3
 802308a:	3714      	adds	r7, #20
 802308c:	46bd      	mov	sp, r7
 802308e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023092:	4770      	bx	lr

08023094 <lv_color_make>:
#elif LV_COLOR_DEPTH == 32
#define LV_COLOR_MAKE(r8, g8, b8) (_LV_COLOR_MAKE_TYPE_HELPER{{b8, g8, r8, 0xff}}) /*Fix 0xff alpha*/
#endif

static inline lv_color_t lv_color_make(uint8_t r, uint8_t g, uint8_t b)
{
 8023094:	b490      	push	{r4, r7}
 8023096:	b082      	sub	sp, #8
 8023098:	af00      	add	r7, sp, #0
 802309a:	4604      	mov	r4, r0
 802309c:	4608      	mov	r0, r1
 802309e:	4611      	mov	r1, r2
 80230a0:	4622      	mov	r2, r4
 80230a2:	71fa      	strb	r2, [r7, #7]
 80230a4:	4602      	mov	r2, r0
 80230a6:	71ba      	strb	r2, [r7, #6]
 80230a8:	460a      	mov	r2, r1
 80230aa:	717a      	strb	r2, [r7, #5]
    return LV_COLOR_MAKE(r, g, b);
 80230ac:	797a      	ldrb	r2, [r7, #5]
 80230ae:	08d2      	lsrs	r2, r2, #3
 80230b0:	b2d2      	uxtb	r2, r2
 80230b2:	f002 021f 	and.w	r2, r2, #31
 80230b6:	b2d0      	uxtb	r0, r2
 80230b8:	79ba      	ldrb	r2, [r7, #6]
 80230ba:	0892      	lsrs	r2, r2, #2
 80230bc:	b2d2      	uxtb	r2, r2
 80230be:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 80230c2:	b2d1      	uxtb	r1, r2
 80230c4:	79fa      	ldrb	r2, [r7, #7]
 80230c6:	08d2      	lsrs	r2, r2, #3
 80230c8:	b2d2      	uxtb	r2, r2
 80230ca:	f002 021f 	and.w	r2, r2, #31
 80230ce:	b2d2      	uxtb	r2, r2
 80230d0:	f360 0304 	bfi	r3, r0, #0, #5
 80230d4:	f361 134a 	bfi	r3, r1, #5, #6
 80230d8:	f362 23cf 	bfi	r3, r2, #11, #5
}
 80230dc:	4618      	mov	r0, r3
 80230de:	3708      	adds	r7, #8
 80230e0:	46bd      	mov	sp, r7
 80230e2:	bc90      	pop	{r4, r7}
 80230e4:	4770      	bx	lr

080230e6 <lv_color_hex>:

static inline lv_color_t lv_color_hex(uint32_t c)
{
 80230e6:	b580      	push	{r7, lr}
 80230e8:	b082      	sub	sp, #8
 80230ea:	af00      	add	r7, sp, #0
 80230ec:	6078      	str	r0, [r7, #4]
    return lv_color_make((uint8_t)((c >> 16) & 0xFF), (uint8_t)((c >> 8) & 0xFF), (uint8_t)(c & 0xFF));
 80230ee:	687b      	ldr	r3, [r7, #4]
 80230f0:	0c1b      	lsrs	r3, r3, #16
 80230f2:	b2d8      	uxtb	r0, r3
 80230f4:	687b      	ldr	r3, [r7, #4]
 80230f6:	0a1b      	lsrs	r3, r3, #8
 80230f8:	b2db      	uxtb	r3, r3
 80230fa:	687a      	ldr	r2, [r7, #4]
 80230fc:	b2d2      	uxtb	r2, r2
 80230fe:	4619      	mov	r1, r3
 8023100:	f7ff ffc8 	bl	8023094 <lv_color_make>
 8023104:	4603      	mov	r3, r0
}
 8023106:	4618      	mov	r0, r3
 8023108:	3708      	adds	r7, #8
 802310a:	46bd      	mov	sp, r7
 802310c:	bd80      	pop	{r7, pc}

0802310e <lv_color_hex3>:

static inline lv_color_t lv_color_hex3(uint32_t c)
{
 802310e:	b580      	push	{r7, lr}
 8023110:	b082      	sub	sp, #8
 8023112:	af00      	add	r7, sp, #0
 8023114:	6078      	str	r0, [r7, #4]
    return lv_color_make((uint8_t)(((c >> 4) & 0xF0) | ((c >> 8) & 0xF)), (uint8_t)((c & 0xF0) | ((c & 0xF0) >> 4)),
 8023116:	687b      	ldr	r3, [r7, #4]
 8023118:	091b      	lsrs	r3, r3, #4
 802311a:	b2db      	uxtb	r3, r3
 802311c:	f023 030f 	bic.w	r3, r3, #15
 8023120:	b2da      	uxtb	r2, r3
 8023122:	687b      	ldr	r3, [r7, #4]
 8023124:	0a1b      	lsrs	r3, r3, #8
 8023126:	b2db      	uxtb	r3, r3
 8023128:	f003 030f 	and.w	r3, r3, #15
 802312c:	b2db      	uxtb	r3, r3
 802312e:	4313      	orrs	r3, r2
 8023130:	b2d8      	uxtb	r0, r3
 8023132:	687b      	ldr	r3, [r7, #4]
 8023134:	b2db      	uxtb	r3, r3
 8023136:	f023 030f 	bic.w	r3, r3, #15
 802313a:	b2da      	uxtb	r2, r3
 802313c:	687b      	ldr	r3, [r7, #4]
 802313e:	091b      	lsrs	r3, r3, #4
 8023140:	b2db      	uxtb	r3, r3
 8023142:	f003 030f 	and.w	r3, r3, #15
 8023146:	b2db      	uxtb	r3, r3
 8023148:	4313      	orrs	r3, r2
 802314a:	b2d9      	uxtb	r1, r3
                         (uint8_t)((c & 0xF) | ((c & 0xF) << 4)));
 802314c:	687b      	ldr	r3, [r7, #4]
 802314e:	b2db      	uxtb	r3, r3
 8023150:	f003 030f 	and.w	r3, r3, #15
 8023154:	b2da      	uxtb	r2, r3
 8023156:	687b      	ldr	r3, [r7, #4]
 8023158:	b2db      	uxtb	r3, r3
 802315a:	011b      	lsls	r3, r3, #4
 802315c:	b2db      	uxtb	r3, r3
    return lv_color_make((uint8_t)(((c >> 4) & 0xF0) | ((c >> 8) & 0xF)), (uint8_t)((c & 0xF0) | ((c & 0xF0) >> 4)),
 802315e:	4313      	orrs	r3, r2
 8023160:	b2db      	uxtb	r3, r3
 8023162:	461a      	mov	r2, r3
 8023164:	f7ff ff96 	bl	8023094 <lv_color_make>
 8023168:	4603      	mov	r3, r0
}
 802316a:	4618      	mov	r0, r3
 802316c:	3708      	adds	r7, #8
 802316e:	46bd      	mov	sp, r7
 8023170:	bd80      	pop	{r7, pc}

08023172 <lv_style_set_radius>:
#define _LV_OBJ_STYLE_SET_GET_DECLARE(prop_name, func_name, value_type, style_type, scalar)                             \
    _OBJ_GET_STYLE_##scalar(prop_name, func_name, value_type, style_type)                                               \
    _OBJ_SET_STYLE_LOCAL_##scalar(prop_name, func_name, value_type, style_type)                                         \
    _OBJ_SET_STYLE_##scalar(prop_name, func_name, value_type, style_type)

_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
 8023172:	b580      	push	{r7, lr}
 8023174:	b082      	sub	sp, #8
 8023176:	af00      	add	r7, sp, #0
 8023178:	6078      	str	r0, [r7, #4]
 802317a:	460b      	mov	r3, r1
 802317c:	70fb      	strb	r3, [r7, #3]
 802317e:	4613      	mov	r3, r2
 8023180:	803b      	strh	r3, [r7, #0]
 8023182:	78fb      	ldrb	r3, [r7, #3]
 8023184:	021b      	lsls	r3, r3, #8
 8023186:	b21b      	sxth	r3, r3
 8023188:	f043 0301 	orr.w	r3, r3, #1
 802318c:	b21b      	sxth	r3, r3
 802318e:	b29b      	uxth	r3, r3
 8023190:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023194:	4619      	mov	r1, r3
 8023196:	6878      	ldr	r0, [r7, #4]
 8023198:	f7ec fb1e 	bl	800f7d8 <_lv_style_set_int>
 802319c:	3708      	adds	r7, #8
 802319e:	46bd      	mov	sp, r7
 80231a0:	bd80      	pop	{r7, pc}

080231a2 <lv_style_set_clip_corner>:
_LV_OBJ_STYLE_SET_GET_DECLARE(CLIP_CORNER, clip_corner, bool, _int, scalar)
 80231a2:	b580      	push	{r7, lr}
 80231a4:	b082      	sub	sp, #8
 80231a6:	af00      	add	r7, sp, #0
 80231a8:	6078      	str	r0, [r7, #4]
 80231aa:	460b      	mov	r3, r1
 80231ac:	70fb      	strb	r3, [r7, #3]
 80231ae:	4613      	mov	r3, r2
 80231b0:	70bb      	strb	r3, [r7, #2]
 80231b2:	78fb      	ldrb	r3, [r7, #3]
 80231b4:	021b      	lsls	r3, r3, #8
 80231b6:	b21b      	sxth	r3, r3
 80231b8:	f043 0302 	orr.w	r3, r3, #2
 80231bc:	b21b      	sxth	r3, r3
 80231be:	b29b      	uxth	r3, r3
 80231c0:	78ba      	ldrb	r2, [r7, #2]
 80231c2:	b212      	sxth	r2, r2
 80231c4:	4619      	mov	r1, r3
 80231c6:	6878      	ldr	r0, [r7, #4]
 80231c8:	f7ec fb06 	bl	800f7d8 <_lv_style_set_int>
 80231cc:	3708      	adds	r7, #8
 80231ce:	46bd      	mov	sp, r7
 80231d0:	bd80      	pop	{r7, pc}

080231d2 <lv_style_set_size>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SIZE, size, lv_style_int_t, _int, scalar)
 80231d2:	b580      	push	{r7, lr}
 80231d4:	b082      	sub	sp, #8
 80231d6:	af00      	add	r7, sp, #0
 80231d8:	6078      	str	r0, [r7, #4]
 80231da:	460b      	mov	r3, r1
 80231dc:	70fb      	strb	r3, [r7, #3]
 80231de:	4613      	mov	r3, r2
 80231e0:	803b      	strh	r3, [r7, #0]
 80231e2:	78fb      	ldrb	r3, [r7, #3]
 80231e4:	021b      	lsls	r3, r3, #8
 80231e6:	b21b      	sxth	r3, r3
 80231e8:	f043 0303 	orr.w	r3, r3, #3
 80231ec:	b21b      	sxth	r3, r3
 80231ee:	b29b      	uxth	r3, r3
 80231f0:	f9b7 2000 	ldrsh.w	r2, [r7]
 80231f4:	4619      	mov	r1, r3
 80231f6:	6878      	ldr	r0, [r7, #4]
 80231f8:	f7ec faee 	bl	800f7d8 <_lv_style_set_int>
 80231fc:	3708      	adds	r7, #8
 80231fe:	46bd      	mov	sp, r7
 8023200:	bd80      	pop	{r7, pc}

08023202 <lv_style_set_transform_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
 8023202:	b580      	push	{r7, lr}
 8023204:	b082      	sub	sp, #8
 8023206:	af00      	add	r7, sp, #0
 8023208:	6078      	str	r0, [r7, #4]
 802320a:	460b      	mov	r3, r1
 802320c:	70fb      	strb	r3, [r7, #3]
 802320e:	4613      	mov	r3, r2
 8023210:	803b      	strh	r3, [r7, #0]
 8023212:	78fb      	ldrb	r3, [r7, #3]
 8023214:	021b      	lsls	r3, r3, #8
 8023216:	b21b      	sxth	r3, r3
 8023218:	f043 0304 	orr.w	r3, r3, #4
 802321c:	b21b      	sxth	r3, r3
 802321e:	b29b      	uxth	r3, r3
 8023220:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023224:	4619      	mov	r1, r3
 8023226:	6878      	ldr	r0, [r7, #4]
 8023228:	f7ec fad6 	bl	800f7d8 <_lv_style_set_int>
 802322c:	3708      	adds	r7, #8
 802322e:	46bd      	mov	sp, r7
 8023230:	bd80      	pop	{r7, pc}

08023232 <lv_style_set_pad_top>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
 8023232:	b580      	push	{r7, lr}
 8023234:	b082      	sub	sp, #8
 8023236:	af00      	add	r7, sp, #0
 8023238:	6078      	str	r0, [r7, #4]
 802323a:	460b      	mov	r3, r1
 802323c:	70fb      	strb	r3, [r7, #3]
 802323e:	4613      	mov	r3, r2
 8023240:	803b      	strh	r3, [r7, #0]
 8023242:	78fb      	ldrb	r3, [r7, #3]
 8023244:	021b      	lsls	r3, r3, #8
 8023246:	b21b      	sxth	r3, r3
 8023248:	f043 0310 	orr.w	r3, r3, #16
 802324c:	b21b      	sxth	r3, r3
 802324e:	b29b      	uxth	r3, r3
 8023250:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023254:	4619      	mov	r1, r3
 8023256:	6878      	ldr	r0, [r7, #4]
 8023258:	f7ec fabe 	bl	800f7d8 <_lv_style_set_int>
 802325c:	3708      	adds	r7, #8
 802325e:	46bd      	mov	sp, r7
 8023260:	bd80      	pop	{r7, pc}

08023262 <lv_style_set_pad_bottom>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
 8023262:	b580      	push	{r7, lr}
 8023264:	b082      	sub	sp, #8
 8023266:	af00      	add	r7, sp, #0
 8023268:	6078      	str	r0, [r7, #4]
 802326a:	460b      	mov	r3, r1
 802326c:	70fb      	strb	r3, [r7, #3]
 802326e:	4613      	mov	r3, r2
 8023270:	803b      	strh	r3, [r7, #0]
 8023272:	78fb      	ldrb	r3, [r7, #3]
 8023274:	021b      	lsls	r3, r3, #8
 8023276:	b21b      	sxth	r3, r3
 8023278:	f043 0311 	orr.w	r3, r3, #17
 802327c:	b21b      	sxth	r3, r3
 802327e:	b29b      	uxth	r3, r3
 8023280:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023284:	4619      	mov	r1, r3
 8023286:	6878      	ldr	r0, [r7, #4]
 8023288:	f7ec faa6 	bl	800f7d8 <_lv_style_set_int>
 802328c:	3708      	adds	r7, #8
 802328e:	46bd      	mov	sp, r7
 8023290:	bd80      	pop	{r7, pc}

08023292 <lv_style_set_pad_left>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
 8023292:	b580      	push	{r7, lr}
 8023294:	b082      	sub	sp, #8
 8023296:	af00      	add	r7, sp, #0
 8023298:	6078      	str	r0, [r7, #4]
 802329a:	460b      	mov	r3, r1
 802329c:	70fb      	strb	r3, [r7, #3]
 802329e:	4613      	mov	r3, r2
 80232a0:	803b      	strh	r3, [r7, #0]
 80232a2:	78fb      	ldrb	r3, [r7, #3]
 80232a4:	021b      	lsls	r3, r3, #8
 80232a6:	b21b      	sxth	r3, r3
 80232a8:	f043 0312 	orr.w	r3, r3, #18
 80232ac:	b21b      	sxth	r3, r3
 80232ae:	b29b      	uxth	r3, r3
 80232b0:	f9b7 2000 	ldrsh.w	r2, [r7]
 80232b4:	4619      	mov	r1, r3
 80232b6:	6878      	ldr	r0, [r7, #4]
 80232b8:	f7ec fa8e 	bl	800f7d8 <_lv_style_set_int>
 80232bc:	3708      	adds	r7, #8
 80232be:	46bd      	mov	sp, r7
 80232c0:	bd80      	pop	{r7, pc}

080232c2 <lv_style_set_pad_right>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
 80232c2:	b580      	push	{r7, lr}
 80232c4:	b082      	sub	sp, #8
 80232c6:	af00      	add	r7, sp, #0
 80232c8:	6078      	str	r0, [r7, #4]
 80232ca:	460b      	mov	r3, r1
 80232cc:	70fb      	strb	r3, [r7, #3]
 80232ce:	4613      	mov	r3, r2
 80232d0:	803b      	strh	r3, [r7, #0]
 80232d2:	78fb      	ldrb	r3, [r7, #3]
 80232d4:	021b      	lsls	r3, r3, #8
 80232d6:	b21b      	sxth	r3, r3
 80232d8:	f043 0313 	orr.w	r3, r3, #19
 80232dc:	b21b      	sxth	r3, r3
 80232de:	b29b      	uxth	r3, r3
 80232e0:	f9b7 2000 	ldrsh.w	r2, [r7]
 80232e4:	4619      	mov	r1, r3
 80232e6:	6878      	ldr	r0, [r7, #4]
 80232e8:	f7ec fa76 	bl	800f7d8 <_lv_style_set_int>
 80232ec:	3708      	adds	r7, #8
 80232ee:	46bd      	mov	sp, r7
 80232f0:	bd80      	pop	{r7, pc}

080232f2 <lv_style_set_pad_inner>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
 80232f2:	b580      	push	{r7, lr}
 80232f4:	b082      	sub	sp, #8
 80232f6:	af00      	add	r7, sp, #0
 80232f8:	6078      	str	r0, [r7, #4]
 80232fa:	460b      	mov	r3, r1
 80232fc:	70fb      	strb	r3, [r7, #3]
 80232fe:	4613      	mov	r3, r2
 8023300:	803b      	strh	r3, [r7, #0]
 8023302:	78fb      	ldrb	r3, [r7, #3]
 8023304:	021b      	lsls	r3, r3, #8
 8023306:	b21b      	sxth	r3, r3
 8023308:	f043 0314 	orr.w	r3, r3, #20
 802330c:	b21b      	sxth	r3, r3
 802330e:	b29b      	uxth	r3, r3
 8023310:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023314:	4619      	mov	r1, r3
 8023316:	6878      	ldr	r0, [r7, #4]
 8023318:	f7ec fa5e 	bl	800f7d8 <_lv_style_set_int>
 802331c:	3708      	adds	r7, #8
 802331e:	46bd      	mov	sp, r7
 8023320:	bd80      	pop	{r7, pc}

08023322 <lv_style_set_margin_top>:
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
 8023322:	b580      	push	{r7, lr}
 8023324:	b082      	sub	sp, #8
 8023326:	af00      	add	r7, sp, #0
 8023328:	6078      	str	r0, [r7, #4]
 802332a:	460b      	mov	r3, r1
 802332c:	70fb      	strb	r3, [r7, #3]
 802332e:	4613      	mov	r3, r2
 8023330:	803b      	strh	r3, [r7, #0]
 8023332:	78fb      	ldrb	r3, [r7, #3]
 8023334:	021b      	lsls	r3, r3, #8
 8023336:	b21b      	sxth	r3, r3
 8023338:	f043 0315 	orr.w	r3, r3, #21
 802333c:	b21b      	sxth	r3, r3
 802333e:	b29b      	uxth	r3, r3
 8023340:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023344:	4619      	mov	r1, r3
 8023346:	6878      	ldr	r0, [r7, #4]
 8023348:	f7ec fa46 	bl	800f7d8 <_lv_style_set_int>
 802334c:	3708      	adds	r7, #8
 802334e:	46bd      	mov	sp, r7
 8023350:	bd80      	pop	{r7, pc}

08023352 <lv_style_set_margin_bottom>:
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
 8023352:	b580      	push	{r7, lr}
 8023354:	b082      	sub	sp, #8
 8023356:	af00      	add	r7, sp, #0
 8023358:	6078      	str	r0, [r7, #4]
 802335a:	460b      	mov	r3, r1
 802335c:	70fb      	strb	r3, [r7, #3]
 802335e:	4613      	mov	r3, r2
 8023360:	803b      	strh	r3, [r7, #0]
 8023362:	78fb      	ldrb	r3, [r7, #3]
 8023364:	021b      	lsls	r3, r3, #8
 8023366:	b21b      	sxth	r3, r3
 8023368:	f043 0316 	orr.w	r3, r3, #22
 802336c:	b21b      	sxth	r3, r3
 802336e:	b29b      	uxth	r3, r3
 8023370:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023374:	4619      	mov	r1, r3
 8023376:	6878      	ldr	r0, [r7, #4]
 8023378:	f7ec fa2e 	bl	800f7d8 <_lv_style_set_int>
 802337c:	3708      	adds	r7, #8
 802337e:	46bd      	mov	sp, r7
 8023380:	bd80      	pop	{r7, pc}

08023382 <lv_style_set_margin_left>:
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
 8023382:	b580      	push	{r7, lr}
 8023384:	b082      	sub	sp, #8
 8023386:	af00      	add	r7, sp, #0
 8023388:	6078      	str	r0, [r7, #4]
 802338a:	460b      	mov	r3, r1
 802338c:	70fb      	strb	r3, [r7, #3]
 802338e:	4613      	mov	r3, r2
 8023390:	803b      	strh	r3, [r7, #0]
 8023392:	78fb      	ldrb	r3, [r7, #3]
 8023394:	021b      	lsls	r3, r3, #8
 8023396:	b21b      	sxth	r3, r3
 8023398:	f043 0317 	orr.w	r3, r3, #23
 802339c:	b21b      	sxth	r3, r3
 802339e:	b29b      	uxth	r3, r3
 80233a0:	f9b7 2000 	ldrsh.w	r2, [r7]
 80233a4:	4619      	mov	r1, r3
 80233a6:	6878      	ldr	r0, [r7, #4]
 80233a8:	f7ec fa16 	bl	800f7d8 <_lv_style_set_int>
 80233ac:	3708      	adds	r7, #8
 80233ae:	46bd      	mov	sp, r7
 80233b0:	bd80      	pop	{r7, pc}

080233b2 <lv_style_set_margin_right>:
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
 80233b2:	b580      	push	{r7, lr}
 80233b4:	b082      	sub	sp, #8
 80233b6:	af00      	add	r7, sp, #0
 80233b8:	6078      	str	r0, [r7, #4]
 80233ba:	460b      	mov	r3, r1
 80233bc:	70fb      	strb	r3, [r7, #3]
 80233be:	4613      	mov	r3, r2
 80233c0:	803b      	strh	r3, [r7, #0]
 80233c2:	78fb      	ldrb	r3, [r7, #3]
 80233c4:	021b      	lsls	r3, r3, #8
 80233c6:	b21b      	sxth	r3, r3
 80233c8:	f043 0318 	orr.w	r3, r3, #24
 80233cc:	b21b      	sxth	r3, r3
 80233ce:	b29b      	uxth	r3, r3
 80233d0:	f9b7 2000 	ldrsh.w	r2, [r7]
 80233d4:	4619      	mov	r1, r3
 80233d6:	6878      	ldr	r0, [r7, #4]
 80233d8:	f7ec f9fe 	bl	800f7d8 <_lv_style_set_int>
 80233dc:	3708      	adds	r7, #8
 80233de:	46bd      	mov	sp, r7
 80233e0:	bd80      	pop	{r7, pc}

080233e2 <lv_style_set_bg_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_BLEND_MODE, bg_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_MAIN_STOP, bg_main_stop, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_STOP, bg_grad_stop, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_DIR, bg_grad_dir, lv_grad_dir_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_COLOR, bg_color, lv_color_t, _color, nonscalar)
 80233e2:	b580      	push	{r7, lr}
 80233e4:	b082      	sub	sp, #8
 80233e6:	af00      	add	r7, sp, #0
 80233e8:	6078      	str	r0, [r7, #4]
 80233ea:	460b      	mov	r3, r1
 80233ec:	803a      	strh	r2, [r7, #0]
 80233ee:	70fb      	strb	r3, [r7, #3]
 80233f0:	78fb      	ldrb	r3, [r7, #3]
 80233f2:	021b      	lsls	r3, r3, #8
 80233f4:	b21b      	sxth	r3, r3
 80233f6:	f043 0329 	orr.w	r3, r3, #41	; 0x29
 80233fa:	b21b      	sxth	r3, r3
 80233fc:	b29b      	uxth	r3, r3
 80233fe:	883a      	ldrh	r2, [r7, #0]
 8023400:	4619      	mov	r1, r3
 8023402:	6878      	ldr	r0, [r7, #4]
 8023404:	f7ec fa78 	bl	800f8f8 <_lv_style_set_color>
 8023408:	3708      	adds	r7, #8
 802340a:	46bd      	mov	sp, r7
 802340c:	bd80      	pop	{r7, pc}

0802340e <lv_style_set_bg_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_COLOR, bg_grad_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
 802340e:	b580      	push	{r7, lr}
 8023410:	b082      	sub	sp, #8
 8023412:	af00      	add	r7, sp, #0
 8023414:	6078      	str	r0, [r7, #4]
 8023416:	460b      	mov	r3, r1
 8023418:	70fb      	strb	r3, [r7, #3]
 802341a:	4613      	mov	r3, r2
 802341c:	70bb      	strb	r3, [r7, #2]
 802341e:	78fb      	ldrb	r3, [r7, #3]
 8023420:	021b      	lsls	r3, r3, #8
 8023422:	b21b      	sxth	r3, r3
 8023424:	f043 032c 	orr.w	r3, r3, #44	; 0x2c
 8023428:	b21b      	sxth	r3, r3
 802342a:	b29b      	uxth	r3, r3
 802342c:	78ba      	ldrb	r2, [r7, #2]
 802342e:	4619      	mov	r1, r3
 8023430:	6878      	ldr	r0, [r7, #4]
 8023432:	f7ec faf1 	bl	800fa18 <_lv_style_set_opa>
 8023436:	3708      	adds	r7, #8
 8023438:	46bd      	mov	sp, r7
 802343a:	bd80      	pop	{r7, pc}

0802343c <lv_style_set_border_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
 802343c:	b580      	push	{r7, lr}
 802343e:	b082      	sub	sp, #8
 8023440:	af00      	add	r7, sp, #0
 8023442:	6078      	str	r0, [r7, #4]
 8023444:	460b      	mov	r3, r1
 8023446:	70fb      	strb	r3, [r7, #3]
 8023448:	4613      	mov	r3, r2
 802344a:	803b      	strh	r3, [r7, #0]
 802344c:	78fb      	ldrb	r3, [r7, #3]
 802344e:	021b      	lsls	r3, r3, #8
 8023450:	b21b      	sxth	r3, r3
 8023452:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 8023456:	b21b      	sxth	r3, r3
 8023458:	b29b      	uxth	r3, r3
 802345a:	f9b7 2000 	ldrsh.w	r2, [r7]
 802345e:	4619      	mov	r1, r3
 8023460:	6878      	ldr	r0, [r7, #4]
 8023462:	f7ec f9b9 	bl	800f7d8 <_lv_style_set_int>
 8023466:	3708      	adds	r7, #8
 8023468:	46bd      	mov	sp, r7
 802346a:	bd80      	pop	{r7, pc}

0802346c <lv_style_set_border_side>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_SIDE, border_side, lv_border_side_t, _int, scalar)
 802346c:	b580      	push	{r7, lr}
 802346e:	b082      	sub	sp, #8
 8023470:	af00      	add	r7, sp, #0
 8023472:	6078      	str	r0, [r7, #4]
 8023474:	460b      	mov	r3, r1
 8023476:	70fb      	strb	r3, [r7, #3]
 8023478:	4613      	mov	r3, r2
 802347a:	70bb      	strb	r3, [r7, #2]
 802347c:	78fb      	ldrb	r3, [r7, #3]
 802347e:	021b      	lsls	r3, r3, #8
 8023480:	b21b      	sxth	r3, r3
 8023482:	f043 0331 	orr.w	r3, r3, #49	; 0x31
 8023486:	b21b      	sxth	r3, r3
 8023488:	b29b      	uxth	r3, r3
 802348a:	78ba      	ldrb	r2, [r7, #2]
 802348c:	b212      	sxth	r2, r2
 802348e:	4619      	mov	r1, r3
 8023490:	6878      	ldr	r0, [r7, #4]
 8023492:	f7ec f9a1 	bl	800f7d8 <_lv_style_set_int>
 8023496:	3708      	adds	r7, #8
 8023498:	46bd      	mov	sp, r7
 802349a:	bd80      	pop	{r7, pc}

0802349c <lv_style_set_border_post>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_BLEND_MODE, border_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
 802349c:	b580      	push	{r7, lr}
 802349e:	b082      	sub	sp, #8
 80234a0:	af00      	add	r7, sp, #0
 80234a2:	6078      	str	r0, [r7, #4]
 80234a4:	460b      	mov	r3, r1
 80234a6:	70fb      	strb	r3, [r7, #3]
 80234a8:	4613      	mov	r3, r2
 80234aa:	70bb      	strb	r3, [r7, #2]
 80234ac:	78fb      	ldrb	r3, [r7, #3]
 80234ae:	021b      	lsls	r3, r3, #8
 80234b0:	b21b      	sxth	r3, r3
 80234b2:	f043 0333 	orr.w	r3, r3, #51	; 0x33
 80234b6:	b21b      	sxth	r3, r3
 80234b8:	b29b      	uxth	r3, r3
 80234ba:	78ba      	ldrb	r2, [r7, #2]
 80234bc:	b212      	sxth	r2, r2
 80234be:	4619      	mov	r1, r3
 80234c0:	6878      	ldr	r0, [r7, #4]
 80234c2:	f7ec f989 	bl	800f7d8 <_lv_style_set_int>
 80234c6:	3708      	adds	r7, #8
 80234c8:	46bd      	mov	sp, r7
 80234ca:	bd80      	pop	{r7, pc}

080234cc <lv_style_set_border_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_COLOR, border_color, lv_color_t, _color, nonscalar)
 80234cc:	b580      	push	{r7, lr}
 80234ce:	b082      	sub	sp, #8
 80234d0:	af00      	add	r7, sp, #0
 80234d2:	6078      	str	r0, [r7, #4]
 80234d4:	460b      	mov	r3, r1
 80234d6:	803a      	strh	r2, [r7, #0]
 80234d8:	70fb      	strb	r3, [r7, #3]
 80234da:	78fb      	ldrb	r3, [r7, #3]
 80234dc:	021b      	lsls	r3, r3, #8
 80234de:	b21b      	sxth	r3, r3
 80234e0:	f043 0339 	orr.w	r3, r3, #57	; 0x39
 80234e4:	b21b      	sxth	r3, r3
 80234e6:	b29b      	uxth	r3, r3
 80234e8:	883a      	ldrh	r2, [r7, #0]
 80234ea:	4619      	mov	r1, r3
 80234ec:	6878      	ldr	r0, [r7, #4]
 80234ee:	f7ec fa03 	bl	800f8f8 <_lv_style_set_color>
 80234f2:	3708      	adds	r7, #8
 80234f4:	46bd      	mov	sp, r7
 80234f6:	bd80      	pop	{r7, pc}

080234f8 <lv_style_set_border_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_OPA, border_opa, lv_opa_t, _opa, scalar)
 80234f8:	b580      	push	{r7, lr}
 80234fa:	b082      	sub	sp, #8
 80234fc:	af00      	add	r7, sp, #0
 80234fe:	6078      	str	r0, [r7, #4]
 8023500:	460b      	mov	r3, r1
 8023502:	70fb      	strb	r3, [r7, #3]
 8023504:	4613      	mov	r3, r2
 8023506:	70bb      	strb	r3, [r7, #2]
 8023508:	78fb      	ldrb	r3, [r7, #3]
 802350a:	021b      	lsls	r3, r3, #8
 802350c:	b21b      	sxth	r3, r3
 802350e:	f043 033c 	orr.w	r3, r3, #60	; 0x3c
 8023512:	b21b      	sxth	r3, r3
 8023514:	b29b      	uxth	r3, r3
 8023516:	78ba      	ldrb	r2, [r7, #2]
 8023518:	4619      	mov	r1, r3
 802351a:	6878      	ldr	r0, [r7, #4]
 802351c:	f7ec fa7c 	bl	800fa18 <_lv_style_set_opa>
 8023520:	3708      	adds	r7, #8
 8023522:	46bd      	mov	sp, r7
 8023524:	bd80      	pop	{r7, pc}

08023526 <lv_style_set_outline_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_WIDTH, outline_width, lv_style_int_t, _int, scalar)
 8023526:	b580      	push	{r7, lr}
 8023528:	b082      	sub	sp, #8
 802352a:	af00      	add	r7, sp, #0
 802352c:	6078      	str	r0, [r7, #4]
 802352e:	460b      	mov	r3, r1
 8023530:	70fb      	strb	r3, [r7, #3]
 8023532:	4613      	mov	r3, r2
 8023534:	803b      	strh	r3, [r7, #0]
 8023536:	78fb      	ldrb	r3, [r7, #3]
 8023538:	021b      	lsls	r3, r3, #8
 802353a:	b21b      	sxth	r3, r3
 802353c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8023540:	b21b      	sxth	r3, r3
 8023542:	b29b      	uxth	r3, r3
 8023544:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023548:	4619      	mov	r1, r3
 802354a:	6878      	ldr	r0, [r7, #4]
 802354c:	f7ec f944 	bl	800f7d8 <_lv_style_set_int>
 8023550:	3708      	adds	r7, #8
 8023552:	46bd      	mov	sp, r7
 8023554:	bd80      	pop	{r7, pc}

08023556 <lv_style_set_outline_pad>:
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_PAD, outline_pad, lv_style_int_t, _int, scalar)
 8023556:	b580      	push	{r7, lr}
 8023558:	b082      	sub	sp, #8
 802355a:	af00      	add	r7, sp, #0
 802355c:	6078      	str	r0, [r7, #4]
 802355e:	460b      	mov	r3, r1
 8023560:	70fb      	strb	r3, [r7, #3]
 8023562:	4613      	mov	r3, r2
 8023564:	803b      	strh	r3, [r7, #0]
 8023566:	78fb      	ldrb	r3, [r7, #3]
 8023568:	021b      	lsls	r3, r3, #8
 802356a:	b21b      	sxth	r3, r3
 802356c:	f043 0341 	orr.w	r3, r3, #65	; 0x41
 8023570:	b21b      	sxth	r3, r3
 8023572:	b29b      	uxth	r3, r3
 8023574:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023578:	4619      	mov	r1, r3
 802357a:	6878      	ldr	r0, [r7, #4]
 802357c:	f7ec f92c 	bl	800f7d8 <_lv_style_set_int>
 8023580:	3708      	adds	r7, #8
 8023582:	46bd      	mov	sp, r7
 8023584:	bd80      	pop	{r7, pc}

08023586 <lv_style_set_outline_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_BLEND_MODE, outline_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_COLOR, outline_color, lv_color_t, _color, nonscalar)
 8023586:	b580      	push	{r7, lr}
 8023588:	b082      	sub	sp, #8
 802358a:	af00      	add	r7, sp, #0
 802358c:	6078      	str	r0, [r7, #4]
 802358e:	460b      	mov	r3, r1
 8023590:	803a      	strh	r2, [r7, #0]
 8023592:	70fb      	strb	r3, [r7, #3]
 8023594:	78fb      	ldrb	r3, [r7, #3]
 8023596:	021b      	lsls	r3, r3, #8
 8023598:	b21b      	sxth	r3, r3
 802359a:	f043 0349 	orr.w	r3, r3, #73	; 0x49
 802359e:	b21b      	sxth	r3, r3
 80235a0:	b29b      	uxth	r3, r3
 80235a2:	883a      	ldrh	r2, [r7, #0]
 80235a4:	4619      	mov	r1, r3
 80235a6:	6878      	ldr	r0, [r7, #4]
 80235a8:	f7ec f9a6 	bl	800f8f8 <_lv_style_set_color>
 80235ac:	3708      	adds	r7, #8
 80235ae:	46bd      	mov	sp, r7
 80235b0:	bd80      	pop	{r7, pc}

080235b2 <lv_style_set_outline_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(OUTLINE_OPA, outline_opa, lv_opa_t, _opa, scalar)
 80235b2:	b580      	push	{r7, lr}
 80235b4:	b082      	sub	sp, #8
 80235b6:	af00      	add	r7, sp, #0
 80235b8:	6078      	str	r0, [r7, #4]
 80235ba:	460b      	mov	r3, r1
 80235bc:	70fb      	strb	r3, [r7, #3]
 80235be:	4613      	mov	r3, r2
 80235c0:	70bb      	strb	r3, [r7, #2]
 80235c2:	78fb      	ldrb	r3, [r7, #3]
 80235c4:	021b      	lsls	r3, r3, #8
 80235c6:	b21b      	sxth	r3, r3
 80235c8:	f043 034c 	orr.w	r3, r3, #76	; 0x4c
 80235cc:	b21b      	sxth	r3, r3
 80235ce:	b29b      	uxth	r3, r3
 80235d0:	78ba      	ldrb	r2, [r7, #2]
 80235d2:	4619      	mov	r1, r3
 80235d4:	6878      	ldr	r0, [r7, #4]
 80235d6:	f7ec fa1f 	bl	800fa18 <_lv_style_set_opa>
 80235da:	3708      	adds	r7, #8
 80235dc:	46bd      	mov	sp, r7
 80235de:	bd80      	pop	{r7, pc}

080235e0 <lv_style_set_shadow_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_WIDTH, shadow_width, lv_style_int_t, _int, scalar)
 80235e0:	b580      	push	{r7, lr}
 80235e2:	b082      	sub	sp, #8
 80235e4:	af00      	add	r7, sp, #0
 80235e6:	6078      	str	r0, [r7, #4]
 80235e8:	460b      	mov	r3, r1
 80235ea:	70fb      	strb	r3, [r7, #3]
 80235ec:	4613      	mov	r3, r2
 80235ee:	803b      	strh	r3, [r7, #0]
 80235f0:	78fb      	ldrb	r3, [r7, #3]
 80235f2:	021b      	lsls	r3, r3, #8
 80235f4:	b21b      	sxth	r3, r3
 80235f6:	f043 0350 	orr.w	r3, r3, #80	; 0x50
 80235fa:	b21b      	sxth	r3, r3
 80235fc:	b29b      	uxth	r3, r3
 80235fe:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023602:	4619      	mov	r1, r3
 8023604:	6878      	ldr	r0, [r7, #4]
 8023606:	f7ec f8e7 	bl	800f7d8 <_lv_style_set_int>
 802360a:	3708      	adds	r7, #8
 802360c:	46bd      	mov	sp, r7
 802360e:	bd80      	pop	{r7, pc}

08023610 <lv_style_set_shadow_spread>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_X, shadow_ofs_x, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OFS_Y, shadow_ofs_y, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_SPREAD, shadow_spread, lv_style_int_t, _int, scalar)
 8023610:	b580      	push	{r7, lr}
 8023612:	b082      	sub	sp, #8
 8023614:	af00      	add	r7, sp, #0
 8023616:	6078      	str	r0, [r7, #4]
 8023618:	460b      	mov	r3, r1
 802361a:	70fb      	strb	r3, [r7, #3]
 802361c:	4613      	mov	r3, r2
 802361e:	803b      	strh	r3, [r7, #0]
 8023620:	78fb      	ldrb	r3, [r7, #3]
 8023622:	021b      	lsls	r3, r3, #8
 8023624:	b21b      	sxth	r3, r3
 8023626:	f043 0353 	orr.w	r3, r3, #83	; 0x53
 802362a:	b21b      	sxth	r3, r3
 802362c:	b29b      	uxth	r3, r3
 802362e:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023632:	4619      	mov	r1, r3
 8023634:	6878      	ldr	r0, [r7, #4]
 8023636:	f7ec f8cf 	bl	800f7d8 <_lv_style_set_int>
 802363a:	3708      	adds	r7, #8
 802363c:	46bd      	mov	sp, r7
 802363e:	bd80      	pop	{r7, pc}

08023640 <lv_style_set_shadow_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_BLEND_MODE, shadow_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_COLOR, shadow_color, lv_color_t, _color, nonscalar)
 8023640:	b580      	push	{r7, lr}
 8023642:	b082      	sub	sp, #8
 8023644:	af00      	add	r7, sp, #0
 8023646:	6078      	str	r0, [r7, #4]
 8023648:	460b      	mov	r3, r1
 802364a:	803a      	strh	r2, [r7, #0]
 802364c:	70fb      	strb	r3, [r7, #3]
 802364e:	78fb      	ldrb	r3, [r7, #3]
 8023650:	021b      	lsls	r3, r3, #8
 8023652:	b21b      	sxth	r3, r3
 8023654:	f043 0359 	orr.w	r3, r3, #89	; 0x59
 8023658:	b21b      	sxth	r3, r3
 802365a:	b29b      	uxth	r3, r3
 802365c:	883a      	ldrh	r2, [r7, #0]
 802365e:	4619      	mov	r1, r3
 8023660:	6878      	ldr	r0, [r7, #4]
 8023662:	f7ec f949 	bl	800f8f8 <_lv_style_set_color>
 8023666:	3708      	adds	r7, #8
 8023668:	46bd      	mov	sp, r7
 802366a:	bd80      	pop	{r7, pc}

0802366c <lv_style_set_pattern_recolor>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SHADOW_OPA, shadow_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_REPEAT, pattern_repeat, bool, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_BLEND_MODE, pattern_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_RECOLOR, pattern_recolor, lv_color_t, _color, nonscalar)
 802366c:	b580      	push	{r7, lr}
 802366e:	b082      	sub	sp, #8
 8023670:	af00      	add	r7, sp, #0
 8023672:	6078      	str	r0, [r7, #4]
 8023674:	460b      	mov	r3, r1
 8023676:	803a      	strh	r2, [r7, #0]
 8023678:	70fb      	strb	r3, [r7, #3]
 802367a:	78fb      	ldrb	r3, [r7, #3]
 802367c:	021b      	lsls	r3, r3, #8
 802367e:	b21b      	sxth	r3, r3
 8023680:	f043 0369 	orr.w	r3, r3, #105	; 0x69
 8023684:	b21b      	sxth	r3, r3
 8023686:	b29b      	uxth	r3, r3
 8023688:	883a      	ldrh	r2, [r7, #0]
 802368a:	4619      	mov	r1, r3
 802368c:	6878      	ldr	r0, [r7, #4]
 802368e:	f7ec f933 	bl	800f8f8 <_lv_style_set_color>
 8023692:	3708      	adds	r7, #8
 8023694:	46bd      	mov	sp, r7
 8023696:	bd80      	pop	{r7, pc}

08023698 <lv_style_set_pattern_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_OPA, pattern_opa, lv_opa_t, _opa, scalar)
 8023698:	b580      	push	{r7, lr}
 802369a:	b082      	sub	sp, #8
 802369c:	af00      	add	r7, sp, #0
 802369e:	6078      	str	r0, [r7, #4]
 80236a0:	460b      	mov	r3, r1
 80236a2:	70fb      	strb	r3, [r7, #3]
 80236a4:	4613      	mov	r3, r2
 80236a6:	70bb      	strb	r3, [r7, #2]
 80236a8:	78fb      	ldrb	r3, [r7, #3]
 80236aa:	021b      	lsls	r3, r3, #8
 80236ac:	b21b      	sxth	r3, r3
 80236ae:	f043 036c 	orr.w	r3, r3, #108	; 0x6c
 80236b2:	b21b      	sxth	r3, r3
 80236b4:	b29b      	uxth	r3, r3
 80236b6:	78ba      	ldrb	r2, [r7, #2]
 80236b8:	4619      	mov	r1, r3
 80236ba:	6878      	ldr	r0, [r7, #4]
 80236bc:	f7ec f9ac 	bl	800fa18 <_lv_style_set_opa>
 80236c0:	3708      	adds	r7, #8
 80236c2:	46bd      	mov	sp, r7
 80236c4:	bd80      	pop	{r7, pc}

080236c6 <lv_style_set_pattern_image>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_RECOLOR_OPA, pattern_recolor_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PATTERN_IMAGE, pattern_image, const void *, _ptr, scalar)
 80236c6:	b580      	push	{r7, lr}
 80236c8:	b084      	sub	sp, #16
 80236ca:	af00      	add	r7, sp, #0
 80236cc:	60f8      	str	r0, [r7, #12]
 80236ce:	460b      	mov	r3, r1
 80236d0:	607a      	str	r2, [r7, #4]
 80236d2:	72fb      	strb	r3, [r7, #11]
 80236d4:	7afb      	ldrb	r3, [r7, #11]
 80236d6:	021b      	lsls	r3, r3, #8
 80236d8:	b21b      	sxth	r3, r3
 80236da:	f043 036e 	orr.w	r3, r3, #110	; 0x6e
 80236de:	b21b      	sxth	r3, r3
 80236e0:	b29b      	uxth	r3, r3
 80236e2:	687a      	ldr	r2, [r7, #4]
 80236e4:	4619      	mov	r1, r3
 80236e6:	68f8      	ldr	r0, [r7, #12]
 80236e8:	f7ec fa26 	bl	800fb38 <_lv_style_set_ptr>
 80236ec:	3710      	adds	r7, #16
 80236ee:	46bd      	mov	sp, r7
 80236f0:	bd80      	pop	{r7, pc}

080236f2 <lv_style_set_value_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_LINE_SPACE, value_line_space, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_BLEND_MODE, value_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_X, value_ofs_x, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OFS_Y, value_ofs_y, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_ALIGN, value_align, lv_align_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_COLOR, value_color, lv_color_t, _color, nonscalar)
 80236f2:	b580      	push	{r7, lr}
 80236f4:	b082      	sub	sp, #8
 80236f6:	af00      	add	r7, sp, #0
 80236f8:	6078      	str	r0, [r7, #4]
 80236fa:	460b      	mov	r3, r1
 80236fc:	803a      	strh	r2, [r7, #0]
 80236fe:	70fb      	strb	r3, [r7, #3]
 8023700:	78fb      	ldrb	r3, [r7, #3]
 8023702:	021b      	lsls	r3, r3, #8
 8023704:	b21b      	sxth	r3, r3
 8023706:	f043 0379 	orr.w	r3, r3, #121	; 0x79
 802370a:	b21b      	sxth	r3, r3
 802370c:	b29b      	uxth	r3, r3
 802370e:	883a      	ldrh	r2, [r7, #0]
 8023710:	4619      	mov	r1, r3
 8023712:	6878      	ldr	r0, [r7, #4]
 8023714:	f7ec f8f0 	bl	800f8f8 <_lv_style_set_color>
 8023718:	3708      	adds	r7, #8
 802371a:	46bd      	mov	sp, r7
 802371c:	bd80      	pop	{r7, pc}

0802371e <lv_style_set_value_font>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OPA, value_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_FONT, value_font, const lv_font_t *, _ptr, scalar)
 802371e:	b580      	push	{r7, lr}
 8023720:	b084      	sub	sp, #16
 8023722:	af00      	add	r7, sp, #0
 8023724:	60f8      	str	r0, [r7, #12]
 8023726:	460b      	mov	r3, r1
 8023728:	607a      	str	r2, [r7, #4]
 802372a:	72fb      	strb	r3, [r7, #11]
 802372c:	7afb      	ldrb	r3, [r7, #11]
 802372e:	021b      	lsls	r3, r3, #8
 8023730:	b21b      	sxth	r3, r3
 8023732:	f043 037e 	orr.w	r3, r3, #126	; 0x7e
 8023736:	b21b      	sxth	r3, r3
 8023738:	b29b      	uxth	r3, r3
 802373a:	687a      	ldr	r2, [r7, #4]
 802373c:	4619      	mov	r1, r3
 802373e:	68f8      	ldr	r0, [r7, #12]
 8023740:	f7ec f9fa 	bl	800fb38 <_lv_style_set_ptr>
 8023744:	3710      	adds	r7, #16
 8023746:	46bd      	mov	sp, r7
 8023748:	bd80      	pop	{r7, pc}
	...

0802374c <lv_style_set_text_line_space>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_STR, value_str, const char *, _ptr, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
 802374c:	b580      	push	{r7, lr}
 802374e:	b082      	sub	sp, #8
 8023750:	af00      	add	r7, sp, #0
 8023752:	6078      	str	r0, [r7, #4]
 8023754:	460b      	mov	r3, r1
 8023756:	70fb      	strb	r3, [r7, #3]
 8023758:	4613      	mov	r3, r2
 802375a:	803b      	strh	r3, [r7, #0]
 802375c:	78fb      	ldrb	r3, [r7, #3]
 802375e:	021b      	lsls	r3, r3, #8
 8023760:	b21a      	sxth	r2, r3
 8023762:	4b06      	ldr	r3, [pc, #24]	; (802377c <lv_style_set_text_line_space+0x30>)
 8023764:	4313      	orrs	r3, r2
 8023766:	b21b      	sxth	r3, r3
 8023768:	b29b      	uxth	r3, r3
 802376a:	f9b7 2000 	ldrsh.w	r2, [r7]
 802376e:	4619      	mov	r1, r3
 8023770:	6878      	ldr	r0, [r7, #4]
 8023772:	f7ec f831 	bl	800f7d8 <_lv_style_set_int>
 8023776:	3708      	adds	r7, #8
 8023778:	46bd      	mov	sp, r7
 802377a:	bd80      	pop	{r7, pc}
 802377c:	ffff8081 	.word	0xffff8081

08023780 <lv_style_set_text_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_BLEND_MODE, text_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
 8023780:	b580      	push	{r7, lr}
 8023782:	b082      	sub	sp, #8
 8023784:	af00      	add	r7, sp, #0
 8023786:	6078      	str	r0, [r7, #4]
 8023788:	460b      	mov	r3, r1
 802378a:	803a      	strh	r2, [r7, #0]
 802378c:	70fb      	strb	r3, [r7, #3]
 802378e:	78fb      	ldrb	r3, [r7, #3]
 8023790:	021b      	lsls	r3, r3, #8
 8023792:	b21a      	sxth	r2, r3
 8023794:	4b05      	ldr	r3, [pc, #20]	; (80237ac <lv_style_set_text_color+0x2c>)
 8023796:	4313      	orrs	r3, r2
 8023798:	b21b      	sxth	r3, r3
 802379a:	b29b      	uxth	r3, r3
 802379c:	883a      	ldrh	r2, [r7, #0]
 802379e:	4619      	mov	r1, r3
 80237a0:	6878      	ldr	r0, [r7, #4]
 80237a2:	f7ec f8a9 	bl	800f8f8 <_lv_style_set_color>
 80237a6:	3708      	adds	r7, #8
 80237a8:	46bd      	mov	sp, r7
 80237aa:	bd80      	pop	{r7, pc}
 80237ac:	ffff8089 	.word	0xffff8089

080237b0 <lv_style_set_text_font>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_SEL_COLOR, text_sel_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_OPA, text_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
 80237b0:	b580      	push	{r7, lr}
 80237b2:	b084      	sub	sp, #16
 80237b4:	af00      	add	r7, sp, #0
 80237b6:	60f8      	str	r0, [r7, #12]
 80237b8:	460b      	mov	r3, r1
 80237ba:	607a      	str	r2, [r7, #4]
 80237bc:	72fb      	strb	r3, [r7, #11]
 80237be:	7afb      	ldrb	r3, [r7, #11]
 80237c0:	021b      	lsls	r3, r3, #8
 80237c2:	b21a      	sxth	r2, r3
 80237c4:	4b05      	ldr	r3, [pc, #20]	; (80237dc <lv_style_set_text_font+0x2c>)
 80237c6:	4313      	orrs	r3, r2
 80237c8:	b21b      	sxth	r3, r3
 80237ca:	b29b      	uxth	r3, r3
 80237cc:	687a      	ldr	r2, [r7, #4]
 80237ce:	4619      	mov	r1, r3
 80237d0:	68f8      	ldr	r0, [r7, #12]
 80237d2:	f7ec f9b1 	bl	800fb38 <_lv_style_set_ptr>
 80237d6:	3710      	adds	r7, #16
 80237d8:	46bd      	mov	sp, r7
 80237da:	bd80      	pop	{r7, pc}
 80237dc:	ffff808e 	.word	0xffff808e

080237e0 <lv_style_set_line_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_WIDTH, line_width, lv_style_int_t, _int, scalar)
 80237e0:	b580      	push	{r7, lr}
 80237e2:	b082      	sub	sp, #8
 80237e4:	af00      	add	r7, sp, #0
 80237e6:	6078      	str	r0, [r7, #4]
 80237e8:	460b      	mov	r3, r1
 80237ea:	70fb      	strb	r3, [r7, #3]
 80237ec:	4613      	mov	r3, r2
 80237ee:	803b      	strh	r3, [r7, #0]
 80237f0:	78fb      	ldrb	r3, [r7, #3]
 80237f2:	021b      	lsls	r3, r3, #8
 80237f4:	b21b      	sxth	r3, r3
 80237f6:	f043 0390 	orr.w	r3, r3, #144	; 0x90
 80237fa:	b21b      	sxth	r3, r3
 80237fc:	b29b      	uxth	r3, r3
 80237fe:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023802:	4619      	mov	r1, r3
 8023804:	6878      	ldr	r0, [r7, #4]
 8023806:	f7eb ffe7 	bl	800f7d8 <_lv_style_set_int>
 802380a:	3708      	adds	r7, #8
 802380c:	46bd      	mov	sp, r7
 802380e:	bd80      	pop	{r7, pc}

08023810 <lv_style_set_line_dash_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_BLEND_MODE, line_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_DASH_WIDTH, line_dash_width, lv_style_int_t, _int, scalar)
 8023810:	b580      	push	{r7, lr}
 8023812:	b082      	sub	sp, #8
 8023814:	af00      	add	r7, sp, #0
 8023816:	6078      	str	r0, [r7, #4]
 8023818:	460b      	mov	r3, r1
 802381a:	70fb      	strb	r3, [r7, #3]
 802381c:	4613      	mov	r3, r2
 802381e:	803b      	strh	r3, [r7, #0]
 8023820:	78fb      	ldrb	r3, [r7, #3]
 8023822:	021b      	lsls	r3, r3, #8
 8023824:	b21b      	sxth	r3, r3
 8023826:	f043 0392 	orr.w	r3, r3, #146	; 0x92
 802382a:	b21b      	sxth	r3, r3
 802382c:	b29b      	uxth	r3, r3
 802382e:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023832:	4619      	mov	r1, r3
 8023834:	6878      	ldr	r0, [r7, #4]
 8023836:	f7eb ffcf 	bl	800f7d8 <_lv_style_set_int>
 802383a:	3708      	adds	r7, #8
 802383c:	46bd      	mov	sp, r7
 802383e:	bd80      	pop	{r7, pc}

08023840 <lv_style_set_line_dash_gap>:
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_DASH_GAP, line_dash_gap, lv_style_int_t, _int, scalar)
 8023840:	b580      	push	{r7, lr}
 8023842:	b082      	sub	sp, #8
 8023844:	af00      	add	r7, sp, #0
 8023846:	6078      	str	r0, [r7, #4]
 8023848:	460b      	mov	r3, r1
 802384a:	70fb      	strb	r3, [r7, #3]
 802384c:	4613      	mov	r3, r2
 802384e:	803b      	strh	r3, [r7, #0]
 8023850:	78fb      	ldrb	r3, [r7, #3]
 8023852:	021b      	lsls	r3, r3, #8
 8023854:	b21b      	sxth	r3, r3
 8023856:	f043 0393 	orr.w	r3, r3, #147	; 0x93
 802385a:	b21b      	sxth	r3, r3
 802385c:	b29b      	uxth	r3, r3
 802385e:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023862:	4619      	mov	r1, r3
 8023864:	6878      	ldr	r0, [r7, #4]
 8023866:	f7eb ffb7 	bl	800f7d8 <_lv_style_set_int>
 802386a:	3708      	adds	r7, #8
 802386c:	46bd      	mov	sp, r7
 802386e:	bd80      	pop	{r7, pc}

08023870 <lv_style_set_line_rounded>:
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_ROUNDED, line_rounded, bool, _int, scalar)
 8023870:	b580      	push	{r7, lr}
 8023872:	b082      	sub	sp, #8
 8023874:	af00      	add	r7, sp, #0
 8023876:	6078      	str	r0, [r7, #4]
 8023878:	460b      	mov	r3, r1
 802387a:	70fb      	strb	r3, [r7, #3]
 802387c:	4613      	mov	r3, r2
 802387e:	70bb      	strb	r3, [r7, #2]
 8023880:	78fb      	ldrb	r3, [r7, #3]
 8023882:	021b      	lsls	r3, r3, #8
 8023884:	b21b      	sxth	r3, r3
 8023886:	f043 0394 	orr.w	r3, r3, #148	; 0x94
 802388a:	b21b      	sxth	r3, r3
 802388c:	b29b      	uxth	r3, r3
 802388e:	78ba      	ldrb	r2, [r7, #2]
 8023890:	b212      	sxth	r2, r2
 8023892:	4619      	mov	r1, r3
 8023894:	6878      	ldr	r0, [r7, #4]
 8023896:	f7eb ff9f 	bl	800f7d8 <_lv_style_set_int>
 802389a:	3708      	adds	r7, #8
 802389c:	46bd      	mov	sp, r7
 802389e:	bd80      	pop	{r7, pc}

080238a0 <lv_style_set_line_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_COLOR, line_color, lv_color_t, _color, nonscalar)
 80238a0:	b580      	push	{r7, lr}
 80238a2:	b082      	sub	sp, #8
 80238a4:	af00      	add	r7, sp, #0
 80238a6:	6078      	str	r0, [r7, #4]
 80238a8:	460b      	mov	r3, r1
 80238aa:	803a      	strh	r2, [r7, #0]
 80238ac:	70fb      	strb	r3, [r7, #3]
 80238ae:	78fb      	ldrb	r3, [r7, #3]
 80238b0:	021b      	lsls	r3, r3, #8
 80238b2:	b21b      	sxth	r3, r3
 80238b4:	f043 0399 	orr.w	r3, r3, #153	; 0x99
 80238b8:	b21b      	sxth	r3, r3
 80238ba:	b29b      	uxth	r3, r3
 80238bc:	883a      	ldrh	r2, [r7, #0]
 80238be:	4619      	mov	r1, r3
 80238c0:	6878      	ldr	r0, [r7, #4]
 80238c2:	f7ec f819 	bl	800f8f8 <_lv_style_set_color>
 80238c6:	3708      	adds	r7, #8
 80238c8:	46bd      	mov	sp, r7
 80238ca:	bd80      	pop	{r7, pc}

080238cc <lv_style_set_image_recolor>:
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_OPA, line_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_BLEND_MODE, image_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
 80238cc:	b580      	push	{r7, lr}
 80238ce:	b082      	sub	sp, #8
 80238d0:	af00      	add	r7, sp, #0
 80238d2:	6078      	str	r0, [r7, #4]
 80238d4:	460b      	mov	r3, r1
 80238d6:	803a      	strh	r2, [r7, #0]
 80238d8:	70fb      	strb	r3, [r7, #3]
 80238da:	78fb      	ldrb	r3, [r7, #3]
 80238dc:	021b      	lsls	r3, r3, #8
 80238de:	b21a      	sxth	r2, r3
 80238e0:	4b05      	ldr	r3, [pc, #20]	; (80238f8 <lv_style_set_image_recolor+0x2c>)
 80238e2:	4313      	orrs	r3, r2
 80238e4:	b21b      	sxth	r3, r3
 80238e6:	b29b      	uxth	r3, r3
 80238e8:	883a      	ldrh	r2, [r7, #0]
 80238ea:	4619      	mov	r1, r3
 80238ec:	6878      	ldr	r0, [r7, #4]
 80238ee:	f7ec f803 	bl	800f8f8 <_lv_style_set_color>
 80238f2:	3708      	adds	r7, #8
 80238f4:	46bd      	mov	sp, r7
 80238f6:	bd80      	pop	{r7, pc}
 80238f8:	ffff80a9 	.word	0xffff80a9

080238fc <lv_style_set_transition_time>:
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_OPA, image_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR_OPA, image_recolor_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_TIME, transition_time, lv_style_int_t, _int, scalar)
 80238fc:	b580      	push	{r7, lr}
 80238fe:	b082      	sub	sp, #8
 8023900:	af00      	add	r7, sp, #0
 8023902:	6078      	str	r0, [r7, #4]
 8023904:	460b      	mov	r3, r1
 8023906:	70fb      	strb	r3, [r7, #3]
 8023908:	4613      	mov	r3, r2
 802390a:	803b      	strh	r3, [r7, #0]
 802390c:	78fb      	ldrb	r3, [r7, #3]
 802390e:	021b      	lsls	r3, r3, #8
 8023910:	b21b      	sxth	r3, r3
 8023912:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
 8023916:	b21b      	sxth	r3, r3
 8023918:	b29b      	uxth	r3, r3
 802391a:	f9b7 2000 	ldrsh.w	r2, [r7]
 802391e:	4619      	mov	r1, r3
 8023920:	6878      	ldr	r0, [r7, #4]
 8023922:	f7eb ff59 	bl	800f7d8 <_lv_style_set_int>
 8023926:	3708      	adds	r7, #8
 8023928:	46bd      	mov	sp, r7
 802392a:	bd80      	pop	{r7, pc}

0802392c <lv_style_set_transition_delay>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_DELAY, transition_delay, lv_style_int_t, _int, scalar)
 802392c:	b580      	push	{r7, lr}
 802392e:	b082      	sub	sp, #8
 8023930:	af00      	add	r7, sp, #0
 8023932:	6078      	str	r0, [r7, #4]
 8023934:	460b      	mov	r3, r1
 8023936:	70fb      	strb	r3, [r7, #3]
 8023938:	4613      	mov	r3, r2
 802393a:	803b      	strh	r3, [r7, #0]
 802393c:	78fb      	ldrb	r3, [r7, #3]
 802393e:	021b      	lsls	r3, r3, #8
 8023940:	b21b      	sxth	r3, r3
 8023942:	f043 03b1 	orr.w	r3, r3, #177	; 0xb1
 8023946:	b21b      	sxth	r3, r3
 8023948:	b29b      	uxth	r3, r3
 802394a:	f9b7 2000 	ldrsh.w	r2, [r7]
 802394e:	4619      	mov	r1, r3
 8023950:	6878      	ldr	r0, [r7, #4]
 8023952:	f7eb ff41 	bl	800f7d8 <_lv_style_set_int>
 8023956:	3708      	adds	r7, #8
 8023958:	46bd      	mov	sp, r7
 802395a:	bd80      	pop	{r7, pc}

0802395c <lv_style_set_transition_prop_3>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_1, transition_prop_1, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_2, transition_prop_2, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_3, transition_prop_3, lv_style_int_t, _int, scalar)
 802395c:	b580      	push	{r7, lr}
 802395e:	b082      	sub	sp, #8
 8023960:	af00      	add	r7, sp, #0
 8023962:	6078      	str	r0, [r7, #4]
 8023964:	460b      	mov	r3, r1
 8023966:	70fb      	strb	r3, [r7, #3]
 8023968:	4613      	mov	r3, r2
 802396a:	803b      	strh	r3, [r7, #0]
 802396c:	78fb      	ldrb	r3, [r7, #3]
 802396e:	021b      	lsls	r3, r3, #8
 8023970:	b21b      	sxth	r3, r3
 8023972:	f043 03b4 	orr.w	r3, r3, #180	; 0xb4
 8023976:	b21b      	sxth	r3, r3
 8023978:	b29b      	uxth	r3, r3
 802397a:	f9b7 2000 	ldrsh.w	r2, [r7]
 802397e:	4619      	mov	r1, r3
 8023980:	6878      	ldr	r0, [r7, #4]
 8023982:	f7eb ff29 	bl	800f7d8 <_lv_style_set_int>
 8023986:	3708      	adds	r7, #8
 8023988:	46bd      	mov	sp, r7
 802398a:	bd80      	pop	{r7, pc}

0802398c <lv_style_set_transition_prop_4>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_4, transition_prop_4, lv_style_int_t, _int, scalar)
 802398c:	b580      	push	{r7, lr}
 802398e:	b082      	sub	sp, #8
 8023990:	af00      	add	r7, sp, #0
 8023992:	6078      	str	r0, [r7, #4]
 8023994:	460b      	mov	r3, r1
 8023996:	70fb      	strb	r3, [r7, #3]
 8023998:	4613      	mov	r3, r2
 802399a:	803b      	strh	r3, [r7, #0]
 802399c:	78fb      	ldrb	r3, [r7, #3]
 802399e:	021b      	lsls	r3, r3, #8
 80239a0:	b21b      	sxth	r3, r3
 80239a2:	f043 03b5 	orr.w	r3, r3, #181	; 0xb5
 80239a6:	b21b      	sxth	r3, r3
 80239a8:	b29b      	uxth	r3, r3
 80239aa:	f9b7 2000 	ldrsh.w	r2, [r7]
 80239ae:	4619      	mov	r1, r3
 80239b0:	6878      	ldr	r0, [r7, #4]
 80239b2:	f7eb ff11 	bl	800f7d8 <_lv_style_set_int>
 80239b6:	3708      	adds	r7, #8
 80239b8:	46bd      	mov	sp, r7
 80239ba:	bd80      	pop	{r7, pc}

080239bc <lv_style_set_transition_prop_5>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_5, transition_prop_5, lv_style_int_t, _int, scalar)
 80239bc:	b580      	push	{r7, lr}
 80239be:	b082      	sub	sp, #8
 80239c0:	af00      	add	r7, sp, #0
 80239c2:	6078      	str	r0, [r7, #4]
 80239c4:	460b      	mov	r3, r1
 80239c6:	70fb      	strb	r3, [r7, #3]
 80239c8:	4613      	mov	r3, r2
 80239ca:	803b      	strh	r3, [r7, #0]
 80239cc:	78fb      	ldrb	r3, [r7, #3]
 80239ce:	021b      	lsls	r3, r3, #8
 80239d0:	b21b      	sxth	r3, r3
 80239d2:	f043 03b6 	orr.w	r3, r3, #182	; 0xb6
 80239d6:	b21b      	sxth	r3, r3
 80239d8:	b29b      	uxth	r3, r3
 80239da:	f9b7 2000 	ldrsh.w	r2, [r7]
 80239de:	4619      	mov	r1, r3
 80239e0:	6878      	ldr	r0, [r7, #4]
 80239e2:	f7eb fef9 	bl	800f7d8 <_lv_style_set_int>
 80239e6:	3708      	adds	r7, #8
 80239e8:	46bd      	mov	sp, r7
 80239ea:	bd80      	pop	{r7, pc}

080239ec <lv_style_set_transition_prop_6>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PROP_6, transition_prop_6, lv_style_int_t, _int, scalar)
 80239ec:	b580      	push	{r7, lr}
 80239ee:	b082      	sub	sp, #8
 80239f0:	af00      	add	r7, sp, #0
 80239f2:	6078      	str	r0, [r7, #4]
 80239f4:	460b      	mov	r3, r1
 80239f6:	70fb      	strb	r3, [r7, #3]
 80239f8:	4613      	mov	r3, r2
 80239fa:	803b      	strh	r3, [r7, #0]
 80239fc:	78fb      	ldrb	r3, [r7, #3]
 80239fe:	021b      	lsls	r3, r3, #8
 8023a00:	b21b      	sxth	r3, r3
 8023a02:	f043 03b7 	orr.w	r3, r3, #183	; 0xb7
 8023a06:	b21b      	sxth	r3, r3
 8023a08:	b29b      	uxth	r3, r3
 8023a0a:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023a0e:	4619      	mov	r1, r3
 8023a10:	6878      	ldr	r0, [r7, #4]
 8023a12:	f7eb fee1 	bl	800f7d8 <_lv_style_set_int>
 8023a16:	3708      	adds	r7, #8
 8023a18:	46bd      	mov	sp, r7
 8023a1a:	bd80      	pop	{r7, pc}

08023a1c <lv_style_set_scale_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PATH, transition_path, lv_anim_path_t *, _ptr, scalar)
#else
/*For compatibility*/
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSITION_PATH, transition_path, const void *, _ptr, scalar)
#endif
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_WIDTH, scale_width, lv_style_int_t, _int, scalar)
 8023a1c:	b580      	push	{r7, lr}
 8023a1e:	b082      	sub	sp, #8
 8023a20:	af00      	add	r7, sp, #0
 8023a22:	6078      	str	r0, [r7, #4]
 8023a24:	460b      	mov	r3, r1
 8023a26:	70fb      	strb	r3, [r7, #3]
 8023a28:	4613      	mov	r3, r2
 8023a2a:	803b      	strh	r3, [r7, #0]
 8023a2c:	78fb      	ldrb	r3, [r7, #3]
 8023a2e:	021b      	lsls	r3, r3, #8
 8023a30:	b21b      	sxth	r3, r3
 8023a32:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8023a36:	b21b      	sxth	r3, r3
 8023a38:	b29b      	uxth	r3, r3
 8023a3a:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023a3e:	4619      	mov	r1, r3
 8023a40:	6878      	ldr	r0, [r7, #4]
 8023a42:	f7eb fec9 	bl	800f7d8 <_lv_style_set_int>
 8023a46:	3708      	adds	r7, #8
 8023a48:	46bd      	mov	sp, r7
 8023a4a:	bd80      	pop	{r7, pc}

08023a4c <lv_style_set_scale_end_border_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_BORDER_WIDTH, scale_border_width, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_BORDER_WIDTH, scale_end_border_width, lv_style_int_t, _int, scalar)
 8023a4c:	b580      	push	{r7, lr}
 8023a4e:	b082      	sub	sp, #8
 8023a50:	af00      	add	r7, sp, #0
 8023a52:	6078      	str	r0, [r7, #4]
 8023a54:	460b      	mov	r3, r1
 8023a56:	70fb      	strb	r3, [r7, #3]
 8023a58:	4613      	mov	r3, r2
 8023a5a:	803b      	strh	r3, [r7, #0]
 8023a5c:	78fb      	ldrb	r3, [r7, #3]
 8023a5e:	021b      	lsls	r3, r3, #8
 8023a60:	b21b      	sxth	r3, r3
 8023a62:	f043 03c2 	orr.w	r3, r3, #194	; 0xc2
 8023a66:	b21b      	sxth	r3, r3
 8023a68:	b29b      	uxth	r3, r3
 8023a6a:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023a6e:	4619      	mov	r1, r3
 8023a70:	6878      	ldr	r0, [r7, #4]
 8023a72:	f7eb feb1 	bl	800f7d8 <_lv_style_set_int>
 8023a76:	3708      	adds	r7, #8
 8023a78:	46bd      	mov	sp, r7
 8023a7a:	bd80      	pop	{r7, pc}

08023a7c <lv_style_set_scale_end_line_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_LINE_WIDTH, scale_end_line_width, lv_style_int_t, _int, scalar)
 8023a7c:	b580      	push	{r7, lr}
 8023a7e:	b082      	sub	sp, #8
 8023a80:	af00      	add	r7, sp, #0
 8023a82:	6078      	str	r0, [r7, #4]
 8023a84:	460b      	mov	r3, r1
 8023a86:	70fb      	strb	r3, [r7, #3]
 8023a88:	4613      	mov	r3, r2
 8023a8a:	803b      	strh	r3, [r7, #0]
 8023a8c:	78fb      	ldrb	r3, [r7, #3]
 8023a8e:	021b      	lsls	r3, r3, #8
 8023a90:	b21b      	sxth	r3, r3
 8023a92:	f043 03c3 	orr.w	r3, r3, #195	; 0xc3
 8023a96:	b21b      	sxth	r3, r3
 8023a98:	b29b      	uxth	r3, r3
 8023a9a:	f9b7 2000 	ldrsh.w	r2, [r7]
 8023a9e:	4619      	mov	r1, r3
 8023aa0:	6878      	ldr	r0, [r7, #4]
 8023aa2:	f7eb fe99 	bl	800f7d8 <_lv_style_set_int>
 8023aa6:	3708      	adds	r7, #8
 8023aa8:	46bd      	mov	sp, r7
 8023aaa:	bd80      	pop	{r7, pc}

08023aac <lv_style_set_scale_grad_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_GRAD_COLOR, scale_grad_color, lv_color_t, _color, nonscalar)
 8023aac:	b580      	push	{r7, lr}
 8023aae:	b082      	sub	sp, #8
 8023ab0:	af00      	add	r7, sp, #0
 8023ab2:	6078      	str	r0, [r7, #4]
 8023ab4:	460b      	mov	r3, r1
 8023ab6:	803a      	strh	r2, [r7, #0]
 8023ab8:	70fb      	strb	r3, [r7, #3]
 8023aba:	78fb      	ldrb	r3, [r7, #3]
 8023abc:	021b      	lsls	r3, r3, #8
 8023abe:	b21b      	sxth	r3, r3
 8023ac0:	f043 03c9 	orr.w	r3, r3, #201	; 0xc9
 8023ac4:	b21b      	sxth	r3, r3
 8023ac6:	b29b      	uxth	r3, r3
 8023ac8:	883a      	ldrh	r2, [r7, #0]
 8023aca:	4619      	mov	r1, r3
 8023acc:	6878      	ldr	r0, [r7, #4]
 8023ace:	f7eb ff13 	bl	800f8f8 <_lv_style_set_color>
 8023ad2:	3708      	adds	r7, #8
 8023ad4:	46bd      	mov	sp, r7
 8023ad6:	bd80      	pop	{r7, pc}

08023ad8 <lv_style_set_scale_end_color>:
_LV_OBJ_STYLE_SET_GET_DECLARE(SCALE_END_COLOR, scale_end_color, lv_color_t, _color, nonscalar)
 8023ad8:	b580      	push	{r7, lr}
 8023ada:	b082      	sub	sp, #8
 8023adc:	af00      	add	r7, sp, #0
 8023ade:	6078      	str	r0, [r7, #4]
 8023ae0:	460b      	mov	r3, r1
 8023ae2:	803a      	strh	r2, [r7, #0]
 8023ae4:	70fb      	strb	r3, [r7, #3]
 8023ae6:	78fb      	ldrb	r3, [r7, #3]
 8023ae8:	021b      	lsls	r3, r3, #8
 8023aea:	b21b      	sxth	r3, r3
 8023aec:	f043 03ca 	orr.w	r3, r3, #202	; 0xca
 8023af0:	b21b      	sxth	r3, r3
 8023af2:	b29b      	uxth	r3, r3
 8023af4:	883a      	ldrh	r2, [r7, #0]
 8023af6:	4619      	mov	r1, r3
 8023af8:	6878      	ldr	r0, [r7, #4]
 8023afa:	f7eb fefd 	bl	800f8f8 <_lv_style_set_color>
 8023afe:	3708      	adds	r7, #8
 8023b00:	46bd      	mov	sp, r7
 8023b02:	bd80      	pop	{r7, pc}

08023b04 <basic_init>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void basic_init(void)
{
 8023b04:	b5b0      	push	{r4, r5, r7, lr}
 8023b06:	b082      	sub	sp, #8
 8023b08:	af00      	add	r7, sp, #0
    style_init_reset(&styles->scr);
 8023b0a:	4bb0      	ldr	r3, [pc, #704]	; (8023dcc <basic_init+0x2c8>)
 8023b0c:	681b      	ldr	r3, [r3, #0]
 8023b0e:	4618      	mov	r0, r3
 8023b10:	f005 fe7c 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->scr, LV_STATE_DEFAULT, LV_OPA_COVER);
 8023b14:	4bad      	ldr	r3, [pc, #692]	; (8023dcc <basic_init+0x2c8>)
 8023b16:	681b      	ldr	r3, [r3, #0]
 8023b18:	22ff      	movs	r2, #255	; 0xff
 8023b1a:	2100      	movs	r1, #0
 8023b1c:	4618      	mov	r0, r3
 8023b1e:	f7ff fc76 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->scr, LV_STATE_DEFAULT, COLOR_SCR);
 8023b22:	4baa      	ldr	r3, [pc, #680]	; (8023dcc <basic_init+0x2c8>)
 8023b24:	681b      	ldr	r3, [r3, #0]
 8023b26:	461c      	mov	r4, r3
 8023b28:	4ba9      	ldr	r3, [pc, #676]	; (8023dd0 <basic_init+0x2cc>)
 8023b2a:	6a1b      	ldr	r3, [r3, #32]
 8023b2c:	f003 0302 	and.w	r3, r3, #2
 8023b30:	2b00      	cmp	r3, #0
 8023b32:	d004      	beq.n	8023b3e <basic_init+0x3a>
 8023b34:	48a7      	ldr	r0, [pc, #668]	; (8023dd4 <basic_init+0x2d0>)
 8023b36:	f7ff fad6 	bl	80230e6 <lv_color_hex>
 8023b3a:	4603      	mov	r3, r0
 8023b3c:	e003      	b.n	8023b46 <basic_init+0x42>
 8023b3e:	48a6      	ldr	r0, [pc, #664]	; (8023dd8 <basic_init+0x2d4>)
 8023b40:	f7ff fad1 	bl	80230e6 <lv_color_hex>
 8023b44:	4603      	mov	r3, r0
 8023b46:	461a      	mov	r2, r3
 8023b48:	2100      	movs	r1, #0
 8023b4a:	4620      	mov	r0, r4
 8023b4c:	f7ff fc49 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_text_color(&styles->scr, LV_STATE_DEFAULT, COLOR_SCR_TEXT);
 8023b50:	4b9e      	ldr	r3, [pc, #632]	; (8023dcc <basic_init+0x2c8>)
 8023b52:	681b      	ldr	r3, [r3, #0]
 8023b54:	461c      	mov	r4, r3
 8023b56:	4b9e      	ldr	r3, [pc, #632]	; (8023dd0 <basic_init+0x2cc>)
 8023b58:	6a1b      	ldr	r3, [r3, #32]
 8023b5a:	f003 0302 	and.w	r3, r3, #2
 8023b5e:	2b00      	cmp	r3, #0
 8023b60:	d004      	beq.n	8023b6c <basic_init+0x68>
 8023b62:	489e      	ldr	r0, [pc, #632]	; (8023ddc <basic_init+0x2d8>)
 8023b64:	f7ff fabf 	bl	80230e6 <lv_color_hex>
 8023b68:	4603      	mov	r3, r0
 8023b6a:	e003      	b.n	8023b74 <basic_init+0x70>
 8023b6c:	489c      	ldr	r0, [pc, #624]	; (8023de0 <basic_init+0x2dc>)
 8023b6e:	f7ff faba 	bl	80230e6 <lv_color_hex>
 8023b72:	4603      	mov	r3, r0
 8023b74:	461a      	mov	r2, r3
 8023b76:	2100      	movs	r1, #0
 8023b78:	4620      	mov	r0, r4
 8023b7a:	f7ff fe01 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_value_color(&styles->scr, LV_STATE_DEFAULT, COLOR_SCR_TEXT);
 8023b7e:	4b93      	ldr	r3, [pc, #588]	; (8023dcc <basic_init+0x2c8>)
 8023b80:	681b      	ldr	r3, [r3, #0]
 8023b82:	461c      	mov	r4, r3
 8023b84:	4b92      	ldr	r3, [pc, #584]	; (8023dd0 <basic_init+0x2cc>)
 8023b86:	6a1b      	ldr	r3, [r3, #32]
 8023b88:	f003 0302 	and.w	r3, r3, #2
 8023b8c:	2b00      	cmp	r3, #0
 8023b8e:	d004      	beq.n	8023b9a <basic_init+0x96>
 8023b90:	4892      	ldr	r0, [pc, #584]	; (8023ddc <basic_init+0x2d8>)
 8023b92:	f7ff faa8 	bl	80230e6 <lv_color_hex>
 8023b96:	4603      	mov	r3, r0
 8023b98:	e003      	b.n	8023ba2 <basic_init+0x9e>
 8023b9a:	4891      	ldr	r0, [pc, #580]	; (8023de0 <basic_init+0x2dc>)
 8023b9c:	f7ff faa3 	bl	80230e6 <lv_color_hex>
 8023ba0:	4603      	mov	r3, r0
 8023ba2:	461a      	mov	r2, r3
 8023ba4:	2100      	movs	r1, #0
 8023ba6:	4620      	mov	r0, r4
 8023ba8:	f7ff fda3 	bl	80236f2 <lv_style_set_value_color>
    lv_style_set_text_font(&styles->scr, LV_STATE_DEFAULT, theme.font_normal);
 8023bac:	4b87      	ldr	r3, [pc, #540]	; (8023dcc <basic_init+0x2c8>)
 8023bae:	681b      	ldr	r3, [r3, #0]
 8023bb0:	4618      	mov	r0, r3
 8023bb2:	4b87      	ldr	r3, [pc, #540]	; (8023dd0 <basic_init+0x2cc>)
 8023bb4:	695b      	ldr	r3, [r3, #20]
 8023bb6:	461a      	mov	r2, r3
 8023bb8:	2100      	movs	r1, #0
 8023bba:	f7ff fdf9 	bl	80237b0 <lv_style_set_text_font>
    lv_style_set_value_font(&styles->scr, LV_STATE_DEFAULT, theme.font_normal);
 8023bbe:	4b83      	ldr	r3, [pc, #524]	; (8023dcc <basic_init+0x2c8>)
 8023bc0:	681b      	ldr	r3, [r3, #0]
 8023bc2:	4618      	mov	r0, r3
 8023bc4:	4b82      	ldr	r3, [pc, #520]	; (8023dd0 <basic_init+0x2cc>)
 8023bc6:	695b      	ldr	r3, [r3, #20]
 8023bc8:	461a      	mov	r2, r3
 8023bca:	2100      	movs	r1, #0
 8023bcc:	f7ff fda7 	bl	802371e <lv_style_set_value_font>

    style_init_reset(&styles->bg);
 8023bd0:	4b7e      	ldr	r3, [pc, #504]	; (8023dcc <basic_init+0x2c8>)
 8023bd2:	681b      	ldr	r3, [r3, #0]
 8023bd4:	3304      	adds	r3, #4
 8023bd6:	4618      	mov	r0, r3
 8023bd8:	f005 fe18 	bl	802980c <style_init_reset>
    lv_style_set_radius(&styles->bg, LV_STATE_DEFAULT, LV_DPX(8));
 8023bdc:	4b7b      	ldr	r3, [pc, #492]	; (8023dcc <basic_init+0x2c8>)
 8023bde:	681b      	ldr	r3, [r3, #0]
 8023be0:	1d1c      	adds	r4, r3, #4
 8023be2:	2000      	movs	r0, #0
 8023be4:	f7fa ff96 	bl	801eb14 <lv_disp_get_dpi>
 8023be8:	4603      	mov	r3, r0
 8023bea:	2b1d      	cmp	r3, #29
 8023bec:	dd0c      	ble.n	8023c08 <basic_init+0x104>
 8023bee:	2000      	movs	r0, #0
 8023bf0:	f7fa ff90 	bl	801eb14 <lv_disp_get_dpi>
 8023bf4:	4603      	mov	r3, r0
 8023bf6:	330a      	adds	r3, #10
 8023bf8:	4a7a      	ldr	r2, [pc, #488]	; (8023de4 <basic_init+0x2e0>)
 8023bfa:	fb82 1203 	smull	r1, r2, r2, r3
 8023bfe:	10d2      	asrs	r2, r2, #3
 8023c00:	17db      	asrs	r3, r3, #31
 8023c02:	1ad3      	subs	r3, r2, r3
 8023c04:	b21b      	sxth	r3, r3
 8023c06:	e000      	b.n	8023c0a <basic_init+0x106>
 8023c08:	2301      	movs	r3, #1
 8023c0a:	461a      	mov	r2, r3
 8023c0c:	2100      	movs	r1, #0
 8023c0e:	4620      	mov	r0, r4
 8023c10:	f7ff faaf 	bl	8023172 <lv_style_set_radius>
    lv_style_set_bg_opa(&styles->bg, LV_STATE_DEFAULT, LV_OPA_COVER);
 8023c14:	4b6d      	ldr	r3, [pc, #436]	; (8023dcc <basic_init+0x2c8>)
 8023c16:	681b      	ldr	r3, [r3, #0]
 8023c18:	3304      	adds	r3, #4
 8023c1a:	22ff      	movs	r2, #255	; 0xff
 8023c1c:	2100      	movs	r1, #0
 8023c1e:	4618      	mov	r0, r3
 8023c20:	f7ff fbf5 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->bg, LV_STATE_DEFAULT, COLOR_BG);
 8023c24:	4b69      	ldr	r3, [pc, #420]	; (8023dcc <basic_init+0x2c8>)
 8023c26:	681b      	ldr	r3, [r3, #0]
 8023c28:	1d1c      	adds	r4, r3, #4
 8023c2a:	4b69      	ldr	r3, [pc, #420]	; (8023dd0 <basic_init+0x2cc>)
 8023c2c:	6a1b      	ldr	r3, [r3, #32]
 8023c2e:	f003 0302 	and.w	r3, r3, #2
 8023c32:	2b00      	cmp	r3, #0
 8023c34:	d005      	beq.n	8023c42 <basic_init+0x13e>
 8023c36:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8023c3a:	f7ff fa54 	bl	80230e6 <lv_color_hex>
 8023c3e:	4603      	mov	r3, r0
 8023c40:	e003      	b.n	8023c4a <basic_init+0x146>
 8023c42:	4869      	ldr	r0, [pc, #420]	; (8023de8 <basic_init+0x2e4>)
 8023c44:	f7ff fa4f 	bl	80230e6 <lv_color_hex>
 8023c48:	4603      	mov	r3, r0
 8023c4a:	461a      	mov	r2, r3
 8023c4c:	2100      	movs	r1, #0
 8023c4e:	4620      	mov	r0, r4
 8023c50:	f7ff fbc7 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_border_color(&styles->bg, LV_STATE_DEFAULT, COLOR_BG_BORDER);
 8023c54:	4b5d      	ldr	r3, [pc, #372]	; (8023dcc <basic_init+0x2c8>)
 8023c56:	681b      	ldr	r3, [r3, #0]
 8023c58:	1d1c      	adds	r4, r3, #4
 8023c5a:	4b5d      	ldr	r3, [pc, #372]	; (8023dd0 <basic_init+0x2cc>)
 8023c5c:	6a1b      	ldr	r3, [r3, #32]
 8023c5e:	f003 0302 	and.w	r3, r3, #2
 8023c62:	2b00      	cmp	r3, #0
 8023c64:	d004      	beq.n	8023c70 <basic_init+0x16c>
 8023c66:	4861      	ldr	r0, [pc, #388]	; (8023dec <basic_init+0x2e8>)
 8023c68:	f7ff fa3d 	bl	80230e6 <lv_color_hex>
 8023c6c:	4603      	mov	r3, r0
 8023c6e:	e003      	b.n	8023c78 <basic_init+0x174>
 8023c70:	485f      	ldr	r0, [pc, #380]	; (8023df0 <basic_init+0x2ec>)
 8023c72:	f7ff fa38 	bl	80230e6 <lv_color_hex>
 8023c76:	4603      	mov	r3, r0
 8023c78:	461a      	mov	r2, r3
 8023c7a:	2100      	movs	r1, #0
 8023c7c:	4620      	mov	r0, r4
 8023c7e:	f7ff fc25 	bl	80234cc <lv_style_set_border_color>
    if((theme.flags & LV_THEME_MATERIAL_FLAG_NO_FOCUS) == 0)lv_style_set_border_color(&styles->bg, LV_STATE_FOCUSED,
 8023c82:	4b53      	ldr	r3, [pc, #332]	; (8023dd0 <basic_init+0x2cc>)
 8023c84:	6a1b      	ldr	r3, [r3, #32]
 8023c86:	f003 0320 	and.w	r3, r3, #32
 8023c8a:	2b00      	cmp	r3, #0
 8023c8c:	d108      	bne.n	8023ca0 <basic_init+0x19c>
 8023c8e:	4b4f      	ldr	r3, [pc, #316]	; (8023dcc <basic_init+0x2c8>)
 8023c90:	681b      	ldr	r3, [r3, #0]
 8023c92:	3304      	adds	r3, #4
 8023c94:	4a4e      	ldr	r2, [pc, #312]	; (8023dd0 <basic_init+0x2cc>)
 8023c96:	8992      	ldrh	r2, [r2, #12]
 8023c98:	2102      	movs	r1, #2
 8023c9a:	4618      	mov	r0, r3
 8023c9c:	f7ff fc16 	bl	80234cc <lv_style_set_border_color>
                                                                                          theme.color_primary);
    lv_style_set_border_color(&styles->bg, LV_STATE_EDITED, theme.color_secondary);
 8023ca0:	4b4a      	ldr	r3, [pc, #296]	; (8023dcc <basic_init+0x2c8>)
 8023ca2:	681b      	ldr	r3, [r3, #0]
 8023ca4:	3304      	adds	r3, #4
 8023ca6:	4a4a      	ldr	r2, [pc, #296]	; (8023dd0 <basic_init+0x2cc>)
 8023ca8:	89d2      	ldrh	r2, [r2, #14]
 8023caa:	2104      	movs	r1, #4
 8023cac:	4618      	mov	r0, r3
 8023cae:	f7ff fc0d 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_width(&styles->bg, LV_STATE_DEFAULT, BORDER_WIDTH);
 8023cb2:	4b46      	ldr	r3, [pc, #280]	; (8023dcc <basic_init+0x2c8>)
 8023cb4:	681b      	ldr	r3, [r3, #0]
 8023cb6:	1d1c      	adds	r4, r3, #4
 8023cb8:	2000      	movs	r0, #0
 8023cba:	f7fa ff2b 	bl	801eb14 <lv_disp_get_dpi>
 8023cbe:	4603      	mov	r3, r0
 8023cc0:	2b77      	cmp	r3, #119	; 0x77
 8023cc2:	dd0c      	ble.n	8023cde <basic_init+0x1da>
 8023cc4:	2000      	movs	r0, #0
 8023cc6:	f7fa ff25 	bl	801eb14 <lv_disp_get_dpi>
 8023cca:	4603      	mov	r3, r0
 8023ccc:	3328      	adds	r3, #40	; 0x28
 8023cce:	4a45      	ldr	r2, [pc, #276]	; (8023de4 <basic_init+0x2e0>)
 8023cd0:	fb82 1203 	smull	r1, r2, r2, r3
 8023cd4:	1152      	asrs	r2, r2, #5
 8023cd6:	17db      	asrs	r3, r3, #31
 8023cd8:	1ad3      	subs	r3, r2, r3
 8023cda:	b21b      	sxth	r3, r3
 8023cdc:	e000      	b.n	8023ce0 <basic_init+0x1dc>
 8023cde:	2301      	movs	r3, #1
 8023ce0:	461a      	mov	r2, r3
 8023ce2:	2100      	movs	r1, #0
 8023ce4:	4620      	mov	r0, r4
 8023ce6:	f7ff fba9 	bl	802343c <lv_style_set_border_width>
    lv_style_set_border_post(&styles->bg, LV_STATE_DEFAULT, true);
 8023cea:	4b38      	ldr	r3, [pc, #224]	; (8023dcc <basic_init+0x2c8>)
 8023cec:	681b      	ldr	r3, [r3, #0]
 8023cee:	3304      	adds	r3, #4
 8023cf0:	2201      	movs	r2, #1
 8023cf2:	2100      	movs	r1, #0
 8023cf4:	4618      	mov	r0, r3
 8023cf6:	f7ff fbd1 	bl	802349c <lv_style_set_border_post>
    lv_style_set_text_font(&styles->bg, LV_STATE_DEFAULT, theme.font_normal);
 8023cfa:	4b34      	ldr	r3, [pc, #208]	; (8023dcc <basic_init+0x2c8>)
 8023cfc:	681b      	ldr	r3, [r3, #0]
 8023cfe:	3304      	adds	r3, #4
 8023d00:	4a33      	ldr	r2, [pc, #204]	; (8023dd0 <basic_init+0x2cc>)
 8023d02:	6952      	ldr	r2, [r2, #20]
 8023d04:	2100      	movs	r1, #0
 8023d06:	4618      	mov	r0, r3
 8023d08:	f7ff fd52 	bl	80237b0 <lv_style_set_text_font>
    lv_style_set_text_color(&styles->bg, LV_STATE_DEFAULT, COLOR_BG_TEXT);
 8023d0c:	4b2f      	ldr	r3, [pc, #188]	; (8023dcc <basic_init+0x2c8>)
 8023d0e:	681b      	ldr	r3, [r3, #0]
 8023d10:	1d1c      	adds	r4, r3, #4
 8023d12:	4b2f      	ldr	r3, [pc, #188]	; (8023dd0 <basic_init+0x2cc>)
 8023d14:	6a1b      	ldr	r3, [r3, #32]
 8023d16:	f003 0302 	and.w	r3, r3, #2
 8023d1a:	2b00      	cmp	r3, #0
 8023d1c:	d004      	beq.n	8023d28 <basic_init+0x224>
 8023d1e:	482f      	ldr	r0, [pc, #188]	; (8023ddc <basic_init+0x2d8>)
 8023d20:	f7ff f9e1 	bl	80230e6 <lv_color_hex>
 8023d24:	4603      	mov	r3, r0
 8023d26:	e004      	b.n	8023d32 <basic_init+0x22e>
 8023d28:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8023d2c:	f7ff f9db 	bl	80230e6 <lv_color_hex>
 8023d30:	4603      	mov	r3, r0
 8023d32:	461a      	mov	r2, r3
 8023d34:	2100      	movs	r1, #0
 8023d36:	4620      	mov	r0, r4
 8023d38:	f7ff fd22 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_value_font(&styles->bg, LV_STATE_DEFAULT, theme.font_normal);
 8023d3c:	4b23      	ldr	r3, [pc, #140]	; (8023dcc <basic_init+0x2c8>)
 8023d3e:	681b      	ldr	r3, [r3, #0]
 8023d40:	3304      	adds	r3, #4
 8023d42:	4a23      	ldr	r2, [pc, #140]	; (8023dd0 <basic_init+0x2cc>)
 8023d44:	6952      	ldr	r2, [r2, #20]
 8023d46:	2100      	movs	r1, #0
 8023d48:	4618      	mov	r0, r3
 8023d4a:	f7ff fce8 	bl	802371e <lv_style_set_value_font>
    lv_style_set_value_color(&styles->bg, LV_STATE_DEFAULT, COLOR_BG_TEXT);
 8023d4e:	4b1f      	ldr	r3, [pc, #124]	; (8023dcc <basic_init+0x2c8>)
 8023d50:	681b      	ldr	r3, [r3, #0]
 8023d52:	1d1c      	adds	r4, r3, #4
 8023d54:	4b1e      	ldr	r3, [pc, #120]	; (8023dd0 <basic_init+0x2cc>)
 8023d56:	6a1b      	ldr	r3, [r3, #32]
 8023d58:	f003 0302 	and.w	r3, r3, #2
 8023d5c:	2b00      	cmp	r3, #0
 8023d5e:	d004      	beq.n	8023d6a <basic_init+0x266>
 8023d60:	481e      	ldr	r0, [pc, #120]	; (8023ddc <basic_init+0x2d8>)
 8023d62:	f7ff f9c0 	bl	80230e6 <lv_color_hex>
 8023d66:	4603      	mov	r3, r0
 8023d68:	e004      	b.n	8023d74 <basic_init+0x270>
 8023d6a:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8023d6e:	f7ff f9ba 	bl	80230e6 <lv_color_hex>
 8023d72:	4603      	mov	r3, r0
 8023d74:	461a      	mov	r2, r3
 8023d76:	2100      	movs	r1, #0
 8023d78:	4620      	mov	r0, r4
 8023d7a:	f7ff fcba 	bl	80236f2 <lv_style_set_value_color>
    lv_style_set_image_recolor(&styles->bg, LV_STATE_DEFAULT, COLOR_BG_TEXT);
 8023d7e:	4b13      	ldr	r3, [pc, #76]	; (8023dcc <basic_init+0x2c8>)
 8023d80:	681b      	ldr	r3, [r3, #0]
 8023d82:	1d1c      	adds	r4, r3, #4
 8023d84:	4b12      	ldr	r3, [pc, #72]	; (8023dd0 <basic_init+0x2cc>)
 8023d86:	6a1b      	ldr	r3, [r3, #32]
 8023d88:	f003 0302 	and.w	r3, r3, #2
 8023d8c:	2b00      	cmp	r3, #0
 8023d8e:	d004      	beq.n	8023d9a <basic_init+0x296>
 8023d90:	4812      	ldr	r0, [pc, #72]	; (8023ddc <basic_init+0x2d8>)
 8023d92:	f7ff f9a8 	bl	80230e6 <lv_color_hex>
 8023d96:	4603      	mov	r3, r0
 8023d98:	e004      	b.n	8023da4 <basic_init+0x2a0>
 8023d9a:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8023d9e:	f7ff f9a2 	bl	80230e6 <lv_color_hex>
 8023da2:	4603      	mov	r3, r0
 8023da4:	461a      	mov	r2, r3
 8023da6:	2100      	movs	r1, #0
 8023da8:	4620      	mov	r0, r4
 8023daa:	f7ff fd8f 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_line_color(&styles->bg, LV_STATE_DEFAULT, COLOR_BG_TEXT);
 8023dae:	4b07      	ldr	r3, [pc, #28]	; (8023dcc <basic_init+0x2c8>)
 8023db0:	681b      	ldr	r3, [r3, #0]
 8023db2:	1d1c      	adds	r4, r3, #4
 8023db4:	4b06      	ldr	r3, [pc, #24]	; (8023dd0 <basic_init+0x2cc>)
 8023db6:	6a1b      	ldr	r3, [r3, #32]
 8023db8:	f003 0302 	and.w	r3, r3, #2
 8023dbc:	2b00      	cmp	r3, #0
 8023dbe:	d019      	beq.n	8023df4 <basic_init+0x2f0>
 8023dc0:	4806      	ldr	r0, [pc, #24]	; (8023ddc <basic_init+0x2d8>)
 8023dc2:	f7ff f990 	bl	80230e6 <lv_color_hex>
 8023dc6:	4603      	mov	r3, r0
 8023dc8:	e019      	b.n	8023dfe <basic_init+0x2fa>
 8023dca:	bf00      	nop
 8023dcc:	20012350 	.word	0x20012350
 8023dd0:	20012328 	.word	0x20012328
 8023dd4:	00eaeff3 	.word	0x00eaeff3
 8023dd8:	00444b5a 	.word	0x00444b5a
 8023ddc:	003b3e42 	.word	0x003b3e42
 8023de0:	00e7e9ec 	.word	0x00e7e9ec
 8023de4:	66666667 	.word	0x66666667
 8023de8:	00586273 	.word	0x00586273
 8023dec:	00d6dde3 	.word	0x00d6dde3
 8023df0:	00808a97 	.word	0x00808a97
 8023df4:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8023df8:	f7ff f975 	bl	80230e6 <lv_color_hex>
 8023dfc:	4603      	mov	r3, r0
 8023dfe:	461a      	mov	r2, r3
 8023e00:	2100      	movs	r1, #0
 8023e02:	4620      	mov	r0, r4
 8023e04:	f7ff fd4c 	bl	80238a0 <lv_style_set_line_color>
    lv_style_set_line_width(&styles->bg, LV_STATE_DEFAULT, 1);
 8023e08:	4bbf      	ldr	r3, [pc, #764]	; (8024108 <basic_init+0x604>)
 8023e0a:	681b      	ldr	r3, [r3, #0]
 8023e0c:	3304      	adds	r3, #4
 8023e0e:	2201      	movs	r2, #1
 8023e10:	2100      	movs	r1, #0
 8023e12:	4618      	mov	r0, r3
 8023e14:	f7ff fce4 	bl	80237e0 <lv_style_set_line_width>
    lv_style_set_pad_left(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
 8023e18:	4bbb      	ldr	r3, [pc, #748]	; (8024108 <basic_init+0x604>)
 8023e1a:	681b      	ldr	r3, [r3, #0]
 8023e1c:	1d1d      	adds	r5, r3, #4
 8023e1e:	2000      	movs	r0, #0
 8023e20:	f7fa fe91 	bl	801eb46 <lv_disp_get_size_category>
 8023e24:	4603      	mov	r3, r0
 8023e26:	2b01      	cmp	r3, #1
 8023e28:	d81c      	bhi.n	8023e64 <basic_init+0x360>
 8023e2a:	2000      	movs	r0, #0
 8023e2c:	f7fa fe72 	bl	801eb14 <lv_disp_get_dpi>
 8023e30:	4603      	mov	r3, r0
 8023e32:	461a      	mov	r2, r3
 8023e34:	4613      	mov	r3, r2
 8023e36:	011b      	lsls	r3, r3, #4
 8023e38:	1a9b      	subs	r3, r3, r2
 8023e3a:	2bef      	cmp	r3, #239	; 0xef
 8023e3c:	dd10      	ble.n	8023e60 <basic_init+0x35c>
 8023e3e:	2000      	movs	r0, #0
 8023e40:	f7fa fe68 	bl	801eb14 <lv_disp_get_dpi>
 8023e44:	4603      	mov	r3, r0
 8023e46:	461a      	mov	r2, r3
 8023e48:	4613      	mov	r3, r2
 8023e4a:	011b      	lsls	r3, r3, #4
 8023e4c:	1a9b      	subs	r3, r3, r2
 8023e4e:	3350      	adds	r3, #80	; 0x50
 8023e50:	4aae      	ldr	r2, [pc, #696]	; (802410c <basic_init+0x608>)
 8023e52:	fb82 1203 	smull	r1, r2, r2, r3
 8023e56:	1192      	asrs	r2, r2, #6
 8023e58:	17db      	asrs	r3, r3, #31
 8023e5a:	1ad3      	subs	r3, r2, r3
 8023e5c:	b29c      	uxth	r4, r3
 8023e5e:	e01f      	b.n	8023ea0 <basic_init+0x39c>
 8023e60:	2401      	movs	r4, #1
 8023e62:	e01d      	b.n	8023ea0 <basic_init+0x39c>
 8023e64:	2000      	movs	r0, #0
 8023e66:	f7fa fe55 	bl	801eb14 <lv_disp_get_dpi>
 8023e6a:	4603      	mov	r3, r0
 8023e6c:	461a      	mov	r2, r3
 8023e6e:	4613      	mov	r3, r2
 8023e70:	011b      	lsls	r3, r3, #4
 8023e72:	1a9b      	subs	r3, r3, r2
 8023e74:	005b      	lsls	r3, r3, #1
 8023e76:	2bef      	cmp	r3, #239	; 0xef
 8023e78:	dd11      	ble.n	8023e9e <basic_init+0x39a>
 8023e7a:	2000      	movs	r0, #0
 8023e7c:	f7fa fe4a 	bl	801eb14 <lv_disp_get_dpi>
 8023e80:	4603      	mov	r3, r0
 8023e82:	461a      	mov	r2, r3
 8023e84:	4613      	mov	r3, r2
 8023e86:	011b      	lsls	r3, r3, #4
 8023e88:	1a9b      	subs	r3, r3, r2
 8023e8a:	005b      	lsls	r3, r3, #1
 8023e8c:	3350      	adds	r3, #80	; 0x50
 8023e8e:	4a9f      	ldr	r2, [pc, #636]	; (802410c <basic_init+0x608>)
 8023e90:	fb82 1203 	smull	r1, r2, r2, r3
 8023e94:	1192      	asrs	r2, r2, #6
 8023e96:	17db      	asrs	r3, r3, #31
 8023e98:	1ad3      	subs	r3, r2, r3
 8023e9a:	b29c      	uxth	r4, r3
 8023e9c:	e000      	b.n	8023ea0 <basic_init+0x39c>
 8023e9e:	2401      	movs	r4, #1
 8023ea0:	2000      	movs	r0, #0
 8023ea2:	f7fa fe37 	bl	801eb14 <lv_disp_get_dpi>
 8023ea6:	4603      	mov	r3, r0
 8023ea8:	2b77      	cmp	r3, #119	; 0x77
 8023eaa:	dd0c      	ble.n	8023ec6 <basic_init+0x3c2>
 8023eac:	2000      	movs	r0, #0
 8023eae:	f7fa fe31 	bl	801eb14 <lv_disp_get_dpi>
 8023eb2:	4603      	mov	r3, r0
 8023eb4:	3328      	adds	r3, #40	; 0x28
 8023eb6:	4a95      	ldr	r2, [pc, #596]	; (802410c <basic_init+0x608>)
 8023eb8:	fb82 1203 	smull	r1, r2, r2, r3
 8023ebc:	1152      	asrs	r2, r2, #5
 8023ebe:	17db      	asrs	r3, r3, #31
 8023ec0:	1ad3      	subs	r3, r2, r3
 8023ec2:	b29b      	uxth	r3, r3
 8023ec4:	e000      	b.n	8023ec8 <basic_init+0x3c4>
 8023ec6:	2301      	movs	r3, #1
 8023ec8:	4423      	add	r3, r4
 8023eca:	b29b      	uxth	r3, r3
 8023ecc:	b21b      	sxth	r3, r3
 8023ece:	461a      	mov	r2, r3
 8023ed0:	2100      	movs	r1, #0
 8023ed2:	4628      	mov	r0, r5
 8023ed4:	f7ff f9dd 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
 8023ed8:	4b8b      	ldr	r3, [pc, #556]	; (8024108 <basic_init+0x604>)
 8023eda:	681b      	ldr	r3, [r3, #0]
 8023edc:	1d1d      	adds	r5, r3, #4
 8023ede:	2000      	movs	r0, #0
 8023ee0:	f7fa fe31 	bl	801eb46 <lv_disp_get_size_category>
 8023ee4:	4603      	mov	r3, r0
 8023ee6:	2b01      	cmp	r3, #1
 8023ee8:	d81c      	bhi.n	8023f24 <basic_init+0x420>
 8023eea:	2000      	movs	r0, #0
 8023eec:	f7fa fe12 	bl	801eb14 <lv_disp_get_dpi>
 8023ef0:	4603      	mov	r3, r0
 8023ef2:	461a      	mov	r2, r3
 8023ef4:	4613      	mov	r3, r2
 8023ef6:	011b      	lsls	r3, r3, #4
 8023ef8:	1a9b      	subs	r3, r3, r2
 8023efa:	2bef      	cmp	r3, #239	; 0xef
 8023efc:	dd10      	ble.n	8023f20 <basic_init+0x41c>
 8023efe:	2000      	movs	r0, #0
 8023f00:	f7fa fe08 	bl	801eb14 <lv_disp_get_dpi>
 8023f04:	4603      	mov	r3, r0
 8023f06:	461a      	mov	r2, r3
 8023f08:	4613      	mov	r3, r2
 8023f0a:	011b      	lsls	r3, r3, #4
 8023f0c:	1a9b      	subs	r3, r3, r2
 8023f0e:	3350      	adds	r3, #80	; 0x50
 8023f10:	4a7e      	ldr	r2, [pc, #504]	; (802410c <basic_init+0x608>)
 8023f12:	fb82 1203 	smull	r1, r2, r2, r3
 8023f16:	1192      	asrs	r2, r2, #6
 8023f18:	17db      	asrs	r3, r3, #31
 8023f1a:	1ad3      	subs	r3, r2, r3
 8023f1c:	b29c      	uxth	r4, r3
 8023f1e:	e01f      	b.n	8023f60 <basic_init+0x45c>
 8023f20:	2401      	movs	r4, #1
 8023f22:	e01d      	b.n	8023f60 <basic_init+0x45c>
 8023f24:	2000      	movs	r0, #0
 8023f26:	f7fa fdf5 	bl	801eb14 <lv_disp_get_dpi>
 8023f2a:	4603      	mov	r3, r0
 8023f2c:	461a      	mov	r2, r3
 8023f2e:	4613      	mov	r3, r2
 8023f30:	011b      	lsls	r3, r3, #4
 8023f32:	1a9b      	subs	r3, r3, r2
 8023f34:	005b      	lsls	r3, r3, #1
 8023f36:	2bef      	cmp	r3, #239	; 0xef
 8023f38:	dd11      	ble.n	8023f5e <basic_init+0x45a>
 8023f3a:	2000      	movs	r0, #0
 8023f3c:	f7fa fdea 	bl	801eb14 <lv_disp_get_dpi>
 8023f40:	4603      	mov	r3, r0
 8023f42:	461a      	mov	r2, r3
 8023f44:	4613      	mov	r3, r2
 8023f46:	011b      	lsls	r3, r3, #4
 8023f48:	1a9b      	subs	r3, r3, r2
 8023f4a:	005b      	lsls	r3, r3, #1
 8023f4c:	3350      	adds	r3, #80	; 0x50
 8023f4e:	4a6f      	ldr	r2, [pc, #444]	; (802410c <basic_init+0x608>)
 8023f50:	fb82 1203 	smull	r1, r2, r2, r3
 8023f54:	1192      	asrs	r2, r2, #6
 8023f56:	17db      	asrs	r3, r3, #31
 8023f58:	1ad3      	subs	r3, r2, r3
 8023f5a:	b29c      	uxth	r4, r3
 8023f5c:	e000      	b.n	8023f60 <basic_init+0x45c>
 8023f5e:	2401      	movs	r4, #1
 8023f60:	2000      	movs	r0, #0
 8023f62:	f7fa fdd7 	bl	801eb14 <lv_disp_get_dpi>
 8023f66:	4603      	mov	r3, r0
 8023f68:	2b77      	cmp	r3, #119	; 0x77
 8023f6a:	dd0c      	ble.n	8023f86 <basic_init+0x482>
 8023f6c:	2000      	movs	r0, #0
 8023f6e:	f7fa fdd1 	bl	801eb14 <lv_disp_get_dpi>
 8023f72:	4603      	mov	r3, r0
 8023f74:	3328      	adds	r3, #40	; 0x28
 8023f76:	4a65      	ldr	r2, [pc, #404]	; (802410c <basic_init+0x608>)
 8023f78:	fb82 1203 	smull	r1, r2, r2, r3
 8023f7c:	1152      	asrs	r2, r2, #5
 8023f7e:	17db      	asrs	r3, r3, #31
 8023f80:	1ad3      	subs	r3, r2, r3
 8023f82:	b29b      	uxth	r3, r3
 8023f84:	e000      	b.n	8023f88 <basic_init+0x484>
 8023f86:	2301      	movs	r3, #1
 8023f88:	4423      	add	r3, r4
 8023f8a:	b29b      	uxth	r3, r3
 8023f8c:	b21b      	sxth	r3, r3
 8023f8e:	461a      	mov	r2, r3
 8023f90:	2100      	movs	r1, #0
 8023f92:	4628      	mov	r0, r5
 8023f94:	f7ff f995 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
 8023f98:	4b5b      	ldr	r3, [pc, #364]	; (8024108 <basic_init+0x604>)
 8023f9a:	681b      	ldr	r3, [r3, #0]
 8023f9c:	1d1d      	adds	r5, r3, #4
 8023f9e:	2000      	movs	r0, #0
 8023fa0:	f7fa fdd1 	bl	801eb46 <lv_disp_get_size_category>
 8023fa4:	4603      	mov	r3, r0
 8023fa6:	2b01      	cmp	r3, #1
 8023fa8:	d81c      	bhi.n	8023fe4 <basic_init+0x4e0>
 8023faa:	2000      	movs	r0, #0
 8023fac:	f7fa fdb2 	bl	801eb14 <lv_disp_get_dpi>
 8023fb0:	4603      	mov	r3, r0
 8023fb2:	461a      	mov	r2, r3
 8023fb4:	4613      	mov	r3, r2
 8023fb6:	011b      	lsls	r3, r3, #4
 8023fb8:	1a9b      	subs	r3, r3, r2
 8023fba:	2bef      	cmp	r3, #239	; 0xef
 8023fbc:	dd10      	ble.n	8023fe0 <basic_init+0x4dc>
 8023fbe:	2000      	movs	r0, #0
 8023fc0:	f7fa fda8 	bl	801eb14 <lv_disp_get_dpi>
 8023fc4:	4603      	mov	r3, r0
 8023fc6:	461a      	mov	r2, r3
 8023fc8:	4613      	mov	r3, r2
 8023fca:	011b      	lsls	r3, r3, #4
 8023fcc:	1a9b      	subs	r3, r3, r2
 8023fce:	3350      	adds	r3, #80	; 0x50
 8023fd0:	4a4e      	ldr	r2, [pc, #312]	; (802410c <basic_init+0x608>)
 8023fd2:	fb82 1203 	smull	r1, r2, r2, r3
 8023fd6:	1192      	asrs	r2, r2, #6
 8023fd8:	17db      	asrs	r3, r3, #31
 8023fda:	1ad3      	subs	r3, r2, r3
 8023fdc:	b29c      	uxth	r4, r3
 8023fde:	e01f      	b.n	8024020 <basic_init+0x51c>
 8023fe0:	2401      	movs	r4, #1
 8023fe2:	e01d      	b.n	8024020 <basic_init+0x51c>
 8023fe4:	2000      	movs	r0, #0
 8023fe6:	f7fa fd95 	bl	801eb14 <lv_disp_get_dpi>
 8023fea:	4603      	mov	r3, r0
 8023fec:	461a      	mov	r2, r3
 8023fee:	4613      	mov	r3, r2
 8023ff0:	011b      	lsls	r3, r3, #4
 8023ff2:	1a9b      	subs	r3, r3, r2
 8023ff4:	005b      	lsls	r3, r3, #1
 8023ff6:	2bef      	cmp	r3, #239	; 0xef
 8023ff8:	dd11      	ble.n	802401e <basic_init+0x51a>
 8023ffa:	2000      	movs	r0, #0
 8023ffc:	f7fa fd8a 	bl	801eb14 <lv_disp_get_dpi>
 8024000:	4603      	mov	r3, r0
 8024002:	461a      	mov	r2, r3
 8024004:	4613      	mov	r3, r2
 8024006:	011b      	lsls	r3, r3, #4
 8024008:	1a9b      	subs	r3, r3, r2
 802400a:	005b      	lsls	r3, r3, #1
 802400c:	3350      	adds	r3, #80	; 0x50
 802400e:	4a3f      	ldr	r2, [pc, #252]	; (802410c <basic_init+0x608>)
 8024010:	fb82 1203 	smull	r1, r2, r2, r3
 8024014:	1192      	asrs	r2, r2, #6
 8024016:	17db      	asrs	r3, r3, #31
 8024018:	1ad3      	subs	r3, r2, r3
 802401a:	b29c      	uxth	r4, r3
 802401c:	e000      	b.n	8024020 <basic_init+0x51c>
 802401e:	2401      	movs	r4, #1
 8024020:	2000      	movs	r0, #0
 8024022:	f7fa fd77 	bl	801eb14 <lv_disp_get_dpi>
 8024026:	4603      	mov	r3, r0
 8024028:	2b77      	cmp	r3, #119	; 0x77
 802402a:	dd0c      	ble.n	8024046 <basic_init+0x542>
 802402c:	2000      	movs	r0, #0
 802402e:	f7fa fd71 	bl	801eb14 <lv_disp_get_dpi>
 8024032:	4603      	mov	r3, r0
 8024034:	3328      	adds	r3, #40	; 0x28
 8024036:	4a35      	ldr	r2, [pc, #212]	; (802410c <basic_init+0x608>)
 8024038:	fb82 1203 	smull	r1, r2, r2, r3
 802403c:	1152      	asrs	r2, r2, #5
 802403e:	17db      	asrs	r3, r3, #31
 8024040:	1ad3      	subs	r3, r2, r3
 8024042:	b29b      	uxth	r3, r3
 8024044:	e000      	b.n	8024048 <basic_init+0x544>
 8024046:	2301      	movs	r3, #1
 8024048:	4423      	add	r3, r4
 802404a:	b29b      	uxth	r3, r3
 802404c:	b21b      	sxth	r3, r3
 802404e:	461a      	mov	r2, r3
 8024050:	2100      	movs	r1, #0
 8024052:	4628      	mov	r0, r5
 8024054:	f7ff f8ed 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->bg, LV_STATE_DEFAULT, PAD_DEF + BORDER_WIDTH);
 8024058:	4b2b      	ldr	r3, [pc, #172]	; (8024108 <basic_init+0x604>)
 802405a:	681b      	ldr	r3, [r3, #0]
 802405c:	1d1d      	adds	r5, r3, #4
 802405e:	2000      	movs	r0, #0
 8024060:	f7fa fd71 	bl	801eb46 <lv_disp_get_size_category>
 8024064:	4603      	mov	r3, r0
 8024066:	2b01      	cmp	r3, #1
 8024068:	d81c      	bhi.n	80240a4 <basic_init+0x5a0>
 802406a:	2000      	movs	r0, #0
 802406c:	f7fa fd52 	bl	801eb14 <lv_disp_get_dpi>
 8024070:	4603      	mov	r3, r0
 8024072:	461a      	mov	r2, r3
 8024074:	4613      	mov	r3, r2
 8024076:	011b      	lsls	r3, r3, #4
 8024078:	1a9b      	subs	r3, r3, r2
 802407a:	2bef      	cmp	r3, #239	; 0xef
 802407c:	dd10      	ble.n	80240a0 <basic_init+0x59c>
 802407e:	2000      	movs	r0, #0
 8024080:	f7fa fd48 	bl	801eb14 <lv_disp_get_dpi>
 8024084:	4603      	mov	r3, r0
 8024086:	461a      	mov	r2, r3
 8024088:	4613      	mov	r3, r2
 802408a:	011b      	lsls	r3, r3, #4
 802408c:	1a9b      	subs	r3, r3, r2
 802408e:	3350      	adds	r3, #80	; 0x50
 8024090:	4a1e      	ldr	r2, [pc, #120]	; (802410c <basic_init+0x608>)
 8024092:	fb82 1203 	smull	r1, r2, r2, r3
 8024096:	1192      	asrs	r2, r2, #6
 8024098:	17db      	asrs	r3, r3, #31
 802409a:	1ad3      	subs	r3, r2, r3
 802409c:	b29c      	uxth	r4, r3
 802409e:	e01f      	b.n	80240e0 <basic_init+0x5dc>
 80240a0:	2401      	movs	r4, #1
 80240a2:	e01d      	b.n	80240e0 <basic_init+0x5dc>
 80240a4:	2000      	movs	r0, #0
 80240a6:	f7fa fd35 	bl	801eb14 <lv_disp_get_dpi>
 80240aa:	4603      	mov	r3, r0
 80240ac:	461a      	mov	r2, r3
 80240ae:	4613      	mov	r3, r2
 80240b0:	011b      	lsls	r3, r3, #4
 80240b2:	1a9b      	subs	r3, r3, r2
 80240b4:	005b      	lsls	r3, r3, #1
 80240b6:	2bef      	cmp	r3, #239	; 0xef
 80240b8:	dd11      	ble.n	80240de <basic_init+0x5da>
 80240ba:	2000      	movs	r0, #0
 80240bc:	f7fa fd2a 	bl	801eb14 <lv_disp_get_dpi>
 80240c0:	4603      	mov	r3, r0
 80240c2:	461a      	mov	r2, r3
 80240c4:	4613      	mov	r3, r2
 80240c6:	011b      	lsls	r3, r3, #4
 80240c8:	1a9b      	subs	r3, r3, r2
 80240ca:	005b      	lsls	r3, r3, #1
 80240cc:	3350      	adds	r3, #80	; 0x50
 80240ce:	4a0f      	ldr	r2, [pc, #60]	; (802410c <basic_init+0x608>)
 80240d0:	fb82 1203 	smull	r1, r2, r2, r3
 80240d4:	1192      	asrs	r2, r2, #6
 80240d6:	17db      	asrs	r3, r3, #31
 80240d8:	1ad3      	subs	r3, r2, r3
 80240da:	b29c      	uxth	r4, r3
 80240dc:	e000      	b.n	80240e0 <basic_init+0x5dc>
 80240de:	2401      	movs	r4, #1
 80240e0:	2000      	movs	r0, #0
 80240e2:	f7fa fd17 	bl	801eb14 <lv_disp_get_dpi>
 80240e6:	4603      	mov	r3, r0
 80240e8:	2b77      	cmp	r3, #119	; 0x77
 80240ea:	dd11      	ble.n	8024110 <basic_init+0x60c>
 80240ec:	2000      	movs	r0, #0
 80240ee:	f7fa fd11 	bl	801eb14 <lv_disp_get_dpi>
 80240f2:	4603      	mov	r3, r0
 80240f4:	3328      	adds	r3, #40	; 0x28
 80240f6:	4a05      	ldr	r2, [pc, #20]	; (802410c <basic_init+0x608>)
 80240f8:	fb82 1203 	smull	r1, r2, r2, r3
 80240fc:	1152      	asrs	r2, r2, #5
 80240fe:	17db      	asrs	r3, r3, #31
 8024100:	1ad3      	subs	r3, r2, r3
 8024102:	b29b      	uxth	r3, r3
 8024104:	e005      	b.n	8024112 <basic_init+0x60e>
 8024106:	bf00      	nop
 8024108:	20012350 	.word	0x20012350
 802410c:	66666667 	.word	0x66666667
 8024110:	2301      	movs	r3, #1
 8024112:	4423      	add	r3, r4
 8024114:	b29b      	uxth	r3, r3
 8024116:	b21b      	sxth	r3, r3
 8024118:	461a      	mov	r2, r3
 802411a:	2100      	movs	r1, #0
 802411c:	4628      	mov	r0, r5
 802411e:	f7ff f8a0 	bl	8023262 <lv_style_set_pad_bottom>
    lv_style_set_pad_inner(&styles->bg, LV_STATE_DEFAULT, PAD_DEF);
 8024122:	4bbc      	ldr	r3, [pc, #752]	; (8024414 <basic_init+0x910>)
 8024124:	681b      	ldr	r3, [r3, #0]
 8024126:	1d1c      	adds	r4, r3, #4
 8024128:	2000      	movs	r0, #0
 802412a:	f7fa fd0c 	bl	801eb46 <lv_disp_get_size_category>
 802412e:	4603      	mov	r3, r0
 8024130:	2b01      	cmp	r3, #1
 8024132:	d81c      	bhi.n	802416e <basic_init+0x66a>
 8024134:	2000      	movs	r0, #0
 8024136:	f7fa fced 	bl	801eb14 <lv_disp_get_dpi>
 802413a:	4603      	mov	r3, r0
 802413c:	461a      	mov	r2, r3
 802413e:	4613      	mov	r3, r2
 8024140:	011b      	lsls	r3, r3, #4
 8024142:	1a9b      	subs	r3, r3, r2
 8024144:	2bef      	cmp	r3, #239	; 0xef
 8024146:	dd10      	ble.n	802416a <basic_init+0x666>
 8024148:	2000      	movs	r0, #0
 802414a:	f7fa fce3 	bl	801eb14 <lv_disp_get_dpi>
 802414e:	4603      	mov	r3, r0
 8024150:	461a      	mov	r2, r3
 8024152:	4613      	mov	r3, r2
 8024154:	011b      	lsls	r3, r3, #4
 8024156:	1a9b      	subs	r3, r3, r2
 8024158:	3350      	adds	r3, #80	; 0x50
 802415a:	4aaf      	ldr	r2, [pc, #700]	; (8024418 <basic_init+0x914>)
 802415c:	fb82 1203 	smull	r1, r2, r2, r3
 8024160:	1192      	asrs	r2, r2, #6
 8024162:	17db      	asrs	r3, r3, #31
 8024164:	1ad3      	subs	r3, r2, r3
 8024166:	b21b      	sxth	r3, r3
 8024168:	e01f      	b.n	80241aa <basic_init+0x6a6>
 802416a:	2301      	movs	r3, #1
 802416c:	e01d      	b.n	80241aa <basic_init+0x6a6>
 802416e:	2000      	movs	r0, #0
 8024170:	f7fa fcd0 	bl	801eb14 <lv_disp_get_dpi>
 8024174:	4603      	mov	r3, r0
 8024176:	461a      	mov	r2, r3
 8024178:	4613      	mov	r3, r2
 802417a:	011b      	lsls	r3, r3, #4
 802417c:	1a9b      	subs	r3, r3, r2
 802417e:	005b      	lsls	r3, r3, #1
 8024180:	2bef      	cmp	r3, #239	; 0xef
 8024182:	dd11      	ble.n	80241a8 <basic_init+0x6a4>
 8024184:	2000      	movs	r0, #0
 8024186:	f7fa fcc5 	bl	801eb14 <lv_disp_get_dpi>
 802418a:	4603      	mov	r3, r0
 802418c:	461a      	mov	r2, r3
 802418e:	4613      	mov	r3, r2
 8024190:	011b      	lsls	r3, r3, #4
 8024192:	1a9b      	subs	r3, r3, r2
 8024194:	005b      	lsls	r3, r3, #1
 8024196:	3350      	adds	r3, #80	; 0x50
 8024198:	4a9f      	ldr	r2, [pc, #636]	; (8024418 <basic_init+0x914>)
 802419a:	fb82 1203 	smull	r1, r2, r2, r3
 802419e:	1192      	asrs	r2, r2, #6
 80241a0:	17db      	asrs	r3, r3, #31
 80241a2:	1ad3      	subs	r3, r2, r3
 80241a4:	b21b      	sxth	r3, r3
 80241a6:	e000      	b.n	80241aa <basic_init+0x6a6>
 80241a8:	2301      	movs	r3, #1
 80241aa:	461a      	mov	r2, r3
 80241ac:	2100      	movs	r1, #0
 80241ae:	4620      	mov	r0, r4
 80241b0:	f7ff f89f 	bl	80232f2 <lv_style_set_pad_inner>
    lv_style_set_transition_time(&styles->bg, LV_STATE_DEFAULT, TRANSITION_TIME);
 80241b4:	4b97      	ldr	r3, [pc, #604]	; (8024414 <basic_init+0x910>)
 80241b6:	681b      	ldr	r3, [r3, #0]
 80241b8:	1d18      	adds	r0, r3, #4
 80241ba:	4b98      	ldr	r3, [pc, #608]	; (802441c <basic_init+0x918>)
 80241bc:	6a1b      	ldr	r3, [r3, #32]
 80241be:	f003 0310 	and.w	r3, r3, #16
 80241c2:	2b00      	cmp	r3, #0
 80241c4:	d001      	beq.n	80241ca <basic_init+0x6c6>
 80241c6:	2300      	movs	r3, #0
 80241c8:	e000      	b.n	80241cc <basic_init+0x6c8>
 80241ca:	2396      	movs	r3, #150	; 0x96
 80241cc:	461a      	mov	r2, r3
 80241ce:	2100      	movs	r1, #0
 80241d0:	f7ff fb94 	bl	80238fc <lv_style_set_transition_time>
    lv_style_set_transition_prop_6(&styles->bg, LV_STATE_DEFAULT, LV_STYLE_BORDER_COLOR);
 80241d4:	4b8f      	ldr	r3, [pc, #572]	; (8024414 <basic_init+0x910>)
 80241d6:	681b      	ldr	r3, [r3, #0]
 80241d8:	3304      	adds	r3, #4
 80241da:	2239      	movs	r2, #57	; 0x39
 80241dc:	2100      	movs	r1, #0
 80241de:	4618      	mov	r0, r3
 80241e0:	f7ff fc04 	bl	80239ec <lv_style_set_transition_prop_6>

    style_init_reset(&styles->bg_sec);
 80241e4:	4b8b      	ldr	r3, [pc, #556]	; (8024414 <basic_init+0x910>)
 80241e6:	681b      	ldr	r3, [r3, #0]
 80241e8:	330c      	adds	r3, #12
 80241ea:	4618      	mov	r0, r3
 80241ec:	f005 fb0e 	bl	802980c <style_init_reset>
    lv_style_copy(&styles->bg_sec, &styles->bg);
 80241f0:	4b88      	ldr	r3, [pc, #544]	; (8024414 <basic_init+0x910>)
 80241f2:	681b      	ldr	r3, [r3, #0]
 80241f4:	f103 020c 	add.w	r2, r3, #12
 80241f8:	4b86      	ldr	r3, [pc, #536]	; (8024414 <basic_init+0x910>)
 80241fa:	681b      	ldr	r3, [r3, #0]
 80241fc:	3304      	adds	r3, #4
 80241fe:	4619      	mov	r1, r3
 8024200:	4610      	mov	r0, r2
 8024202:	f7ea ffb2 	bl	800f16a <lv_style_copy>
    lv_style_set_bg_color(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC);
 8024206:	4b83      	ldr	r3, [pc, #524]	; (8024414 <basic_init+0x910>)
 8024208:	681b      	ldr	r3, [r3, #0]
 802420a:	f103 040c 	add.w	r4, r3, #12
 802420e:	4b83      	ldr	r3, [pc, #524]	; (802441c <basic_init+0x918>)
 8024210:	6a1b      	ldr	r3, [r3, #32]
 8024212:	f003 0302 	and.w	r3, r3, #2
 8024216:	2b00      	cmp	r3, #0
 8024218:	d004      	beq.n	8024224 <basic_init+0x720>
 802421a:	4881      	ldr	r0, [pc, #516]	; (8024420 <basic_init+0x91c>)
 802421c:	f7fe ff63 	bl	80230e6 <lv_color_hex>
 8024220:	4603      	mov	r3, r0
 8024222:	e003      	b.n	802422c <basic_init+0x728>
 8024224:	487f      	ldr	r0, [pc, #508]	; (8024424 <basic_init+0x920>)
 8024226:	f7fe ff5e 	bl	80230e6 <lv_color_hex>
 802422a:	4603      	mov	r3, r0
 802422c:	461a      	mov	r2, r3
 802422e:	2100      	movs	r1, #0
 8024230:	4620      	mov	r0, r4
 8024232:	f7ff f8d6 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_border_color(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC_BORDER);
 8024236:	4b77      	ldr	r3, [pc, #476]	; (8024414 <basic_init+0x910>)
 8024238:	681b      	ldr	r3, [r3, #0]
 802423a:	f103 040c 	add.w	r4, r3, #12
 802423e:	4b77      	ldr	r3, [pc, #476]	; (802441c <basic_init+0x918>)
 8024240:	6a1b      	ldr	r3, [r3, #32]
 8024242:	f003 0302 	and.w	r3, r3, #2
 8024246:	2b00      	cmp	r3, #0
 8024248:	d004      	beq.n	8024254 <basic_init+0x750>
 802424a:	4877      	ldr	r0, [pc, #476]	; (8024428 <basic_init+0x924>)
 802424c:	f7fe ff4b 	bl	80230e6 <lv_color_hex>
 8024250:	4603      	mov	r3, r0
 8024252:	e003      	b.n	802425c <basic_init+0x758>
 8024254:	4875      	ldr	r0, [pc, #468]	; (802442c <basic_init+0x928>)
 8024256:	f7fe ff46 	bl	80230e6 <lv_color_hex>
 802425a:	4603      	mov	r3, r0
 802425c:	461a      	mov	r2, r3
 802425e:	2100      	movs	r1, #0
 8024260:	4620      	mov	r0, r4
 8024262:	f7ff f933 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_text_color(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC_TEXT);
 8024266:	4b6b      	ldr	r3, [pc, #428]	; (8024414 <basic_init+0x910>)
 8024268:	681b      	ldr	r3, [r3, #0]
 802426a:	f103 040c 	add.w	r4, r3, #12
 802426e:	4b6b      	ldr	r3, [pc, #428]	; (802441c <basic_init+0x918>)
 8024270:	6a1b      	ldr	r3, [r3, #32]
 8024272:	f003 0302 	and.w	r3, r3, #2
 8024276:	2b00      	cmp	r3, #0
 8024278:	d004      	beq.n	8024284 <basic_init+0x780>
 802427a:	486d      	ldr	r0, [pc, #436]	; (8024430 <basic_init+0x92c>)
 802427c:	f7fe ff33 	bl	80230e6 <lv_color_hex>
 8024280:	4603      	mov	r3, r0
 8024282:	e003      	b.n	802428c <basic_init+0x788>
 8024284:	486b      	ldr	r0, [pc, #428]	; (8024434 <basic_init+0x930>)
 8024286:	f7fe ff2e 	bl	80230e6 <lv_color_hex>
 802428a:	4603      	mov	r3, r0
 802428c:	461a      	mov	r2, r3
 802428e:	2100      	movs	r1, #0
 8024290:	4620      	mov	r0, r4
 8024292:	f7ff fa75 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_value_color(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC_TEXT);
 8024296:	4b5f      	ldr	r3, [pc, #380]	; (8024414 <basic_init+0x910>)
 8024298:	681b      	ldr	r3, [r3, #0]
 802429a:	f103 040c 	add.w	r4, r3, #12
 802429e:	4b5f      	ldr	r3, [pc, #380]	; (802441c <basic_init+0x918>)
 80242a0:	6a1b      	ldr	r3, [r3, #32]
 80242a2:	f003 0302 	and.w	r3, r3, #2
 80242a6:	2b00      	cmp	r3, #0
 80242a8:	d004      	beq.n	80242b4 <basic_init+0x7b0>
 80242aa:	4861      	ldr	r0, [pc, #388]	; (8024430 <basic_init+0x92c>)
 80242ac:	f7fe ff1b 	bl	80230e6 <lv_color_hex>
 80242b0:	4603      	mov	r3, r0
 80242b2:	e003      	b.n	80242bc <basic_init+0x7b8>
 80242b4:	485f      	ldr	r0, [pc, #380]	; (8024434 <basic_init+0x930>)
 80242b6:	f7fe ff16 	bl	80230e6 <lv_color_hex>
 80242ba:	4603      	mov	r3, r0
 80242bc:	461a      	mov	r2, r3
 80242be:	2100      	movs	r1, #0
 80242c0:	4620      	mov	r0, r4
 80242c2:	f7ff fa16 	bl	80236f2 <lv_style_set_value_color>
    lv_style_set_image_recolor(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC_TEXT);
 80242c6:	4b53      	ldr	r3, [pc, #332]	; (8024414 <basic_init+0x910>)
 80242c8:	681b      	ldr	r3, [r3, #0]
 80242ca:	f103 040c 	add.w	r4, r3, #12
 80242ce:	4b53      	ldr	r3, [pc, #332]	; (802441c <basic_init+0x918>)
 80242d0:	6a1b      	ldr	r3, [r3, #32]
 80242d2:	f003 0302 	and.w	r3, r3, #2
 80242d6:	2b00      	cmp	r3, #0
 80242d8:	d004      	beq.n	80242e4 <basic_init+0x7e0>
 80242da:	4855      	ldr	r0, [pc, #340]	; (8024430 <basic_init+0x92c>)
 80242dc:	f7fe ff03 	bl	80230e6 <lv_color_hex>
 80242e0:	4603      	mov	r3, r0
 80242e2:	e003      	b.n	80242ec <basic_init+0x7e8>
 80242e4:	4853      	ldr	r0, [pc, #332]	; (8024434 <basic_init+0x930>)
 80242e6:	f7fe fefe 	bl	80230e6 <lv_color_hex>
 80242ea:	4603      	mov	r3, r0
 80242ec:	461a      	mov	r2, r3
 80242ee:	2100      	movs	r1, #0
 80242f0:	4620      	mov	r0, r4
 80242f2:	f7ff faeb 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_line_color(&styles->bg_sec, LV_STATE_DEFAULT, COLOR_BG_SEC_TEXT);
 80242f6:	4b47      	ldr	r3, [pc, #284]	; (8024414 <basic_init+0x910>)
 80242f8:	681b      	ldr	r3, [r3, #0]
 80242fa:	f103 040c 	add.w	r4, r3, #12
 80242fe:	4b47      	ldr	r3, [pc, #284]	; (802441c <basic_init+0x918>)
 8024300:	6a1b      	ldr	r3, [r3, #32]
 8024302:	f003 0302 	and.w	r3, r3, #2
 8024306:	2b00      	cmp	r3, #0
 8024308:	d004      	beq.n	8024314 <basic_init+0x810>
 802430a:	4849      	ldr	r0, [pc, #292]	; (8024430 <basic_init+0x92c>)
 802430c:	f7fe feeb 	bl	80230e6 <lv_color_hex>
 8024310:	4603      	mov	r3, r0
 8024312:	e003      	b.n	802431c <basic_init+0x818>
 8024314:	4847      	ldr	r0, [pc, #284]	; (8024434 <basic_init+0x930>)
 8024316:	f7fe fee6 	bl	80230e6 <lv_color_hex>
 802431a:	4603      	mov	r3, r0
 802431c:	461a      	mov	r2, r3
 802431e:	2100      	movs	r1, #0
 8024320:	4620      	mov	r0, r4
 8024322:	f7ff fabd 	bl	80238a0 <lv_style_set_line_color>

    style_init_reset(&styles->bg_click);
 8024326:	4b3b      	ldr	r3, [pc, #236]	; (8024414 <basic_init+0x910>)
 8024328:	681b      	ldr	r3, [r3, #0]
 802432a:	3308      	adds	r3, #8
 802432c:	4618      	mov	r0, r3
 802432e:	f005 fa6d 	bl	802980c <style_init_reset>
    lv_style_set_bg_color(&styles->bg_click, LV_STATE_PRESSED, COLOR_BG_PR);
 8024332:	4b38      	ldr	r3, [pc, #224]	; (8024414 <basic_init+0x910>)
 8024334:	681b      	ldr	r3, [r3, #0]
 8024336:	f103 0408 	add.w	r4, r3, #8
 802433a:	4b38      	ldr	r3, [pc, #224]	; (802441c <basic_init+0x918>)
 802433c:	6a1b      	ldr	r3, [r3, #32]
 802433e:	f003 0302 	and.w	r3, r3, #2
 8024342:	2b00      	cmp	r3, #0
 8024344:	d004      	beq.n	8024350 <basic_init+0x84c>
 8024346:	483c      	ldr	r0, [pc, #240]	; (8024438 <basic_init+0x934>)
 8024348:	f7fe fecd 	bl	80230e6 <lv_color_hex>
 802434c:	4603      	mov	r3, r0
 802434e:	e003      	b.n	8024358 <basic_init+0x854>
 8024350:	483a      	ldr	r0, [pc, #232]	; (802443c <basic_init+0x938>)
 8024352:	f7fe fec8 	bl	80230e6 <lv_color_hex>
 8024356:	4603      	mov	r3, r0
 8024358:	461a      	mov	r2, r3
 802435a:	2110      	movs	r1, #16
 802435c:	4620      	mov	r0, r4
 802435e:	f7ff f840 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->bg_click, LV_STATE_CHECKED, COLOR_BG_CHK);
 8024362:	4b2c      	ldr	r3, [pc, #176]	; (8024414 <basic_init+0x910>)
 8024364:	681b      	ldr	r3, [r3, #0]
 8024366:	3308      	adds	r3, #8
 8024368:	4a2c      	ldr	r2, [pc, #176]	; (802441c <basic_init+0x918>)
 802436a:	8992      	ldrh	r2, [r2, #12]
 802436c:	2101      	movs	r1, #1
 802436e:	4618      	mov	r0, r3
 8024370:	f7ff f837 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->bg_click, LV_STATE_PRESSED | LV_STATE_CHECKED, COLOR_BG_PR_CHK);
 8024374:	4b27      	ldr	r3, [pc, #156]	; (8024414 <basic_init+0x910>)
 8024376:	681b      	ldr	r3, [r3, #0]
 8024378:	f103 0408 	add.w	r4, r3, #8
 802437c:	4b27      	ldr	r3, [pc, #156]	; (802441c <basic_init+0x918>)
 802437e:	2133      	movs	r1, #51	; 0x33
 8024380:	8998      	ldrh	r0, [r3, #12]
 8024382:	f7fb fe9f 	bl	80200c4 <lv_color_darken>
 8024386:	4603      	mov	r3, r0
 8024388:	461a      	mov	r2, r3
 802438a:	2111      	movs	r1, #17
 802438c:	4620      	mov	r0, r4
 802438e:	f7ff f828 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->bg_click, LV_STATE_DISABLED, COLOR_BG_DIS);
 8024392:	4b20      	ldr	r3, [pc, #128]	; (8024414 <basic_init+0x910>)
 8024394:	681b      	ldr	r3, [r3, #0]
 8024396:	f103 0408 	add.w	r4, r3, #8
 802439a:	4b20      	ldr	r3, [pc, #128]	; (802441c <basic_init+0x918>)
 802439c:	6a1b      	ldr	r3, [r3, #32]
 802439e:	f003 0302 	and.w	r3, r3, #2
 80243a2:	2b00      	cmp	r3, #0
 80243a4:	d005      	beq.n	80243b2 <basic_init+0x8ae>
 80243a6:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80243aa:	f7fe fe9c 	bl	80230e6 <lv_color_hex>
 80243ae:	4603      	mov	r3, r0
 80243b0:	e003      	b.n	80243ba <basic_init+0x8b6>
 80243b2:	4823      	ldr	r0, [pc, #140]	; (8024440 <basic_init+0x93c>)
 80243b4:	f7fe fe97 	bl	80230e6 <lv_color_hex>
 80243b8:	4603      	mov	r3, r0
 80243ba:	461a      	mov	r2, r3
 80243bc:	2120      	movs	r1, #32
 80243be:	4620      	mov	r0, r4
 80243c0:	f7ff f80f 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_border_width(&styles->bg_click, LV_STATE_CHECKED, 0);
 80243c4:	4b13      	ldr	r3, [pc, #76]	; (8024414 <basic_init+0x910>)
 80243c6:	681b      	ldr	r3, [r3, #0]
 80243c8:	3308      	adds	r3, #8
 80243ca:	2200      	movs	r2, #0
 80243cc:	2101      	movs	r1, #1
 80243ce:	4618      	mov	r0, r3
 80243d0:	f7ff f834 	bl	802343c <lv_style_set_border_width>
    lv_style_set_border_color(&styles->bg_click, LV_STATE_FOCUSED | LV_STATE_PRESSED, lv_color_darken(theme.color_primary,
 80243d4:	4b0f      	ldr	r3, [pc, #60]	; (8024414 <basic_init+0x910>)
 80243d6:	681b      	ldr	r3, [r3, #0]
 80243d8:	f103 0408 	add.w	r4, r3, #8
 80243dc:	4b0f      	ldr	r3, [pc, #60]	; (802441c <basic_init+0x918>)
 80243de:	2133      	movs	r1, #51	; 0x33
 80243e0:	8998      	ldrh	r0, [r3, #12]
 80243e2:	f7fb fe6f 	bl	80200c4 <lv_color_darken>
 80243e6:	4603      	mov	r3, r0
 80243e8:	461a      	mov	r2, r3
 80243ea:	2112      	movs	r1, #18
 80243ec:	4620      	mov	r0, r4
 80243ee:	f7ff f86d 	bl	80234cc <lv_style_set_border_color>
                                                                                                      LV_OPA_20));
    lv_style_set_border_color(&styles->bg_click, LV_STATE_PRESSED, COLOR_BG_BORDER_PR);
 80243f2:	4b08      	ldr	r3, [pc, #32]	; (8024414 <basic_init+0x910>)
 80243f4:	681b      	ldr	r3, [r3, #0]
 80243f6:	f103 0408 	add.w	r4, r3, #8
 80243fa:	4b08      	ldr	r3, [pc, #32]	; (802441c <basic_init+0x918>)
 80243fc:	6a1b      	ldr	r3, [r3, #32]
 80243fe:	f003 0302 	and.w	r3, r3, #2
 8024402:	2b00      	cmp	r3, #0
 8024404:	d01e      	beq.n	8024444 <basic_init+0x940>
 8024406:	f640 40cc 	movw	r0, #3276	; 0xccc
 802440a:	f7fe fe80 	bl	802310e <lv_color_hex3>
 802440e:	4603      	mov	r3, r0
 8024410:	e01c      	b.n	802444c <basic_init+0x948>
 8024412:	bf00      	nop
 8024414:	20012350 	.word	0x20012350
 8024418:	66666667 	.word	0x66666667
 802441c:	20012328 	.word	0x20012328
 8024420:	00d4d7d9 	.word	0x00d4d7d9
 8024424:	0045494d 	.word	0x0045494d
 8024428:	00dfe7ed 	.word	0x00dfe7ed
 802442c:	00404040 	.word	0x00404040
 8024430:	0031404f 	.word	0x0031404f
 8024434:	00a5a8ad 	.word	0x00a5a8ad
 8024438:	00eeeeee 	.word	0x00eeeeee
 802443c:	00494f57 	.word	0x00494f57
 8024440:	00586273 	.word	0x00586273
 8024444:	48bc      	ldr	r0, [pc, #752]	; (8024738 <basic_init+0xc34>)
 8024446:	f7fe fe4e 	bl	80230e6 <lv_color_hex>
 802444a:	4603      	mov	r3, r0
 802444c:	461a      	mov	r2, r3
 802444e:	2110      	movs	r1, #16
 8024450:	4620      	mov	r0, r4
 8024452:	f7ff f83b 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_color(&styles->bg_click, LV_STATE_CHECKED, COLOR_BG_BORDER_CHK);
 8024456:	4bb9      	ldr	r3, [pc, #740]	; (802473c <basic_init+0xc38>)
 8024458:	681b      	ldr	r3, [r3, #0]
 802445a:	f103 0408 	add.w	r4, r3, #8
 802445e:	4bb8      	ldr	r3, [pc, #736]	; (8024740 <basic_init+0xc3c>)
 8024460:	6a1b      	ldr	r3, [r3, #32]
 8024462:	f003 0302 	and.w	r3, r3, #2
 8024466:	2b00      	cmp	r3, #0
 8024468:	d004      	beq.n	8024474 <basic_init+0x970>
 802446a:	48b6      	ldr	r0, [pc, #728]	; (8024744 <basic_init+0xc40>)
 802446c:	f7fe fe3b 	bl	80230e6 <lv_color_hex>
 8024470:	4603      	mov	r3, r0
 8024472:	e003      	b.n	802447c <basic_init+0x978>
 8024474:	48b0      	ldr	r0, [pc, #704]	; (8024738 <basic_init+0xc34>)
 8024476:	f7fe fe36 	bl	80230e6 <lv_color_hex>
 802447a:	4603      	mov	r3, r0
 802447c:	461a      	mov	r2, r3
 802447e:	2101      	movs	r1, #1
 8024480:	4620      	mov	r0, r4
 8024482:	f7ff f823 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_color(&styles->bg_click, LV_STATE_PRESSED | LV_STATE_CHECKED, COLOR_BG_BORDER_CHK_PR);
 8024486:	4bad      	ldr	r3, [pc, #692]	; (802473c <basic_init+0xc38>)
 8024488:	681b      	ldr	r3, [r3, #0]
 802448a:	f103 0408 	add.w	r4, r3, #8
 802448e:	4bac      	ldr	r3, [pc, #688]	; (8024740 <basic_init+0xc3c>)
 8024490:	6a1b      	ldr	r3, [r3, #32]
 8024492:	f003 0302 	and.w	r3, r3, #2
 8024496:	2b00      	cmp	r3, #0
 8024498:	d004      	beq.n	80244a4 <basic_init+0x9a0>
 802449a:	48aa      	ldr	r0, [pc, #680]	; (8024744 <basic_init+0xc40>)
 802449c:	f7fe fe23 	bl	80230e6 <lv_color_hex>
 80244a0:	4603      	mov	r3, r0
 80244a2:	e003      	b.n	80244ac <basic_init+0x9a8>
 80244a4:	48a4      	ldr	r0, [pc, #656]	; (8024738 <basic_init+0xc34>)
 80244a6:	f7fe fe1e 	bl	80230e6 <lv_color_hex>
 80244aa:	4603      	mov	r3, r0
 80244ac:	461a      	mov	r2, r3
 80244ae:	2111      	movs	r1, #17
 80244b0:	4620      	mov	r0, r4
 80244b2:	f7ff f80b 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_color(&styles->bg_click, LV_STATE_DISABLED, COLOR_BG_BORDER_DIS);
 80244b6:	4ba1      	ldr	r3, [pc, #644]	; (802473c <basic_init+0xc38>)
 80244b8:	681b      	ldr	r3, [r3, #0]
 80244ba:	f103 0408 	add.w	r4, r3, #8
 80244be:	4ba0      	ldr	r3, [pc, #640]	; (8024740 <basic_init+0xc3c>)
 80244c0:	6a1b      	ldr	r3, [r3, #32]
 80244c2:	f003 0302 	and.w	r3, r3, #2
 80244c6:	2b00      	cmp	r3, #0
 80244c8:	d004      	beq.n	80244d4 <basic_init+0x9d0>
 80244ca:	489f      	ldr	r0, [pc, #636]	; (8024748 <basic_init+0xc44>)
 80244cc:	f7fe fe0b 	bl	80230e6 <lv_color_hex>
 80244d0:	4603      	mov	r3, r0
 80244d2:	e003      	b.n	80244dc <basic_init+0x9d8>
 80244d4:	4898      	ldr	r0, [pc, #608]	; (8024738 <basic_init+0xc34>)
 80244d6:	f7fe fe06 	bl	80230e6 <lv_color_hex>
 80244da:	4603      	mov	r3, r0
 80244dc:	461a      	mov	r2, r3
 80244de:	2120      	movs	r1, #32
 80244e0:	4620      	mov	r0, r4
 80244e2:	f7fe fff3 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_text_color(&styles->bg_click, LV_STATE_PRESSED, COLOR_BG_TEXT_PR);
 80244e6:	4b95      	ldr	r3, [pc, #596]	; (802473c <basic_init+0xc38>)
 80244e8:	681b      	ldr	r3, [r3, #0]
 80244ea:	f103 0408 	add.w	r4, r3, #8
 80244ee:	4b94      	ldr	r3, [pc, #592]	; (8024740 <basic_init+0xc3c>)
 80244f0:	6a1b      	ldr	r3, [r3, #32]
 80244f2:	f003 0302 	and.w	r3, r3, #2
 80244f6:	2b00      	cmp	r3, #0
 80244f8:	d004      	beq.n	8024504 <basic_init+0xa00>
 80244fa:	4892      	ldr	r0, [pc, #584]	; (8024744 <basic_init+0xc40>)
 80244fc:	f7fe fdf3 	bl	80230e6 <lv_color_hex>
 8024500:	4603      	mov	r3, r0
 8024502:	e004      	b.n	802450e <basic_init+0xa0a>
 8024504:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024508:	f7fe fded 	bl	80230e6 <lv_color_hex>
 802450c:	4603      	mov	r3, r0
 802450e:	461a      	mov	r2, r3
 8024510:	2110      	movs	r1, #16
 8024512:	4620      	mov	r0, r4
 8024514:	f7ff f934 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_color(&styles->bg_click, LV_STATE_CHECKED, COLOR_BG_TEXT_CHK);
 8024518:	4b88      	ldr	r3, [pc, #544]	; (802473c <basic_init+0xc38>)
 802451a:	681b      	ldr	r3, [r3, #0]
 802451c:	f103 0408 	add.w	r4, r3, #8
 8024520:	4b87      	ldr	r3, [pc, #540]	; (8024740 <basic_init+0xc3c>)
 8024522:	6a1b      	ldr	r3, [r3, #32]
 8024524:	f003 0302 	and.w	r3, r3, #2
 8024528:	2b00      	cmp	r3, #0
 802452a:	d005      	beq.n	8024538 <basic_init+0xa34>
 802452c:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024530:	f7fe fdd9 	bl	80230e6 <lv_color_hex>
 8024534:	4603      	mov	r3, r0
 8024536:	e004      	b.n	8024542 <basic_init+0xa3e>
 8024538:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 802453c:	f7fe fdd3 	bl	80230e6 <lv_color_hex>
 8024540:	4603      	mov	r3, r0
 8024542:	461a      	mov	r2, r3
 8024544:	2101      	movs	r1, #1
 8024546:	4620      	mov	r0, r4
 8024548:	f7ff f91a 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_color(&styles->bg_click, LV_STATE_PRESSED | LV_STATE_CHECKED, COLOR_BG_TEXT_CHK_PR);
 802454c:	4b7b      	ldr	r3, [pc, #492]	; (802473c <basic_init+0xc38>)
 802454e:	681b      	ldr	r3, [r3, #0]
 8024550:	f103 0408 	add.w	r4, r3, #8
 8024554:	4b7a      	ldr	r3, [pc, #488]	; (8024740 <basic_init+0xc3c>)
 8024556:	6a1b      	ldr	r3, [r3, #32]
 8024558:	f003 0302 	and.w	r3, r3, #2
 802455c:	2b00      	cmp	r3, #0
 802455e:	d005      	beq.n	802456c <basic_init+0xa68>
 8024560:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024564:	f7fe fdbf 	bl	80230e6 <lv_color_hex>
 8024568:	4603      	mov	r3, r0
 802456a:	e004      	b.n	8024576 <basic_init+0xa72>
 802456c:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024570:	f7fe fdb9 	bl	80230e6 <lv_color_hex>
 8024574:	4603      	mov	r3, r0
 8024576:	461a      	mov	r2, r3
 8024578:	2111      	movs	r1, #17
 802457a:	4620      	mov	r0, r4
 802457c:	f7ff f900 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_color(&styles->bg_click, LV_STATE_DISABLED, COLOR_BG_TEXT_DIS);
 8024580:	4b6e      	ldr	r3, [pc, #440]	; (802473c <basic_init+0xc38>)
 8024582:	681b      	ldr	r3, [r3, #0]
 8024584:	f103 0408 	add.w	r4, r3, #8
 8024588:	4b6d      	ldr	r3, [pc, #436]	; (8024740 <basic_init+0xc3c>)
 802458a:	6a1b      	ldr	r3, [r3, #32]
 802458c:	f003 0302 	and.w	r3, r3, #2
 8024590:	2b00      	cmp	r3, #0
 8024592:	d005      	beq.n	80245a0 <basic_init+0xa9c>
 8024594:	f640 20aa 	movw	r0, #2730	; 0xaaa
 8024598:	f7fe fdb9 	bl	802310e <lv_color_hex3>
 802459c:	4603      	mov	r3, r0
 802459e:	e004      	b.n	80245aa <basic_init+0xaa6>
 80245a0:	f640 1099 	movw	r0, #2457	; 0x999
 80245a4:	f7fe fdb3 	bl	802310e <lv_color_hex3>
 80245a8:	4603      	mov	r3, r0
 80245aa:	461a      	mov	r2, r3
 80245ac:	2120      	movs	r1, #32
 80245ae:	4620      	mov	r0, r4
 80245b0:	f7ff f8e6 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_image_recolor(&styles->bg_click, LV_STATE_PRESSED, COLOR_BG_TEXT_PR);
 80245b4:	4b61      	ldr	r3, [pc, #388]	; (802473c <basic_init+0xc38>)
 80245b6:	681b      	ldr	r3, [r3, #0]
 80245b8:	f103 0408 	add.w	r4, r3, #8
 80245bc:	4b60      	ldr	r3, [pc, #384]	; (8024740 <basic_init+0xc3c>)
 80245be:	6a1b      	ldr	r3, [r3, #32]
 80245c0:	f003 0302 	and.w	r3, r3, #2
 80245c4:	2b00      	cmp	r3, #0
 80245c6:	d004      	beq.n	80245d2 <basic_init+0xace>
 80245c8:	485e      	ldr	r0, [pc, #376]	; (8024744 <basic_init+0xc40>)
 80245ca:	f7fe fd8c 	bl	80230e6 <lv_color_hex>
 80245ce:	4603      	mov	r3, r0
 80245d0:	e004      	b.n	80245dc <basic_init+0xad8>
 80245d2:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80245d6:	f7fe fd86 	bl	80230e6 <lv_color_hex>
 80245da:	4603      	mov	r3, r0
 80245dc:	461a      	mov	r2, r3
 80245de:	2110      	movs	r1, #16
 80245e0:	4620      	mov	r0, r4
 80245e2:	f7ff f973 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_image_recolor(&styles->bg_click, LV_STATE_CHECKED, COLOR_BG_TEXT_CHK);
 80245e6:	4b55      	ldr	r3, [pc, #340]	; (802473c <basic_init+0xc38>)
 80245e8:	681b      	ldr	r3, [r3, #0]
 80245ea:	f103 0408 	add.w	r4, r3, #8
 80245ee:	4b54      	ldr	r3, [pc, #336]	; (8024740 <basic_init+0xc3c>)
 80245f0:	6a1b      	ldr	r3, [r3, #32]
 80245f2:	f003 0302 	and.w	r3, r3, #2
 80245f6:	2b00      	cmp	r3, #0
 80245f8:	d005      	beq.n	8024606 <basic_init+0xb02>
 80245fa:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80245fe:	f7fe fd72 	bl	80230e6 <lv_color_hex>
 8024602:	4603      	mov	r3, r0
 8024604:	e004      	b.n	8024610 <basic_init+0xb0c>
 8024606:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 802460a:	f7fe fd6c 	bl	80230e6 <lv_color_hex>
 802460e:	4603      	mov	r3, r0
 8024610:	461a      	mov	r2, r3
 8024612:	2101      	movs	r1, #1
 8024614:	4620      	mov	r0, r4
 8024616:	f7ff f959 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_image_recolor(&styles->bg_click, LV_STATE_PRESSED | LV_STATE_CHECKED, COLOR_BG_TEXT_CHK_PR);
 802461a:	4b48      	ldr	r3, [pc, #288]	; (802473c <basic_init+0xc38>)
 802461c:	681b      	ldr	r3, [r3, #0]
 802461e:	f103 0408 	add.w	r4, r3, #8
 8024622:	4b47      	ldr	r3, [pc, #284]	; (8024740 <basic_init+0xc3c>)
 8024624:	6a1b      	ldr	r3, [r3, #32]
 8024626:	f003 0302 	and.w	r3, r3, #2
 802462a:	2b00      	cmp	r3, #0
 802462c:	d005      	beq.n	802463a <basic_init+0xb36>
 802462e:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024632:	f7fe fd58 	bl	80230e6 <lv_color_hex>
 8024636:	4603      	mov	r3, r0
 8024638:	e004      	b.n	8024644 <basic_init+0xb40>
 802463a:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 802463e:	f7fe fd52 	bl	80230e6 <lv_color_hex>
 8024642:	4603      	mov	r3, r0
 8024644:	461a      	mov	r2, r3
 8024646:	2111      	movs	r1, #17
 8024648:	4620      	mov	r0, r4
 802464a:	f7ff f93f 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_image_recolor(&styles->bg_click, LV_STATE_DISABLED, COLOR_BG_TEXT_DIS);
 802464e:	4b3b      	ldr	r3, [pc, #236]	; (802473c <basic_init+0xc38>)
 8024650:	681b      	ldr	r3, [r3, #0]
 8024652:	f103 0408 	add.w	r4, r3, #8
 8024656:	4b3a      	ldr	r3, [pc, #232]	; (8024740 <basic_init+0xc3c>)
 8024658:	6a1b      	ldr	r3, [r3, #32]
 802465a:	f003 0302 	and.w	r3, r3, #2
 802465e:	2b00      	cmp	r3, #0
 8024660:	d005      	beq.n	802466e <basic_init+0xb6a>
 8024662:	f640 20aa 	movw	r0, #2730	; 0xaaa
 8024666:	f7fe fd52 	bl	802310e <lv_color_hex3>
 802466a:	4603      	mov	r3, r0
 802466c:	e004      	b.n	8024678 <basic_init+0xb74>
 802466e:	f640 1099 	movw	r0, #2457	; 0x999
 8024672:	f7fe fd4c 	bl	802310e <lv_color_hex3>
 8024676:	4603      	mov	r3, r0
 8024678:	461a      	mov	r2, r3
 802467a:	2120      	movs	r1, #32
 802467c:	4620      	mov	r0, r4
 802467e:	f7ff f925 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_transition_prop_5(&styles->bg_click, LV_STATE_DEFAULT, LV_STYLE_BG_COLOR);
 8024682:	4b2e      	ldr	r3, [pc, #184]	; (802473c <basic_init+0xc38>)
 8024684:	681b      	ldr	r3, [r3, #0]
 8024686:	3308      	adds	r3, #8
 8024688:	2229      	movs	r2, #41	; 0x29
 802468a:	2100      	movs	r1, #0
 802468c:	4618      	mov	r0, r3
 802468e:	f7ff f995 	bl	80239bc <lv_style_set_transition_prop_5>

    style_init_reset(&styles->btn);
 8024692:	4b2a      	ldr	r3, [pc, #168]	; (802473c <basic_init+0xc38>)
 8024694:	681b      	ldr	r3, [r3, #0]
 8024696:	3310      	adds	r3, #16
 8024698:	4618      	mov	r0, r3
 802469a:	f005 f8b7 	bl	802980c <style_init_reset>
    lv_style_set_radius(&styles->btn, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 802469e:	4b27      	ldr	r3, [pc, #156]	; (802473c <basic_init+0xc38>)
 80246a0:	681b      	ldr	r3, [r3, #0]
 80246a2:	3310      	adds	r3, #16
 80246a4:	f647 72ff 	movw	r2, #32767	; 0x7fff
 80246a8:	2100      	movs	r1, #0
 80246aa:	4618      	mov	r0, r3
 80246ac:	f7fe fd61 	bl	8023172 <lv_style_set_radius>
    lv_style_set_bg_opa(&styles->btn, LV_STATE_DEFAULT, LV_OPA_COVER);
 80246b0:	4b22      	ldr	r3, [pc, #136]	; (802473c <basic_init+0xc38>)
 80246b2:	681b      	ldr	r3, [r3, #0]
 80246b4:	3310      	adds	r3, #16
 80246b6:	22ff      	movs	r2, #255	; 0xff
 80246b8:	2100      	movs	r1, #0
 80246ba:	4618      	mov	r0, r3
 80246bc:	f7fe fea7 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->btn, LV_STATE_DEFAULT, COLOR_BTN);
 80246c0:	4b1e      	ldr	r3, [pc, #120]	; (802473c <basic_init+0xc38>)
 80246c2:	681b      	ldr	r3, [r3, #0]
 80246c4:	f103 0410 	add.w	r4, r3, #16
 80246c8:	4b1d      	ldr	r3, [pc, #116]	; (8024740 <basic_init+0xc3c>)
 80246ca:	6a1b      	ldr	r3, [r3, #32]
 80246cc:	f003 0302 	and.w	r3, r3, #2
 80246d0:	2b00      	cmp	r3, #0
 80246d2:	d005      	beq.n	80246e0 <basic_init+0xbdc>
 80246d4:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80246d8:	f7fe fd05 	bl	80230e6 <lv_color_hex>
 80246dc:	4603      	mov	r3, r0
 80246de:	e003      	b.n	80246e8 <basic_init+0xbe4>
 80246e0:	481a      	ldr	r0, [pc, #104]	; (802474c <basic_init+0xc48>)
 80246e2:	f7fe fd00 	bl	80230e6 <lv_color_hex>
 80246e6:	4603      	mov	r3, r0
 80246e8:	461a      	mov	r2, r3
 80246ea:	2100      	movs	r1, #0
 80246ec:	4620      	mov	r0, r4
 80246ee:	f7fe fe78 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_PRESSED, COLOR_BTN_PR);
 80246f2:	4b12      	ldr	r3, [pc, #72]	; (802473c <basic_init+0xc38>)
 80246f4:	681b      	ldr	r3, [r3, #0]
 80246f6:	f103 0410 	add.w	r4, r3, #16
 80246fa:	4b11      	ldr	r3, [pc, #68]	; (8024740 <basic_init+0xc3c>)
 80246fc:	6a1b      	ldr	r3, [r3, #32]
 80246fe:	f003 0302 	and.w	r3, r3, #2
 8024702:	2b00      	cmp	r3, #0
 8024704:	d024      	beq.n	8024750 <basic_init+0xc4c>
 8024706:	4b0e      	ldr	r3, [pc, #56]	; (8024740 <basic_init+0xc3c>)
 8024708:	6a1b      	ldr	r3, [r3, #32]
 802470a:	f003 0302 	and.w	r3, r3, #2
 802470e:	2b00      	cmp	r3, #0
 8024710:	d005      	beq.n	802471e <basic_init+0xc1a>
 8024712:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024716:	f7fe fce6 	bl	80230e6 <lv_color_hex>
 802471a:	4603      	mov	r3, r0
 802471c:	e003      	b.n	8024726 <basic_init+0xc22>
 802471e:	480b      	ldr	r0, [pc, #44]	; (802474c <basic_init+0xc48>)
 8024720:	f7fe fce1 	bl	80230e6 <lv_color_hex>
 8024724:	4603      	mov	r3, r0
 8024726:	4806      	ldr	r0, [pc, #24]	; (8024740 <basic_init+0xc3c>)
 8024728:	2219      	movs	r2, #25
 802472a:	4619      	mov	r1, r3
 802472c:	8980      	ldrh	r0, [r0, #12]
 802472e:	f7fe fc3d 	bl	8022fac <lv_color_mix>
 8024732:	4603      	mov	r3, r0
 8024734:	e023      	b.n	802477e <basic_init+0xc7a>
 8024736:	bf00      	nop
 8024738:	005f656e 	.word	0x005f656e
 802473c:	20012350 	.word	0x20012350
 8024740:	20012328 	.word	0x20012328
 8024744:	003b3e42 	.word	0x003b3e42
 8024748:	00d6dde3 	.word	0x00d6dde3
 802474c:	00586273 	.word	0x00586273
 8024750:	4bbc      	ldr	r3, [pc, #752]	; (8024a44 <basic_init+0xf40>)
 8024752:	6a1b      	ldr	r3, [r3, #32]
 8024754:	f003 0302 	and.w	r3, r3, #2
 8024758:	2b00      	cmp	r3, #0
 802475a:	d005      	beq.n	8024768 <basic_init+0xc64>
 802475c:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024760:	f7fe fcc1 	bl	80230e6 <lv_color_hex>
 8024764:	4603      	mov	r3, r0
 8024766:	e003      	b.n	8024770 <basic_init+0xc6c>
 8024768:	48b7      	ldr	r0, [pc, #732]	; (8024a48 <basic_init+0xf44>)
 802476a:	f7fe fcbc 	bl	80230e6 <lv_color_hex>
 802476e:	4603      	mov	r3, r0
 8024770:	48b4      	ldr	r0, [pc, #720]	; (8024a44 <basic_init+0xf40>)
 8024772:	224c      	movs	r2, #76	; 0x4c
 8024774:	4619      	mov	r1, r3
 8024776:	8980      	ldrh	r0, [r0, #12]
 8024778:	f7fe fc18 	bl	8022fac <lv_color_mix>
 802477c:	4603      	mov	r3, r0
 802477e:	461a      	mov	r2, r3
 8024780:	2110      	movs	r1, #16
 8024782:	4620      	mov	r0, r4
 8024784:	f7fe fe2d 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_CHECKED, COLOR_BTN_CHK);
 8024788:	4bb0      	ldr	r3, [pc, #704]	; (8024a4c <basic_init+0xf48>)
 802478a:	681b      	ldr	r3, [r3, #0]
 802478c:	3310      	adds	r3, #16
 802478e:	4aad      	ldr	r2, [pc, #692]	; (8024a44 <basic_init+0xf40>)
 8024790:	8992      	ldrh	r2, [r2, #12]
 8024792:	2101      	movs	r1, #1
 8024794:	4618      	mov	r0, r3
 8024796:	f7fe fe24 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, COLOR_BTN_CHK_PR);
 802479a:	4bac      	ldr	r3, [pc, #688]	; (8024a4c <basic_init+0xf48>)
 802479c:	681b      	ldr	r3, [r3, #0]
 802479e:	f103 0410 	add.w	r4, r3, #16
 80247a2:	4ba8      	ldr	r3, [pc, #672]	; (8024a44 <basic_init+0xf40>)
 80247a4:	214c      	movs	r1, #76	; 0x4c
 80247a6:	8998      	ldrh	r0, [r3, #12]
 80247a8:	f7fb fc8c 	bl	80200c4 <lv_color_darken>
 80247ac:	4603      	mov	r3, r0
 80247ae:	461a      	mov	r2, r3
 80247b0:	2111      	movs	r1, #17
 80247b2:	4620      	mov	r0, r4
 80247b4:	f7fe fe15 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_DISABLED, COLOR_BTN);
 80247b8:	4ba4      	ldr	r3, [pc, #656]	; (8024a4c <basic_init+0xf48>)
 80247ba:	681b      	ldr	r3, [r3, #0]
 80247bc:	f103 0410 	add.w	r4, r3, #16
 80247c0:	4ba0      	ldr	r3, [pc, #640]	; (8024a44 <basic_init+0xf40>)
 80247c2:	6a1b      	ldr	r3, [r3, #32]
 80247c4:	f003 0302 	and.w	r3, r3, #2
 80247c8:	2b00      	cmp	r3, #0
 80247ca:	d005      	beq.n	80247d8 <basic_init+0xcd4>
 80247cc:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80247d0:	f7fe fc89 	bl	80230e6 <lv_color_hex>
 80247d4:	4603      	mov	r3, r0
 80247d6:	e003      	b.n	80247e0 <basic_init+0xcdc>
 80247d8:	489b      	ldr	r0, [pc, #620]	; (8024a48 <basic_init+0xf44>)
 80247da:	f7fe fc84 	bl	80230e6 <lv_color_hex>
 80247de:	4603      	mov	r3, r0
 80247e0:	461a      	mov	r2, r3
 80247e2:	2120      	movs	r1, #32
 80247e4:	4620      	mov	r0, r4
 80247e6:	f7fe fdfc 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->btn, LV_STATE_DISABLED | LV_STATE_CHECKED, COLOR_BTN_DIS);
 80247ea:	4b98      	ldr	r3, [pc, #608]	; (8024a4c <basic_init+0xf48>)
 80247ec:	681b      	ldr	r3, [r3, #0]
 80247ee:	f103 0410 	add.w	r4, r3, #16
 80247f2:	4b94      	ldr	r3, [pc, #592]	; (8024a44 <basic_init+0xf40>)
 80247f4:	6a1b      	ldr	r3, [r3, #32]
 80247f6:	f003 0302 	and.w	r3, r3, #2
 80247fa:	2b00      	cmp	r3, #0
 80247fc:	d005      	beq.n	802480a <basic_init+0xd06>
 80247fe:	f640 40cc 	movw	r0, #3276	; 0xccc
 8024802:	f7fe fc84 	bl	802310e <lv_color_hex3>
 8024806:	4603      	mov	r3, r0
 8024808:	e004      	b.n	8024814 <basic_init+0xd10>
 802480a:	f640 0088 	movw	r0, #2184	; 0x888
 802480e:	f7fe fc7e 	bl	802310e <lv_color_hex3>
 8024812:	4603      	mov	r3, r0
 8024814:	461a      	mov	r2, r3
 8024816:	2121      	movs	r1, #33	; 0x21
 8024818:	4620      	mov	r0, r4
 802481a:	f7fe fde2 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_border_color(&styles->btn, LV_STATE_DEFAULT, COLOR_BTN_BORDER);
 802481e:	4b8b      	ldr	r3, [pc, #556]	; (8024a4c <basic_init+0xf48>)
 8024820:	681b      	ldr	r3, [r3, #0]
 8024822:	3310      	adds	r3, #16
 8024824:	4a87      	ldr	r2, [pc, #540]	; (8024a44 <basic_init+0xf40>)
 8024826:	8992      	ldrh	r2, [r2, #12]
 8024828:	2100      	movs	r1, #0
 802482a:	4618      	mov	r0, r3
 802482c:	f7fe fe4e 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_color(&styles->btn, LV_STATE_PRESSED, COLOR_BTN_BORDER_PR);
 8024830:	4b86      	ldr	r3, [pc, #536]	; (8024a4c <basic_init+0xf48>)
 8024832:	681b      	ldr	r3, [r3, #0]
 8024834:	3310      	adds	r3, #16
 8024836:	4a83      	ldr	r2, [pc, #524]	; (8024a44 <basic_init+0xf40>)
 8024838:	8992      	ldrh	r2, [r2, #12]
 802483a:	2110      	movs	r1, #16
 802483c:	4618      	mov	r0, r3
 802483e:	f7fe fe45 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_color(&styles->btn, LV_STATE_DISABLED, COLOR_BTN_BORDER_INA);
 8024842:	4b82      	ldr	r3, [pc, #520]	; (8024a4c <basic_init+0xf48>)
 8024844:	681b      	ldr	r3, [r3, #0]
 8024846:	f103 0410 	add.w	r4, r3, #16
 802484a:	4b7e      	ldr	r3, [pc, #504]	; (8024a44 <basic_init+0xf40>)
 802484c:	6a1b      	ldr	r3, [r3, #32]
 802484e:	f003 0302 	and.w	r3, r3, #2
 8024852:	2b00      	cmp	r3, #0
 8024854:	d005      	beq.n	8024862 <basic_init+0xd5e>
 8024856:	f640 0088 	movw	r0, #2184	; 0x888
 802485a:	f7fe fc58 	bl	802310e <lv_color_hex3>
 802485e:	4603      	mov	r3, r0
 8024860:	e003      	b.n	802486a <basic_init+0xd66>
 8024862:	487b      	ldr	r0, [pc, #492]	; (8024a50 <basic_init+0xf4c>)
 8024864:	f7fe fc3f 	bl	80230e6 <lv_color_hex>
 8024868:	4603      	mov	r3, r0
 802486a:	461a      	mov	r2, r3
 802486c:	2120      	movs	r1, #32
 802486e:	4620      	mov	r0, r4
 8024870:	f7fe fe2c 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_width(&styles->btn, LV_STATE_DEFAULT, BORDER_WIDTH);
 8024874:	4b75      	ldr	r3, [pc, #468]	; (8024a4c <basic_init+0xf48>)
 8024876:	681b      	ldr	r3, [r3, #0]
 8024878:	f103 0410 	add.w	r4, r3, #16
 802487c:	2000      	movs	r0, #0
 802487e:	f7fa f949 	bl	801eb14 <lv_disp_get_dpi>
 8024882:	4603      	mov	r3, r0
 8024884:	2b77      	cmp	r3, #119	; 0x77
 8024886:	dd0c      	ble.n	80248a2 <basic_init+0xd9e>
 8024888:	2000      	movs	r0, #0
 802488a:	f7fa f943 	bl	801eb14 <lv_disp_get_dpi>
 802488e:	4603      	mov	r3, r0
 8024890:	3328      	adds	r3, #40	; 0x28
 8024892:	4a70      	ldr	r2, [pc, #448]	; (8024a54 <basic_init+0xf50>)
 8024894:	fb82 1203 	smull	r1, r2, r2, r3
 8024898:	1152      	asrs	r2, r2, #5
 802489a:	17db      	asrs	r3, r3, #31
 802489c:	1ad3      	subs	r3, r2, r3
 802489e:	b21b      	sxth	r3, r3
 80248a0:	e000      	b.n	80248a4 <basic_init+0xda0>
 80248a2:	2301      	movs	r3, #1
 80248a4:	461a      	mov	r2, r3
 80248a6:	2100      	movs	r1, #0
 80248a8:	4620      	mov	r0, r4
 80248aa:	f7fe fdc7 	bl	802343c <lv_style_set_border_width>
    lv_style_set_border_opa(&styles->btn, LV_STATE_CHECKED, LV_OPA_TRANSP);
 80248ae:	4b67      	ldr	r3, [pc, #412]	; (8024a4c <basic_init+0xf48>)
 80248b0:	681b      	ldr	r3, [r3, #0]
 80248b2:	3310      	adds	r3, #16
 80248b4:	2200      	movs	r2, #0
 80248b6:	2101      	movs	r1, #1
 80248b8:	4618      	mov	r0, r3
 80248ba:	f7fe fe1d 	bl	80234f8 <lv_style_set_border_opa>

    lv_style_set_text_color(&styles->btn, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
 80248be:	4b63      	ldr	r3, [pc, #396]	; (8024a4c <basic_init+0xf48>)
 80248c0:	681b      	ldr	r3, [r3, #0]
 80248c2:	f103 0410 	add.w	r4, r3, #16
 80248c6:	4b5f      	ldr	r3, [pc, #380]	; (8024a44 <basic_init+0xf40>)
 80248c8:	6a1b      	ldr	r3, [r3, #32]
 80248ca:	f003 0302 	and.w	r3, r3, #2
 80248ce:	2b00      	cmp	r3, #0
 80248d0:	d004      	beq.n	80248dc <basic_init+0xdd8>
 80248d2:	4861      	ldr	r0, [pc, #388]	; (8024a58 <basic_init+0xf54>)
 80248d4:	f7fe fc07 	bl	80230e6 <lv_color_hex>
 80248d8:	4603      	mov	r3, r0
 80248da:	e004      	b.n	80248e6 <basic_init+0xde2>
 80248dc:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80248e0:	f7fe fc01 	bl	80230e6 <lv_color_hex>
 80248e4:	4603      	mov	r3, r0
 80248e6:	461a      	mov	r2, r3
 80248e8:	2100      	movs	r1, #0
 80248ea:	4620      	mov	r0, r4
 80248ec:	f7fe ff48 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_PRESSED, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
 80248f0:	4b56      	ldr	r3, [pc, #344]	; (8024a4c <basic_init+0xf48>)
 80248f2:	681b      	ldr	r3, [r3, #0]
 80248f4:	f103 0410 	add.w	r4, r3, #16
 80248f8:	4b52      	ldr	r3, [pc, #328]	; (8024a44 <basic_init+0xf40>)
 80248fa:	6a1b      	ldr	r3, [r3, #32]
 80248fc:	f003 0302 	and.w	r3, r3, #2
 8024900:	2b00      	cmp	r3, #0
 8024902:	d004      	beq.n	802490e <basic_init+0xe0a>
 8024904:	4854      	ldr	r0, [pc, #336]	; (8024a58 <basic_init+0xf54>)
 8024906:	f7fe fbee 	bl	80230e6 <lv_color_hex>
 802490a:	4603      	mov	r3, r0
 802490c:	e004      	b.n	8024918 <basic_init+0xe14>
 802490e:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024912:	f7fe fbe8 	bl	80230e6 <lv_color_hex>
 8024916:	4603      	mov	r3, r0
 8024918:	461a      	mov	r2, r3
 802491a:	2110      	movs	r1, #16
 802491c:	4620      	mov	r0, r4
 802491e:	f7fe ff2f 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_CHECKED,  lv_color_hex(0xffffff));
 8024922:	4b4a      	ldr	r3, [pc, #296]	; (8024a4c <basic_init+0xf48>)
 8024924:	681b      	ldr	r3, [r3, #0]
 8024926:	f103 0410 	add.w	r4, r3, #16
 802492a:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 802492e:	f7fe fbda 	bl	80230e6 <lv_color_hex>
 8024932:	4603      	mov	r3, r0
 8024934:	461a      	mov	r2, r3
 8024936:	2101      	movs	r1, #1
 8024938:	4620      	mov	r0, r4
 802493a:	f7fe ff21 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, lv_color_hex(0xffffff));
 802493e:	4b43      	ldr	r3, [pc, #268]	; (8024a4c <basic_init+0xf48>)
 8024940:	681b      	ldr	r3, [r3, #0]
 8024942:	f103 0410 	add.w	r4, r3, #16
 8024946:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 802494a:	f7fe fbcc 	bl	80230e6 <lv_color_hex>
 802494e:	4603      	mov	r3, r0
 8024950:	461a      	mov	r2, r3
 8024952:	2111      	movs	r1, #17
 8024954:	4620      	mov	r0, r4
 8024956:	f7fe ff13 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_color(&styles->btn, LV_STATE_DISABLED, IS_LIGHT ? lv_color_hex(0x888888) : lv_color_hex(0x888888));
 802495a:	4b3c      	ldr	r3, [pc, #240]	; (8024a4c <basic_init+0xf48>)
 802495c:	681b      	ldr	r3, [r3, #0]
 802495e:	f103 0410 	add.w	r4, r3, #16
 8024962:	4b38      	ldr	r3, [pc, #224]	; (8024a44 <basic_init+0xf40>)
 8024964:	6a1b      	ldr	r3, [r3, #32]
 8024966:	f003 0302 	and.w	r3, r3, #2
 802496a:	2b00      	cmp	r3, #0
 802496c:	d004      	beq.n	8024978 <basic_init+0xe74>
 802496e:	483b      	ldr	r0, [pc, #236]	; (8024a5c <basic_init+0xf58>)
 8024970:	f7fe fbb9 	bl	80230e6 <lv_color_hex>
 8024974:	4603      	mov	r3, r0
 8024976:	e003      	b.n	8024980 <basic_init+0xe7c>
 8024978:	4838      	ldr	r0, [pc, #224]	; (8024a5c <basic_init+0xf58>)
 802497a:	f7fe fbb4 	bl	80230e6 <lv_color_hex>
 802497e:	4603      	mov	r3, r0
 8024980:	461a      	mov	r2, r3
 8024982:	2120      	movs	r1, #32
 8024984:	4620      	mov	r0, r4
 8024986:	f7fe fefb 	bl	8023780 <lv_style_set_text_color>

    lv_style_set_image_recolor(&styles->btn, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
 802498a:	4b30      	ldr	r3, [pc, #192]	; (8024a4c <basic_init+0xf48>)
 802498c:	681b      	ldr	r3, [r3, #0]
 802498e:	f103 0410 	add.w	r4, r3, #16
 8024992:	4b2c      	ldr	r3, [pc, #176]	; (8024a44 <basic_init+0xf40>)
 8024994:	6a1b      	ldr	r3, [r3, #32]
 8024996:	f003 0302 	and.w	r3, r3, #2
 802499a:	2b00      	cmp	r3, #0
 802499c:	d004      	beq.n	80249a8 <basic_init+0xea4>
 802499e:	482e      	ldr	r0, [pc, #184]	; (8024a58 <basic_init+0xf54>)
 80249a0:	f7fe fba1 	bl	80230e6 <lv_color_hex>
 80249a4:	4603      	mov	r3, r0
 80249a6:	e004      	b.n	80249b2 <basic_init+0xeae>
 80249a8:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80249ac:	f7fe fb9b 	bl	80230e6 <lv_color_hex>
 80249b0:	4603      	mov	r3, r0
 80249b2:	461a      	mov	r2, r3
 80249b4:	2100      	movs	r1, #0
 80249b6:	4620      	mov	r0, r4
 80249b8:	f7fe ff88 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_PRESSED, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
 80249bc:	4b23      	ldr	r3, [pc, #140]	; (8024a4c <basic_init+0xf48>)
 80249be:	681b      	ldr	r3, [r3, #0]
 80249c0:	f103 0410 	add.w	r4, r3, #16
 80249c4:	4b1f      	ldr	r3, [pc, #124]	; (8024a44 <basic_init+0xf40>)
 80249c6:	6a1b      	ldr	r3, [r3, #32]
 80249c8:	f003 0302 	and.w	r3, r3, #2
 80249cc:	2b00      	cmp	r3, #0
 80249ce:	d004      	beq.n	80249da <basic_init+0xed6>
 80249d0:	4821      	ldr	r0, [pc, #132]	; (8024a58 <basic_init+0xf54>)
 80249d2:	f7fe fb88 	bl	80230e6 <lv_color_hex>
 80249d6:	4603      	mov	r3, r0
 80249d8:	e004      	b.n	80249e4 <basic_init+0xee0>
 80249da:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80249de:	f7fe fb82 	bl	80230e6 <lv_color_hex>
 80249e2:	4603      	mov	r3, r0
 80249e4:	461a      	mov	r2, r3
 80249e6:	2110      	movs	r1, #16
 80249e8:	4620      	mov	r0, r4
 80249ea:	f7fe ff6f 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_PRESSED, lv_color_hex(0xffffff));
 80249ee:	4b17      	ldr	r3, [pc, #92]	; (8024a4c <basic_init+0xf48>)
 80249f0:	681b      	ldr	r3, [r3, #0]
 80249f2:	f103 0410 	add.w	r4, r3, #16
 80249f6:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80249fa:	f7fe fb74 	bl	80230e6 <lv_color_hex>
 80249fe:	4603      	mov	r3, r0
 8024a00:	461a      	mov	r2, r3
 8024a02:	2110      	movs	r1, #16
 8024a04:	4620      	mov	r0, r4
 8024a06:	f7fe ff61 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, lv_color_hex(0xffffff));
 8024a0a:	4b10      	ldr	r3, [pc, #64]	; (8024a4c <basic_init+0xf48>)
 8024a0c:	681b      	ldr	r3, [r3, #0]
 8024a0e:	f103 0410 	add.w	r4, r3, #16
 8024a12:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024a16:	f7fe fb66 	bl	80230e6 <lv_color_hex>
 8024a1a:	4603      	mov	r3, r0
 8024a1c:	461a      	mov	r2, r3
 8024a1e:	2111      	movs	r1, #17
 8024a20:	4620      	mov	r0, r4
 8024a22:	f7fe ff53 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_image_recolor(&styles->btn, LV_STATE_DISABLED, IS_LIGHT ? lv_color_hex(0x888888) : lv_color_hex(0x888888));
 8024a26:	4b09      	ldr	r3, [pc, #36]	; (8024a4c <basic_init+0xf48>)
 8024a28:	681b      	ldr	r3, [r3, #0]
 8024a2a:	f103 0410 	add.w	r4, r3, #16
 8024a2e:	4b05      	ldr	r3, [pc, #20]	; (8024a44 <basic_init+0xf40>)
 8024a30:	6a1b      	ldr	r3, [r3, #32]
 8024a32:	f003 0302 	and.w	r3, r3, #2
 8024a36:	2b00      	cmp	r3, #0
 8024a38:	d012      	beq.n	8024a60 <basic_init+0xf5c>
 8024a3a:	4808      	ldr	r0, [pc, #32]	; (8024a5c <basic_init+0xf58>)
 8024a3c:	f7fe fb53 	bl	80230e6 <lv_color_hex>
 8024a40:	4603      	mov	r3, r0
 8024a42:	e011      	b.n	8024a68 <basic_init+0xf64>
 8024a44:	20012328 	.word	0x20012328
 8024a48:	00586273 	.word	0x00586273
 8024a4c:	20012350 	.word	0x20012350
 8024a50:	00404040 	.word	0x00404040
 8024a54:	66666667 	.word	0x66666667
 8024a58:	0031404f 	.word	0x0031404f
 8024a5c:	00888888 	.word	0x00888888
 8024a60:	48c0      	ldr	r0, [pc, #768]	; (8024d64 <basic_init+0x1260>)
 8024a62:	f7fe fb40 	bl	80230e6 <lv_color_hex>
 8024a66:	4603      	mov	r3, r0
 8024a68:	461a      	mov	r2, r3
 8024a6a:	2120      	movs	r1, #32
 8024a6c:	4620      	mov	r0, r4
 8024a6e:	f7fe ff2d 	bl	80238cc <lv_style_set_image_recolor>

    lv_style_set_value_color(&styles->btn, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
 8024a72:	4bbd      	ldr	r3, [pc, #756]	; (8024d68 <basic_init+0x1264>)
 8024a74:	681b      	ldr	r3, [r3, #0]
 8024a76:	f103 0410 	add.w	r4, r3, #16
 8024a7a:	4bbc      	ldr	r3, [pc, #752]	; (8024d6c <basic_init+0x1268>)
 8024a7c:	6a1b      	ldr	r3, [r3, #32]
 8024a7e:	f003 0302 	and.w	r3, r3, #2
 8024a82:	2b00      	cmp	r3, #0
 8024a84:	d004      	beq.n	8024a90 <basic_init+0xf8c>
 8024a86:	48ba      	ldr	r0, [pc, #744]	; (8024d70 <basic_init+0x126c>)
 8024a88:	f7fe fb2d 	bl	80230e6 <lv_color_hex>
 8024a8c:	4603      	mov	r3, r0
 8024a8e:	e004      	b.n	8024a9a <basic_init+0xf96>
 8024a90:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024a94:	f7fe fb27 	bl	80230e6 <lv_color_hex>
 8024a98:	4603      	mov	r3, r0
 8024a9a:	461a      	mov	r2, r3
 8024a9c:	2100      	movs	r1, #0
 8024a9e:	4620      	mov	r0, r4
 8024aa0:	f7fe fe27 	bl	80236f2 <lv_style_set_value_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_PRESSED, IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex(0xffffff));
 8024aa4:	4bb0      	ldr	r3, [pc, #704]	; (8024d68 <basic_init+0x1264>)
 8024aa6:	681b      	ldr	r3, [r3, #0]
 8024aa8:	f103 0410 	add.w	r4, r3, #16
 8024aac:	4baf      	ldr	r3, [pc, #700]	; (8024d6c <basic_init+0x1268>)
 8024aae:	6a1b      	ldr	r3, [r3, #32]
 8024ab0:	f003 0302 	and.w	r3, r3, #2
 8024ab4:	2b00      	cmp	r3, #0
 8024ab6:	d004      	beq.n	8024ac2 <basic_init+0xfbe>
 8024ab8:	48ad      	ldr	r0, [pc, #692]	; (8024d70 <basic_init+0x126c>)
 8024aba:	f7fe fb14 	bl	80230e6 <lv_color_hex>
 8024abe:	4603      	mov	r3, r0
 8024ac0:	e004      	b.n	8024acc <basic_init+0xfc8>
 8024ac2:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024ac6:	f7fe fb0e 	bl	80230e6 <lv_color_hex>
 8024aca:	4603      	mov	r3, r0
 8024acc:	461a      	mov	r2, r3
 8024ace:	2110      	movs	r1, #16
 8024ad0:	4620      	mov	r0, r4
 8024ad2:	f7fe fe0e 	bl	80236f2 <lv_style_set_value_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_CHECKED,  lv_color_hex(0xffffff));
 8024ad6:	4ba4      	ldr	r3, [pc, #656]	; (8024d68 <basic_init+0x1264>)
 8024ad8:	681b      	ldr	r3, [r3, #0]
 8024ada:	f103 0410 	add.w	r4, r3, #16
 8024ade:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024ae2:	f7fe fb00 	bl	80230e6 <lv_color_hex>
 8024ae6:	4603      	mov	r3, r0
 8024ae8:	461a      	mov	r2, r3
 8024aea:	2101      	movs	r1, #1
 8024aec:	4620      	mov	r0, r4
 8024aee:	f7fe fe00 	bl	80236f2 <lv_style_set_value_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_CHECKED | LV_STATE_PRESSED, lv_color_hex(0xffffff));
 8024af2:	4b9d      	ldr	r3, [pc, #628]	; (8024d68 <basic_init+0x1264>)
 8024af4:	681b      	ldr	r3, [r3, #0]
 8024af6:	f103 0410 	add.w	r4, r3, #16
 8024afa:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8024afe:	f7fe faf2 	bl	80230e6 <lv_color_hex>
 8024b02:	4603      	mov	r3, r0
 8024b04:	461a      	mov	r2, r3
 8024b06:	2111      	movs	r1, #17
 8024b08:	4620      	mov	r0, r4
 8024b0a:	f7fe fdf2 	bl	80236f2 <lv_style_set_value_color>
    lv_style_set_value_color(&styles->btn, LV_STATE_DISABLED, IS_LIGHT ? lv_color_hex(0x888888) : lv_color_hex(0x888888));
 8024b0e:	4b96      	ldr	r3, [pc, #600]	; (8024d68 <basic_init+0x1264>)
 8024b10:	681b      	ldr	r3, [r3, #0]
 8024b12:	f103 0410 	add.w	r4, r3, #16
 8024b16:	4b95      	ldr	r3, [pc, #596]	; (8024d6c <basic_init+0x1268>)
 8024b18:	6a1b      	ldr	r3, [r3, #32]
 8024b1a:	f003 0302 	and.w	r3, r3, #2
 8024b1e:	2b00      	cmp	r3, #0
 8024b20:	d004      	beq.n	8024b2c <basic_init+0x1028>
 8024b22:	4890      	ldr	r0, [pc, #576]	; (8024d64 <basic_init+0x1260>)
 8024b24:	f7fe fadf 	bl	80230e6 <lv_color_hex>
 8024b28:	4603      	mov	r3, r0
 8024b2a:	e003      	b.n	8024b34 <basic_init+0x1030>
 8024b2c:	488d      	ldr	r0, [pc, #564]	; (8024d64 <basic_init+0x1260>)
 8024b2e:	f7fe fada 	bl	80230e6 <lv_color_hex>
 8024b32:	4603      	mov	r3, r0
 8024b34:	461a      	mov	r2, r3
 8024b36:	2120      	movs	r1, #32
 8024b38:	4620      	mov	r0, r4
 8024b3a:	f7fe fdda 	bl	80236f2 <lv_style_set_value_color>

    lv_style_set_pad_left(&styles->btn, LV_STATE_DEFAULT, LV_DPX(40));
 8024b3e:	4b8a      	ldr	r3, [pc, #552]	; (8024d68 <basic_init+0x1264>)
 8024b40:	681b      	ldr	r3, [r3, #0]
 8024b42:	f103 0410 	add.w	r4, r3, #16
 8024b46:	2000      	movs	r0, #0
 8024b48:	f7f9 ffe4 	bl	801eb14 <lv_disp_get_dpi>
 8024b4c:	4603      	mov	r3, r0
 8024b4e:	461a      	mov	r2, r3
 8024b50:	4613      	mov	r3, r2
 8024b52:	009b      	lsls	r3, r3, #2
 8024b54:	4413      	add	r3, r2
 8024b56:	00db      	lsls	r3, r3, #3
 8024b58:	2bef      	cmp	r3, #239	; 0xef
 8024b5a:	dd11      	ble.n	8024b80 <basic_init+0x107c>
 8024b5c:	2000      	movs	r0, #0
 8024b5e:	f7f9 ffd9 	bl	801eb14 <lv_disp_get_dpi>
 8024b62:	4603      	mov	r3, r0
 8024b64:	461a      	mov	r2, r3
 8024b66:	4613      	mov	r3, r2
 8024b68:	009b      	lsls	r3, r3, #2
 8024b6a:	4413      	add	r3, r2
 8024b6c:	00db      	lsls	r3, r3, #3
 8024b6e:	3350      	adds	r3, #80	; 0x50
 8024b70:	4a80      	ldr	r2, [pc, #512]	; (8024d74 <basic_init+0x1270>)
 8024b72:	fb82 1203 	smull	r1, r2, r2, r3
 8024b76:	1192      	asrs	r2, r2, #6
 8024b78:	17db      	asrs	r3, r3, #31
 8024b7a:	1ad3      	subs	r3, r2, r3
 8024b7c:	b21b      	sxth	r3, r3
 8024b7e:	e000      	b.n	8024b82 <basic_init+0x107e>
 8024b80:	2301      	movs	r3, #1
 8024b82:	461a      	mov	r2, r3
 8024b84:	2100      	movs	r1, #0
 8024b86:	4620      	mov	r0, r4
 8024b88:	f7fe fb83 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->btn, LV_STATE_DEFAULT, LV_DPX(40));
 8024b8c:	4b76      	ldr	r3, [pc, #472]	; (8024d68 <basic_init+0x1264>)
 8024b8e:	681b      	ldr	r3, [r3, #0]
 8024b90:	f103 0410 	add.w	r4, r3, #16
 8024b94:	2000      	movs	r0, #0
 8024b96:	f7f9 ffbd 	bl	801eb14 <lv_disp_get_dpi>
 8024b9a:	4603      	mov	r3, r0
 8024b9c:	461a      	mov	r2, r3
 8024b9e:	4613      	mov	r3, r2
 8024ba0:	009b      	lsls	r3, r3, #2
 8024ba2:	4413      	add	r3, r2
 8024ba4:	00db      	lsls	r3, r3, #3
 8024ba6:	2bef      	cmp	r3, #239	; 0xef
 8024ba8:	dd11      	ble.n	8024bce <basic_init+0x10ca>
 8024baa:	2000      	movs	r0, #0
 8024bac:	f7f9 ffb2 	bl	801eb14 <lv_disp_get_dpi>
 8024bb0:	4603      	mov	r3, r0
 8024bb2:	461a      	mov	r2, r3
 8024bb4:	4613      	mov	r3, r2
 8024bb6:	009b      	lsls	r3, r3, #2
 8024bb8:	4413      	add	r3, r2
 8024bba:	00db      	lsls	r3, r3, #3
 8024bbc:	3350      	adds	r3, #80	; 0x50
 8024bbe:	4a6d      	ldr	r2, [pc, #436]	; (8024d74 <basic_init+0x1270>)
 8024bc0:	fb82 1203 	smull	r1, r2, r2, r3
 8024bc4:	1192      	asrs	r2, r2, #6
 8024bc6:	17db      	asrs	r3, r3, #31
 8024bc8:	1ad3      	subs	r3, r2, r3
 8024bca:	b21b      	sxth	r3, r3
 8024bcc:	e000      	b.n	8024bd0 <basic_init+0x10cc>
 8024bce:	2301      	movs	r3, #1
 8024bd0:	461a      	mov	r2, r3
 8024bd2:	2100      	movs	r1, #0
 8024bd4:	4620      	mov	r0, r4
 8024bd6:	f7fe fb74 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->btn, LV_STATE_DEFAULT, LV_DPX(15));
 8024bda:	4b63      	ldr	r3, [pc, #396]	; (8024d68 <basic_init+0x1264>)
 8024bdc:	681b      	ldr	r3, [r3, #0]
 8024bde:	f103 0410 	add.w	r4, r3, #16
 8024be2:	2000      	movs	r0, #0
 8024be4:	f7f9 ff96 	bl	801eb14 <lv_disp_get_dpi>
 8024be8:	4603      	mov	r3, r0
 8024bea:	461a      	mov	r2, r3
 8024bec:	4613      	mov	r3, r2
 8024bee:	011b      	lsls	r3, r3, #4
 8024bf0:	1a9b      	subs	r3, r3, r2
 8024bf2:	2bef      	cmp	r3, #239	; 0xef
 8024bf4:	dd10      	ble.n	8024c18 <basic_init+0x1114>
 8024bf6:	2000      	movs	r0, #0
 8024bf8:	f7f9 ff8c 	bl	801eb14 <lv_disp_get_dpi>
 8024bfc:	4603      	mov	r3, r0
 8024bfe:	461a      	mov	r2, r3
 8024c00:	4613      	mov	r3, r2
 8024c02:	011b      	lsls	r3, r3, #4
 8024c04:	1a9b      	subs	r3, r3, r2
 8024c06:	3350      	adds	r3, #80	; 0x50
 8024c08:	4a5a      	ldr	r2, [pc, #360]	; (8024d74 <basic_init+0x1270>)
 8024c0a:	fb82 1203 	smull	r1, r2, r2, r3
 8024c0e:	1192      	asrs	r2, r2, #6
 8024c10:	17db      	asrs	r3, r3, #31
 8024c12:	1ad3      	subs	r3, r2, r3
 8024c14:	b21b      	sxth	r3, r3
 8024c16:	e000      	b.n	8024c1a <basic_init+0x1116>
 8024c18:	2301      	movs	r3, #1
 8024c1a:	461a      	mov	r2, r3
 8024c1c:	2100      	movs	r1, #0
 8024c1e:	4620      	mov	r0, r4
 8024c20:	f7fe fb07 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->btn, LV_STATE_DEFAULT, LV_DPX(15));
 8024c24:	4b50      	ldr	r3, [pc, #320]	; (8024d68 <basic_init+0x1264>)
 8024c26:	681b      	ldr	r3, [r3, #0]
 8024c28:	f103 0410 	add.w	r4, r3, #16
 8024c2c:	2000      	movs	r0, #0
 8024c2e:	f7f9 ff71 	bl	801eb14 <lv_disp_get_dpi>
 8024c32:	4603      	mov	r3, r0
 8024c34:	461a      	mov	r2, r3
 8024c36:	4613      	mov	r3, r2
 8024c38:	011b      	lsls	r3, r3, #4
 8024c3a:	1a9b      	subs	r3, r3, r2
 8024c3c:	2bef      	cmp	r3, #239	; 0xef
 8024c3e:	dd10      	ble.n	8024c62 <basic_init+0x115e>
 8024c40:	2000      	movs	r0, #0
 8024c42:	f7f9 ff67 	bl	801eb14 <lv_disp_get_dpi>
 8024c46:	4603      	mov	r3, r0
 8024c48:	461a      	mov	r2, r3
 8024c4a:	4613      	mov	r3, r2
 8024c4c:	011b      	lsls	r3, r3, #4
 8024c4e:	1a9b      	subs	r3, r3, r2
 8024c50:	3350      	adds	r3, #80	; 0x50
 8024c52:	4a48      	ldr	r2, [pc, #288]	; (8024d74 <basic_init+0x1270>)
 8024c54:	fb82 1203 	smull	r1, r2, r2, r3
 8024c58:	1192      	asrs	r2, r2, #6
 8024c5a:	17db      	asrs	r3, r3, #31
 8024c5c:	1ad3      	subs	r3, r2, r3
 8024c5e:	b21b      	sxth	r3, r3
 8024c60:	e000      	b.n	8024c64 <basic_init+0x1160>
 8024c62:	2301      	movs	r3, #1
 8024c64:	461a      	mov	r2, r3
 8024c66:	2100      	movs	r1, #0
 8024c68:	4620      	mov	r0, r4
 8024c6a:	f7fe fafa 	bl	8023262 <lv_style_set_pad_bottom>
    lv_style_set_pad_inner(&styles->btn, LV_STATE_DEFAULT, LV_DPX(20));
 8024c6e:	4b3e      	ldr	r3, [pc, #248]	; (8024d68 <basic_init+0x1264>)
 8024c70:	681b      	ldr	r3, [r3, #0]
 8024c72:	f103 0410 	add.w	r4, r3, #16
 8024c76:	2000      	movs	r0, #0
 8024c78:	f7f9 ff4c 	bl	801eb14 <lv_disp_get_dpi>
 8024c7c:	4603      	mov	r3, r0
 8024c7e:	461a      	mov	r2, r3
 8024c80:	4613      	mov	r3, r2
 8024c82:	009b      	lsls	r3, r3, #2
 8024c84:	4413      	add	r3, r2
 8024c86:	009b      	lsls	r3, r3, #2
 8024c88:	2bef      	cmp	r3, #239	; 0xef
 8024c8a:	dd11      	ble.n	8024cb0 <basic_init+0x11ac>
 8024c8c:	2000      	movs	r0, #0
 8024c8e:	f7f9 ff41 	bl	801eb14 <lv_disp_get_dpi>
 8024c92:	4603      	mov	r3, r0
 8024c94:	461a      	mov	r2, r3
 8024c96:	4613      	mov	r3, r2
 8024c98:	009b      	lsls	r3, r3, #2
 8024c9a:	4413      	add	r3, r2
 8024c9c:	009b      	lsls	r3, r3, #2
 8024c9e:	3350      	adds	r3, #80	; 0x50
 8024ca0:	4a34      	ldr	r2, [pc, #208]	; (8024d74 <basic_init+0x1270>)
 8024ca2:	fb82 1203 	smull	r1, r2, r2, r3
 8024ca6:	1192      	asrs	r2, r2, #6
 8024ca8:	17db      	asrs	r3, r3, #31
 8024caa:	1ad3      	subs	r3, r2, r3
 8024cac:	b21b      	sxth	r3, r3
 8024cae:	e000      	b.n	8024cb2 <basic_init+0x11ae>
 8024cb0:	2301      	movs	r3, #1
 8024cb2:	461a      	mov	r2, r3
 8024cb4:	2100      	movs	r1, #0
 8024cb6:	4620      	mov	r0, r4
 8024cb8:	f7fe fb1b 	bl	80232f2 <lv_style_set_pad_inner>
    lv_style_set_outline_width(&styles->btn, LV_STATE_DEFAULT, OUTLINE_WIDTH);
 8024cbc:	4b2a      	ldr	r3, [pc, #168]	; (8024d68 <basic_init+0x1264>)
 8024cbe:	681b      	ldr	r3, [r3, #0]
 8024cc0:	f103 0410 	add.w	r4, r3, #16
 8024cc4:	4b29      	ldr	r3, [pc, #164]	; (8024d6c <basic_init+0x1268>)
 8024cc6:	6a1b      	ldr	r3, [r3, #32]
 8024cc8:	f003 0320 	and.w	r3, r3, #32
 8024ccc:	2b00      	cmp	r3, #0
 8024cce:	d114      	bne.n	8024cfa <basic_init+0x11f6>
 8024cd0:	2000      	movs	r0, #0
 8024cd2:	f7f9 ff1f 	bl	801eb14 <lv_disp_get_dpi>
 8024cd6:	4603      	mov	r3, r0
 8024cd8:	2b77      	cmp	r3, #119	; 0x77
 8024cda:	dd0c      	ble.n	8024cf6 <basic_init+0x11f2>
 8024cdc:	2000      	movs	r0, #0
 8024cde:	f7f9 ff19 	bl	801eb14 <lv_disp_get_dpi>
 8024ce2:	4603      	mov	r3, r0
 8024ce4:	3328      	adds	r3, #40	; 0x28
 8024ce6:	4a23      	ldr	r2, [pc, #140]	; (8024d74 <basic_init+0x1270>)
 8024ce8:	fb82 1203 	smull	r1, r2, r2, r3
 8024cec:	1152      	asrs	r2, r2, #5
 8024cee:	17db      	asrs	r3, r3, #31
 8024cf0:	1ad3      	subs	r3, r2, r3
 8024cf2:	b21b      	sxth	r3, r3
 8024cf4:	e002      	b.n	8024cfc <basic_init+0x11f8>
 8024cf6:	2301      	movs	r3, #1
 8024cf8:	e000      	b.n	8024cfc <basic_init+0x11f8>
 8024cfa:	2300      	movs	r3, #0
 8024cfc:	461a      	mov	r2, r3
 8024cfe:	2100      	movs	r1, #0
 8024d00:	4620      	mov	r0, r4
 8024d02:	f7fe fc10 	bl	8023526 <lv_style_set_outline_width>
    lv_style_set_outline_opa(&styles->btn, LV_STATE_DEFAULT, LV_OPA_0);
 8024d06:	4b18      	ldr	r3, [pc, #96]	; (8024d68 <basic_init+0x1264>)
 8024d08:	681b      	ldr	r3, [r3, #0]
 8024d0a:	3310      	adds	r3, #16
 8024d0c:	2200      	movs	r2, #0
 8024d0e:	2100      	movs	r1, #0
 8024d10:	4618      	mov	r0, r3
 8024d12:	f7fe fc4e 	bl	80235b2 <lv_style_set_outline_opa>
    lv_style_set_outline_opa(&styles->btn, LV_STATE_FOCUSED, LV_OPA_50);
 8024d16:	4b14      	ldr	r3, [pc, #80]	; (8024d68 <basic_init+0x1264>)
 8024d18:	681b      	ldr	r3, [r3, #0]
 8024d1a:	3310      	adds	r3, #16
 8024d1c:	227f      	movs	r2, #127	; 0x7f
 8024d1e:	2102      	movs	r1, #2
 8024d20:	4618      	mov	r0, r3
 8024d22:	f7fe fc46 	bl	80235b2 <lv_style_set_outline_opa>
    lv_style_set_outline_color(&styles->btn, LV_STATE_DEFAULT, theme.color_primary);
 8024d26:	4b10      	ldr	r3, [pc, #64]	; (8024d68 <basic_init+0x1264>)
 8024d28:	681b      	ldr	r3, [r3, #0]
 8024d2a:	3310      	adds	r3, #16
 8024d2c:	4a0f      	ldr	r2, [pc, #60]	; (8024d6c <basic_init+0x1268>)
 8024d2e:	8992      	ldrh	r2, [r2, #12]
 8024d30:	2100      	movs	r1, #0
 8024d32:	4618      	mov	r0, r3
 8024d34:	f7fe fc27 	bl	8023586 <lv_style_set_outline_color>
    lv_style_set_outline_color(&styles->btn, LV_STATE_EDITED, theme.color_secondary);
 8024d38:	4b0b      	ldr	r3, [pc, #44]	; (8024d68 <basic_init+0x1264>)
 8024d3a:	681b      	ldr	r3, [r3, #0]
 8024d3c:	3310      	adds	r3, #16
 8024d3e:	4a0b      	ldr	r2, [pc, #44]	; (8024d6c <basic_init+0x1268>)
 8024d40:	89d2      	ldrh	r2, [r2, #14]
 8024d42:	2104      	movs	r1, #4
 8024d44:	4618      	mov	r0, r3
 8024d46:	f7fe fc1e 	bl	8023586 <lv_style_set_outline_color>
    lv_style_set_transition_time(&styles->btn, LV_STATE_DEFAULT, TRANSITION_TIME);
 8024d4a:	4b07      	ldr	r3, [pc, #28]	; (8024d68 <basic_init+0x1264>)
 8024d4c:	681b      	ldr	r3, [r3, #0]
 8024d4e:	f103 0010 	add.w	r0, r3, #16
 8024d52:	4b06      	ldr	r3, [pc, #24]	; (8024d6c <basic_init+0x1268>)
 8024d54:	6a1b      	ldr	r3, [r3, #32]
 8024d56:	f003 0310 	and.w	r3, r3, #16
 8024d5a:	2b00      	cmp	r3, #0
 8024d5c:	d00c      	beq.n	8024d78 <basic_init+0x1274>
 8024d5e:	2300      	movs	r3, #0
 8024d60:	e00b      	b.n	8024d7a <basic_init+0x1276>
 8024d62:	bf00      	nop
 8024d64:	00888888 	.word	0x00888888
 8024d68:	20012350 	.word	0x20012350
 8024d6c:	20012328 	.word	0x20012328
 8024d70:	0031404f 	.word	0x0031404f
 8024d74:	66666667 	.word	0x66666667
 8024d78:	2396      	movs	r3, #150	; 0x96
 8024d7a:	461a      	mov	r2, r3
 8024d7c:	2100      	movs	r1, #0
 8024d7e:	f7fe fdbd 	bl	80238fc <lv_style_set_transition_time>
    lv_style_set_transition_prop_4(&styles->btn, LV_STATE_DEFAULT, LV_STYLE_BORDER_OPA);
 8024d82:	4b7f      	ldr	r3, [pc, #508]	; (8024f80 <basic_init+0x147c>)
 8024d84:	681b      	ldr	r3, [r3, #0]
 8024d86:	3310      	adds	r3, #16
 8024d88:	223c      	movs	r2, #60	; 0x3c
 8024d8a:	2100      	movs	r1, #0
 8024d8c:	4618      	mov	r0, r3
 8024d8e:	f7fe fdfd 	bl	802398c <lv_style_set_transition_prop_4>
    lv_style_set_transition_prop_5(&styles->btn, LV_STATE_DEFAULT, LV_STYLE_BG_COLOR);
 8024d92:	4b7b      	ldr	r3, [pc, #492]	; (8024f80 <basic_init+0x147c>)
 8024d94:	681b      	ldr	r3, [r3, #0]
 8024d96:	3310      	adds	r3, #16
 8024d98:	2229      	movs	r2, #41	; 0x29
 8024d9a:	2100      	movs	r1, #0
 8024d9c:	4618      	mov	r0, r3
 8024d9e:	f7fe fe0d 	bl	80239bc <lv_style_set_transition_prop_5>
    lv_style_set_transition_prop_6(&styles->btn, LV_STATE_DEFAULT, LV_STYLE_OUTLINE_OPA);
 8024da2:	4b77      	ldr	r3, [pc, #476]	; (8024f80 <basic_init+0x147c>)
 8024da4:	681b      	ldr	r3, [r3, #0]
 8024da6:	3310      	adds	r3, #16
 8024da8:	224c      	movs	r2, #76	; 0x4c
 8024daa:	2100      	movs	r1, #0
 8024dac:	4618      	mov	r0, r3
 8024dae:	f7fe fe1d 	bl	80239ec <lv_style_set_transition_prop_6>
    lv_style_set_transition_delay(&styles->btn, LV_STATE_DEFAULT, TRANSITION_TIME);
 8024db2:	4b73      	ldr	r3, [pc, #460]	; (8024f80 <basic_init+0x147c>)
 8024db4:	681b      	ldr	r3, [r3, #0]
 8024db6:	f103 0010 	add.w	r0, r3, #16
 8024dba:	4b72      	ldr	r3, [pc, #456]	; (8024f84 <basic_init+0x1480>)
 8024dbc:	6a1b      	ldr	r3, [r3, #32]
 8024dbe:	f003 0310 	and.w	r3, r3, #16
 8024dc2:	2b00      	cmp	r3, #0
 8024dc4:	d001      	beq.n	8024dca <basic_init+0x12c6>
 8024dc6:	2300      	movs	r3, #0
 8024dc8:	e000      	b.n	8024dcc <basic_init+0x12c8>
 8024dca:	2396      	movs	r3, #150	; 0x96
 8024dcc:	461a      	mov	r2, r3
 8024dce:	2100      	movs	r1, #0
 8024dd0:	f7fe fdac 	bl	802392c <lv_style_set_transition_delay>
    lv_style_set_transition_delay(&styles->btn, LV_STATE_PRESSED, 0);
 8024dd4:	4b6a      	ldr	r3, [pc, #424]	; (8024f80 <basic_init+0x147c>)
 8024dd6:	681b      	ldr	r3, [r3, #0]
 8024dd8:	3310      	adds	r3, #16
 8024dda:	2200      	movs	r2, #0
 8024ddc:	2110      	movs	r1, #16
 8024dde:	4618      	mov	r0, r3
 8024de0:	f7fe fda4 	bl	802392c <lv_style_set_transition_delay>

    style_init_reset(&styles->pad_inner);
 8024de4:	4b66      	ldr	r3, [pc, #408]	; (8024f80 <basic_init+0x147c>)
 8024de6:	681b      	ldr	r3, [r3, #0]
 8024de8:	3314      	adds	r3, #20
 8024dea:	4618      	mov	r0, r3
 8024dec:	f004 fd0e 	bl	802980c <style_init_reset>

    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT,
 8024df0:	4b63      	ldr	r3, [pc, #396]	; (8024f80 <basic_init+0x147c>)
 8024df2:	681b      	ldr	r3, [r3, #0]
 8024df4:	f103 0414 	add.w	r4, r3, #20
                           lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(20) : LV_DPX(40));
 8024df8:	2000      	movs	r0, #0
 8024dfa:	f7f9 fea4 	bl	801eb46 <lv_disp_get_size_category>
 8024dfe:	4603      	mov	r3, r0
    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT,
 8024e00:	2b32      	cmp	r3, #50	; 0x32
 8024e02:	d81e      	bhi.n	8024e42 <basic_init+0x133e>
                           lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(20) : LV_DPX(40));
 8024e04:	2000      	movs	r0, #0
 8024e06:	f7f9 fe85 	bl	801eb14 <lv_disp_get_dpi>
 8024e0a:	4603      	mov	r3, r0
 8024e0c:	461a      	mov	r2, r3
 8024e0e:	4613      	mov	r3, r2
 8024e10:	009b      	lsls	r3, r3, #2
 8024e12:	4413      	add	r3, r2
 8024e14:	009b      	lsls	r3, r3, #2
    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT,
 8024e16:	2bef      	cmp	r3, #239	; 0xef
 8024e18:	dd11      	ble.n	8024e3e <basic_init+0x133a>
                           lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(20) : LV_DPX(40));
 8024e1a:	2000      	movs	r0, #0
 8024e1c:	f7f9 fe7a 	bl	801eb14 <lv_disp_get_dpi>
 8024e20:	4603      	mov	r3, r0
 8024e22:	461a      	mov	r2, r3
 8024e24:	4613      	mov	r3, r2
 8024e26:	009b      	lsls	r3, r3, #2
 8024e28:	4413      	add	r3, r2
 8024e2a:	009b      	lsls	r3, r3, #2
 8024e2c:	3350      	adds	r3, #80	; 0x50
 8024e2e:	4a56      	ldr	r2, [pc, #344]	; (8024f88 <basic_init+0x1484>)
 8024e30:	fb82 1203 	smull	r1, r2, r2, r3
 8024e34:	1192      	asrs	r2, r2, #6
 8024e36:	17db      	asrs	r3, r3, #31
 8024e38:	1ad3      	subs	r3, r2, r3
    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT,
 8024e3a:	b21b      	sxth	r3, r3
 8024e3c:	e01f      	b.n	8024e7e <basic_init+0x137a>
 8024e3e:	2301      	movs	r3, #1
 8024e40:	e01d      	b.n	8024e7e <basic_init+0x137a>
                           lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(20) : LV_DPX(40));
 8024e42:	2000      	movs	r0, #0
 8024e44:	f7f9 fe66 	bl	801eb14 <lv_disp_get_dpi>
 8024e48:	4603      	mov	r3, r0
 8024e4a:	461a      	mov	r2, r3
 8024e4c:	4613      	mov	r3, r2
 8024e4e:	009b      	lsls	r3, r3, #2
 8024e50:	4413      	add	r3, r2
 8024e52:	00db      	lsls	r3, r3, #3
    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT,
 8024e54:	2bef      	cmp	r3, #239	; 0xef
 8024e56:	dd11      	ble.n	8024e7c <basic_init+0x1378>
                           lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(20) : LV_DPX(40));
 8024e58:	2000      	movs	r0, #0
 8024e5a:	f7f9 fe5b 	bl	801eb14 <lv_disp_get_dpi>
 8024e5e:	4603      	mov	r3, r0
 8024e60:	461a      	mov	r2, r3
 8024e62:	4613      	mov	r3, r2
 8024e64:	009b      	lsls	r3, r3, #2
 8024e66:	4413      	add	r3, r2
 8024e68:	00db      	lsls	r3, r3, #3
 8024e6a:	3350      	adds	r3, #80	; 0x50
 8024e6c:	4a46      	ldr	r2, [pc, #280]	; (8024f88 <basic_init+0x1484>)
 8024e6e:	fb82 1203 	smull	r1, r2, r2, r3
 8024e72:	1192      	asrs	r2, r2, #6
 8024e74:	17db      	asrs	r3, r3, #31
 8024e76:	1ad3      	subs	r3, r2, r3
    lv_style_set_pad_inner(&styles->pad_inner, LV_STATE_DEFAULT,
 8024e78:	b21b      	sxth	r3, r3
 8024e7a:	e000      	b.n	8024e7e <basic_init+0x137a>
 8024e7c:	2301      	movs	r3, #1
 8024e7e:	461a      	mov	r2, r3
 8024e80:	2100      	movs	r1, #0
 8024e82:	4620      	mov	r0, r4
 8024e84:	f7fe fa35 	bl	80232f2 <lv_style_set_pad_inner>

    style_init_reset(&styles->pad_small);
 8024e88:	4b3d      	ldr	r3, [pc, #244]	; (8024f80 <basic_init+0x147c>)
 8024e8a:	681b      	ldr	r3, [r3, #0]
 8024e8c:	3318      	adds	r3, #24
 8024e8e:	4618      	mov	r0, r3
 8024e90:	f004 fcbc 	bl	802980c <style_init_reset>
    lv_style_int_t pad_small_value = lv_disp_get_size_category(NULL) <= LV_DISP_MEDIUM_LIMIT ? LV_DPX(10) : LV_DPX(20);
 8024e94:	2000      	movs	r0, #0
 8024e96:	f7f9 fe56 	bl	801eb46 <lv_disp_get_size_category>
 8024e9a:	4603      	mov	r3, r0
 8024e9c:	2b32      	cmp	r3, #50	; 0x32
 8024e9e:	d81e      	bhi.n	8024ede <basic_init+0x13da>
 8024ea0:	2000      	movs	r0, #0
 8024ea2:	f7f9 fe37 	bl	801eb14 <lv_disp_get_dpi>
 8024ea6:	4603      	mov	r3, r0
 8024ea8:	461a      	mov	r2, r3
 8024eaa:	4613      	mov	r3, r2
 8024eac:	009b      	lsls	r3, r3, #2
 8024eae:	4413      	add	r3, r2
 8024eb0:	005b      	lsls	r3, r3, #1
 8024eb2:	2bef      	cmp	r3, #239	; 0xef
 8024eb4:	dd11      	ble.n	8024eda <basic_init+0x13d6>
 8024eb6:	2000      	movs	r0, #0
 8024eb8:	f7f9 fe2c 	bl	801eb14 <lv_disp_get_dpi>
 8024ebc:	4603      	mov	r3, r0
 8024ebe:	461a      	mov	r2, r3
 8024ec0:	4613      	mov	r3, r2
 8024ec2:	009b      	lsls	r3, r3, #2
 8024ec4:	4413      	add	r3, r2
 8024ec6:	005b      	lsls	r3, r3, #1
 8024ec8:	3350      	adds	r3, #80	; 0x50
 8024eca:	4a2f      	ldr	r2, [pc, #188]	; (8024f88 <basic_init+0x1484>)
 8024ecc:	fb82 1203 	smull	r1, r2, r2, r3
 8024ed0:	1192      	asrs	r2, r2, #6
 8024ed2:	17db      	asrs	r3, r3, #31
 8024ed4:	1ad3      	subs	r3, r2, r3
 8024ed6:	b21b      	sxth	r3, r3
 8024ed8:	e01f      	b.n	8024f1a <basic_init+0x1416>
 8024eda:	2301      	movs	r3, #1
 8024edc:	e01d      	b.n	8024f1a <basic_init+0x1416>
 8024ede:	2000      	movs	r0, #0
 8024ee0:	f7f9 fe18 	bl	801eb14 <lv_disp_get_dpi>
 8024ee4:	4603      	mov	r3, r0
 8024ee6:	461a      	mov	r2, r3
 8024ee8:	4613      	mov	r3, r2
 8024eea:	009b      	lsls	r3, r3, #2
 8024eec:	4413      	add	r3, r2
 8024eee:	009b      	lsls	r3, r3, #2
 8024ef0:	2bef      	cmp	r3, #239	; 0xef
 8024ef2:	dd11      	ble.n	8024f18 <basic_init+0x1414>
 8024ef4:	2000      	movs	r0, #0
 8024ef6:	f7f9 fe0d 	bl	801eb14 <lv_disp_get_dpi>
 8024efa:	4603      	mov	r3, r0
 8024efc:	461a      	mov	r2, r3
 8024efe:	4613      	mov	r3, r2
 8024f00:	009b      	lsls	r3, r3, #2
 8024f02:	4413      	add	r3, r2
 8024f04:	009b      	lsls	r3, r3, #2
 8024f06:	3350      	adds	r3, #80	; 0x50
 8024f08:	4a1f      	ldr	r2, [pc, #124]	; (8024f88 <basic_init+0x1484>)
 8024f0a:	fb82 1203 	smull	r1, r2, r2, r3
 8024f0e:	1192      	asrs	r2, r2, #6
 8024f10:	17db      	asrs	r3, r3, #31
 8024f12:	1ad3      	subs	r3, r2, r3
 8024f14:	b21b      	sxth	r3, r3
 8024f16:	e000      	b.n	8024f1a <basic_init+0x1416>
 8024f18:	2301      	movs	r3, #1
 8024f1a:	80fb      	strh	r3, [r7, #6]
    lv_style_set_pad_left(&styles->pad_small, LV_STATE_DEFAULT,  pad_small_value);
 8024f1c:	4b18      	ldr	r3, [pc, #96]	; (8024f80 <basic_init+0x147c>)
 8024f1e:	681b      	ldr	r3, [r3, #0]
 8024f20:	3318      	adds	r3, #24
 8024f22:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8024f26:	2100      	movs	r1, #0
 8024f28:	4618      	mov	r0, r3
 8024f2a:	f7fe f9b2 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->pad_small, LV_STATE_DEFAULT, pad_small_value);
 8024f2e:	4b14      	ldr	r3, [pc, #80]	; (8024f80 <basic_init+0x147c>)
 8024f30:	681b      	ldr	r3, [r3, #0]
 8024f32:	3318      	adds	r3, #24
 8024f34:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8024f38:	2100      	movs	r1, #0
 8024f3a:	4618      	mov	r0, r3
 8024f3c:	f7fe f9c1 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->pad_small, LV_STATE_DEFAULT,  pad_small_value);
 8024f40:	4b0f      	ldr	r3, [pc, #60]	; (8024f80 <basic_init+0x147c>)
 8024f42:	681b      	ldr	r3, [r3, #0]
 8024f44:	3318      	adds	r3, #24
 8024f46:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8024f4a:	2100      	movs	r1, #0
 8024f4c:	4618      	mov	r0, r3
 8024f4e:	f7fe f970 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->pad_small, LV_STATE_DEFAULT, pad_small_value);
 8024f52:	4b0b      	ldr	r3, [pc, #44]	; (8024f80 <basic_init+0x147c>)
 8024f54:	681b      	ldr	r3, [r3, #0]
 8024f56:	3318      	adds	r3, #24
 8024f58:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8024f5c:	2100      	movs	r1, #0
 8024f5e:	4618      	mov	r0, r3
 8024f60:	f7fe f97f 	bl	8023262 <lv_style_set_pad_bottom>
    lv_style_set_pad_inner(&styles->pad_small, LV_STATE_DEFAULT, pad_small_value);
 8024f64:	4b06      	ldr	r3, [pc, #24]	; (8024f80 <basic_init+0x147c>)
 8024f66:	681b      	ldr	r3, [r3, #0]
 8024f68:	3318      	adds	r3, #24
 8024f6a:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8024f6e:	2100      	movs	r1, #0
 8024f70:	4618      	mov	r0, r3
 8024f72:	f7fe f9be 	bl	80232f2 <lv_style_set_pad_inner>
}
 8024f76:	bf00      	nop
 8024f78:	3708      	adds	r7, #8
 8024f7a:	46bd      	mov	sp, r7
 8024f7c:	bdb0      	pop	{r4, r5, r7, pc}
 8024f7e:	bf00      	nop
 8024f80:	20012350 	.word	0x20012350
 8024f84:	20012328 	.word	0x20012328
 8024f88:	66666667 	.word	0x66666667

08024f8c <cont_init>:

static void cont_init(void)
{
 8024f8c:	b480      	push	{r7}
 8024f8e:	af00      	add	r7, sp, #0
#if LV_USE_CONT != 0

#endif
}
 8024f90:	bf00      	nop
 8024f92:	46bd      	mov	sp, r7
 8024f94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024f98:	4770      	bx	lr

08024f9a <btn_init>:

static void btn_init(void)
{
 8024f9a:	b480      	push	{r7}
 8024f9c:	af00      	add	r7, sp, #0
#if LV_USE_BTN != 0

#endif
}
 8024f9e:	bf00      	nop
 8024fa0:	46bd      	mov	sp, r7
 8024fa2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024fa6:	4770      	bx	lr

08024fa8 <label_init>:

static void label_init(void)
{
 8024fa8:	b480      	push	{r7}
 8024faa:	af00      	add	r7, sp, #0
#if LV_USE_LABEL != 0

#endif
}
 8024fac:	bf00      	nop
 8024fae:	46bd      	mov	sp, r7
 8024fb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024fb4:	4770      	bx	lr
	...

08024fb8 <bar_init>:

static void bar_init(void)
{
 8024fb8:	b598      	push	{r3, r4, r7, lr}
 8024fba:	af00      	add	r7, sp, #0
#if LV_USE_BAR
    style_init_reset(&styles->bar_bg);
 8024fbc:	4b75      	ldr	r3, [pc, #468]	; (8025194 <bar_init+0x1dc>)
 8024fbe:	681b      	ldr	r3, [r3, #0]
 8024fc0:	3328      	adds	r3, #40	; 0x28
 8024fc2:	4618      	mov	r0, r3
 8024fc4:	f004 fc22 	bl	802980c <style_init_reset>
    lv_style_set_radius(&styles->bar_bg, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 8024fc8:	4b72      	ldr	r3, [pc, #456]	; (8025194 <bar_init+0x1dc>)
 8024fca:	681b      	ldr	r3, [r3, #0]
 8024fcc:	3328      	adds	r3, #40	; 0x28
 8024fce:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8024fd2:	2100      	movs	r1, #0
 8024fd4:	4618      	mov	r0, r3
 8024fd6:	f7fe f8cc 	bl	8023172 <lv_style_set_radius>
    lv_style_set_bg_opa(&styles->bar_bg, LV_STATE_DEFAULT, LV_OPA_COVER);
 8024fda:	4b6e      	ldr	r3, [pc, #440]	; (8025194 <bar_init+0x1dc>)
 8024fdc:	681b      	ldr	r3, [r3, #0]
 8024fde:	3328      	adds	r3, #40	; 0x28
 8024fe0:	22ff      	movs	r2, #255	; 0xff
 8024fe2:	2100      	movs	r1, #0
 8024fe4:	4618      	mov	r0, r3
 8024fe6:	f7fe fa12 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->bar_bg, LV_STATE_DEFAULT, COLOR_BG_SEC);
 8024fea:	4b6a      	ldr	r3, [pc, #424]	; (8025194 <bar_init+0x1dc>)
 8024fec:	681b      	ldr	r3, [r3, #0]
 8024fee:	f103 0428 	add.w	r4, r3, #40	; 0x28
 8024ff2:	4b69      	ldr	r3, [pc, #420]	; (8025198 <bar_init+0x1e0>)
 8024ff4:	6a1b      	ldr	r3, [r3, #32]
 8024ff6:	f003 0302 	and.w	r3, r3, #2
 8024ffa:	2b00      	cmp	r3, #0
 8024ffc:	d004      	beq.n	8025008 <bar_init+0x50>
 8024ffe:	4867      	ldr	r0, [pc, #412]	; (802519c <bar_init+0x1e4>)
 8025000:	f7fe f871 	bl	80230e6 <lv_color_hex>
 8025004:	4603      	mov	r3, r0
 8025006:	e003      	b.n	8025010 <bar_init+0x58>
 8025008:	4865      	ldr	r0, [pc, #404]	; (80251a0 <bar_init+0x1e8>)
 802500a:	f7fe f86c 	bl	80230e6 <lv_color_hex>
 802500e:	4603      	mov	r3, r0
 8025010:	461a      	mov	r2, r3
 8025012:	2100      	movs	r1, #0
 8025014:	4620      	mov	r0, r4
 8025016:	f7fe f9e4 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_value_color(&styles->bar_bg, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex(0x31404f) : LV_COLOR_WHITE);
 802501a:	4b5e      	ldr	r3, [pc, #376]	; (8025194 <bar_init+0x1dc>)
 802501c:	681b      	ldr	r3, [r3, #0]
 802501e:	f103 0428 	add.w	r4, r3, #40	; 0x28
 8025022:	4b5d      	ldr	r3, [pc, #372]	; (8025198 <bar_init+0x1e0>)
 8025024:	6a1b      	ldr	r3, [r3, #32]
 8025026:	f003 0302 	and.w	r3, r3, #2
 802502a:	2b00      	cmp	r3, #0
 802502c:	d004      	beq.n	8025038 <bar_init+0x80>
 802502e:	485d      	ldr	r0, [pc, #372]	; (80251a4 <bar_init+0x1ec>)
 8025030:	f7fe f859 	bl	80230e6 <lv_color_hex>
 8025034:	4603      	mov	r3, r0
 8025036:	e001      	b.n	802503c <bar_init+0x84>
 8025038:	4b5b      	ldr	r3, [pc, #364]	; (80251a8 <bar_init+0x1f0>)
 802503a:	881b      	ldrh	r3, [r3, #0]
 802503c:	461a      	mov	r2, r3
 802503e:	2100      	movs	r1, #0
 8025040:	4620      	mov	r0, r4
 8025042:	f7fe fb56 	bl	80236f2 <lv_style_set_value_color>
    lv_style_set_outline_color(&styles->bar_bg, LV_STATE_DEFAULT, theme.color_primary);
 8025046:	4b53      	ldr	r3, [pc, #332]	; (8025194 <bar_init+0x1dc>)
 8025048:	681b      	ldr	r3, [r3, #0]
 802504a:	3328      	adds	r3, #40	; 0x28
 802504c:	4a52      	ldr	r2, [pc, #328]	; (8025198 <bar_init+0x1e0>)
 802504e:	8992      	ldrh	r2, [r2, #12]
 8025050:	2100      	movs	r1, #0
 8025052:	4618      	mov	r0, r3
 8025054:	f7fe fa97 	bl	8023586 <lv_style_set_outline_color>
    lv_style_set_outline_color(&styles->bar_bg, LV_STATE_EDITED, theme.color_secondary);
 8025058:	4b4e      	ldr	r3, [pc, #312]	; (8025194 <bar_init+0x1dc>)
 802505a:	681b      	ldr	r3, [r3, #0]
 802505c:	3328      	adds	r3, #40	; 0x28
 802505e:	4a4e      	ldr	r2, [pc, #312]	; (8025198 <bar_init+0x1e0>)
 8025060:	89d2      	ldrh	r2, [r2, #14]
 8025062:	2104      	movs	r1, #4
 8025064:	4618      	mov	r0, r3
 8025066:	f7fe fa8e 	bl	8023586 <lv_style_set_outline_color>
    lv_style_set_outline_opa(&styles->bar_bg, LV_STATE_DEFAULT, LV_OPA_TRANSP);
 802506a:	4b4a      	ldr	r3, [pc, #296]	; (8025194 <bar_init+0x1dc>)
 802506c:	681b      	ldr	r3, [r3, #0]
 802506e:	3328      	adds	r3, #40	; 0x28
 8025070:	2200      	movs	r2, #0
 8025072:	2100      	movs	r1, #0
 8025074:	4618      	mov	r0, r3
 8025076:	f7fe fa9c 	bl	80235b2 <lv_style_set_outline_opa>
    lv_style_set_outline_opa(&styles->bar_bg, LV_STATE_FOCUSED, LV_OPA_50);
 802507a:	4b46      	ldr	r3, [pc, #280]	; (8025194 <bar_init+0x1dc>)
 802507c:	681b      	ldr	r3, [r3, #0]
 802507e:	3328      	adds	r3, #40	; 0x28
 8025080:	227f      	movs	r2, #127	; 0x7f
 8025082:	2102      	movs	r1, #2
 8025084:	4618      	mov	r0, r3
 8025086:	f7fe fa94 	bl	80235b2 <lv_style_set_outline_opa>
    lv_style_set_outline_width(&styles->bar_bg, LV_STATE_DEFAULT, OUTLINE_WIDTH);
 802508a:	4b42      	ldr	r3, [pc, #264]	; (8025194 <bar_init+0x1dc>)
 802508c:	681b      	ldr	r3, [r3, #0]
 802508e:	f103 0428 	add.w	r4, r3, #40	; 0x28
 8025092:	4b41      	ldr	r3, [pc, #260]	; (8025198 <bar_init+0x1e0>)
 8025094:	6a1b      	ldr	r3, [r3, #32]
 8025096:	f003 0320 	and.w	r3, r3, #32
 802509a:	2b00      	cmp	r3, #0
 802509c:	d114      	bne.n	80250c8 <bar_init+0x110>
 802509e:	2000      	movs	r0, #0
 80250a0:	f7f9 fd38 	bl	801eb14 <lv_disp_get_dpi>
 80250a4:	4603      	mov	r3, r0
 80250a6:	2b77      	cmp	r3, #119	; 0x77
 80250a8:	dd0c      	ble.n	80250c4 <bar_init+0x10c>
 80250aa:	2000      	movs	r0, #0
 80250ac:	f7f9 fd32 	bl	801eb14 <lv_disp_get_dpi>
 80250b0:	4603      	mov	r3, r0
 80250b2:	3328      	adds	r3, #40	; 0x28
 80250b4:	4a3d      	ldr	r2, [pc, #244]	; (80251ac <bar_init+0x1f4>)
 80250b6:	fb82 1203 	smull	r1, r2, r2, r3
 80250ba:	1152      	asrs	r2, r2, #5
 80250bc:	17db      	asrs	r3, r3, #31
 80250be:	1ad3      	subs	r3, r2, r3
 80250c0:	b21b      	sxth	r3, r3
 80250c2:	e002      	b.n	80250ca <bar_init+0x112>
 80250c4:	2301      	movs	r3, #1
 80250c6:	e000      	b.n	80250ca <bar_init+0x112>
 80250c8:	2300      	movs	r3, #0
 80250ca:	461a      	mov	r2, r3
 80250cc:	2100      	movs	r1, #0
 80250ce:	4620      	mov	r0, r4
 80250d0:	f7fe fa29 	bl	8023526 <lv_style_set_outline_width>
    lv_style_set_transition_time(&styles->bar_bg, LV_STATE_DEFAULT, TRANSITION_TIME);
 80250d4:	4b2f      	ldr	r3, [pc, #188]	; (8025194 <bar_init+0x1dc>)
 80250d6:	681b      	ldr	r3, [r3, #0]
 80250d8:	f103 0028 	add.w	r0, r3, #40	; 0x28
 80250dc:	4b2e      	ldr	r3, [pc, #184]	; (8025198 <bar_init+0x1e0>)
 80250de:	6a1b      	ldr	r3, [r3, #32]
 80250e0:	f003 0310 	and.w	r3, r3, #16
 80250e4:	2b00      	cmp	r3, #0
 80250e6:	d001      	beq.n	80250ec <bar_init+0x134>
 80250e8:	2300      	movs	r3, #0
 80250ea:	e000      	b.n	80250ee <bar_init+0x136>
 80250ec:	2396      	movs	r3, #150	; 0x96
 80250ee:	461a      	mov	r2, r3
 80250f0:	2100      	movs	r1, #0
 80250f2:	f7fe fc03 	bl	80238fc <lv_style_set_transition_time>
    lv_style_set_transition_prop_6(&styles->bar_bg, LV_STATE_DEFAULT, LV_STYLE_OUTLINE_OPA);
 80250f6:	4b27      	ldr	r3, [pc, #156]	; (8025194 <bar_init+0x1dc>)
 80250f8:	681b      	ldr	r3, [r3, #0]
 80250fa:	3328      	adds	r3, #40	; 0x28
 80250fc:	224c      	movs	r2, #76	; 0x4c
 80250fe:	2100      	movs	r1, #0
 8025100:	4618      	mov	r0, r3
 8025102:	f7fe fc73 	bl	80239ec <lv_style_set_transition_prop_6>

    style_init_reset(&styles->bar_indic);
 8025106:	4b23      	ldr	r3, [pc, #140]	; (8025194 <bar_init+0x1dc>)
 8025108:	681b      	ldr	r3, [r3, #0]
 802510a:	332c      	adds	r3, #44	; 0x2c
 802510c:	4618      	mov	r0, r3
 802510e:	f004 fb7d 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->bar_indic, LV_STATE_DEFAULT, LV_OPA_COVER);
 8025112:	4b20      	ldr	r3, [pc, #128]	; (8025194 <bar_init+0x1dc>)
 8025114:	681b      	ldr	r3, [r3, #0]
 8025116:	332c      	adds	r3, #44	; 0x2c
 8025118:	22ff      	movs	r2, #255	; 0xff
 802511a:	2100      	movs	r1, #0
 802511c:	4618      	mov	r0, r3
 802511e:	f7fe f976 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_radius(&styles->bar_indic, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 8025122:	4b1c      	ldr	r3, [pc, #112]	; (8025194 <bar_init+0x1dc>)
 8025124:	681b      	ldr	r3, [r3, #0]
 8025126:	332c      	adds	r3, #44	; 0x2c
 8025128:	f647 72ff 	movw	r2, #32767	; 0x7fff
 802512c:	2100      	movs	r1, #0
 802512e:	4618      	mov	r0, r3
 8025130:	f7fe f81f 	bl	8023172 <lv_style_set_radius>
    lv_style_set_bg_color(&styles->bar_indic, LV_STATE_DEFAULT, theme.color_primary);
 8025134:	4b17      	ldr	r3, [pc, #92]	; (8025194 <bar_init+0x1dc>)
 8025136:	681b      	ldr	r3, [r3, #0]
 8025138:	332c      	adds	r3, #44	; 0x2c
 802513a:	4a17      	ldr	r2, [pc, #92]	; (8025198 <bar_init+0x1e0>)
 802513c:	8992      	ldrh	r2, [r2, #12]
 802513e:	2100      	movs	r1, #0
 8025140:	4618      	mov	r0, r3
 8025142:	f7fe f94e 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->bar_indic, LV_STATE_DISABLED, lv_color_hex3(0x888));
 8025146:	4b13      	ldr	r3, [pc, #76]	; (8025194 <bar_init+0x1dc>)
 8025148:	681b      	ldr	r3, [r3, #0]
 802514a:	f103 042c 	add.w	r4, r3, #44	; 0x2c
 802514e:	f640 0088 	movw	r0, #2184	; 0x888
 8025152:	f7fd ffdc 	bl	802310e <lv_color_hex3>
 8025156:	4603      	mov	r3, r0
 8025158:	461a      	mov	r2, r3
 802515a:	2120      	movs	r1, #32
 802515c:	4620      	mov	r0, r4
 802515e:	f7fe f940 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_value_color(&styles->bar_indic, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex(0x41404f) : LV_COLOR_WHITE);
 8025162:	4b0c      	ldr	r3, [pc, #48]	; (8025194 <bar_init+0x1dc>)
 8025164:	681b      	ldr	r3, [r3, #0]
 8025166:	f103 042c 	add.w	r4, r3, #44	; 0x2c
 802516a:	4b0b      	ldr	r3, [pc, #44]	; (8025198 <bar_init+0x1e0>)
 802516c:	6a1b      	ldr	r3, [r3, #32]
 802516e:	f003 0302 	and.w	r3, r3, #2
 8025172:	2b00      	cmp	r3, #0
 8025174:	d004      	beq.n	8025180 <bar_init+0x1c8>
 8025176:	480e      	ldr	r0, [pc, #56]	; (80251b0 <bar_init+0x1f8>)
 8025178:	f7fd ffb5 	bl	80230e6 <lv_color_hex>
 802517c:	4603      	mov	r3, r0
 802517e:	e001      	b.n	8025184 <bar_init+0x1cc>
 8025180:	4b09      	ldr	r3, [pc, #36]	; (80251a8 <bar_init+0x1f0>)
 8025182:	881b      	ldrh	r3, [r3, #0]
 8025184:	461a      	mov	r2, r3
 8025186:	2100      	movs	r1, #0
 8025188:	4620      	mov	r0, r4
 802518a:	f7fe fab2 	bl	80236f2 <lv_style_set_value_color>
#endif
}
 802518e:	bf00      	nop
 8025190:	bd98      	pop	{r3, r4, r7, pc}
 8025192:	bf00      	nop
 8025194:	20012350 	.word	0x20012350
 8025198:	20012328 	.word	0x20012328
 802519c:	00d4d7d9 	.word	0x00d4d7d9
 80251a0:	0045494d 	.word	0x0045494d
 80251a4:	0031404f 	.word	0x0031404f
 80251a8:	0802e594 	.word	0x0802e594
 80251ac:	66666667 	.word	0x66666667
 80251b0:	0041404f 	.word	0x0041404f

080251b4 <img_init>:

static void img_init(void)
{
 80251b4:	b480      	push	{r7}
 80251b6:	af00      	add	r7, sp, #0
#if LV_USE_IMG != 0

#endif
}
 80251b8:	bf00      	nop
 80251ba:	46bd      	mov	sp, r7
 80251bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80251c0:	4770      	bx	lr

080251c2 <line_init>:

static void line_init(void)
{
 80251c2:	b480      	push	{r7}
 80251c4:	af00      	add	r7, sp, #0
#if LV_USE_LINE != 0

#endif
}
 80251c6:	bf00      	nop
 80251c8:	46bd      	mov	sp, r7
 80251ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80251ce:	4770      	bx	lr

080251d0 <led_init>:

static void led_init(void)
{
 80251d0:	b598      	push	{r3, r4, r7, lr}
 80251d2:	af00      	add	r7, sp, #0
#if LV_USE_LED != 0
    style_init_reset(&styles->led);
 80251d4:	4b49      	ldr	r3, [pc, #292]	; (80252fc <led_init+0x12c>)
 80251d6:	681b      	ldr	r3, [r3, #0]
 80251d8:	3370      	adds	r3, #112	; 0x70
 80251da:	4618      	mov	r0, r3
 80251dc:	f004 fb16 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->led, LV_STATE_DEFAULT, LV_OPA_COVER);
 80251e0:	4b46      	ldr	r3, [pc, #280]	; (80252fc <led_init+0x12c>)
 80251e2:	681b      	ldr	r3, [r3, #0]
 80251e4:	3370      	adds	r3, #112	; 0x70
 80251e6:	22ff      	movs	r2, #255	; 0xff
 80251e8:	2100      	movs	r1, #0
 80251ea:	4618      	mov	r0, r3
 80251ec:	f7fe f90f 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->led, LV_STATE_DEFAULT, theme.color_primary);
 80251f0:	4b42      	ldr	r3, [pc, #264]	; (80252fc <led_init+0x12c>)
 80251f2:	681b      	ldr	r3, [r3, #0]
 80251f4:	3370      	adds	r3, #112	; 0x70
 80251f6:	4a42      	ldr	r2, [pc, #264]	; (8025300 <led_init+0x130>)
 80251f8:	8992      	ldrh	r2, [r2, #12]
 80251fa:	2100      	movs	r1, #0
 80251fc:	4618      	mov	r0, r3
 80251fe:	f7fe f8f0 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_border_width(&styles->led, LV_STATE_DEFAULT, 2);
 8025202:	4b3e      	ldr	r3, [pc, #248]	; (80252fc <led_init+0x12c>)
 8025204:	681b      	ldr	r3, [r3, #0]
 8025206:	3370      	adds	r3, #112	; 0x70
 8025208:	2202      	movs	r2, #2
 802520a:	2100      	movs	r1, #0
 802520c:	4618      	mov	r0, r3
 802520e:	f7fe f915 	bl	802343c <lv_style_set_border_width>
    lv_style_set_border_opa(&styles->led, LV_STATE_DEFAULT, LV_OPA_50);
 8025212:	4b3a      	ldr	r3, [pc, #232]	; (80252fc <led_init+0x12c>)
 8025214:	681b      	ldr	r3, [r3, #0]
 8025216:	3370      	adds	r3, #112	; 0x70
 8025218:	227f      	movs	r2, #127	; 0x7f
 802521a:	2100      	movs	r1, #0
 802521c:	4618      	mov	r0, r3
 802521e:	f7fe f96b 	bl	80234f8 <lv_style_set_border_opa>
    lv_style_set_border_color(&styles->led, LV_STATE_DEFAULT, lv_color_lighten(theme.color_primary, LV_OPA_30));
 8025222:	4b36      	ldr	r3, [pc, #216]	; (80252fc <led_init+0x12c>)
 8025224:	681b      	ldr	r3, [r3, #0]
 8025226:	f103 0470 	add.w	r4, r3, #112	; 0x70
 802522a:	4b35      	ldr	r3, [pc, #212]	; (8025300 <led_init+0x130>)
 802522c:	214c      	movs	r1, #76	; 0x4c
 802522e:	8998      	ldrh	r0, [r3, #12]
 8025230:	f7fa ff34 	bl	802009c <lv_color_lighten>
 8025234:	4603      	mov	r3, r0
 8025236:	461a      	mov	r2, r3
 8025238:	2100      	movs	r1, #0
 802523a:	4620      	mov	r0, r4
 802523c:	f7fe f946 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_radius(&styles->led, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 8025240:	4b2e      	ldr	r3, [pc, #184]	; (80252fc <led_init+0x12c>)
 8025242:	681b      	ldr	r3, [r3, #0]
 8025244:	3370      	adds	r3, #112	; 0x70
 8025246:	f647 72ff 	movw	r2, #32767	; 0x7fff
 802524a:	2100      	movs	r1, #0
 802524c:	4618      	mov	r0, r3
 802524e:	f7fd ff90 	bl	8023172 <lv_style_set_radius>
    lv_style_set_shadow_width(&styles->led, LV_STATE_DEFAULT, LV_DPX(15));
 8025252:	4b2a      	ldr	r3, [pc, #168]	; (80252fc <led_init+0x12c>)
 8025254:	681b      	ldr	r3, [r3, #0]
 8025256:	f103 0470 	add.w	r4, r3, #112	; 0x70
 802525a:	2000      	movs	r0, #0
 802525c:	f7f9 fc5a 	bl	801eb14 <lv_disp_get_dpi>
 8025260:	4603      	mov	r3, r0
 8025262:	461a      	mov	r2, r3
 8025264:	4613      	mov	r3, r2
 8025266:	011b      	lsls	r3, r3, #4
 8025268:	1a9b      	subs	r3, r3, r2
 802526a:	2bef      	cmp	r3, #239	; 0xef
 802526c:	dd10      	ble.n	8025290 <led_init+0xc0>
 802526e:	2000      	movs	r0, #0
 8025270:	f7f9 fc50 	bl	801eb14 <lv_disp_get_dpi>
 8025274:	4603      	mov	r3, r0
 8025276:	461a      	mov	r2, r3
 8025278:	4613      	mov	r3, r2
 802527a:	011b      	lsls	r3, r3, #4
 802527c:	1a9b      	subs	r3, r3, r2
 802527e:	3350      	adds	r3, #80	; 0x50
 8025280:	4a20      	ldr	r2, [pc, #128]	; (8025304 <led_init+0x134>)
 8025282:	fb82 1203 	smull	r1, r2, r2, r3
 8025286:	1192      	asrs	r2, r2, #6
 8025288:	17db      	asrs	r3, r3, #31
 802528a:	1ad3      	subs	r3, r2, r3
 802528c:	b21b      	sxth	r3, r3
 802528e:	e000      	b.n	8025292 <led_init+0xc2>
 8025290:	2301      	movs	r3, #1
 8025292:	461a      	mov	r2, r3
 8025294:	2100      	movs	r1, #0
 8025296:	4620      	mov	r0, r4
 8025298:	f7fe f9a2 	bl	80235e0 <lv_style_set_shadow_width>
    lv_style_set_shadow_color(&styles->led, LV_STATE_DEFAULT, theme.color_primary);
 802529c:	4b17      	ldr	r3, [pc, #92]	; (80252fc <led_init+0x12c>)
 802529e:	681b      	ldr	r3, [r3, #0]
 80252a0:	3370      	adds	r3, #112	; 0x70
 80252a2:	4a17      	ldr	r2, [pc, #92]	; (8025300 <led_init+0x130>)
 80252a4:	8992      	ldrh	r2, [r2, #12]
 80252a6:	2100      	movs	r1, #0
 80252a8:	4618      	mov	r0, r3
 80252aa:	f7fe f9c9 	bl	8023640 <lv_style_set_shadow_color>
    lv_style_set_shadow_spread(&styles->led, LV_STATE_DEFAULT, LV_DPX(5));
 80252ae:	4b13      	ldr	r3, [pc, #76]	; (80252fc <led_init+0x12c>)
 80252b0:	681b      	ldr	r3, [r3, #0]
 80252b2:	f103 0470 	add.w	r4, r3, #112	; 0x70
 80252b6:	2000      	movs	r0, #0
 80252b8:	f7f9 fc2c 	bl	801eb14 <lv_disp_get_dpi>
 80252bc:	4603      	mov	r3, r0
 80252be:	461a      	mov	r2, r3
 80252c0:	4613      	mov	r3, r2
 80252c2:	009b      	lsls	r3, r3, #2
 80252c4:	4413      	add	r3, r2
 80252c6:	2bef      	cmp	r3, #239	; 0xef
 80252c8:	dd10      	ble.n	80252ec <led_init+0x11c>
 80252ca:	2000      	movs	r0, #0
 80252cc:	f7f9 fc22 	bl	801eb14 <lv_disp_get_dpi>
 80252d0:	4603      	mov	r3, r0
 80252d2:	461a      	mov	r2, r3
 80252d4:	4613      	mov	r3, r2
 80252d6:	009b      	lsls	r3, r3, #2
 80252d8:	4413      	add	r3, r2
 80252da:	3350      	adds	r3, #80	; 0x50
 80252dc:	4a09      	ldr	r2, [pc, #36]	; (8025304 <led_init+0x134>)
 80252de:	fb82 1203 	smull	r1, r2, r2, r3
 80252e2:	1192      	asrs	r2, r2, #6
 80252e4:	17db      	asrs	r3, r3, #31
 80252e6:	1ad3      	subs	r3, r2, r3
 80252e8:	b21b      	sxth	r3, r3
 80252ea:	e000      	b.n	80252ee <led_init+0x11e>
 80252ec:	2301      	movs	r3, #1
 80252ee:	461a      	mov	r2, r3
 80252f0:	2100      	movs	r1, #0
 80252f2:	4620      	mov	r0, r4
 80252f4:	f7fe f98c 	bl	8023610 <lv_style_set_shadow_spread>
#endif
}
 80252f8:	bf00      	nop
 80252fa:	bd98      	pop	{r3, r4, r7, pc}
 80252fc:	20012350 	.word	0x20012350
 8025300:	20012328 	.word	0x20012328
 8025304:	66666667 	.word	0x66666667

08025308 <slider_init>:

static void slider_init(void)
{
 8025308:	b598      	push	{r3, r4, r7, lr}
 802530a:	af00      	add	r7, sp, #0
#if LV_USE_SLIDER != 0
    style_init_reset(&styles->slider_knob);
 802530c:	4bbb      	ldr	r3, [pc, #748]	; (80255fc <slider_init+0x2f4>)
 802530e:	681b      	ldr	r3, [r3, #0]
 8025310:	3394      	adds	r3, #148	; 0x94
 8025312:	4618      	mov	r0, r3
 8025314:	f004 fa7a 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->slider_knob, LV_STATE_DEFAULT, LV_OPA_COVER);
 8025318:	4bb8      	ldr	r3, [pc, #736]	; (80255fc <slider_init+0x2f4>)
 802531a:	681b      	ldr	r3, [r3, #0]
 802531c:	3394      	adds	r3, #148	; 0x94
 802531e:	22ff      	movs	r2, #255	; 0xff
 8025320:	2100      	movs	r1, #0
 8025322:	4618      	mov	r0, r3
 8025324:	f7fe f873 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->slider_knob, LV_STATE_DEFAULT, IS_LIGHT ? theme.color_primary : LV_COLOR_WHITE);
 8025328:	4bb4      	ldr	r3, [pc, #720]	; (80255fc <slider_init+0x2f4>)
 802532a:	681b      	ldr	r3, [r3, #0]
 802532c:	f103 0094 	add.w	r0, r3, #148	; 0x94
 8025330:	4bb3      	ldr	r3, [pc, #716]	; (8025600 <slider_init+0x2f8>)
 8025332:	6a1b      	ldr	r3, [r3, #32]
 8025334:	f003 0302 	and.w	r3, r3, #2
 8025338:	2b00      	cmp	r3, #0
 802533a:	d002      	beq.n	8025342 <slider_init+0x3a>
 802533c:	4bb0      	ldr	r3, [pc, #704]	; (8025600 <slider_init+0x2f8>)
 802533e:	899b      	ldrh	r3, [r3, #12]
 8025340:	e001      	b.n	8025346 <slider_init+0x3e>
 8025342:	4bb0      	ldr	r3, [pc, #704]	; (8025604 <slider_init+0x2fc>)
 8025344:	881b      	ldrh	r3, [r3, #0]
 8025346:	461a      	mov	r2, r3
 8025348:	2100      	movs	r1, #0
 802534a:	f7fe f84a 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_value_color(&styles->slider_knob, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex(0x31404f) : LV_COLOR_WHITE);
 802534e:	4bab      	ldr	r3, [pc, #684]	; (80255fc <slider_init+0x2f4>)
 8025350:	681b      	ldr	r3, [r3, #0]
 8025352:	f103 0494 	add.w	r4, r3, #148	; 0x94
 8025356:	4baa      	ldr	r3, [pc, #680]	; (8025600 <slider_init+0x2f8>)
 8025358:	6a1b      	ldr	r3, [r3, #32]
 802535a:	f003 0302 	and.w	r3, r3, #2
 802535e:	2b00      	cmp	r3, #0
 8025360:	d004      	beq.n	802536c <slider_init+0x64>
 8025362:	48a9      	ldr	r0, [pc, #676]	; (8025608 <slider_init+0x300>)
 8025364:	f7fd febf 	bl	80230e6 <lv_color_hex>
 8025368:	4603      	mov	r3, r0
 802536a:	e001      	b.n	8025370 <slider_init+0x68>
 802536c:	4ba5      	ldr	r3, [pc, #660]	; (8025604 <slider_init+0x2fc>)
 802536e:	881b      	ldrh	r3, [r3, #0]
 8025370:	461a      	mov	r2, r3
 8025372:	2100      	movs	r1, #0
 8025374:	4620      	mov	r0, r4
 8025376:	f7fe f9bc 	bl	80236f2 <lv_style_set_value_color>
    lv_style_set_radius(&styles->slider_knob, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 802537a:	4ba0      	ldr	r3, [pc, #640]	; (80255fc <slider_init+0x2f4>)
 802537c:	681b      	ldr	r3, [r3, #0]
 802537e:	3394      	adds	r3, #148	; 0x94
 8025380:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8025384:	2100      	movs	r1, #0
 8025386:	4618      	mov	r0, r3
 8025388:	f7fd fef3 	bl	8023172 <lv_style_set_radius>
    lv_style_set_pad_left(&styles->slider_knob, LV_STATE_DEFAULT, LV_DPX(7));
 802538c:	4b9b      	ldr	r3, [pc, #620]	; (80255fc <slider_init+0x2f4>)
 802538e:	681b      	ldr	r3, [r3, #0]
 8025390:	f103 0494 	add.w	r4, r3, #148	; 0x94
 8025394:	2000      	movs	r0, #0
 8025396:	f7f9 fbbd 	bl	801eb14 <lv_disp_get_dpi>
 802539a:	4603      	mov	r3, r0
 802539c:	461a      	mov	r2, r3
 802539e:	4613      	mov	r3, r2
 80253a0:	00db      	lsls	r3, r3, #3
 80253a2:	1a9b      	subs	r3, r3, r2
 80253a4:	2bef      	cmp	r3, #239	; 0xef
 80253a6:	dd10      	ble.n	80253ca <slider_init+0xc2>
 80253a8:	2000      	movs	r0, #0
 80253aa:	f7f9 fbb3 	bl	801eb14 <lv_disp_get_dpi>
 80253ae:	4603      	mov	r3, r0
 80253b0:	461a      	mov	r2, r3
 80253b2:	4613      	mov	r3, r2
 80253b4:	00db      	lsls	r3, r3, #3
 80253b6:	1a9b      	subs	r3, r3, r2
 80253b8:	3350      	adds	r3, #80	; 0x50
 80253ba:	4a94      	ldr	r2, [pc, #592]	; (802560c <slider_init+0x304>)
 80253bc:	fb82 1203 	smull	r1, r2, r2, r3
 80253c0:	1192      	asrs	r2, r2, #6
 80253c2:	17db      	asrs	r3, r3, #31
 80253c4:	1ad3      	subs	r3, r2, r3
 80253c6:	b21b      	sxth	r3, r3
 80253c8:	e000      	b.n	80253cc <slider_init+0xc4>
 80253ca:	2301      	movs	r3, #1
 80253cc:	461a      	mov	r2, r3
 80253ce:	2100      	movs	r1, #0
 80253d0:	4620      	mov	r0, r4
 80253d2:	f7fd ff5e 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->slider_knob, LV_STATE_DEFAULT, LV_DPX(7));
 80253d6:	4b89      	ldr	r3, [pc, #548]	; (80255fc <slider_init+0x2f4>)
 80253d8:	681b      	ldr	r3, [r3, #0]
 80253da:	f103 0494 	add.w	r4, r3, #148	; 0x94
 80253de:	2000      	movs	r0, #0
 80253e0:	f7f9 fb98 	bl	801eb14 <lv_disp_get_dpi>
 80253e4:	4603      	mov	r3, r0
 80253e6:	461a      	mov	r2, r3
 80253e8:	4613      	mov	r3, r2
 80253ea:	00db      	lsls	r3, r3, #3
 80253ec:	1a9b      	subs	r3, r3, r2
 80253ee:	2bef      	cmp	r3, #239	; 0xef
 80253f0:	dd10      	ble.n	8025414 <slider_init+0x10c>
 80253f2:	2000      	movs	r0, #0
 80253f4:	f7f9 fb8e 	bl	801eb14 <lv_disp_get_dpi>
 80253f8:	4603      	mov	r3, r0
 80253fa:	461a      	mov	r2, r3
 80253fc:	4613      	mov	r3, r2
 80253fe:	00db      	lsls	r3, r3, #3
 8025400:	1a9b      	subs	r3, r3, r2
 8025402:	3350      	adds	r3, #80	; 0x50
 8025404:	4a81      	ldr	r2, [pc, #516]	; (802560c <slider_init+0x304>)
 8025406:	fb82 1203 	smull	r1, r2, r2, r3
 802540a:	1192      	asrs	r2, r2, #6
 802540c:	17db      	asrs	r3, r3, #31
 802540e:	1ad3      	subs	r3, r2, r3
 8025410:	b21b      	sxth	r3, r3
 8025412:	e000      	b.n	8025416 <slider_init+0x10e>
 8025414:	2301      	movs	r3, #1
 8025416:	461a      	mov	r2, r3
 8025418:	2100      	movs	r1, #0
 802541a:	4620      	mov	r0, r4
 802541c:	f7fd ff51 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->slider_knob, LV_STATE_DEFAULT, LV_DPX(7));
 8025420:	4b76      	ldr	r3, [pc, #472]	; (80255fc <slider_init+0x2f4>)
 8025422:	681b      	ldr	r3, [r3, #0]
 8025424:	f103 0494 	add.w	r4, r3, #148	; 0x94
 8025428:	2000      	movs	r0, #0
 802542a:	f7f9 fb73 	bl	801eb14 <lv_disp_get_dpi>
 802542e:	4603      	mov	r3, r0
 8025430:	461a      	mov	r2, r3
 8025432:	4613      	mov	r3, r2
 8025434:	00db      	lsls	r3, r3, #3
 8025436:	1a9b      	subs	r3, r3, r2
 8025438:	2bef      	cmp	r3, #239	; 0xef
 802543a:	dd10      	ble.n	802545e <slider_init+0x156>
 802543c:	2000      	movs	r0, #0
 802543e:	f7f9 fb69 	bl	801eb14 <lv_disp_get_dpi>
 8025442:	4603      	mov	r3, r0
 8025444:	461a      	mov	r2, r3
 8025446:	4613      	mov	r3, r2
 8025448:	00db      	lsls	r3, r3, #3
 802544a:	1a9b      	subs	r3, r3, r2
 802544c:	3350      	adds	r3, #80	; 0x50
 802544e:	4a6f      	ldr	r2, [pc, #444]	; (802560c <slider_init+0x304>)
 8025450:	fb82 1203 	smull	r1, r2, r2, r3
 8025454:	1192      	asrs	r2, r2, #6
 8025456:	17db      	asrs	r3, r3, #31
 8025458:	1ad3      	subs	r3, r2, r3
 802545a:	b21b      	sxth	r3, r3
 802545c:	e000      	b.n	8025460 <slider_init+0x158>
 802545e:	2301      	movs	r3, #1
 8025460:	461a      	mov	r2, r3
 8025462:	2100      	movs	r1, #0
 8025464:	4620      	mov	r0, r4
 8025466:	f7fd fee4 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->slider_knob, LV_STATE_DEFAULT, LV_DPX(7));
 802546a:	4b64      	ldr	r3, [pc, #400]	; (80255fc <slider_init+0x2f4>)
 802546c:	681b      	ldr	r3, [r3, #0]
 802546e:	f103 0494 	add.w	r4, r3, #148	; 0x94
 8025472:	2000      	movs	r0, #0
 8025474:	f7f9 fb4e 	bl	801eb14 <lv_disp_get_dpi>
 8025478:	4603      	mov	r3, r0
 802547a:	461a      	mov	r2, r3
 802547c:	4613      	mov	r3, r2
 802547e:	00db      	lsls	r3, r3, #3
 8025480:	1a9b      	subs	r3, r3, r2
 8025482:	2bef      	cmp	r3, #239	; 0xef
 8025484:	dd10      	ble.n	80254a8 <slider_init+0x1a0>
 8025486:	2000      	movs	r0, #0
 8025488:	f7f9 fb44 	bl	801eb14 <lv_disp_get_dpi>
 802548c:	4603      	mov	r3, r0
 802548e:	461a      	mov	r2, r3
 8025490:	4613      	mov	r3, r2
 8025492:	00db      	lsls	r3, r3, #3
 8025494:	1a9b      	subs	r3, r3, r2
 8025496:	3350      	adds	r3, #80	; 0x50
 8025498:	4a5c      	ldr	r2, [pc, #368]	; (802560c <slider_init+0x304>)
 802549a:	fb82 1203 	smull	r1, r2, r2, r3
 802549e:	1192      	asrs	r2, r2, #6
 80254a0:	17db      	asrs	r3, r3, #31
 80254a2:	1ad3      	subs	r3, r2, r3
 80254a4:	b21b      	sxth	r3, r3
 80254a6:	e000      	b.n	80254aa <slider_init+0x1a2>
 80254a8:	2301      	movs	r3, #1
 80254aa:	461a      	mov	r2, r3
 80254ac:	2100      	movs	r1, #0
 80254ae:	4620      	mov	r0, r4
 80254b0:	f7fd fed7 	bl	8023262 <lv_style_set_pad_bottom>

    style_init_reset(&styles->slider_bg);
 80254b4:	4b51      	ldr	r3, [pc, #324]	; (80255fc <slider_init+0x2f4>)
 80254b6:	681b      	ldr	r3, [r3, #0]
 80254b8:	3398      	adds	r3, #152	; 0x98
 80254ba:	4618      	mov	r0, r3
 80254bc:	f004 f9a6 	bl	802980c <style_init_reset>
    lv_style_set_margin_left(&styles->slider_bg, LV_STATE_DEFAULT, LV_DPX(10));
 80254c0:	4b4e      	ldr	r3, [pc, #312]	; (80255fc <slider_init+0x2f4>)
 80254c2:	681b      	ldr	r3, [r3, #0]
 80254c4:	f103 0498 	add.w	r4, r3, #152	; 0x98
 80254c8:	2000      	movs	r0, #0
 80254ca:	f7f9 fb23 	bl	801eb14 <lv_disp_get_dpi>
 80254ce:	4603      	mov	r3, r0
 80254d0:	461a      	mov	r2, r3
 80254d2:	4613      	mov	r3, r2
 80254d4:	009b      	lsls	r3, r3, #2
 80254d6:	4413      	add	r3, r2
 80254d8:	005b      	lsls	r3, r3, #1
 80254da:	2bef      	cmp	r3, #239	; 0xef
 80254dc:	dd11      	ble.n	8025502 <slider_init+0x1fa>
 80254de:	2000      	movs	r0, #0
 80254e0:	f7f9 fb18 	bl	801eb14 <lv_disp_get_dpi>
 80254e4:	4603      	mov	r3, r0
 80254e6:	461a      	mov	r2, r3
 80254e8:	4613      	mov	r3, r2
 80254ea:	009b      	lsls	r3, r3, #2
 80254ec:	4413      	add	r3, r2
 80254ee:	005b      	lsls	r3, r3, #1
 80254f0:	3350      	adds	r3, #80	; 0x50
 80254f2:	4a46      	ldr	r2, [pc, #280]	; (802560c <slider_init+0x304>)
 80254f4:	fb82 1203 	smull	r1, r2, r2, r3
 80254f8:	1192      	asrs	r2, r2, #6
 80254fa:	17db      	asrs	r3, r3, #31
 80254fc:	1ad3      	subs	r3, r2, r3
 80254fe:	b21b      	sxth	r3, r3
 8025500:	e000      	b.n	8025504 <slider_init+0x1fc>
 8025502:	2301      	movs	r3, #1
 8025504:	461a      	mov	r2, r3
 8025506:	2100      	movs	r1, #0
 8025508:	4620      	mov	r0, r4
 802550a:	f7fd ff3a 	bl	8023382 <lv_style_set_margin_left>
    lv_style_set_margin_right(&styles->slider_bg, LV_STATE_DEFAULT, LV_DPX(10));
 802550e:	4b3b      	ldr	r3, [pc, #236]	; (80255fc <slider_init+0x2f4>)
 8025510:	681b      	ldr	r3, [r3, #0]
 8025512:	f103 0498 	add.w	r4, r3, #152	; 0x98
 8025516:	2000      	movs	r0, #0
 8025518:	f7f9 fafc 	bl	801eb14 <lv_disp_get_dpi>
 802551c:	4603      	mov	r3, r0
 802551e:	461a      	mov	r2, r3
 8025520:	4613      	mov	r3, r2
 8025522:	009b      	lsls	r3, r3, #2
 8025524:	4413      	add	r3, r2
 8025526:	005b      	lsls	r3, r3, #1
 8025528:	2bef      	cmp	r3, #239	; 0xef
 802552a:	dd11      	ble.n	8025550 <slider_init+0x248>
 802552c:	2000      	movs	r0, #0
 802552e:	f7f9 faf1 	bl	801eb14 <lv_disp_get_dpi>
 8025532:	4603      	mov	r3, r0
 8025534:	461a      	mov	r2, r3
 8025536:	4613      	mov	r3, r2
 8025538:	009b      	lsls	r3, r3, #2
 802553a:	4413      	add	r3, r2
 802553c:	005b      	lsls	r3, r3, #1
 802553e:	3350      	adds	r3, #80	; 0x50
 8025540:	4a32      	ldr	r2, [pc, #200]	; (802560c <slider_init+0x304>)
 8025542:	fb82 1203 	smull	r1, r2, r2, r3
 8025546:	1192      	asrs	r2, r2, #6
 8025548:	17db      	asrs	r3, r3, #31
 802554a:	1ad3      	subs	r3, r2, r3
 802554c:	b21b      	sxth	r3, r3
 802554e:	e000      	b.n	8025552 <slider_init+0x24a>
 8025550:	2301      	movs	r3, #1
 8025552:	461a      	mov	r2, r3
 8025554:	2100      	movs	r1, #0
 8025556:	4620      	mov	r0, r4
 8025558:	f7fd ff2b 	bl	80233b2 <lv_style_set_margin_right>
    lv_style_set_margin_top(&styles->slider_bg, LV_STATE_DEFAULT, LV_DPX(10));
 802555c:	4b27      	ldr	r3, [pc, #156]	; (80255fc <slider_init+0x2f4>)
 802555e:	681b      	ldr	r3, [r3, #0]
 8025560:	f103 0498 	add.w	r4, r3, #152	; 0x98
 8025564:	2000      	movs	r0, #0
 8025566:	f7f9 fad5 	bl	801eb14 <lv_disp_get_dpi>
 802556a:	4603      	mov	r3, r0
 802556c:	461a      	mov	r2, r3
 802556e:	4613      	mov	r3, r2
 8025570:	009b      	lsls	r3, r3, #2
 8025572:	4413      	add	r3, r2
 8025574:	005b      	lsls	r3, r3, #1
 8025576:	2bef      	cmp	r3, #239	; 0xef
 8025578:	dd11      	ble.n	802559e <slider_init+0x296>
 802557a:	2000      	movs	r0, #0
 802557c:	f7f9 faca 	bl	801eb14 <lv_disp_get_dpi>
 8025580:	4603      	mov	r3, r0
 8025582:	461a      	mov	r2, r3
 8025584:	4613      	mov	r3, r2
 8025586:	009b      	lsls	r3, r3, #2
 8025588:	4413      	add	r3, r2
 802558a:	005b      	lsls	r3, r3, #1
 802558c:	3350      	adds	r3, #80	; 0x50
 802558e:	4a1f      	ldr	r2, [pc, #124]	; (802560c <slider_init+0x304>)
 8025590:	fb82 1203 	smull	r1, r2, r2, r3
 8025594:	1192      	asrs	r2, r2, #6
 8025596:	17db      	asrs	r3, r3, #31
 8025598:	1ad3      	subs	r3, r2, r3
 802559a:	b21b      	sxth	r3, r3
 802559c:	e000      	b.n	80255a0 <slider_init+0x298>
 802559e:	2301      	movs	r3, #1
 80255a0:	461a      	mov	r2, r3
 80255a2:	2100      	movs	r1, #0
 80255a4:	4620      	mov	r0, r4
 80255a6:	f7fd febc 	bl	8023322 <lv_style_set_margin_top>
    lv_style_set_margin_bottom(&styles->slider_bg, LV_STATE_DEFAULT, LV_DPX(10));
 80255aa:	4b14      	ldr	r3, [pc, #80]	; (80255fc <slider_init+0x2f4>)
 80255ac:	681b      	ldr	r3, [r3, #0]
 80255ae:	f103 0498 	add.w	r4, r3, #152	; 0x98
 80255b2:	2000      	movs	r0, #0
 80255b4:	f7f9 faae 	bl	801eb14 <lv_disp_get_dpi>
 80255b8:	4603      	mov	r3, r0
 80255ba:	461a      	mov	r2, r3
 80255bc:	4613      	mov	r3, r2
 80255be:	009b      	lsls	r3, r3, #2
 80255c0:	4413      	add	r3, r2
 80255c2:	005b      	lsls	r3, r3, #1
 80255c4:	2bef      	cmp	r3, #239	; 0xef
 80255c6:	dd11      	ble.n	80255ec <slider_init+0x2e4>
 80255c8:	2000      	movs	r0, #0
 80255ca:	f7f9 faa3 	bl	801eb14 <lv_disp_get_dpi>
 80255ce:	4603      	mov	r3, r0
 80255d0:	461a      	mov	r2, r3
 80255d2:	4613      	mov	r3, r2
 80255d4:	009b      	lsls	r3, r3, #2
 80255d6:	4413      	add	r3, r2
 80255d8:	005b      	lsls	r3, r3, #1
 80255da:	3350      	adds	r3, #80	; 0x50
 80255dc:	4a0b      	ldr	r2, [pc, #44]	; (802560c <slider_init+0x304>)
 80255de:	fb82 1203 	smull	r1, r2, r2, r3
 80255e2:	1192      	asrs	r2, r2, #6
 80255e4:	17db      	asrs	r3, r3, #31
 80255e6:	1ad3      	subs	r3, r2, r3
 80255e8:	b21b      	sxth	r3, r3
 80255ea:	e000      	b.n	80255ee <slider_init+0x2e6>
 80255ec:	2301      	movs	r3, #1
 80255ee:	461a      	mov	r2, r3
 80255f0:	2100      	movs	r1, #0
 80255f2:	4620      	mov	r0, r4
 80255f4:	f7fd fead 	bl	8023352 <lv_style_set_margin_bottom>

#endif
}
 80255f8:	bf00      	nop
 80255fa:	bd98      	pop	{r3, r4, r7, pc}
 80255fc:	20012350 	.word	0x20012350
 8025600:	20012328 	.word	0x20012328
 8025604:	0802e594 	.word	0x0802e594
 8025608:	0031404f 	.word	0x0031404f
 802560c:	66666667 	.word	0x66666667

08025610 <switch_init>:

static void switch_init(void)
{
 8025610:	b598      	push	{r3, r4, r7, lr}
 8025612:	af00      	add	r7, sp, #0
#if LV_USE_SWITCH != 0
    style_init_reset(&styles->sw_knob);
 8025614:	4b4c      	ldr	r3, [pc, #304]	; (8025748 <switch_init+0x138>)
 8025616:	681b      	ldr	r3, [r3, #0]
 8025618:	33a0      	adds	r3, #160	; 0xa0
 802561a:	4618      	mov	r0, r3
 802561c:	f004 f8f6 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->sw_knob, LV_STATE_DEFAULT, LV_OPA_COVER);
 8025620:	4b49      	ldr	r3, [pc, #292]	; (8025748 <switch_init+0x138>)
 8025622:	681b      	ldr	r3, [r3, #0]
 8025624:	33a0      	adds	r3, #160	; 0xa0
 8025626:	22ff      	movs	r2, #255	; 0xff
 8025628:	2100      	movs	r1, #0
 802562a:	4618      	mov	r0, r3
 802562c:	f7fd feef 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->sw_knob, LV_STATE_DEFAULT, LV_COLOR_WHITE);
 8025630:	4b45      	ldr	r3, [pc, #276]	; (8025748 <switch_init+0x138>)
 8025632:	681b      	ldr	r3, [r3, #0]
 8025634:	33a0      	adds	r3, #160	; 0xa0
 8025636:	4a45      	ldr	r2, [pc, #276]	; (802574c <switch_init+0x13c>)
 8025638:	8812      	ldrh	r2, [r2, #0]
 802563a:	2100      	movs	r1, #0
 802563c:	4618      	mov	r0, r3
 802563e:	f7fd fed0 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_radius(&styles->sw_knob, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 8025642:	4b41      	ldr	r3, [pc, #260]	; (8025748 <switch_init+0x138>)
 8025644:	681b      	ldr	r3, [r3, #0]
 8025646:	33a0      	adds	r3, #160	; 0xa0
 8025648:	f647 72ff 	movw	r2, #32767	; 0x7fff
 802564c:	2100      	movs	r1, #0
 802564e:	4618      	mov	r0, r3
 8025650:	f7fd fd8f 	bl	8023172 <lv_style_set_radius>
    lv_style_set_pad_top(&styles->sw_knob, LV_STATE_DEFAULT,    - LV_DPX(4));
 8025654:	4b3c      	ldr	r3, [pc, #240]	; (8025748 <switch_init+0x138>)
 8025656:	681b      	ldr	r3, [r3, #0]
 8025658:	f103 04a0 	add.w	r4, r3, #160	; 0xa0
 802565c:	2000      	movs	r0, #0
 802565e:	f7f9 fa59 	bl	801eb14 <lv_disp_get_dpi>
 8025662:	4603      	mov	r3, r0
 8025664:	2b3b      	cmp	r3, #59	; 0x3b
 8025666:	dd0c      	ble.n	8025682 <switch_init+0x72>
 8025668:	2000      	movs	r0, #0
 802566a:	f7f9 fa53 	bl	801eb14 <lv_disp_get_dpi>
 802566e:	4603      	mov	r3, r0
 8025670:	3314      	adds	r3, #20
 8025672:	4a37      	ldr	r2, [pc, #220]	; (8025750 <switch_init+0x140>)
 8025674:	fb82 1203 	smull	r1, r2, r2, r3
 8025678:	1112      	asrs	r2, r2, #4
 802567a:	17db      	asrs	r3, r3, #31
 802567c:	1a9b      	subs	r3, r3, r2
 802567e:	b21b      	sxth	r3, r3
 8025680:	e001      	b.n	8025686 <switch_init+0x76>
 8025682:	f04f 33ff 	mov.w	r3, #4294967295
 8025686:	461a      	mov	r2, r3
 8025688:	2100      	movs	r1, #0
 802568a:	4620      	mov	r0, r4
 802568c:	f7fd fdd1 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->sw_knob, LV_STATE_DEFAULT, - LV_DPX(4));
 8025690:	4b2d      	ldr	r3, [pc, #180]	; (8025748 <switch_init+0x138>)
 8025692:	681b      	ldr	r3, [r3, #0]
 8025694:	f103 04a0 	add.w	r4, r3, #160	; 0xa0
 8025698:	2000      	movs	r0, #0
 802569a:	f7f9 fa3b 	bl	801eb14 <lv_disp_get_dpi>
 802569e:	4603      	mov	r3, r0
 80256a0:	2b3b      	cmp	r3, #59	; 0x3b
 80256a2:	dd0c      	ble.n	80256be <switch_init+0xae>
 80256a4:	2000      	movs	r0, #0
 80256a6:	f7f9 fa35 	bl	801eb14 <lv_disp_get_dpi>
 80256aa:	4603      	mov	r3, r0
 80256ac:	3314      	adds	r3, #20
 80256ae:	4a28      	ldr	r2, [pc, #160]	; (8025750 <switch_init+0x140>)
 80256b0:	fb82 1203 	smull	r1, r2, r2, r3
 80256b4:	1112      	asrs	r2, r2, #4
 80256b6:	17db      	asrs	r3, r3, #31
 80256b8:	1a9b      	subs	r3, r3, r2
 80256ba:	b21b      	sxth	r3, r3
 80256bc:	e001      	b.n	80256c2 <switch_init+0xb2>
 80256be:	f04f 33ff 	mov.w	r3, #4294967295
 80256c2:	461a      	mov	r2, r3
 80256c4:	2100      	movs	r1, #0
 80256c6:	4620      	mov	r0, r4
 80256c8:	f7fd fdcb 	bl	8023262 <lv_style_set_pad_bottom>
    lv_style_set_pad_left(&styles->sw_knob, LV_STATE_DEFAULT,   - LV_DPX(4));
 80256cc:	4b1e      	ldr	r3, [pc, #120]	; (8025748 <switch_init+0x138>)
 80256ce:	681b      	ldr	r3, [r3, #0]
 80256d0:	f103 04a0 	add.w	r4, r3, #160	; 0xa0
 80256d4:	2000      	movs	r0, #0
 80256d6:	f7f9 fa1d 	bl	801eb14 <lv_disp_get_dpi>
 80256da:	4603      	mov	r3, r0
 80256dc:	2b3b      	cmp	r3, #59	; 0x3b
 80256de:	dd0c      	ble.n	80256fa <switch_init+0xea>
 80256e0:	2000      	movs	r0, #0
 80256e2:	f7f9 fa17 	bl	801eb14 <lv_disp_get_dpi>
 80256e6:	4603      	mov	r3, r0
 80256e8:	3314      	adds	r3, #20
 80256ea:	4a19      	ldr	r2, [pc, #100]	; (8025750 <switch_init+0x140>)
 80256ec:	fb82 1203 	smull	r1, r2, r2, r3
 80256f0:	1112      	asrs	r2, r2, #4
 80256f2:	17db      	asrs	r3, r3, #31
 80256f4:	1a9b      	subs	r3, r3, r2
 80256f6:	b21b      	sxth	r3, r3
 80256f8:	e001      	b.n	80256fe <switch_init+0xee>
 80256fa:	f04f 33ff 	mov.w	r3, #4294967295
 80256fe:	461a      	mov	r2, r3
 8025700:	2100      	movs	r1, #0
 8025702:	4620      	mov	r0, r4
 8025704:	f7fd fdc5 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->sw_knob, LV_STATE_DEFAULT,  - LV_DPX(4));
 8025708:	4b0f      	ldr	r3, [pc, #60]	; (8025748 <switch_init+0x138>)
 802570a:	681b      	ldr	r3, [r3, #0]
 802570c:	f103 04a0 	add.w	r4, r3, #160	; 0xa0
 8025710:	2000      	movs	r0, #0
 8025712:	f7f9 f9ff 	bl	801eb14 <lv_disp_get_dpi>
 8025716:	4603      	mov	r3, r0
 8025718:	2b3b      	cmp	r3, #59	; 0x3b
 802571a:	dd0c      	ble.n	8025736 <switch_init+0x126>
 802571c:	2000      	movs	r0, #0
 802571e:	f7f9 f9f9 	bl	801eb14 <lv_disp_get_dpi>
 8025722:	4603      	mov	r3, r0
 8025724:	3314      	adds	r3, #20
 8025726:	4a0a      	ldr	r2, [pc, #40]	; (8025750 <switch_init+0x140>)
 8025728:	fb82 1203 	smull	r1, r2, r2, r3
 802572c:	1112      	asrs	r2, r2, #4
 802572e:	17db      	asrs	r3, r3, #31
 8025730:	1a9b      	subs	r3, r3, r2
 8025732:	b21b      	sxth	r3, r3
 8025734:	e001      	b.n	802573a <switch_init+0x12a>
 8025736:	f04f 33ff 	mov.w	r3, #4294967295
 802573a:	461a      	mov	r2, r3
 802573c:	2100      	movs	r1, #0
 802573e:	4620      	mov	r0, r4
 8025740:	f7fd fdbf 	bl	80232c2 <lv_style_set_pad_right>
#endif
}
 8025744:	bf00      	nop
 8025746:	bd98      	pop	{r3, r4, r7, pc}
 8025748:	20012350 	.word	0x20012350
 802574c:	0802e594 	.word	0x0802e594
 8025750:	66666667 	.word	0x66666667

08025754 <linemeter_init>:

static void linemeter_init(void)
{
 8025754:	b598      	push	{r3, r4, r7, lr}
 8025756:	af00      	add	r7, sp, #0
#if LV_USE_LINEMETER != 0
    style_init_reset(&styles->lmeter);
 8025758:	4ba0      	ldr	r3, [pc, #640]	; (80259dc <linemeter_init+0x288>)
 802575a:	681b      	ldr	r3, [r3, #0]
 802575c:	3374      	adds	r3, #116	; 0x74
 802575e:	4618      	mov	r0, r3
 8025760:	f004 f854 	bl	802980c <style_init_reset>
    lv_style_set_radius(&styles->lmeter, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 8025764:	4b9d      	ldr	r3, [pc, #628]	; (80259dc <linemeter_init+0x288>)
 8025766:	681b      	ldr	r3, [r3, #0]
 8025768:	3374      	adds	r3, #116	; 0x74
 802576a:	f647 72ff 	movw	r2, #32767	; 0x7fff
 802576e:	2100      	movs	r1, #0
 8025770:	4618      	mov	r0, r3
 8025772:	f7fd fcfe 	bl	8023172 <lv_style_set_radius>
    lv_style_set_pad_left(&styles->lmeter, LV_STATE_DEFAULT, LV_DPX(20));
 8025776:	4b99      	ldr	r3, [pc, #612]	; (80259dc <linemeter_init+0x288>)
 8025778:	681b      	ldr	r3, [r3, #0]
 802577a:	f103 0474 	add.w	r4, r3, #116	; 0x74
 802577e:	2000      	movs	r0, #0
 8025780:	f7f9 f9c8 	bl	801eb14 <lv_disp_get_dpi>
 8025784:	4603      	mov	r3, r0
 8025786:	461a      	mov	r2, r3
 8025788:	4613      	mov	r3, r2
 802578a:	009b      	lsls	r3, r3, #2
 802578c:	4413      	add	r3, r2
 802578e:	009b      	lsls	r3, r3, #2
 8025790:	2bef      	cmp	r3, #239	; 0xef
 8025792:	dd11      	ble.n	80257b8 <linemeter_init+0x64>
 8025794:	2000      	movs	r0, #0
 8025796:	f7f9 f9bd 	bl	801eb14 <lv_disp_get_dpi>
 802579a:	4603      	mov	r3, r0
 802579c:	461a      	mov	r2, r3
 802579e:	4613      	mov	r3, r2
 80257a0:	009b      	lsls	r3, r3, #2
 80257a2:	4413      	add	r3, r2
 80257a4:	009b      	lsls	r3, r3, #2
 80257a6:	3350      	adds	r3, #80	; 0x50
 80257a8:	4a8d      	ldr	r2, [pc, #564]	; (80259e0 <linemeter_init+0x28c>)
 80257aa:	fb82 1203 	smull	r1, r2, r2, r3
 80257ae:	1192      	asrs	r2, r2, #6
 80257b0:	17db      	asrs	r3, r3, #31
 80257b2:	1ad3      	subs	r3, r2, r3
 80257b4:	b21b      	sxth	r3, r3
 80257b6:	e000      	b.n	80257ba <linemeter_init+0x66>
 80257b8:	2301      	movs	r3, #1
 80257ba:	461a      	mov	r2, r3
 80257bc:	2100      	movs	r1, #0
 80257be:	4620      	mov	r0, r4
 80257c0:	f7fd fd67 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->lmeter, LV_STATE_DEFAULT, LV_DPX(20));
 80257c4:	4b85      	ldr	r3, [pc, #532]	; (80259dc <linemeter_init+0x288>)
 80257c6:	681b      	ldr	r3, [r3, #0]
 80257c8:	f103 0474 	add.w	r4, r3, #116	; 0x74
 80257cc:	2000      	movs	r0, #0
 80257ce:	f7f9 f9a1 	bl	801eb14 <lv_disp_get_dpi>
 80257d2:	4603      	mov	r3, r0
 80257d4:	461a      	mov	r2, r3
 80257d6:	4613      	mov	r3, r2
 80257d8:	009b      	lsls	r3, r3, #2
 80257da:	4413      	add	r3, r2
 80257dc:	009b      	lsls	r3, r3, #2
 80257de:	2bef      	cmp	r3, #239	; 0xef
 80257e0:	dd11      	ble.n	8025806 <linemeter_init+0xb2>
 80257e2:	2000      	movs	r0, #0
 80257e4:	f7f9 f996 	bl	801eb14 <lv_disp_get_dpi>
 80257e8:	4603      	mov	r3, r0
 80257ea:	461a      	mov	r2, r3
 80257ec:	4613      	mov	r3, r2
 80257ee:	009b      	lsls	r3, r3, #2
 80257f0:	4413      	add	r3, r2
 80257f2:	009b      	lsls	r3, r3, #2
 80257f4:	3350      	adds	r3, #80	; 0x50
 80257f6:	4a7a      	ldr	r2, [pc, #488]	; (80259e0 <linemeter_init+0x28c>)
 80257f8:	fb82 1203 	smull	r1, r2, r2, r3
 80257fc:	1192      	asrs	r2, r2, #6
 80257fe:	17db      	asrs	r3, r3, #31
 8025800:	1ad3      	subs	r3, r2, r3
 8025802:	b21b      	sxth	r3, r3
 8025804:	e000      	b.n	8025808 <linemeter_init+0xb4>
 8025806:	2301      	movs	r3, #1
 8025808:	461a      	mov	r2, r3
 802580a:	2100      	movs	r1, #0
 802580c:	4620      	mov	r0, r4
 802580e:	f7fd fd58 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->lmeter, LV_STATE_DEFAULT, LV_DPX(20));
 8025812:	4b72      	ldr	r3, [pc, #456]	; (80259dc <linemeter_init+0x288>)
 8025814:	681b      	ldr	r3, [r3, #0]
 8025816:	f103 0474 	add.w	r4, r3, #116	; 0x74
 802581a:	2000      	movs	r0, #0
 802581c:	f7f9 f97a 	bl	801eb14 <lv_disp_get_dpi>
 8025820:	4603      	mov	r3, r0
 8025822:	461a      	mov	r2, r3
 8025824:	4613      	mov	r3, r2
 8025826:	009b      	lsls	r3, r3, #2
 8025828:	4413      	add	r3, r2
 802582a:	009b      	lsls	r3, r3, #2
 802582c:	2bef      	cmp	r3, #239	; 0xef
 802582e:	dd11      	ble.n	8025854 <linemeter_init+0x100>
 8025830:	2000      	movs	r0, #0
 8025832:	f7f9 f96f 	bl	801eb14 <lv_disp_get_dpi>
 8025836:	4603      	mov	r3, r0
 8025838:	461a      	mov	r2, r3
 802583a:	4613      	mov	r3, r2
 802583c:	009b      	lsls	r3, r3, #2
 802583e:	4413      	add	r3, r2
 8025840:	009b      	lsls	r3, r3, #2
 8025842:	3350      	adds	r3, #80	; 0x50
 8025844:	4a66      	ldr	r2, [pc, #408]	; (80259e0 <linemeter_init+0x28c>)
 8025846:	fb82 1203 	smull	r1, r2, r2, r3
 802584a:	1192      	asrs	r2, r2, #6
 802584c:	17db      	asrs	r3, r3, #31
 802584e:	1ad3      	subs	r3, r2, r3
 8025850:	b21b      	sxth	r3, r3
 8025852:	e000      	b.n	8025856 <linemeter_init+0x102>
 8025854:	2301      	movs	r3, #1
 8025856:	461a      	mov	r2, r3
 8025858:	2100      	movs	r1, #0
 802585a:	4620      	mov	r0, r4
 802585c:	f7fd fce9 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_inner(&styles->lmeter, LV_STATE_DEFAULT, LV_DPX(30));
 8025860:	4b5e      	ldr	r3, [pc, #376]	; (80259dc <linemeter_init+0x288>)
 8025862:	681b      	ldr	r3, [r3, #0]
 8025864:	f103 0474 	add.w	r4, r3, #116	; 0x74
 8025868:	2000      	movs	r0, #0
 802586a:	f7f9 f953 	bl	801eb14 <lv_disp_get_dpi>
 802586e:	4603      	mov	r3, r0
 8025870:	461a      	mov	r2, r3
 8025872:	4613      	mov	r3, r2
 8025874:	011b      	lsls	r3, r3, #4
 8025876:	1a9b      	subs	r3, r3, r2
 8025878:	005b      	lsls	r3, r3, #1
 802587a:	2bef      	cmp	r3, #239	; 0xef
 802587c:	dd11      	ble.n	80258a2 <linemeter_init+0x14e>
 802587e:	2000      	movs	r0, #0
 8025880:	f7f9 f948 	bl	801eb14 <lv_disp_get_dpi>
 8025884:	4603      	mov	r3, r0
 8025886:	461a      	mov	r2, r3
 8025888:	4613      	mov	r3, r2
 802588a:	011b      	lsls	r3, r3, #4
 802588c:	1a9b      	subs	r3, r3, r2
 802588e:	005b      	lsls	r3, r3, #1
 8025890:	3350      	adds	r3, #80	; 0x50
 8025892:	4a53      	ldr	r2, [pc, #332]	; (80259e0 <linemeter_init+0x28c>)
 8025894:	fb82 1203 	smull	r1, r2, r2, r3
 8025898:	1192      	asrs	r2, r2, #6
 802589a:	17db      	asrs	r3, r3, #31
 802589c:	1ad3      	subs	r3, r2, r3
 802589e:	b21b      	sxth	r3, r3
 80258a0:	e000      	b.n	80258a4 <linemeter_init+0x150>
 80258a2:	2301      	movs	r3, #1
 80258a4:	461a      	mov	r2, r3
 80258a6:	2100      	movs	r1, #0
 80258a8:	4620      	mov	r0, r4
 80258aa:	f7fd fd22 	bl	80232f2 <lv_style_set_pad_inner>
    lv_style_set_scale_width(&styles->lmeter, LV_STATE_DEFAULT, LV_DPX(25));
 80258ae:	4b4b      	ldr	r3, [pc, #300]	; (80259dc <linemeter_init+0x288>)
 80258b0:	681b      	ldr	r3, [r3, #0]
 80258b2:	f103 0474 	add.w	r4, r3, #116	; 0x74
 80258b6:	2000      	movs	r0, #0
 80258b8:	f7f9 f92c 	bl	801eb14 <lv_disp_get_dpi>
 80258bc:	4603      	mov	r3, r0
 80258be:	461a      	mov	r2, r3
 80258c0:	4613      	mov	r3, r2
 80258c2:	009b      	lsls	r3, r3, #2
 80258c4:	4413      	add	r3, r2
 80258c6:	009a      	lsls	r2, r3, #2
 80258c8:	4413      	add	r3, r2
 80258ca:	2bef      	cmp	r3, #239	; 0xef
 80258cc:	dd12      	ble.n	80258f4 <linemeter_init+0x1a0>
 80258ce:	2000      	movs	r0, #0
 80258d0:	f7f9 f920 	bl	801eb14 <lv_disp_get_dpi>
 80258d4:	4603      	mov	r3, r0
 80258d6:	461a      	mov	r2, r3
 80258d8:	4613      	mov	r3, r2
 80258da:	009b      	lsls	r3, r3, #2
 80258dc:	4413      	add	r3, r2
 80258de:	009a      	lsls	r2, r3, #2
 80258e0:	4413      	add	r3, r2
 80258e2:	3350      	adds	r3, #80	; 0x50
 80258e4:	4a3e      	ldr	r2, [pc, #248]	; (80259e0 <linemeter_init+0x28c>)
 80258e6:	fb82 1203 	smull	r1, r2, r2, r3
 80258ea:	1192      	asrs	r2, r2, #6
 80258ec:	17db      	asrs	r3, r3, #31
 80258ee:	1ad3      	subs	r3, r2, r3
 80258f0:	b21b      	sxth	r3, r3
 80258f2:	e000      	b.n	80258f6 <linemeter_init+0x1a2>
 80258f4:	2301      	movs	r3, #1
 80258f6:	461a      	mov	r2, r3
 80258f8:	2100      	movs	r1, #0
 80258fa:	4620      	mov	r0, r4
 80258fc:	f7fe f88e 	bl	8023a1c <lv_style_set_scale_width>

    lv_style_set_line_color(&styles->lmeter, LV_STATE_DEFAULT, theme.color_primary);
 8025900:	4b36      	ldr	r3, [pc, #216]	; (80259dc <linemeter_init+0x288>)
 8025902:	681b      	ldr	r3, [r3, #0]
 8025904:	3374      	adds	r3, #116	; 0x74
 8025906:	4a37      	ldr	r2, [pc, #220]	; (80259e4 <linemeter_init+0x290>)
 8025908:	8992      	ldrh	r2, [r2, #12]
 802590a:	2100      	movs	r1, #0
 802590c:	4618      	mov	r0, r3
 802590e:	f7fd ffc7 	bl	80238a0 <lv_style_set_line_color>
    lv_style_set_scale_grad_color(&styles->lmeter, LV_STATE_DEFAULT, theme.color_primary);
 8025912:	4b32      	ldr	r3, [pc, #200]	; (80259dc <linemeter_init+0x288>)
 8025914:	681b      	ldr	r3, [r3, #0]
 8025916:	3374      	adds	r3, #116	; 0x74
 8025918:	4a32      	ldr	r2, [pc, #200]	; (80259e4 <linemeter_init+0x290>)
 802591a:	8992      	ldrh	r2, [r2, #12]
 802591c:	2100      	movs	r1, #0
 802591e:	4618      	mov	r0, r3
 8025920:	f7fe f8c4 	bl	8023aac <lv_style_set_scale_grad_color>
    lv_style_set_scale_end_color(&styles->lmeter, LV_STATE_DEFAULT, lv_color_hex3(0x888));
 8025924:	4b2d      	ldr	r3, [pc, #180]	; (80259dc <linemeter_init+0x288>)
 8025926:	681b      	ldr	r3, [r3, #0]
 8025928:	f103 0474 	add.w	r4, r3, #116	; 0x74
 802592c:	f640 0088 	movw	r0, #2184	; 0x888
 8025930:	f7fd fbed 	bl	802310e <lv_color_hex3>
 8025934:	4603      	mov	r3, r0
 8025936:	461a      	mov	r2, r3
 8025938:	2100      	movs	r1, #0
 802593a:	4620      	mov	r0, r4
 802593c:	f7fe f8cc 	bl	8023ad8 <lv_style_set_scale_end_color>
    lv_style_set_line_width(&styles->lmeter, LV_STATE_DEFAULT, LV_DPX(10));
 8025940:	4b26      	ldr	r3, [pc, #152]	; (80259dc <linemeter_init+0x288>)
 8025942:	681b      	ldr	r3, [r3, #0]
 8025944:	f103 0474 	add.w	r4, r3, #116	; 0x74
 8025948:	2000      	movs	r0, #0
 802594a:	f7f9 f8e3 	bl	801eb14 <lv_disp_get_dpi>
 802594e:	4603      	mov	r3, r0
 8025950:	461a      	mov	r2, r3
 8025952:	4613      	mov	r3, r2
 8025954:	009b      	lsls	r3, r3, #2
 8025956:	4413      	add	r3, r2
 8025958:	005b      	lsls	r3, r3, #1
 802595a:	2bef      	cmp	r3, #239	; 0xef
 802595c:	dd11      	ble.n	8025982 <linemeter_init+0x22e>
 802595e:	2000      	movs	r0, #0
 8025960:	f7f9 f8d8 	bl	801eb14 <lv_disp_get_dpi>
 8025964:	4603      	mov	r3, r0
 8025966:	461a      	mov	r2, r3
 8025968:	4613      	mov	r3, r2
 802596a:	009b      	lsls	r3, r3, #2
 802596c:	4413      	add	r3, r2
 802596e:	005b      	lsls	r3, r3, #1
 8025970:	3350      	adds	r3, #80	; 0x50
 8025972:	4a1b      	ldr	r2, [pc, #108]	; (80259e0 <linemeter_init+0x28c>)
 8025974:	fb82 1203 	smull	r1, r2, r2, r3
 8025978:	1192      	asrs	r2, r2, #6
 802597a:	17db      	asrs	r3, r3, #31
 802597c:	1ad3      	subs	r3, r2, r3
 802597e:	b21b      	sxth	r3, r3
 8025980:	e000      	b.n	8025984 <linemeter_init+0x230>
 8025982:	2301      	movs	r3, #1
 8025984:	461a      	mov	r2, r3
 8025986:	2100      	movs	r1, #0
 8025988:	4620      	mov	r0, r4
 802598a:	f7fd ff29 	bl	80237e0 <lv_style_set_line_width>
    lv_style_set_scale_end_line_width(&styles->lmeter, LV_STATE_DEFAULT, LV_DPX(7));
 802598e:	4b13      	ldr	r3, [pc, #76]	; (80259dc <linemeter_init+0x288>)
 8025990:	681b      	ldr	r3, [r3, #0]
 8025992:	f103 0474 	add.w	r4, r3, #116	; 0x74
 8025996:	2000      	movs	r0, #0
 8025998:	f7f9 f8bc 	bl	801eb14 <lv_disp_get_dpi>
 802599c:	4603      	mov	r3, r0
 802599e:	461a      	mov	r2, r3
 80259a0:	4613      	mov	r3, r2
 80259a2:	00db      	lsls	r3, r3, #3
 80259a4:	1a9b      	subs	r3, r3, r2
 80259a6:	2bef      	cmp	r3, #239	; 0xef
 80259a8:	dd10      	ble.n	80259cc <linemeter_init+0x278>
 80259aa:	2000      	movs	r0, #0
 80259ac:	f7f9 f8b2 	bl	801eb14 <lv_disp_get_dpi>
 80259b0:	4603      	mov	r3, r0
 80259b2:	461a      	mov	r2, r3
 80259b4:	4613      	mov	r3, r2
 80259b6:	00db      	lsls	r3, r3, #3
 80259b8:	1a9b      	subs	r3, r3, r2
 80259ba:	3350      	adds	r3, #80	; 0x50
 80259bc:	4a08      	ldr	r2, [pc, #32]	; (80259e0 <linemeter_init+0x28c>)
 80259be:	fb82 1203 	smull	r1, r2, r2, r3
 80259c2:	1192      	asrs	r2, r2, #6
 80259c4:	17db      	asrs	r3, r3, #31
 80259c6:	1ad3      	subs	r3, r2, r3
 80259c8:	b21b      	sxth	r3, r3
 80259ca:	e000      	b.n	80259ce <linemeter_init+0x27a>
 80259cc:	2301      	movs	r3, #1
 80259ce:	461a      	mov	r2, r3
 80259d0:	2100      	movs	r1, #0
 80259d2:	4620      	mov	r0, r4
 80259d4:	f7fe f852 	bl	8023a7c <lv_style_set_scale_end_line_width>
#endif
}
 80259d8:	bf00      	nop
 80259da:	bd98      	pop	{r3, r4, r7, pc}
 80259dc:	20012350 	.word	0x20012350
 80259e0:	66666667 	.word	0x66666667
 80259e4:	20012328 	.word	0x20012328

080259e8 <gauge_init>:

static void gauge_init(void)
{
 80259e8:	b598      	push	{r3, r4, r7, lr}
 80259ea:	af00      	add	r7, sp, #0
#if LV_USE_GAUGE != 0
    style_init_reset(&styles->gauge_main);
 80259ec:	4bca      	ldr	r3, [pc, #808]	; (8025d18 <gauge_init+0x330>)
 80259ee:	681b      	ldr	r3, [r3, #0]
 80259f0:	3360      	adds	r3, #96	; 0x60
 80259f2:	4618      	mov	r0, r3
 80259f4:	f003 ff0a 	bl	802980c <style_init_reset>
    lv_style_set_line_color(&styles->gauge_main, LV_STATE_DEFAULT, lv_color_hex3(0x888));
 80259f8:	4bc7      	ldr	r3, [pc, #796]	; (8025d18 <gauge_init+0x330>)
 80259fa:	681b      	ldr	r3, [r3, #0]
 80259fc:	f103 0460 	add.w	r4, r3, #96	; 0x60
 8025a00:	f640 0088 	movw	r0, #2184	; 0x888
 8025a04:	f7fd fb83 	bl	802310e <lv_color_hex3>
 8025a08:	4603      	mov	r3, r0
 8025a0a:	461a      	mov	r2, r3
 8025a0c:	2100      	movs	r1, #0
 8025a0e:	4620      	mov	r0, r4
 8025a10:	f7fd ff46 	bl	80238a0 <lv_style_set_line_color>
    lv_style_set_scale_grad_color(&styles->gauge_main, LV_STATE_DEFAULT, lv_color_hex3(0x888));
 8025a14:	4bc0      	ldr	r3, [pc, #768]	; (8025d18 <gauge_init+0x330>)
 8025a16:	681b      	ldr	r3, [r3, #0]
 8025a18:	f103 0460 	add.w	r4, r3, #96	; 0x60
 8025a1c:	f640 0088 	movw	r0, #2184	; 0x888
 8025a20:	f7fd fb75 	bl	802310e <lv_color_hex3>
 8025a24:	4603      	mov	r3, r0
 8025a26:	461a      	mov	r2, r3
 8025a28:	2100      	movs	r1, #0
 8025a2a:	4620      	mov	r0, r4
 8025a2c:	f7fe f83e 	bl	8023aac <lv_style_set_scale_grad_color>
    lv_style_set_scale_end_color(&styles->gauge_main, LV_STATE_DEFAULT, theme.color_primary);
 8025a30:	4bb9      	ldr	r3, [pc, #740]	; (8025d18 <gauge_init+0x330>)
 8025a32:	681b      	ldr	r3, [r3, #0]
 8025a34:	3360      	adds	r3, #96	; 0x60
 8025a36:	4ab9      	ldr	r2, [pc, #740]	; (8025d1c <gauge_init+0x334>)
 8025a38:	8992      	ldrh	r2, [r2, #12]
 8025a3a:	2100      	movs	r1, #0
 8025a3c:	4618      	mov	r0, r3
 8025a3e:	f7fe f84b 	bl	8023ad8 <lv_style_set_scale_end_color>
    lv_style_set_line_width(&styles->gauge_main, LV_STATE_DEFAULT, LV_DPX(5));
 8025a42:	4bb5      	ldr	r3, [pc, #724]	; (8025d18 <gauge_init+0x330>)
 8025a44:	681b      	ldr	r3, [r3, #0]
 8025a46:	f103 0460 	add.w	r4, r3, #96	; 0x60
 8025a4a:	2000      	movs	r0, #0
 8025a4c:	f7f9 f862 	bl	801eb14 <lv_disp_get_dpi>
 8025a50:	4603      	mov	r3, r0
 8025a52:	461a      	mov	r2, r3
 8025a54:	4613      	mov	r3, r2
 8025a56:	009b      	lsls	r3, r3, #2
 8025a58:	4413      	add	r3, r2
 8025a5a:	2bef      	cmp	r3, #239	; 0xef
 8025a5c:	dd10      	ble.n	8025a80 <gauge_init+0x98>
 8025a5e:	2000      	movs	r0, #0
 8025a60:	f7f9 f858 	bl	801eb14 <lv_disp_get_dpi>
 8025a64:	4603      	mov	r3, r0
 8025a66:	461a      	mov	r2, r3
 8025a68:	4613      	mov	r3, r2
 8025a6a:	009b      	lsls	r3, r3, #2
 8025a6c:	4413      	add	r3, r2
 8025a6e:	3350      	adds	r3, #80	; 0x50
 8025a70:	4aab      	ldr	r2, [pc, #684]	; (8025d20 <gauge_init+0x338>)
 8025a72:	fb82 1203 	smull	r1, r2, r2, r3
 8025a76:	1192      	asrs	r2, r2, #6
 8025a78:	17db      	asrs	r3, r3, #31
 8025a7a:	1ad3      	subs	r3, r2, r3
 8025a7c:	b21b      	sxth	r3, r3
 8025a7e:	e000      	b.n	8025a82 <gauge_init+0x9a>
 8025a80:	2301      	movs	r3, #1
 8025a82:	461a      	mov	r2, r3
 8025a84:	2100      	movs	r1, #0
 8025a86:	4620      	mov	r0, r4
 8025a88:	f7fd feaa 	bl	80237e0 <lv_style_set_line_width>
    lv_style_set_scale_end_line_width(&styles->gauge_main, LV_STATE_DEFAULT, LV_DPX(4));
 8025a8c:	4ba2      	ldr	r3, [pc, #648]	; (8025d18 <gauge_init+0x330>)
 8025a8e:	681b      	ldr	r3, [r3, #0]
 8025a90:	f103 0460 	add.w	r4, r3, #96	; 0x60
 8025a94:	2000      	movs	r0, #0
 8025a96:	f7f9 f83d 	bl	801eb14 <lv_disp_get_dpi>
 8025a9a:	4603      	mov	r3, r0
 8025a9c:	2b3b      	cmp	r3, #59	; 0x3b
 8025a9e:	dd0c      	ble.n	8025aba <gauge_init+0xd2>
 8025aa0:	2000      	movs	r0, #0
 8025aa2:	f7f9 f837 	bl	801eb14 <lv_disp_get_dpi>
 8025aa6:	4603      	mov	r3, r0
 8025aa8:	3314      	adds	r3, #20
 8025aaa:	4a9d      	ldr	r2, [pc, #628]	; (8025d20 <gauge_init+0x338>)
 8025aac:	fb82 1203 	smull	r1, r2, r2, r3
 8025ab0:	1112      	asrs	r2, r2, #4
 8025ab2:	17db      	asrs	r3, r3, #31
 8025ab4:	1ad3      	subs	r3, r2, r3
 8025ab6:	b21b      	sxth	r3, r3
 8025ab8:	e000      	b.n	8025abc <gauge_init+0xd4>
 8025aba:	2301      	movs	r3, #1
 8025abc:	461a      	mov	r2, r3
 8025abe:	2100      	movs	r1, #0
 8025ac0:	4620      	mov	r0, r4
 8025ac2:	f7fd ffdb 	bl	8023a7c <lv_style_set_scale_end_line_width>
    lv_style_set_scale_end_border_width(&styles->gauge_main, LV_STATE_DEFAULT, LV_DPX(8));
 8025ac6:	4b94      	ldr	r3, [pc, #592]	; (8025d18 <gauge_init+0x330>)
 8025ac8:	681b      	ldr	r3, [r3, #0]
 8025aca:	f103 0460 	add.w	r4, r3, #96	; 0x60
 8025ace:	2000      	movs	r0, #0
 8025ad0:	f7f9 f820 	bl	801eb14 <lv_disp_get_dpi>
 8025ad4:	4603      	mov	r3, r0
 8025ad6:	2b1d      	cmp	r3, #29
 8025ad8:	dd0c      	ble.n	8025af4 <gauge_init+0x10c>
 8025ada:	2000      	movs	r0, #0
 8025adc:	f7f9 f81a 	bl	801eb14 <lv_disp_get_dpi>
 8025ae0:	4603      	mov	r3, r0
 8025ae2:	330a      	adds	r3, #10
 8025ae4:	4a8e      	ldr	r2, [pc, #568]	; (8025d20 <gauge_init+0x338>)
 8025ae6:	fb82 1203 	smull	r1, r2, r2, r3
 8025aea:	10d2      	asrs	r2, r2, #3
 8025aec:	17db      	asrs	r3, r3, #31
 8025aee:	1ad3      	subs	r3, r2, r3
 8025af0:	b21b      	sxth	r3, r3
 8025af2:	e000      	b.n	8025af6 <gauge_init+0x10e>
 8025af4:	2301      	movs	r3, #1
 8025af6:	461a      	mov	r2, r3
 8025af8:	2100      	movs	r1, #0
 8025afa:	4620      	mov	r0, r4
 8025afc:	f7fd ffa6 	bl	8023a4c <lv_style_set_scale_end_border_width>
    lv_style_set_pad_left(&styles->gauge_main, LV_STATE_DEFAULT, LV_DPX(20));
 8025b00:	4b85      	ldr	r3, [pc, #532]	; (8025d18 <gauge_init+0x330>)
 8025b02:	681b      	ldr	r3, [r3, #0]
 8025b04:	f103 0460 	add.w	r4, r3, #96	; 0x60
 8025b08:	2000      	movs	r0, #0
 8025b0a:	f7f9 f803 	bl	801eb14 <lv_disp_get_dpi>
 8025b0e:	4603      	mov	r3, r0
 8025b10:	461a      	mov	r2, r3
 8025b12:	4613      	mov	r3, r2
 8025b14:	009b      	lsls	r3, r3, #2
 8025b16:	4413      	add	r3, r2
 8025b18:	009b      	lsls	r3, r3, #2
 8025b1a:	2bef      	cmp	r3, #239	; 0xef
 8025b1c:	dd11      	ble.n	8025b42 <gauge_init+0x15a>
 8025b1e:	2000      	movs	r0, #0
 8025b20:	f7f8 fff8 	bl	801eb14 <lv_disp_get_dpi>
 8025b24:	4603      	mov	r3, r0
 8025b26:	461a      	mov	r2, r3
 8025b28:	4613      	mov	r3, r2
 8025b2a:	009b      	lsls	r3, r3, #2
 8025b2c:	4413      	add	r3, r2
 8025b2e:	009b      	lsls	r3, r3, #2
 8025b30:	3350      	adds	r3, #80	; 0x50
 8025b32:	4a7b      	ldr	r2, [pc, #492]	; (8025d20 <gauge_init+0x338>)
 8025b34:	fb82 1203 	smull	r1, r2, r2, r3
 8025b38:	1192      	asrs	r2, r2, #6
 8025b3a:	17db      	asrs	r3, r3, #31
 8025b3c:	1ad3      	subs	r3, r2, r3
 8025b3e:	b21b      	sxth	r3, r3
 8025b40:	e000      	b.n	8025b44 <gauge_init+0x15c>
 8025b42:	2301      	movs	r3, #1
 8025b44:	461a      	mov	r2, r3
 8025b46:	2100      	movs	r1, #0
 8025b48:	4620      	mov	r0, r4
 8025b4a:	f7fd fba2 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->gauge_main, LV_STATE_DEFAULT, LV_DPX(20));
 8025b4e:	4b72      	ldr	r3, [pc, #456]	; (8025d18 <gauge_init+0x330>)
 8025b50:	681b      	ldr	r3, [r3, #0]
 8025b52:	f103 0460 	add.w	r4, r3, #96	; 0x60
 8025b56:	2000      	movs	r0, #0
 8025b58:	f7f8 ffdc 	bl	801eb14 <lv_disp_get_dpi>
 8025b5c:	4603      	mov	r3, r0
 8025b5e:	461a      	mov	r2, r3
 8025b60:	4613      	mov	r3, r2
 8025b62:	009b      	lsls	r3, r3, #2
 8025b64:	4413      	add	r3, r2
 8025b66:	009b      	lsls	r3, r3, #2
 8025b68:	2bef      	cmp	r3, #239	; 0xef
 8025b6a:	dd11      	ble.n	8025b90 <gauge_init+0x1a8>
 8025b6c:	2000      	movs	r0, #0
 8025b6e:	f7f8 ffd1 	bl	801eb14 <lv_disp_get_dpi>
 8025b72:	4603      	mov	r3, r0
 8025b74:	461a      	mov	r2, r3
 8025b76:	4613      	mov	r3, r2
 8025b78:	009b      	lsls	r3, r3, #2
 8025b7a:	4413      	add	r3, r2
 8025b7c:	009b      	lsls	r3, r3, #2
 8025b7e:	3350      	adds	r3, #80	; 0x50
 8025b80:	4a67      	ldr	r2, [pc, #412]	; (8025d20 <gauge_init+0x338>)
 8025b82:	fb82 1203 	smull	r1, r2, r2, r3
 8025b86:	1192      	asrs	r2, r2, #6
 8025b88:	17db      	asrs	r3, r3, #31
 8025b8a:	1ad3      	subs	r3, r2, r3
 8025b8c:	b21b      	sxth	r3, r3
 8025b8e:	e000      	b.n	8025b92 <gauge_init+0x1aa>
 8025b90:	2301      	movs	r3, #1
 8025b92:	461a      	mov	r2, r3
 8025b94:	2100      	movs	r1, #0
 8025b96:	4620      	mov	r0, r4
 8025b98:	f7fd fb93 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->gauge_main, LV_STATE_DEFAULT, LV_DPX(20));
 8025b9c:	4b5e      	ldr	r3, [pc, #376]	; (8025d18 <gauge_init+0x330>)
 8025b9e:	681b      	ldr	r3, [r3, #0]
 8025ba0:	f103 0460 	add.w	r4, r3, #96	; 0x60
 8025ba4:	2000      	movs	r0, #0
 8025ba6:	f7f8 ffb5 	bl	801eb14 <lv_disp_get_dpi>
 8025baa:	4603      	mov	r3, r0
 8025bac:	461a      	mov	r2, r3
 8025bae:	4613      	mov	r3, r2
 8025bb0:	009b      	lsls	r3, r3, #2
 8025bb2:	4413      	add	r3, r2
 8025bb4:	009b      	lsls	r3, r3, #2
 8025bb6:	2bef      	cmp	r3, #239	; 0xef
 8025bb8:	dd11      	ble.n	8025bde <gauge_init+0x1f6>
 8025bba:	2000      	movs	r0, #0
 8025bbc:	f7f8 ffaa 	bl	801eb14 <lv_disp_get_dpi>
 8025bc0:	4603      	mov	r3, r0
 8025bc2:	461a      	mov	r2, r3
 8025bc4:	4613      	mov	r3, r2
 8025bc6:	009b      	lsls	r3, r3, #2
 8025bc8:	4413      	add	r3, r2
 8025bca:	009b      	lsls	r3, r3, #2
 8025bcc:	3350      	adds	r3, #80	; 0x50
 8025bce:	4a54      	ldr	r2, [pc, #336]	; (8025d20 <gauge_init+0x338>)
 8025bd0:	fb82 1203 	smull	r1, r2, r2, r3
 8025bd4:	1192      	asrs	r2, r2, #6
 8025bd6:	17db      	asrs	r3, r3, #31
 8025bd8:	1ad3      	subs	r3, r2, r3
 8025bda:	b21b      	sxth	r3, r3
 8025bdc:	e000      	b.n	8025be0 <gauge_init+0x1f8>
 8025bde:	2301      	movs	r3, #1
 8025be0:	461a      	mov	r2, r3
 8025be2:	2100      	movs	r1, #0
 8025be4:	4620      	mov	r0, r4
 8025be6:	f7fd fb24 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_inner(&styles->gauge_main, LV_STATE_DEFAULT, LV_DPX(20));
 8025bea:	4b4b      	ldr	r3, [pc, #300]	; (8025d18 <gauge_init+0x330>)
 8025bec:	681b      	ldr	r3, [r3, #0]
 8025bee:	f103 0460 	add.w	r4, r3, #96	; 0x60
 8025bf2:	2000      	movs	r0, #0
 8025bf4:	f7f8 ff8e 	bl	801eb14 <lv_disp_get_dpi>
 8025bf8:	4603      	mov	r3, r0
 8025bfa:	461a      	mov	r2, r3
 8025bfc:	4613      	mov	r3, r2
 8025bfe:	009b      	lsls	r3, r3, #2
 8025c00:	4413      	add	r3, r2
 8025c02:	009b      	lsls	r3, r3, #2
 8025c04:	2bef      	cmp	r3, #239	; 0xef
 8025c06:	dd11      	ble.n	8025c2c <gauge_init+0x244>
 8025c08:	2000      	movs	r0, #0
 8025c0a:	f7f8 ff83 	bl	801eb14 <lv_disp_get_dpi>
 8025c0e:	4603      	mov	r3, r0
 8025c10:	461a      	mov	r2, r3
 8025c12:	4613      	mov	r3, r2
 8025c14:	009b      	lsls	r3, r3, #2
 8025c16:	4413      	add	r3, r2
 8025c18:	009b      	lsls	r3, r3, #2
 8025c1a:	3350      	adds	r3, #80	; 0x50
 8025c1c:	4a40      	ldr	r2, [pc, #256]	; (8025d20 <gauge_init+0x338>)
 8025c1e:	fb82 1203 	smull	r1, r2, r2, r3
 8025c22:	1192      	asrs	r2, r2, #6
 8025c24:	17db      	asrs	r3, r3, #31
 8025c26:	1ad3      	subs	r3, r2, r3
 8025c28:	b21b      	sxth	r3, r3
 8025c2a:	e000      	b.n	8025c2e <gauge_init+0x246>
 8025c2c:	2301      	movs	r3, #1
 8025c2e:	461a      	mov	r2, r3
 8025c30:	2100      	movs	r1, #0
 8025c32:	4620      	mov	r0, r4
 8025c34:	f7fd fb5d 	bl	80232f2 <lv_style_set_pad_inner>
    lv_style_set_scale_width(&styles->gauge_main, LV_STATE_DEFAULT, LV_DPX(15));
 8025c38:	4b37      	ldr	r3, [pc, #220]	; (8025d18 <gauge_init+0x330>)
 8025c3a:	681b      	ldr	r3, [r3, #0]
 8025c3c:	f103 0460 	add.w	r4, r3, #96	; 0x60
 8025c40:	2000      	movs	r0, #0
 8025c42:	f7f8 ff67 	bl	801eb14 <lv_disp_get_dpi>
 8025c46:	4603      	mov	r3, r0
 8025c48:	461a      	mov	r2, r3
 8025c4a:	4613      	mov	r3, r2
 8025c4c:	011b      	lsls	r3, r3, #4
 8025c4e:	1a9b      	subs	r3, r3, r2
 8025c50:	2bef      	cmp	r3, #239	; 0xef
 8025c52:	dd10      	ble.n	8025c76 <gauge_init+0x28e>
 8025c54:	2000      	movs	r0, #0
 8025c56:	f7f8 ff5d 	bl	801eb14 <lv_disp_get_dpi>
 8025c5a:	4603      	mov	r3, r0
 8025c5c:	461a      	mov	r2, r3
 8025c5e:	4613      	mov	r3, r2
 8025c60:	011b      	lsls	r3, r3, #4
 8025c62:	1a9b      	subs	r3, r3, r2
 8025c64:	3350      	adds	r3, #80	; 0x50
 8025c66:	4a2e      	ldr	r2, [pc, #184]	; (8025d20 <gauge_init+0x338>)
 8025c68:	fb82 1203 	smull	r1, r2, r2, r3
 8025c6c:	1192      	asrs	r2, r2, #6
 8025c6e:	17db      	asrs	r3, r3, #31
 8025c70:	1ad3      	subs	r3, r2, r3
 8025c72:	b21b      	sxth	r3, r3
 8025c74:	e000      	b.n	8025c78 <gauge_init+0x290>
 8025c76:	2301      	movs	r3, #1
 8025c78:	461a      	mov	r2, r3
 8025c7a:	2100      	movs	r1, #0
 8025c7c:	4620      	mov	r0, r4
 8025c7e:	f7fd fecd 	bl	8023a1c <lv_style_set_scale_width>
    lv_style_set_radius(&styles->gauge_main, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 8025c82:	4b25      	ldr	r3, [pc, #148]	; (8025d18 <gauge_init+0x330>)
 8025c84:	681b      	ldr	r3, [r3, #0]
 8025c86:	3360      	adds	r3, #96	; 0x60
 8025c88:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8025c8c:	2100      	movs	r1, #0
 8025c8e:	4618      	mov	r0, r3
 8025c90:	f7fd fa6f 	bl	8023172 <lv_style_set_radius>

    style_init_reset(&styles->gauge_strong);
 8025c94:	4b20      	ldr	r3, [pc, #128]	; (8025d18 <gauge_init+0x330>)
 8025c96:	681b      	ldr	r3, [r3, #0]
 8025c98:	3364      	adds	r3, #100	; 0x64
 8025c9a:	4618      	mov	r0, r3
 8025c9c:	f003 fdb6 	bl	802980c <style_init_reset>
    lv_style_set_line_color(&styles->gauge_strong, LV_STATE_DEFAULT, lv_color_hex3(0x888));
 8025ca0:	4b1d      	ldr	r3, [pc, #116]	; (8025d18 <gauge_init+0x330>)
 8025ca2:	681b      	ldr	r3, [r3, #0]
 8025ca4:	f103 0464 	add.w	r4, r3, #100	; 0x64
 8025ca8:	f640 0088 	movw	r0, #2184	; 0x888
 8025cac:	f7fd fa2f 	bl	802310e <lv_color_hex3>
 8025cb0:	4603      	mov	r3, r0
 8025cb2:	461a      	mov	r2, r3
 8025cb4:	2100      	movs	r1, #0
 8025cb6:	4620      	mov	r0, r4
 8025cb8:	f7fd fdf2 	bl	80238a0 <lv_style_set_line_color>
    lv_style_set_scale_grad_color(&styles->gauge_strong, LV_STATE_DEFAULT, lv_color_hex3(0x888));
 8025cbc:	4b16      	ldr	r3, [pc, #88]	; (8025d18 <gauge_init+0x330>)
 8025cbe:	681b      	ldr	r3, [r3, #0]
 8025cc0:	f103 0464 	add.w	r4, r3, #100	; 0x64
 8025cc4:	f640 0088 	movw	r0, #2184	; 0x888
 8025cc8:	f7fd fa21 	bl	802310e <lv_color_hex3>
 8025ccc:	4603      	mov	r3, r0
 8025cce:	461a      	mov	r2, r3
 8025cd0:	2100      	movs	r1, #0
 8025cd2:	4620      	mov	r0, r4
 8025cd4:	f7fd feea 	bl	8023aac <lv_style_set_scale_grad_color>
    lv_style_set_scale_end_color(&styles->gauge_strong, LV_STATE_DEFAULT, theme.color_primary);
 8025cd8:	4b0f      	ldr	r3, [pc, #60]	; (8025d18 <gauge_init+0x330>)
 8025cda:	681b      	ldr	r3, [r3, #0]
 8025cdc:	3364      	adds	r3, #100	; 0x64
 8025cde:	4a0f      	ldr	r2, [pc, #60]	; (8025d1c <gauge_init+0x334>)
 8025ce0:	8992      	ldrh	r2, [r2, #12]
 8025ce2:	2100      	movs	r1, #0
 8025ce4:	4618      	mov	r0, r3
 8025ce6:	f7fd fef7 	bl	8023ad8 <lv_style_set_scale_end_color>
    lv_style_set_line_width(&styles->gauge_strong, LV_STATE_DEFAULT, LV_DPX(8));
 8025cea:	4b0b      	ldr	r3, [pc, #44]	; (8025d18 <gauge_init+0x330>)
 8025cec:	681b      	ldr	r3, [r3, #0]
 8025cee:	f103 0464 	add.w	r4, r3, #100	; 0x64
 8025cf2:	2000      	movs	r0, #0
 8025cf4:	f7f8 ff0e 	bl	801eb14 <lv_disp_get_dpi>
 8025cf8:	4603      	mov	r3, r0
 8025cfa:	2b1d      	cmp	r3, #29
 8025cfc:	dd12      	ble.n	8025d24 <gauge_init+0x33c>
 8025cfe:	2000      	movs	r0, #0
 8025d00:	f7f8 ff08 	bl	801eb14 <lv_disp_get_dpi>
 8025d04:	4603      	mov	r3, r0
 8025d06:	330a      	adds	r3, #10
 8025d08:	4a05      	ldr	r2, [pc, #20]	; (8025d20 <gauge_init+0x338>)
 8025d0a:	fb82 1203 	smull	r1, r2, r2, r3
 8025d0e:	10d2      	asrs	r2, r2, #3
 8025d10:	17db      	asrs	r3, r3, #31
 8025d12:	1ad3      	subs	r3, r2, r3
 8025d14:	b21b      	sxth	r3, r3
 8025d16:	e006      	b.n	8025d26 <gauge_init+0x33e>
 8025d18:	20012350 	.word	0x20012350
 8025d1c:	20012328 	.word	0x20012328
 8025d20:	66666667 	.word	0x66666667
 8025d24:	2301      	movs	r3, #1
 8025d26:	461a      	mov	r2, r3
 8025d28:	2100      	movs	r1, #0
 8025d2a:	4620      	mov	r0, r4
 8025d2c:	f7fd fd58 	bl	80237e0 <lv_style_set_line_width>
    lv_style_set_scale_end_line_width(&styles->gauge_strong, LV_STATE_DEFAULT, LV_DPX(8));
 8025d30:	4b7a      	ldr	r3, [pc, #488]	; (8025f1c <gauge_init+0x534>)
 8025d32:	681b      	ldr	r3, [r3, #0]
 8025d34:	f103 0464 	add.w	r4, r3, #100	; 0x64
 8025d38:	2000      	movs	r0, #0
 8025d3a:	f7f8 feeb 	bl	801eb14 <lv_disp_get_dpi>
 8025d3e:	4603      	mov	r3, r0
 8025d40:	2b1d      	cmp	r3, #29
 8025d42:	dd0c      	ble.n	8025d5e <gauge_init+0x376>
 8025d44:	2000      	movs	r0, #0
 8025d46:	f7f8 fee5 	bl	801eb14 <lv_disp_get_dpi>
 8025d4a:	4603      	mov	r3, r0
 8025d4c:	330a      	adds	r3, #10
 8025d4e:	4a74      	ldr	r2, [pc, #464]	; (8025f20 <gauge_init+0x538>)
 8025d50:	fb82 1203 	smull	r1, r2, r2, r3
 8025d54:	10d2      	asrs	r2, r2, #3
 8025d56:	17db      	asrs	r3, r3, #31
 8025d58:	1ad3      	subs	r3, r2, r3
 8025d5a:	b21b      	sxth	r3, r3
 8025d5c:	e000      	b.n	8025d60 <gauge_init+0x378>
 8025d5e:	2301      	movs	r3, #1
 8025d60:	461a      	mov	r2, r3
 8025d62:	2100      	movs	r1, #0
 8025d64:	4620      	mov	r0, r4
 8025d66:	f7fd fe89 	bl	8023a7c <lv_style_set_scale_end_line_width>
    lv_style_set_scale_width(&styles->gauge_strong, LV_STATE_DEFAULT, LV_DPX(25));
 8025d6a:	4b6c      	ldr	r3, [pc, #432]	; (8025f1c <gauge_init+0x534>)
 8025d6c:	681b      	ldr	r3, [r3, #0]
 8025d6e:	f103 0464 	add.w	r4, r3, #100	; 0x64
 8025d72:	2000      	movs	r0, #0
 8025d74:	f7f8 fece 	bl	801eb14 <lv_disp_get_dpi>
 8025d78:	4603      	mov	r3, r0
 8025d7a:	461a      	mov	r2, r3
 8025d7c:	4613      	mov	r3, r2
 8025d7e:	009b      	lsls	r3, r3, #2
 8025d80:	4413      	add	r3, r2
 8025d82:	009a      	lsls	r2, r3, #2
 8025d84:	4413      	add	r3, r2
 8025d86:	2bef      	cmp	r3, #239	; 0xef
 8025d88:	dd12      	ble.n	8025db0 <gauge_init+0x3c8>
 8025d8a:	2000      	movs	r0, #0
 8025d8c:	f7f8 fec2 	bl	801eb14 <lv_disp_get_dpi>
 8025d90:	4603      	mov	r3, r0
 8025d92:	461a      	mov	r2, r3
 8025d94:	4613      	mov	r3, r2
 8025d96:	009b      	lsls	r3, r3, #2
 8025d98:	4413      	add	r3, r2
 8025d9a:	009a      	lsls	r2, r3, #2
 8025d9c:	4413      	add	r3, r2
 8025d9e:	3350      	adds	r3, #80	; 0x50
 8025da0:	4a5f      	ldr	r2, [pc, #380]	; (8025f20 <gauge_init+0x538>)
 8025da2:	fb82 1203 	smull	r1, r2, r2, r3
 8025da6:	1192      	asrs	r2, r2, #6
 8025da8:	17db      	asrs	r3, r3, #31
 8025daa:	1ad3      	subs	r3, r2, r3
 8025dac:	b21b      	sxth	r3, r3
 8025dae:	e000      	b.n	8025db2 <gauge_init+0x3ca>
 8025db0:	2301      	movs	r3, #1
 8025db2:	461a      	mov	r2, r3
 8025db4:	2100      	movs	r1, #0
 8025db6:	4620      	mov	r0, r4
 8025db8:	f7fd fe30 	bl	8023a1c <lv_style_set_scale_width>

    style_init_reset(&styles->gauge_needle);
 8025dbc:	4b57      	ldr	r3, [pc, #348]	; (8025f1c <gauge_init+0x534>)
 8025dbe:	681b      	ldr	r3, [r3, #0]
 8025dc0:	3368      	adds	r3, #104	; 0x68
 8025dc2:	4618      	mov	r0, r3
 8025dc4:	f003 fd22 	bl	802980c <style_init_reset>
    lv_style_set_line_color(&styles->gauge_needle, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex(0x464b5b) : LV_COLOR_WHITE);
 8025dc8:	4b54      	ldr	r3, [pc, #336]	; (8025f1c <gauge_init+0x534>)
 8025dca:	681b      	ldr	r3, [r3, #0]
 8025dcc:	f103 0468 	add.w	r4, r3, #104	; 0x68
 8025dd0:	4b54      	ldr	r3, [pc, #336]	; (8025f24 <gauge_init+0x53c>)
 8025dd2:	6a1b      	ldr	r3, [r3, #32]
 8025dd4:	f003 0302 	and.w	r3, r3, #2
 8025dd8:	2b00      	cmp	r3, #0
 8025dda:	d004      	beq.n	8025de6 <gauge_init+0x3fe>
 8025ddc:	4852      	ldr	r0, [pc, #328]	; (8025f28 <gauge_init+0x540>)
 8025dde:	f7fd f982 	bl	80230e6 <lv_color_hex>
 8025de2:	4603      	mov	r3, r0
 8025de4:	e001      	b.n	8025dea <gauge_init+0x402>
 8025de6:	4b51      	ldr	r3, [pc, #324]	; (8025f2c <gauge_init+0x544>)
 8025de8:	881b      	ldrh	r3, [r3, #0]
 8025dea:	461a      	mov	r2, r3
 8025dec:	2100      	movs	r1, #0
 8025dee:	4620      	mov	r0, r4
 8025df0:	f7fd fd56 	bl	80238a0 <lv_style_set_line_color>
    lv_style_set_line_width(&styles->gauge_needle, LV_STATE_DEFAULT, LV_DPX(8));
 8025df4:	4b49      	ldr	r3, [pc, #292]	; (8025f1c <gauge_init+0x534>)
 8025df6:	681b      	ldr	r3, [r3, #0]
 8025df8:	f103 0468 	add.w	r4, r3, #104	; 0x68
 8025dfc:	2000      	movs	r0, #0
 8025dfe:	f7f8 fe89 	bl	801eb14 <lv_disp_get_dpi>
 8025e02:	4603      	mov	r3, r0
 8025e04:	2b1d      	cmp	r3, #29
 8025e06:	dd0c      	ble.n	8025e22 <gauge_init+0x43a>
 8025e08:	2000      	movs	r0, #0
 8025e0a:	f7f8 fe83 	bl	801eb14 <lv_disp_get_dpi>
 8025e0e:	4603      	mov	r3, r0
 8025e10:	330a      	adds	r3, #10
 8025e12:	4a43      	ldr	r2, [pc, #268]	; (8025f20 <gauge_init+0x538>)
 8025e14:	fb82 1203 	smull	r1, r2, r2, r3
 8025e18:	10d2      	asrs	r2, r2, #3
 8025e1a:	17db      	asrs	r3, r3, #31
 8025e1c:	1ad3      	subs	r3, r2, r3
 8025e1e:	b21b      	sxth	r3, r3
 8025e20:	e000      	b.n	8025e24 <gauge_init+0x43c>
 8025e22:	2301      	movs	r3, #1
 8025e24:	461a      	mov	r2, r3
 8025e26:	2100      	movs	r1, #0
 8025e28:	4620      	mov	r0, r4
 8025e2a:	f7fd fcd9 	bl	80237e0 <lv_style_set_line_width>
    lv_style_set_bg_opa(&styles->gauge_needle, LV_STATE_DEFAULT, LV_OPA_COVER);
 8025e2e:	4b3b      	ldr	r3, [pc, #236]	; (8025f1c <gauge_init+0x534>)
 8025e30:	681b      	ldr	r3, [r3, #0]
 8025e32:	3368      	adds	r3, #104	; 0x68
 8025e34:	22ff      	movs	r2, #255	; 0xff
 8025e36:	2100      	movs	r1, #0
 8025e38:	4618      	mov	r0, r3
 8025e3a:	f7fd fae8 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->gauge_needle, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex(0x464b5b) : LV_COLOR_WHITE);
 8025e3e:	4b37      	ldr	r3, [pc, #220]	; (8025f1c <gauge_init+0x534>)
 8025e40:	681b      	ldr	r3, [r3, #0]
 8025e42:	f103 0468 	add.w	r4, r3, #104	; 0x68
 8025e46:	4b37      	ldr	r3, [pc, #220]	; (8025f24 <gauge_init+0x53c>)
 8025e48:	6a1b      	ldr	r3, [r3, #32]
 8025e4a:	f003 0302 	and.w	r3, r3, #2
 8025e4e:	2b00      	cmp	r3, #0
 8025e50:	d004      	beq.n	8025e5c <gauge_init+0x474>
 8025e52:	4835      	ldr	r0, [pc, #212]	; (8025f28 <gauge_init+0x540>)
 8025e54:	f7fd f947 	bl	80230e6 <lv_color_hex>
 8025e58:	4603      	mov	r3, r0
 8025e5a:	e001      	b.n	8025e60 <gauge_init+0x478>
 8025e5c:	4b33      	ldr	r3, [pc, #204]	; (8025f2c <gauge_init+0x544>)
 8025e5e:	881b      	ldrh	r3, [r3, #0]
 8025e60:	461a      	mov	r2, r3
 8025e62:	2100      	movs	r1, #0
 8025e64:	4620      	mov	r0, r4
 8025e66:	f7fd fabc 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_radius(&styles->gauge_needle, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 8025e6a:	4b2c      	ldr	r3, [pc, #176]	; (8025f1c <gauge_init+0x534>)
 8025e6c:	681b      	ldr	r3, [r3, #0]
 8025e6e:	3368      	adds	r3, #104	; 0x68
 8025e70:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8025e74:	2100      	movs	r1, #0
 8025e76:	4618      	mov	r0, r3
 8025e78:	f7fd f97b 	bl	8023172 <lv_style_set_radius>
    lv_style_set_size(&styles->gauge_needle, LV_STATE_DEFAULT, LV_DPX(30));
 8025e7c:	4b27      	ldr	r3, [pc, #156]	; (8025f1c <gauge_init+0x534>)
 8025e7e:	681b      	ldr	r3, [r3, #0]
 8025e80:	f103 0468 	add.w	r4, r3, #104	; 0x68
 8025e84:	2000      	movs	r0, #0
 8025e86:	f7f8 fe45 	bl	801eb14 <lv_disp_get_dpi>
 8025e8a:	4603      	mov	r3, r0
 8025e8c:	461a      	mov	r2, r3
 8025e8e:	4613      	mov	r3, r2
 8025e90:	011b      	lsls	r3, r3, #4
 8025e92:	1a9b      	subs	r3, r3, r2
 8025e94:	005b      	lsls	r3, r3, #1
 8025e96:	2bef      	cmp	r3, #239	; 0xef
 8025e98:	dd11      	ble.n	8025ebe <gauge_init+0x4d6>
 8025e9a:	2000      	movs	r0, #0
 8025e9c:	f7f8 fe3a 	bl	801eb14 <lv_disp_get_dpi>
 8025ea0:	4603      	mov	r3, r0
 8025ea2:	461a      	mov	r2, r3
 8025ea4:	4613      	mov	r3, r2
 8025ea6:	011b      	lsls	r3, r3, #4
 8025ea8:	1a9b      	subs	r3, r3, r2
 8025eaa:	005b      	lsls	r3, r3, #1
 8025eac:	3350      	adds	r3, #80	; 0x50
 8025eae:	4a1c      	ldr	r2, [pc, #112]	; (8025f20 <gauge_init+0x538>)
 8025eb0:	fb82 1203 	smull	r1, r2, r2, r3
 8025eb4:	1192      	asrs	r2, r2, #6
 8025eb6:	17db      	asrs	r3, r3, #31
 8025eb8:	1ad3      	subs	r3, r2, r3
 8025eba:	b21b      	sxth	r3, r3
 8025ebc:	e000      	b.n	8025ec0 <gauge_init+0x4d8>
 8025ebe:	2301      	movs	r3, #1
 8025ec0:	461a      	mov	r2, r3
 8025ec2:	2100      	movs	r1, #0
 8025ec4:	4620      	mov	r0, r4
 8025ec6:	f7fd f984 	bl	80231d2 <lv_style_set_size>
    lv_style_set_pad_inner(&styles->gauge_needle, LV_STATE_DEFAULT, LV_DPX(10));
 8025eca:	4b14      	ldr	r3, [pc, #80]	; (8025f1c <gauge_init+0x534>)
 8025ecc:	681b      	ldr	r3, [r3, #0]
 8025ece:	f103 0468 	add.w	r4, r3, #104	; 0x68
 8025ed2:	2000      	movs	r0, #0
 8025ed4:	f7f8 fe1e 	bl	801eb14 <lv_disp_get_dpi>
 8025ed8:	4603      	mov	r3, r0
 8025eda:	461a      	mov	r2, r3
 8025edc:	4613      	mov	r3, r2
 8025ede:	009b      	lsls	r3, r3, #2
 8025ee0:	4413      	add	r3, r2
 8025ee2:	005b      	lsls	r3, r3, #1
 8025ee4:	2bef      	cmp	r3, #239	; 0xef
 8025ee6:	dd11      	ble.n	8025f0c <gauge_init+0x524>
 8025ee8:	2000      	movs	r0, #0
 8025eea:	f7f8 fe13 	bl	801eb14 <lv_disp_get_dpi>
 8025eee:	4603      	mov	r3, r0
 8025ef0:	461a      	mov	r2, r3
 8025ef2:	4613      	mov	r3, r2
 8025ef4:	009b      	lsls	r3, r3, #2
 8025ef6:	4413      	add	r3, r2
 8025ef8:	005b      	lsls	r3, r3, #1
 8025efa:	3350      	adds	r3, #80	; 0x50
 8025efc:	4a08      	ldr	r2, [pc, #32]	; (8025f20 <gauge_init+0x538>)
 8025efe:	fb82 1203 	smull	r1, r2, r2, r3
 8025f02:	1192      	asrs	r2, r2, #6
 8025f04:	17db      	asrs	r3, r3, #31
 8025f06:	1ad3      	subs	r3, r2, r3
 8025f08:	b21b      	sxth	r3, r3
 8025f0a:	e000      	b.n	8025f0e <gauge_init+0x526>
 8025f0c:	2301      	movs	r3, #1
 8025f0e:	461a      	mov	r2, r3
 8025f10:	2100      	movs	r1, #0
 8025f12:	4620      	mov	r0, r4
 8025f14:	f7fd f9ed 	bl	80232f2 <lv_style_set_pad_inner>
#endif
}
 8025f18:	bf00      	nop
 8025f1a:	bd98      	pop	{r3, r4, r7, pc}
 8025f1c:	20012350 	.word	0x20012350
 8025f20:	66666667 	.word	0x66666667
 8025f24:	20012328 	.word	0x20012328
 8025f28:	00464b5b 	.word	0x00464b5b
 8025f2c:	0802e594 	.word	0x0802e594

08025f30 <arc_init>:

static void arc_init(void)
{
 8025f30:	b598      	push	{r3, r4, r7, lr}
 8025f32:	af00      	add	r7, sp, #0
#if LV_USE_ARC != 0
    style_init_reset(&styles->arc_indic);
 8025f34:	4b5f      	ldr	r3, [pc, #380]	; (80260b4 <arc_init+0x184>)
 8025f36:	681b      	ldr	r3, [r3, #0]
 8025f38:	331c      	adds	r3, #28
 8025f3a:	4618      	mov	r0, r3
 8025f3c:	f003 fc66 	bl	802980c <style_init_reset>
    lv_style_set_line_color(&styles->arc_indic, LV_STATE_DEFAULT, theme.color_primary);
 8025f40:	4b5c      	ldr	r3, [pc, #368]	; (80260b4 <arc_init+0x184>)
 8025f42:	681b      	ldr	r3, [r3, #0]
 8025f44:	331c      	adds	r3, #28
 8025f46:	4a5c      	ldr	r2, [pc, #368]	; (80260b8 <arc_init+0x188>)
 8025f48:	8992      	ldrh	r2, [r2, #12]
 8025f4a:	2100      	movs	r1, #0
 8025f4c:	4618      	mov	r0, r3
 8025f4e:	f7fd fca7 	bl	80238a0 <lv_style_set_line_color>
    lv_style_set_line_width(&styles->arc_indic, LV_STATE_DEFAULT, LV_DPX(25));
 8025f52:	4b58      	ldr	r3, [pc, #352]	; (80260b4 <arc_init+0x184>)
 8025f54:	681b      	ldr	r3, [r3, #0]
 8025f56:	f103 041c 	add.w	r4, r3, #28
 8025f5a:	2000      	movs	r0, #0
 8025f5c:	f7f8 fdda 	bl	801eb14 <lv_disp_get_dpi>
 8025f60:	4603      	mov	r3, r0
 8025f62:	461a      	mov	r2, r3
 8025f64:	4613      	mov	r3, r2
 8025f66:	009b      	lsls	r3, r3, #2
 8025f68:	4413      	add	r3, r2
 8025f6a:	009a      	lsls	r2, r3, #2
 8025f6c:	4413      	add	r3, r2
 8025f6e:	2bef      	cmp	r3, #239	; 0xef
 8025f70:	dd12      	ble.n	8025f98 <arc_init+0x68>
 8025f72:	2000      	movs	r0, #0
 8025f74:	f7f8 fdce 	bl	801eb14 <lv_disp_get_dpi>
 8025f78:	4603      	mov	r3, r0
 8025f7a:	461a      	mov	r2, r3
 8025f7c:	4613      	mov	r3, r2
 8025f7e:	009b      	lsls	r3, r3, #2
 8025f80:	4413      	add	r3, r2
 8025f82:	009a      	lsls	r2, r3, #2
 8025f84:	4413      	add	r3, r2
 8025f86:	3350      	adds	r3, #80	; 0x50
 8025f88:	4a4c      	ldr	r2, [pc, #304]	; (80260bc <arc_init+0x18c>)
 8025f8a:	fb82 1203 	smull	r1, r2, r2, r3
 8025f8e:	1192      	asrs	r2, r2, #6
 8025f90:	17db      	asrs	r3, r3, #31
 8025f92:	1ad3      	subs	r3, r2, r3
 8025f94:	b21b      	sxth	r3, r3
 8025f96:	e000      	b.n	8025f9a <arc_init+0x6a>
 8025f98:	2301      	movs	r3, #1
 8025f9a:	461a      	mov	r2, r3
 8025f9c:	2100      	movs	r1, #0
 8025f9e:	4620      	mov	r0, r4
 8025fa0:	f7fd fc1e 	bl	80237e0 <lv_style_set_line_width>
    lv_style_set_line_rounded(&styles->arc_indic, LV_STATE_DEFAULT, true);
 8025fa4:	4b43      	ldr	r3, [pc, #268]	; (80260b4 <arc_init+0x184>)
 8025fa6:	681b      	ldr	r3, [r3, #0]
 8025fa8:	331c      	adds	r3, #28
 8025faa:	2201      	movs	r2, #1
 8025fac:	2100      	movs	r1, #0
 8025fae:	4618      	mov	r0, r3
 8025fb0:	f7fd fc5e 	bl	8023870 <lv_style_set_line_rounded>

    style_init_reset(&styles->arc_bg);
 8025fb4:	4b3f      	ldr	r3, [pc, #252]	; (80260b4 <arc_init+0x184>)
 8025fb6:	681b      	ldr	r3, [r3, #0]
 8025fb8:	3320      	adds	r3, #32
 8025fba:	4618      	mov	r0, r3
 8025fbc:	f003 fc26 	bl	802980c <style_init_reset>
    lv_style_set_line_color(&styles->arc_bg, LV_STATE_DEFAULT, COLOR_BG_SEC);
 8025fc0:	4b3c      	ldr	r3, [pc, #240]	; (80260b4 <arc_init+0x184>)
 8025fc2:	681b      	ldr	r3, [r3, #0]
 8025fc4:	f103 0420 	add.w	r4, r3, #32
 8025fc8:	4b3b      	ldr	r3, [pc, #236]	; (80260b8 <arc_init+0x188>)
 8025fca:	6a1b      	ldr	r3, [r3, #32]
 8025fcc:	f003 0302 	and.w	r3, r3, #2
 8025fd0:	2b00      	cmp	r3, #0
 8025fd2:	d004      	beq.n	8025fde <arc_init+0xae>
 8025fd4:	483a      	ldr	r0, [pc, #232]	; (80260c0 <arc_init+0x190>)
 8025fd6:	f7fd f886 	bl	80230e6 <lv_color_hex>
 8025fda:	4603      	mov	r3, r0
 8025fdc:	e003      	b.n	8025fe6 <arc_init+0xb6>
 8025fde:	4839      	ldr	r0, [pc, #228]	; (80260c4 <arc_init+0x194>)
 8025fe0:	f7fd f881 	bl	80230e6 <lv_color_hex>
 8025fe4:	4603      	mov	r3, r0
 8025fe6:	461a      	mov	r2, r3
 8025fe8:	2100      	movs	r1, #0
 8025fea:	4620      	mov	r0, r4
 8025fec:	f7fd fc58 	bl	80238a0 <lv_style_set_line_color>
    lv_style_set_line_width(&styles->arc_bg, LV_STATE_DEFAULT, LV_DPX(25));
 8025ff0:	4b30      	ldr	r3, [pc, #192]	; (80260b4 <arc_init+0x184>)
 8025ff2:	681b      	ldr	r3, [r3, #0]
 8025ff4:	f103 0420 	add.w	r4, r3, #32
 8025ff8:	2000      	movs	r0, #0
 8025ffa:	f7f8 fd8b 	bl	801eb14 <lv_disp_get_dpi>
 8025ffe:	4603      	mov	r3, r0
 8026000:	461a      	mov	r2, r3
 8026002:	4613      	mov	r3, r2
 8026004:	009b      	lsls	r3, r3, #2
 8026006:	4413      	add	r3, r2
 8026008:	009a      	lsls	r2, r3, #2
 802600a:	4413      	add	r3, r2
 802600c:	2bef      	cmp	r3, #239	; 0xef
 802600e:	dd12      	ble.n	8026036 <arc_init+0x106>
 8026010:	2000      	movs	r0, #0
 8026012:	f7f8 fd7f 	bl	801eb14 <lv_disp_get_dpi>
 8026016:	4603      	mov	r3, r0
 8026018:	461a      	mov	r2, r3
 802601a:	4613      	mov	r3, r2
 802601c:	009b      	lsls	r3, r3, #2
 802601e:	4413      	add	r3, r2
 8026020:	009a      	lsls	r2, r3, #2
 8026022:	4413      	add	r3, r2
 8026024:	3350      	adds	r3, #80	; 0x50
 8026026:	4a25      	ldr	r2, [pc, #148]	; (80260bc <arc_init+0x18c>)
 8026028:	fb82 1203 	smull	r1, r2, r2, r3
 802602c:	1192      	asrs	r2, r2, #6
 802602e:	17db      	asrs	r3, r3, #31
 8026030:	1ad3      	subs	r3, r2, r3
 8026032:	b21b      	sxth	r3, r3
 8026034:	e000      	b.n	8026038 <arc_init+0x108>
 8026036:	2301      	movs	r3, #1
 8026038:	461a      	mov	r2, r3
 802603a:	2100      	movs	r1, #0
 802603c:	4620      	mov	r0, r4
 802603e:	f7fd fbcf 	bl	80237e0 <lv_style_set_line_width>
    lv_style_set_line_rounded(&styles->arc_bg, LV_STATE_DEFAULT, true);
 8026042:	4b1c      	ldr	r3, [pc, #112]	; (80260b4 <arc_init+0x184>)
 8026044:	681b      	ldr	r3, [r3, #0]
 8026046:	3320      	adds	r3, #32
 8026048:	2201      	movs	r2, #1
 802604a:	2100      	movs	r1, #0
 802604c:	4618      	mov	r0, r3
 802604e:	f7fd fc0f 	bl	8023870 <lv_style_set_line_rounded>

    style_init_reset(&styles->arc_knob);
 8026052:	4b18      	ldr	r3, [pc, #96]	; (80260b4 <arc_init+0x184>)
 8026054:	681b      	ldr	r3, [r3, #0]
 8026056:	3324      	adds	r3, #36	; 0x24
 8026058:	4618      	mov	r0, r3
 802605a:	f003 fbd7 	bl	802980c <style_init_reset>
    lv_style_set_radius(&styles->arc_knob, LV_STATE_DEFAULT,   LV_RADIUS_CIRCLE);
 802605e:	4b15      	ldr	r3, [pc, #84]	; (80260b4 <arc_init+0x184>)
 8026060:	681b      	ldr	r3, [r3, #0]
 8026062:	3324      	adds	r3, #36	; 0x24
 8026064:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8026068:	2100      	movs	r1, #0
 802606a:	4618      	mov	r0, r3
 802606c:	f7fd f881 	bl	8023172 <lv_style_set_radius>
    lv_style_set_pad_top(&styles->arc_knob, LV_STATE_DEFAULT,  LV_DPX(0));
 8026070:	4b10      	ldr	r3, [pc, #64]	; (80260b4 <arc_init+0x184>)
 8026072:	681b      	ldr	r3, [r3, #0]
 8026074:	3324      	adds	r3, #36	; 0x24
 8026076:	2200      	movs	r2, #0
 8026078:	2100      	movs	r1, #0
 802607a:	4618      	mov	r0, r3
 802607c:	f7fd f8d9 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->arc_knob, LV_STATE_DEFAULT,  LV_DPX(0));
 8026080:	4b0c      	ldr	r3, [pc, #48]	; (80260b4 <arc_init+0x184>)
 8026082:	681b      	ldr	r3, [r3, #0]
 8026084:	3324      	adds	r3, #36	; 0x24
 8026086:	2200      	movs	r2, #0
 8026088:	2100      	movs	r1, #0
 802608a:	4618      	mov	r0, r3
 802608c:	f7fd f8e9 	bl	8023262 <lv_style_set_pad_bottom>
    lv_style_set_pad_left(&styles->arc_knob, LV_STATE_DEFAULT,    LV_DPX(0));
 8026090:	4b08      	ldr	r3, [pc, #32]	; (80260b4 <arc_init+0x184>)
 8026092:	681b      	ldr	r3, [r3, #0]
 8026094:	3324      	adds	r3, #36	; 0x24
 8026096:	2200      	movs	r2, #0
 8026098:	2100      	movs	r1, #0
 802609a:	4618      	mov	r0, r3
 802609c:	f7fd f8f9 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->arc_knob, LV_STATE_DEFAULT,   LV_DPX(0));
 80260a0:	4b04      	ldr	r3, [pc, #16]	; (80260b4 <arc_init+0x184>)
 80260a2:	681b      	ldr	r3, [r3, #0]
 80260a4:	3324      	adds	r3, #36	; 0x24
 80260a6:	2200      	movs	r2, #0
 80260a8:	2100      	movs	r1, #0
 80260aa:	4618      	mov	r0, r3
 80260ac:	f7fd f909 	bl	80232c2 <lv_style_set_pad_right>

#endif
}
 80260b0:	bf00      	nop
 80260b2:	bd98      	pop	{r3, r4, r7, pc}
 80260b4:	20012350 	.word	0x20012350
 80260b8:	20012328 	.word	0x20012328
 80260bc:	66666667 	.word	0x66666667
 80260c0:	00d4d7d9 	.word	0x00d4d7d9
 80260c4:	0045494d 	.word	0x0045494d

080260c8 <spinner_init>:

static void spinner_init(void)
{
 80260c8:	b480      	push	{r7}
 80260ca:	af00      	add	r7, sp, #0
#if LV_USE_SPINNER != 0
#endif
}
 80260cc:	bf00      	nop
 80260ce:	46bd      	mov	sp, r7
 80260d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80260d4:	4770      	bx	lr
	...

080260d8 <chart_init>:

static void chart_init(void)
{
 80260d8:	b598      	push	{r3, r4, r7, lr}
 80260da:	af00      	add	r7, sp, #0
#if LV_USE_CHART
    style_init_reset(&styles->chart_bg);
 80260dc:	4b9b      	ldr	r3, [pc, #620]	; (802634c <chart_init+0x274>)
 80260de:	681b      	ldr	r3, [r3, #0]
 80260e0:	3344      	adds	r3, #68	; 0x44
 80260e2:	4618      	mov	r0, r3
 80260e4:	f003 fb92 	bl	802980c <style_init_reset>
    lv_style_set_text_color(&styles->chart_bg, LV_STATE_DEFAULT, IS_LIGHT ? COLOR_BG_TEXT_DIS : lv_color_hex(0xa1adbd));
 80260e8:	4b98      	ldr	r3, [pc, #608]	; (802634c <chart_init+0x274>)
 80260ea:	681b      	ldr	r3, [r3, #0]
 80260ec:	f103 0444 	add.w	r4, r3, #68	; 0x44
 80260f0:	4b97      	ldr	r3, [pc, #604]	; (8026350 <chart_init+0x278>)
 80260f2:	6a1b      	ldr	r3, [r3, #32]
 80260f4:	f003 0302 	and.w	r3, r3, #2
 80260f8:	2b00      	cmp	r3, #0
 80260fa:	d011      	beq.n	8026120 <chart_init+0x48>
 80260fc:	4b94      	ldr	r3, [pc, #592]	; (8026350 <chart_init+0x278>)
 80260fe:	6a1b      	ldr	r3, [r3, #32]
 8026100:	f003 0302 	and.w	r3, r3, #2
 8026104:	2b00      	cmp	r3, #0
 8026106:	d005      	beq.n	8026114 <chart_init+0x3c>
 8026108:	f640 20aa 	movw	r0, #2730	; 0xaaa
 802610c:	f7fc ffff 	bl	802310e <lv_color_hex3>
 8026110:	4603      	mov	r3, r0
 8026112:	e009      	b.n	8026128 <chart_init+0x50>
 8026114:	f640 1099 	movw	r0, #2457	; 0x999
 8026118:	f7fc fff9 	bl	802310e <lv_color_hex3>
 802611c:	4603      	mov	r3, r0
 802611e:	e003      	b.n	8026128 <chart_init+0x50>
 8026120:	488c      	ldr	r0, [pc, #560]	; (8026354 <chart_init+0x27c>)
 8026122:	f7fc ffe0 	bl	80230e6 <lv_color_hex>
 8026126:	4603      	mov	r3, r0
 8026128:	461a      	mov	r2, r3
 802612a:	2100      	movs	r1, #0
 802612c:	4620      	mov	r0, r4
 802612e:	f7fd fb27 	bl	8023780 <lv_style_set_text_color>

    style_init_reset(&styles->chart_series_bg);
 8026132:	4b86      	ldr	r3, [pc, #536]	; (802634c <chart_init+0x274>)
 8026134:	681b      	ldr	r3, [r3, #0]
 8026136:	3348      	adds	r3, #72	; 0x48
 8026138:	4618      	mov	r0, r3
 802613a:	f003 fb67 	bl	802980c <style_init_reset>
    lv_style_set_line_width(&styles->chart_series_bg, LV_STATE_DEFAULT, LV_DPX(1));
 802613e:	4b83      	ldr	r3, [pc, #524]	; (802634c <chart_init+0x274>)
 8026140:	681b      	ldr	r3, [r3, #0]
 8026142:	f103 0448 	add.w	r4, r3, #72	; 0x48
 8026146:	2000      	movs	r0, #0
 8026148:	f7f8 fce4 	bl	801eb14 <lv_disp_get_dpi>
 802614c:	4603      	mov	r3, r0
 802614e:	2bef      	cmp	r3, #239	; 0xef
 8026150:	dd0c      	ble.n	802616c <chart_init+0x94>
 8026152:	2000      	movs	r0, #0
 8026154:	f7f8 fcde 	bl	801eb14 <lv_disp_get_dpi>
 8026158:	4603      	mov	r3, r0
 802615a:	3350      	adds	r3, #80	; 0x50
 802615c:	4a7e      	ldr	r2, [pc, #504]	; (8026358 <chart_init+0x280>)
 802615e:	fb82 1203 	smull	r1, r2, r2, r3
 8026162:	1192      	asrs	r2, r2, #6
 8026164:	17db      	asrs	r3, r3, #31
 8026166:	1ad3      	subs	r3, r2, r3
 8026168:	b21b      	sxth	r3, r3
 802616a:	e000      	b.n	802616e <chart_init+0x96>
 802616c:	2301      	movs	r3, #1
 802616e:	461a      	mov	r2, r3
 8026170:	2100      	movs	r1, #0
 8026172:	4620      	mov	r0, r4
 8026174:	f7fd fb34 	bl	80237e0 <lv_style_set_line_width>
    lv_style_set_line_dash_width(&styles->chart_series_bg, LV_STATE_DEFAULT, LV_DPX(10));
 8026178:	4b74      	ldr	r3, [pc, #464]	; (802634c <chart_init+0x274>)
 802617a:	681b      	ldr	r3, [r3, #0]
 802617c:	f103 0448 	add.w	r4, r3, #72	; 0x48
 8026180:	2000      	movs	r0, #0
 8026182:	f7f8 fcc7 	bl	801eb14 <lv_disp_get_dpi>
 8026186:	4603      	mov	r3, r0
 8026188:	461a      	mov	r2, r3
 802618a:	4613      	mov	r3, r2
 802618c:	009b      	lsls	r3, r3, #2
 802618e:	4413      	add	r3, r2
 8026190:	005b      	lsls	r3, r3, #1
 8026192:	2bef      	cmp	r3, #239	; 0xef
 8026194:	dd11      	ble.n	80261ba <chart_init+0xe2>
 8026196:	2000      	movs	r0, #0
 8026198:	f7f8 fcbc 	bl	801eb14 <lv_disp_get_dpi>
 802619c:	4603      	mov	r3, r0
 802619e:	461a      	mov	r2, r3
 80261a0:	4613      	mov	r3, r2
 80261a2:	009b      	lsls	r3, r3, #2
 80261a4:	4413      	add	r3, r2
 80261a6:	005b      	lsls	r3, r3, #1
 80261a8:	3350      	adds	r3, #80	; 0x50
 80261aa:	4a6b      	ldr	r2, [pc, #428]	; (8026358 <chart_init+0x280>)
 80261ac:	fb82 1203 	smull	r1, r2, r2, r3
 80261b0:	1192      	asrs	r2, r2, #6
 80261b2:	17db      	asrs	r3, r3, #31
 80261b4:	1ad3      	subs	r3, r2, r3
 80261b6:	b21b      	sxth	r3, r3
 80261b8:	e000      	b.n	80261bc <chart_init+0xe4>
 80261ba:	2301      	movs	r3, #1
 80261bc:	461a      	mov	r2, r3
 80261be:	2100      	movs	r1, #0
 80261c0:	4620      	mov	r0, r4
 80261c2:	f7fd fb25 	bl	8023810 <lv_style_set_line_dash_width>
    lv_style_set_line_dash_gap(&styles->chart_series_bg, LV_STATE_DEFAULT, LV_DPX(10));
 80261c6:	4b61      	ldr	r3, [pc, #388]	; (802634c <chart_init+0x274>)
 80261c8:	681b      	ldr	r3, [r3, #0]
 80261ca:	f103 0448 	add.w	r4, r3, #72	; 0x48
 80261ce:	2000      	movs	r0, #0
 80261d0:	f7f8 fca0 	bl	801eb14 <lv_disp_get_dpi>
 80261d4:	4603      	mov	r3, r0
 80261d6:	461a      	mov	r2, r3
 80261d8:	4613      	mov	r3, r2
 80261da:	009b      	lsls	r3, r3, #2
 80261dc:	4413      	add	r3, r2
 80261de:	005b      	lsls	r3, r3, #1
 80261e0:	2bef      	cmp	r3, #239	; 0xef
 80261e2:	dd11      	ble.n	8026208 <chart_init+0x130>
 80261e4:	2000      	movs	r0, #0
 80261e6:	f7f8 fc95 	bl	801eb14 <lv_disp_get_dpi>
 80261ea:	4603      	mov	r3, r0
 80261ec:	461a      	mov	r2, r3
 80261ee:	4613      	mov	r3, r2
 80261f0:	009b      	lsls	r3, r3, #2
 80261f2:	4413      	add	r3, r2
 80261f4:	005b      	lsls	r3, r3, #1
 80261f6:	3350      	adds	r3, #80	; 0x50
 80261f8:	4a57      	ldr	r2, [pc, #348]	; (8026358 <chart_init+0x280>)
 80261fa:	fb82 1203 	smull	r1, r2, r2, r3
 80261fe:	1192      	asrs	r2, r2, #6
 8026200:	17db      	asrs	r3, r3, #31
 8026202:	1ad3      	subs	r3, r2, r3
 8026204:	b21b      	sxth	r3, r3
 8026206:	e000      	b.n	802620a <chart_init+0x132>
 8026208:	2301      	movs	r3, #1
 802620a:	461a      	mov	r2, r3
 802620c:	2100      	movs	r1, #0
 802620e:	4620      	mov	r0, r4
 8026210:	f7fd fb16 	bl	8023840 <lv_style_set_line_dash_gap>
    lv_style_set_line_color(&styles->chart_series_bg, LV_STATE_DEFAULT, COLOR_BG_BORDER);
 8026214:	4b4d      	ldr	r3, [pc, #308]	; (802634c <chart_init+0x274>)
 8026216:	681b      	ldr	r3, [r3, #0]
 8026218:	f103 0448 	add.w	r4, r3, #72	; 0x48
 802621c:	4b4c      	ldr	r3, [pc, #304]	; (8026350 <chart_init+0x278>)
 802621e:	6a1b      	ldr	r3, [r3, #32]
 8026220:	f003 0302 	and.w	r3, r3, #2
 8026224:	2b00      	cmp	r3, #0
 8026226:	d004      	beq.n	8026232 <chart_init+0x15a>
 8026228:	484c      	ldr	r0, [pc, #304]	; (802635c <chart_init+0x284>)
 802622a:	f7fc ff5c 	bl	80230e6 <lv_color_hex>
 802622e:	4603      	mov	r3, r0
 8026230:	e003      	b.n	802623a <chart_init+0x162>
 8026232:	484b      	ldr	r0, [pc, #300]	; (8026360 <chart_init+0x288>)
 8026234:	f7fc ff57 	bl	80230e6 <lv_color_hex>
 8026238:	4603      	mov	r3, r0
 802623a:	461a      	mov	r2, r3
 802623c:	2100      	movs	r1, #0
 802623e:	4620      	mov	r0, r4
 8026240:	f7fd fb2e 	bl	80238a0 <lv_style_set_line_color>

    style_init_reset(&styles->chart_series);
 8026244:	4b41      	ldr	r3, [pc, #260]	; (802634c <chart_init+0x274>)
 8026246:	681b      	ldr	r3, [r3, #0]
 8026248:	334c      	adds	r3, #76	; 0x4c
 802624a:	4618      	mov	r0, r3
 802624c:	f003 fade 	bl	802980c <style_init_reset>
    lv_style_set_line_width(&styles->chart_series, LV_STATE_DEFAULT, LV_DPX(3));
 8026250:	4b3e      	ldr	r3, [pc, #248]	; (802634c <chart_init+0x274>)
 8026252:	681b      	ldr	r3, [r3, #0]
 8026254:	f103 044c 	add.w	r4, r3, #76	; 0x4c
 8026258:	2000      	movs	r0, #0
 802625a:	f7f8 fc5b 	bl	801eb14 <lv_disp_get_dpi>
 802625e:	4603      	mov	r3, r0
 8026260:	461a      	mov	r2, r3
 8026262:	4613      	mov	r3, r2
 8026264:	005b      	lsls	r3, r3, #1
 8026266:	4413      	add	r3, r2
 8026268:	2bef      	cmp	r3, #239	; 0xef
 802626a:	dd10      	ble.n	802628e <chart_init+0x1b6>
 802626c:	2000      	movs	r0, #0
 802626e:	f7f8 fc51 	bl	801eb14 <lv_disp_get_dpi>
 8026272:	4603      	mov	r3, r0
 8026274:	461a      	mov	r2, r3
 8026276:	4613      	mov	r3, r2
 8026278:	005b      	lsls	r3, r3, #1
 802627a:	4413      	add	r3, r2
 802627c:	3350      	adds	r3, #80	; 0x50
 802627e:	4a36      	ldr	r2, [pc, #216]	; (8026358 <chart_init+0x280>)
 8026280:	fb82 1203 	smull	r1, r2, r2, r3
 8026284:	1192      	asrs	r2, r2, #6
 8026286:	17db      	asrs	r3, r3, #31
 8026288:	1ad3      	subs	r3, r2, r3
 802628a:	b21b      	sxth	r3, r3
 802628c:	e000      	b.n	8026290 <chart_init+0x1b8>
 802628e:	2301      	movs	r3, #1
 8026290:	461a      	mov	r2, r3
 8026292:	2100      	movs	r1, #0
 8026294:	4620      	mov	r0, r4
 8026296:	f7fd faa3 	bl	80237e0 <lv_style_set_line_width>
    lv_style_set_size(&styles->chart_series, LV_STATE_DEFAULT, LV_DPX(4));
 802629a:	4b2c      	ldr	r3, [pc, #176]	; (802634c <chart_init+0x274>)
 802629c:	681b      	ldr	r3, [r3, #0]
 802629e:	f103 044c 	add.w	r4, r3, #76	; 0x4c
 80262a2:	2000      	movs	r0, #0
 80262a4:	f7f8 fc36 	bl	801eb14 <lv_disp_get_dpi>
 80262a8:	4603      	mov	r3, r0
 80262aa:	2b3b      	cmp	r3, #59	; 0x3b
 80262ac:	dd0c      	ble.n	80262c8 <chart_init+0x1f0>
 80262ae:	2000      	movs	r0, #0
 80262b0:	f7f8 fc30 	bl	801eb14 <lv_disp_get_dpi>
 80262b4:	4603      	mov	r3, r0
 80262b6:	3314      	adds	r3, #20
 80262b8:	4a27      	ldr	r2, [pc, #156]	; (8026358 <chart_init+0x280>)
 80262ba:	fb82 1203 	smull	r1, r2, r2, r3
 80262be:	1112      	asrs	r2, r2, #4
 80262c0:	17db      	asrs	r3, r3, #31
 80262c2:	1ad3      	subs	r3, r2, r3
 80262c4:	b21b      	sxth	r3, r3
 80262c6:	e000      	b.n	80262ca <chart_init+0x1f2>
 80262c8:	2301      	movs	r3, #1
 80262ca:	461a      	mov	r2, r3
 80262cc:	2100      	movs	r1, #0
 80262ce:	4620      	mov	r0, r4
 80262d0:	f7fc ff7f 	bl	80231d2 <lv_style_set_size>
    lv_style_set_pad_inner(&styles->chart_series, LV_STATE_DEFAULT, LV_DPX(2));     /*Space between columns*/
 80262d4:	4b1d      	ldr	r3, [pc, #116]	; (802634c <chart_init+0x274>)
 80262d6:	681b      	ldr	r3, [r3, #0]
 80262d8:	f103 044c 	add.w	r4, r3, #76	; 0x4c
 80262dc:	2000      	movs	r0, #0
 80262de:	f7f8 fc19 	bl	801eb14 <lv_disp_get_dpi>
 80262e2:	4603      	mov	r3, r0
 80262e4:	2b77      	cmp	r3, #119	; 0x77
 80262e6:	dd0c      	ble.n	8026302 <chart_init+0x22a>
 80262e8:	2000      	movs	r0, #0
 80262ea:	f7f8 fc13 	bl	801eb14 <lv_disp_get_dpi>
 80262ee:	4603      	mov	r3, r0
 80262f0:	3328      	adds	r3, #40	; 0x28
 80262f2:	4a19      	ldr	r2, [pc, #100]	; (8026358 <chart_init+0x280>)
 80262f4:	fb82 1203 	smull	r1, r2, r2, r3
 80262f8:	1152      	asrs	r2, r2, #5
 80262fa:	17db      	asrs	r3, r3, #31
 80262fc:	1ad3      	subs	r3, r2, r3
 80262fe:	b21b      	sxth	r3, r3
 8026300:	e000      	b.n	8026304 <chart_init+0x22c>
 8026302:	2301      	movs	r3, #1
 8026304:	461a      	mov	r2, r3
 8026306:	2100      	movs	r1, #0
 8026308:	4620      	mov	r0, r4
 802630a:	f7fc fff2 	bl	80232f2 <lv_style_set_pad_inner>
    lv_style_set_radius(&styles->chart_series, LV_STATE_DEFAULT, LV_DPX(1));
 802630e:	4b0f      	ldr	r3, [pc, #60]	; (802634c <chart_init+0x274>)
 8026310:	681b      	ldr	r3, [r3, #0]
 8026312:	f103 044c 	add.w	r4, r3, #76	; 0x4c
 8026316:	2000      	movs	r0, #0
 8026318:	f7f8 fbfc 	bl	801eb14 <lv_disp_get_dpi>
 802631c:	4603      	mov	r3, r0
 802631e:	2bef      	cmp	r3, #239	; 0xef
 8026320:	dd0c      	ble.n	802633c <chart_init+0x264>
 8026322:	2000      	movs	r0, #0
 8026324:	f7f8 fbf6 	bl	801eb14 <lv_disp_get_dpi>
 8026328:	4603      	mov	r3, r0
 802632a:	3350      	adds	r3, #80	; 0x50
 802632c:	4a0a      	ldr	r2, [pc, #40]	; (8026358 <chart_init+0x280>)
 802632e:	fb82 1203 	smull	r1, r2, r2, r3
 8026332:	1192      	asrs	r2, r2, #6
 8026334:	17db      	asrs	r3, r3, #31
 8026336:	1ad3      	subs	r3, r2, r3
 8026338:	b21b      	sxth	r3, r3
 802633a:	e000      	b.n	802633e <chart_init+0x266>
 802633c:	2301      	movs	r3, #1
 802633e:	461a      	mov	r2, r3
 8026340:	2100      	movs	r1, #0
 8026342:	4620      	mov	r0, r4
 8026344:	f7fc ff15 	bl	8023172 <lv_style_set_radius>

#endif
}
 8026348:	bf00      	nop
 802634a:	bd98      	pop	{r3, r4, r7, pc}
 802634c:	20012350 	.word	0x20012350
 8026350:	20012328 	.word	0x20012328
 8026354:	00a1adbd 	.word	0x00a1adbd
 8026358:	66666667 	.word	0x66666667
 802635c:	00d6dde3 	.word	0x00d6dde3
 8026360:	00808a97 	.word	0x00808a97

08026364 <calendar_init>:

static void calendar_init(void)
{
 8026364:	b598      	push	{r3, r4, r7, lr}
 8026366:	af00      	add	r7, sp, #0
#if LV_USE_CALENDAR

    style_init_reset(&styles->calendar_header);
 8026368:	4bc4      	ldr	r3, [pc, #784]	; (802667c <calendar_init+0x318>)
 802636a:	681b      	ldr	r3, [r3, #0]
 802636c:	3334      	adds	r3, #52	; 0x34
 802636e:	4618      	mov	r0, r3
 8026370:	f003 fa4c 	bl	802980c <style_init_reset>
    lv_style_set_pad_top(&styles->calendar_header, LV_STATE_DEFAULT, PAD_DEF);
 8026374:	4bc1      	ldr	r3, [pc, #772]	; (802667c <calendar_init+0x318>)
 8026376:	681b      	ldr	r3, [r3, #0]
 8026378:	f103 0434 	add.w	r4, r3, #52	; 0x34
 802637c:	2000      	movs	r0, #0
 802637e:	f7f8 fbe2 	bl	801eb46 <lv_disp_get_size_category>
 8026382:	4603      	mov	r3, r0
 8026384:	2b01      	cmp	r3, #1
 8026386:	d81c      	bhi.n	80263c2 <calendar_init+0x5e>
 8026388:	2000      	movs	r0, #0
 802638a:	f7f8 fbc3 	bl	801eb14 <lv_disp_get_dpi>
 802638e:	4603      	mov	r3, r0
 8026390:	461a      	mov	r2, r3
 8026392:	4613      	mov	r3, r2
 8026394:	011b      	lsls	r3, r3, #4
 8026396:	1a9b      	subs	r3, r3, r2
 8026398:	2bef      	cmp	r3, #239	; 0xef
 802639a:	dd10      	ble.n	80263be <calendar_init+0x5a>
 802639c:	2000      	movs	r0, #0
 802639e:	f7f8 fbb9 	bl	801eb14 <lv_disp_get_dpi>
 80263a2:	4603      	mov	r3, r0
 80263a4:	461a      	mov	r2, r3
 80263a6:	4613      	mov	r3, r2
 80263a8:	011b      	lsls	r3, r3, #4
 80263aa:	1a9b      	subs	r3, r3, r2
 80263ac:	3350      	adds	r3, #80	; 0x50
 80263ae:	4ab4      	ldr	r2, [pc, #720]	; (8026680 <calendar_init+0x31c>)
 80263b0:	fb82 1203 	smull	r1, r2, r2, r3
 80263b4:	1192      	asrs	r2, r2, #6
 80263b6:	17db      	asrs	r3, r3, #31
 80263b8:	1ad3      	subs	r3, r2, r3
 80263ba:	b21b      	sxth	r3, r3
 80263bc:	e01f      	b.n	80263fe <calendar_init+0x9a>
 80263be:	2301      	movs	r3, #1
 80263c0:	e01d      	b.n	80263fe <calendar_init+0x9a>
 80263c2:	2000      	movs	r0, #0
 80263c4:	f7f8 fba6 	bl	801eb14 <lv_disp_get_dpi>
 80263c8:	4603      	mov	r3, r0
 80263ca:	461a      	mov	r2, r3
 80263cc:	4613      	mov	r3, r2
 80263ce:	011b      	lsls	r3, r3, #4
 80263d0:	1a9b      	subs	r3, r3, r2
 80263d2:	005b      	lsls	r3, r3, #1
 80263d4:	2bef      	cmp	r3, #239	; 0xef
 80263d6:	dd11      	ble.n	80263fc <calendar_init+0x98>
 80263d8:	2000      	movs	r0, #0
 80263da:	f7f8 fb9b 	bl	801eb14 <lv_disp_get_dpi>
 80263de:	4603      	mov	r3, r0
 80263e0:	461a      	mov	r2, r3
 80263e2:	4613      	mov	r3, r2
 80263e4:	011b      	lsls	r3, r3, #4
 80263e6:	1a9b      	subs	r3, r3, r2
 80263e8:	005b      	lsls	r3, r3, #1
 80263ea:	3350      	adds	r3, #80	; 0x50
 80263ec:	4aa4      	ldr	r2, [pc, #656]	; (8026680 <calendar_init+0x31c>)
 80263ee:	fb82 1203 	smull	r1, r2, r2, r3
 80263f2:	1192      	asrs	r2, r2, #6
 80263f4:	17db      	asrs	r3, r3, #31
 80263f6:	1ad3      	subs	r3, r2, r3
 80263f8:	b21b      	sxth	r3, r3
 80263fa:	e000      	b.n	80263fe <calendar_init+0x9a>
 80263fc:	2301      	movs	r3, #1
 80263fe:	461a      	mov	r2, r3
 8026400:	2100      	movs	r1, #0
 8026402:	4620      	mov	r0, r4
 8026404:	f7fc ff15 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_left(&styles->calendar_header, LV_STATE_DEFAULT, PAD_DEF);
 8026408:	4b9c      	ldr	r3, [pc, #624]	; (802667c <calendar_init+0x318>)
 802640a:	681b      	ldr	r3, [r3, #0]
 802640c:	f103 0434 	add.w	r4, r3, #52	; 0x34
 8026410:	2000      	movs	r0, #0
 8026412:	f7f8 fb98 	bl	801eb46 <lv_disp_get_size_category>
 8026416:	4603      	mov	r3, r0
 8026418:	2b01      	cmp	r3, #1
 802641a:	d81c      	bhi.n	8026456 <calendar_init+0xf2>
 802641c:	2000      	movs	r0, #0
 802641e:	f7f8 fb79 	bl	801eb14 <lv_disp_get_dpi>
 8026422:	4603      	mov	r3, r0
 8026424:	461a      	mov	r2, r3
 8026426:	4613      	mov	r3, r2
 8026428:	011b      	lsls	r3, r3, #4
 802642a:	1a9b      	subs	r3, r3, r2
 802642c:	2bef      	cmp	r3, #239	; 0xef
 802642e:	dd10      	ble.n	8026452 <calendar_init+0xee>
 8026430:	2000      	movs	r0, #0
 8026432:	f7f8 fb6f 	bl	801eb14 <lv_disp_get_dpi>
 8026436:	4603      	mov	r3, r0
 8026438:	461a      	mov	r2, r3
 802643a:	4613      	mov	r3, r2
 802643c:	011b      	lsls	r3, r3, #4
 802643e:	1a9b      	subs	r3, r3, r2
 8026440:	3350      	adds	r3, #80	; 0x50
 8026442:	4a8f      	ldr	r2, [pc, #572]	; (8026680 <calendar_init+0x31c>)
 8026444:	fb82 1203 	smull	r1, r2, r2, r3
 8026448:	1192      	asrs	r2, r2, #6
 802644a:	17db      	asrs	r3, r3, #31
 802644c:	1ad3      	subs	r3, r2, r3
 802644e:	b21b      	sxth	r3, r3
 8026450:	e01f      	b.n	8026492 <calendar_init+0x12e>
 8026452:	2301      	movs	r3, #1
 8026454:	e01d      	b.n	8026492 <calendar_init+0x12e>
 8026456:	2000      	movs	r0, #0
 8026458:	f7f8 fb5c 	bl	801eb14 <lv_disp_get_dpi>
 802645c:	4603      	mov	r3, r0
 802645e:	461a      	mov	r2, r3
 8026460:	4613      	mov	r3, r2
 8026462:	011b      	lsls	r3, r3, #4
 8026464:	1a9b      	subs	r3, r3, r2
 8026466:	005b      	lsls	r3, r3, #1
 8026468:	2bef      	cmp	r3, #239	; 0xef
 802646a:	dd11      	ble.n	8026490 <calendar_init+0x12c>
 802646c:	2000      	movs	r0, #0
 802646e:	f7f8 fb51 	bl	801eb14 <lv_disp_get_dpi>
 8026472:	4603      	mov	r3, r0
 8026474:	461a      	mov	r2, r3
 8026476:	4613      	mov	r3, r2
 8026478:	011b      	lsls	r3, r3, #4
 802647a:	1a9b      	subs	r3, r3, r2
 802647c:	005b      	lsls	r3, r3, #1
 802647e:	3350      	adds	r3, #80	; 0x50
 8026480:	4a7f      	ldr	r2, [pc, #508]	; (8026680 <calendar_init+0x31c>)
 8026482:	fb82 1203 	smull	r1, r2, r2, r3
 8026486:	1192      	asrs	r2, r2, #6
 8026488:	17db      	asrs	r3, r3, #31
 802648a:	1ad3      	subs	r3, r2, r3
 802648c:	b21b      	sxth	r3, r3
 802648e:	e000      	b.n	8026492 <calendar_init+0x12e>
 8026490:	2301      	movs	r3, #1
 8026492:	461a      	mov	r2, r3
 8026494:	2100      	movs	r1, #0
 8026496:	4620      	mov	r0, r4
 8026498:	f7fc fefb 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->calendar_header, LV_STATE_DEFAULT, PAD_DEF);
 802649c:	4b77      	ldr	r3, [pc, #476]	; (802667c <calendar_init+0x318>)
 802649e:	681b      	ldr	r3, [r3, #0]
 80264a0:	f103 0434 	add.w	r4, r3, #52	; 0x34
 80264a4:	2000      	movs	r0, #0
 80264a6:	f7f8 fb4e 	bl	801eb46 <lv_disp_get_size_category>
 80264aa:	4603      	mov	r3, r0
 80264ac:	2b01      	cmp	r3, #1
 80264ae:	d81c      	bhi.n	80264ea <calendar_init+0x186>
 80264b0:	2000      	movs	r0, #0
 80264b2:	f7f8 fb2f 	bl	801eb14 <lv_disp_get_dpi>
 80264b6:	4603      	mov	r3, r0
 80264b8:	461a      	mov	r2, r3
 80264ba:	4613      	mov	r3, r2
 80264bc:	011b      	lsls	r3, r3, #4
 80264be:	1a9b      	subs	r3, r3, r2
 80264c0:	2bef      	cmp	r3, #239	; 0xef
 80264c2:	dd10      	ble.n	80264e6 <calendar_init+0x182>
 80264c4:	2000      	movs	r0, #0
 80264c6:	f7f8 fb25 	bl	801eb14 <lv_disp_get_dpi>
 80264ca:	4603      	mov	r3, r0
 80264cc:	461a      	mov	r2, r3
 80264ce:	4613      	mov	r3, r2
 80264d0:	011b      	lsls	r3, r3, #4
 80264d2:	1a9b      	subs	r3, r3, r2
 80264d4:	3350      	adds	r3, #80	; 0x50
 80264d6:	4a6a      	ldr	r2, [pc, #424]	; (8026680 <calendar_init+0x31c>)
 80264d8:	fb82 1203 	smull	r1, r2, r2, r3
 80264dc:	1192      	asrs	r2, r2, #6
 80264de:	17db      	asrs	r3, r3, #31
 80264e0:	1ad3      	subs	r3, r2, r3
 80264e2:	b21b      	sxth	r3, r3
 80264e4:	e01f      	b.n	8026526 <calendar_init+0x1c2>
 80264e6:	2301      	movs	r3, #1
 80264e8:	e01d      	b.n	8026526 <calendar_init+0x1c2>
 80264ea:	2000      	movs	r0, #0
 80264ec:	f7f8 fb12 	bl	801eb14 <lv_disp_get_dpi>
 80264f0:	4603      	mov	r3, r0
 80264f2:	461a      	mov	r2, r3
 80264f4:	4613      	mov	r3, r2
 80264f6:	011b      	lsls	r3, r3, #4
 80264f8:	1a9b      	subs	r3, r3, r2
 80264fa:	005b      	lsls	r3, r3, #1
 80264fc:	2bef      	cmp	r3, #239	; 0xef
 80264fe:	dd11      	ble.n	8026524 <calendar_init+0x1c0>
 8026500:	2000      	movs	r0, #0
 8026502:	f7f8 fb07 	bl	801eb14 <lv_disp_get_dpi>
 8026506:	4603      	mov	r3, r0
 8026508:	461a      	mov	r2, r3
 802650a:	4613      	mov	r3, r2
 802650c:	011b      	lsls	r3, r3, #4
 802650e:	1a9b      	subs	r3, r3, r2
 8026510:	005b      	lsls	r3, r3, #1
 8026512:	3350      	adds	r3, #80	; 0x50
 8026514:	4a5a      	ldr	r2, [pc, #360]	; (8026680 <calendar_init+0x31c>)
 8026516:	fb82 1203 	smull	r1, r2, r2, r3
 802651a:	1192      	asrs	r2, r2, #6
 802651c:	17db      	asrs	r3, r3, #31
 802651e:	1ad3      	subs	r3, r2, r3
 8026520:	b21b      	sxth	r3, r3
 8026522:	e000      	b.n	8026526 <calendar_init+0x1c2>
 8026524:	2301      	movs	r3, #1
 8026526:	461a      	mov	r2, r3
 8026528:	2100      	movs	r1, #0
 802652a:	4620      	mov	r0, r4
 802652c:	f7fc fec9 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_bottom(&styles->calendar_header, LV_STATE_DEFAULT, PAD_DEF);
 8026530:	4b52      	ldr	r3, [pc, #328]	; (802667c <calendar_init+0x318>)
 8026532:	681b      	ldr	r3, [r3, #0]
 8026534:	f103 0434 	add.w	r4, r3, #52	; 0x34
 8026538:	2000      	movs	r0, #0
 802653a:	f7f8 fb04 	bl	801eb46 <lv_disp_get_size_category>
 802653e:	4603      	mov	r3, r0
 8026540:	2b01      	cmp	r3, #1
 8026542:	d81c      	bhi.n	802657e <calendar_init+0x21a>
 8026544:	2000      	movs	r0, #0
 8026546:	f7f8 fae5 	bl	801eb14 <lv_disp_get_dpi>
 802654a:	4603      	mov	r3, r0
 802654c:	461a      	mov	r2, r3
 802654e:	4613      	mov	r3, r2
 8026550:	011b      	lsls	r3, r3, #4
 8026552:	1a9b      	subs	r3, r3, r2
 8026554:	2bef      	cmp	r3, #239	; 0xef
 8026556:	dd10      	ble.n	802657a <calendar_init+0x216>
 8026558:	2000      	movs	r0, #0
 802655a:	f7f8 fadb 	bl	801eb14 <lv_disp_get_dpi>
 802655e:	4603      	mov	r3, r0
 8026560:	461a      	mov	r2, r3
 8026562:	4613      	mov	r3, r2
 8026564:	011b      	lsls	r3, r3, #4
 8026566:	1a9b      	subs	r3, r3, r2
 8026568:	3350      	adds	r3, #80	; 0x50
 802656a:	4a45      	ldr	r2, [pc, #276]	; (8026680 <calendar_init+0x31c>)
 802656c:	fb82 1203 	smull	r1, r2, r2, r3
 8026570:	1192      	asrs	r2, r2, #6
 8026572:	17db      	asrs	r3, r3, #31
 8026574:	1ad3      	subs	r3, r2, r3
 8026576:	b21b      	sxth	r3, r3
 8026578:	e01f      	b.n	80265ba <calendar_init+0x256>
 802657a:	2301      	movs	r3, #1
 802657c:	e01d      	b.n	80265ba <calendar_init+0x256>
 802657e:	2000      	movs	r0, #0
 8026580:	f7f8 fac8 	bl	801eb14 <lv_disp_get_dpi>
 8026584:	4603      	mov	r3, r0
 8026586:	461a      	mov	r2, r3
 8026588:	4613      	mov	r3, r2
 802658a:	011b      	lsls	r3, r3, #4
 802658c:	1a9b      	subs	r3, r3, r2
 802658e:	005b      	lsls	r3, r3, #1
 8026590:	2bef      	cmp	r3, #239	; 0xef
 8026592:	dd11      	ble.n	80265b8 <calendar_init+0x254>
 8026594:	2000      	movs	r0, #0
 8026596:	f7f8 fabd 	bl	801eb14 <lv_disp_get_dpi>
 802659a:	4603      	mov	r3, r0
 802659c:	461a      	mov	r2, r3
 802659e:	4613      	mov	r3, r2
 80265a0:	011b      	lsls	r3, r3, #4
 80265a2:	1a9b      	subs	r3, r3, r2
 80265a4:	005b      	lsls	r3, r3, #1
 80265a6:	3350      	adds	r3, #80	; 0x50
 80265a8:	4a35      	ldr	r2, [pc, #212]	; (8026680 <calendar_init+0x31c>)
 80265aa:	fb82 1203 	smull	r1, r2, r2, r3
 80265ae:	1192      	asrs	r2, r2, #6
 80265b0:	17db      	asrs	r3, r3, #31
 80265b2:	1ad3      	subs	r3, r2, r3
 80265b4:	b21b      	sxth	r3, r3
 80265b6:	e000      	b.n	80265ba <calendar_init+0x256>
 80265b8:	2301      	movs	r3, #1
 80265ba:	461a      	mov	r2, r3
 80265bc:	2100      	movs	r1, #0
 80265be:	4620      	mov	r0, r4
 80265c0:	f7fc fe4f 	bl	8023262 <lv_style_set_pad_bottom>
    lv_style_set_text_color(&styles->calendar_header, LV_STATE_PRESSED, IS_LIGHT ? lv_color_hex(0x888888) : LV_COLOR_WHITE);
 80265c4:	4b2d      	ldr	r3, [pc, #180]	; (802667c <calendar_init+0x318>)
 80265c6:	681b      	ldr	r3, [r3, #0]
 80265c8:	f103 0434 	add.w	r4, r3, #52	; 0x34
 80265cc:	4b2d      	ldr	r3, [pc, #180]	; (8026684 <calendar_init+0x320>)
 80265ce:	6a1b      	ldr	r3, [r3, #32]
 80265d0:	f003 0302 	and.w	r3, r3, #2
 80265d4:	2b00      	cmp	r3, #0
 80265d6:	d004      	beq.n	80265e2 <calendar_init+0x27e>
 80265d8:	482b      	ldr	r0, [pc, #172]	; (8026688 <calendar_init+0x324>)
 80265da:	f7fc fd84 	bl	80230e6 <lv_color_hex>
 80265de:	4603      	mov	r3, r0
 80265e0:	e001      	b.n	80265e6 <calendar_init+0x282>
 80265e2:	4b2a      	ldr	r3, [pc, #168]	; (802668c <calendar_init+0x328>)
 80265e4:	881b      	ldrh	r3, [r3, #0]
 80265e6:	461a      	mov	r2, r3
 80265e8:	2110      	movs	r1, #16
 80265ea:	4620      	mov	r0, r4
 80265ec:	f7fd f8c8 	bl	8023780 <lv_style_set_text_color>

    style_init_reset(&styles->calendar_daynames);
 80265f0:	4b22      	ldr	r3, [pc, #136]	; (802667c <calendar_init+0x318>)
 80265f2:	681b      	ldr	r3, [r3, #0]
 80265f4:	3338      	adds	r3, #56	; 0x38
 80265f6:	4618      	mov	r0, r3
 80265f8:	f003 f908 	bl	802980c <style_init_reset>
    lv_style_set_text_color(&styles->calendar_daynames, LV_STATE_DEFAULT,
 80265fc:	4b1f      	ldr	r3, [pc, #124]	; (802667c <calendar_init+0x318>)
 80265fe:	681b      	ldr	r3, [r3, #0]
 8026600:	f103 0438 	add.w	r4, r3, #56	; 0x38
                            IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex3(0xeee));
 8026604:	4b1f      	ldr	r3, [pc, #124]	; (8026684 <calendar_init+0x320>)
 8026606:	6a1b      	ldr	r3, [r3, #32]
 8026608:	f003 0302 	and.w	r3, r3, #2
    lv_style_set_text_color(&styles->calendar_daynames, LV_STATE_DEFAULT,
 802660c:	2b00      	cmp	r3, #0
 802660e:	d004      	beq.n	802661a <calendar_init+0x2b6>
                            IS_LIGHT ? lv_color_hex(0x31404f) : lv_color_hex3(0xeee));
 8026610:	481f      	ldr	r0, [pc, #124]	; (8026690 <calendar_init+0x32c>)
 8026612:	f7fc fd68 	bl	80230e6 <lv_color_hex>
 8026616:	4603      	mov	r3, r0
 8026618:	e004      	b.n	8026624 <calendar_init+0x2c0>
 802661a:	f640 60ee 	movw	r0, #3822	; 0xeee
 802661e:	f7fc fd76 	bl	802310e <lv_color_hex3>
 8026622:	4603      	mov	r3, r0
    lv_style_set_text_color(&styles->calendar_daynames, LV_STATE_DEFAULT,
 8026624:	461a      	mov	r2, r3
 8026626:	2100      	movs	r1, #0
 8026628:	4620      	mov	r0, r4
 802662a:	f7fd f8a9 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_pad_left(&styles->calendar_daynames, LV_STATE_DEFAULT, PAD_DEF);
 802662e:	4b13      	ldr	r3, [pc, #76]	; (802667c <calendar_init+0x318>)
 8026630:	681b      	ldr	r3, [r3, #0]
 8026632:	f103 0438 	add.w	r4, r3, #56	; 0x38
 8026636:	2000      	movs	r0, #0
 8026638:	f7f8 fa85 	bl	801eb46 <lv_disp_get_size_category>
 802663c:	4603      	mov	r3, r0
 802663e:	2b01      	cmp	r3, #1
 8026640:	d828      	bhi.n	8026694 <calendar_init+0x330>
 8026642:	2000      	movs	r0, #0
 8026644:	f7f8 fa66 	bl	801eb14 <lv_disp_get_dpi>
 8026648:	4603      	mov	r3, r0
 802664a:	461a      	mov	r2, r3
 802664c:	4613      	mov	r3, r2
 802664e:	011b      	lsls	r3, r3, #4
 8026650:	1a9b      	subs	r3, r3, r2
 8026652:	2bef      	cmp	r3, #239	; 0xef
 8026654:	dd10      	ble.n	8026678 <calendar_init+0x314>
 8026656:	2000      	movs	r0, #0
 8026658:	f7f8 fa5c 	bl	801eb14 <lv_disp_get_dpi>
 802665c:	4603      	mov	r3, r0
 802665e:	461a      	mov	r2, r3
 8026660:	4613      	mov	r3, r2
 8026662:	011b      	lsls	r3, r3, #4
 8026664:	1a9b      	subs	r3, r3, r2
 8026666:	3350      	adds	r3, #80	; 0x50
 8026668:	4a05      	ldr	r2, [pc, #20]	; (8026680 <calendar_init+0x31c>)
 802666a:	fb82 1203 	smull	r1, r2, r2, r3
 802666e:	1192      	asrs	r2, r2, #6
 8026670:	17db      	asrs	r3, r3, #31
 8026672:	1ad3      	subs	r3, r2, r3
 8026674:	b21b      	sxth	r3, r3
 8026676:	e02b      	b.n	80266d0 <calendar_init+0x36c>
 8026678:	2301      	movs	r3, #1
 802667a:	e029      	b.n	80266d0 <calendar_init+0x36c>
 802667c:	20012350 	.word	0x20012350
 8026680:	66666667 	.word	0x66666667
 8026684:	20012328 	.word	0x20012328
 8026688:	00888888 	.word	0x00888888
 802668c:	0802e594 	.word	0x0802e594
 8026690:	0031404f 	.word	0x0031404f
 8026694:	2000      	movs	r0, #0
 8026696:	f7f8 fa3d 	bl	801eb14 <lv_disp_get_dpi>
 802669a:	4603      	mov	r3, r0
 802669c:	461a      	mov	r2, r3
 802669e:	4613      	mov	r3, r2
 80266a0:	011b      	lsls	r3, r3, #4
 80266a2:	1a9b      	subs	r3, r3, r2
 80266a4:	005b      	lsls	r3, r3, #1
 80266a6:	2bef      	cmp	r3, #239	; 0xef
 80266a8:	dd11      	ble.n	80266ce <calendar_init+0x36a>
 80266aa:	2000      	movs	r0, #0
 80266ac:	f7f8 fa32 	bl	801eb14 <lv_disp_get_dpi>
 80266b0:	4603      	mov	r3, r0
 80266b2:	461a      	mov	r2, r3
 80266b4:	4613      	mov	r3, r2
 80266b6:	011b      	lsls	r3, r3, #4
 80266b8:	1a9b      	subs	r3, r3, r2
 80266ba:	005b      	lsls	r3, r3, #1
 80266bc:	3350      	adds	r3, #80	; 0x50
 80266be:	4ab7      	ldr	r2, [pc, #732]	; (802699c <calendar_init+0x638>)
 80266c0:	fb82 1203 	smull	r1, r2, r2, r3
 80266c4:	1192      	asrs	r2, r2, #6
 80266c6:	17db      	asrs	r3, r3, #31
 80266c8:	1ad3      	subs	r3, r2, r3
 80266ca:	b21b      	sxth	r3, r3
 80266cc:	e000      	b.n	80266d0 <calendar_init+0x36c>
 80266ce:	2301      	movs	r3, #1
 80266d0:	461a      	mov	r2, r3
 80266d2:	2100      	movs	r1, #0
 80266d4:	4620      	mov	r0, r4
 80266d6:	f7fc fddc 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->calendar_daynames, LV_STATE_DEFAULT, PAD_DEF);
 80266da:	4bb1      	ldr	r3, [pc, #708]	; (80269a0 <calendar_init+0x63c>)
 80266dc:	681b      	ldr	r3, [r3, #0]
 80266de:	f103 0438 	add.w	r4, r3, #56	; 0x38
 80266e2:	2000      	movs	r0, #0
 80266e4:	f7f8 fa2f 	bl	801eb46 <lv_disp_get_size_category>
 80266e8:	4603      	mov	r3, r0
 80266ea:	2b01      	cmp	r3, #1
 80266ec:	d81c      	bhi.n	8026728 <calendar_init+0x3c4>
 80266ee:	2000      	movs	r0, #0
 80266f0:	f7f8 fa10 	bl	801eb14 <lv_disp_get_dpi>
 80266f4:	4603      	mov	r3, r0
 80266f6:	461a      	mov	r2, r3
 80266f8:	4613      	mov	r3, r2
 80266fa:	011b      	lsls	r3, r3, #4
 80266fc:	1a9b      	subs	r3, r3, r2
 80266fe:	2bef      	cmp	r3, #239	; 0xef
 8026700:	dd10      	ble.n	8026724 <calendar_init+0x3c0>
 8026702:	2000      	movs	r0, #0
 8026704:	f7f8 fa06 	bl	801eb14 <lv_disp_get_dpi>
 8026708:	4603      	mov	r3, r0
 802670a:	461a      	mov	r2, r3
 802670c:	4613      	mov	r3, r2
 802670e:	011b      	lsls	r3, r3, #4
 8026710:	1a9b      	subs	r3, r3, r2
 8026712:	3350      	adds	r3, #80	; 0x50
 8026714:	4aa1      	ldr	r2, [pc, #644]	; (802699c <calendar_init+0x638>)
 8026716:	fb82 1203 	smull	r1, r2, r2, r3
 802671a:	1192      	asrs	r2, r2, #6
 802671c:	17db      	asrs	r3, r3, #31
 802671e:	1ad3      	subs	r3, r2, r3
 8026720:	b21b      	sxth	r3, r3
 8026722:	e01f      	b.n	8026764 <calendar_init+0x400>
 8026724:	2301      	movs	r3, #1
 8026726:	e01d      	b.n	8026764 <calendar_init+0x400>
 8026728:	2000      	movs	r0, #0
 802672a:	f7f8 f9f3 	bl	801eb14 <lv_disp_get_dpi>
 802672e:	4603      	mov	r3, r0
 8026730:	461a      	mov	r2, r3
 8026732:	4613      	mov	r3, r2
 8026734:	011b      	lsls	r3, r3, #4
 8026736:	1a9b      	subs	r3, r3, r2
 8026738:	005b      	lsls	r3, r3, #1
 802673a:	2bef      	cmp	r3, #239	; 0xef
 802673c:	dd11      	ble.n	8026762 <calendar_init+0x3fe>
 802673e:	2000      	movs	r0, #0
 8026740:	f7f8 f9e8 	bl	801eb14 <lv_disp_get_dpi>
 8026744:	4603      	mov	r3, r0
 8026746:	461a      	mov	r2, r3
 8026748:	4613      	mov	r3, r2
 802674a:	011b      	lsls	r3, r3, #4
 802674c:	1a9b      	subs	r3, r3, r2
 802674e:	005b      	lsls	r3, r3, #1
 8026750:	3350      	adds	r3, #80	; 0x50
 8026752:	4a92      	ldr	r2, [pc, #584]	; (802699c <calendar_init+0x638>)
 8026754:	fb82 1203 	smull	r1, r2, r2, r3
 8026758:	1192      	asrs	r2, r2, #6
 802675a:	17db      	asrs	r3, r3, #31
 802675c:	1ad3      	subs	r3, r2, r3
 802675e:	b21b      	sxth	r3, r3
 8026760:	e000      	b.n	8026764 <calendar_init+0x400>
 8026762:	2301      	movs	r3, #1
 8026764:	461a      	mov	r2, r3
 8026766:	2100      	movs	r1, #0
 8026768:	4620      	mov	r0, r4
 802676a:	f7fc fdaa 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_bottom(&styles->calendar_daynames, LV_STATE_DEFAULT, PAD_DEF);
 802676e:	4b8c      	ldr	r3, [pc, #560]	; (80269a0 <calendar_init+0x63c>)
 8026770:	681b      	ldr	r3, [r3, #0]
 8026772:	f103 0438 	add.w	r4, r3, #56	; 0x38
 8026776:	2000      	movs	r0, #0
 8026778:	f7f8 f9e5 	bl	801eb46 <lv_disp_get_size_category>
 802677c:	4603      	mov	r3, r0
 802677e:	2b01      	cmp	r3, #1
 8026780:	d81c      	bhi.n	80267bc <calendar_init+0x458>
 8026782:	2000      	movs	r0, #0
 8026784:	f7f8 f9c6 	bl	801eb14 <lv_disp_get_dpi>
 8026788:	4603      	mov	r3, r0
 802678a:	461a      	mov	r2, r3
 802678c:	4613      	mov	r3, r2
 802678e:	011b      	lsls	r3, r3, #4
 8026790:	1a9b      	subs	r3, r3, r2
 8026792:	2bef      	cmp	r3, #239	; 0xef
 8026794:	dd10      	ble.n	80267b8 <calendar_init+0x454>
 8026796:	2000      	movs	r0, #0
 8026798:	f7f8 f9bc 	bl	801eb14 <lv_disp_get_dpi>
 802679c:	4603      	mov	r3, r0
 802679e:	461a      	mov	r2, r3
 80267a0:	4613      	mov	r3, r2
 80267a2:	011b      	lsls	r3, r3, #4
 80267a4:	1a9b      	subs	r3, r3, r2
 80267a6:	3350      	adds	r3, #80	; 0x50
 80267a8:	4a7c      	ldr	r2, [pc, #496]	; (802699c <calendar_init+0x638>)
 80267aa:	fb82 1203 	smull	r1, r2, r2, r3
 80267ae:	1192      	asrs	r2, r2, #6
 80267b0:	17db      	asrs	r3, r3, #31
 80267b2:	1ad3      	subs	r3, r2, r3
 80267b4:	b21b      	sxth	r3, r3
 80267b6:	e01f      	b.n	80267f8 <calendar_init+0x494>
 80267b8:	2301      	movs	r3, #1
 80267ba:	e01d      	b.n	80267f8 <calendar_init+0x494>
 80267bc:	2000      	movs	r0, #0
 80267be:	f7f8 f9a9 	bl	801eb14 <lv_disp_get_dpi>
 80267c2:	4603      	mov	r3, r0
 80267c4:	461a      	mov	r2, r3
 80267c6:	4613      	mov	r3, r2
 80267c8:	011b      	lsls	r3, r3, #4
 80267ca:	1a9b      	subs	r3, r3, r2
 80267cc:	005b      	lsls	r3, r3, #1
 80267ce:	2bef      	cmp	r3, #239	; 0xef
 80267d0:	dd11      	ble.n	80267f6 <calendar_init+0x492>
 80267d2:	2000      	movs	r0, #0
 80267d4:	f7f8 f99e 	bl	801eb14 <lv_disp_get_dpi>
 80267d8:	4603      	mov	r3, r0
 80267da:	461a      	mov	r2, r3
 80267dc:	4613      	mov	r3, r2
 80267de:	011b      	lsls	r3, r3, #4
 80267e0:	1a9b      	subs	r3, r3, r2
 80267e2:	005b      	lsls	r3, r3, #1
 80267e4:	3350      	adds	r3, #80	; 0x50
 80267e6:	4a6d      	ldr	r2, [pc, #436]	; (802699c <calendar_init+0x638>)
 80267e8:	fb82 1203 	smull	r1, r2, r2, r3
 80267ec:	1192      	asrs	r2, r2, #6
 80267ee:	17db      	asrs	r3, r3, #31
 80267f0:	1ad3      	subs	r3, r2, r3
 80267f2:	b21b      	sxth	r3, r3
 80267f4:	e000      	b.n	80267f8 <calendar_init+0x494>
 80267f6:	2301      	movs	r3, #1
 80267f8:	461a      	mov	r2, r3
 80267fa:	2100      	movs	r1, #0
 80267fc:	4620      	mov	r0, r4
 80267fe:	f7fc fd30 	bl	8023262 <lv_style_set_pad_bottom>

    style_init_reset(&styles->calendar_date_nums);
 8026802:	4b67      	ldr	r3, [pc, #412]	; (80269a0 <calendar_init+0x63c>)
 8026804:	681b      	ldr	r3, [r3, #0]
 8026806:	3330      	adds	r3, #48	; 0x30
 8026808:	4618      	mov	r0, r3
 802680a:	f002 ffff 	bl	802980c <style_init_reset>
    lv_style_set_radius(&styles->calendar_date_nums, LV_STATE_DEFAULT, LV_DPX(4));
 802680e:	4b64      	ldr	r3, [pc, #400]	; (80269a0 <calendar_init+0x63c>)
 8026810:	681b      	ldr	r3, [r3, #0]
 8026812:	f103 0430 	add.w	r4, r3, #48	; 0x30
 8026816:	2000      	movs	r0, #0
 8026818:	f7f8 f97c 	bl	801eb14 <lv_disp_get_dpi>
 802681c:	4603      	mov	r3, r0
 802681e:	2b3b      	cmp	r3, #59	; 0x3b
 8026820:	dd0c      	ble.n	802683c <calendar_init+0x4d8>
 8026822:	2000      	movs	r0, #0
 8026824:	f7f8 f976 	bl	801eb14 <lv_disp_get_dpi>
 8026828:	4603      	mov	r3, r0
 802682a:	3314      	adds	r3, #20
 802682c:	4a5b      	ldr	r2, [pc, #364]	; (802699c <calendar_init+0x638>)
 802682e:	fb82 1203 	smull	r1, r2, r2, r3
 8026832:	1112      	asrs	r2, r2, #4
 8026834:	17db      	asrs	r3, r3, #31
 8026836:	1ad3      	subs	r3, r2, r3
 8026838:	b21b      	sxth	r3, r3
 802683a:	e000      	b.n	802683e <calendar_init+0x4da>
 802683c:	2301      	movs	r3, #1
 802683e:	461a      	mov	r2, r3
 8026840:	2100      	movs	r1, #0
 8026842:	4620      	mov	r0, r4
 8026844:	f7fc fc95 	bl	8023172 <lv_style_set_radius>
    lv_style_set_text_color(&styles->calendar_date_nums, LV_STATE_CHECKED,
 8026848:	4b55      	ldr	r3, [pc, #340]	; (80269a0 <calendar_init+0x63c>)
 802684a:	681b      	ldr	r3, [r3, #0]
 802684c:	f103 0430 	add.w	r4, r3, #48	; 0x30
                            IS_LIGHT ? lv_color_hex(0x31404f) : LV_COLOR_WHITE);
 8026850:	4b54      	ldr	r3, [pc, #336]	; (80269a4 <calendar_init+0x640>)
 8026852:	6a1b      	ldr	r3, [r3, #32]
 8026854:	f003 0302 	and.w	r3, r3, #2
    lv_style_set_text_color(&styles->calendar_date_nums, LV_STATE_CHECKED,
 8026858:	2b00      	cmp	r3, #0
 802685a:	d004      	beq.n	8026866 <calendar_init+0x502>
                            IS_LIGHT ? lv_color_hex(0x31404f) : LV_COLOR_WHITE);
 802685c:	4852      	ldr	r0, [pc, #328]	; (80269a8 <calendar_init+0x644>)
 802685e:	f7fc fc42 	bl	80230e6 <lv_color_hex>
 8026862:	4603      	mov	r3, r0
 8026864:	e001      	b.n	802686a <calendar_init+0x506>
    lv_style_set_text_color(&styles->calendar_date_nums, LV_STATE_CHECKED,
 8026866:	4b51      	ldr	r3, [pc, #324]	; (80269ac <calendar_init+0x648>)
 8026868:	881b      	ldrh	r3, [r3, #0]
 802686a:	461a      	mov	r2, r3
 802686c:	2101      	movs	r1, #1
 802686e:	4620      	mov	r0, r4
 8026870:	f7fc ff86 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_color(&styles->calendar_date_nums, LV_STATE_DISABLED, LV_COLOR_GRAY);
 8026874:	4b4a      	ldr	r3, [pc, #296]	; (80269a0 <calendar_init+0x63c>)
 8026876:	681b      	ldr	r3, [r3, #0]
 8026878:	3330      	adds	r3, #48	; 0x30
 802687a:	4a4d      	ldr	r2, [pc, #308]	; (80269b0 <calendar_init+0x64c>)
 802687c:	8812      	ldrh	r2, [r2, #0]
 802687e:	2120      	movs	r1, #32
 8026880:	4618      	mov	r0, r3
 8026882:	f7fc ff7d 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_bg_opa(&styles->calendar_date_nums, LV_STATE_CHECKED, IS_LIGHT ? LV_OPA_20 : LV_OPA_40);
 8026886:	4b46      	ldr	r3, [pc, #280]	; (80269a0 <calendar_init+0x63c>)
 8026888:	681b      	ldr	r3, [r3, #0]
 802688a:	f103 0030 	add.w	r0, r3, #48	; 0x30
 802688e:	4b45      	ldr	r3, [pc, #276]	; (80269a4 <calendar_init+0x640>)
 8026890:	6a1b      	ldr	r3, [r3, #32]
 8026892:	f003 0302 	and.w	r3, r3, #2
 8026896:	2b00      	cmp	r3, #0
 8026898:	d001      	beq.n	802689e <calendar_init+0x53a>
 802689a:	2333      	movs	r3, #51	; 0x33
 802689c:	e000      	b.n	80268a0 <calendar_init+0x53c>
 802689e:	2366      	movs	r3, #102	; 0x66
 80268a0:	461a      	mov	r2, r3
 80268a2:	2101      	movs	r1, #1
 80268a4:	f7fc fdb3 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_opa(&styles->calendar_date_nums, LV_STATE_PRESSED, LV_OPA_20);
 80268a8:	4b3d      	ldr	r3, [pc, #244]	; (80269a0 <calendar_init+0x63c>)
 80268aa:	681b      	ldr	r3, [r3, #0]
 80268ac:	3330      	adds	r3, #48	; 0x30
 80268ae:	2233      	movs	r2, #51	; 0x33
 80268b0:	2110      	movs	r1, #16
 80268b2:	4618      	mov	r0, r3
 80268b4:	f7fc fdab 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_opa(&styles->calendar_date_nums, LV_STATE_FOCUSED, LV_OPA_COVER);
 80268b8:	4b39      	ldr	r3, [pc, #228]	; (80269a0 <calendar_init+0x63c>)
 80268ba:	681b      	ldr	r3, [r3, #0]
 80268bc:	3330      	adds	r3, #48	; 0x30
 80268be:	22ff      	movs	r2, #255	; 0xff
 80268c0:	2102      	movs	r1, #2
 80268c2:	4618      	mov	r0, r3
 80268c4:	f7fc fda3 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_text_color(&styles->calendar_date_nums, LV_STATE_FOCUSED, LV_COLOR_WHITE);
 80268c8:	4b35      	ldr	r3, [pc, #212]	; (80269a0 <calendar_init+0x63c>)
 80268ca:	681b      	ldr	r3, [r3, #0]
 80268cc:	3330      	adds	r3, #48	; 0x30
 80268ce:	4a37      	ldr	r2, [pc, #220]	; (80269ac <calendar_init+0x648>)
 80268d0:	8812      	ldrh	r2, [r2, #0]
 80268d2:	2102      	movs	r1, #2
 80268d4:	4618      	mov	r0, r3
 80268d6:	f7fc ff53 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_bg_color(&styles->calendar_date_nums, LV_STATE_FOCUSED, theme.color_primary);
 80268da:	4b31      	ldr	r3, [pc, #196]	; (80269a0 <calendar_init+0x63c>)
 80268dc:	681b      	ldr	r3, [r3, #0]
 80268de:	3330      	adds	r3, #48	; 0x30
 80268e0:	4a30      	ldr	r2, [pc, #192]	; (80269a4 <calendar_init+0x640>)
 80268e2:	8992      	ldrh	r2, [r2, #12]
 80268e4:	2102      	movs	r1, #2
 80268e6:	4618      	mov	r0, r3
 80268e8:	f7fc fd7b 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->calendar_date_nums, LV_STATE_DEFAULT,
 80268ec:	4b2c      	ldr	r3, [pc, #176]	; (80269a0 <calendar_init+0x63c>)
 80268ee:	681b      	ldr	r3, [r3, #0]
 80268f0:	f103 0430 	add.w	r4, r3, #48	; 0x30
                          IS_LIGHT ? lv_color_hex(0x666666) : LV_COLOR_WHITE);
 80268f4:	4b2b      	ldr	r3, [pc, #172]	; (80269a4 <calendar_init+0x640>)
 80268f6:	6a1b      	ldr	r3, [r3, #32]
 80268f8:	f003 0302 	and.w	r3, r3, #2
    lv_style_set_bg_color(&styles->calendar_date_nums, LV_STATE_DEFAULT,
 80268fc:	2b00      	cmp	r3, #0
 80268fe:	d004      	beq.n	802690a <calendar_init+0x5a6>
                          IS_LIGHT ? lv_color_hex(0x666666) : LV_COLOR_WHITE);
 8026900:	482c      	ldr	r0, [pc, #176]	; (80269b4 <calendar_init+0x650>)
 8026902:	f7fc fbf0 	bl	80230e6 <lv_color_hex>
 8026906:	4603      	mov	r3, r0
 8026908:	e001      	b.n	802690e <calendar_init+0x5aa>
    lv_style_set_bg_color(&styles->calendar_date_nums, LV_STATE_DEFAULT,
 802690a:	4b28      	ldr	r3, [pc, #160]	; (80269ac <calendar_init+0x648>)
 802690c:	881b      	ldrh	r3, [r3, #0]
 802690e:	461a      	mov	r2, r3
 8026910:	2100      	movs	r1, #0
 8026912:	4620      	mov	r0, r4
 8026914:	f7fc fd65 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->calendar_date_nums, LV_STATE_CHECKED, theme.color_primary);
 8026918:	4b21      	ldr	r3, [pc, #132]	; (80269a0 <calendar_init+0x63c>)
 802691a:	681b      	ldr	r3, [r3, #0]
 802691c:	3330      	adds	r3, #48	; 0x30
 802691e:	4a21      	ldr	r2, [pc, #132]	; (80269a4 <calendar_init+0x640>)
 8026920:	8992      	ldrh	r2, [r2, #12]
 8026922:	2101      	movs	r1, #1
 8026924:	4618      	mov	r0, r3
 8026926:	f7fc fd5c 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_border_width(&styles->calendar_date_nums, LV_STATE_CHECKED, 2);
 802692a:	4b1d      	ldr	r3, [pc, #116]	; (80269a0 <calendar_init+0x63c>)
 802692c:	681b      	ldr	r3, [r3, #0]
 802692e:	3330      	adds	r3, #48	; 0x30
 8026930:	2202      	movs	r2, #2
 8026932:	2101      	movs	r1, #1
 8026934:	4618      	mov	r0, r3
 8026936:	f7fc fd81 	bl	802343c <lv_style_set_border_width>
    lv_style_set_border_side(&styles->calendar_date_nums, LV_STATE_CHECKED, LV_BORDER_SIDE_LEFT);
 802693a:	4b19      	ldr	r3, [pc, #100]	; (80269a0 <calendar_init+0x63c>)
 802693c:	681b      	ldr	r3, [r3, #0]
 802693e:	3330      	adds	r3, #48	; 0x30
 8026940:	2204      	movs	r2, #4
 8026942:	2101      	movs	r1, #1
 8026944:	4618      	mov	r0, r3
 8026946:	f7fc fd91 	bl	802346c <lv_style_set_border_side>
    lv_style_set_border_color(&styles->calendar_date_nums, LV_STATE_CHECKED, theme.color_primary);
 802694a:	4b15      	ldr	r3, [pc, #84]	; (80269a0 <calendar_init+0x63c>)
 802694c:	681b      	ldr	r3, [r3, #0]
 802694e:	3330      	adds	r3, #48	; 0x30
 8026950:	4a14      	ldr	r2, [pc, #80]	; (80269a4 <calendar_init+0x640>)
 8026952:	8992      	ldrh	r2, [r2, #12]
 8026954:	2101      	movs	r1, #1
 8026956:	4618      	mov	r0, r3
 8026958:	f7fc fdb8 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_pad_inner(&styles->calendar_date_nums, LV_STATE_DEFAULT, LV_DPX(3));
 802695c:	4b10      	ldr	r3, [pc, #64]	; (80269a0 <calendar_init+0x63c>)
 802695e:	681b      	ldr	r3, [r3, #0]
 8026960:	f103 0430 	add.w	r4, r3, #48	; 0x30
 8026964:	2000      	movs	r0, #0
 8026966:	f7f8 f8d5 	bl	801eb14 <lv_disp_get_dpi>
 802696a:	4603      	mov	r3, r0
 802696c:	461a      	mov	r2, r3
 802696e:	4613      	mov	r3, r2
 8026970:	005b      	lsls	r3, r3, #1
 8026972:	4413      	add	r3, r2
 8026974:	2bef      	cmp	r3, #239	; 0xef
 8026976:	dd1f      	ble.n	80269b8 <calendar_init+0x654>
 8026978:	2000      	movs	r0, #0
 802697a:	f7f8 f8cb 	bl	801eb14 <lv_disp_get_dpi>
 802697e:	4603      	mov	r3, r0
 8026980:	461a      	mov	r2, r3
 8026982:	4613      	mov	r3, r2
 8026984:	005b      	lsls	r3, r3, #1
 8026986:	4413      	add	r3, r2
 8026988:	3350      	adds	r3, #80	; 0x50
 802698a:	4a04      	ldr	r2, [pc, #16]	; (802699c <calendar_init+0x638>)
 802698c:	fb82 1203 	smull	r1, r2, r2, r3
 8026990:	1192      	asrs	r2, r2, #6
 8026992:	17db      	asrs	r3, r3, #31
 8026994:	1ad3      	subs	r3, r2, r3
 8026996:	b21b      	sxth	r3, r3
 8026998:	e00f      	b.n	80269ba <calendar_init+0x656>
 802699a:	bf00      	nop
 802699c:	66666667 	.word	0x66666667
 80269a0:	20012350 	.word	0x20012350
 80269a4:	20012328 	.word	0x20012328
 80269a8:	0031404f 	.word	0x0031404f
 80269ac:	0802e594 	.word	0x0802e594
 80269b0:	0802e598 	.word	0x0802e598
 80269b4:	00666666 	.word	0x00666666
 80269b8:	2301      	movs	r3, #1
 80269ba:	461a      	mov	r2, r3
 80269bc:	2100      	movs	r1, #0
 80269be:	4620      	mov	r0, r4
 80269c0:	f7fc fc97 	bl	80232f2 <lv_style_set_pad_inner>
    lv_style_set_pad_left(&styles->calendar_date_nums, LV_STATE_DEFAULT, PAD_DEF);
 80269c4:	4b6f      	ldr	r3, [pc, #444]	; (8026b84 <calendar_init+0x820>)
 80269c6:	681b      	ldr	r3, [r3, #0]
 80269c8:	f103 0430 	add.w	r4, r3, #48	; 0x30
 80269cc:	2000      	movs	r0, #0
 80269ce:	f7f8 f8ba 	bl	801eb46 <lv_disp_get_size_category>
 80269d2:	4603      	mov	r3, r0
 80269d4:	2b01      	cmp	r3, #1
 80269d6:	d81c      	bhi.n	8026a12 <calendar_init+0x6ae>
 80269d8:	2000      	movs	r0, #0
 80269da:	f7f8 f89b 	bl	801eb14 <lv_disp_get_dpi>
 80269de:	4603      	mov	r3, r0
 80269e0:	461a      	mov	r2, r3
 80269e2:	4613      	mov	r3, r2
 80269e4:	011b      	lsls	r3, r3, #4
 80269e6:	1a9b      	subs	r3, r3, r2
 80269e8:	2bef      	cmp	r3, #239	; 0xef
 80269ea:	dd10      	ble.n	8026a0e <calendar_init+0x6aa>
 80269ec:	2000      	movs	r0, #0
 80269ee:	f7f8 f891 	bl	801eb14 <lv_disp_get_dpi>
 80269f2:	4603      	mov	r3, r0
 80269f4:	461a      	mov	r2, r3
 80269f6:	4613      	mov	r3, r2
 80269f8:	011b      	lsls	r3, r3, #4
 80269fa:	1a9b      	subs	r3, r3, r2
 80269fc:	3350      	adds	r3, #80	; 0x50
 80269fe:	4a62      	ldr	r2, [pc, #392]	; (8026b88 <calendar_init+0x824>)
 8026a00:	fb82 1203 	smull	r1, r2, r2, r3
 8026a04:	1192      	asrs	r2, r2, #6
 8026a06:	17db      	asrs	r3, r3, #31
 8026a08:	1ad3      	subs	r3, r2, r3
 8026a0a:	b21b      	sxth	r3, r3
 8026a0c:	e01f      	b.n	8026a4e <calendar_init+0x6ea>
 8026a0e:	2301      	movs	r3, #1
 8026a10:	e01d      	b.n	8026a4e <calendar_init+0x6ea>
 8026a12:	2000      	movs	r0, #0
 8026a14:	f7f8 f87e 	bl	801eb14 <lv_disp_get_dpi>
 8026a18:	4603      	mov	r3, r0
 8026a1a:	461a      	mov	r2, r3
 8026a1c:	4613      	mov	r3, r2
 8026a1e:	011b      	lsls	r3, r3, #4
 8026a20:	1a9b      	subs	r3, r3, r2
 8026a22:	005b      	lsls	r3, r3, #1
 8026a24:	2bef      	cmp	r3, #239	; 0xef
 8026a26:	dd11      	ble.n	8026a4c <calendar_init+0x6e8>
 8026a28:	2000      	movs	r0, #0
 8026a2a:	f7f8 f873 	bl	801eb14 <lv_disp_get_dpi>
 8026a2e:	4603      	mov	r3, r0
 8026a30:	461a      	mov	r2, r3
 8026a32:	4613      	mov	r3, r2
 8026a34:	011b      	lsls	r3, r3, #4
 8026a36:	1a9b      	subs	r3, r3, r2
 8026a38:	005b      	lsls	r3, r3, #1
 8026a3a:	3350      	adds	r3, #80	; 0x50
 8026a3c:	4a52      	ldr	r2, [pc, #328]	; (8026b88 <calendar_init+0x824>)
 8026a3e:	fb82 1203 	smull	r1, r2, r2, r3
 8026a42:	1192      	asrs	r2, r2, #6
 8026a44:	17db      	asrs	r3, r3, #31
 8026a46:	1ad3      	subs	r3, r2, r3
 8026a48:	b21b      	sxth	r3, r3
 8026a4a:	e000      	b.n	8026a4e <calendar_init+0x6ea>
 8026a4c:	2301      	movs	r3, #1
 8026a4e:	461a      	mov	r2, r3
 8026a50:	2100      	movs	r1, #0
 8026a52:	4620      	mov	r0, r4
 8026a54:	f7fc fc1d 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->calendar_date_nums, LV_STATE_DEFAULT, PAD_DEF);
 8026a58:	4b4a      	ldr	r3, [pc, #296]	; (8026b84 <calendar_init+0x820>)
 8026a5a:	681b      	ldr	r3, [r3, #0]
 8026a5c:	f103 0430 	add.w	r4, r3, #48	; 0x30
 8026a60:	2000      	movs	r0, #0
 8026a62:	f7f8 f870 	bl	801eb46 <lv_disp_get_size_category>
 8026a66:	4603      	mov	r3, r0
 8026a68:	2b01      	cmp	r3, #1
 8026a6a:	d81c      	bhi.n	8026aa6 <calendar_init+0x742>
 8026a6c:	2000      	movs	r0, #0
 8026a6e:	f7f8 f851 	bl	801eb14 <lv_disp_get_dpi>
 8026a72:	4603      	mov	r3, r0
 8026a74:	461a      	mov	r2, r3
 8026a76:	4613      	mov	r3, r2
 8026a78:	011b      	lsls	r3, r3, #4
 8026a7a:	1a9b      	subs	r3, r3, r2
 8026a7c:	2bef      	cmp	r3, #239	; 0xef
 8026a7e:	dd10      	ble.n	8026aa2 <calendar_init+0x73e>
 8026a80:	2000      	movs	r0, #0
 8026a82:	f7f8 f847 	bl	801eb14 <lv_disp_get_dpi>
 8026a86:	4603      	mov	r3, r0
 8026a88:	461a      	mov	r2, r3
 8026a8a:	4613      	mov	r3, r2
 8026a8c:	011b      	lsls	r3, r3, #4
 8026a8e:	1a9b      	subs	r3, r3, r2
 8026a90:	3350      	adds	r3, #80	; 0x50
 8026a92:	4a3d      	ldr	r2, [pc, #244]	; (8026b88 <calendar_init+0x824>)
 8026a94:	fb82 1203 	smull	r1, r2, r2, r3
 8026a98:	1192      	asrs	r2, r2, #6
 8026a9a:	17db      	asrs	r3, r3, #31
 8026a9c:	1ad3      	subs	r3, r2, r3
 8026a9e:	b21b      	sxth	r3, r3
 8026aa0:	e01f      	b.n	8026ae2 <calendar_init+0x77e>
 8026aa2:	2301      	movs	r3, #1
 8026aa4:	e01d      	b.n	8026ae2 <calendar_init+0x77e>
 8026aa6:	2000      	movs	r0, #0
 8026aa8:	f7f8 f834 	bl	801eb14 <lv_disp_get_dpi>
 8026aac:	4603      	mov	r3, r0
 8026aae:	461a      	mov	r2, r3
 8026ab0:	4613      	mov	r3, r2
 8026ab2:	011b      	lsls	r3, r3, #4
 8026ab4:	1a9b      	subs	r3, r3, r2
 8026ab6:	005b      	lsls	r3, r3, #1
 8026ab8:	2bef      	cmp	r3, #239	; 0xef
 8026aba:	dd11      	ble.n	8026ae0 <calendar_init+0x77c>
 8026abc:	2000      	movs	r0, #0
 8026abe:	f7f8 f829 	bl	801eb14 <lv_disp_get_dpi>
 8026ac2:	4603      	mov	r3, r0
 8026ac4:	461a      	mov	r2, r3
 8026ac6:	4613      	mov	r3, r2
 8026ac8:	011b      	lsls	r3, r3, #4
 8026aca:	1a9b      	subs	r3, r3, r2
 8026acc:	005b      	lsls	r3, r3, #1
 8026ace:	3350      	adds	r3, #80	; 0x50
 8026ad0:	4a2d      	ldr	r2, [pc, #180]	; (8026b88 <calendar_init+0x824>)
 8026ad2:	fb82 1203 	smull	r1, r2, r2, r3
 8026ad6:	1192      	asrs	r2, r2, #6
 8026ad8:	17db      	asrs	r3, r3, #31
 8026ada:	1ad3      	subs	r3, r2, r3
 8026adc:	b21b      	sxth	r3, r3
 8026ade:	e000      	b.n	8026ae2 <calendar_init+0x77e>
 8026ae0:	2301      	movs	r3, #1
 8026ae2:	461a      	mov	r2, r3
 8026ae4:	2100      	movs	r1, #0
 8026ae6:	4620      	mov	r0, r4
 8026ae8:	f7fc fbeb 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_bottom(&styles->calendar_date_nums, LV_STATE_DEFAULT, PAD_DEF);
 8026aec:	4b25      	ldr	r3, [pc, #148]	; (8026b84 <calendar_init+0x820>)
 8026aee:	681b      	ldr	r3, [r3, #0]
 8026af0:	f103 0430 	add.w	r4, r3, #48	; 0x30
 8026af4:	2000      	movs	r0, #0
 8026af6:	f7f8 f826 	bl	801eb46 <lv_disp_get_size_category>
 8026afa:	4603      	mov	r3, r0
 8026afc:	2b01      	cmp	r3, #1
 8026afe:	d81c      	bhi.n	8026b3a <calendar_init+0x7d6>
 8026b00:	2000      	movs	r0, #0
 8026b02:	f7f8 f807 	bl	801eb14 <lv_disp_get_dpi>
 8026b06:	4603      	mov	r3, r0
 8026b08:	461a      	mov	r2, r3
 8026b0a:	4613      	mov	r3, r2
 8026b0c:	011b      	lsls	r3, r3, #4
 8026b0e:	1a9b      	subs	r3, r3, r2
 8026b10:	2bef      	cmp	r3, #239	; 0xef
 8026b12:	dd10      	ble.n	8026b36 <calendar_init+0x7d2>
 8026b14:	2000      	movs	r0, #0
 8026b16:	f7f7 fffd 	bl	801eb14 <lv_disp_get_dpi>
 8026b1a:	4603      	mov	r3, r0
 8026b1c:	461a      	mov	r2, r3
 8026b1e:	4613      	mov	r3, r2
 8026b20:	011b      	lsls	r3, r3, #4
 8026b22:	1a9b      	subs	r3, r3, r2
 8026b24:	3350      	adds	r3, #80	; 0x50
 8026b26:	4a18      	ldr	r2, [pc, #96]	; (8026b88 <calendar_init+0x824>)
 8026b28:	fb82 1203 	smull	r1, r2, r2, r3
 8026b2c:	1192      	asrs	r2, r2, #6
 8026b2e:	17db      	asrs	r3, r3, #31
 8026b30:	1ad3      	subs	r3, r2, r3
 8026b32:	b21b      	sxth	r3, r3
 8026b34:	e01f      	b.n	8026b76 <calendar_init+0x812>
 8026b36:	2301      	movs	r3, #1
 8026b38:	e01d      	b.n	8026b76 <calendar_init+0x812>
 8026b3a:	2000      	movs	r0, #0
 8026b3c:	f7f7 ffea 	bl	801eb14 <lv_disp_get_dpi>
 8026b40:	4603      	mov	r3, r0
 8026b42:	461a      	mov	r2, r3
 8026b44:	4613      	mov	r3, r2
 8026b46:	011b      	lsls	r3, r3, #4
 8026b48:	1a9b      	subs	r3, r3, r2
 8026b4a:	005b      	lsls	r3, r3, #1
 8026b4c:	2bef      	cmp	r3, #239	; 0xef
 8026b4e:	dd11      	ble.n	8026b74 <calendar_init+0x810>
 8026b50:	2000      	movs	r0, #0
 8026b52:	f7f7 ffdf 	bl	801eb14 <lv_disp_get_dpi>
 8026b56:	4603      	mov	r3, r0
 8026b58:	461a      	mov	r2, r3
 8026b5a:	4613      	mov	r3, r2
 8026b5c:	011b      	lsls	r3, r3, #4
 8026b5e:	1a9b      	subs	r3, r3, r2
 8026b60:	005b      	lsls	r3, r3, #1
 8026b62:	3350      	adds	r3, #80	; 0x50
 8026b64:	4a08      	ldr	r2, [pc, #32]	; (8026b88 <calendar_init+0x824>)
 8026b66:	fb82 1203 	smull	r1, r2, r2, r3
 8026b6a:	1192      	asrs	r2, r2, #6
 8026b6c:	17db      	asrs	r3, r3, #31
 8026b6e:	1ad3      	subs	r3, r2, r3
 8026b70:	b21b      	sxth	r3, r3
 8026b72:	e000      	b.n	8026b76 <calendar_init+0x812>
 8026b74:	2301      	movs	r3, #1
 8026b76:	461a      	mov	r2, r3
 8026b78:	2100      	movs	r1, #0
 8026b7a:	4620      	mov	r0, r4
 8026b7c:	f7fc fb71 	bl	8023262 <lv_style_set_pad_bottom>
#endif
}
 8026b80:	bf00      	nop
 8026b82:	bd98      	pop	{r3, r4, r7, pc}
 8026b84:	20012350 	.word	0x20012350
 8026b88:	66666667 	.word	0x66666667

08026b8c <cpicker_init>:

static void cpicker_init(void)
{
 8026b8c:	b598      	push	{r3, r4, r7, lr}
 8026b8e:	af00      	add	r7, sp, #0
#if LV_USE_CPICKER
    style_init_reset(&styles->cpicker_bg);
 8026b90:	4bb2      	ldr	r3, [pc, #712]	; (8026e5c <cpicker_init+0x2d0>)
 8026b92:	681b      	ldr	r3, [r3, #0]
 8026b94:	333c      	adds	r3, #60	; 0x3c
 8026b96:	4618      	mov	r0, r3
 8026b98:	f002 fe38 	bl	802980c <style_init_reset>
    lv_style_set_scale_width(&styles->cpicker_bg, LV_STATE_DEFAULT, LV_DPX(30));
 8026b9c:	4baf      	ldr	r3, [pc, #700]	; (8026e5c <cpicker_init+0x2d0>)
 8026b9e:	681b      	ldr	r3, [r3, #0]
 8026ba0:	f103 043c 	add.w	r4, r3, #60	; 0x3c
 8026ba4:	2000      	movs	r0, #0
 8026ba6:	f7f7 ffb5 	bl	801eb14 <lv_disp_get_dpi>
 8026baa:	4603      	mov	r3, r0
 8026bac:	461a      	mov	r2, r3
 8026bae:	4613      	mov	r3, r2
 8026bb0:	011b      	lsls	r3, r3, #4
 8026bb2:	1a9b      	subs	r3, r3, r2
 8026bb4:	005b      	lsls	r3, r3, #1
 8026bb6:	2bef      	cmp	r3, #239	; 0xef
 8026bb8:	dd11      	ble.n	8026bde <cpicker_init+0x52>
 8026bba:	2000      	movs	r0, #0
 8026bbc:	f7f7 ffaa 	bl	801eb14 <lv_disp_get_dpi>
 8026bc0:	4603      	mov	r3, r0
 8026bc2:	461a      	mov	r2, r3
 8026bc4:	4613      	mov	r3, r2
 8026bc6:	011b      	lsls	r3, r3, #4
 8026bc8:	1a9b      	subs	r3, r3, r2
 8026bca:	005b      	lsls	r3, r3, #1
 8026bcc:	3350      	adds	r3, #80	; 0x50
 8026bce:	4aa4      	ldr	r2, [pc, #656]	; (8026e60 <cpicker_init+0x2d4>)
 8026bd0:	fb82 1203 	smull	r1, r2, r2, r3
 8026bd4:	1192      	asrs	r2, r2, #6
 8026bd6:	17db      	asrs	r3, r3, #31
 8026bd8:	1ad3      	subs	r3, r2, r3
 8026bda:	b21b      	sxth	r3, r3
 8026bdc:	e000      	b.n	8026be0 <cpicker_init+0x54>
 8026bde:	2301      	movs	r3, #1
 8026be0:	461a      	mov	r2, r3
 8026be2:	2100      	movs	r1, #0
 8026be4:	4620      	mov	r0, r4
 8026be6:	f7fc ff19 	bl	8023a1c <lv_style_set_scale_width>
    lv_style_set_bg_opa(&styles->cpicker_bg, LV_STATE_DEFAULT, LV_OPA_COVER);
 8026bea:	4b9c      	ldr	r3, [pc, #624]	; (8026e5c <cpicker_init+0x2d0>)
 8026bec:	681b      	ldr	r3, [r3, #0]
 8026bee:	333c      	adds	r3, #60	; 0x3c
 8026bf0:	22ff      	movs	r2, #255	; 0xff
 8026bf2:	2100      	movs	r1, #0
 8026bf4:	4618      	mov	r0, r3
 8026bf6:	f7fc fc0a 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->cpicker_bg, LV_STATE_DEFAULT, COLOR_SCR);
 8026bfa:	4b98      	ldr	r3, [pc, #608]	; (8026e5c <cpicker_init+0x2d0>)
 8026bfc:	681b      	ldr	r3, [r3, #0]
 8026bfe:	f103 043c 	add.w	r4, r3, #60	; 0x3c
 8026c02:	4b98      	ldr	r3, [pc, #608]	; (8026e64 <cpicker_init+0x2d8>)
 8026c04:	6a1b      	ldr	r3, [r3, #32]
 8026c06:	f003 0302 	and.w	r3, r3, #2
 8026c0a:	2b00      	cmp	r3, #0
 8026c0c:	d004      	beq.n	8026c18 <cpicker_init+0x8c>
 8026c0e:	4896      	ldr	r0, [pc, #600]	; (8026e68 <cpicker_init+0x2dc>)
 8026c10:	f7fc fa69 	bl	80230e6 <lv_color_hex>
 8026c14:	4603      	mov	r3, r0
 8026c16:	e003      	b.n	8026c20 <cpicker_init+0x94>
 8026c18:	4894      	ldr	r0, [pc, #592]	; (8026e6c <cpicker_init+0x2e0>)
 8026c1a:	f7fc fa64 	bl	80230e6 <lv_color_hex>
 8026c1e:	4603      	mov	r3, r0
 8026c20:	461a      	mov	r2, r3
 8026c22:	2100      	movs	r1, #0
 8026c24:	4620      	mov	r0, r4
 8026c26:	f7fc fbdc 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_pad_inner(&styles->cpicker_bg, LV_STATE_DEFAULT, LV_DPX(20));
 8026c2a:	4b8c      	ldr	r3, [pc, #560]	; (8026e5c <cpicker_init+0x2d0>)
 8026c2c:	681b      	ldr	r3, [r3, #0]
 8026c2e:	f103 043c 	add.w	r4, r3, #60	; 0x3c
 8026c32:	2000      	movs	r0, #0
 8026c34:	f7f7 ff6e 	bl	801eb14 <lv_disp_get_dpi>
 8026c38:	4603      	mov	r3, r0
 8026c3a:	461a      	mov	r2, r3
 8026c3c:	4613      	mov	r3, r2
 8026c3e:	009b      	lsls	r3, r3, #2
 8026c40:	4413      	add	r3, r2
 8026c42:	009b      	lsls	r3, r3, #2
 8026c44:	2bef      	cmp	r3, #239	; 0xef
 8026c46:	dd11      	ble.n	8026c6c <cpicker_init+0xe0>
 8026c48:	2000      	movs	r0, #0
 8026c4a:	f7f7 ff63 	bl	801eb14 <lv_disp_get_dpi>
 8026c4e:	4603      	mov	r3, r0
 8026c50:	461a      	mov	r2, r3
 8026c52:	4613      	mov	r3, r2
 8026c54:	009b      	lsls	r3, r3, #2
 8026c56:	4413      	add	r3, r2
 8026c58:	009b      	lsls	r3, r3, #2
 8026c5a:	3350      	adds	r3, #80	; 0x50
 8026c5c:	4a80      	ldr	r2, [pc, #512]	; (8026e60 <cpicker_init+0x2d4>)
 8026c5e:	fb82 1203 	smull	r1, r2, r2, r3
 8026c62:	1192      	asrs	r2, r2, #6
 8026c64:	17db      	asrs	r3, r3, #31
 8026c66:	1ad3      	subs	r3, r2, r3
 8026c68:	b21b      	sxth	r3, r3
 8026c6a:	e000      	b.n	8026c6e <cpicker_init+0xe2>
 8026c6c:	2301      	movs	r3, #1
 8026c6e:	461a      	mov	r2, r3
 8026c70:	2100      	movs	r1, #0
 8026c72:	4620      	mov	r0, r4
 8026c74:	f7fc fb3d 	bl	80232f2 <lv_style_set_pad_inner>
    lv_style_set_radius(&styles->cpicker_bg, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 8026c78:	4b78      	ldr	r3, [pc, #480]	; (8026e5c <cpicker_init+0x2d0>)
 8026c7a:	681b      	ldr	r3, [r3, #0]
 8026c7c:	333c      	adds	r3, #60	; 0x3c
 8026c7e:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8026c82:	2100      	movs	r1, #0
 8026c84:	4618      	mov	r0, r3
 8026c86:	f7fc fa74 	bl	8023172 <lv_style_set_radius>

    style_init_reset(&styles->cpicker_indic);
 8026c8a:	4b74      	ldr	r3, [pc, #464]	; (8026e5c <cpicker_init+0x2d0>)
 8026c8c:	681b      	ldr	r3, [r3, #0]
 8026c8e:	3340      	adds	r3, #64	; 0x40
 8026c90:	4618      	mov	r0, r3
 8026c92:	f002 fdbb 	bl	802980c <style_init_reset>
    lv_style_set_radius(&styles->cpicker_indic, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 8026c96:	4b71      	ldr	r3, [pc, #452]	; (8026e5c <cpicker_init+0x2d0>)
 8026c98:	681b      	ldr	r3, [r3, #0]
 8026c9a:	3340      	adds	r3, #64	; 0x40
 8026c9c:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8026ca0:	2100      	movs	r1, #0
 8026ca2:	4618      	mov	r0, r3
 8026ca4:	f7fc fa65 	bl	8023172 <lv_style_set_radius>
    lv_style_set_bg_color(&styles->cpicker_indic, LV_STATE_DEFAULT, LV_COLOR_WHITE);
 8026ca8:	4b6c      	ldr	r3, [pc, #432]	; (8026e5c <cpicker_init+0x2d0>)
 8026caa:	681b      	ldr	r3, [r3, #0]
 8026cac:	3340      	adds	r3, #64	; 0x40
 8026cae:	4a70      	ldr	r2, [pc, #448]	; (8026e70 <cpicker_init+0x2e4>)
 8026cb0:	8812      	ldrh	r2, [r2, #0]
 8026cb2:	2100      	movs	r1, #0
 8026cb4:	4618      	mov	r0, r3
 8026cb6:	f7fc fb94 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_opa(&styles->cpicker_indic, LV_STATE_DEFAULT, LV_OPA_COVER);
 8026cba:	4b68      	ldr	r3, [pc, #416]	; (8026e5c <cpicker_init+0x2d0>)
 8026cbc:	681b      	ldr	r3, [r3, #0]
 8026cbe:	3340      	adds	r3, #64	; 0x40
 8026cc0:	22ff      	movs	r2, #255	; 0xff
 8026cc2:	2100      	movs	r1, #0
 8026cc4:	4618      	mov	r0, r3
 8026cc6:	f7fc fba2 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_border_width(&styles->cpicker_indic, LV_STATE_DEFAULT, 2);
 8026cca:	4b64      	ldr	r3, [pc, #400]	; (8026e5c <cpicker_init+0x2d0>)
 8026ccc:	681b      	ldr	r3, [r3, #0]
 8026cce:	3340      	adds	r3, #64	; 0x40
 8026cd0:	2202      	movs	r2, #2
 8026cd2:	2100      	movs	r1, #0
 8026cd4:	4618      	mov	r0, r3
 8026cd6:	f7fc fbb1 	bl	802343c <lv_style_set_border_width>
    lv_style_set_border_color(&styles->cpicker_indic, LV_STATE_DEFAULT, LV_COLOR_GRAY);
 8026cda:	4b60      	ldr	r3, [pc, #384]	; (8026e5c <cpicker_init+0x2d0>)
 8026cdc:	681b      	ldr	r3, [r3, #0]
 8026cde:	3340      	adds	r3, #64	; 0x40
 8026ce0:	4a64      	ldr	r2, [pc, #400]	; (8026e74 <cpicker_init+0x2e8>)
 8026ce2:	8812      	ldrh	r2, [r2, #0]
 8026ce4:	2100      	movs	r1, #0
 8026ce6:	4618      	mov	r0, r3
 8026ce8:	f7fc fbf0 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_color(&styles->cpicker_indic, LV_STATE_FOCUSED, theme.color_primary);
 8026cec:	4b5b      	ldr	r3, [pc, #364]	; (8026e5c <cpicker_init+0x2d0>)
 8026cee:	681b      	ldr	r3, [r3, #0]
 8026cf0:	3340      	adds	r3, #64	; 0x40
 8026cf2:	4a5c      	ldr	r2, [pc, #368]	; (8026e64 <cpicker_init+0x2d8>)
 8026cf4:	8992      	ldrh	r2, [r2, #12]
 8026cf6:	2102      	movs	r1, #2
 8026cf8:	4618      	mov	r0, r3
 8026cfa:	f7fc fbe7 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_color(&styles->cpicker_indic, LV_STATE_EDITED, theme.color_secondary);
 8026cfe:	4b57      	ldr	r3, [pc, #348]	; (8026e5c <cpicker_init+0x2d0>)
 8026d00:	681b      	ldr	r3, [r3, #0]
 8026d02:	3340      	adds	r3, #64	; 0x40
 8026d04:	4a57      	ldr	r2, [pc, #348]	; (8026e64 <cpicker_init+0x2d8>)
 8026d06:	89d2      	ldrh	r2, [r2, #14]
 8026d08:	2104      	movs	r1, #4
 8026d0a:	4618      	mov	r0, r3
 8026d0c:	f7fc fbde 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_pad_left(&styles->cpicker_indic, LV_STATE_DEFAULT, LV_DPX(13));
 8026d10:	4b52      	ldr	r3, [pc, #328]	; (8026e5c <cpicker_init+0x2d0>)
 8026d12:	681b      	ldr	r3, [r3, #0]
 8026d14:	f103 0440 	add.w	r4, r3, #64	; 0x40
 8026d18:	2000      	movs	r0, #0
 8026d1a:	f7f7 fefb 	bl	801eb14 <lv_disp_get_dpi>
 8026d1e:	4603      	mov	r3, r0
 8026d20:	461a      	mov	r2, r3
 8026d22:	4613      	mov	r3, r2
 8026d24:	005b      	lsls	r3, r3, #1
 8026d26:	4413      	add	r3, r2
 8026d28:	009b      	lsls	r3, r3, #2
 8026d2a:	4413      	add	r3, r2
 8026d2c:	2bef      	cmp	r3, #239	; 0xef
 8026d2e:	dd12      	ble.n	8026d56 <cpicker_init+0x1ca>
 8026d30:	2000      	movs	r0, #0
 8026d32:	f7f7 feef 	bl	801eb14 <lv_disp_get_dpi>
 8026d36:	4603      	mov	r3, r0
 8026d38:	461a      	mov	r2, r3
 8026d3a:	4613      	mov	r3, r2
 8026d3c:	005b      	lsls	r3, r3, #1
 8026d3e:	4413      	add	r3, r2
 8026d40:	009b      	lsls	r3, r3, #2
 8026d42:	4413      	add	r3, r2
 8026d44:	3350      	adds	r3, #80	; 0x50
 8026d46:	4a46      	ldr	r2, [pc, #280]	; (8026e60 <cpicker_init+0x2d4>)
 8026d48:	fb82 1203 	smull	r1, r2, r2, r3
 8026d4c:	1192      	asrs	r2, r2, #6
 8026d4e:	17db      	asrs	r3, r3, #31
 8026d50:	1ad3      	subs	r3, r2, r3
 8026d52:	b21b      	sxth	r3, r3
 8026d54:	e000      	b.n	8026d58 <cpicker_init+0x1cc>
 8026d56:	2301      	movs	r3, #1
 8026d58:	461a      	mov	r2, r3
 8026d5a:	2100      	movs	r1, #0
 8026d5c:	4620      	mov	r0, r4
 8026d5e:	f7fc fa98 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->cpicker_indic, LV_STATE_DEFAULT, LV_DPX(13));
 8026d62:	4b3e      	ldr	r3, [pc, #248]	; (8026e5c <cpicker_init+0x2d0>)
 8026d64:	681b      	ldr	r3, [r3, #0]
 8026d66:	f103 0440 	add.w	r4, r3, #64	; 0x40
 8026d6a:	2000      	movs	r0, #0
 8026d6c:	f7f7 fed2 	bl	801eb14 <lv_disp_get_dpi>
 8026d70:	4603      	mov	r3, r0
 8026d72:	461a      	mov	r2, r3
 8026d74:	4613      	mov	r3, r2
 8026d76:	005b      	lsls	r3, r3, #1
 8026d78:	4413      	add	r3, r2
 8026d7a:	009b      	lsls	r3, r3, #2
 8026d7c:	4413      	add	r3, r2
 8026d7e:	2bef      	cmp	r3, #239	; 0xef
 8026d80:	dd12      	ble.n	8026da8 <cpicker_init+0x21c>
 8026d82:	2000      	movs	r0, #0
 8026d84:	f7f7 fec6 	bl	801eb14 <lv_disp_get_dpi>
 8026d88:	4603      	mov	r3, r0
 8026d8a:	461a      	mov	r2, r3
 8026d8c:	4613      	mov	r3, r2
 8026d8e:	005b      	lsls	r3, r3, #1
 8026d90:	4413      	add	r3, r2
 8026d92:	009b      	lsls	r3, r3, #2
 8026d94:	4413      	add	r3, r2
 8026d96:	3350      	adds	r3, #80	; 0x50
 8026d98:	4a31      	ldr	r2, [pc, #196]	; (8026e60 <cpicker_init+0x2d4>)
 8026d9a:	fb82 1203 	smull	r1, r2, r2, r3
 8026d9e:	1192      	asrs	r2, r2, #6
 8026da0:	17db      	asrs	r3, r3, #31
 8026da2:	1ad3      	subs	r3, r2, r3
 8026da4:	b21b      	sxth	r3, r3
 8026da6:	e000      	b.n	8026daa <cpicker_init+0x21e>
 8026da8:	2301      	movs	r3, #1
 8026daa:	461a      	mov	r2, r3
 8026dac:	2100      	movs	r1, #0
 8026dae:	4620      	mov	r0, r4
 8026db0:	f7fc fa87 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->cpicker_indic, LV_STATE_DEFAULT, LV_DPX(13));
 8026db4:	4b29      	ldr	r3, [pc, #164]	; (8026e5c <cpicker_init+0x2d0>)
 8026db6:	681b      	ldr	r3, [r3, #0]
 8026db8:	f103 0440 	add.w	r4, r3, #64	; 0x40
 8026dbc:	2000      	movs	r0, #0
 8026dbe:	f7f7 fea9 	bl	801eb14 <lv_disp_get_dpi>
 8026dc2:	4603      	mov	r3, r0
 8026dc4:	461a      	mov	r2, r3
 8026dc6:	4613      	mov	r3, r2
 8026dc8:	005b      	lsls	r3, r3, #1
 8026dca:	4413      	add	r3, r2
 8026dcc:	009b      	lsls	r3, r3, #2
 8026dce:	4413      	add	r3, r2
 8026dd0:	2bef      	cmp	r3, #239	; 0xef
 8026dd2:	dd12      	ble.n	8026dfa <cpicker_init+0x26e>
 8026dd4:	2000      	movs	r0, #0
 8026dd6:	f7f7 fe9d 	bl	801eb14 <lv_disp_get_dpi>
 8026dda:	4603      	mov	r3, r0
 8026ddc:	461a      	mov	r2, r3
 8026dde:	4613      	mov	r3, r2
 8026de0:	005b      	lsls	r3, r3, #1
 8026de2:	4413      	add	r3, r2
 8026de4:	009b      	lsls	r3, r3, #2
 8026de6:	4413      	add	r3, r2
 8026de8:	3350      	adds	r3, #80	; 0x50
 8026dea:	4a1d      	ldr	r2, [pc, #116]	; (8026e60 <cpicker_init+0x2d4>)
 8026dec:	fb82 1203 	smull	r1, r2, r2, r3
 8026df0:	1192      	asrs	r2, r2, #6
 8026df2:	17db      	asrs	r3, r3, #31
 8026df4:	1ad3      	subs	r3, r2, r3
 8026df6:	b21b      	sxth	r3, r3
 8026df8:	e000      	b.n	8026dfc <cpicker_init+0x270>
 8026dfa:	2301      	movs	r3, #1
 8026dfc:	461a      	mov	r2, r3
 8026dfe:	2100      	movs	r1, #0
 8026e00:	4620      	mov	r0, r4
 8026e02:	f7fc fa16 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->cpicker_indic, LV_STATE_DEFAULT, LV_DPX(13));
 8026e06:	4b15      	ldr	r3, [pc, #84]	; (8026e5c <cpicker_init+0x2d0>)
 8026e08:	681b      	ldr	r3, [r3, #0]
 8026e0a:	f103 0440 	add.w	r4, r3, #64	; 0x40
 8026e0e:	2000      	movs	r0, #0
 8026e10:	f7f7 fe80 	bl	801eb14 <lv_disp_get_dpi>
 8026e14:	4603      	mov	r3, r0
 8026e16:	461a      	mov	r2, r3
 8026e18:	4613      	mov	r3, r2
 8026e1a:	005b      	lsls	r3, r3, #1
 8026e1c:	4413      	add	r3, r2
 8026e1e:	009b      	lsls	r3, r3, #2
 8026e20:	4413      	add	r3, r2
 8026e22:	2bef      	cmp	r3, #239	; 0xef
 8026e24:	dd12      	ble.n	8026e4c <cpicker_init+0x2c0>
 8026e26:	2000      	movs	r0, #0
 8026e28:	f7f7 fe74 	bl	801eb14 <lv_disp_get_dpi>
 8026e2c:	4603      	mov	r3, r0
 8026e2e:	461a      	mov	r2, r3
 8026e30:	4613      	mov	r3, r2
 8026e32:	005b      	lsls	r3, r3, #1
 8026e34:	4413      	add	r3, r2
 8026e36:	009b      	lsls	r3, r3, #2
 8026e38:	4413      	add	r3, r2
 8026e3a:	3350      	adds	r3, #80	; 0x50
 8026e3c:	4a08      	ldr	r2, [pc, #32]	; (8026e60 <cpicker_init+0x2d4>)
 8026e3e:	fb82 1203 	smull	r1, r2, r2, r3
 8026e42:	1192      	asrs	r2, r2, #6
 8026e44:	17db      	asrs	r3, r3, #31
 8026e46:	1ad3      	subs	r3, r2, r3
 8026e48:	b21b      	sxth	r3, r3
 8026e4a:	e000      	b.n	8026e4e <cpicker_init+0x2c2>
 8026e4c:	2301      	movs	r3, #1
 8026e4e:	461a      	mov	r2, r3
 8026e50:	2100      	movs	r1, #0
 8026e52:	4620      	mov	r0, r4
 8026e54:	f7fc fa05 	bl	8023262 <lv_style_set_pad_bottom>
#endif
}
 8026e58:	bf00      	nop
 8026e5a:	bd98      	pop	{r3, r4, r7, pc}
 8026e5c:	20012350 	.word	0x20012350
 8026e60:	66666667 	.word	0x66666667
 8026e64:	20012328 	.word	0x20012328
 8026e68:	00eaeff3 	.word	0x00eaeff3
 8026e6c:	00444b5a 	.word	0x00444b5a
 8026e70:	0802e594 	.word	0x0802e594
 8026e74:	0802e598 	.word	0x0802e598

08026e78 <checkbox_init>:

static void checkbox_init(void)
{
 8026e78:	b598      	push	{r3, r4, r7, lr}
 8026e7a:	af00      	add	r7, sp, #0
#if LV_USE_CHECKBOX != 0
    style_init_reset(&styles->cb_bg);
 8026e7c:	4bc6      	ldr	r3, [pc, #792]	; (8027198 <checkbox_init+0x320>)
 8026e7e:	681b      	ldr	r3, [r3, #0]
 8026e80:	3350      	adds	r3, #80	; 0x50
 8026e82:	4618      	mov	r0, r3
 8026e84:	f002 fcc2 	bl	802980c <style_init_reset>
    lv_style_set_radius(&styles->cb_bg, LV_STATE_DEFAULT, LV_DPX(4));
 8026e88:	4bc3      	ldr	r3, [pc, #780]	; (8027198 <checkbox_init+0x320>)
 8026e8a:	681b      	ldr	r3, [r3, #0]
 8026e8c:	f103 0450 	add.w	r4, r3, #80	; 0x50
 8026e90:	2000      	movs	r0, #0
 8026e92:	f7f7 fe3f 	bl	801eb14 <lv_disp_get_dpi>
 8026e96:	4603      	mov	r3, r0
 8026e98:	2b3b      	cmp	r3, #59	; 0x3b
 8026e9a:	dd0c      	ble.n	8026eb6 <checkbox_init+0x3e>
 8026e9c:	2000      	movs	r0, #0
 8026e9e:	f7f7 fe39 	bl	801eb14 <lv_disp_get_dpi>
 8026ea2:	4603      	mov	r3, r0
 8026ea4:	3314      	adds	r3, #20
 8026ea6:	4abd      	ldr	r2, [pc, #756]	; (802719c <checkbox_init+0x324>)
 8026ea8:	fb82 1203 	smull	r1, r2, r2, r3
 8026eac:	1112      	asrs	r2, r2, #4
 8026eae:	17db      	asrs	r3, r3, #31
 8026eb0:	1ad3      	subs	r3, r2, r3
 8026eb2:	b21b      	sxth	r3, r3
 8026eb4:	e000      	b.n	8026eb8 <checkbox_init+0x40>
 8026eb6:	2301      	movs	r3, #1
 8026eb8:	461a      	mov	r2, r3
 8026eba:	2100      	movs	r1, #0
 8026ebc:	4620      	mov	r0, r4
 8026ebe:	f7fc f958 	bl	8023172 <lv_style_set_radius>
    lv_style_set_pad_inner(&styles->cb_bg, LV_STATE_DEFAULT, LV_DPX(10));
 8026ec2:	4bb5      	ldr	r3, [pc, #724]	; (8027198 <checkbox_init+0x320>)
 8026ec4:	681b      	ldr	r3, [r3, #0]
 8026ec6:	f103 0450 	add.w	r4, r3, #80	; 0x50
 8026eca:	2000      	movs	r0, #0
 8026ecc:	f7f7 fe22 	bl	801eb14 <lv_disp_get_dpi>
 8026ed0:	4603      	mov	r3, r0
 8026ed2:	461a      	mov	r2, r3
 8026ed4:	4613      	mov	r3, r2
 8026ed6:	009b      	lsls	r3, r3, #2
 8026ed8:	4413      	add	r3, r2
 8026eda:	005b      	lsls	r3, r3, #1
 8026edc:	2bef      	cmp	r3, #239	; 0xef
 8026ede:	dd11      	ble.n	8026f04 <checkbox_init+0x8c>
 8026ee0:	2000      	movs	r0, #0
 8026ee2:	f7f7 fe17 	bl	801eb14 <lv_disp_get_dpi>
 8026ee6:	4603      	mov	r3, r0
 8026ee8:	461a      	mov	r2, r3
 8026eea:	4613      	mov	r3, r2
 8026eec:	009b      	lsls	r3, r3, #2
 8026eee:	4413      	add	r3, r2
 8026ef0:	005b      	lsls	r3, r3, #1
 8026ef2:	3350      	adds	r3, #80	; 0x50
 8026ef4:	4aa9      	ldr	r2, [pc, #676]	; (802719c <checkbox_init+0x324>)
 8026ef6:	fb82 1203 	smull	r1, r2, r2, r3
 8026efa:	1192      	asrs	r2, r2, #6
 8026efc:	17db      	asrs	r3, r3, #31
 8026efe:	1ad3      	subs	r3, r2, r3
 8026f00:	b21b      	sxth	r3, r3
 8026f02:	e000      	b.n	8026f06 <checkbox_init+0x8e>
 8026f04:	2301      	movs	r3, #1
 8026f06:	461a      	mov	r2, r3
 8026f08:	2100      	movs	r1, #0
 8026f0a:	4620      	mov	r0, r4
 8026f0c:	f7fc f9f1 	bl	80232f2 <lv_style_set_pad_inner>
    lv_style_set_outline_color(&styles->cb_bg, LV_STATE_DEFAULT, theme.color_primary);
 8026f10:	4ba1      	ldr	r3, [pc, #644]	; (8027198 <checkbox_init+0x320>)
 8026f12:	681b      	ldr	r3, [r3, #0]
 8026f14:	3350      	adds	r3, #80	; 0x50
 8026f16:	4aa2      	ldr	r2, [pc, #648]	; (80271a0 <checkbox_init+0x328>)
 8026f18:	8992      	ldrh	r2, [r2, #12]
 8026f1a:	2100      	movs	r1, #0
 8026f1c:	4618      	mov	r0, r3
 8026f1e:	f7fc fb32 	bl	8023586 <lv_style_set_outline_color>
    lv_style_set_outline_opa(&styles->cb_bg, LV_STATE_DEFAULT, LV_OPA_TRANSP);
 8026f22:	4b9d      	ldr	r3, [pc, #628]	; (8027198 <checkbox_init+0x320>)
 8026f24:	681b      	ldr	r3, [r3, #0]
 8026f26:	3350      	adds	r3, #80	; 0x50
 8026f28:	2200      	movs	r2, #0
 8026f2a:	2100      	movs	r1, #0
 8026f2c:	4618      	mov	r0, r3
 8026f2e:	f7fc fb40 	bl	80235b2 <lv_style_set_outline_opa>
    lv_style_set_outline_opa(&styles->cb_bg, LV_STATE_FOCUSED, LV_OPA_50);
 8026f32:	4b99      	ldr	r3, [pc, #612]	; (8027198 <checkbox_init+0x320>)
 8026f34:	681b      	ldr	r3, [r3, #0]
 8026f36:	3350      	adds	r3, #80	; 0x50
 8026f38:	227f      	movs	r2, #127	; 0x7f
 8026f3a:	2102      	movs	r1, #2
 8026f3c:	4618      	mov	r0, r3
 8026f3e:	f7fc fb38 	bl	80235b2 <lv_style_set_outline_opa>
    lv_style_set_outline_width(&styles->cb_bg, LV_STATE_DEFAULT, OUTLINE_WIDTH);
 8026f42:	4b95      	ldr	r3, [pc, #596]	; (8027198 <checkbox_init+0x320>)
 8026f44:	681b      	ldr	r3, [r3, #0]
 8026f46:	f103 0450 	add.w	r4, r3, #80	; 0x50
 8026f4a:	4b95      	ldr	r3, [pc, #596]	; (80271a0 <checkbox_init+0x328>)
 8026f4c:	6a1b      	ldr	r3, [r3, #32]
 8026f4e:	f003 0320 	and.w	r3, r3, #32
 8026f52:	2b00      	cmp	r3, #0
 8026f54:	d114      	bne.n	8026f80 <checkbox_init+0x108>
 8026f56:	2000      	movs	r0, #0
 8026f58:	f7f7 fddc 	bl	801eb14 <lv_disp_get_dpi>
 8026f5c:	4603      	mov	r3, r0
 8026f5e:	2b77      	cmp	r3, #119	; 0x77
 8026f60:	dd0c      	ble.n	8026f7c <checkbox_init+0x104>
 8026f62:	2000      	movs	r0, #0
 8026f64:	f7f7 fdd6 	bl	801eb14 <lv_disp_get_dpi>
 8026f68:	4603      	mov	r3, r0
 8026f6a:	3328      	adds	r3, #40	; 0x28
 8026f6c:	4a8b      	ldr	r2, [pc, #556]	; (802719c <checkbox_init+0x324>)
 8026f6e:	fb82 1203 	smull	r1, r2, r2, r3
 8026f72:	1152      	asrs	r2, r2, #5
 8026f74:	17db      	asrs	r3, r3, #31
 8026f76:	1ad3      	subs	r3, r2, r3
 8026f78:	b21b      	sxth	r3, r3
 8026f7a:	e002      	b.n	8026f82 <checkbox_init+0x10a>
 8026f7c:	2301      	movs	r3, #1
 8026f7e:	e000      	b.n	8026f82 <checkbox_init+0x10a>
 8026f80:	2300      	movs	r3, #0
 8026f82:	461a      	mov	r2, r3
 8026f84:	2100      	movs	r1, #0
 8026f86:	4620      	mov	r0, r4
 8026f88:	f7fc facd 	bl	8023526 <lv_style_set_outline_width>
    lv_style_set_outline_pad(&styles->cb_bg, LV_STATE_DEFAULT, LV_DPX(10));
 8026f8c:	4b82      	ldr	r3, [pc, #520]	; (8027198 <checkbox_init+0x320>)
 8026f8e:	681b      	ldr	r3, [r3, #0]
 8026f90:	f103 0450 	add.w	r4, r3, #80	; 0x50
 8026f94:	2000      	movs	r0, #0
 8026f96:	f7f7 fdbd 	bl	801eb14 <lv_disp_get_dpi>
 8026f9a:	4603      	mov	r3, r0
 8026f9c:	461a      	mov	r2, r3
 8026f9e:	4613      	mov	r3, r2
 8026fa0:	009b      	lsls	r3, r3, #2
 8026fa2:	4413      	add	r3, r2
 8026fa4:	005b      	lsls	r3, r3, #1
 8026fa6:	2bef      	cmp	r3, #239	; 0xef
 8026fa8:	dd11      	ble.n	8026fce <checkbox_init+0x156>
 8026faa:	2000      	movs	r0, #0
 8026fac:	f7f7 fdb2 	bl	801eb14 <lv_disp_get_dpi>
 8026fb0:	4603      	mov	r3, r0
 8026fb2:	461a      	mov	r2, r3
 8026fb4:	4613      	mov	r3, r2
 8026fb6:	009b      	lsls	r3, r3, #2
 8026fb8:	4413      	add	r3, r2
 8026fba:	005b      	lsls	r3, r3, #1
 8026fbc:	3350      	adds	r3, #80	; 0x50
 8026fbe:	4a77      	ldr	r2, [pc, #476]	; (802719c <checkbox_init+0x324>)
 8026fc0:	fb82 1203 	smull	r1, r2, r2, r3
 8026fc4:	1192      	asrs	r2, r2, #6
 8026fc6:	17db      	asrs	r3, r3, #31
 8026fc8:	1ad3      	subs	r3, r2, r3
 8026fca:	b21b      	sxth	r3, r3
 8026fcc:	e000      	b.n	8026fd0 <checkbox_init+0x158>
 8026fce:	2301      	movs	r3, #1
 8026fd0:	461a      	mov	r2, r3
 8026fd2:	2100      	movs	r1, #0
 8026fd4:	4620      	mov	r0, r4
 8026fd6:	f7fc fabe 	bl	8023556 <lv_style_set_outline_pad>
    lv_style_set_transition_time(&styles->cb_bg, LV_STATE_DEFAULT, TRANSITION_TIME);
 8026fda:	4b6f      	ldr	r3, [pc, #444]	; (8027198 <checkbox_init+0x320>)
 8026fdc:	681b      	ldr	r3, [r3, #0]
 8026fde:	f103 0050 	add.w	r0, r3, #80	; 0x50
 8026fe2:	4b6f      	ldr	r3, [pc, #444]	; (80271a0 <checkbox_init+0x328>)
 8026fe4:	6a1b      	ldr	r3, [r3, #32]
 8026fe6:	f003 0310 	and.w	r3, r3, #16
 8026fea:	2b00      	cmp	r3, #0
 8026fec:	d001      	beq.n	8026ff2 <checkbox_init+0x17a>
 8026fee:	2300      	movs	r3, #0
 8026ff0:	e000      	b.n	8026ff4 <checkbox_init+0x17c>
 8026ff2:	2396      	movs	r3, #150	; 0x96
 8026ff4:	461a      	mov	r2, r3
 8026ff6:	2100      	movs	r1, #0
 8026ff8:	f7fc fc80 	bl	80238fc <lv_style_set_transition_time>
    lv_style_set_transition_prop_6(&styles->cb_bg, LV_STATE_DEFAULT, LV_STYLE_OUTLINE_OPA);
 8026ffc:	4b66      	ldr	r3, [pc, #408]	; (8027198 <checkbox_init+0x320>)
 8026ffe:	681b      	ldr	r3, [r3, #0]
 8027000:	3350      	adds	r3, #80	; 0x50
 8027002:	224c      	movs	r2, #76	; 0x4c
 8027004:	2100      	movs	r1, #0
 8027006:	4618      	mov	r0, r3
 8027008:	f7fc fcf0 	bl	80239ec <lv_style_set_transition_prop_6>

    style_init_reset(&styles->cb_bullet);
 802700c:	4b62      	ldr	r3, [pc, #392]	; (8027198 <checkbox_init+0x320>)
 802700e:	681b      	ldr	r3, [r3, #0]
 8027010:	3354      	adds	r3, #84	; 0x54
 8027012:	4618      	mov	r0, r3
 8027014:	f002 fbfa 	bl	802980c <style_init_reset>
    lv_style_set_outline_opa(&styles->cb_bullet, LV_STATE_FOCUSED, LV_OPA_TRANSP);
 8027018:	4b5f      	ldr	r3, [pc, #380]	; (8027198 <checkbox_init+0x320>)
 802701a:	681b      	ldr	r3, [r3, #0]
 802701c:	3354      	adds	r3, #84	; 0x54
 802701e:	2200      	movs	r2, #0
 8027020:	2102      	movs	r1, #2
 8027022:	4618      	mov	r0, r3
 8027024:	f7fc fac5 	bl	80235b2 <lv_style_set_outline_opa>
    lv_style_set_radius(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(4));
 8027028:	4b5b      	ldr	r3, [pc, #364]	; (8027198 <checkbox_init+0x320>)
 802702a:	681b      	ldr	r3, [r3, #0]
 802702c:	f103 0454 	add.w	r4, r3, #84	; 0x54
 8027030:	2000      	movs	r0, #0
 8027032:	f7f7 fd6f 	bl	801eb14 <lv_disp_get_dpi>
 8027036:	4603      	mov	r3, r0
 8027038:	2b3b      	cmp	r3, #59	; 0x3b
 802703a:	dd0c      	ble.n	8027056 <checkbox_init+0x1de>
 802703c:	2000      	movs	r0, #0
 802703e:	f7f7 fd69 	bl	801eb14 <lv_disp_get_dpi>
 8027042:	4603      	mov	r3, r0
 8027044:	3314      	adds	r3, #20
 8027046:	4a55      	ldr	r2, [pc, #340]	; (802719c <checkbox_init+0x324>)
 8027048:	fb82 1203 	smull	r1, r2, r2, r3
 802704c:	1112      	asrs	r2, r2, #4
 802704e:	17db      	asrs	r3, r3, #31
 8027050:	1ad3      	subs	r3, r2, r3
 8027052:	b21b      	sxth	r3, r3
 8027054:	e000      	b.n	8027058 <checkbox_init+0x1e0>
 8027056:	2301      	movs	r3, #1
 8027058:	461a      	mov	r2, r3
 802705a:	2100      	movs	r1, #0
 802705c:	4620      	mov	r0, r4
 802705e:	f7fc f888 	bl	8023172 <lv_style_set_radius>
    lv_style_set_pattern_image(&styles->cb_bullet, LV_STATE_CHECKED, LV_SYMBOL_OK);
 8027062:	4b4d      	ldr	r3, [pc, #308]	; (8027198 <checkbox_init+0x320>)
 8027064:	681b      	ldr	r3, [r3, #0]
 8027066:	3354      	adds	r3, #84	; 0x54
 8027068:	4a4e      	ldr	r2, [pc, #312]	; (80271a4 <checkbox_init+0x32c>)
 802706a:	2101      	movs	r1, #1
 802706c:	4618      	mov	r0, r3
 802706e:	f7fc fb2a 	bl	80236c6 <lv_style_set_pattern_image>
    lv_style_set_pattern_recolor(&styles->cb_bullet, LV_STATE_CHECKED, LV_COLOR_WHITE);
 8027072:	4b49      	ldr	r3, [pc, #292]	; (8027198 <checkbox_init+0x320>)
 8027074:	681b      	ldr	r3, [r3, #0]
 8027076:	3354      	adds	r3, #84	; 0x54
 8027078:	4a4b      	ldr	r2, [pc, #300]	; (80271a8 <checkbox_init+0x330>)
 802707a:	8812      	ldrh	r2, [r2, #0]
 802707c:	2101      	movs	r1, #1
 802707e:	4618      	mov	r0, r3
 8027080:	f7fc faf4 	bl	802366c <lv_style_set_pattern_recolor>
    lv_style_set_pattern_opa(&styles->cb_bullet, LV_STATE_DEFAULT, LV_OPA_TRANSP);
 8027084:	4b44      	ldr	r3, [pc, #272]	; (8027198 <checkbox_init+0x320>)
 8027086:	681b      	ldr	r3, [r3, #0]
 8027088:	3354      	adds	r3, #84	; 0x54
 802708a:	2200      	movs	r2, #0
 802708c:	2100      	movs	r1, #0
 802708e:	4618      	mov	r0, r3
 8027090:	f7fc fb02 	bl	8023698 <lv_style_set_pattern_opa>
    lv_style_set_pattern_opa(&styles->cb_bullet, LV_STATE_CHECKED, LV_OPA_COVER);
 8027094:	4b40      	ldr	r3, [pc, #256]	; (8027198 <checkbox_init+0x320>)
 8027096:	681b      	ldr	r3, [r3, #0]
 8027098:	3354      	adds	r3, #84	; 0x54
 802709a:	22ff      	movs	r2, #255	; 0xff
 802709c:	2101      	movs	r1, #1
 802709e:	4618      	mov	r0, r3
 80270a0:	f7fc fafa 	bl	8023698 <lv_style_set_pattern_opa>
    lv_style_set_transition_prop_3(&styles->cb_bullet, LV_STATE_DEFAULT, LV_STYLE_PATTERN_OPA);
 80270a4:	4b3c      	ldr	r3, [pc, #240]	; (8027198 <checkbox_init+0x320>)
 80270a6:	681b      	ldr	r3, [r3, #0]
 80270a8:	3354      	adds	r3, #84	; 0x54
 80270aa:	226c      	movs	r2, #108	; 0x6c
 80270ac:	2100      	movs	r1, #0
 80270ae:	4618      	mov	r0, r3
 80270b0:	f7fc fc54 	bl	802395c <lv_style_set_transition_prop_3>
    lv_style_set_text_font(&styles->cb_bullet, LV_STATE_CHECKED, theme.font_small);
 80270b4:	4b38      	ldr	r3, [pc, #224]	; (8027198 <checkbox_init+0x320>)
 80270b6:	681b      	ldr	r3, [r3, #0]
 80270b8:	3354      	adds	r3, #84	; 0x54
 80270ba:	4a39      	ldr	r2, [pc, #228]	; (80271a0 <checkbox_init+0x328>)
 80270bc:	6912      	ldr	r2, [r2, #16]
 80270be:	2101      	movs	r1, #1
 80270c0:	4618      	mov	r0, r3
 80270c2:	f7fc fb75 	bl	80237b0 <lv_style_set_text_font>
    lv_style_set_pad_left(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
 80270c6:	4b34      	ldr	r3, [pc, #208]	; (8027198 <checkbox_init+0x320>)
 80270c8:	681b      	ldr	r3, [r3, #0]
 80270ca:	f103 0454 	add.w	r4, r3, #84	; 0x54
 80270ce:	2000      	movs	r0, #0
 80270d0:	f7f7 fd20 	bl	801eb14 <lv_disp_get_dpi>
 80270d4:	4603      	mov	r3, r0
 80270d6:	461a      	mov	r2, r3
 80270d8:	4613      	mov	r3, r2
 80270da:	005b      	lsls	r3, r3, #1
 80270dc:	4413      	add	r3, r2
 80270de:	2bef      	cmp	r3, #239	; 0xef
 80270e0:	dd10      	ble.n	8027104 <checkbox_init+0x28c>
 80270e2:	2000      	movs	r0, #0
 80270e4:	f7f7 fd16 	bl	801eb14 <lv_disp_get_dpi>
 80270e8:	4603      	mov	r3, r0
 80270ea:	461a      	mov	r2, r3
 80270ec:	4613      	mov	r3, r2
 80270ee:	005b      	lsls	r3, r3, #1
 80270f0:	4413      	add	r3, r2
 80270f2:	3350      	adds	r3, #80	; 0x50
 80270f4:	4a29      	ldr	r2, [pc, #164]	; (802719c <checkbox_init+0x324>)
 80270f6:	fb82 1203 	smull	r1, r2, r2, r3
 80270fa:	1192      	asrs	r2, r2, #6
 80270fc:	17db      	asrs	r3, r3, #31
 80270fe:	1ad3      	subs	r3, r2, r3
 8027100:	b21b      	sxth	r3, r3
 8027102:	e000      	b.n	8027106 <checkbox_init+0x28e>
 8027104:	2301      	movs	r3, #1
 8027106:	461a      	mov	r2, r3
 8027108:	2100      	movs	r1, #0
 802710a:	4620      	mov	r0, r4
 802710c:	f7fc f8c1 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
 8027110:	4b21      	ldr	r3, [pc, #132]	; (8027198 <checkbox_init+0x320>)
 8027112:	681b      	ldr	r3, [r3, #0]
 8027114:	f103 0454 	add.w	r4, r3, #84	; 0x54
 8027118:	2000      	movs	r0, #0
 802711a:	f7f7 fcfb 	bl	801eb14 <lv_disp_get_dpi>
 802711e:	4603      	mov	r3, r0
 8027120:	461a      	mov	r2, r3
 8027122:	4613      	mov	r3, r2
 8027124:	005b      	lsls	r3, r3, #1
 8027126:	4413      	add	r3, r2
 8027128:	2bef      	cmp	r3, #239	; 0xef
 802712a:	dd10      	ble.n	802714e <checkbox_init+0x2d6>
 802712c:	2000      	movs	r0, #0
 802712e:	f7f7 fcf1 	bl	801eb14 <lv_disp_get_dpi>
 8027132:	4603      	mov	r3, r0
 8027134:	461a      	mov	r2, r3
 8027136:	4613      	mov	r3, r2
 8027138:	005b      	lsls	r3, r3, #1
 802713a:	4413      	add	r3, r2
 802713c:	3350      	adds	r3, #80	; 0x50
 802713e:	4a17      	ldr	r2, [pc, #92]	; (802719c <checkbox_init+0x324>)
 8027140:	fb82 1203 	smull	r1, r2, r2, r3
 8027144:	1192      	asrs	r2, r2, #6
 8027146:	17db      	asrs	r3, r3, #31
 8027148:	1ad3      	subs	r3, r2, r3
 802714a:	b21b      	sxth	r3, r3
 802714c:	e000      	b.n	8027150 <checkbox_init+0x2d8>
 802714e:	2301      	movs	r3, #1
 8027150:	461a      	mov	r2, r3
 8027152:	2100      	movs	r1, #0
 8027154:	4620      	mov	r0, r4
 8027156:	f7fc f8b4 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
 802715a:	4b0f      	ldr	r3, [pc, #60]	; (8027198 <checkbox_init+0x320>)
 802715c:	681b      	ldr	r3, [r3, #0]
 802715e:	f103 0454 	add.w	r4, r3, #84	; 0x54
 8027162:	2000      	movs	r0, #0
 8027164:	f7f7 fcd6 	bl	801eb14 <lv_disp_get_dpi>
 8027168:	4603      	mov	r3, r0
 802716a:	461a      	mov	r2, r3
 802716c:	4613      	mov	r3, r2
 802716e:	005b      	lsls	r3, r3, #1
 8027170:	4413      	add	r3, r2
 8027172:	2bef      	cmp	r3, #239	; 0xef
 8027174:	dd1a      	ble.n	80271ac <checkbox_init+0x334>
 8027176:	2000      	movs	r0, #0
 8027178:	f7f7 fccc 	bl	801eb14 <lv_disp_get_dpi>
 802717c:	4603      	mov	r3, r0
 802717e:	461a      	mov	r2, r3
 8027180:	4613      	mov	r3, r2
 8027182:	005b      	lsls	r3, r3, #1
 8027184:	4413      	add	r3, r2
 8027186:	3350      	adds	r3, #80	; 0x50
 8027188:	4a04      	ldr	r2, [pc, #16]	; (802719c <checkbox_init+0x324>)
 802718a:	fb82 1203 	smull	r1, r2, r2, r3
 802718e:	1192      	asrs	r2, r2, #6
 8027190:	17db      	asrs	r3, r3, #31
 8027192:	1ad3      	subs	r3, r2, r3
 8027194:	b21b      	sxth	r3, r3
 8027196:	e00a      	b.n	80271ae <checkbox_init+0x336>
 8027198:	20012350 	.word	0x20012350
 802719c:	66666667 	.word	0x66666667
 80271a0:	20012328 	.word	0x20012328
 80271a4:	0802e59c 	.word	0x0802e59c
 80271a8:	0802e594 	.word	0x0802e594
 80271ac:	2301      	movs	r3, #1
 80271ae:	461a      	mov	r2, r3
 80271b0:	2100      	movs	r1, #0
 80271b2:	4620      	mov	r0, r4
 80271b4:	f7fc f83d 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->cb_bullet, LV_STATE_DEFAULT, LV_DPX(3));
 80271b8:	4b13      	ldr	r3, [pc, #76]	; (8027208 <checkbox_init+0x390>)
 80271ba:	681b      	ldr	r3, [r3, #0]
 80271bc:	f103 0454 	add.w	r4, r3, #84	; 0x54
 80271c0:	2000      	movs	r0, #0
 80271c2:	f7f7 fca7 	bl	801eb14 <lv_disp_get_dpi>
 80271c6:	4603      	mov	r3, r0
 80271c8:	461a      	mov	r2, r3
 80271ca:	4613      	mov	r3, r2
 80271cc:	005b      	lsls	r3, r3, #1
 80271ce:	4413      	add	r3, r2
 80271d0:	2bef      	cmp	r3, #239	; 0xef
 80271d2:	dd10      	ble.n	80271f6 <checkbox_init+0x37e>
 80271d4:	2000      	movs	r0, #0
 80271d6:	f7f7 fc9d 	bl	801eb14 <lv_disp_get_dpi>
 80271da:	4603      	mov	r3, r0
 80271dc:	461a      	mov	r2, r3
 80271de:	4613      	mov	r3, r2
 80271e0:	005b      	lsls	r3, r3, #1
 80271e2:	4413      	add	r3, r2
 80271e4:	3350      	adds	r3, #80	; 0x50
 80271e6:	4a09      	ldr	r2, [pc, #36]	; (802720c <checkbox_init+0x394>)
 80271e8:	fb82 1203 	smull	r1, r2, r2, r3
 80271ec:	1192      	asrs	r2, r2, #6
 80271ee:	17db      	asrs	r3, r3, #31
 80271f0:	1ad3      	subs	r3, r2, r3
 80271f2:	b21b      	sxth	r3, r3
 80271f4:	e000      	b.n	80271f8 <checkbox_init+0x380>
 80271f6:	2301      	movs	r3, #1
 80271f8:	461a      	mov	r2, r3
 80271fa:	2100      	movs	r1, #0
 80271fc:	4620      	mov	r0, r4
 80271fe:	f7fc f830 	bl	8023262 <lv_style_set_pad_bottom>
#endif
}
 8027202:	bf00      	nop
 8027204:	bd98      	pop	{r3, r4, r7, pc}
 8027206:	bf00      	nop
 8027208:	20012350 	.word	0x20012350
 802720c:	66666667 	.word	0x66666667

08027210 <btnmatrix_init>:

static void btnmatrix_init(void)
{
 8027210:	b480      	push	{r7}
 8027212:	af00      	add	r7, sp, #0
}
 8027214:	bf00      	nop
 8027216:	46bd      	mov	sp, r7
 8027218:	f85d 7b04 	ldr.w	r7, [sp], #4
 802721c:	4770      	bx	lr
	...

08027220 <keyboard_init>:

static void keyboard_init(void)
{
 8027220:	b5b0      	push	{r4, r5, r7, lr}
 8027222:	af00      	add	r7, sp, #0
#if LV_USE_KEYBOARD
    style_init_reset(&styles->kb_bg);
 8027224:	4b8e      	ldr	r3, [pc, #568]	; (8027460 <keyboard_init+0x240>)
 8027226:	681b      	ldr	r3, [r3, #0]
 8027228:	336c      	adds	r3, #108	; 0x6c
 802722a:	4618      	mov	r0, r3
 802722c:	f002 faee 	bl	802980c <style_init_reset>
    lv_style_set_radius(&styles->kb_bg, LV_STATE_DEFAULT, 0);
 8027230:	4b8b      	ldr	r3, [pc, #556]	; (8027460 <keyboard_init+0x240>)
 8027232:	681b      	ldr	r3, [r3, #0]
 8027234:	336c      	adds	r3, #108	; 0x6c
 8027236:	2200      	movs	r2, #0
 8027238:	2100      	movs	r1, #0
 802723a:	4618      	mov	r0, r3
 802723c:	f7fb ff99 	bl	8023172 <lv_style_set_radius>
    lv_style_set_border_width(&styles->kb_bg, LV_STATE_DEFAULT, LV_DPX(4));
 8027240:	4b87      	ldr	r3, [pc, #540]	; (8027460 <keyboard_init+0x240>)
 8027242:	681b      	ldr	r3, [r3, #0]
 8027244:	f103 056c 	add.w	r5, r3, #108	; 0x6c
 8027248:	2000      	movs	r0, #0
 802724a:	f7f7 fc63 	bl	801eb14 <lv_disp_get_dpi>
 802724e:	4603      	mov	r3, r0
 8027250:	2b3b      	cmp	r3, #59	; 0x3b
 8027252:	dd0c      	ble.n	802726e <keyboard_init+0x4e>
 8027254:	2000      	movs	r0, #0
 8027256:	f7f7 fc5d 	bl	801eb14 <lv_disp_get_dpi>
 802725a:	4603      	mov	r3, r0
 802725c:	3314      	adds	r3, #20
 802725e:	4a81      	ldr	r2, [pc, #516]	; (8027464 <keyboard_init+0x244>)
 8027260:	fb82 1203 	smull	r1, r2, r2, r3
 8027264:	1112      	asrs	r2, r2, #4
 8027266:	17db      	asrs	r3, r3, #31
 8027268:	1ad3      	subs	r3, r2, r3
 802726a:	b21b      	sxth	r3, r3
 802726c:	e000      	b.n	8027270 <keyboard_init+0x50>
 802726e:	2301      	movs	r3, #1
 8027270:	461a      	mov	r2, r3
 8027272:	2100      	movs	r1, #0
 8027274:	4628      	mov	r0, r5
 8027276:	f7fc f8e1 	bl	802343c <lv_style_set_border_width>
    lv_style_set_border_side(&styles->kb_bg, LV_STATE_DEFAULT, LV_BORDER_SIDE_TOP);
 802727a:	4b79      	ldr	r3, [pc, #484]	; (8027460 <keyboard_init+0x240>)
 802727c:	681b      	ldr	r3, [r3, #0]
 802727e:	336c      	adds	r3, #108	; 0x6c
 8027280:	2202      	movs	r2, #2
 8027282:	2100      	movs	r1, #0
 8027284:	4618      	mov	r0, r3
 8027286:	f7fc f8f1 	bl	802346c <lv_style_set_border_side>
    lv_style_set_border_color(&styles->kb_bg, LV_STATE_DEFAULT, IS_LIGHT ? COLOR_BG_TEXT : LV_COLOR_BLACK);
 802728a:	4b75      	ldr	r3, [pc, #468]	; (8027460 <keyboard_init+0x240>)
 802728c:	681b      	ldr	r3, [r3, #0]
 802728e:	f103 056c 	add.w	r5, r3, #108	; 0x6c
 8027292:	4b75      	ldr	r3, [pc, #468]	; (8027468 <keyboard_init+0x248>)
 8027294:	6a1b      	ldr	r3, [r3, #32]
 8027296:	f003 0302 	and.w	r3, r3, #2
 802729a:	2b00      	cmp	r3, #0
 802729c:	d010      	beq.n	80272c0 <keyboard_init+0xa0>
 802729e:	4b72      	ldr	r3, [pc, #456]	; (8027468 <keyboard_init+0x248>)
 80272a0:	6a1b      	ldr	r3, [r3, #32]
 80272a2:	f003 0302 	and.w	r3, r3, #2
 80272a6:	2b00      	cmp	r3, #0
 80272a8:	d004      	beq.n	80272b4 <keyboard_init+0x94>
 80272aa:	4870      	ldr	r0, [pc, #448]	; (802746c <keyboard_init+0x24c>)
 80272ac:	f7fb ff1b 	bl	80230e6 <lv_color_hex>
 80272b0:	4604      	mov	r4, r0
 80272b2:	e00b      	b.n	80272cc <keyboard_init+0xac>
 80272b4:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80272b8:	f7fb ff15 	bl	80230e6 <lv_color_hex>
 80272bc:	4604      	mov	r4, r0
 80272be:	e005      	b.n	80272cc <keyboard_init+0xac>
 80272c0:	f36f 0404 	bfc	r4, #0, #5
 80272c4:	f36f 144a 	bfc	r4, #5, #6
 80272c8:	f36f 24cf 	bfc	r4, #11, #5
 80272cc:	4622      	mov	r2, r4
 80272ce:	2100      	movs	r1, #0
 80272d0:	4628      	mov	r0, r5
 80272d2:	f7fc f8fb 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_color(&styles->kb_bg, LV_STATE_EDITED, theme.color_secondary);
 80272d6:	4b62      	ldr	r3, [pc, #392]	; (8027460 <keyboard_init+0x240>)
 80272d8:	681b      	ldr	r3, [r3, #0]
 80272da:	336c      	adds	r3, #108	; 0x6c
 80272dc:	4a62      	ldr	r2, [pc, #392]	; (8027468 <keyboard_init+0x248>)
 80272de:	89d2      	ldrh	r2, [r2, #14]
 80272e0:	2104      	movs	r1, #4
 80272e2:	4618      	mov	r0, r3
 80272e4:	f7fc f8f2 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_pad_left(&styles->kb_bg, LV_STATE_DEFAULT,  LV_DPX(5));
 80272e8:	4b5d      	ldr	r3, [pc, #372]	; (8027460 <keyboard_init+0x240>)
 80272ea:	681b      	ldr	r3, [r3, #0]
 80272ec:	f103 046c 	add.w	r4, r3, #108	; 0x6c
 80272f0:	2000      	movs	r0, #0
 80272f2:	f7f7 fc0f 	bl	801eb14 <lv_disp_get_dpi>
 80272f6:	4603      	mov	r3, r0
 80272f8:	461a      	mov	r2, r3
 80272fa:	4613      	mov	r3, r2
 80272fc:	009b      	lsls	r3, r3, #2
 80272fe:	4413      	add	r3, r2
 8027300:	2bef      	cmp	r3, #239	; 0xef
 8027302:	dd10      	ble.n	8027326 <keyboard_init+0x106>
 8027304:	2000      	movs	r0, #0
 8027306:	f7f7 fc05 	bl	801eb14 <lv_disp_get_dpi>
 802730a:	4603      	mov	r3, r0
 802730c:	461a      	mov	r2, r3
 802730e:	4613      	mov	r3, r2
 8027310:	009b      	lsls	r3, r3, #2
 8027312:	4413      	add	r3, r2
 8027314:	3350      	adds	r3, #80	; 0x50
 8027316:	4a53      	ldr	r2, [pc, #332]	; (8027464 <keyboard_init+0x244>)
 8027318:	fb82 1203 	smull	r1, r2, r2, r3
 802731c:	1192      	asrs	r2, r2, #6
 802731e:	17db      	asrs	r3, r3, #31
 8027320:	1ad3      	subs	r3, r2, r3
 8027322:	b21b      	sxth	r3, r3
 8027324:	e000      	b.n	8027328 <keyboard_init+0x108>
 8027326:	2301      	movs	r3, #1
 8027328:	461a      	mov	r2, r3
 802732a:	2100      	movs	r1, #0
 802732c:	4620      	mov	r0, r4
 802732e:	f7fb ffb0 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->kb_bg, LV_STATE_DEFAULT, LV_DPX(5));
 8027332:	4b4b      	ldr	r3, [pc, #300]	; (8027460 <keyboard_init+0x240>)
 8027334:	681b      	ldr	r3, [r3, #0]
 8027336:	f103 046c 	add.w	r4, r3, #108	; 0x6c
 802733a:	2000      	movs	r0, #0
 802733c:	f7f7 fbea 	bl	801eb14 <lv_disp_get_dpi>
 8027340:	4603      	mov	r3, r0
 8027342:	461a      	mov	r2, r3
 8027344:	4613      	mov	r3, r2
 8027346:	009b      	lsls	r3, r3, #2
 8027348:	4413      	add	r3, r2
 802734a:	2bef      	cmp	r3, #239	; 0xef
 802734c:	dd10      	ble.n	8027370 <keyboard_init+0x150>
 802734e:	2000      	movs	r0, #0
 8027350:	f7f7 fbe0 	bl	801eb14 <lv_disp_get_dpi>
 8027354:	4603      	mov	r3, r0
 8027356:	461a      	mov	r2, r3
 8027358:	4613      	mov	r3, r2
 802735a:	009b      	lsls	r3, r3, #2
 802735c:	4413      	add	r3, r2
 802735e:	3350      	adds	r3, #80	; 0x50
 8027360:	4a40      	ldr	r2, [pc, #256]	; (8027464 <keyboard_init+0x244>)
 8027362:	fb82 1203 	smull	r1, r2, r2, r3
 8027366:	1192      	asrs	r2, r2, #6
 8027368:	17db      	asrs	r3, r3, #31
 802736a:	1ad3      	subs	r3, r2, r3
 802736c:	b21b      	sxth	r3, r3
 802736e:	e000      	b.n	8027372 <keyboard_init+0x152>
 8027370:	2301      	movs	r3, #1
 8027372:	461a      	mov	r2, r3
 8027374:	2100      	movs	r1, #0
 8027376:	4620      	mov	r0, r4
 8027378:	f7fb ffa3 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->kb_bg, LV_STATE_DEFAULT,  LV_DPX(5));
 802737c:	4b38      	ldr	r3, [pc, #224]	; (8027460 <keyboard_init+0x240>)
 802737e:	681b      	ldr	r3, [r3, #0]
 8027380:	f103 046c 	add.w	r4, r3, #108	; 0x6c
 8027384:	2000      	movs	r0, #0
 8027386:	f7f7 fbc5 	bl	801eb14 <lv_disp_get_dpi>
 802738a:	4603      	mov	r3, r0
 802738c:	461a      	mov	r2, r3
 802738e:	4613      	mov	r3, r2
 8027390:	009b      	lsls	r3, r3, #2
 8027392:	4413      	add	r3, r2
 8027394:	2bef      	cmp	r3, #239	; 0xef
 8027396:	dd10      	ble.n	80273ba <keyboard_init+0x19a>
 8027398:	2000      	movs	r0, #0
 802739a:	f7f7 fbbb 	bl	801eb14 <lv_disp_get_dpi>
 802739e:	4603      	mov	r3, r0
 80273a0:	461a      	mov	r2, r3
 80273a2:	4613      	mov	r3, r2
 80273a4:	009b      	lsls	r3, r3, #2
 80273a6:	4413      	add	r3, r2
 80273a8:	3350      	adds	r3, #80	; 0x50
 80273aa:	4a2e      	ldr	r2, [pc, #184]	; (8027464 <keyboard_init+0x244>)
 80273ac:	fb82 1203 	smull	r1, r2, r2, r3
 80273b0:	1192      	asrs	r2, r2, #6
 80273b2:	17db      	asrs	r3, r3, #31
 80273b4:	1ad3      	subs	r3, r2, r3
 80273b6:	b21b      	sxth	r3, r3
 80273b8:	e000      	b.n	80273bc <keyboard_init+0x19c>
 80273ba:	2301      	movs	r3, #1
 80273bc:	461a      	mov	r2, r3
 80273be:	2100      	movs	r1, #0
 80273c0:	4620      	mov	r0, r4
 80273c2:	f7fb ff36 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->kb_bg, LV_STATE_DEFAULT, LV_DPX(5));
 80273c6:	4b26      	ldr	r3, [pc, #152]	; (8027460 <keyboard_init+0x240>)
 80273c8:	681b      	ldr	r3, [r3, #0]
 80273ca:	f103 046c 	add.w	r4, r3, #108	; 0x6c
 80273ce:	2000      	movs	r0, #0
 80273d0:	f7f7 fba0 	bl	801eb14 <lv_disp_get_dpi>
 80273d4:	4603      	mov	r3, r0
 80273d6:	461a      	mov	r2, r3
 80273d8:	4613      	mov	r3, r2
 80273da:	009b      	lsls	r3, r3, #2
 80273dc:	4413      	add	r3, r2
 80273de:	2bef      	cmp	r3, #239	; 0xef
 80273e0:	dd10      	ble.n	8027404 <keyboard_init+0x1e4>
 80273e2:	2000      	movs	r0, #0
 80273e4:	f7f7 fb96 	bl	801eb14 <lv_disp_get_dpi>
 80273e8:	4603      	mov	r3, r0
 80273ea:	461a      	mov	r2, r3
 80273ec:	4613      	mov	r3, r2
 80273ee:	009b      	lsls	r3, r3, #2
 80273f0:	4413      	add	r3, r2
 80273f2:	3350      	adds	r3, #80	; 0x50
 80273f4:	4a1b      	ldr	r2, [pc, #108]	; (8027464 <keyboard_init+0x244>)
 80273f6:	fb82 1203 	smull	r1, r2, r2, r3
 80273fa:	1192      	asrs	r2, r2, #6
 80273fc:	17db      	asrs	r3, r3, #31
 80273fe:	1ad3      	subs	r3, r2, r3
 8027400:	b21b      	sxth	r3, r3
 8027402:	e000      	b.n	8027406 <keyboard_init+0x1e6>
 8027404:	2301      	movs	r3, #1
 8027406:	461a      	mov	r2, r3
 8027408:	2100      	movs	r1, #0
 802740a:	4620      	mov	r0, r4
 802740c:	f7fb ff29 	bl	8023262 <lv_style_set_pad_bottom>
    lv_style_set_pad_inner(&styles->kb_bg, LV_STATE_DEFAULT, LV_DPX(3));
 8027410:	4b13      	ldr	r3, [pc, #76]	; (8027460 <keyboard_init+0x240>)
 8027412:	681b      	ldr	r3, [r3, #0]
 8027414:	f103 046c 	add.w	r4, r3, #108	; 0x6c
 8027418:	2000      	movs	r0, #0
 802741a:	f7f7 fb7b 	bl	801eb14 <lv_disp_get_dpi>
 802741e:	4603      	mov	r3, r0
 8027420:	461a      	mov	r2, r3
 8027422:	4613      	mov	r3, r2
 8027424:	005b      	lsls	r3, r3, #1
 8027426:	4413      	add	r3, r2
 8027428:	2bef      	cmp	r3, #239	; 0xef
 802742a:	dd10      	ble.n	802744e <keyboard_init+0x22e>
 802742c:	2000      	movs	r0, #0
 802742e:	f7f7 fb71 	bl	801eb14 <lv_disp_get_dpi>
 8027432:	4603      	mov	r3, r0
 8027434:	461a      	mov	r2, r3
 8027436:	4613      	mov	r3, r2
 8027438:	005b      	lsls	r3, r3, #1
 802743a:	4413      	add	r3, r2
 802743c:	3350      	adds	r3, #80	; 0x50
 802743e:	4a09      	ldr	r2, [pc, #36]	; (8027464 <keyboard_init+0x244>)
 8027440:	fb82 1203 	smull	r1, r2, r2, r3
 8027444:	1192      	asrs	r2, r2, #6
 8027446:	17db      	asrs	r3, r3, #31
 8027448:	1ad3      	subs	r3, r2, r3
 802744a:	b21b      	sxth	r3, r3
 802744c:	e000      	b.n	8027450 <keyboard_init+0x230>
 802744e:	2301      	movs	r3, #1
 8027450:	461a      	mov	r2, r3
 8027452:	2100      	movs	r1, #0
 8027454:	4620      	mov	r0, r4
 8027456:	f7fb ff4c 	bl	80232f2 <lv_style_set_pad_inner>
#endif
}
 802745a:	bf00      	nop
 802745c:	bdb0      	pop	{r4, r5, r7, pc}
 802745e:	bf00      	nop
 8027460:	20012350 	.word	0x20012350
 8027464:	66666667 	.word	0x66666667
 8027468:	20012328 	.word	0x20012328
 802746c:	003b3e42 	.word	0x003b3e42

08027470 <msgbox_init>:

static void msgbox_init(void)
{
 8027470:	b598      	push	{r3, r4, r7, lr}
 8027472:	af00      	add	r7, sp, #0
#if LV_USE_MSGBOX
    style_init_reset(&styles->mbox_bg);
 8027474:	4b21      	ldr	r3, [pc, #132]	; (80274fc <msgbox_init+0x8c>)
 8027476:	681b      	ldr	r3, [r3, #0]
 8027478:	3380      	adds	r3, #128	; 0x80
 802747a:	4618      	mov	r0, r3
 802747c:	f002 f9c6 	bl	802980c <style_init_reset>
    lv_style_set_shadow_width(&styles->mbox_bg, LV_STATE_DEFAULT, LV_DPX(50));
 8027480:	4b1e      	ldr	r3, [pc, #120]	; (80274fc <msgbox_init+0x8c>)
 8027482:	681b      	ldr	r3, [r3, #0]
 8027484:	f103 0480 	add.w	r4, r3, #128	; 0x80
 8027488:	2000      	movs	r0, #0
 802748a:	f7f7 fb43 	bl	801eb14 <lv_disp_get_dpi>
 802748e:	4603      	mov	r3, r0
 8027490:	461a      	mov	r2, r3
 8027492:	2332      	movs	r3, #50	; 0x32
 8027494:	fb02 f303 	mul.w	r3, r2, r3
 8027498:	2bef      	cmp	r3, #239	; 0xef
 802749a:	dd10      	ble.n	80274be <msgbox_init+0x4e>
 802749c:	2000      	movs	r0, #0
 802749e:	f7f7 fb39 	bl	801eb14 <lv_disp_get_dpi>
 80274a2:	4603      	mov	r3, r0
 80274a4:	461a      	mov	r2, r3
 80274a6:	2332      	movs	r3, #50	; 0x32
 80274a8:	fb02 f303 	mul.w	r3, r2, r3
 80274ac:	3350      	adds	r3, #80	; 0x50
 80274ae:	4a14      	ldr	r2, [pc, #80]	; (8027500 <msgbox_init+0x90>)
 80274b0:	fb82 1203 	smull	r1, r2, r2, r3
 80274b4:	1192      	asrs	r2, r2, #6
 80274b6:	17db      	asrs	r3, r3, #31
 80274b8:	1ad3      	subs	r3, r2, r3
 80274ba:	b21b      	sxth	r3, r3
 80274bc:	e000      	b.n	80274c0 <msgbox_init+0x50>
 80274be:	2301      	movs	r3, #1
 80274c0:	461a      	mov	r2, r3
 80274c2:	2100      	movs	r1, #0
 80274c4:	4620      	mov	r0, r4
 80274c6:	f7fc f88b 	bl	80235e0 <lv_style_set_shadow_width>
    lv_style_set_shadow_color(&styles->mbox_bg, LV_STATE_DEFAULT, IS_LIGHT ? LV_COLOR_SILVER : lv_color_hex3(0x999));
 80274ca:	4b0c      	ldr	r3, [pc, #48]	; (80274fc <msgbox_init+0x8c>)
 80274cc:	681b      	ldr	r3, [r3, #0]
 80274ce:	f103 0480 	add.w	r4, r3, #128	; 0x80
 80274d2:	4b0c      	ldr	r3, [pc, #48]	; (8027504 <msgbox_init+0x94>)
 80274d4:	6a1b      	ldr	r3, [r3, #32]
 80274d6:	f003 0302 	and.w	r3, r3, #2
 80274da:	2b00      	cmp	r3, #0
 80274dc:	d002      	beq.n	80274e4 <msgbox_init+0x74>
 80274de:	4b0a      	ldr	r3, [pc, #40]	; (8027508 <msgbox_init+0x98>)
 80274e0:	881b      	ldrh	r3, [r3, #0]
 80274e2:	e004      	b.n	80274ee <msgbox_init+0x7e>
 80274e4:	f640 1099 	movw	r0, #2457	; 0x999
 80274e8:	f7fb fe11 	bl	802310e <lv_color_hex3>
 80274ec:	4603      	mov	r3, r0
 80274ee:	461a      	mov	r2, r3
 80274f0:	2100      	movs	r1, #0
 80274f2:	4620      	mov	r0, r4
 80274f4:	f7fc f8a4 	bl	8023640 <lv_style_set_shadow_color>

#endif
}
 80274f8:	bf00      	nop
 80274fa:	bd98      	pop	{r3, r4, r7, pc}
 80274fc:	20012350 	.word	0x20012350
 8027500:	66666667 	.word	0x66666667
 8027504:	20012328 	.word	0x20012328
 8027508:	0802e5a0 	.word	0x0802e5a0

0802750c <page_init>:

static void page_init(void)
{
 802750c:	b598      	push	{r3, r4, r7, lr}
 802750e:	af00      	add	r7, sp, #0
#if LV_USE_PAGE
    style_init_reset(&styles->sb);
 8027510:	4b5d      	ldr	r3, [pc, #372]	; (8027688 <page_init+0x17c>)
 8027512:	681b      	ldr	r3, [r3, #0]
 8027514:	3384      	adds	r3, #132	; 0x84
 8027516:	4618      	mov	r0, r3
 8027518:	f002 f978 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->sb, LV_STATE_DEFAULT, LV_OPA_COVER);
 802751c:	4b5a      	ldr	r3, [pc, #360]	; (8027688 <page_init+0x17c>)
 802751e:	681b      	ldr	r3, [r3, #0]
 8027520:	3384      	adds	r3, #132	; 0x84
 8027522:	22ff      	movs	r2, #255	; 0xff
 8027524:	2100      	movs	r1, #0
 8027526:	4618      	mov	r0, r3
 8027528:	f7fb ff71 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->sb, LV_STATE_DEFAULT, (IS_LIGHT ? lv_color_hex(0xcccfd1) : lv_color_hex(0x777f85)));
 802752c:	4b56      	ldr	r3, [pc, #344]	; (8027688 <page_init+0x17c>)
 802752e:	681b      	ldr	r3, [r3, #0]
 8027530:	f103 0484 	add.w	r4, r3, #132	; 0x84
 8027534:	4b55      	ldr	r3, [pc, #340]	; (802768c <page_init+0x180>)
 8027536:	6a1b      	ldr	r3, [r3, #32]
 8027538:	f003 0302 	and.w	r3, r3, #2
 802753c:	2b00      	cmp	r3, #0
 802753e:	d004      	beq.n	802754a <page_init+0x3e>
 8027540:	4853      	ldr	r0, [pc, #332]	; (8027690 <page_init+0x184>)
 8027542:	f7fb fdd0 	bl	80230e6 <lv_color_hex>
 8027546:	4603      	mov	r3, r0
 8027548:	e003      	b.n	8027552 <page_init+0x46>
 802754a:	4852      	ldr	r0, [pc, #328]	; (8027694 <page_init+0x188>)
 802754c:	f7fb fdcb 	bl	80230e6 <lv_color_hex>
 8027550:	4603      	mov	r3, r0
 8027552:	461a      	mov	r2, r3
 8027554:	2100      	movs	r1, #0
 8027556:	4620      	mov	r0, r4
 8027558:	f7fb ff43 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_radius(&styles->sb, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 802755c:	4b4a      	ldr	r3, [pc, #296]	; (8027688 <page_init+0x17c>)
 802755e:	681b      	ldr	r3, [r3, #0]
 8027560:	3384      	adds	r3, #132	; 0x84
 8027562:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8027566:	2100      	movs	r1, #0
 8027568:	4618      	mov	r0, r3
 802756a:	f7fb fe02 	bl	8023172 <lv_style_set_radius>
    lv_style_set_size(&styles->sb, LV_STATE_DEFAULT, LV_DPX(7));
 802756e:	4b46      	ldr	r3, [pc, #280]	; (8027688 <page_init+0x17c>)
 8027570:	681b      	ldr	r3, [r3, #0]
 8027572:	f103 0484 	add.w	r4, r3, #132	; 0x84
 8027576:	2000      	movs	r0, #0
 8027578:	f7f7 facc 	bl	801eb14 <lv_disp_get_dpi>
 802757c:	4603      	mov	r3, r0
 802757e:	461a      	mov	r2, r3
 8027580:	4613      	mov	r3, r2
 8027582:	00db      	lsls	r3, r3, #3
 8027584:	1a9b      	subs	r3, r3, r2
 8027586:	2bef      	cmp	r3, #239	; 0xef
 8027588:	dd10      	ble.n	80275ac <page_init+0xa0>
 802758a:	2000      	movs	r0, #0
 802758c:	f7f7 fac2 	bl	801eb14 <lv_disp_get_dpi>
 8027590:	4603      	mov	r3, r0
 8027592:	461a      	mov	r2, r3
 8027594:	4613      	mov	r3, r2
 8027596:	00db      	lsls	r3, r3, #3
 8027598:	1a9b      	subs	r3, r3, r2
 802759a:	3350      	adds	r3, #80	; 0x50
 802759c:	4a3e      	ldr	r2, [pc, #248]	; (8027698 <page_init+0x18c>)
 802759e:	fb82 1203 	smull	r1, r2, r2, r3
 80275a2:	1192      	asrs	r2, r2, #6
 80275a4:	17db      	asrs	r3, r3, #31
 80275a6:	1ad3      	subs	r3, r2, r3
 80275a8:	b21b      	sxth	r3, r3
 80275aa:	e000      	b.n	80275ae <page_init+0xa2>
 80275ac:	2301      	movs	r3, #1
 80275ae:	461a      	mov	r2, r3
 80275b0:	2100      	movs	r1, #0
 80275b2:	4620      	mov	r0, r4
 80275b4:	f7fb fe0d 	bl	80231d2 <lv_style_set_size>
    lv_style_set_pad_right(&styles->sb, LV_STATE_DEFAULT,  LV_DPX(7));
 80275b8:	4b33      	ldr	r3, [pc, #204]	; (8027688 <page_init+0x17c>)
 80275ba:	681b      	ldr	r3, [r3, #0]
 80275bc:	f103 0484 	add.w	r4, r3, #132	; 0x84
 80275c0:	2000      	movs	r0, #0
 80275c2:	f7f7 faa7 	bl	801eb14 <lv_disp_get_dpi>
 80275c6:	4603      	mov	r3, r0
 80275c8:	461a      	mov	r2, r3
 80275ca:	4613      	mov	r3, r2
 80275cc:	00db      	lsls	r3, r3, #3
 80275ce:	1a9b      	subs	r3, r3, r2
 80275d0:	2bef      	cmp	r3, #239	; 0xef
 80275d2:	dd10      	ble.n	80275f6 <page_init+0xea>
 80275d4:	2000      	movs	r0, #0
 80275d6:	f7f7 fa9d 	bl	801eb14 <lv_disp_get_dpi>
 80275da:	4603      	mov	r3, r0
 80275dc:	461a      	mov	r2, r3
 80275de:	4613      	mov	r3, r2
 80275e0:	00db      	lsls	r3, r3, #3
 80275e2:	1a9b      	subs	r3, r3, r2
 80275e4:	3350      	adds	r3, #80	; 0x50
 80275e6:	4a2c      	ldr	r2, [pc, #176]	; (8027698 <page_init+0x18c>)
 80275e8:	fb82 1203 	smull	r1, r2, r2, r3
 80275ec:	1192      	asrs	r2, r2, #6
 80275ee:	17db      	asrs	r3, r3, #31
 80275f0:	1ad3      	subs	r3, r2, r3
 80275f2:	b21b      	sxth	r3, r3
 80275f4:	e000      	b.n	80275f8 <page_init+0xec>
 80275f6:	2301      	movs	r3, #1
 80275f8:	461a      	mov	r2, r3
 80275fa:	2100      	movs	r1, #0
 80275fc:	4620      	mov	r0, r4
 80275fe:	f7fb fe60 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_bottom(&styles->sb, LV_STATE_DEFAULT,  LV_DPX(7));
 8027602:	4b21      	ldr	r3, [pc, #132]	; (8027688 <page_init+0x17c>)
 8027604:	681b      	ldr	r3, [r3, #0]
 8027606:	f103 0484 	add.w	r4, r3, #132	; 0x84
 802760a:	2000      	movs	r0, #0
 802760c:	f7f7 fa82 	bl	801eb14 <lv_disp_get_dpi>
 8027610:	4603      	mov	r3, r0
 8027612:	461a      	mov	r2, r3
 8027614:	4613      	mov	r3, r2
 8027616:	00db      	lsls	r3, r3, #3
 8027618:	1a9b      	subs	r3, r3, r2
 802761a:	2bef      	cmp	r3, #239	; 0xef
 802761c:	dd10      	ble.n	8027640 <page_init+0x134>
 802761e:	2000      	movs	r0, #0
 8027620:	f7f7 fa78 	bl	801eb14 <lv_disp_get_dpi>
 8027624:	4603      	mov	r3, r0
 8027626:	461a      	mov	r2, r3
 8027628:	4613      	mov	r3, r2
 802762a:	00db      	lsls	r3, r3, #3
 802762c:	1a9b      	subs	r3, r3, r2
 802762e:	3350      	adds	r3, #80	; 0x50
 8027630:	4a19      	ldr	r2, [pc, #100]	; (8027698 <page_init+0x18c>)
 8027632:	fb82 1203 	smull	r1, r2, r2, r3
 8027636:	1192      	asrs	r2, r2, #6
 8027638:	17db      	asrs	r3, r3, #31
 802763a:	1ad3      	subs	r3, r2, r3
 802763c:	b21b      	sxth	r3, r3
 802763e:	e000      	b.n	8027642 <page_init+0x136>
 8027640:	2301      	movs	r3, #1
 8027642:	461a      	mov	r2, r3
 8027644:	2100      	movs	r1, #0
 8027646:	4620      	mov	r0, r4
 8027648:	f7fb fe0b 	bl	8023262 <lv_style_set_pad_bottom>

#if  LV_USE_ANIMATION
    style_init_reset(&styles->edge_flash);
 802764c:	4b0e      	ldr	r3, [pc, #56]	; (8027688 <page_init+0x17c>)
 802764e:	681b      	ldr	r3, [r3, #0]
 8027650:	3388      	adds	r3, #136	; 0x88
 8027652:	4618      	mov	r0, r3
 8027654:	f002 f8da 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->edge_flash, LV_STATE_DEFAULT, LV_OPA_COVER);
 8027658:	4b0b      	ldr	r3, [pc, #44]	; (8027688 <page_init+0x17c>)
 802765a:	681b      	ldr	r3, [r3, #0]
 802765c:	3388      	adds	r3, #136	; 0x88
 802765e:	22ff      	movs	r2, #255	; 0xff
 8027660:	2100      	movs	r1, #0
 8027662:	4618      	mov	r0, r3
 8027664:	f7fb fed3 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->edge_flash, LV_STATE_DEFAULT,  lv_color_hex3(0x888));
 8027668:	4b07      	ldr	r3, [pc, #28]	; (8027688 <page_init+0x17c>)
 802766a:	681b      	ldr	r3, [r3, #0]
 802766c:	f103 0488 	add.w	r4, r3, #136	; 0x88
 8027670:	f640 0088 	movw	r0, #2184	; 0x888
 8027674:	f7fb fd4b 	bl	802310e <lv_color_hex3>
 8027678:	4603      	mov	r3, r0
 802767a:	461a      	mov	r2, r3
 802767c:	2100      	movs	r1, #0
 802767e:	4620      	mov	r0, r4
 8027680:	f7fb feaf 	bl	80233e2 <lv_style_set_bg_color>
#endif
#endif
}
 8027684:	bf00      	nop
 8027686:	bd98      	pop	{r3, r4, r7, pc}
 8027688:	20012350 	.word	0x20012350
 802768c:	20012328 	.word	0x20012328
 8027690:	00cccfd1 	.word	0x00cccfd1
 8027694:	00777f85 	.word	0x00777f85
 8027698:	66666667 	.word	0x66666667

0802769c <textarea_init>:

static void textarea_init(void)
{
 802769c:	b598      	push	{r3, r4, r7, lr}
 802769e:	af00      	add	r7, sp, #0
#if LV_USE_TEXTAREA
    style_init_reset(&styles->ta_cursor);
 80276a0:	4b46      	ldr	r3, [pc, #280]	; (80277bc <textarea_init+0x120>)
 80276a2:	681b      	ldr	r3, [r3, #0]
 80276a4:	33b8      	adds	r3, #184	; 0xb8
 80276a6:	4618      	mov	r0, r3
 80276a8:	f002 f8b0 	bl	802980c <style_init_reset>
    lv_style_set_border_color(&styles->ta_cursor, LV_STATE_DEFAULT, COLOR_BG_SEC_TEXT);
 80276ac:	4b43      	ldr	r3, [pc, #268]	; (80277bc <textarea_init+0x120>)
 80276ae:	681b      	ldr	r3, [r3, #0]
 80276b0:	f103 04b8 	add.w	r4, r3, #184	; 0xb8
 80276b4:	4b42      	ldr	r3, [pc, #264]	; (80277c0 <textarea_init+0x124>)
 80276b6:	6a1b      	ldr	r3, [r3, #32]
 80276b8:	f003 0302 	and.w	r3, r3, #2
 80276bc:	2b00      	cmp	r3, #0
 80276be:	d004      	beq.n	80276ca <textarea_init+0x2e>
 80276c0:	4840      	ldr	r0, [pc, #256]	; (80277c4 <textarea_init+0x128>)
 80276c2:	f7fb fd10 	bl	80230e6 <lv_color_hex>
 80276c6:	4603      	mov	r3, r0
 80276c8:	e003      	b.n	80276d2 <textarea_init+0x36>
 80276ca:	483f      	ldr	r0, [pc, #252]	; (80277c8 <textarea_init+0x12c>)
 80276cc:	f7fb fd0b 	bl	80230e6 <lv_color_hex>
 80276d0:	4603      	mov	r3, r0
 80276d2:	461a      	mov	r2, r3
 80276d4:	2100      	movs	r1, #0
 80276d6:	4620      	mov	r0, r4
 80276d8:	f7fb fef8 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_width(&styles->ta_cursor, LV_STATE_DEFAULT, LV_DPX(2));
 80276dc:	4b37      	ldr	r3, [pc, #220]	; (80277bc <textarea_init+0x120>)
 80276de:	681b      	ldr	r3, [r3, #0]
 80276e0:	f103 04b8 	add.w	r4, r3, #184	; 0xb8
 80276e4:	2000      	movs	r0, #0
 80276e6:	f7f7 fa15 	bl	801eb14 <lv_disp_get_dpi>
 80276ea:	4603      	mov	r3, r0
 80276ec:	2b77      	cmp	r3, #119	; 0x77
 80276ee:	dd0c      	ble.n	802770a <textarea_init+0x6e>
 80276f0:	2000      	movs	r0, #0
 80276f2:	f7f7 fa0f 	bl	801eb14 <lv_disp_get_dpi>
 80276f6:	4603      	mov	r3, r0
 80276f8:	3328      	adds	r3, #40	; 0x28
 80276fa:	4a34      	ldr	r2, [pc, #208]	; (80277cc <textarea_init+0x130>)
 80276fc:	fb82 1203 	smull	r1, r2, r2, r3
 8027700:	1152      	asrs	r2, r2, #5
 8027702:	17db      	asrs	r3, r3, #31
 8027704:	1ad3      	subs	r3, r2, r3
 8027706:	b21b      	sxth	r3, r3
 8027708:	e000      	b.n	802770c <textarea_init+0x70>
 802770a:	2301      	movs	r3, #1
 802770c:	461a      	mov	r2, r3
 802770e:	2100      	movs	r1, #0
 8027710:	4620      	mov	r0, r4
 8027712:	f7fb fe93 	bl	802343c <lv_style_set_border_width>
    lv_style_set_pad_left(&styles->ta_cursor, LV_STATE_DEFAULT, LV_DPX(1));
 8027716:	4b29      	ldr	r3, [pc, #164]	; (80277bc <textarea_init+0x120>)
 8027718:	681b      	ldr	r3, [r3, #0]
 802771a:	f103 04b8 	add.w	r4, r3, #184	; 0xb8
 802771e:	2000      	movs	r0, #0
 8027720:	f7f7 f9f8 	bl	801eb14 <lv_disp_get_dpi>
 8027724:	4603      	mov	r3, r0
 8027726:	2bef      	cmp	r3, #239	; 0xef
 8027728:	dd0c      	ble.n	8027744 <textarea_init+0xa8>
 802772a:	2000      	movs	r0, #0
 802772c:	f7f7 f9f2 	bl	801eb14 <lv_disp_get_dpi>
 8027730:	4603      	mov	r3, r0
 8027732:	3350      	adds	r3, #80	; 0x50
 8027734:	4a25      	ldr	r2, [pc, #148]	; (80277cc <textarea_init+0x130>)
 8027736:	fb82 1203 	smull	r1, r2, r2, r3
 802773a:	1192      	asrs	r2, r2, #6
 802773c:	17db      	asrs	r3, r3, #31
 802773e:	1ad3      	subs	r3, r2, r3
 8027740:	b21b      	sxth	r3, r3
 8027742:	e000      	b.n	8027746 <textarea_init+0xaa>
 8027744:	2301      	movs	r3, #1
 8027746:	461a      	mov	r2, r3
 8027748:	2100      	movs	r1, #0
 802774a:	4620      	mov	r0, r4
 802774c:	f7fb fda1 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_border_side(&styles->ta_cursor, LV_STATE_DEFAULT, LV_BORDER_SIDE_LEFT);
 8027750:	4b1a      	ldr	r3, [pc, #104]	; (80277bc <textarea_init+0x120>)
 8027752:	681b      	ldr	r3, [r3, #0]
 8027754:	33b8      	adds	r3, #184	; 0xb8
 8027756:	2204      	movs	r2, #4
 8027758:	2100      	movs	r1, #0
 802775a:	4618      	mov	r0, r3
 802775c:	f7fb fe86 	bl	802346c <lv_style_set_border_side>

    style_init_reset(&styles->ta_placeholder);
 8027760:	4b16      	ldr	r3, [pc, #88]	; (80277bc <textarea_init+0x120>)
 8027762:	681b      	ldr	r3, [r3, #0]
 8027764:	33bc      	adds	r3, #188	; 0xbc
 8027766:	4618      	mov	r0, r3
 8027768:	f002 f850 	bl	802980c <style_init_reset>
    lv_style_set_text_color(&styles->ta_placeholder, LV_STATE_DEFAULT,
 802776c:	4b13      	ldr	r3, [pc, #76]	; (80277bc <textarea_init+0x120>)
 802776e:	681b      	ldr	r3, [r3, #0]
 8027770:	f103 04bc 	add.w	r4, r3, #188	; 0xbc
                            IS_LIGHT ? COLOR_BG_TEXT_DIS : lv_color_hex(0xa1adbd));
 8027774:	4b12      	ldr	r3, [pc, #72]	; (80277c0 <textarea_init+0x124>)
 8027776:	6a1b      	ldr	r3, [r3, #32]
 8027778:	f003 0302 	and.w	r3, r3, #2
    lv_style_set_text_color(&styles->ta_placeholder, LV_STATE_DEFAULT,
 802777c:	2b00      	cmp	r3, #0
 802777e:	d011      	beq.n	80277a4 <textarea_init+0x108>
                            IS_LIGHT ? COLOR_BG_TEXT_DIS : lv_color_hex(0xa1adbd));
 8027780:	4b0f      	ldr	r3, [pc, #60]	; (80277c0 <textarea_init+0x124>)
 8027782:	6a1b      	ldr	r3, [r3, #32]
 8027784:	f003 0302 	and.w	r3, r3, #2
    lv_style_set_text_color(&styles->ta_placeholder, LV_STATE_DEFAULT,
 8027788:	2b00      	cmp	r3, #0
 802778a:	d005      	beq.n	8027798 <textarea_init+0xfc>
                            IS_LIGHT ? COLOR_BG_TEXT_DIS : lv_color_hex(0xa1adbd));
 802778c:	f640 20aa 	movw	r0, #2730	; 0xaaa
 8027790:	f7fb fcbd 	bl	802310e <lv_color_hex3>
 8027794:	4603      	mov	r3, r0
 8027796:	e009      	b.n	80277ac <textarea_init+0x110>
 8027798:	f640 1099 	movw	r0, #2457	; 0x999
 802779c:	f7fb fcb7 	bl	802310e <lv_color_hex3>
 80277a0:	4603      	mov	r3, r0
 80277a2:	e003      	b.n	80277ac <textarea_init+0x110>
 80277a4:	480a      	ldr	r0, [pc, #40]	; (80277d0 <textarea_init+0x134>)
 80277a6:	f7fb fc9e 	bl	80230e6 <lv_color_hex>
 80277aa:	4603      	mov	r3, r0
    lv_style_set_text_color(&styles->ta_placeholder, LV_STATE_DEFAULT,
 80277ac:	461a      	mov	r2, r3
 80277ae:	2100      	movs	r1, #0
 80277b0:	4620      	mov	r0, r4
 80277b2:	f7fb ffe5 	bl	8023780 <lv_style_set_text_color>
#endif
}
 80277b6:	bf00      	nop
 80277b8:	bd98      	pop	{r3, r4, r7, pc}
 80277ba:	bf00      	nop
 80277bc:	20012350 	.word	0x20012350
 80277c0:	20012328 	.word	0x20012328
 80277c4:	0031404f 	.word	0x0031404f
 80277c8:	00a5a8ad 	.word	0x00a5a8ad
 80277cc:	66666667 	.word	0x66666667
 80277d0:	00a1adbd 	.word	0x00a1adbd

080277d4 <spinbox_init>:

static void spinbox_init(void)
{
 80277d4:	b598      	push	{r3, r4, r7, lr}
 80277d6:	af00      	add	r7, sp, #0
#if LV_USE_SPINBOX

    style_init_reset(&styles->spinbox_cursor);
 80277d8:	4b35      	ldr	r3, [pc, #212]	; (80278b0 <spinbox_init+0xdc>)
 80277da:	681b      	ldr	r3, [r3, #0]
 80277dc:	339c      	adds	r3, #156	; 0x9c
 80277de:	4618      	mov	r0, r3
 80277e0:	f002 f814 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->spinbox_cursor, LV_STATE_DEFAULT, LV_OPA_COVER);
 80277e4:	4b32      	ldr	r3, [pc, #200]	; (80278b0 <spinbox_init+0xdc>)
 80277e6:	681b      	ldr	r3, [r3, #0]
 80277e8:	339c      	adds	r3, #156	; 0x9c
 80277ea:	22ff      	movs	r2, #255	; 0xff
 80277ec:	2100      	movs	r1, #0
 80277ee:	4618      	mov	r0, r3
 80277f0:	f7fb fe0d 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->spinbox_cursor, LV_STATE_DEFAULT, theme.color_primary);
 80277f4:	4b2e      	ldr	r3, [pc, #184]	; (80278b0 <spinbox_init+0xdc>)
 80277f6:	681b      	ldr	r3, [r3, #0]
 80277f8:	339c      	adds	r3, #156	; 0x9c
 80277fa:	4a2e      	ldr	r2, [pc, #184]	; (80278b4 <spinbox_init+0xe0>)
 80277fc:	8992      	ldrh	r2, [r2, #12]
 80277fe:	2100      	movs	r1, #0
 8027800:	4618      	mov	r0, r3
 8027802:	f7fb fdee 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_text_color(&styles->spinbox_cursor, LV_STATE_DEFAULT, LV_COLOR_WHITE);
 8027806:	4b2a      	ldr	r3, [pc, #168]	; (80278b0 <spinbox_init+0xdc>)
 8027808:	681b      	ldr	r3, [r3, #0]
 802780a:	339c      	adds	r3, #156	; 0x9c
 802780c:	4a2a      	ldr	r2, [pc, #168]	; (80278b8 <spinbox_init+0xe4>)
 802780e:	8812      	ldrh	r2, [r2, #0]
 8027810:	2100      	movs	r1, #0
 8027812:	4618      	mov	r0, r3
 8027814:	f7fb ffb4 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_pad_top(&styles->spinbox_cursor, LV_STATE_DEFAULT, LV_DPX(100));
 8027818:	4b25      	ldr	r3, [pc, #148]	; (80278b0 <spinbox_init+0xdc>)
 802781a:	681b      	ldr	r3, [r3, #0]
 802781c:	f103 049c 	add.w	r4, r3, #156	; 0x9c
 8027820:	2000      	movs	r0, #0
 8027822:	f7f7 f977 	bl	801eb14 <lv_disp_get_dpi>
 8027826:	4603      	mov	r3, r0
 8027828:	461a      	mov	r2, r3
 802782a:	2364      	movs	r3, #100	; 0x64
 802782c:	fb02 f303 	mul.w	r3, r2, r3
 8027830:	2bef      	cmp	r3, #239	; 0xef
 8027832:	dd10      	ble.n	8027856 <spinbox_init+0x82>
 8027834:	2000      	movs	r0, #0
 8027836:	f7f7 f96d 	bl	801eb14 <lv_disp_get_dpi>
 802783a:	4603      	mov	r3, r0
 802783c:	461a      	mov	r2, r3
 802783e:	2364      	movs	r3, #100	; 0x64
 8027840:	fb02 f303 	mul.w	r3, r2, r3
 8027844:	3350      	adds	r3, #80	; 0x50
 8027846:	4a1d      	ldr	r2, [pc, #116]	; (80278bc <spinbox_init+0xe8>)
 8027848:	fb82 1203 	smull	r1, r2, r2, r3
 802784c:	1192      	asrs	r2, r2, #6
 802784e:	17db      	asrs	r3, r3, #31
 8027850:	1ad3      	subs	r3, r2, r3
 8027852:	b21b      	sxth	r3, r3
 8027854:	e000      	b.n	8027858 <spinbox_init+0x84>
 8027856:	2301      	movs	r3, #1
 8027858:	461a      	mov	r2, r3
 802785a:	2100      	movs	r1, #0
 802785c:	4620      	mov	r0, r4
 802785e:	f7fb fce8 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->spinbox_cursor, LV_STATE_DEFAULT, LV_DPX(100));
 8027862:	4b13      	ldr	r3, [pc, #76]	; (80278b0 <spinbox_init+0xdc>)
 8027864:	681b      	ldr	r3, [r3, #0]
 8027866:	f103 049c 	add.w	r4, r3, #156	; 0x9c
 802786a:	2000      	movs	r0, #0
 802786c:	f7f7 f952 	bl	801eb14 <lv_disp_get_dpi>
 8027870:	4603      	mov	r3, r0
 8027872:	461a      	mov	r2, r3
 8027874:	2364      	movs	r3, #100	; 0x64
 8027876:	fb02 f303 	mul.w	r3, r2, r3
 802787a:	2bef      	cmp	r3, #239	; 0xef
 802787c:	dd10      	ble.n	80278a0 <spinbox_init+0xcc>
 802787e:	2000      	movs	r0, #0
 8027880:	f7f7 f948 	bl	801eb14 <lv_disp_get_dpi>
 8027884:	4603      	mov	r3, r0
 8027886:	461a      	mov	r2, r3
 8027888:	2364      	movs	r3, #100	; 0x64
 802788a:	fb02 f303 	mul.w	r3, r2, r3
 802788e:	3350      	adds	r3, #80	; 0x50
 8027890:	4a0a      	ldr	r2, [pc, #40]	; (80278bc <spinbox_init+0xe8>)
 8027892:	fb82 1203 	smull	r1, r2, r2, r3
 8027896:	1192      	asrs	r2, r2, #6
 8027898:	17db      	asrs	r3, r3, #31
 802789a:	1ad3      	subs	r3, r2, r3
 802789c:	b21b      	sxth	r3, r3
 802789e:	e000      	b.n	80278a2 <spinbox_init+0xce>
 80278a0:	2301      	movs	r3, #1
 80278a2:	461a      	mov	r2, r3
 80278a4:	2100      	movs	r1, #0
 80278a6:	4620      	mov	r0, r4
 80278a8:	f7fb fcdb 	bl	8023262 <lv_style_set_pad_bottom>

#endif
}
 80278ac:	bf00      	nop
 80278ae:	bd98      	pop	{r3, r4, r7, pc}
 80278b0:	20012350 	.word	0x20012350
 80278b4:	20012328 	.word	0x20012328
 80278b8:	0802e594 	.word	0x0802e594
 80278bc:	66666667 	.word	0x66666667

080278c0 <list_init>:

static void list_init(void)
{
 80278c0:	b598      	push	{r3, r4, r7, lr}
 80278c2:	af00      	add	r7, sp, #0
#if LV_USE_LIST != 0
    style_init_reset(&styles->list_bg);
 80278c4:	4bab      	ldr	r3, [pc, #684]	; (8027b74 <list_init+0x2b4>)
 80278c6:	681b      	ldr	r3, [r3, #0]
 80278c8:	3378      	adds	r3, #120	; 0x78
 80278ca:	4618      	mov	r0, r3
 80278cc:	f001 ff9e 	bl	802980c <style_init_reset>
    lv_style_set_clip_corner(&styles->list_bg, LV_STATE_DEFAULT, true);
 80278d0:	4ba8      	ldr	r3, [pc, #672]	; (8027b74 <list_init+0x2b4>)
 80278d2:	681b      	ldr	r3, [r3, #0]
 80278d4:	3378      	adds	r3, #120	; 0x78
 80278d6:	2201      	movs	r2, #1
 80278d8:	2100      	movs	r1, #0
 80278da:	4618      	mov	r0, r3
 80278dc:	f7fb fc61 	bl	80231a2 <lv_style_set_clip_corner>
    lv_style_set_pad_left(&styles->list_bg, LV_STATE_DEFAULT, 0);
 80278e0:	4ba4      	ldr	r3, [pc, #656]	; (8027b74 <list_init+0x2b4>)
 80278e2:	681b      	ldr	r3, [r3, #0]
 80278e4:	3378      	adds	r3, #120	; 0x78
 80278e6:	2200      	movs	r2, #0
 80278e8:	2100      	movs	r1, #0
 80278ea:	4618      	mov	r0, r3
 80278ec:	f7fb fcd1 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->list_bg, LV_STATE_DEFAULT, 0);
 80278f0:	4ba0      	ldr	r3, [pc, #640]	; (8027b74 <list_init+0x2b4>)
 80278f2:	681b      	ldr	r3, [r3, #0]
 80278f4:	3378      	adds	r3, #120	; 0x78
 80278f6:	2200      	movs	r2, #0
 80278f8:	2100      	movs	r1, #0
 80278fa:	4618      	mov	r0, r3
 80278fc:	f7fb fce1 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->list_bg, LV_STATE_DEFAULT, 0);
 8027900:	4b9c      	ldr	r3, [pc, #624]	; (8027b74 <list_init+0x2b4>)
 8027902:	681b      	ldr	r3, [r3, #0]
 8027904:	3378      	adds	r3, #120	; 0x78
 8027906:	2200      	movs	r2, #0
 8027908:	2100      	movs	r1, #0
 802790a:	4618      	mov	r0, r3
 802790c:	f7fb fc91 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->list_bg, LV_STATE_DEFAULT, 0);
 8027910:	4b98      	ldr	r3, [pc, #608]	; (8027b74 <list_init+0x2b4>)
 8027912:	681b      	ldr	r3, [r3, #0]
 8027914:	3378      	adds	r3, #120	; 0x78
 8027916:	2200      	movs	r2, #0
 8027918:	2100      	movs	r1, #0
 802791a:	4618      	mov	r0, r3
 802791c:	f7fb fca1 	bl	8023262 <lv_style_set_pad_bottom>
    lv_style_set_pad_inner(&styles->list_bg, LV_STATE_DEFAULT, 0);
 8027920:	4b94      	ldr	r3, [pc, #592]	; (8027b74 <list_init+0x2b4>)
 8027922:	681b      	ldr	r3, [r3, #0]
 8027924:	3378      	adds	r3, #120	; 0x78
 8027926:	2200      	movs	r2, #0
 8027928:	2100      	movs	r1, #0
 802792a:	4618      	mov	r0, r3
 802792c:	f7fb fce1 	bl	80232f2 <lv_style_set_pad_inner>

    style_init_reset(&styles->list_btn);
 8027930:	4b90      	ldr	r3, [pc, #576]	; (8027b74 <list_init+0x2b4>)
 8027932:	681b      	ldr	r3, [r3, #0]
 8027934:	337c      	adds	r3, #124	; 0x7c
 8027936:	4618      	mov	r0, r3
 8027938:	f001 ff68 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->list_btn, LV_STATE_DEFAULT, LV_OPA_COVER);
 802793c:	4b8d      	ldr	r3, [pc, #564]	; (8027b74 <list_init+0x2b4>)
 802793e:	681b      	ldr	r3, [r3, #0]
 8027940:	337c      	adds	r3, #124	; 0x7c
 8027942:	22ff      	movs	r2, #255	; 0xff
 8027944:	2100      	movs	r1, #0
 8027946:	4618      	mov	r0, r3
 8027948:	f7fb fd61 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->list_btn, LV_STATE_DEFAULT, COLOR_BG);
 802794c:	4b89      	ldr	r3, [pc, #548]	; (8027b74 <list_init+0x2b4>)
 802794e:	681b      	ldr	r3, [r3, #0]
 8027950:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027954:	4b88      	ldr	r3, [pc, #544]	; (8027b78 <list_init+0x2b8>)
 8027956:	6a1b      	ldr	r3, [r3, #32]
 8027958:	f003 0302 	and.w	r3, r3, #2
 802795c:	2b00      	cmp	r3, #0
 802795e:	d005      	beq.n	802796c <list_init+0xac>
 8027960:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8027964:	f7fb fbbf 	bl	80230e6 <lv_color_hex>
 8027968:	4603      	mov	r3, r0
 802796a:	e003      	b.n	8027974 <list_init+0xb4>
 802796c:	4883      	ldr	r0, [pc, #524]	; (8027b7c <list_init+0x2bc>)
 802796e:	f7fb fbba 	bl	80230e6 <lv_color_hex>
 8027972:	4603      	mov	r3, r0
 8027974:	461a      	mov	r2, r3
 8027976:	2100      	movs	r1, #0
 8027978:	4620      	mov	r0, r4
 802797a:	f7fb fd32 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->list_btn, LV_STATE_PRESSED, COLOR_BG_PR);
 802797e:	4b7d      	ldr	r3, [pc, #500]	; (8027b74 <list_init+0x2b4>)
 8027980:	681b      	ldr	r3, [r3, #0]
 8027982:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027986:	4b7c      	ldr	r3, [pc, #496]	; (8027b78 <list_init+0x2b8>)
 8027988:	6a1b      	ldr	r3, [r3, #32]
 802798a:	f003 0302 	and.w	r3, r3, #2
 802798e:	2b00      	cmp	r3, #0
 8027990:	d004      	beq.n	802799c <list_init+0xdc>
 8027992:	487b      	ldr	r0, [pc, #492]	; (8027b80 <list_init+0x2c0>)
 8027994:	f7fb fba7 	bl	80230e6 <lv_color_hex>
 8027998:	4603      	mov	r3, r0
 802799a:	e003      	b.n	80279a4 <list_init+0xe4>
 802799c:	4879      	ldr	r0, [pc, #484]	; (8027b84 <list_init+0x2c4>)
 802799e:	f7fb fba2 	bl	80230e6 <lv_color_hex>
 80279a2:	4603      	mov	r3, r0
 80279a4:	461a      	mov	r2, r3
 80279a6:	2110      	movs	r1, #16
 80279a8:	4620      	mov	r0, r4
 80279aa:	f7fb fd1a 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->list_btn, LV_STATE_DISABLED, COLOR_BG_DIS);
 80279ae:	4b71      	ldr	r3, [pc, #452]	; (8027b74 <list_init+0x2b4>)
 80279b0:	681b      	ldr	r3, [r3, #0]
 80279b2:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 80279b6:	4b70      	ldr	r3, [pc, #448]	; (8027b78 <list_init+0x2b8>)
 80279b8:	6a1b      	ldr	r3, [r3, #32]
 80279ba:	f003 0302 	and.w	r3, r3, #2
 80279be:	2b00      	cmp	r3, #0
 80279c0:	d005      	beq.n	80279ce <list_init+0x10e>
 80279c2:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80279c6:	f7fb fb8e 	bl	80230e6 <lv_color_hex>
 80279ca:	4603      	mov	r3, r0
 80279cc:	e003      	b.n	80279d6 <list_init+0x116>
 80279ce:	486b      	ldr	r0, [pc, #428]	; (8027b7c <list_init+0x2bc>)
 80279d0:	f7fb fb89 	bl	80230e6 <lv_color_hex>
 80279d4:	4603      	mov	r3, r0
 80279d6:	461a      	mov	r2, r3
 80279d8:	2120      	movs	r1, #32
 80279da:	4620      	mov	r0, r4
 80279dc:	f7fb fd01 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->list_btn, LV_STATE_CHECKED, COLOR_BG_CHK);
 80279e0:	4b64      	ldr	r3, [pc, #400]	; (8027b74 <list_init+0x2b4>)
 80279e2:	681b      	ldr	r3, [r3, #0]
 80279e4:	337c      	adds	r3, #124	; 0x7c
 80279e6:	4a64      	ldr	r2, [pc, #400]	; (8027b78 <list_init+0x2b8>)
 80279e8:	8992      	ldrh	r2, [r2, #12]
 80279ea:	2101      	movs	r1, #1
 80279ec:	4618      	mov	r0, r3
 80279ee:	f7fb fcf8 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->list_btn, LV_STATE_CHECKED | LV_STATE_PRESSED, COLOR_BG_PR_CHK);
 80279f2:	4b60      	ldr	r3, [pc, #384]	; (8027b74 <list_init+0x2b4>)
 80279f4:	681b      	ldr	r3, [r3, #0]
 80279f6:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 80279fa:	4b5f      	ldr	r3, [pc, #380]	; (8027b78 <list_init+0x2b8>)
 80279fc:	2133      	movs	r1, #51	; 0x33
 80279fe:	8998      	ldrh	r0, [r3, #12]
 8027a00:	f7f8 fb60 	bl	80200c4 <lv_color_darken>
 8027a04:	4603      	mov	r3, r0
 8027a06:	461a      	mov	r2, r3
 8027a08:	2111      	movs	r1, #17
 8027a0a:	4620      	mov	r0, r4
 8027a0c:	f7fb fce9 	bl	80233e2 <lv_style_set_bg_color>

    lv_style_set_text_color(&styles->list_btn, LV_STATE_DEFAULT, COLOR_BG_TEXT);
 8027a10:	4b58      	ldr	r3, [pc, #352]	; (8027b74 <list_init+0x2b4>)
 8027a12:	681b      	ldr	r3, [r3, #0]
 8027a14:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027a18:	4b57      	ldr	r3, [pc, #348]	; (8027b78 <list_init+0x2b8>)
 8027a1a:	6a1b      	ldr	r3, [r3, #32]
 8027a1c:	f003 0302 	and.w	r3, r3, #2
 8027a20:	2b00      	cmp	r3, #0
 8027a22:	d004      	beq.n	8027a2e <list_init+0x16e>
 8027a24:	4858      	ldr	r0, [pc, #352]	; (8027b88 <list_init+0x2c8>)
 8027a26:	f7fb fb5e 	bl	80230e6 <lv_color_hex>
 8027a2a:	4603      	mov	r3, r0
 8027a2c:	e004      	b.n	8027a38 <list_init+0x178>
 8027a2e:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8027a32:	f7fb fb58 	bl	80230e6 <lv_color_hex>
 8027a36:	4603      	mov	r3, r0
 8027a38:	461a      	mov	r2, r3
 8027a3a:	2100      	movs	r1, #0
 8027a3c:	4620      	mov	r0, r4
 8027a3e:	f7fb fe9f 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_color(&styles->list_btn, LV_STATE_CHECKED, COLOR_BG_TEXT_CHK);
 8027a42:	4b4c      	ldr	r3, [pc, #304]	; (8027b74 <list_init+0x2b4>)
 8027a44:	681b      	ldr	r3, [r3, #0]
 8027a46:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027a4a:	4b4b      	ldr	r3, [pc, #300]	; (8027b78 <list_init+0x2b8>)
 8027a4c:	6a1b      	ldr	r3, [r3, #32]
 8027a4e:	f003 0302 	and.w	r3, r3, #2
 8027a52:	2b00      	cmp	r3, #0
 8027a54:	d005      	beq.n	8027a62 <list_init+0x1a2>
 8027a56:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8027a5a:	f7fb fb44 	bl	80230e6 <lv_color_hex>
 8027a5e:	4603      	mov	r3, r0
 8027a60:	e004      	b.n	8027a6c <list_init+0x1ac>
 8027a62:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8027a66:	f7fb fb3e 	bl	80230e6 <lv_color_hex>
 8027a6a:	4603      	mov	r3, r0
 8027a6c:	461a      	mov	r2, r3
 8027a6e:	2101      	movs	r1, #1
 8027a70:	4620      	mov	r0, r4
 8027a72:	f7fb fe85 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_color(&styles->list_btn, LV_STATE_DISABLED, COLOR_BG_TEXT_DIS);
 8027a76:	4b3f      	ldr	r3, [pc, #252]	; (8027b74 <list_init+0x2b4>)
 8027a78:	681b      	ldr	r3, [r3, #0]
 8027a7a:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027a7e:	4b3e      	ldr	r3, [pc, #248]	; (8027b78 <list_init+0x2b8>)
 8027a80:	6a1b      	ldr	r3, [r3, #32]
 8027a82:	f003 0302 	and.w	r3, r3, #2
 8027a86:	2b00      	cmp	r3, #0
 8027a88:	d005      	beq.n	8027a96 <list_init+0x1d6>
 8027a8a:	f640 20aa 	movw	r0, #2730	; 0xaaa
 8027a8e:	f7fb fb3e 	bl	802310e <lv_color_hex3>
 8027a92:	4603      	mov	r3, r0
 8027a94:	e004      	b.n	8027aa0 <list_init+0x1e0>
 8027a96:	f640 1099 	movw	r0, #2457	; 0x999
 8027a9a:	f7fb fb38 	bl	802310e <lv_color_hex3>
 8027a9e:	4603      	mov	r3, r0
 8027aa0:	461a      	mov	r2, r3
 8027aa2:	2120      	movs	r1, #32
 8027aa4:	4620      	mov	r0, r4
 8027aa6:	f7fb fe6b 	bl	8023780 <lv_style_set_text_color>

    lv_style_set_image_recolor(&styles->list_btn, LV_STATE_DEFAULT, COLOR_BG_TEXT);
 8027aaa:	4b32      	ldr	r3, [pc, #200]	; (8027b74 <list_init+0x2b4>)
 8027aac:	681b      	ldr	r3, [r3, #0]
 8027aae:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027ab2:	4b31      	ldr	r3, [pc, #196]	; (8027b78 <list_init+0x2b8>)
 8027ab4:	6a1b      	ldr	r3, [r3, #32]
 8027ab6:	f003 0302 	and.w	r3, r3, #2
 8027aba:	2b00      	cmp	r3, #0
 8027abc:	d004      	beq.n	8027ac8 <list_init+0x208>
 8027abe:	4832      	ldr	r0, [pc, #200]	; (8027b88 <list_init+0x2c8>)
 8027ac0:	f7fb fb11 	bl	80230e6 <lv_color_hex>
 8027ac4:	4603      	mov	r3, r0
 8027ac6:	e004      	b.n	8027ad2 <list_init+0x212>
 8027ac8:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8027acc:	f7fb fb0b 	bl	80230e6 <lv_color_hex>
 8027ad0:	4603      	mov	r3, r0
 8027ad2:	461a      	mov	r2, r3
 8027ad4:	2100      	movs	r1, #0
 8027ad6:	4620      	mov	r0, r4
 8027ad8:	f7fb fef8 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_image_recolor(&styles->list_btn, LV_STATE_CHECKED, COLOR_BG_TEXT_CHK);
 8027adc:	4b25      	ldr	r3, [pc, #148]	; (8027b74 <list_init+0x2b4>)
 8027ade:	681b      	ldr	r3, [r3, #0]
 8027ae0:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027ae4:	4b24      	ldr	r3, [pc, #144]	; (8027b78 <list_init+0x2b8>)
 8027ae6:	6a1b      	ldr	r3, [r3, #32]
 8027ae8:	f003 0302 	and.w	r3, r3, #2
 8027aec:	2b00      	cmp	r3, #0
 8027aee:	d005      	beq.n	8027afc <list_init+0x23c>
 8027af0:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8027af4:	f7fb faf7 	bl	80230e6 <lv_color_hex>
 8027af8:	4603      	mov	r3, r0
 8027afa:	e004      	b.n	8027b06 <list_init+0x246>
 8027afc:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8027b00:	f7fb faf1 	bl	80230e6 <lv_color_hex>
 8027b04:	4603      	mov	r3, r0
 8027b06:	461a      	mov	r2, r3
 8027b08:	2101      	movs	r1, #1
 8027b0a:	4620      	mov	r0, r4
 8027b0c:	f7fb fede 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_image_recolor(&styles->list_btn, LV_STATE_DISABLED, COLOR_BG_TEXT_DIS);
 8027b10:	4b18      	ldr	r3, [pc, #96]	; (8027b74 <list_init+0x2b4>)
 8027b12:	681b      	ldr	r3, [r3, #0]
 8027b14:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027b18:	4b17      	ldr	r3, [pc, #92]	; (8027b78 <list_init+0x2b8>)
 8027b1a:	6a1b      	ldr	r3, [r3, #32]
 8027b1c:	f003 0302 	and.w	r3, r3, #2
 8027b20:	2b00      	cmp	r3, #0
 8027b22:	d005      	beq.n	8027b30 <list_init+0x270>
 8027b24:	f640 20aa 	movw	r0, #2730	; 0xaaa
 8027b28:	f7fb faf1 	bl	802310e <lv_color_hex3>
 8027b2c:	4603      	mov	r3, r0
 8027b2e:	e004      	b.n	8027b3a <list_init+0x27a>
 8027b30:	f640 1099 	movw	r0, #2457	; 0x999
 8027b34:	f7fb faeb 	bl	802310e <lv_color_hex3>
 8027b38:	4603      	mov	r3, r0
 8027b3a:	461a      	mov	r2, r3
 8027b3c:	2120      	movs	r1, #32
 8027b3e:	4620      	mov	r0, r4
 8027b40:	f7fb fec4 	bl	80238cc <lv_style_set_image_recolor>

    lv_style_set_border_side(&styles->list_btn, LV_STATE_DEFAULT, LV_BORDER_SIDE_BOTTOM);
 8027b44:	4b0b      	ldr	r3, [pc, #44]	; (8027b74 <list_init+0x2b4>)
 8027b46:	681b      	ldr	r3, [r3, #0]
 8027b48:	337c      	adds	r3, #124	; 0x7c
 8027b4a:	2201      	movs	r2, #1
 8027b4c:	2100      	movs	r1, #0
 8027b4e:	4618      	mov	r0, r3
 8027b50:	f7fb fc8c 	bl	802346c <lv_style_set_border_side>
    lv_style_set_border_color(&styles->list_btn, LV_STATE_DEFAULT, COLOR_BG_BORDER);
 8027b54:	4b07      	ldr	r3, [pc, #28]	; (8027b74 <list_init+0x2b4>)
 8027b56:	681b      	ldr	r3, [r3, #0]
 8027b58:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027b5c:	4b06      	ldr	r3, [pc, #24]	; (8027b78 <list_init+0x2b8>)
 8027b5e:	6a1b      	ldr	r3, [r3, #32]
 8027b60:	f003 0302 	and.w	r3, r3, #2
 8027b64:	2b00      	cmp	r3, #0
 8027b66:	d013      	beq.n	8027b90 <list_init+0x2d0>
 8027b68:	4808      	ldr	r0, [pc, #32]	; (8027b8c <list_init+0x2cc>)
 8027b6a:	f7fb fabc 	bl	80230e6 <lv_color_hex>
 8027b6e:	4603      	mov	r3, r0
 8027b70:	e012      	b.n	8027b98 <list_init+0x2d8>
 8027b72:	bf00      	nop
 8027b74:	20012350 	.word	0x20012350
 8027b78:	20012328 	.word	0x20012328
 8027b7c:	00586273 	.word	0x00586273
 8027b80:	00eeeeee 	.word	0x00eeeeee
 8027b84:	00494f57 	.word	0x00494f57
 8027b88:	003b3e42 	.word	0x003b3e42
 8027b8c:	00d6dde3 	.word	0x00d6dde3
 8027b90:	48c3      	ldr	r0, [pc, #780]	; (8027ea0 <list_init+0x5e0>)
 8027b92:	f7fb faa8 	bl	80230e6 <lv_color_hex>
 8027b96:	4603      	mov	r3, r0
 8027b98:	461a      	mov	r2, r3
 8027b9a:	2100      	movs	r1, #0
 8027b9c:	4620      	mov	r0, r4
 8027b9e:	f7fb fc95 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_color(&styles->list_btn, LV_STATE_FOCUSED, theme.color_primary);
 8027ba2:	4bc0      	ldr	r3, [pc, #768]	; (8027ea4 <list_init+0x5e4>)
 8027ba4:	681b      	ldr	r3, [r3, #0]
 8027ba6:	337c      	adds	r3, #124	; 0x7c
 8027ba8:	4abf      	ldr	r2, [pc, #764]	; (8027ea8 <list_init+0x5e8>)
 8027baa:	8992      	ldrh	r2, [r2, #12]
 8027bac:	2102      	movs	r1, #2
 8027bae:	4618      	mov	r0, r3
 8027bb0:	f7fb fc8c 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_width(&styles->list_btn, LV_STATE_DEFAULT, 1);
 8027bb4:	4bbb      	ldr	r3, [pc, #748]	; (8027ea4 <list_init+0x5e4>)
 8027bb6:	681b      	ldr	r3, [r3, #0]
 8027bb8:	337c      	adds	r3, #124	; 0x7c
 8027bba:	2201      	movs	r2, #1
 8027bbc:	2100      	movs	r1, #0
 8027bbe:	4618      	mov	r0, r3
 8027bc0:	f7fb fc3c 	bl	802343c <lv_style_set_border_width>

    lv_style_set_outline_color(&styles->list_btn, LV_STATE_FOCUSED, theme.color_secondary);
 8027bc4:	4bb7      	ldr	r3, [pc, #732]	; (8027ea4 <list_init+0x5e4>)
 8027bc6:	681b      	ldr	r3, [r3, #0]
 8027bc8:	337c      	adds	r3, #124	; 0x7c
 8027bca:	4ab7      	ldr	r2, [pc, #732]	; (8027ea8 <list_init+0x5e8>)
 8027bcc:	89d2      	ldrh	r2, [r2, #14]
 8027bce:	2102      	movs	r1, #2
 8027bd0:	4618      	mov	r0, r3
 8027bd2:	f7fb fcd8 	bl	8023586 <lv_style_set_outline_color>
    lv_style_set_outline_width(&styles->list_btn, LV_STATE_FOCUSED, OUTLINE_WIDTH);
 8027bd6:	4bb3      	ldr	r3, [pc, #716]	; (8027ea4 <list_init+0x5e4>)
 8027bd8:	681b      	ldr	r3, [r3, #0]
 8027bda:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027bde:	4bb2      	ldr	r3, [pc, #712]	; (8027ea8 <list_init+0x5e8>)
 8027be0:	6a1b      	ldr	r3, [r3, #32]
 8027be2:	f003 0320 	and.w	r3, r3, #32
 8027be6:	2b00      	cmp	r3, #0
 8027be8:	d114      	bne.n	8027c14 <list_init+0x354>
 8027bea:	2000      	movs	r0, #0
 8027bec:	f7f6 ff92 	bl	801eb14 <lv_disp_get_dpi>
 8027bf0:	4603      	mov	r3, r0
 8027bf2:	2b77      	cmp	r3, #119	; 0x77
 8027bf4:	dd0c      	ble.n	8027c10 <list_init+0x350>
 8027bf6:	2000      	movs	r0, #0
 8027bf8:	f7f6 ff8c 	bl	801eb14 <lv_disp_get_dpi>
 8027bfc:	4603      	mov	r3, r0
 8027bfe:	3328      	adds	r3, #40	; 0x28
 8027c00:	4aaa      	ldr	r2, [pc, #680]	; (8027eac <list_init+0x5ec>)
 8027c02:	fb82 1203 	smull	r1, r2, r2, r3
 8027c06:	1152      	asrs	r2, r2, #5
 8027c08:	17db      	asrs	r3, r3, #31
 8027c0a:	1ad3      	subs	r3, r2, r3
 8027c0c:	b21b      	sxth	r3, r3
 8027c0e:	e002      	b.n	8027c16 <list_init+0x356>
 8027c10:	2301      	movs	r3, #1
 8027c12:	e000      	b.n	8027c16 <list_init+0x356>
 8027c14:	2300      	movs	r3, #0
 8027c16:	461a      	mov	r2, r3
 8027c18:	2102      	movs	r1, #2
 8027c1a:	4620      	mov	r0, r4
 8027c1c:	f7fb fc83 	bl	8023526 <lv_style_set_outline_width>
    lv_style_set_outline_pad(&styles->list_btn, LV_STATE_FOCUSED, -BORDER_WIDTH);
 8027c20:	4ba0      	ldr	r3, [pc, #640]	; (8027ea4 <list_init+0x5e4>)
 8027c22:	681b      	ldr	r3, [r3, #0]
 8027c24:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027c28:	2000      	movs	r0, #0
 8027c2a:	f7f6 ff73 	bl	801eb14 <lv_disp_get_dpi>
 8027c2e:	4603      	mov	r3, r0
 8027c30:	2b77      	cmp	r3, #119	; 0x77
 8027c32:	dd0c      	ble.n	8027c4e <list_init+0x38e>
 8027c34:	2000      	movs	r0, #0
 8027c36:	f7f6 ff6d 	bl	801eb14 <lv_disp_get_dpi>
 8027c3a:	4603      	mov	r3, r0
 8027c3c:	3328      	adds	r3, #40	; 0x28
 8027c3e:	4a9b      	ldr	r2, [pc, #620]	; (8027eac <list_init+0x5ec>)
 8027c40:	fb82 1203 	smull	r1, r2, r2, r3
 8027c44:	1152      	asrs	r2, r2, #5
 8027c46:	17db      	asrs	r3, r3, #31
 8027c48:	1a9b      	subs	r3, r3, r2
 8027c4a:	b21b      	sxth	r3, r3
 8027c4c:	e001      	b.n	8027c52 <list_init+0x392>
 8027c4e:	f04f 33ff 	mov.w	r3, #4294967295
 8027c52:	461a      	mov	r2, r3
 8027c54:	2102      	movs	r1, #2
 8027c56:	4620      	mov	r0, r4
 8027c58:	f7fb fc7d 	bl	8023556 <lv_style_set_outline_pad>

    lv_style_set_pad_left(&styles->list_btn, LV_STATE_DEFAULT, PAD_DEF);
 8027c5c:	4b91      	ldr	r3, [pc, #580]	; (8027ea4 <list_init+0x5e4>)
 8027c5e:	681b      	ldr	r3, [r3, #0]
 8027c60:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027c64:	2000      	movs	r0, #0
 8027c66:	f7f6 ff6e 	bl	801eb46 <lv_disp_get_size_category>
 8027c6a:	4603      	mov	r3, r0
 8027c6c:	2b01      	cmp	r3, #1
 8027c6e:	d81c      	bhi.n	8027caa <list_init+0x3ea>
 8027c70:	2000      	movs	r0, #0
 8027c72:	f7f6 ff4f 	bl	801eb14 <lv_disp_get_dpi>
 8027c76:	4603      	mov	r3, r0
 8027c78:	461a      	mov	r2, r3
 8027c7a:	4613      	mov	r3, r2
 8027c7c:	011b      	lsls	r3, r3, #4
 8027c7e:	1a9b      	subs	r3, r3, r2
 8027c80:	2bef      	cmp	r3, #239	; 0xef
 8027c82:	dd10      	ble.n	8027ca6 <list_init+0x3e6>
 8027c84:	2000      	movs	r0, #0
 8027c86:	f7f6 ff45 	bl	801eb14 <lv_disp_get_dpi>
 8027c8a:	4603      	mov	r3, r0
 8027c8c:	461a      	mov	r2, r3
 8027c8e:	4613      	mov	r3, r2
 8027c90:	011b      	lsls	r3, r3, #4
 8027c92:	1a9b      	subs	r3, r3, r2
 8027c94:	3350      	adds	r3, #80	; 0x50
 8027c96:	4a85      	ldr	r2, [pc, #532]	; (8027eac <list_init+0x5ec>)
 8027c98:	fb82 1203 	smull	r1, r2, r2, r3
 8027c9c:	1192      	asrs	r2, r2, #6
 8027c9e:	17db      	asrs	r3, r3, #31
 8027ca0:	1ad3      	subs	r3, r2, r3
 8027ca2:	b21b      	sxth	r3, r3
 8027ca4:	e01f      	b.n	8027ce6 <list_init+0x426>
 8027ca6:	2301      	movs	r3, #1
 8027ca8:	e01d      	b.n	8027ce6 <list_init+0x426>
 8027caa:	2000      	movs	r0, #0
 8027cac:	f7f6 ff32 	bl	801eb14 <lv_disp_get_dpi>
 8027cb0:	4603      	mov	r3, r0
 8027cb2:	461a      	mov	r2, r3
 8027cb4:	4613      	mov	r3, r2
 8027cb6:	011b      	lsls	r3, r3, #4
 8027cb8:	1a9b      	subs	r3, r3, r2
 8027cba:	005b      	lsls	r3, r3, #1
 8027cbc:	2bef      	cmp	r3, #239	; 0xef
 8027cbe:	dd11      	ble.n	8027ce4 <list_init+0x424>
 8027cc0:	2000      	movs	r0, #0
 8027cc2:	f7f6 ff27 	bl	801eb14 <lv_disp_get_dpi>
 8027cc6:	4603      	mov	r3, r0
 8027cc8:	461a      	mov	r2, r3
 8027cca:	4613      	mov	r3, r2
 8027ccc:	011b      	lsls	r3, r3, #4
 8027cce:	1a9b      	subs	r3, r3, r2
 8027cd0:	005b      	lsls	r3, r3, #1
 8027cd2:	3350      	adds	r3, #80	; 0x50
 8027cd4:	4a75      	ldr	r2, [pc, #468]	; (8027eac <list_init+0x5ec>)
 8027cd6:	fb82 1203 	smull	r1, r2, r2, r3
 8027cda:	1192      	asrs	r2, r2, #6
 8027cdc:	17db      	asrs	r3, r3, #31
 8027cde:	1ad3      	subs	r3, r2, r3
 8027ce0:	b21b      	sxth	r3, r3
 8027ce2:	e000      	b.n	8027ce6 <list_init+0x426>
 8027ce4:	2301      	movs	r3, #1
 8027ce6:	461a      	mov	r2, r3
 8027ce8:	2100      	movs	r1, #0
 8027cea:	4620      	mov	r0, r4
 8027cec:	f7fb fad1 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->list_btn, LV_STATE_DEFAULT, PAD_DEF);
 8027cf0:	4b6c      	ldr	r3, [pc, #432]	; (8027ea4 <list_init+0x5e4>)
 8027cf2:	681b      	ldr	r3, [r3, #0]
 8027cf4:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027cf8:	2000      	movs	r0, #0
 8027cfa:	f7f6 ff24 	bl	801eb46 <lv_disp_get_size_category>
 8027cfe:	4603      	mov	r3, r0
 8027d00:	2b01      	cmp	r3, #1
 8027d02:	d81c      	bhi.n	8027d3e <list_init+0x47e>
 8027d04:	2000      	movs	r0, #0
 8027d06:	f7f6 ff05 	bl	801eb14 <lv_disp_get_dpi>
 8027d0a:	4603      	mov	r3, r0
 8027d0c:	461a      	mov	r2, r3
 8027d0e:	4613      	mov	r3, r2
 8027d10:	011b      	lsls	r3, r3, #4
 8027d12:	1a9b      	subs	r3, r3, r2
 8027d14:	2bef      	cmp	r3, #239	; 0xef
 8027d16:	dd10      	ble.n	8027d3a <list_init+0x47a>
 8027d18:	2000      	movs	r0, #0
 8027d1a:	f7f6 fefb 	bl	801eb14 <lv_disp_get_dpi>
 8027d1e:	4603      	mov	r3, r0
 8027d20:	461a      	mov	r2, r3
 8027d22:	4613      	mov	r3, r2
 8027d24:	011b      	lsls	r3, r3, #4
 8027d26:	1a9b      	subs	r3, r3, r2
 8027d28:	3350      	adds	r3, #80	; 0x50
 8027d2a:	4a60      	ldr	r2, [pc, #384]	; (8027eac <list_init+0x5ec>)
 8027d2c:	fb82 1203 	smull	r1, r2, r2, r3
 8027d30:	1192      	asrs	r2, r2, #6
 8027d32:	17db      	asrs	r3, r3, #31
 8027d34:	1ad3      	subs	r3, r2, r3
 8027d36:	b21b      	sxth	r3, r3
 8027d38:	e01f      	b.n	8027d7a <list_init+0x4ba>
 8027d3a:	2301      	movs	r3, #1
 8027d3c:	e01d      	b.n	8027d7a <list_init+0x4ba>
 8027d3e:	2000      	movs	r0, #0
 8027d40:	f7f6 fee8 	bl	801eb14 <lv_disp_get_dpi>
 8027d44:	4603      	mov	r3, r0
 8027d46:	461a      	mov	r2, r3
 8027d48:	4613      	mov	r3, r2
 8027d4a:	011b      	lsls	r3, r3, #4
 8027d4c:	1a9b      	subs	r3, r3, r2
 8027d4e:	005b      	lsls	r3, r3, #1
 8027d50:	2bef      	cmp	r3, #239	; 0xef
 8027d52:	dd11      	ble.n	8027d78 <list_init+0x4b8>
 8027d54:	2000      	movs	r0, #0
 8027d56:	f7f6 fedd 	bl	801eb14 <lv_disp_get_dpi>
 8027d5a:	4603      	mov	r3, r0
 8027d5c:	461a      	mov	r2, r3
 8027d5e:	4613      	mov	r3, r2
 8027d60:	011b      	lsls	r3, r3, #4
 8027d62:	1a9b      	subs	r3, r3, r2
 8027d64:	005b      	lsls	r3, r3, #1
 8027d66:	3350      	adds	r3, #80	; 0x50
 8027d68:	4a50      	ldr	r2, [pc, #320]	; (8027eac <list_init+0x5ec>)
 8027d6a:	fb82 1203 	smull	r1, r2, r2, r3
 8027d6e:	1192      	asrs	r2, r2, #6
 8027d70:	17db      	asrs	r3, r3, #31
 8027d72:	1ad3      	subs	r3, r2, r3
 8027d74:	b21b      	sxth	r3, r3
 8027d76:	e000      	b.n	8027d7a <list_init+0x4ba>
 8027d78:	2301      	movs	r3, #1
 8027d7a:	461a      	mov	r2, r3
 8027d7c:	2100      	movs	r1, #0
 8027d7e:	4620      	mov	r0, r4
 8027d80:	f7fb fa9f 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->list_btn, LV_STATE_DEFAULT, PAD_DEF);
 8027d84:	4b47      	ldr	r3, [pc, #284]	; (8027ea4 <list_init+0x5e4>)
 8027d86:	681b      	ldr	r3, [r3, #0]
 8027d88:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027d8c:	2000      	movs	r0, #0
 8027d8e:	f7f6 feda 	bl	801eb46 <lv_disp_get_size_category>
 8027d92:	4603      	mov	r3, r0
 8027d94:	2b01      	cmp	r3, #1
 8027d96:	d81c      	bhi.n	8027dd2 <list_init+0x512>
 8027d98:	2000      	movs	r0, #0
 8027d9a:	f7f6 febb 	bl	801eb14 <lv_disp_get_dpi>
 8027d9e:	4603      	mov	r3, r0
 8027da0:	461a      	mov	r2, r3
 8027da2:	4613      	mov	r3, r2
 8027da4:	011b      	lsls	r3, r3, #4
 8027da6:	1a9b      	subs	r3, r3, r2
 8027da8:	2bef      	cmp	r3, #239	; 0xef
 8027daa:	dd10      	ble.n	8027dce <list_init+0x50e>
 8027dac:	2000      	movs	r0, #0
 8027dae:	f7f6 feb1 	bl	801eb14 <lv_disp_get_dpi>
 8027db2:	4603      	mov	r3, r0
 8027db4:	461a      	mov	r2, r3
 8027db6:	4613      	mov	r3, r2
 8027db8:	011b      	lsls	r3, r3, #4
 8027dba:	1a9b      	subs	r3, r3, r2
 8027dbc:	3350      	adds	r3, #80	; 0x50
 8027dbe:	4a3b      	ldr	r2, [pc, #236]	; (8027eac <list_init+0x5ec>)
 8027dc0:	fb82 1203 	smull	r1, r2, r2, r3
 8027dc4:	1192      	asrs	r2, r2, #6
 8027dc6:	17db      	asrs	r3, r3, #31
 8027dc8:	1ad3      	subs	r3, r2, r3
 8027dca:	b21b      	sxth	r3, r3
 8027dcc:	e01f      	b.n	8027e0e <list_init+0x54e>
 8027dce:	2301      	movs	r3, #1
 8027dd0:	e01d      	b.n	8027e0e <list_init+0x54e>
 8027dd2:	2000      	movs	r0, #0
 8027dd4:	f7f6 fe9e 	bl	801eb14 <lv_disp_get_dpi>
 8027dd8:	4603      	mov	r3, r0
 8027dda:	461a      	mov	r2, r3
 8027ddc:	4613      	mov	r3, r2
 8027dde:	011b      	lsls	r3, r3, #4
 8027de0:	1a9b      	subs	r3, r3, r2
 8027de2:	005b      	lsls	r3, r3, #1
 8027de4:	2bef      	cmp	r3, #239	; 0xef
 8027de6:	dd11      	ble.n	8027e0c <list_init+0x54c>
 8027de8:	2000      	movs	r0, #0
 8027dea:	f7f6 fe93 	bl	801eb14 <lv_disp_get_dpi>
 8027dee:	4603      	mov	r3, r0
 8027df0:	461a      	mov	r2, r3
 8027df2:	4613      	mov	r3, r2
 8027df4:	011b      	lsls	r3, r3, #4
 8027df6:	1a9b      	subs	r3, r3, r2
 8027df8:	005b      	lsls	r3, r3, #1
 8027dfa:	3350      	adds	r3, #80	; 0x50
 8027dfc:	4a2b      	ldr	r2, [pc, #172]	; (8027eac <list_init+0x5ec>)
 8027dfe:	fb82 1203 	smull	r1, r2, r2, r3
 8027e02:	1192      	asrs	r2, r2, #6
 8027e04:	17db      	asrs	r3, r3, #31
 8027e06:	1ad3      	subs	r3, r2, r3
 8027e08:	b21b      	sxth	r3, r3
 8027e0a:	e000      	b.n	8027e0e <list_init+0x54e>
 8027e0c:	2301      	movs	r3, #1
 8027e0e:	461a      	mov	r2, r3
 8027e10:	2100      	movs	r1, #0
 8027e12:	4620      	mov	r0, r4
 8027e14:	f7fb fa0d 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->list_btn, LV_STATE_DEFAULT, PAD_DEF);
 8027e18:	4b22      	ldr	r3, [pc, #136]	; (8027ea4 <list_init+0x5e4>)
 8027e1a:	681b      	ldr	r3, [r3, #0]
 8027e1c:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027e20:	2000      	movs	r0, #0
 8027e22:	f7f6 fe90 	bl	801eb46 <lv_disp_get_size_category>
 8027e26:	4603      	mov	r3, r0
 8027e28:	2b01      	cmp	r3, #1
 8027e2a:	d81c      	bhi.n	8027e66 <list_init+0x5a6>
 8027e2c:	2000      	movs	r0, #0
 8027e2e:	f7f6 fe71 	bl	801eb14 <lv_disp_get_dpi>
 8027e32:	4603      	mov	r3, r0
 8027e34:	461a      	mov	r2, r3
 8027e36:	4613      	mov	r3, r2
 8027e38:	011b      	lsls	r3, r3, #4
 8027e3a:	1a9b      	subs	r3, r3, r2
 8027e3c:	2bef      	cmp	r3, #239	; 0xef
 8027e3e:	dd10      	ble.n	8027e62 <list_init+0x5a2>
 8027e40:	2000      	movs	r0, #0
 8027e42:	f7f6 fe67 	bl	801eb14 <lv_disp_get_dpi>
 8027e46:	4603      	mov	r3, r0
 8027e48:	461a      	mov	r2, r3
 8027e4a:	4613      	mov	r3, r2
 8027e4c:	011b      	lsls	r3, r3, #4
 8027e4e:	1a9b      	subs	r3, r3, r2
 8027e50:	3350      	adds	r3, #80	; 0x50
 8027e52:	4a16      	ldr	r2, [pc, #88]	; (8027eac <list_init+0x5ec>)
 8027e54:	fb82 1203 	smull	r1, r2, r2, r3
 8027e58:	1192      	asrs	r2, r2, #6
 8027e5a:	17db      	asrs	r3, r3, #31
 8027e5c:	1ad3      	subs	r3, r2, r3
 8027e5e:	b21b      	sxth	r3, r3
 8027e60:	e027      	b.n	8027eb2 <list_init+0x5f2>
 8027e62:	2301      	movs	r3, #1
 8027e64:	e025      	b.n	8027eb2 <list_init+0x5f2>
 8027e66:	2000      	movs	r0, #0
 8027e68:	f7f6 fe54 	bl	801eb14 <lv_disp_get_dpi>
 8027e6c:	4603      	mov	r3, r0
 8027e6e:	461a      	mov	r2, r3
 8027e70:	4613      	mov	r3, r2
 8027e72:	011b      	lsls	r3, r3, #4
 8027e74:	1a9b      	subs	r3, r3, r2
 8027e76:	005b      	lsls	r3, r3, #1
 8027e78:	2bef      	cmp	r3, #239	; 0xef
 8027e7a:	dd19      	ble.n	8027eb0 <list_init+0x5f0>
 8027e7c:	2000      	movs	r0, #0
 8027e7e:	f7f6 fe49 	bl	801eb14 <lv_disp_get_dpi>
 8027e82:	4603      	mov	r3, r0
 8027e84:	461a      	mov	r2, r3
 8027e86:	4613      	mov	r3, r2
 8027e88:	011b      	lsls	r3, r3, #4
 8027e8a:	1a9b      	subs	r3, r3, r2
 8027e8c:	005b      	lsls	r3, r3, #1
 8027e8e:	3350      	adds	r3, #80	; 0x50
 8027e90:	4a06      	ldr	r2, [pc, #24]	; (8027eac <list_init+0x5ec>)
 8027e92:	fb82 1203 	smull	r1, r2, r2, r3
 8027e96:	1192      	asrs	r2, r2, #6
 8027e98:	17db      	asrs	r3, r3, #31
 8027e9a:	1ad3      	subs	r3, r2, r3
 8027e9c:	b21b      	sxth	r3, r3
 8027e9e:	e008      	b.n	8027eb2 <list_init+0x5f2>
 8027ea0:	00808a97 	.word	0x00808a97
 8027ea4:	20012350 	.word	0x20012350
 8027ea8:	20012328 	.word	0x20012328
 8027eac:	66666667 	.word	0x66666667
 8027eb0:	2301      	movs	r3, #1
 8027eb2:	461a      	mov	r2, r3
 8027eb4:	2100      	movs	r1, #0
 8027eb6:	4620      	mov	r0, r4
 8027eb8:	f7fb f9d3 	bl	8023262 <lv_style_set_pad_bottom>
    lv_style_set_pad_inner(&styles->list_btn, LV_STATE_DEFAULT, PAD_DEF);
 8027ebc:	4b98      	ldr	r3, [pc, #608]	; (8028120 <list_init+0x860>)
 8027ebe:	681b      	ldr	r3, [r3, #0]
 8027ec0:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027ec4:	2000      	movs	r0, #0
 8027ec6:	f7f6 fe3e 	bl	801eb46 <lv_disp_get_size_category>
 8027eca:	4603      	mov	r3, r0
 8027ecc:	2b01      	cmp	r3, #1
 8027ece:	d81c      	bhi.n	8027f0a <list_init+0x64a>
 8027ed0:	2000      	movs	r0, #0
 8027ed2:	f7f6 fe1f 	bl	801eb14 <lv_disp_get_dpi>
 8027ed6:	4603      	mov	r3, r0
 8027ed8:	461a      	mov	r2, r3
 8027eda:	4613      	mov	r3, r2
 8027edc:	011b      	lsls	r3, r3, #4
 8027ede:	1a9b      	subs	r3, r3, r2
 8027ee0:	2bef      	cmp	r3, #239	; 0xef
 8027ee2:	dd10      	ble.n	8027f06 <list_init+0x646>
 8027ee4:	2000      	movs	r0, #0
 8027ee6:	f7f6 fe15 	bl	801eb14 <lv_disp_get_dpi>
 8027eea:	4603      	mov	r3, r0
 8027eec:	461a      	mov	r2, r3
 8027eee:	4613      	mov	r3, r2
 8027ef0:	011b      	lsls	r3, r3, #4
 8027ef2:	1a9b      	subs	r3, r3, r2
 8027ef4:	3350      	adds	r3, #80	; 0x50
 8027ef6:	4a8b      	ldr	r2, [pc, #556]	; (8028124 <list_init+0x864>)
 8027ef8:	fb82 1203 	smull	r1, r2, r2, r3
 8027efc:	1192      	asrs	r2, r2, #6
 8027efe:	17db      	asrs	r3, r3, #31
 8027f00:	1ad3      	subs	r3, r2, r3
 8027f02:	b21b      	sxth	r3, r3
 8027f04:	e01f      	b.n	8027f46 <list_init+0x686>
 8027f06:	2301      	movs	r3, #1
 8027f08:	e01d      	b.n	8027f46 <list_init+0x686>
 8027f0a:	2000      	movs	r0, #0
 8027f0c:	f7f6 fe02 	bl	801eb14 <lv_disp_get_dpi>
 8027f10:	4603      	mov	r3, r0
 8027f12:	461a      	mov	r2, r3
 8027f14:	4613      	mov	r3, r2
 8027f16:	011b      	lsls	r3, r3, #4
 8027f18:	1a9b      	subs	r3, r3, r2
 8027f1a:	005b      	lsls	r3, r3, #1
 8027f1c:	2bef      	cmp	r3, #239	; 0xef
 8027f1e:	dd11      	ble.n	8027f44 <list_init+0x684>
 8027f20:	2000      	movs	r0, #0
 8027f22:	f7f6 fdf7 	bl	801eb14 <lv_disp_get_dpi>
 8027f26:	4603      	mov	r3, r0
 8027f28:	461a      	mov	r2, r3
 8027f2a:	4613      	mov	r3, r2
 8027f2c:	011b      	lsls	r3, r3, #4
 8027f2e:	1a9b      	subs	r3, r3, r2
 8027f30:	005b      	lsls	r3, r3, #1
 8027f32:	3350      	adds	r3, #80	; 0x50
 8027f34:	4a7b      	ldr	r2, [pc, #492]	; (8028124 <list_init+0x864>)
 8027f36:	fb82 1203 	smull	r1, r2, r2, r3
 8027f3a:	1192      	asrs	r2, r2, #6
 8027f3c:	17db      	asrs	r3, r3, #31
 8027f3e:	1ad3      	subs	r3, r2, r3
 8027f40:	b21b      	sxth	r3, r3
 8027f42:	e000      	b.n	8027f46 <list_init+0x686>
 8027f44:	2301      	movs	r3, #1
 8027f46:	461a      	mov	r2, r3
 8027f48:	2100      	movs	r1, #0
 8027f4a:	4620      	mov	r0, r4
 8027f4c:	f7fb f9d1 	bl	80232f2 <lv_style_set_pad_inner>

    lv_style_set_transform_width(&styles->list_btn, LV_STATE_DEFAULT, - PAD_DEF);
 8027f50:	4b73      	ldr	r3, [pc, #460]	; (8028120 <list_init+0x860>)
 8027f52:	681b      	ldr	r3, [r3, #0]
 8027f54:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027f58:	2000      	movs	r0, #0
 8027f5a:	f7f6 fdf4 	bl	801eb46 <lv_disp_get_size_category>
 8027f5e:	4603      	mov	r3, r0
 8027f60:	2b01      	cmp	r3, #1
 8027f62:	d81d      	bhi.n	8027fa0 <list_init+0x6e0>
 8027f64:	2000      	movs	r0, #0
 8027f66:	f7f6 fdd5 	bl	801eb14 <lv_disp_get_dpi>
 8027f6a:	4603      	mov	r3, r0
 8027f6c:	461a      	mov	r2, r3
 8027f6e:	4613      	mov	r3, r2
 8027f70:	011b      	lsls	r3, r3, #4
 8027f72:	1a9b      	subs	r3, r3, r2
 8027f74:	2bef      	cmp	r3, #239	; 0xef
 8027f76:	dd10      	ble.n	8027f9a <list_init+0x6da>
 8027f78:	2000      	movs	r0, #0
 8027f7a:	f7f6 fdcb 	bl	801eb14 <lv_disp_get_dpi>
 8027f7e:	4603      	mov	r3, r0
 8027f80:	461a      	mov	r2, r3
 8027f82:	4613      	mov	r3, r2
 8027f84:	011b      	lsls	r3, r3, #4
 8027f86:	1a9b      	subs	r3, r3, r2
 8027f88:	3350      	adds	r3, #80	; 0x50
 8027f8a:	4a66      	ldr	r2, [pc, #408]	; (8028124 <list_init+0x864>)
 8027f8c:	fb82 1203 	smull	r1, r2, r2, r3
 8027f90:	1192      	asrs	r2, r2, #6
 8027f92:	17db      	asrs	r3, r3, #31
 8027f94:	1a9b      	subs	r3, r3, r2
 8027f96:	b21b      	sxth	r3, r3
 8027f98:	e021      	b.n	8027fde <list_init+0x71e>
 8027f9a:	f04f 33ff 	mov.w	r3, #4294967295
 8027f9e:	e01e      	b.n	8027fde <list_init+0x71e>
 8027fa0:	2000      	movs	r0, #0
 8027fa2:	f7f6 fdb7 	bl	801eb14 <lv_disp_get_dpi>
 8027fa6:	4603      	mov	r3, r0
 8027fa8:	461a      	mov	r2, r3
 8027faa:	4613      	mov	r3, r2
 8027fac:	011b      	lsls	r3, r3, #4
 8027fae:	1a9b      	subs	r3, r3, r2
 8027fb0:	005b      	lsls	r3, r3, #1
 8027fb2:	2bef      	cmp	r3, #239	; 0xef
 8027fb4:	dd11      	ble.n	8027fda <list_init+0x71a>
 8027fb6:	2000      	movs	r0, #0
 8027fb8:	f7f6 fdac 	bl	801eb14 <lv_disp_get_dpi>
 8027fbc:	4603      	mov	r3, r0
 8027fbe:	461a      	mov	r2, r3
 8027fc0:	4613      	mov	r3, r2
 8027fc2:	011b      	lsls	r3, r3, #4
 8027fc4:	1a9b      	subs	r3, r3, r2
 8027fc6:	005b      	lsls	r3, r3, #1
 8027fc8:	3350      	adds	r3, #80	; 0x50
 8027fca:	4a56      	ldr	r2, [pc, #344]	; (8028124 <list_init+0x864>)
 8027fcc:	fb82 1203 	smull	r1, r2, r2, r3
 8027fd0:	1192      	asrs	r2, r2, #6
 8027fd2:	17db      	asrs	r3, r3, #31
 8027fd4:	1a9b      	subs	r3, r3, r2
 8027fd6:	b21b      	sxth	r3, r3
 8027fd8:	e001      	b.n	8027fde <list_init+0x71e>
 8027fda:	f04f 33ff 	mov.w	r3, #4294967295
 8027fde:	461a      	mov	r2, r3
 8027fe0:	2100      	movs	r1, #0
 8027fe2:	4620      	mov	r0, r4
 8027fe4:	f7fb f90d 	bl	8023202 <lv_style_set_transform_width>
    lv_style_set_transform_width(&styles->list_btn, LV_STATE_PRESSED, -BORDER_WIDTH);
 8027fe8:	4b4d      	ldr	r3, [pc, #308]	; (8028120 <list_init+0x860>)
 8027fea:	681b      	ldr	r3, [r3, #0]
 8027fec:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8027ff0:	2000      	movs	r0, #0
 8027ff2:	f7f6 fd8f 	bl	801eb14 <lv_disp_get_dpi>
 8027ff6:	4603      	mov	r3, r0
 8027ff8:	2b77      	cmp	r3, #119	; 0x77
 8027ffa:	dd0c      	ble.n	8028016 <list_init+0x756>
 8027ffc:	2000      	movs	r0, #0
 8027ffe:	f7f6 fd89 	bl	801eb14 <lv_disp_get_dpi>
 8028002:	4603      	mov	r3, r0
 8028004:	3328      	adds	r3, #40	; 0x28
 8028006:	4a47      	ldr	r2, [pc, #284]	; (8028124 <list_init+0x864>)
 8028008:	fb82 1203 	smull	r1, r2, r2, r3
 802800c:	1152      	asrs	r2, r2, #5
 802800e:	17db      	asrs	r3, r3, #31
 8028010:	1a9b      	subs	r3, r3, r2
 8028012:	b21b      	sxth	r3, r3
 8028014:	e001      	b.n	802801a <list_init+0x75a>
 8028016:	f04f 33ff 	mov.w	r3, #4294967295
 802801a:	461a      	mov	r2, r3
 802801c:	2110      	movs	r1, #16
 802801e:	4620      	mov	r0, r4
 8028020:	f7fb f8ef 	bl	8023202 <lv_style_set_transform_width>
    lv_style_set_transform_width(&styles->list_btn, LV_STATE_CHECKED, -BORDER_WIDTH);
 8028024:	4b3e      	ldr	r3, [pc, #248]	; (8028120 <list_init+0x860>)
 8028026:	681b      	ldr	r3, [r3, #0]
 8028028:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 802802c:	2000      	movs	r0, #0
 802802e:	f7f6 fd71 	bl	801eb14 <lv_disp_get_dpi>
 8028032:	4603      	mov	r3, r0
 8028034:	2b77      	cmp	r3, #119	; 0x77
 8028036:	dd0c      	ble.n	8028052 <list_init+0x792>
 8028038:	2000      	movs	r0, #0
 802803a:	f7f6 fd6b 	bl	801eb14 <lv_disp_get_dpi>
 802803e:	4603      	mov	r3, r0
 8028040:	3328      	adds	r3, #40	; 0x28
 8028042:	4a38      	ldr	r2, [pc, #224]	; (8028124 <list_init+0x864>)
 8028044:	fb82 1203 	smull	r1, r2, r2, r3
 8028048:	1152      	asrs	r2, r2, #5
 802804a:	17db      	asrs	r3, r3, #31
 802804c:	1a9b      	subs	r3, r3, r2
 802804e:	b21b      	sxth	r3, r3
 8028050:	e001      	b.n	8028056 <list_init+0x796>
 8028052:	f04f 33ff 	mov.w	r3, #4294967295
 8028056:	461a      	mov	r2, r3
 8028058:	2101      	movs	r1, #1
 802805a:	4620      	mov	r0, r4
 802805c:	f7fb f8d1 	bl	8023202 <lv_style_set_transform_width>
    lv_style_set_transform_width(&styles->list_btn, LV_STATE_DISABLED, -BORDER_WIDTH);
 8028060:	4b2f      	ldr	r3, [pc, #188]	; (8028120 <list_init+0x860>)
 8028062:	681b      	ldr	r3, [r3, #0]
 8028064:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 8028068:	2000      	movs	r0, #0
 802806a:	f7f6 fd53 	bl	801eb14 <lv_disp_get_dpi>
 802806e:	4603      	mov	r3, r0
 8028070:	2b77      	cmp	r3, #119	; 0x77
 8028072:	dd0c      	ble.n	802808e <list_init+0x7ce>
 8028074:	2000      	movs	r0, #0
 8028076:	f7f6 fd4d 	bl	801eb14 <lv_disp_get_dpi>
 802807a:	4603      	mov	r3, r0
 802807c:	3328      	adds	r3, #40	; 0x28
 802807e:	4a29      	ldr	r2, [pc, #164]	; (8028124 <list_init+0x864>)
 8028080:	fb82 1203 	smull	r1, r2, r2, r3
 8028084:	1152      	asrs	r2, r2, #5
 8028086:	17db      	asrs	r3, r3, #31
 8028088:	1a9b      	subs	r3, r3, r2
 802808a:	b21b      	sxth	r3, r3
 802808c:	e001      	b.n	8028092 <list_init+0x7d2>
 802808e:	f04f 33ff 	mov.w	r3, #4294967295
 8028092:	461a      	mov	r2, r3
 8028094:	2120      	movs	r1, #32
 8028096:	4620      	mov	r0, r4
 8028098:	f7fb f8b3 	bl	8023202 <lv_style_set_transform_width>
    lv_style_set_transform_width(&styles->list_btn, LV_STATE_FOCUSED, - BORDER_WIDTH);
 802809c:	4b20      	ldr	r3, [pc, #128]	; (8028120 <list_init+0x860>)
 802809e:	681b      	ldr	r3, [r3, #0]
 80280a0:	f103 047c 	add.w	r4, r3, #124	; 0x7c
 80280a4:	2000      	movs	r0, #0
 80280a6:	f7f6 fd35 	bl	801eb14 <lv_disp_get_dpi>
 80280aa:	4603      	mov	r3, r0
 80280ac:	2b77      	cmp	r3, #119	; 0x77
 80280ae:	dd0c      	ble.n	80280ca <list_init+0x80a>
 80280b0:	2000      	movs	r0, #0
 80280b2:	f7f6 fd2f 	bl	801eb14 <lv_disp_get_dpi>
 80280b6:	4603      	mov	r3, r0
 80280b8:	3328      	adds	r3, #40	; 0x28
 80280ba:	4a1a      	ldr	r2, [pc, #104]	; (8028124 <list_init+0x864>)
 80280bc:	fb82 1203 	smull	r1, r2, r2, r3
 80280c0:	1152      	asrs	r2, r2, #5
 80280c2:	17db      	asrs	r3, r3, #31
 80280c4:	1a9b      	subs	r3, r3, r2
 80280c6:	b21b      	sxth	r3, r3
 80280c8:	e001      	b.n	80280ce <list_init+0x80e>
 80280ca:	f04f 33ff 	mov.w	r3, #4294967295
 80280ce:	461a      	mov	r2, r3
 80280d0:	2102      	movs	r1, #2
 80280d2:	4620      	mov	r0, r4
 80280d4:	f7fb f895 	bl	8023202 <lv_style_set_transform_width>

    lv_style_set_transition_time(&styles->list_btn, LV_STATE_DEFAULT, TRANSITION_TIME);
 80280d8:	4b11      	ldr	r3, [pc, #68]	; (8028120 <list_init+0x860>)
 80280da:	681b      	ldr	r3, [r3, #0]
 80280dc:	f103 007c 	add.w	r0, r3, #124	; 0x7c
 80280e0:	4b11      	ldr	r3, [pc, #68]	; (8028128 <list_init+0x868>)
 80280e2:	6a1b      	ldr	r3, [r3, #32]
 80280e4:	f003 0310 	and.w	r3, r3, #16
 80280e8:	2b00      	cmp	r3, #0
 80280ea:	d001      	beq.n	80280f0 <list_init+0x830>
 80280ec:	2300      	movs	r3, #0
 80280ee:	e000      	b.n	80280f2 <list_init+0x832>
 80280f0:	2396      	movs	r3, #150	; 0x96
 80280f2:	461a      	mov	r2, r3
 80280f4:	2100      	movs	r1, #0
 80280f6:	f7fb fc01 	bl	80238fc <lv_style_set_transition_time>
    lv_style_set_transition_prop_6(&styles->list_btn, LV_STATE_DEFAULT, LV_STYLE_BG_COLOR);
 80280fa:	4b09      	ldr	r3, [pc, #36]	; (8028120 <list_init+0x860>)
 80280fc:	681b      	ldr	r3, [r3, #0]
 80280fe:	337c      	adds	r3, #124	; 0x7c
 8028100:	2229      	movs	r2, #41	; 0x29
 8028102:	2100      	movs	r1, #0
 8028104:	4618      	mov	r0, r3
 8028106:	f7fb fc71 	bl	80239ec <lv_style_set_transition_prop_6>
    lv_style_set_transition_prop_5(&styles->list_btn, LV_STATE_DEFAULT, LV_STYLE_TRANSFORM_WIDTH);
 802810a:	4b05      	ldr	r3, [pc, #20]	; (8028120 <list_init+0x860>)
 802810c:	681b      	ldr	r3, [r3, #0]
 802810e:	337c      	adds	r3, #124	; 0x7c
 8028110:	2204      	movs	r2, #4
 8028112:	2100      	movs	r1, #0
 8028114:	4618      	mov	r0, r3
 8028116:	f7fb fc51 	bl	80239bc <lv_style_set_transition_prop_5>
#endif
}
 802811a:	bf00      	nop
 802811c:	bd98      	pop	{r3, r4, r7, pc}
 802811e:	bf00      	nop
 8028120:	20012350 	.word	0x20012350
 8028124:	66666667 	.word	0x66666667
 8028128:	20012328 	.word	0x20012328

0802812c <ddlist_init>:

static void ddlist_init(void)
{
 802812c:	b598      	push	{r3, r4, r7, lr}
 802812e:	af00      	add	r7, sp, #0
#if LV_USE_DROPDOWN != 0

    style_init_reset(&styles->ddlist_page);
 8028130:	4b4c      	ldr	r3, [pc, #304]	; (8028264 <ddlist_init+0x138>)
 8028132:	681b      	ldr	r3, [r3, #0]
 8028134:	3358      	adds	r3, #88	; 0x58
 8028136:	4618      	mov	r0, r3
 8028138:	f001 fb68 	bl	802980c <style_init_reset>
    lv_style_set_text_line_space(&styles->ddlist_page, LV_STATE_DEFAULT, LV_DPX(20));
 802813c:	4b49      	ldr	r3, [pc, #292]	; (8028264 <ddlist_init+0x138>)
 802813e:	681b      	ldr	r3, [r3, #0]
 8028140:	f103 0458 	add.w	r4, r3, #88	; 0x58
 8028144:	2000      	movs	r0, #0
 8028146:	f7f6 fce5 	bl	801eb14 <lv_disp_get_dpi>
 802814a:	4603      	mov	r3, r0
 802814c:	461a      	mov	r2, r3
 802814e:	4613      	mov	r3, r2
 8028150:	009b      	lsls	r3, r3, #2
 8028152:	4413      	add	r3, r2
 8028154:	009b      	lsls	r3, r3, #2
 8028156:	2bef      	cmp	r3, #239	; 0xef
 8028158:	dd11      	ble.n	802817e <ddlist_init+0x52>
 802815a:	2000      	movs	r0, #0
 802815c:	f7f6 fcda 	bl	801eb14 <lv_disp_get_dpi>
 8028160:	4603      	mov	r3, r0
 8028162:	461a      	mov	r2, r3
 8028164:	4613      	mov	r3, r2
 8028166:	009b      	lsls	r3, r3, #2
 8028168:	4413      	add	r3, r2
 802816a:	009b      	lsls	r3, r3, #2
 802816c:	3350      	adds	r3, #80	; 0x50
 802816e:	4a3e      	ldr	r2, [pc, #248]	; (8028268 <ddlist_init+0x13c>)
 8028170:	fb82 1203 	smull	r1, r2, r2, r3
 8028174:	1192      	asrs	r2, r2, #6
 8028176:	17db      	asrs	r3, r3, #31
 8028178:	1ad3      	subs	r3, r2, r3
 802817a:	b21b      	sxth	r3, r3
 802817c:	e000      	b.n	8028180 <ddlist_init+0x54>
 802817e:	2301      	movs	r3, #1
 8028180:	461a      	mov	r2, r3
 8028182:	2100      	movs	r1, #0
 8028184:	4620      	mov	r0, r4
 8028186:	f7fb fae1 	bl	802374c <lv_style_set_text_line_space>
    lv_style_set_clip_corner(&styles->ddlist_page, LV_STATE_DEFAULT, true);
 802818a:	4b36      	ldr	r3, [pc, #216]	; (8028264 <ddlist_init+0x138>)
 802818c:	681b      	ldr	r3, [r3, #0]
 802818e:	3358      	adds	r3, #88	; 0x58
 8028190:	2201      	movs	r2, #1
 8028192:	2100      	movs	r1, #0
 8028194:	4618      	mov	r0, r3
 8028196:	f7fb f804 	bl	80231a2 <lv_style_set_clip_corner>

    style_init_reset(&styles->ddlist_sel);
 802819a:	4b32      	ldr	r3, [pc, #200]	; (8028264 <ddlist_init+0x138>)
 802819c:	681b      	ldr	r3, [r3, #0]
 802819e:	335c      	adds	r3, #92	; 0x5c
 80281a0:	4618      	mov	r0, r3
 80281a2:	f001 fb33 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->ddlist_sel, LV_STATE_DEFAULT, LV_OPA_COVER);
 80281a6:	4b2f      	ldr	r3, [pc, #188]	; (8028264 <ddlist_init+0x138>)
 80281a8:	681b      	ldr	r3, [r3, #0]
 80281aa:	335c      	adds	r3, #92	; 0x5c
 80281ac:	22ff      	movs	r2, #255	; 0xff
 80281ae:	2100      	movs	r1, #0
 80281b0:	4618      	mov	r0, r3
 80281b2:	f7fb f92c 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->ddlist_sel, LV_STATE_DEFAULT, theme.color_primary);
 80281b6:	4b2b      	ldr	r3, [pc, #172]	; (8028264 <ddlist_init+0x138>)
 80281b8:	681b      	ldr	r3, [r3, #0]
 80281ba:	335c      	adds	r3, #92	; 0x5c
 80281bc:	4a2b      	ldr	r2, [pc, #172]	; (802826c <ddlist_init+0x140>)
 80281be:	8992      	ldrh	r2, [r2, #12]
 80281c0:	2100      	movs	r1, #0
 80281c2:	4618      	mov	r0, r3
 80281c4:	f7fb f90d 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_text_color(&styles->ddlist_sel, LV_STATE_DEFAULT, IS_LIGHT ? lv_color_hex3(0xfff) : lv_color_hex3(0xfff));
 80281c8:	4b26      	ldr	r3, [pc, #152]	; (8028264 <ddlist_init+0x138>)
 80281ca:	681b      	ldr	r3, [r3, #0]
 80281cc:	f103 045c 	add.w	r4, r3, #92	; 0x5c
 80281d0:	4b26      	ldr	r3, [pc, #152]	; (802826c <ddlist_init+0x140>)
 80281d2:	6a1b      	ldr	r3, [r3, #32]
 80281d4:	f003 0302 	and.w	r3, r3, #2
 80281d8:	2b00      	cmp	r3, #0
 80281da:	d005      	beq.n	80281e8 <ddlist_init+0xbc>
 80281dc:	f640 70ff 	movw	r0, #4095	; 0xfff
 80281e0:	f7fa ff95 	bl	802310e <lv_color_hex3>
 80281e4:	4603      	mov	r3, r0
 80281e6:	e004      	b.n	80281f2 <ddlist_init+0xc6>
 80281e8:	f640 70ff 	movw	r0, #4095	; 0xfff
 80281ec:	f7fa ff8f 	bl	802310e <lv_color_hex3>
 80281f0:	4603      	mov	r3, r0
 80281f2:	461a      	mov	r2, r3
 80281f4:	2100      	movs	r1, #0
 80281f6:	4620      	mov	r0, r4
 80281f8:	f7fb fac2 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_bg_color(&styles->ddlist_sel, LV_STATE_PRESSED, COLOR_BG_PR);
 80281fc:	4b19      	ldr	r3, [pc, #100]	; (8028264 <ddlist_init+0x138>)
 80281fe:	681b      	ldr	r3, [r3, #0]
 8028200:	f103 045c 	add.w	r4, r3, #92	; 0x5c
 8028204:	4b19      	ldr	r3, [pc, #100]	; (802826c <ddlist_init+0x140>)
 8028206:	6a1b      	ldr	r3, [r3, #32]
 8028208:	f003 0302 	and.w	r3, r3, #2
 802820c:	2b00      	cmp	r3, #0
 802820e:	d004      	beq.n	802821a <ddlist_init+0xee>
 8028210:	4817      	ldr	r0, [pc, #92]	; (8028270 <ddlist_init+0x144>)
 8028212:	f7fa ff68 	bl	80230e6 <lv_color_hex>
 8028216:	4603      	mov	r3, r0
 8028218:	e003      	b.n	8028222 <ddlist_init+0xf6>
 802821a:	4816      	ldr	r0, [pc, #88]	; (8028274 <ddlist_init+0x148>)
 802821c:	f7fa ff63 	bl	80230e6 <lv_color_hex>
 8028220:	4603      	mov	r3, r0
 8028222:	461a      	mov	r2, r3
 8028224:	2110      	movs	r1, #16
 8028226:	4620      	mov	r0, r4
 8028228:	f7fb f8db 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_text_color(&styles->ddlist_sel, LV_STATE_PRESSED, COLOR_BG_TEXT_PR);
 802822c:	4b0d      	ldr	r3, [pc, #52]	; (8028264 <ddlist_init+0x138>)
 802822e:	681b      	ldr	r3, [r3, #0]
 8028230:	f103 045c 	add.w	r4, r3, #92	; 0x5c
 8028234:	4b0d      	ldr	r3, [pc, #52]	; (802826c <ddlist_init+0x140>)
 8028236:	6a1b      	ldr	r3, [r3, #32]
 8028238:	f003 0302 	and.w	r3, r3, #2
 802823c:	2b00      	cmp	r3, #0
 802823e:	d004      	beq.n	802824a <ddlist_init+0x11e>
 8028240:	480d      	ldr	r0, [pc, #52]	; (8028278 <ddlist_init+0x14c>)
 8028242:	f7fa ff50 	bl	80230e6 <lv_color_hex>
 8028246:	4603      	mov	r3, r0
 8028248:	e004      	b.n	8028254 <ddlist_init+0x128>
 802824a:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 802824e:	f7fa ff4a 	bl	80230e6 <lv_color_hex>
 8028252:	4603      	mov	r3, r0
 8028254:	461a      	mov	r2, r3
 8028256:	2110      	movs	r1, #16
 8028258:	4620      	mov	r0, r4
 802825a:	f7fb fa91 	bl	8023780 <lv_style_set_text_color>
#endif
}
 802825e:	bf00      	nop
 8028260:	bd98      	pop	{r3, r4, r7, pc}
 8028262:	bf00      	nop
 8028264:	20012350 	.word	0x20012350
 8028268:	66666667 	.word	0x66666667
 802826c:	20012328 	.word	0x20012328
 8028270:	00eeeeee 	.word	0x00eeeeee
 8028274:	00494f57 	.word	0x00494f57
 8028278:	003b3e42 	.word	0x003b3e42

0802827c <roller_init>:

static void roller_init(void)
{
 802827c:	b598      	push	{r3, r4, r7, lr}
 802827e:	af00      	add	r7, sp, #0
#if LV_USE_ROLLER != 0
    style_init_reset(&styles->roller_bg);
 8028280:	4b28      	ldr	r3, [pc, #160]	; (8028324 <roller_init+0xa8>)
 8028282:	681b      	ldr	r3, [r3, #0]
 8028284:	338c      	adds	r3, #140	; 0x8c
 8028286:	4618      	mov	r0, r3
 8028288:	f001 fac0 	bl	802980c <style_init_reset>
    lv_style_set_text_line_space(&styles->roller_bg, LV_STATE_DEFAULT, LV_DPX(25));
 802828c:	4b25      	ldr	r3, [pc, #148]	; (8028324 <roller_init+0xa8>)
 802828e:	681b      	ldr	r3, [r3, #0]
 8028290:	f103 048c 	add.w	r4, r3, #140	; 0x8c
 8028294:	2000      	movs	r0, #0
 8028296:	f7f6 fc3d 	bl	801eb14 <lv_disp_get_dpi>
 802829a:	4603      	mov	r3, r0
 802829c:	461a      	mov	r2, r3
 802829e:	4613      	mov	r3, r2
 80282a0:	009b      	lsls	r3, r3, #2
 80282a2:	4413      	add	r3, r2
 80282a4:	009a      	lsls	r2, r3, #2
 80282a6:	4413      	add	r3, r2
 80282a8:	2bef      	cmp	r3, #239	; 0xef
 80282aa:	dd12      	ble.n	80282d2 <roller_init+0x56>
 80282ac:	2000      	movs	r0, #0
 80282ae:	f7f6 fc31 	bl	801eb14 <lv_disp_get_dpi>
 80282b2:	4603      	mov	r3, r0
 80282b4:	461a      	mov	r2, r3
 80282b6:	4613      	mov	r3, r2
 80282b8:	009b      	lsls	r3, r3, #2
 80282ba:	4413      	add	r3, r2
 80282bc:	009a      	lsls	r2, r3, #2
 80282be:	4413      	add	r3, r2
 80282c0:	3350      	adds	r3, #80	; 0x50
 80282c2:	4a19      	ldr	r2, [pc, #100]	; (8028328 <roller_init+0xac>)
 80282c4:	fb82 1203 	smull	r1, r2, r2, r3
 80282c8:	1192      	asrs	r2, r2, #6
 80282ca:	17db      	asrs	r3, r3, #31
 80282cc:	1ad3      	subs	r3, r2, r3
 80282ce:	b21b      	sxth	r3, r3
 80282d0:	e000      	b.n	80282d4 <roller_init+0x58>
 80282d2:	2301      	movs	r3, #1
 80282d4:	461a      	mov	r2, r3
 80282d6:	2100      	movs	r1, #0
 80282d8:	4620      	mov	r0, r4
 80282da:	f7fb fa37 	bl	802374c <lv_style_set_text_line_space>

    style_init_reset(&styles->roller_sel);
 80282de:	4b11      	ldr	r3, [pc, #68]	; (8028324 <roller_init+0xa8>)
 80282e0:	681b      	ldr	r3, [r3, #0]
 80282e2:	3390      	adds	r3, #144	; 0x90
 80282e4:	4618      	mov	r0, r3
 80282e6:	f001 fa91 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->roller_sel, LV_STATE_DEFAULT, LV_OPA_COVER);
 80282ea:	4b0e      	ldr	r3, [pc, #56]	; (8028324 <roller_init+0xa8>)
 80282ec:	681b      	ldr	r3, [r3, #0]
 80282ee:	3390      	adds	r3, #144	; 0x90
 80282f0:	22ff      	movs	r2, #255	; 0xff
 80282f2:	2100      	movs	r1, #0
 80282f4:	4618      	mov	r0, r3
 80282f6:	f7fb f88a 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->roller_sel, LV_STATE_DEFAULT, theme.color_primary);
 80282fa:	4b0a      	ldr	r3, [pc, #40]	; (8028324 <roller_init+0xa8>)
 80282fc:	681b      	ldr	r3, [r3, #0]
 80282fe:	3390      	adds	r3, #144	; 0x90
 8028300:	4a0a      	ldr	r2, [pc, #40]	; (802832c <roller_init+0xb0>)
 8028302:	8992      	ldrh	r2, [r2, #12]
 8028304:	2100      	movs	r1, #0
 8028306:	4618      	mov	r0, r3
 8028308:	f7fb f86b 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_text_color(&styles->roller_sel, LV_STATE_DEFAULT, LV_COLOR_WHITE);
 802830c:	4b05      	ldr	r3, [pc, #20]	; (8028324 <roller_init+0xa8>)
 802830e:	681b      	ldr	r3, [r3, #0]
 8028310:	3390      	adds	r3, #144	; 0x90
 8028312:	4a07      	ldr	r2, [pc, #28]	; (8028330 <roller_init+0xb4>)
 8028314:	8812      	ldrh	r2, [r2, #0]
 8028316:	2100      	movs	r1, #0
 8028318:	4618      	mov	r0, r3
 802831a:	f7fb fa31 	bl	8023780 <lv_style_set_text_color>
#endif
}
 802831e:	bf00      	nop
 8028320:	bd98      	pop	{r3, r4, r7, pc}
 8028322:	bf00      	nop
 8028324:	20012350 	.word	0x20012350
 8028328:	66666667 	.word	0x66666667
 802832c:	20012328 	.word	0x20012328
 8028330:	0802e594 	.word	0x0802e594

08028334 <tabview_init>:

static void tabview_init(void)
{
 8028334:	b480      	push	{r7}
 8028336:	af00      	add	r7, sp, #0
#if LV_USE_TABVIEW != 0
#endif
}
 8028338:	bf00      	nop
 802833a:	46bd      	mov	sp, r7
 802833c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028340:	4770      	bx	lr

08028342 <tileview_init>:

static void tileview_init(void)
{
 8028342:	b480      	push	{r7}
 8028344:	af00      	add	r7, sp, #0
#if LV_USE_TILEVIEW != 0
#endif
}
 8028346:	bf00      	nop
 8028348:	46bd      	mov	sp, r7
 802834a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802834e:	4770      	bx	lr

08028350 <table_init>:

static void table_init(void)
{
 8028350:	b598      	push	{r3, r4, r7, lr}
 8028352:	af00      	add	r7, sp, #0
#if LV_USE_TABLE != 0
    style_init_reset(&styles->table_cell);
 8028354:	4bab      	ldr	r3, [pc, #684]	; (8028604 <table_init+0x2b4>)
 8028356:	681b      	ldr	r3, [r3, #0]
 8028358:	33a4      	adds	r3, #164	; 0xa4
 802835a:	4618      	mov	r0, r3
 802835c:	f001 fa56 	bl	802980c <style_init_reset>
    lv_style_set_border_color(&styles->table_cell, LV_STATE_DEFAULT, COLOR_BG_BORDER);
 8028360:	4ba8      	ldr	r3, [pc, #672]	; (8028604 <table_init+0x2b4>)
 8028362:	681b      	ldr	r3, [r3, #0]
 8028364:	f103 04a4 	add.w	r4, r3, #164	; 0xa4
 8028368:	4ba7      	ldr	r3, [pc, #668]	; (8028608 <table_init+0x2b8>)
 802836a:	6a1b      	ldr	r3, [r3, #32]
 802836c:	f003 0302 	and.w	r3, r3, #2
 8028370:	2b00      	cmp	r3, #0
 8028372:	d004      	beq.n	802837e <table_init+0x2e>
 8028374:	48a5      	ldr	r0, [pc, #660]	; (802860c <table_init+0x2bc>)
 8028376:	f7fa feb6 	bl	80230e6 <lv_color_hex>
 802837a:	4603      	mov	r3, r0
 802837c:	e003      	b.n	8028386 <table_init+0x36>
 802837e:	48a4      	ldr	r0, [pc, #656]	; (8028610 <table_init+0x2c0>)
 8028380:	f7fa feb1 	bl	80230e6 <lv_color_hex>
 8028384:	4603      	mov	r3, r0
 8028386:	461a      	mov	r2, r3
 8028388:	2100      	movs	r1, #0
 802838a:	4620      	mov	r0, r4
 802838c:	f7fb f89e 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_width(&styles->table_cell, LV_STATE_DEFAULT, 1);
 8028390:	4b9c      	ldr	r3, [pc, #624]	; (8028604 <table_init+0x2b4>)
 8028392:	681b      	ldr	r3, [r3, #0]
 8028394:	33a4      	adds	r3, #164	; 0xa4
 8028396:	2201      	movs	r2, #1
 8028398:	2100      	movs	r1, #0
 802839a:	4618      	mov	r0, r3
 802839c:	f7fb f84e 	bl	802343c <lv_style_set_border_width>
    lv_style_set_border_side(&styles->table_cell, LV_STATE_DEFAULT, LV_BORDER_SIDE_TOP | LV_BORDER_SIDE_BOTTOM);
 80283a0:	4b98      	ldr	r3, [pc, #608]	; (8028604 <table_init+0x2b4>)
 80283a2:	681b      	ldr	r3, [r3, #0]
 80283a4:	33a4      	adds	r3, #164	; 0xa4
 80283a6:	2203      	movs	r2, #3
 80283a8:	2100      	movs	r1, #0
 80283aa:	4618      	mov	r0, r3
 80283ac:	f7fb f85e 	bl	802346c <lv_style_set_border_side>
    lv_style_set_pad_left(&styles->table_cell, LV_STATE_DEFAULT, PAD_DEF);
 80283b0:	4b94      	ldr	r3, [pc, #592]	; (8028604 <table_init+0x2b4>)
 80283b2:	681b      	ldr	r3, [r3, #0]
 80283b4:	f103 04a4 	add.w	r4, r3, #164	; 0xa4
 80283b8:	2000      	movs	r0, #0
 80283ba:	f7f6 fbc4 	bl	801eb46 <lv_disp_get_size_category>
 80283be:	4603      	mov	r3, r0
 80283c0:	2b01      	cmp	r3, #1
 80283c2:	d81c      	bhi.n	80283fe <table_init+0xae>
 80283c4:	2000      	movs	r0, #0
 80283c6:	f7f6 fba5 	bl	801eb14 <lv_disp_get_dpi>
 80283ca:	4603      	mov	r3, r0
 80283cc:	461a      	mov	r2, r3
 80283ce:	4613      	mov	r3, r2
 80283d0:	011b      	lsls	r3, r3, #4
 80283d2:	1a9b      	subs	r3, r3, r2
 80283d4:	2bef      	cmp	r3, #239	; 0xef
 80283d6:	dd10      	ble.n	80283fa <table_init+0xaa>
 80283d8:	2000      	movs	r0, #0
 80283da:	f7f6 fb9b 	bl	801eb14 <lv_disp_get_dpi>
 80283de:	4603      	mov	r3, r0
 80283e0:	461a      	mov	r2, r3
 80283e2:	4613      	mov	r3, r2
 80283e4:	011b      	lsls	r3, r3, #4
 80283e6:	1a9b      	subs	r3, r3, r2
 80283e8:	3350      	adds	r3, #80	; 0x50
 80283ea:	4a8a      	ldr	r2, [pc, #552]	; (8028614 <table_init+0x2c4>)
 80283ec:	fb82 1203 	smull	r1, r2, r2, r3
 80283f0:	1192      	asrs	r2, r2, #6
 80283f2:	17db      	asrs	r3, r3, #31
 80283f4:	1ad3      	subs	r3, r2, r3
 80283f6:	b21b      	sxth	r3, r3
 80283f8:	e01f      	b.n	802843a <table_init+0xea>
 80283fa:	2301      	movs	r3, #1
 80283fc:	e01d      	b.n	802843a <table_init+0xea>
 80283fe:	2000      	movs	r0, #0
 8028400:	f7f6 fb88 	bl	801eb14 <lv_disp_get_dpi>
 8028404:	4603      	mov	r3, r0
 8028406:	461a      	mov	r2, r3
 8028408:	4613      	mov	r3, r2
 802840a:	011b      	lsls	r3, r3, #4
 802840c:	1a9b      	subs	r3, r3, r2
 802840e:	005b      	lsls	r3, r3, #1
 8028410:	2bef      	cmp	r3, #239	; 0xef
 8028412:	dd11      	ble.n	8028438 <table_init+0xe8>
 8028414:	2000      	movs	r0, #0
 8028416:	f7f6 fb7d 	bl	801eb14 <lv_disp_get_dpi>
 802841a:	4603      	mov	r3, r0
 802841c:	461a      	mov	r2, r3
 802841e:	4613      	mov	r3, r2
 8028420:	011b      	lsls	r3, r3, #4
 8028422:	1a9b      	subs	r3, r3, r2
 8028424:	005b      	lsls	r3, r3, #1
 8028426:	3350      	adds	r3, #80	; 0x50
 8028428:	4a7a      	ldr	r2, [pc, #488]	; (8028614 <table_init+0x2c4>)
 802842a:	fb82 1203 	smull	r1, r2, r2, r3
 802842e:	1192      	asrs	r2, r2, #6
 8028430:	17db      	asrs	r3, r3, #31
 8028432:	1ad3      	subs	r3, r2, r3
 8028434:	b21b      	sxth	r3, r3
 8028436:	e000      	b.n	802843a <table_init+0xea>
 8028438:	2301      	movs	r3, #1
 802843a:	461a      	mov	r2, r3
 802843c:	2100      	movs	r1, #0
 802843e:	4620      	mov	r0, r4
 8028440:	f7fa ff27 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->table_cell, LV_STATE_DEFAULT, PAD_DEF);
 8028444:	4b6f      	ldr	r3, [pc, #444]	; (8028604 <table_init+0x2b4>)
 8028446:	681b      	ldr	r3, [r3, #0]
 8028448:	f103 04a4 	add.w	r4, r3, #164	; 0xa4
 802844c:	2000      	movs	r0, #0
 802844e:	f7f6 fb7a 	bl	801eb46 <lv_disp_get_size_category>
 8028452:	4603      	mov	r3, r0
 8028454:	2b01      	cmp	r3, #1
 8028456:	d81c      	bhi.n	8028492 <table_init+0x142>
 8028458:	2000      	movs	r0, #0
 802845a:	f7f6 fb5b 	bl	801eb14 <lv_disp_get_dpi>
 802845e:	4603      	mov	r3, r0
 8028460:	461a      	mov	r2, r3
 8028462:	4613      	mov	r3, r2
 8028464:	011b      	lsls	r3, r3, #4
 8028466:	1a9b      	subs	r3, r3, r2
 8028468:	2bef      	cmp	r3, #239	; 0xef
 802846a:	dd10      	ble.n	802848e <table_init+0x13e>
 802846c:	2000      	movs	r0, #0
 802846e:	f7f6 fb51 	bl	801eb14 <lv_disp_get_dpi>
 8028472:	4603      	mov	r3, r0
 8028474:	461a      	mov	r2, r3
 8028476:	4613      	mov	r3, r2
 8028478:	011b      	lsls	r3, r3, #4
 802847a:	1a9b      	subs	r3, r3, r2
 802847c:	3350      	adds	r3, #80	; 0x50
 802847e:	4a65      	ldr	r2, [pc, #404]	; (8028614 <table_init+0x2c4>)
 8028480:	fb82 1203 	smull	r1, r2, r2, r3
 8028484:	1192      	asrs	r2, r2, #6
 8028486:	17db      	asrs	r3, r3, #31
 8028488:	1ad3      	subs	r3, r2, r3
 802848a:	b21b      	sxth	r3, r3
 802848c:	e01f      	b.n	80284ce <table_init+0x17e>
 802848e:	2301      	movs	r3, #1
 8028490:	e01d      	b.n	80284ce <table_init+0x17e>
 8028492:	2000      	movs	r0, #0
 8028494:	f7f6 fb3e 	bl	801eb14 <lv_disp_get_dpi>
 8028498:	4603      	mov	r3, r0
 802849a:	461a      	mov	r2, r3
 802849c:	4613      	mov	r3, r2
 802849e:	011b      	lsls	r3, r3, #4
 80284a0:	1a9b      	subs	r3, r3, r2
 80284a2:	005b      	lsls	r3, r3, #1
 80284a4:	2bef      	cmp	r3, #239	; 0xef
 80284a6:	dd11      	ble.n	80284cc <table_init+0x17c>
 80284a8:	2000      	movs	r0, #0
 80284aa:	f7f6 fb33 	bl	801eb14 <lv_disp_get_dpi>
 80284ae:	4603      	mov	r3, r0
 80284b0:	461a      	mov	r2, r3
 80284b2:	4613      	mov	r3, r2
 80284b4:	011b      	lsls	r3, r3, #4
 80284b6:	1a9b      	subs	r3, r3, r2
 80284b8:	005b      	lsls	r3, r3, #1
 80284ba:	3350      	adds	r3, #80	; 0x50
 80284bc:	4a55      	ldr	r2, [pc, #340]	; (8028614 <table_init+0x2c4>)
 80284be:	fb82 1203 	smull	r1, r2, r2, r3
 80284c2:	1192      	asrs	r2, r2, #6
 80284c4:	17db      	asrs	r3, r3, #31
 80284c6:	1ad3      	subs	r3, r2, r3
 80284c8:	b21b      	sxth	r3, r3
 80284ca:	e000      	b.n	80284ce <table_init+0x17e>
 80284cc:	2301      	movs	r3, #1
 80284ce:	461a      	mov	r2, r3
 80284d0:	2100      	movs	r1, #0
 80284d2:	4620      	mov	r0, r4
 80284d4:	f7fa fef5 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_top(&styles->table_cell, LV_STATE_DEFAULT, PAD_DEF);
 80284d8:	4b4a      	ldr	r3, [pc, #296]	; (8028604 <table_init+0x2b4>)
 80284da:	681b      	ldr	r3, [r3, #0]
 80284dc:	f103 04a4 	add.w	r4, r3, #164	; 0xa4
 80284e0:	2000      	movs	r0, #0
 80284e2:	f7f6 fb30 	bl	801eb46 <lv_disp_get_size_category>
 80284e6:	4603      	mov	r3, r0
 80284e8:	2b01      	cmp	r3, #1
 80284ea:	d81c      	bhi.n	8028526 <table_init+0x1d6>
 80284ec:	2000      	movs	r0, #0
 80284ee:	f7f6 fb11 	bl	801eb14 <lv_disp_get_dpi>
 80284f2:	4603      	mov	r3, r0
 80284f4:	461a      	mov	r2, r3
 80284f6:	4613      	mov	r3, r2
 80284f8:	011b      	lsls	r3, r3, #4
 80284fa:	1a9b      	subs	r3, r3, r2
 80284fc:	2bef      	cmp	r3, #239	; 0xef
 80284fe:	dd10      	ble.n	8028522 <table_init+0x1d2>
 8028500:	2000      	movs	r0, #0
 8028502:	f7f6 fb07 	bl	801eb14 <lv_disp_get_dpi>
 8028506:	4603      	mov	r3, r0
 8028508:	461a      	mov	r2, r3
 802850a:	4613      	mov	r3, r2
 802850c:	011b      	lsls	r3, r3, #4
 802850e:	1a9b      	subs	r3, r3, r2
 8028510:	3350      	adds	r3, #80	; 0x50
 8028512:	4a40      	ldr	r2, [pc, #256]	; (8028614 <table_init+0x2c4>)
 8028514:	fb82 1203 	smull	r1, r2, r2, r3
 8028518:	1192      	asrs	r2, r2, #6
 802851a:	17db      	asrs	r3, r3, #31
 802851c:	1ad3      	subs	r3, r2, r3
 802851e:	b21b      	sxth	r3, r3
 8028520:	e01f      	b.n	8028562 <table_init+0x212>
 8028522:	2301      	movs	r3, #1
 8028524:	e01d      	b.n	8028562 <table_init+0x212>
 8028526:	2000      	movs	r0, #0
 8028528:	f7f6 faf4 	bl	801eb14 <lv_disp_get_dpi>
 802852c:	4603      	mov	r3, r0
 802852e:	461a      	mov	r2, r3
 8028530:	4613      	mov	r3, r2
 8028532:	011b      	lsls	r3, r3, #4
 8028534:	1a9b      	subs	r3, r3, r2
 8028536:	005b      	lsls	r3, r3, #1
 8028538:	2bef      	cmp	r3, #239	; 0xef
 802853a:	dd11      	ble.n	8028560 <table_init+0x210>
 802853c:	2000      	movs	r0, #0
 802853e:	f7f6 fae9 	bl	801eb14 <lv_disp_get_dpi>
 8028542:	4603      	mov	r3, r0
 8028544:	461a      	mov	r2, r3
 8028546:	4613      	mov	r3, r2
 8028548:	011b      	lsls	r3, r3, #4
 802854a:	1a9b      	subs	r3, r3, r2
 802854c:	005b      	lsls	r3, r3, #1
 802854e:	3350      	adds	r3, #80	; 0x50
 8028550:	4a30      	ldr	r2, [pc, #192]	; (8028614 <table_init+0x2c4>)
 8028552:	fb82 1203 	smull	r1, r2, r2, r3
 8028556:	1192      	asrs	r2, r2, #6
 8028558:	17db      	asrs	r3, r3, #31
 802855a:	1ad3      	subs	r3, r2, r3
 802855c:	b21b      	sxth	r3, r3
 802855e:	e000      	b.n	8028562 <table_init+0x212>
 8028560:	2301      	movs	r3, #1
 8028562:	461a      	mov	r2, r3
 8028564:	2100      	movs	r1, #0
 8028566:	4620      	mov	r0, r4
 8028568:	f7fa fe63 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->table_cell, LV_STATE_DEFAULT, PAD_DEF);
 802856c:	4b25      	ldr	r3, [pc, #148]	; (8028604 <table_init+0x2b4>)
 802856e:	681b      	ldr	r3, [r3, #0]
 8028570:	f103 04a4 	add.w	r4, r3, #164	; 0xa4
 8028574:	2000      	movs	r0, #0
 8028576:	f7f6 fae6 	bl	801eb46 <lv_disp_get_size_category>
 802857a:	4603      	mov	r3, r0
 802857c:	2b01      	cmp	r3, #1
 802857e:	d81c      	bhi.n	80285ba <table_init+0x26a>
 8028580:	2000      	movs	r0, #0
 8028582:	f7f6 fac7 	bl	801eb14 <lv_disp_get_dpi>
 8028586:	4603      	mov	r3, r0
 8028588:	461a      	mov	r2, r3
 802858a:	4613      	mov	r3, r2
 802858c:	011b      	lsls	r3, r3, #4
 802858e:	1a9b      	subs	r3, r3, r2
 8028590:	2bef      	cmp	r3, #239	; 0xef
 8028592:	dd10      	ble.n	80285b6 <table_init+0x266>
 8028594:	2000      	movs	r0, #0
 8028596:	f7f6 fabd 	bl	801eb14 <lv_disp_get_dpi>
 802859a:	4603      	mov	r3, r0
 802859c:	461a      	mov	r2, r3
 802859e:	4613      	mov	r3, r2
 80285a0:	011b      	lsls	r3, r3, #4
 80285a2:	1a9b      	subs	r3, r3, r2
 80285a4:	3350      	adds	r3, #80	; 0x50
 80285a6:	4a1b      	ldr	r2, [pc, #108]	; (8028614 <table_init+0x2c4>)
 80285a8:	fb82 1203 	smull	r1, r2, r2, r3
 80285ac:	1192      	asrs	r2, r2, #6
 80285ae:	17db      	asrs	r3, r3, #31
 80285b0:	1ad3      	subs	r3, r2, r3
 80285b2:	b21b      	sxth	r3, r3
 80285b4:	e01f      	b.n	80285f6 <table_init+0x2a6>
 80285b6:	2301      	movs	r3, #1
 80285b8:	e01d      	b.n	80285f6 <table_init+0x2a6>
 80285ba:	2000      	movs	r0, #0
 80285bc:	f7f6 faaa 	bl	801eb14 <lv_disp_get_dpi>
 80285c0:	4603      	mov	r3, r0
 80285c2:	461a      	mov	r2, r3
 80285c4:	4613      	mov	r3, r2
 80285c6:	011b      	lsls	r3, r3, #4
 80285c8:	1a9b      	subs	r3, r3, r2
 80285ca:	005b      	lsls	r3, r3, #1
 80285cc:	2bef      	cmp	r3, #239	; 0xef
 80285ce:	dd11      	ble.n	80285f4 <table_init+0x2a4>
 80285d0:	2000      	movs	r0, #0
 80285d2:	f7f6 fa9f 	bl	801eb14 <lv_disp_get_dpi>
 80285d6:	4603      	mov	r3, r0
 80285d8:	461a      	mov	r2, r3
 80285da:	4613      	mov	r3, r2
 80285dc:	011b      	lsls	r3, r3, #4
 80285de:	1a9b      	subs	r3, r3, r2
 80285e0:	005b      	lsls	r3, r3, #1
 80285e2:	3350      	adds	r3, #80	; 0x50
 80285e4:	4a0b      	ldr	r2, [pc, #44]	; (8028614 <table_init+0x2c4>)
 80285e6:	fb82 1203 	smull	r1, r2, r2, r3
 80285ea:	1192      	asrs	r2, r2, #6
 80285ec:	17db      	asrs	r3, r3, #31
 80285ee:	1ad3      	subs	r3, r2, r3
 80285f0:	b21b      	sxth	r3, r3
 80285f2:	e000      	b.n	80285f6 <table_init+0x2a6>
 80285f4:	2301      	movs	r3, #1
 80285f6:	461a      	mov	r2, r3
 80285f8:	2100      	movs	r1, #0
 80285fa:	4620      	mov	r0, r4
 80285fc:	f7fa fe31 	bl	8023262 <lv_style_set_pad_bottom>

#endif
}
 8028600:	bf00      	nop
 8028602:	bd98      	pop	{r3, r4, r7, pc}
 8028604:	20012350 	.word	0x20012350
 8028608:	20012328 	.word	0x20012328
 802860c:	00d6dde3 	.word	0x00d6dde3
 8028610:	00808a97 	.word	0x00808a97
 8028614:	66666667 	.word	0x66666667

08028618 <win_init>:

static void win_init(void)
{
 8028618:	b480      	push	{r7}
 802861a:	af00      	add	r7, sp, #0
#if LV_USE_WIN != 0
#endif
}
 802861c:	bf00      	nop
 802861e:	46bd      	mov	sp, r7
 8028620:	f85d 7b04 	ldr.w	r7, [sp], #4
 8028624:	4770      	bx	lr
	...

08028628 <tabview_win_shared_init>:

static void tabview_win_shared_init(void)
{
 8028628:	b598      	push	{r3, r4, r7, lr}
 802862a:	af00      	add	r7, sp, #0
#if LV_USE_TABVIEW || LV_USE_WIN
    style_init_reset(&styles->tabview_btns_bg);
 802862c:	4bc2      	ldr	r3, [pc, #776]	; (8028938 <tabview_win_shared_init+0x310>)
 802862e:	681b      	ldr	r3, [r3, #0]
 8028630:	33ac      	adds	r3, #172	; 0xac
 8028632:	4618      	mov	r0, r3
 8028634:	f001 f8ea 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->tabview_btns_bg, LV_STATE_DEFAULT, LV_OPA_COVER);
 8028638:	4bbf      	ldr	r3, [pc, #764]	; (8028938 <tabview_win_shared_init+0x310>)
 802863a:	681b      	ldr	r3, [r3, #0]
 802863c:	33ac      	adds	r3, #172	; 0xac
 802863e:	22ff      	movs	r2, #255	; 0xff
 8028640:	2100      	movs	r1, #0
 8028642:	4618      	mov	r0, r3
 8028644:	f7fa fee3 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->tabview_btns_bg, LV_STATE_DEFAULT, COLOR_BG);
 8028648:	4bbb      	ldr	r3, [pc, #748]	; (8028938 <tabview_win_shared_init+0x310>)
 802864a:	681b      	ldr	r3, [r3, #0]
 802864c:	f103 04ac 	add.w	r4, r3, #172	; 0xac
 8028650:	4bba      	ldr	r3, [pc, #744]	; (802893c <tabview_win_shared_init+0x314>)
 8028652:	6a1b      	ldr	r3, [r3, #32]
 8028654:	f003 0302 	and.w	r3, r3, #2
 8028658:	2b00      	cmp	r3, #0
 802865a:	d005      	beq.n	8028668 <tabview_win_shared_init+0x40>
 802865c:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8028660:	f7fa fd41 	bl	80230e6 <lv_color_hex>
 8028664:	4603      	mov	r3, r0
 8028666:	e003      	b.n	8028670 <tabview_win_shared_init+0x48>
 8028668:	48b5      	ldr	r0, [pc, #724]	; (8028940 <tabview_win_shared_init+0x318>)
 802866a:	f7fa fd3c 	bl	80230e6 <lv_color_hex>
 802866e:	4603      	mov	r3, r0
 8028670:	461a      	mov	r2, r3
 8028672:	2100      	movs	r1, #0
 8028674:	4620      	mov	r0, r4
 8028676:	f7fa feb4 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_border_color(&styles->tabview_btns_bg, LV_STATE_DEFAULT,
 802867a:	4baf      	ldr	r3, [pc, #700]	; (8028938 <tabview_win_shared_init+0x310>)
 802867c:	681b      	ldr	r3, [r3, #0]
 802867e:	f103 04ac 	add.w	r4, r3, #172	; 0xac
                              IS_LIGHT ? lv_color_hex(0xe4eaf0) : lv_color_hex(0x3b3e42));
 8028682:	4bae      	ldr	r3, [pc, #696]	; (802893c <tabview_win_shared_init+0x314>)
 8028684:	6a1b      	ldr	r3, [r3, #32]
 8028686:	f003 0302 	and.w	r3, r3, #2
    lv_style_set_border_color(&styles->tabview_btns_bg, LV_STATE_DEFAULT,
 802868a:	2b00      	cmp	r3, #0
 802868c:	d004      	beq.n	8028698 <tabview_win_shared_init+0x70>
                              IS_LIGHT ? lv_color_hex(0xe4eaf0) : lv_color_hex(0x3b3e42));
 802868e:	48ad      	ldr	r0, [pc, #692]	; (8028944 <tabview_win_shared_init+0x31c>)
 8028690:	f7fa fd29 	bl	80230e6 <lv_color_hex>
 8028694:	4603      	mov	r3, r0
 8028696:	e003      	b.n	80286a0 <tabview_win_shared_init+0x78>
 8028698:	48ab      	ldr	r0, [pc, #684]	; (8028948 <tabview_win_shared_init+0x320>)
 802869a:	f7fa fd24 	bl	80230e6 <lv_color_hex>
 802869e:	4603      	mov	r3, r0
    lv_style_set_border_color(&styles->tabview_btns_bg, LV_STATE_DEFAULT,
 80286a0:	461a      	mov	r2, r3
 80286a2:	2100      	movs	r1, #0
 80286a4:	4620      	mov	r0, r4
 80286a6:	f7fa ff11 	bl	80234cc <lv_style_set_border_color>
    lv_style_set_border_width(&styles->tabview_btns_bg, LV_STATE_DEFAULT, LV_DPX(5));
 80286aa:	4ba3      	ldr	r3, [pc, #652]	; (8028938 <tabview_win_shared_init+0x310>)
 80286ac:	681b      	ldr	r3, [r3, #0]
 80286ae:	f103 04ac 	add.w	r4, r3, #172	; 0xac
 80286b2:	2000      	movs	r0, #0
 80286b4:	f7f6 fa2e 	bl	801eb14 <lv_disp_get_dpi>
 80286b8:	4603      	mov	r3, r0
 80286ba:	461a      	mov	r2, r3
 80286bc:	4613      	mov	r3, r2
 80286be:	009b      	lsls	r3, r3, #2
 80286c0:	4413      	add	r3, r2
 80286c2:	2bef      	cmp	r3, #239	; 0xef
 80286c4:	dd10      	ble.n	80286e8 <tabview_win_shared_init+0xc0>
 80286c6:	2000      	movs	r0, #0
 80286c8:	f7f6 fa24 	bl	801eb14 <lv_disp_get_dpi>
 80286cc:	4603      	mov	r3, r0
 80286ce:	461a      	mov	r2, r3
 80286d0:	4613      	mov	r3, r2
 80286d2:	009b      	lsls	r3, r3, #2
 80286d4:	4413      	add	r3, r2
 80286d6:	3350      	adds	r3, #80	; 0x50
 80286d8:	4a9c      	ldr	r2, [pc, #624]	; (802894c <tabview_win_shared_init+0x324>)
 80286da:	fb82 1203 	smull	r1, r2, r2, r3
 80286de:	1192      	asrs	r2, r2, #6
 80286e0:	17db      	asrs	r3, r3, #31
 80286e2:	1ad3      	subs	r3, r2, r3
 80286e4:	b21b      	sxth	r3, r3
 80286e6:	e000      	b.n	80286ea <tabview_win_shared_init+0xc2>
 80286e8:	2301      	movs	r3, #1
 80286ea:	461a      	mov	r2, r3
 80286ec:	2100      	movs	r1, #0
 80286ee:	4620      	mov	r0, r4
 80286f0:	f7fa fea4 	bl	802343c <lv_style_set_border_width>
    lv_style_set_border_side(&styles->tabview_btns_bg, LV_STATE_DEFAULT, LV_BORDER_SIDE_BOTTOM);
 80286f4:	4b90      	ldr	r3, [pc, #576]	; (8028938 <tabview_win_shared_init+0x310>)
 80286f6:	681b      	ldr	r3, [r3, #0]
 80286f8:	33ac      	adds	r3, #172	; 0xac
 80286fa:	2201      	movs	r2, #1
 80286fc:	2100      	movs	r1, #0
 80286fe:	4618      	mov	r0, r3
 8028700:	f7fa feb4 	bl	802346c <lv_style_set_border_side>
    lv_style_set_text_color(&styles->tabview_btns_bg, LV_STATE_DEFAULT, COLOR_SCR_TEXT);
 8028704:	4b8c      	ldr	r3, [pc, #560]	; (8028938 <tabview_win_shared_init+0x310>)
 8028706:	681b      	ldr	r3, [r3, #0]
 8028708:	f103 04ac 	add.w	r4, r3, #172	; 0xac
 802870c:	4b8b      	ldr	r3, [pc, #556]	; (802893c <tabview_win_shared_init+0x314>)
 802870e:	6a1b      	ldr	r3, [r3, #32]
 8028710:	f003 0302 	and.w	r3, r3, #2
 8028714:	2b00      	cmp	r3, #0
 8028716:	d004      	beq.n	8028722 <tabview_win_shared_init+0xfa>
 8028718:	488b      	ldr	r0, [pc, #556]	; (8028948 <tabview_win_shared_init+0x320>)
 802871a:	f7fa fce4 	bl	80230e6 <lv_color_hex>
 802871e:	4603      	mov	r3, r0
 8028720:	e003      	b.n	802872a <tabview_win_shared_init+0x102>
 8028722:	488b      	ldr	r0, [pc, #556]	; (8028950 <tabview_win_shared_init+0x328>)
 8028724:	f7fa fcdf 	bl	80230e6 <lv_color_hex>
 8028728:	4603      	mov	r3, r0
 802872a:	461a      	mov	r2, r3
 802872c:	2100      	movs	r1, #0
 802872e:	4620      	mov	r0, r4
 8028730:	f7fb f826 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_font(&styles->tabview_btns_bg, LV_STATE_DEFAULT, theme.font_normal);
 8028734:	4b80      	ldr	r3, [pc, #512]	; (8028938 <tabview_win_shared_init+0x310>)
 8028736:	681b      	ldr	r3, [r3, #0]
 8028738:	33ac      	adds	r3, #172	; 0xac
 802873a:	4a80      	ldr	r2, [pc, #512]	; (802893c <tabview_win_shared_init+0x314>)
 802873c:	6952      	ldr	r2, [r2, #20]
 802873e:	2100      	movs	r1, #0
 8028740:	4618      	mov	r0, r3
 8028742:	f7fb f835 	bl	80237b0 <lv_style_set_text_font>
    lv_style_set_image_recolor(&styles->tabview_btns_bg, LV_STATE_DEFAULT, lv_color_hex(0x979a9f));
 8028746:	4b7c      	ldr	r3, [pc, #496]	; (8028938 <tabview_win_shared_init+0x310>)
 8028748:	681b      	ldr	r3, [r3, #0]
 802874a:	f103 04ac 	add.w	r4, r3, #172	; 0xac
 802874e:	4881      	ldr	r0, [pc, #516]	; (8028954 <tabview_win_shared_init+0x32c>)
 8028750:	f7fa fcc9 	bl	80230e6 <lv_color_hex>
 8028754:	4603      	mov	r3, r0
 8028756:	461a      	mov	r2, r3
 8028758:	2100      	movs	r1, #0
 802875a:	4620      	mov	r0, r4
 802875c:	f7fb f8b6 	bl	80238cc <lv_style_set_image_recolor>
    lv_style_set_pad_top(&styles->tabview_btns_bg, LV_STATE_DEFAULT, LV_DPX(7));
 8028760:	4b75      	ldr	r3, [pc, #468]	; (8028938 <tabview_win_shared_init+0x310>)
 8028762:	681b      	ldr	r3, [r3, #0]
 8028764:	f103 04ac 	add.w	r4, r3, #172	; 0xac
 8028768:	2000      	movs	r0, #0
 802876a:	f7f6 f9d3 	bl	801eb14 <lv_disp_get_dpi>
 802876e:	4603      	mov	r3, r0
 8028770:	461a      	mov	r2, r3
 8028772:	4613      	mov	r3, r2
 8028774:	00db      	lsls	r3, r3, #3
 8028776:	1a9b      	subs	r3, r3, r2
 8028778:	2bef      	cmp	r3, #239	; 0xef
 802877a:	dd10      	ble.n	802879e <tabview_win_shared_init+0x176>
 802877c:	2000      	movs	r0, #0
 802877e:	f7f6 f9c9 	bl	801eb14 <lv_disp_get_dpi>
 8028782:	4603      	mov	r3, r0
 8028784:	461a      	mov	r2, r3
 8028786:	4613      	mov	r3, r2
 8028788:	00db      	lsls	r3, r3, #3
 802878a:	1a9b      	subs	r3, r3, r2
 802878c:	3350      	adds	r3, #80	; 0x50
 802878e:	4a6f      	ldr	r2, [pc, #444]	; (802894c <tabview_win_shared_init+0x324>)
 8028790:	fb82 1203 	smull	r1, r2, r2, r3
 8028794:	1192      	asrs	r2, r2, #6
 8028796:	17db      	asrs	r3, r3, #31
 8028798:	1ad3      	subs	r3, r2, r3
 802879a:	b21b      	sxth	r3, r3
 802879c:	e000      	b.n	80287a0 <tabview_win_shared_init+0x178>
 802879e:	2301      	movs	r3, #1
 80287a0:	461a      	mov	r2, r3
 80287a2:	2100      	movs	r1, #0
 80287a4:	4620      	mov	r0, r4
 80287a6:	f7fa fd44 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_left(&styles->tabview_btns_bg, LV_STATE_DEFAULT, LV_DPX(7));
 80287aa:	4b63      	ldr	r3, [pc, #396]	; (8028938 <tabview_win_shared_init+0x310>)
 80287ac:	681b      	ldr	r3, [r3, #0]
 80287ae:	f103 04ac 	add.w	r4, r3, #172	; 0xac
 80287b2:	2000      	movs	r0, #0
 80287b4:	f7f6 f9ae 	bl	801eb14 <lv_disp_get_dpi>
 80287b8:	4603      	mov	r3, r0
 80287ba:	461a      	mov	r2, r3
 80287bc:	4613      	mov	r3, r2
 80287be:	00db      	lsls	r3, r3, #3
 80287c0:	1a9b      	subs	r3, r3, r2
 80287c2:	2bef      	cmp	r3, #239	; 0xef
 80287c4:	dd10      	ble.n	80287e8 <tabview_win_shared_init+0x1c0>
 80287c6:	2000      	movs	r0, #0
 80287c8:	f7f6 f9a4 	bl	801eb14 <lv_disp_get_dpi>
 80287cc:	4603      	mov	r3, r0
 80287ce:	461a      	mov	r2, r3
 80287d0:	4613      	mov	r3, r2
 80287d2:	00db      	lsls	r3, r3, #3
 80287d4:	1a9b      	subs	r3, r3, r2
 80287d6:	3350      	adds	r3, #80	; 0x50
 80287d8:	4a5c      	ldr	r2, [pc, #368]	; (802894c <tabview_win_shared_init+0x324>)
 80287da:	fb82 1203 	smull	r1, r2, r2, r3
 80287de:	1192      	asrs	r2, r2, #6
 80287e0:	17db      	asrs	r3, r3, #31
 80287e2:	1ad3      	subs	r3, r2, r3
 80287e4:	b21b      	sxth	r3, r3
 80287e6:	e000      	b.n	80287ea <tabview_win_shared_init+0x1c2>
 80287e8:	2301      	movs	r3, #1
 80287ea:	461a      	mov	r2, r3
 80287ec:	2100      	movs	r1, #0
 80287ee:	4620      	mov	r0, r4
 80287f0:	f7fa fd4f 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->tabview_btns_bg, LV_STATE_DEFAULT, LV_DPX(7));
 80287f4:	4b50      	ldr	r3, [pc, #320]	; (8028938 <tabview_win_shared_init+0x310>)
 80287f6:	681b      	ldr	r3, [r3, #0]
 80287f8:	f103 04ac 	add.w	r4, r3, #172	; 0xac
 80287fc:	2000      	movs	r0, #0
 80287fe:	f7f6 f989 	bl	801eb14 <lv_disp_get_dpi>
 8028802:	4603      	mov	r3, r0
 8028804:	461a      	mov	r2, r3
 8028806:	4613      	mov	r3, r2
 8028808:	00db      	lsls	r3, r3, #3
 802880a:	1a9b      	subs	r3, r3, r2
 802880c:	2bef      	cmp	r3, #239	; 0xef
 802880e:	dd10      	ble.n	8028832 <tabview_win_shared_init+0x20a>
 8028810:	2000      	movs	r0, #0
 8028812:	f7f6 f97f 	bl	801eb14 <lv_disp_get_dpi>
 8028816:	4603      	mov	r3, r0
 8028818:	461a      	mov	r2, r3
 802881a:	4613      	mov	r3, r2
 802881c:	00db      	lsls	r3, r3, #3
 802881e:	1a9b      	subs	r3, r3, r2
 8028820:	3350      	adds	r3, #80	; 0x50
 8028822:	4a4a      	ldr	r2, [pc, #296]	; (802894c <tabview_win_shared_init+0x324>)
 8028824:	fb82 1203 	smull	r1, r2, r2, r3
 8028828:	1192      	asrs	r2, r2, #6
 802882a:	17db      	asrs	r3, r3, #31
 802882c:	1ad3      	subs	r3, r2, r3
 802882e:	b21b      	sxth	r3, r3
 8028830:	e000      	b.n	8028834 <tabview_win_shared_init+0x20c>
 8028832:	2301      	movs	r3, #1
 8028834:	461a      	mov	r2, r3
 8028836:	2100      	movs	r1, #0
 8028838:	4620      	mov	r0, r4
 802883a:	f7fa fd42 	bl	80232c2 <lv_style_set_pad_right>

    style_init_reset(&styles->tabview_btns);
 802883e:	4b3e      	ldr	r3, [pc, #248]	; (8028938 <tabview_win_shared_init+0x310>)
 8028840:	681b      	ldr	r3, [r3, #0]
 8028842:	33a8      	adds	r3, #168	; 0xa8
 8028844:	4618      	mov	r0, r3
 8028846:	f000 ffe1 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->tabview_btns, LV_STATE_PRESSED, LV_OPA_50);
 802884a:	4b3b      	ldr	r3, [pc, #236]	; (8028938 <tabview_win_shared_init+0x310>)
 802884c:	681b      	ldr	r3, [r3, #0]
 802884e:	33a8      	adds	r3, #168	; 0xa8
 8028850:	227f      	movs	r2, #127	; 0x7f
 8028852:	2110      	movs	r1, #16
 8028854:	4618      	mov	r0, r3
 8028856:	f7fa fdda 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->tabview_btns, LV_STATE_PRESSED, lv_color_hex3(0x888));
 802885a:	4b37      	ldr	r3, [pc, #220]	; (8028938 <tabview_win_shared_init+0x310>)
 802885c:	681b      	ldr	r3, [r3, #0]
 802885e:	f103 04a8 	add.w	r4, r3, #168	; 0xa8
 8028862:	f640 0088 	movw	r0, #2184	; 0x888
 8028866:	f7fa fc52 	bl	802310e <lv_color_hex3>
 802886a:	4603      	mov	r3, r0
 802886c:	461a      	mov	r2, r3
 802886e:	2110      	movs	r1, #16
 8028870:	4620      	mov	r0, r4
 8028872:	f7fa fdb6 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_text_color(&styles->tabview_btns, LV_STATE_CHECKED, COLOR_SCR_TEXT);
 8028876:	4b30      	ldr	r3, [pc, #192]	; (8028938 <tabview_win_shared_init+0x310>)
 8028878:	681b      	ldr	r3, [r3, #0]
 802887a:	f103 04a8 	add.w	r4, r3, #168	; 0xa8
 802887e:	4b2f      	ldr	r3, [pc, #188]	; (802893c <tabview_win_shared_init+0x314>)
 8028880:	6a1b      	ldr	r3, [r3, #32]
 8028882:	f003 0302 	and.w	r3, r3, #2
 8028886:	2b00      	cmp	r3, #0
 8028888:	d004      	beq.n	8028894 <tabview_win_shared_init+0x26c>
 802888a:	482f      	ldr	r0, [pc, #188]	; (8028948 <tabview_win_shared_init+0x320>)
 802888c:	f7fa fc2b 	bl	80230e6 <lv_color_hex>
 8028890:	4603      	mov	r3, r0
 8028892:	e003      	b.n	802889c <tabview_win_shared_init+0x274>
 8028894:	482e      	ldr	r0, [pc, #184]	; (8028950 <tabview_win_shared_init+0x328>)
 8028896:	f7fa fc26 	bl	80230e6 <lv_color_hex>
 802889a:	4603      	mov	r3, r0
 802889c:	461a      	mov	r2, r3
 802889e:	2101      	movs	r1, #1
 80288a0:	4620      	mov	r0, r4
 80288a2:	f7fa ff6d 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_pad_top(&styles->tabview_btns, LV_STATE_DEFAULT, LV_DPX(20));
 80288a6:	4b24      	ldr	r3, [pc, #144]	; (8028938 <tabview_win_shared_init+0x310>)
 80288a8:	681b      	ldr	r3, [r3, #0]
 80288aa:	f103 04a8 	add.w	r4, r3, #168	; 0xa8
 80288ae:	2000      	movs	r0, #0
 80288b0:	f7f6 f930 	bl	801eb14 <lv_disp_get_dpi>
 80288b4:	4603      	mov	r3, r0
 80288b6:	461a      	mov	r2, r3
 80288b8:	4613      	mov	r3, r2
 80288ba:	009b      	lsls	r3, r3, #2
 80288bc:	4413      	add	r3, r2
 80288be:	009b      	lsls	r3, r3, #2
 80288c0:	2bef      	cmp	r3, #239	; 0xef
 80288c2:	dd11      	ble.n	80288e8 <tabview_win_shared_init+0x2c0>
 80288c4:	2000      	movs	r0, #0
 80288c6:	f7f6 f925 	bl	801eb14 <lv_disp_get_dpi>
 80288ca:	4603      	mov	r3, r0
 80288cc:	461a      	mov	r2, r3
 80288ce:	4613      	mov	r3, r2
 80288d0:	009b      	lsls	r3, r3, #2
 80288d2:	4413      	add	r3, r2
 80288d4:	009b      	lsls	r3, r3, #2
 80288d6:	3350      	adds	r3, #80	; 0x50
 80288d8:	4a1c      	ldr	r2, [pc, #112]	; (802894c <tabview_win_shared_init+0x324>)
 80288da:	fb82 1203 	smull	r1, r2, r2, r3
 80288de:	1192      	asrs	r2, r2, #6
 80288e0:	17db      	asrs	r3, r3, #31
 80288e2:	1ad3      	subs	r3, r2, r3
 80288e4:	b21b      	sxth	r3, r3
 80288e6:	e000      	b.n	80288ea <tabview_win_shared_init+0x2c2>
 80288e8:	2301      	movs	r3, #1
 80288ea:	461a      	mov	r2, r3
 80288ec:	2100      	movs	r1, #0
 80288ee:	4620      	mov	r0, r4
 80288f0:	f7fa fc9f 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->tabview_btns, LV_STATE_DEFAULT, LV_DPX(20));
 80288f4:	4b10      	ldr	r3, [pc, #64]	; (8028938 <tabview_win_shared_init+0x310>)
 80288f6:	681b      	ldr	r3, [r3, #0]
 80288f8:	f103 04a8 	add.w	r4, r3, #168	; 0xa8
 80288fc:	2000      	movs	r0, #0
 80288fe:	f7f6 f909 	bl	801eb14 <lv_disp_get_dpi>
 8028902:	4603      	mov	r3, r0
 8028904:	461a      	mov	r2, r3
 8028906:	4613      	mov	r3, r2
 8028908:	009b      	lsls	r3, r3, #2
 802890a:	4413      	add	r3, r2
 802890c:	009b      	lsls	r3, r3, #2
 802890e:	2bef      	cmp	r3, #239	; 0xef
 8028910:	dd22      	ble.n	8028958 <tabview_win_shared_init+0x330>
 8028912:	2000      	movs	r0, #0
 8028914:	f7f6 f8fe 	bl	801eb14 <lv_disp_get_dpi>
 8028918:	4603      	mov	r3, r0
 802891a:	461a      	mov	r2, r3
 802891c:	4613      	mov	r3, r2
 802891e:	009b      	lsls	r3, r3, #2
 8028920:	4413      	add	r3, r2
 8028922:	009b      	lsls	r3, r3, #2
 8028924:	3350      	adds	r3, #80	; 0x50
 8028926:	4a09      	ldr	r2, [pc, #36]	; (802894c <tabview_win_shared_init+0x324>)
 8028928:	fb82 1203 	smull	r1, r2, r2, r3
 802892c:	1192      	asrs	r2, r2, #6
 802892e:	17db      	asrs	r3, r3, #31
 8028930:	1ad3      	subs	r3, r2, r3
 8028932:	b21b      	sxth	r3, r3
 8028934:	e011      	b.n	802895a <tabview_win_shared_init+0x332>
 8028936:	bf00      	nop
 8028938:	20012350 	.word	0x20012350
 802893c:	20012328 	.word	0x20012328
 8028940:	00586273 	.word	0x00586273
 8028944:	00e4eaf0 	.word	0x00e4eaf0
 8028948:	003b3e42 	.word	0x003b3e42
 802894c:	66666667 	.word	0x66666667
 8028950:	00e7e9ec 	.word	0x00e7e9ec
 8028954:	00979a9f 	.word	0x00979a9f
 8028958:	2301      	movs	r3, #1
 802895a:	461a      	mov	r2, r3
 802895c:	2100      	movs	r1, #0
 802895e:	4620      	mov	r0, r4
 8028960:	f7fa fc7f 	bl	8023262 <lv_style_set_pad_bottom>
    lv_style_set_text_color(&styles->tabview_btns, LV_STATE_FOCUSED, theme.color_primary);
 8028964:	4bc3      	ldr	r3, [pc, #780]	; (8028c74 <tabview_win_shared_init+0x64c>)
 8028966:	681b      	ldr	r3, [r3, #0]
 8028968:	33a8      	adds	r3, #168	; 0xa8
 802896a:	4ac3      	ldr	r2, [pc, #780]	; (8028c78 <tabview_win_shared_init+0x650>)
 802896c:	8992      	ldrh	r2, [r2, #12]
 802896e:	2102      	movs	r1, #2
 8028970:	4618      	mov	r0, r3
 8028972:	f7fa ff05 	bl	8023780 <lv_style_set_text_color>
    lv_style_set_text_color(&styles->tabview_btns, LV_STATE_EDITED, theme.color_secondary);
 8028976:	4bbf      	ldr	r3, [pc, #764]	; (8028c74 <tabview_win_shared_init+0x64c>)
 8028978:	681b      	ldr	r3, [r3, #0]
 802897a:	33a8      	adds	r3, #168	; 0xa8
 802897c:	4abe      	ldr	r2, [pc, #760]	; (8028c78 <tabview_win_shared_init+0x650>)
 802897e:	89d2      	ldrh	r2, [r2, #14]
 8028980:	2104      	movs	r1, #4
 8028982:	4618      	mov	r0, r3
 8028984:	f7fa fefc 	bl	8023780 <lv_style_set_text_color>

    style_init_reset(&styles->tabview_indic);
 8028988:	4bba      	ldr	r3, [pc, #744]	; (8028c74 <tabview_win_shared_init+0x64c>)
 802898a:	681b      	ldr	r3, [r3, #0]
 802898c:	33b0      	adds	r3, #176	; 0xb0
 802898e:	4618      	mov	r0, r3
 8028990:	f000 ff3c 	bl	802980c <style_init_reset>
    lv_style_set_bg_opa(&styles->tabview_indic, LV_STATE_DEFAULT, LV_OPA_COVER);
 8028994:	4bb7      	ldr	r3, [pc, #732]	; (8028c74 <tabview_win_shared_init+0x64c>)
 8028996:	681b      	ldr	r3, [r3, #0]
 8028998:	33b0      	adds	r3, #176	; 0xb0
 802899a:	22ff      	movs	r2, #255	; 0xff
 802899c:	2100      	movs	r1, #0
 802899e:	4618      	mov	r0, r3
 80289a0:	f7fa fd35 	bl	802340e <lv_style_set_bg_opa>
    lv_style_set_bg_color(&styles->tabview_indic, LV_STATE_DEFAULT, theme.color_primary);
 80289a4:	4bb3      	ldr	r3, [pc, #716]	; (8028c74 <tabview_win_shared_init+0x64c>)
 80289a6:	681b      	ldr	r3, [r3, #0]
 80289a8:	33b0      	adds	r3, #176	; 0xb0
 80289aa:	4ab3      	ldr	r2, [pc, #716]	; (8028c78 <tabview_win_shared_init+0x650>)
 80289ac:	8992      	ldrh	r2, [r2, #12]
 80289ae:	2100      	movs	r1, #0
 80289b0:	4618      	mov	r0, r3
 80289b2:	f7fa fd16 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_bg_color(&styles->tabview_indic, LV_STATE_EDITED, theme.color_secondary);
 80289b6:	4baf      	ldr	r3, [pc, #700]	; (8028c74 <tabview_win_shared_init+0x64c>)
 80289b8:	681b      	ldr	r3, [r3, #0]
 80289ba:	33b0      	adds	r3, #176	; 0xb0
 80289bc:	4aae      	ldr	r2, [pc, #696]	; (8028c78 <tabview_win_shared_init+0x650>)
 80289be:	89d2      	ldrh	r2, [r2, #14]
 80289c0:	2104      	movs	r1, #4
 80289c2:	4618      	mov	r0, r3
 80289c4:	f7fa fd0d 	bl	80233e2 <lv_style_set_bg_color>
    lv_style_set_size(&styles->tabview_indic, LV_STATE_DEFAULT, LV_DPX(5));
 80289c8:	4baa      	ldr	r3, [pc, #680]	; (8028c74 <tabview_win_shared_init+0x64c>)
 80289ca:	681b      	ldr	r3, [r3, #0]
 80289cc:	f103 04b0 	add.w	r4, r3, #176	; 0xb0
 80289d0:	2000      	movs	r0, #0
 80289d2:	f7f6 f89f 	bl	801eb14 <lv_disp_get_dpi>
 80289d6:	4603      	mov	r3, r0
 80289d8:	461a      	mov	r2, r3
 80289da:	4613      	mov	r3, r2
 80289dc:	009b      	lsls	r3, r3, #2
 80289de:	4413      	add	r3, r2
 80289e0:	2bef      	cmp	r3, #239	; 0xef
 80289e2:	dd10      	ble.n	8028a06 <tabview_win_shared_init+0x3de>
 80289e4:	2000      	movs	r0, #0
 80289e6:	f7f6 f895 	bl	801eb14 <lv_disp_get_dpi>
 80289ea:	4603      	mov	r3, r0
 80289ec:	461a      	mov	r2, r3
 80289ee:	4613      	mov	r3, r2
 80289f0:	009b      	lsls	r3, r3, #2
 80289f2:	4413      	add	r3, r2
 80289f4:	3350      	adds	r3, #80	; 0x50
 80289f6:	4aa1      	ldr	r2, [pc, #644]	; (8028c7c <tabview_win_shared_init+0x654>)
 80289f8:	fb82 1203 	smull	r1, r2, r2, r3
 80289fc:	1192      	asrs	r2, r2, #6
 80289fe:	17db      	asrs	r3, r3, #31
 8028a00:	1ad3      	subs	r3, r2, r3
 8028a02:	b21b      	sxth	r3, r3
 8028a04:	e000      	b.n	8028a08 <tabview_win_shared_init+0x3e0>
 8028a06:	2301      	movs	r3, #1
 8028a08:	461a      	mov	r2, r3
 8028a0a:	2100      	movs	r1, #0
 8028a0c:	4620      	mov	r0, r4
 8028a0e:	f7fa fbe0 	bl	80231d2 <lv_style_set_size>
    lv_style_set_radius(&styles->tabview_indic, LV_STATE_DEFAULT, LV_RADIUS_CIRCLE);
 8028a12:	4b98      	ldr	r3, [pc, #608]	; (8028c74 <tabview_win_shared_init+0x64c>)
 8028a14:	681b      	ldr	r3, [r3, #0]
 8028a16:	33b0      	adds	r3, #176	; 0xb0
 8028a18:	f647 72ff 	movw	r2, #32767	; 0x7fff
 8028a1c:	2100      	movs	r1, #0
 8028a1e:	4618      	mov	r0, r3
 8028a20:	f7fa fba7 	bl	8023172 <lv_style_set_radius>

    style_init_reset(&styles->tabview_page_scrl);
 8028a24:	4b93      	ldr	r3, [pc, #588]	; (8028c74 <tabview_win_shared_init+0x64c>)
 8028a26:	681b      	ldr	r3, [r3, #0]
 8028a28:	33b4      	adds	r3, #180	; 0xb4
 8028a2a:	4618      	mov	r0, r3
 8028a2c:	f000 feee 	bl	802980c <style_init_reset>
    lv_style_set_pad_top(&styles->tabview_page_scrl, LV_STATE_DEFAULT, PAD_DEF);
 8028a30:	4b90      	ldr	r3, [pc, #576]	; (8028c74 <tabview_win_shared_init+0x64c>)
 8028a32:	681b      	ldr	r3, [r3, #0]
 8028a34:	f103 04b4 	add.w	r4, r3, #180	; 0xb4
 8028a38:	2000      	movs	r0, #0
 8028a3a:	f7f6 f884 	bl	801eb46 <lv_disp_get_size_category>
 8028a3e:	4603      	mov	r3, r0
 8028a40:	2b01      	cmp	r3, #1
 8028a42:	d81c      	bhi.n	8028a7e <tabview_win_shared_init+0x456>
 8028a44:	2000      	movs	r0, #0
 8028a46:	f7f6 f865 	bl	801eb14 <lv_disp_get_dpi>
 8028a4a:	4603      	mov	r3, r0
 8028a4c:	461a      	mov	r2, r3
 8028a4e:	4613      	mov	r3, r2
 8028a50:	011b      	lsls	r3, r3, #4
 8028a52:	1a9b      	subs	r3, r3, r2
 8028a54:	2bef      	cmp	r3, #239	; 0xef
 8028a56:	dd10      	ble.n	8028a7a <tabview_win_shared_init+0x452>
 8028a58:	2000      	movs	r0, #0
 8028a5a:	f7f6 f85b 	bl	801eb14 <lv_disp_get_dpi>
 8028a5e:	4603      	mov	r3, r0
 8028a60:	461a      	mov	r2, r3
 8028a62:	4613      	mov	r3, r2
 8028a64:	011b      	lsls	r3, r3, #4
 8028a66:	1a9b      	subs	r3, r3, r2
 8028a68:	3350      	adds	r3, #80	; 0x50
 8028a6a:	4a84      	ldr	r2, [pc, #528]	; (8028c7c <tabview_win_shared_init+0x654>)
 8028a6c:	fb82 1203 	smull	r1, r2, r2, r3
 8028a70:	1192      	asrs	r2, r2, #6
 8028a72:	17db      	asrs	r3, r3, #31
 8028a74:	1ad3      	subs	r3, r2, r3
 8028a76:	b21b      	sxth	r3, r3
 8028a78:	e01f      	b.n	8028aba <tabview_win_shared_init+0x492>
 8028a7a:	2301      	movs	r3, #1
 8028a7c:	e01d      	b.n	8028aba <tabview_win_shared_init+0x492>
 8028a7e:	2000      	movs	r0, #0
 8028a80:	f7f6 f848 	bl	801eb14 <lv_disp_get_dpi>
 8028a84:	4603      	mov	r3, r0
 8028a86:	461a      	mov	r2, r3
 8028a88:	4613      	mov	r3, r2
 8028a8a:	011b      	lsls	r3, r3, #4
 8028a8c:	1a9b      	subs	r3, r3, r2
 8028a8e:	005b      	lsls	r3, r3, #1
 8028a90:	2bef      	cmp	r3, #239	; 0xef
 8028a92:	dd11      	ble.n	8028ab8 <tabview_win_shared_init+0x490>
 8028a94:	2000      	movs	r0, #0
 8028a96:	f7f6 f83d 	bl	801eb14 <lv_disp_get_dpi>
 8028a9a:	4603      	mov	r3, r0
 8028a9c:	461a      	mov	r2, r3
 8028a9e:	4613      	mov	r3, r2
 8028aa0:	011b      	lsls	r3, r3, #4
 8028aa2:	1a9b      	subs	r3, r3, r2
 8028aa4:	005b      	lsls	r3, r3, #1
 8028aa6:	3350      	adds	r3, #80	; 0x50
 8028aa8:	4a74      	ldr	r2, [pc, #464]	; (8028c7c <tabview_win_shared_init+0x654>)
 8028aaa:	fb82 1203 	smull	r1, r2, r2, r3
 8028aae:	1192      	asrs	r2, r2, #6
 8028ab0:	17db      	asrs	r3, r3, #31
 8028ab2:	1ad3      	subs	r3, r2, r3
 8028ab4:	b21b      	sxth	r3, r3
 8028ab6:	e000      	b.n	8028aba <tabview_win_shared_init+0x492>
 8028ab8:	2301      	movs	r3, #1
 8028aba:	461a      	mov	r2, r3
 8028abc:	2100      	movs	r1, #0
 8028abe:	4620      	mov	r0, r4
 8028ac0:	f7fa fbb7 	bl	8023232 <lv_style_set_pad_top>
    lv_style_set_pad_bottom(&styles->tabview_page_scrl, LV_STATE_DEFAULT, PAD_DEF);
 8028ac4:	4b6b      	ldr	r3, [pc, #428]	; (8028c74 <tabview_win_shared_init+0x64c>)
 8028ac6:	681b      	ldr	r3, [r3, #0]
 8028ac8:	f103 04b4 	add.w	r4, r3, #180	; 0xb4
 8028acc:	2000      	movs	r0, #0
 8028ace:	f7f6 f83a 	bl	801eb46 <lv_disp_get_size_category>
 8028ad2:	4603      	mov	r3, r0
 8028ad4:	2b01      	cmp	r3, #1
 8028ad6:	d81c      	bhi.n	8028b12 <tabview_win_shared_init+0x4ea>
 8028ad8:	2000      	movs	r0, #0
 8028ada:	f7f6 f81b 	bl	801eb14 <lv_disp_get_dpi>
 8028ade:	4603      	mov	r3, r0
 8028ae0:	461a      	mov	r2, r3
 8028ae2:	4613      	mov	r3, r2
 8028ae4:	011b      	lsls	r3, r3, #4
 8028ae6:	1a9b      	subs	r3, r3, r2
 8028ae8:	2bef      	cmp	r3, #239	; 0xef
 8028aea:	dd10      	ble.n	8028b0e <tabview_win_shared_init+0x4e6>
 8028aec:	2000      	movs	r0, #0
 8028aee:	f7f6 f811 	bl	801eb14 <lv_disp_get_dpi>
 8028af2:	4603      	mov	r3, r0
 8028af4:	461a      	mov	r2, r3
 8028af6:	4613      	mov	r3, r2
 8028af8:	011b      	lsls	r3, r3, #4
 8028afa:	1a9b      	subs	r3, r3, r2
 8028afc:	3350      	adds	r3, #80	; 0x50
 8028afe:	4a5f      	ldr	r2, [pc, #380]	; (8028c7c <tabview_win_shared_init+0x654>)
 8028b00:	fb82 1203 	smull	r1, r2, r2, r3
 8028b04:	1192      	asrs	r2, r2, #6
 8028b06:	17db      	asrs	r3, r3, #31
 8028b08:	1ad3      	subs	r3, r2, r3
 8028b0a:	b21b      	sxth	r3, r3
 8028b0c:	e01f      	b.n	8028b4e <tabview_win_shared_init+0x526>
 8028b0e:	2301      	movs	r3, #1
 8028b10:	e01d      	b.n	8028b4e <tabview_win_shared_init+0x526>
 8028b12:	2000      	movs	r0, #0
 8028b14:	f7f5 fffe 	bl	801eb14 <lv_disp_get_dpi>
 8028b18:	4603      	mov	r3, r0
 8028b1a:	461a      	mov	r2, r3
 8028b1c:	4613      	mov	r3, r2
 8028b1e:	011b      	lsls	r3, r3, #4
 8028b20:	1a9b      	subs	r3, r3, r2
 8028b22:	005b      	lsls	r3, r3, #1
 8028b24:	2bef      	cmp	r3, #239	; 0xef
 8028b26:	dd11      	ble.n	8028b4c <tabview_win_shared_init+0x524>
 8028b28:	2000      	movs	r0, #0
 8028b2a:	f7f5 fff3 	bl	801eb14 <lv_disp_get_dpi>
 8028b2e:	4603      	mov	r3, r0
 8028b30:	461a      	mov	r2, r3
 8028b32:	4613      	mov	r3, r2
 8028b34:	011b      	lsls	r3, r3, #4
 8028b36:	1a9b      	subs	r3, r3, r2
 8028b38:	005b      	lsls	r3, r3, #1
 8028b3a:	3350      	adds	r3, #80	; 0x50
 8028b3c:	4a4f      	ldr	r2, [pc, #316]	; (8028c7c <tabview_win_shared_init+0x654>)
 8028b3e:	fb82 1203 	smull	r1, r2, r2, r3
 8028b42:	1192      	asrs	r2, r2, #6
 8028b44:	17db      	asrs	r3, r3, #31
 8028b46:	1ad3      	subs	r3, r2, r3
 8028b48:	b21b      	sxth	r3, r3
 8028b4a:	e000      	b.n	8028b4e <tabview_win_shared_init+0x526>
 8028b4c:	2301      	movs	r3, #1
 8028b4e:	461a      	mov	r2, r3
 8028b50:	2100      	movs	r1, #0
 8028b52:	4620      	mov	r0, r4
 8028b54:	f7fa fb85 	bl	8023262 <lv_style_set_pad_bottom>
    lv_style_set_pad_left(&styles->tabview_page_scrl, LV_STATE_DEFAULT, PAD_DEF);
 8028b58:	4b46      	ldr	r3, [pc, #280]	; (8028c74 <tabview_win_shared_init+0x64c>)
 8028b5a:	681b      	ldr	r3, [r3, #0]
 8028b5c:	f103 04b4 	add.w	r4, r3, #180	; 0xb4
 8028b60:	2000      	movs	r0, #0
 8028b62:	f7f5 fff0 	bl	801eb46 <lv_disp_get_size_category>
 8028b66:	4603      	mov	r3, r0
 8028b68:	2b01      	cmp	r3, #1
 8028b6a:	d81c      	bhi.n	8028ba6 <tabview_win_shared_init+0x57e>
 8028b6c:	2000      	movs	r0, #0
 8028b6e:	f7f5 ffd1 	bl	801eb14 <lv_disp_get_dpi>
 8028b72:	4603      	mov	r3, r0
 8028b74:	461a      	mov	r2, r3
 8028b76:	4613      	mov	r3, r2
 8028b78:	011b      	lsls	r3, r3, #4
 8028b7a:	1a9b      	subs	r3, r3, r2
 8028b7c:	2bef      	cmp	r3, #239	; 0xef
 8028b7e:	dd10      	ble.n	8028ba2 <tabview_win_shared_init+0x57a>
 8028b80:	2000      	movs	r0, #0
 8028b82:	f7f5 ffc7 	bl	801eb14 <lv_disp_get_dpi>
 8028b86:	4603      	mov	r3, r0
 8028b88:	461a      	mov	r2, r3
 8028b8a:	4613      	mov	r3, r2
 8028b8c:	011b      	lsls	r3, r3, #4
 8028b8e:	1a9b      	subs	r3, r3, r2
 8028b90:	3350      	adds	r3, #80	; 0x50
 8028b92:	4a3a      	ldr	r2, [pc, #232]	; (8028c7c <tabview_win_shared_init+0x654>)
 8028b94:	fb82 1203 	smull	r1, r2, r2, r3
 8028b98:	1192      	asrs	r2, r2, #6
 8028b9a:	17db      	asrs	r3, r3, #31
 8028b9c:	1ad3      	subs	r3, r2, r3
 8028b9e:	b21b      	sxth	r3, r3
 8028ba0:	e01f      	b.n	8028be2 <tabview_win_shared_init+0x5ba>
 8028ba2:	2301      	movs	r3, #1
 8028ba4:	e01d      	b.n	8028be2 <tabview_win_shared_init+0x5ba>
 8028ba6:	2000      	movs	r0, #0
 8028ba8:	f7f5 ffb4 	bl	801eb14 <lv_disp_get_dpi>
 8028bac:	4603      	mov	r3, r0
 8028bae:	461a      	mov	r2, r3
 8028bb0:	4613      	mov	r3, r2
 8028bb2:	011b      	lsls	r3, r3, #4
 8028bb4:	1a9b      	subs	r3, r3, r2
 8028bb6:	005b      	lsls	r3, r3, #1
 8028bb8:	2bef      	cmp	r3, #239	; 0xef
 8028bba:	dd11      	ble.n	8028be0 <tabview_win_shared_init+0x5b8>
 8028bbc:	2000      	movs	r0, #0
 8028bbe:	f7f5 ffa9 	bl	801eb14 <lv_disp_get_dpi>
 8028bc2:	4603      	mov	r3, r0
 8028bc4:	461a      	mov	r2, r3
 8028bc6:	4613      	mov	r3, r2
 8028bc8:	011b      	lsls	r3, r3, #4
 8028bca:	1a9b      	subs	r3, r3, r2
 8028bcc:	005b      	lsls	r3, r3, #1
 8028bce:	3350      	adds	r3, #80	; 0x50
 8028bd0:	4a2a      	ldr	r2, [pc, #168]	; (8028c7c <tabview_win_shared_init+0x654>)
 8028bd2:	fb82 1203 	smull	r1, r2, r2, r3
 8028bd6:	1192      	asrs	r2, r2, #6
 8028bd8:	17db      	asrs	r3, r3, #31
 8028bda:	1ad3      	subs	r3, r2, r3
 8028bdc:	b21b      	sxth	r3, r3
 8028bde:	e000      	b.n	8028be2 <tabview_win_shared_init+0x5ba>
 8028be0:	2301      	movs	r3, #1
 8028be2:	461a      	mov	r2, r3
 8028be4:	2100      	movs	r1, #0
 8028be6:	4620      	mov	r0, r4
 8028be8:	f7fa fb53 	bl	8023292 <lv_style_set_pad_left>
    lv_style_set_pad_right(&styles->tabview_page_scrl, LV_STATE_DEFAULT, PAD_DEF);
 8028bec:	4b21      	ldr	r3, [pc, #132]	; (8028c74 <tabview_win_shared_init+0x64c>)
 8028bee:	681b      	ldr	r3, [r3, #0]
 8028bf0:	f103 04b4 	add.w	r4, r3, #180	; 0xb4
 8028bf4:	2000      	movs	r0, #0
 8028bf6:	f7f5 ffa6 	bl	801eb46 <lv_disp_get_size_category>
 8028bfa:	4603      	mov	r3, r0
 8028bfc:	2b01      	cmp	r3, #1
 8028bfe:	d81c      	bhi.n	8028c3a <tabview_win_shared_init+0x612>
 8028c00:	2000      	movs	r0, #0
 8028c02:	f7f5 ff87 	bl	801eb14 <lv_disp_get_dpi>
 8028c06:	4603      	mov	r3, r0
 8028c08:	461a      	mov	r2, r3
 8028c0a:	4613      	mov	r3, r2
 8028c0c:	011b      	lsls	r3, r3, #4
 8028c0e:	1a9b      	subs	r3, r3, r2
 8028c10:	2bef      	cmp	r3, #239	; 0xef
 8028c12:	dd10      	ble.n	8028c36 <tabview_win_shared_init+0x60e>
 8028c14:	2000      	movs	r0, #0
 8028c16:	f7f5 ff7d 	bl	801eb14 <lv_disp_get_dpi>
 8028c1a:	4603      	mov	r3, r0
 8028c1c:	461a      	mov	r2, r3
 8028c1e:	4613      	mov	r3, r2
 8028c20:	011b      	lsls	r3, r3, #4
 8028c22:	1a9b      	subs	r3, r3, r2
 8028c24:	3350      	adds	r3, #80	; 0x50
 8028c26:	4a15      	ldr	r2, [pc, #84]	; (8028c7c <tabview_win_shared_init+0x654>)
 8028c28:	fb82 1203 	smull	r1, r2, r2, r3
 8028c2c:	1192      	asrs	r2, r2, #6
 8028c2e:	17db      	asrs	r3, r3, #31
 8028c30:	1ad3      	subs	r3, r2, r3
 8028c32:	b21b      	sxth	r3, r3
 8028c34:	e025      	b.n	8028c82 <tabview_win_shared_init+0x65a>
 8028c36:	2301      	movs	r3, #1
 8028c38:	e023      	b.n	8028c82 <tabview_win_shared_init+0x65a>
 8028c3a:	2000      	movs	r0, #0
 8028c3c:	f7f5 ff6a 	bl	801eb14 <lv_disp_get_dpi>
 8028c40:	4603      	mov	r3, r0
 8028c42:	461a      	mov	r2, r3
 8028c44:	4613      	mov	r3, r2
 8028c46:	011b      	lsls	r3, r3, #4
 8028c48:	1a9b      	subs	r3, r3, r2
 8028c4a:	005b      	lsls	r3, r3, #1
 8028c4c:	2bef      	cmp	r3, #239	; 0xef
 8028c4e:	dd17      	ble.n	8028c80 <tabview_win_shared_init+0x658>
 8028c50:	2000      	movs	r0, #0
 8028c52:	f7f5 ff5f 	bl	801eb14 <lv_disp_get_dpi>
 8028c56:	4603      	mov	r3, r0
 8028c58:	461a      	mov	r2, r3
 8028c5a:	4613      	mov	r3, r2
 8028c5c:	011b      	lsls	r3, r3, #4
 8028c5e:	1a9b      	subs	r3, r3, r2
 8028c60:	005b      	lsls	r3, r3, #1
 8028c62:	3350      	adds	r3, #80	; 0x50
 8028c64:	4a05      	ldr	r2, [pc, #20]	; (8028c7c <tabview_win_shared_init+0x654>)
 8028c66:	fb82 1203 	smull	r1, r2, r2, r3
 8028c6a:	1192      	asrs	r2, r2, #6
 8028c6c:	17db      	asrs	r3, r3, #31
 8028c6e:	1ad3      	subs	r3, r2, r3
 8028c70:	b21b      	sxth	r3, r3
 8028c72:	e006      	b.n	8028c82 <tabview_win_shared_init+0x65a>
 8028c74:	20012350 	.word	0x20012350
 8028c78:	20012328 	.word	0x20012328
 8028c7c:	66666667 	.word	0x66666667
 8028c80:	2301      	movs	r3, #1
 8028c82:	461a      	mov	r2, r3
 8028c84:	2100      	movs	r1, #0
 8028c86:	4620      	mov	r0, r4
 8028c88:	f7fa fb1b 	bl	80232c2 <lv_style_set_pad_right>
    lv_style_set_pad_inner(&styles->tabview_page_scrl, LV_STATE_DEFAULT, PAD_DEF);
 8028c8c:	4b25      	ldr	r3, [pc, #148]	; (8028d24 <tabview_win_shared_init+0x6fc>)
 8028c8e:	681b      	ldr	r3, [r3, #0]
 8028c90:	f103 04b4 	add.w	r4, r3, #180	; 0xb4
 8028c94:	2000      	movs	r0, #0
 8028c96:	f7f5 ff56 	bl	801eb46 <lv_disp_get_size_category>
 8028c9a:	4603      	mov	r3, r0
 8028c9c:	2b01      	cmp	r3, #1
 8028c9e:	d81c      	bhi.n	8028cda <tabview_win_shared_init+0x6b2>
 8028ca0:	2000      	movs	r0, #0
 8028ca2:	f7f5 ff37 	bl	801eb14 <lv_disp_get_dpi>
 8028ca6:	4603      	mov	r3, r0
 8028ca8:	461a      	mov	r2, r3
 8028caa:	4613      	mov	r3, r2
 8028cac:	011b      	lsls	r3, r3, #4
 8028cae:	1a9b      	subs	r3, r3, r2
 8028cb0:	2bef      	cmp	r3, #239	; 0xef
 8028cb2:	dd10      	ble.n	8028cd6 <tabview_win_shared_init+0x6ae>
 8028cb4:	2000      	movs	r0, #0
 8028cb6:	f7f5 ff2d 	bl	801eb14 <lv_disp_get_dpi>
 8028cba:	4603      	mov	r3, r0
 8028cbc:	461a      	mov	r2, r3
 8028cbe:	4613      	mov	r3, r2
 8028cc0:	011b      	lsls	r3, r3, #4
 8028cc2:	1a9b      	subs	r3, r3, r2
 8028cc4:	3350      	adds	r3, #80	; 0x50
 8028cc6:	4a18      	ldr	r2, [pc, #96]	; (8028d28 <tabview_win_shared_init+0x700>)
 8028cc8:	fb82 1203 	smull	r1, r2, r2, r3
 8028ccc:	1192      	asrs	r2, r2, #6
 8028cce:	17db      	asrs	r3, r3, #31
 8028cd0:	1ad3      	subs	r3, r2, r3
 8028cd2:	b21b      	sxth	r3, r3
 8028cd4:	e01f      	b.n	8028d16 <tabview_win_shared_init+0x6ee>
 8028cd6:	2301      	movs	r3, #1
 8028cd8:	e01d      	b.n	8028d16 <tabview_win_shared_init+0x6ee>
 8028cda:	2000      	movs	r0, #0
 8028cdc:	f7f5 ff1a 	bl	801eb14 <lv_disp_get_dpi>
 8028ce0:	4603      	mov	r3, r0
 8028ce2:	461a      	mov	r2, r3
 8028ce4:	4613      	mov	r3, r2
 8028ce6:	011b      	lsls	r3, r3, #4
 8028ce8:	1a9b      	subs	r3, r3, r2
 8028cea:	005b      	lsls	r3, r3, #1
 8028cec:	2bef      	cmp	r3, #239	; 0xef
 8028cee:	dd11      	ble.n	8028d14 <tabview_win_shared_init+0x6ec>
 8028cf0:	2000      	movs	r0, #0
 8028cf2:	f7f5 ff0f 	bl	801eb14 <lv_disp_get_dpi>
 8028cf6:	4603      	mov	r3, r0
 8028cf8:	461a      	mov	r2, r3
 8028cfa:	4613      	mov	r3, r2
 8028cfc:	011b      	lsls	r3, r3, #4
 8028cfe:	1a9b      	subs	r3, r3, r2
 8028d00:	005b      	lsls	r3, r3, #1
 8028d02:	3350      	adds	r3, #80	; 0x50
 8028d04:	4a08      	ldr	r2, [pc, #32]	; (8028d28 <tabview_win_shared_init+0x700>)
 8028d06:	fb82 1203 	smull	r1, r2, r2, r3
 8028d0a:	1192      	asrs	r2, r2, #6
 8028d0c:	17db      	asrs	r3, r3, #31
 8028d0e:	1ad3      	subs	r3, r2, r3
 8028d10:	b21b      	sxth	r3, r3
 8028d12:	e000      	b.n	8028d16 <tabview_win_shared_init+0x6ee>
 8028d14:	2301      	movs	r3, #1
 8028d16:	461a      	mov	r2, r3
 8028d18:	2100      	movs	r1, #0
 8028d1a:	4620      	mov	r0, r4
 8028d1c:	f7fa fae9 	bl	80232f2 <lv_style_set_pad_inner>
#endif
}
 8028d20:	bf00      	nop
 8028d22:	bd98      	pop	{r3, r4, r7, pc}
 8028d24:	20012350 	.word	0x20012350
 8028d28:	66666667 	.word	0x66666667

08028d2c <lv_theme_material_init>:
 * @return a pointer to reference this theme later
 */
lv_theme_t * lv_theme_material_init(lv_color_t color_primary, lv_color_t color_secondary, uint32_t flags,
                                    const lv_font_t * font_small, const lv_font_t * font_normal, const lv_font_t * font_subtitle,
                                    const lv_font_t * font_title)
{
 8028d2c:	b580      	push	{r7, lr}
 8028d2e:	b084      	sub	sp, #16
 8028d30:	af00      	add	r7, sp, #0
 8028d32:	81b8      	strh	r0, [r7, #12]
 8028d34:	8139      	strh	r1, [r7, #8]
 8028d36:	607a      	str	r2, [r7, #4]
 8028d38:	603b      	str	r3, [r7, #0]

    /* This trick is required only to avoid the garbage collection of
     * styles' data if LVGL is used in a binding (e.g. Micropython)
     * In a general case styles could be simple `static lv_style_t my style` variables*/
    if(!inited) {
 8028d3a:	4b3b      	ldr	r3, [pc, #236]	; (8028e28 <lv_theme_material_init+0xfc>)
 8028d3c:	781b      	ldrb	r3, [r3, #0]
 8028d3e:	f083 0301 	eor.w	r3, r3, #1
 8028d42:	b2db      	uxtb	r3, r3
 8028d44:	2b00      	cmp	r3, #0
 8028d46:	d009      	beq.n	8028d5c <lv_theme_material_init+0x30>
        LV_GC_ROOT(_lv_theme_material_styles) = lv_mem_alloc(sizeof(theme_styles_t));
 8028d48:	20c0      	movs	r0, #192	; 0xc0
 8028d4a:	f7f7 ff43 	bl	8020bd4 <lv_mem_alloc>
 8028d4e:	4603      	mov	r3, r0
 8028d50:	4a36      	ldr	r2, [pc, #216]	; (8028e2c <lv_theme_material_init+0x100>)
 8028d52:	6013      	str	r3, [r2, #0]
        styles = (theme_styles_t *)LV_GC_ROOT(_lv_theme_material_styles);
 8028d54:	4b35      	ldr	r3, [pc, #212]	; (8028e2c <lv_theme_material_init+0x100>)
 8028d56:	681b      	ldr	r3, [r3, #0]
 8028d58:	4a35      	ldr	r2, [pc, #212]	; (8028e30 <lv_theme_material_init+0x104>)
 8028d5a:	6013      	str	r3, [r2, #0]
    }

    theme.color_primary = color_primary;
 8028d5c:	4a35      	ldr	r2, [pc, #212]	; (8028e34 <lv_theme_material_init+0x108>)
 8028d5e:	89bb      	ldrh	r3, [r7, #12]
 8028d60:	8193      	strh	r3, [r2, #12]
    theme.color_secondary = color_secondary;
 8028d62:	4a34      	ldr	r2, [pc, #208]	; (8028e34 <lv_theme_material_init+0x108>)
 8028d64:	893b      	ldrh	r3, [r7, #8]
 8028d66:	81d3      	strh	r3, [r2, #14]
    theme.font_small = font_small;
 8028d68:	4a32      	ldr	r2, [pc, #200]	; (8028e34 <lv_theme_material_init+0x108>)
 8028d6a:	683b      	ldr	r3, [r7, #0]
 8028d6c:	6113      	str	r3, [r2, #16]
    theme.font_normal = font_normal;
 8028d6e:	4a31      	ldr	r2, [pc, #196]	; (8028e34 <lv_theme_material_init+0x108>)
 8028d70:	69bb      	ldr	r3, [r7, #24]
 8028d72:	6153      	str	r3, [r2, #20]
    theme.font_subtitle = font_subtitle;
 8028d74:	4a2f      	ldr	r2, [pc, #188]	; (8028e34 <lv_theme_material_init+0x108>)
 8028d76:	69fb      	ldr	r3, [r7, #28]
 8028d78:	6193      	str	r3, [r2, #24]
    theme.font_title = font_title;
 8028d7a:	4a2e      	ldr	r2, [pc, #184]	; (8028e34 <lv_theme_material_init+0x108>)
 8028d7c:	6a3b      	ldr	r3, [r7, #32]
 8028d7e:	61d3      	str	r3, [r2, #28]
    theme.flags = flags;
 8028d80:	4a2c      	ldr	r2, [pc, #176]	; (8028e34 <lv_theme_material_init+0x108>)
 8028d82:	687b      	ldr	r3, [r7, #4]
 8028d84:	6213      	str	r3, [r2, #32]

    basic_init();
 8028d86:	f7fa febd 	bl	8023b04 <basic_init>
    cont_init();
 8028d8a:	f7fc f8ff 	bl	8024f8c <cont_init>
    btn_init();
 8028d8e:	f7fc f904 	bl	8024f9a <btn_init>
    label_init();
 8028d92:	f7fc f909 	bl	8024fa8 <label_init>
    bar_init();
 8028d96:	f7fc f90f 	bl	8024fb8 <bar_init>
    img_init();
 8028d9a:	f7fc fa0b 	bl	80251b4 <img_init>
    line_init();
 8028d9e:	f7fc fa10 	bl	80251c2 <line_init>
    led_init();
 8028da2:	f7fc fa15 	bl	80251d0 <led_init>
    slider_init();
 8028da6:	f7fc faaf 	bl	8025308 <slider_init>
    switch_init();
 8028daa:	f7fc fc31 	bl	8025610 <switch_init>
    linemeter_init();
 8028dae:	f7fc fcd1 	bl	8025754 <linemeter_init>
    gauge_init();
 8028db2:	f7fc fe19 	bl	80259e8 <gauge_init>
    arc_init();
 8028db6:	f7fd f8bb 	bl	8025f30 <arc_init>
    spinner_init();
 8028dba:	f7fd f985 	bl	80260c8 <spinner_init>
    chart_init();
 8028dbe:	f7fd f98b 	bl	80260d8 <chart_init>
    calendar_init();
 8028dc2:	f7fd facf 	bl	8026364 <calendar_init>
    cpicker_init();
 8028dc6:	f7fd fee1 	bl	8026b8c <cpicker_init>
    checkbox_init();
 8028dca:	f7fe f855 	bl	8026e78 <checkbox_init>
    btnmatrix_init();
 8028dce:	f7fe fa1f 	bl	8027210 <btnmatrix_init>
    keyboard_init();
 8028dd2:	f7fe fa25 	bl	8027220 <keyboard_init>
    msgbox_init();
 8028dd6:	f7fe fb4b 	bl	8027470 <msgbox_init>
    page_init();
 8028dda:	f7fe fb97 	bl	802750c <page_init>
    textarea_init();
 8028dde:	f7fe fc5d 	bl	802769c <textarea_init>
    spinbox_init();
 8028de2:	f7fe fcf7 	bl	80277d4 <spinbox_init>
    list_init();
 8028de6:	f7fe fd6b 	bl	80278c0 <list_init>
    ddlist_init();
 8028dea:	f7ff f99f 	bl	802812c <ddlist_init>
    roller_init();
 8028dee:	f7ff fa45 	bl	802827c <roller_init>
    tabview_init();
 8028df2:	f7ff fa9f 	bl	8028334 <tabview_init>
    tileview_init();
 8028df6:	f7ff faa4 	bl	8028342 <tileview_init>
    table_init();
 8028dfa:	f7ff faa9 	bl	8028350 <table_init>
    win_init();
 8028dfe:	f7ff fc0b 	bl	8028618 <win_init>
    tabview_win_shared_init();
 8028e02:	f7ff fc11 	bl	8028628 <tabview_win_shared_init>

    theme.apply_xcb = NULL;
 8028e06:	4b0b      	ldr	r3, [pc, #44]	; (8028e34 <lv_theme_material_init+0x108>)
 8028e08:	2200      	movs	r2, #0
 8028e0a:	605a      	str	r2, [r3, #4]
    theme.apply_cb = theme_apply;
 8028e0c:	4b09      	ldr	r3, [pc, #36]	; (8028e34 <lv_theme_material_init+0x108>)
 8028e0e:	4a0a      	ldr	r2, [pc, #40]	; (8028e38 <lv_theme_material_init+0x10c>)
 8028e10:	601a      	str	r2, [r3, #0]

    inited = true;
 8028e12:	4b05      	ldr	r3, [pc, #20]	; (8028e28 <lv_theme_material_init+0xfc>)
 8028e14:	2201      	movs	r2, #1
 8028e16:	701a      	strb	r2, [r3, #0]

    lv_obj_report_style_mod(NULL);
 8028e18:	2000      	movs	r0, #0
 8028e1a:	f7e1 fb1f 	bl	800a45c <lv_obj_report_style_mod>

    return &theme;
 8028e1e:	4b05      	ldr	r3, [pc, #20]	; (8028e34 <lv_theme_material_init+0x108>)
}
 8028e20:	4618      	mov	r0, r3
 8028e22:	3710      	adds	r7, #16
 8028e24:	46bd      	mov	sp, r7
 8028e26:	bd80      	pop	{r7, pc}
 8028e28:	20012354 	.word	0x20012354
 8028e2c:	2000a2dc 	.word	0x2000a2dc
 8028e30:	20012350 	.word	0x20012350
 8028e34:	20012328 	.word	0x20012328
 8028e38:	08028e3d 	.word	0x08028e3d

08028e3c <theme_apply>:


static void theme_apply(lv_theme_t * th, lv_obj_t * obj, lv_theme_style_t name)
{
 8028e3c:	b580      	push	{r7, lr}
 8028e3e:	b086      	sub	sp, #24
 8028e40:	af00      	add	r7, sp, #0
 8028e42:	60f8      	str	r0, [r7, #12]
 8028e44:	60b9      	str	r1, [r7, #8]
 8028e46:	4613      	mov	r3, r2
 8028e48:	80fb      	strh	r3, [r7, #6]
    LV_UNUSED(th);

    lv_style_list_t * list;

    switch(name) {
 8028e4a:	88fb      	ldrh	r3, [r7, #6]
 8028e4c:	2b29      	cmp	r3, #41	; 0x29
 8028e4e:	f200 84d0 	bhi.w	80297f2 <theme_apply+0x9b6>
 8028e52:	a201      	add	r2, pc, #4	; (adr r2, 8028e58 <theme_apply+0x1c>)
 8028e54:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8028e58:	080297f3 	.word	0x080297f3
 8028e5c:	08028f01 	.word	0x08028f01
 8028e60:	08028f1b 	.word	0x08028f1b
 8028e64:	08029087 	.word	0x08029087
 8028e68:	0802900b 	.word	0x0802900b
 8028e6c:	08028f53 	.word	0x08028f53
 8028e70:	08028f6f 	.word	0x08028f6f
 8028e74:	080296d9 	.word	0x080296d9
 8028e78:	080297f3 	.word	0x080297f3
 8028e7c:	08029185 	.word	0x08029185
 8028e80:	08029499 	.word	0x08029499
 8028e84:	08028f37 	.word	0x08028f37
 8028e88:	08029741 	.word	0x08029741
 8028e8c:	08029407 	.word	0x08029407
 8028e90:	0802979b 	.word	0x0802979b
 8028e94:	080297f3 	.word	0x080297f3
 8028e98:	080297f3 	.word	0x080297f3
 8028e9c:	08028fbf 	.word	0x08028fbf
 8028ea0:	080297f3 	.word	0x080297f3
 8028ea4:	08029223 	.word	0x08029223
 8028ea8:	080297f3 	.word	0x080297f3
 8028eac:	080293ad 	.word	0x080293ad
 8028eb0:	080293ed 	.word	0x080293ed
 8028eb4:	08029773 	.word	0x08029773
 8028eb8:	080291c9 	.word	0x080291c9
 8028ebc:	080291f1 	.word	0x080291f1
 8028ec0:	080293a1 	.word	0x080293a1
 8028ec4:	0802923d 	.word	0x0802923d
 8028ec8:	08029361 	.word	0x08029361
 8028ecc:	080297f3 	.word	0x080297f3
 8028ed0:	0802912d 	.word	0x0802912d
 8028ed4:	08029671 	.word	0x08029671
 8028ed8:	080296b1 	.word	0x080296b1
 8028edc:	080290fb 	.word	0x080290fb
 8028ee0:	0802903d 	.word	0x0802903d
 8028ee4:	0802950d 	.word	0x0802950d
 8028ee8:	0802929f 	.word	0x0802929f
 8028eec:	080292ff 	.word	0x080292ff
 8028ef0:	08029601 	.word	0x08029601
 8028ef4:	08029319 	.word	0x08029319
 8028ef8:	08029587 	.word	0x08029587
 8028efc:	080295e7 	.word	0x080295e7
        case LV_THEME_NONE:
            break;

        case LV_THEME_SCR:
            list = lv_obj_get_style_list(obj, LV_OBJ_PART_MAIN);
 8028f00:	2100      	movs	r1, #0
 8028f02:	68b8      	ldr	r0, [r7, #8]
 8028f04:	f7e2 f890 	bl	800b028 <lv_obj_get_style_list>
 8028f08:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->scr);
 8028f0a:	4bae      	ldr	r3, [pc, #696]	; (80291c4 <theme_apply+0x388>)
 8028f0c:	681b      	ldr	r3, [r3, #0]
 8028f0e:	4619      	mov	r1, r3
 8028f10:	6978      	ldr	r0, [r7, #20]
 8028f12:	f7e6 fa91 	bl	800f438 <_lv_style_list_add_style>
            break;
 8028f16:	f000 bc6d 	b.w	80297f4 <theme_apply+0x9b8>
        case LV_THEME_OBJ:
            list = lv_obj_get_style_list(obj, LV_OBJ_PART_MAIN);
 8028f1a:	2100      	movs	r1, #0
 8028f1c:	68b8      	ldr	r0, [r7, #8]
 8028f1e:	f7e2 f883 	bl	800b028 <lv_obj_get_style_list>
 8028f22:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 8028f24:	4ba7      	ldr	r3, [pc, #668]	; (80291c4 <theme_apply+0x388>)
 8028f26:	681b      	ldr	r3, [r3, #0]
 8028f28:	3304      	adds	r3, #4
 8028f2a:	4619      	mov	r1, r3
 8028f2c:	6978      	ldr	r0, [r7, #20]
 8028f2e:	f7e6 fa83 	bl	800f438 <_lv_style_list_add_style>
            break;
 8028f32:	f000 bc5f 	b.w	80297f4 <theme_apply+0x9b8>
#if LV_USE_CONT
        case LV_THEME_CONT:
            list = lv_obj_get_style_list(obj, LV_CONT_PART_MAIN);
 8028f36:	2100      	movs	r1, #0
 8028f38:	68b8      	ldr	r0, [r7, #8]
 8028f3a:	f7e2 f875 	bl	800b028 <lv_obj_get_style_list>
 8028f3e:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 8028f40:	4ba0      	ldr	r3, [pc, #640]	; (80291c4 <theme_apply+0x388>)
 8028f42:	681b      	ldr	r3, [r3, #0]
 8028f44:	3304      	adds	r3, #4
 8028f46:	4619      	mov	r1, r3
 8028f48:	6978      	ldr	r0, [r7, #20]
 8028f4a:	f7e6 fa75 	bl	800f438 <_lv_style_list_add_style>
            break;
 8028f4e:	f000 bc51 	b.w	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_BTN
        case LV_THEME_BTN:
            list = lv_obj_get_style_list(obj, LV_BTN_PART_MAIN);
 8028f52:	2100      	movs	r1, #0
 8028f54:	68b8      	ldr	r0, [r7, #8]
 8028f56:	f7e2 f867 	bl	800b028 <lv_obj_get_style_list>
 8028f5a:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->btn);
 8028f5c:	4b99      	ldr	r3, [pc, #612]	; (80291c4 <theme_apply+0x388>)
 8028f5e:	681b      	ldr	r3, [r3, #0]
 8028f60:	3310      	adds	r3, #16
 8028f62:	4619      	mov	r1, r3
 8028f64:	6978      	ldr	r0, [r7, #20]
 8028f66:	f7e6 fa67 	bl	800f438 <_lv_style_list_add_style>
            break;
 8028f6a:	f000 bc43 	b.w	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_BTNMATRIX
        case LV_THEME_BTNMATRIX:
            list = lv_obj_get_style_list(obj, LV_BTNMATRIX_PART_BG);
 8028f6e:	2100      	movs	r1, #0
 8028f70:	68b8      	ldr	r0, [r7, #8]
 8028f72:	f7e2 f859 	bl	800b028 <lv_obj_get_style_list>
 8028f76:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 8028f78:	4b92      	ldr	r3, [pc, #584]	; (80291c4 <theme_apply+0x388>)
 8028f7a:	681b      	ldr	r3, [r3, #0]
 8028f7c:	3304      	adds	r3, #4
 8028f7e:	4619      	mov	r1, r3
 8028f80:	6978      	ldr	r0, [r7, #20]
 8028f82:	f7e6 fa59 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->pad_small);
 8028f86:	4b8f      	ldr	r3, [pc, #572]	; (80291c4 <theme_apply+0x388>)
 8028f88:	681b      	ldr	r3, [r3, #0]
 8028f8a:	3318      	adds	r3, #24
 8028f8c:	4619      	mov	r1, r3
 8028f8e:	6978      	ldr	r0, [r7, #20]
 8028f90:	f7e6 fa52 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_BTNMATRIX_PART_BTN);
 8028f94:	2101      	movs	r1, #1
 8028f96:	68b8      	ldr	r0, [r7, #8]
 8028f98:	f7e2 f846 	bl	800b028 <lv_obj_get_style_list>
 8028f9c:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 8028f9e:	4b89      	ldr	r3, [pc, #548]	; (80291c4 <theme_apply+0x388>)
 8028fa0:	681b      	ldr	r3, [r3, #0]
 8028fa2:	3304      	adds	r3, #4
 8028fa4:	4619      	mov	r1, r3
 8028fa6:	6978      	ldr	r0, [r7, #20]
 8028fa8:	f7e6 fa46 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->bg_click);
 8028fac:	4b85      	ldr	r3, [pc, #532]	; (80291c4 <theme_apply+0x388>)
 8028fae:	681b      	ldr	r3, [r3, #0]
 8028fb0:	3308      	adds	r3, #8
 8028fb2:	4619      	mov	r1, r3
 8028fb4:	6978      	ldr	r0, [r7, #20]
 8028fb6:	f7e6 fa3f 	bl	800f438 <_lv_style_list_add_style>
            break;
 8028fba:	f000 bc1b 	b.w	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_KEYBOARD
        case LV_THEME_KEYBOARD:
            list = lv_obj_get_style_list(obj, LV_KEYBOARD_PART_BG);
 8028fbe:	2100      	movs	r1, #0
 8028fc0:	68b8      	ldr	r0, [r7, #8]
 8028fc2:	f7e2 f831 	bl	800b028 <lv_obj_get_style_list>
 8028fc6:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->scr);
 8028fc8:	4b7e      	ldr	r3, [pc, #504]	; (80291c4 <theme_apply+0x388>)
 8028fca:	681b      	ldr	r3, [r3, #0]
 8028fcc:	4619      	mov	r1, r3
 8028fce:	6978      	ldr	r0, [r7, #20]
 8028fd0:	f7e6 fa32 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->kb_bg);
 8028fd4:	4b7b      	ldr	r3, [pc, #492]	; (80291c4 <theme_apply+0x388>)
 8028fd6:	681b      	ldr	r3, [r3, #0]
 8028fd8:	336c      	adds	r3, #108	; 0x6c
 8028fda:	4619      	mov	r1, r3
 8028fdc:	6978      	ldr	r0, [r7, #20]
 8028fde:	f7e6 fa2b 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_KEYBOARD_PART_BTN);
 8028fe2:	2101      	movs	r1, #1
 8028fe4:	68b8      	ldr	r0, [r7, #8]
 8028fe6:	f7e2 f81f 	bl	800b028 <lv_obj_get_style_list>
 8028fea:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 8028fec:	4b75      	ldr	r3, [pc, #468]	; (80291c4 <theme_apply+0x388>)
 8028fee:	681b      	ldr	r3, [r3, #0]
 8028ff0:	3304      	adds	r3, #4
 8028ff2:	4619      	mov	r1, r3
 8028ff4:	6978      	ldr	r0, [r7, #20]
 8028ff6:	f7e6 fa1f 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->bg_click);
 8028ffa:	4b72      	ldr	r3, [pc, #456]	; (80291c4 <theme_apply+0x388>)
 8028ffc:	681b      	ldr	r3, [r3, #0]
 8028ffe:	3308      	adds	r3, #8
 8029000:	4619      	mov	r1, r3
 8029002:	6978      	ldr	r0, [r7, #20]
 8029004:	f7e6 fa18 	bl	800f438 <_lv_style_list_add_style>
            break;
 8029008:	e3f4      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_BAR
        case LV_THEME_BAR:
            list = lv_obj_get_style_list(obj, LV_BAR_PART_BG);
 802900a:	2100      	movs	r1, #0
 802900c:	68b8      	ldr	r0, [r7, #8]
 802900e:	f7e2 f80b 	bl	800b028 <lv_obj_get_style_list>
 8029012:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bar_bg);
 8029014:	4b6b      	ldr	r3, [pc, #428]	; (80291c4 <theme_apply+0x388>)
 8029016:	681b      	ldr	r3, [r3, #0]
 8029018:	3328      	adds	r3, #40	; 0x28
 802901a:	4619      	mov	r1, r3
 802901c:	6978      	ldr	r0, [r7, #20]
 802901e:	f7e6 fa0b 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_BAR_PART_INDIC);
 8029022:	2101      	movs	r1, #1
 8029024:	68b8      	ldr	r0, [r7, #8]
 8029026:	f7e1 ffff 	bl	800b028 <lv_obj_get_style_list>
 802902a:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bar_indic);
 802902c:	4b65      	ldr	r3, [pc, #404]	; (80291c4 <theme_apply+0x388>)
 802902e:	681b      	ldr	r3, [r3, #0]
 8029030:	332c      	adds	r3, #44	; 0x2c
 8029032:	4619      	mov	r1, r3
 8029034:	6978      	ldr	r0, [r7, #20]
 8029036:	f7e6 f9ff 	bl	800f438 <_lv_style_list_add_style>
            break;
 802903a:	e3db      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_SWITCH
        case LV_THEME_SWITCH:
            list = lv_obj_get_style_list(obj, LV_SWITCH_PART_BG);
 802903c:	2100      	movs	r1, #0
 802903e:	68b8      	ldr	r0, [r7, #8]
 8029040:	f7e1 fff2 	bl	800b028 <lv_obj_get_style_list>
 8029044:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bar_bg);
 8029046:	4b5f      	ldr	r3, [pc, #380]	; (80291c4 <theme_apply+0x388>)
 8029048:	681b      	ldr	r3, [r3, #0]
 802904a:	3328      	adds	r3, #40	; 0x28
 802904c:	4619      	mov	r1, r3
 802904e:	6978      	ldr	r0, [r7, #20]
 8029050:	f7e6 f9f2 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_SWITCH_PART_INDIC);
 8029054:	2101      	movs	r1, #1
 8029056:	68b8      	ldr	r0, [r7, #8]
 8029058:	f7e1 ffe6 	bl	800b028 <lv_obj_get_style_list>
 802905c:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bar_indic);
 802905e:	4b59      	ldr	r3, [pc, #356]	; (80291c4 <theme_apply+0x388>)
 8029060:	681b      	ldr	r3, [r3, #0]
 8029062:	332c      	adds	r3, #44	; 0x2c
 8029064:	4619      	mov	r1, r3
 8029066:	6978      	ldr	r0, [r7, #20]
 8029068:	f7e6 f9e6 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_SWITCH_PART_KNOB);
 802906c:	2102      	movs	r1, #2
 802906e:	68b8      	ldr	r0, [r7, #8]
 8029070:	f7e1 ffda 	bl	800b028 <lv_obj_get_style_list>
 8029074:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->sw_knob);
 8029076:	4b53      	ldr	r3, [pc, #332]	; (80291c4 <theme_apply+0x388>)
 8029078:	681b      	ldr	r3, [r3, #0]
 802907a:	33a0      	adds	r3, #160	; 0xa0
 802907c:	4619      	mov	r1, r3
 802907e:	6978      	ldr	r0, [r7, #20]
 8029080:	f7e6 f9da 	bl	800f438 <_lv_style_list_add_style>
            break;
 8029084:	e3b6      	b.n	80297f4 <theme_apply+0x9b8>
            break;
#endif

#if LV_USE_ARC
        case LV_THEME_ARC:
            list = lv_obj_get_style_list(obj, LV_ARC_PART_BG);
 8029086:	2100      	movs	r1, #0
 8029088:	68b8      	ldr	r0, [r7, #8]
 802908a:	f7e1 ffcd 	bl	800b028 <lv_obj_get_style_list>
 802908e:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 8029090:	4b4c      	ldr	r3, [pc, #304]	; (80291c4 <theme_apply+0x388>)
 8029092:	681b      	ldr	r3, [r3, #0]
 8029094:	3304      	adds	r3, #4
 8029096:	4619      	mov	r1, r3
 8029098:	6978      	ldr	r0, [r7, #20]
 802909a:	f7e6 f9cd 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->arc_bg);
 802909e:	4b49      	ldr	r3, [pc, #292]	; (80291c4 <theme_apply+0x388>)
 80290a0:	681b      	ldr	r3, [r3, #0]
 80290a2:	3320      	adds	r3, #32
 80290a4:	4619      	mov	r1, r3
 80290a6:	6978      	ldr	r0, [r7, #20]
 80290a8:	f7e6 f9c6 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_ARC_PART_INDIC);
 80290ac:	2101      	movs	r1, #1
 80290ae:	68b8      	ldr	r0, [r7, #8]
 80290b0:	f7e1 ffba 	bl	800b028 <lv_obj_get_style_list>
 80290b4:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->arc_indic);
 80290b6:	4b43      	ldr	r3, [pc, #268]	; (80291c4 <theme_apply+0x388>)
 80290b8:	681b      	ldr	r3, [r3, #0]
 80290ba:	331c      	adds	r3, #28
 80290bc:	4619      	mov	r1, r3
 80290be:	6978      	ldr	r0, [r7, #20]
 80290c0:	f7e6 f9ba 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_ARC_PART_KNOB);
 80290c4:	2102      	movs	r1, #2
 80290c6:	68b8      	ldr	r0, [r7, #8]
 80290c8:	f7e1 ffae 	bl	800b028 <lv_obj_get_style_list>
 80290cc:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 80290ce:	4b3d      	ldr	r3, [pc, #244]	; (80291c4 <theme_apply+0x388>)
 80290d0:	681b      	ldr	r3, [r3, #0]
 80290d2:	3304      	adds	r3, #4
 80290d4:	4619      	mov	r1, r3
 80290d6:	6978      	ldr	r0, [r7, #20]
 80290d8:	f7e6 f9ae 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->bg_click);
 80290dc:	4b39      	ldr	r3, [pc, #228]	; (80291c4 <theme_apply+0x388>)
 80290de:	681b      	ldr	r3, [r3, #0]
 80290e0:	3308      	adds	r3, #8
 80290e2:	4619      	mov	r1, r3
 80290e4:	6978      	ldr	r0, [r7, #20]
 80290e6:	f7e6 f9a7 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->arc_knob);
 80290ea:	4b36      	ldr	r3, [pc, #216]	; (80291c4 <theme_apply+0x388>)
 80290ec:	681b      	ldr	r3, [r3, #0]
 80290ee:	3324      	adds	r3, #36	; 0x24
 80290f0:	4619      	mov	r1, r3
 80290f2:	6978      	ldr	r0, [r7, #20]
 80290f4:	f7e6 f9a0 	bl	800f438 <_lv_style_list_add_style>
            break;
 80290f8:	e37c      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_SPINNER
        case LV_THEME_SPINNER:
            list = lv_obj_get_style_list(obj, LV_SPINNER_PART_BG);
 80290fa:	2100      	movs	r1, #0
 80290fc:	68b8      	ldr	r0, [r7, #8]
 80290fe:	f7e1 ff93 	bl	800b028 <lv_obj_get_style_list>
 8029102:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->arc_bg);
 8029104:	4b2f      	ldr	r3, [pc, #188]	; (80291c4 <theme_apply+0x388>)
 8029106:	681b      	ldr	r3, [r3, #0]
 8029108:	3320      	adds	r3, #32
 802910a:	4619      	mov	r1, r3
 802910c:	6978      	ldr	r0, [r7, #20]
 802910e:	f7e6 f993 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_SPINNER_PART_INDIC);
 8029112:	2101      	movs	r1, #1
 8029114:	68b8      	ldr	r0, [r7, #8]
 8029116:	f7e1 ff87 	bl	800b028 <lv_obj_get_style_list>
 802911a:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->arc_indic);
 802911c:	4b29      	ldr	r3, [pc, #164]	; (80291c4 <theme_apply+0x388>)
 802911e:	681b      	ldr	r3, [r3, #0]
 8029120:	331c      	adds	r3, #28
 8029122:	4619      	mov	r1, r3
 8029124:	6978      	ldr	r0, [r7, #20]
 8029126:	f7e6 f987 	bl	800f438 <_lv_style_list_add_style>
            break;
 802912a:	e363      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_SLIDER
        case LV_THEME_SLIDER:
            list = lv_obj_get_style_list(obj, LV_SLIDER_PART_BG);
 802912c:	2100      	movs	r1, #0
 802912e:	68b8      	ldr	r0, [r7, #8]
 8029130:	f7e1 ff7a 	bl	800b028 <lv_obj_get_style_list>
 8029134:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bar_bg);
 8029136:	4b23      	ldr	r3, [pc, #140]	; (80291c4 <theme_apply+0x388>)
 8029138:	681b      	ldr	r3, [r3, #0]
 802913a:	3328      	adds	r3, #40	; 0x28
 802913c:	4619      	mov	r1, r3
 802913e:	6978      	ldr	r0, [r7, #20]
 8029140:	f7e6 f97a 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->slider_bg);
 8029144:	4b1f      	ldr	r3, [pc, #124]	; (80291c4 <theme_apply+0x388>)
 8029146:	681b      	ldr	r3, [r3, #0]
 8029148:	3398      	adds	r3, #152	; 0x98
 802914a:	4619      	mov	r1, r3
 802914c:	6978      	ldr	r0, [r7, #20]
 802914e:	f7e6 f973 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_SLIDER_PART_INDIC);
 8029152:	2101      	movs	r1, #1
 8029154:	68b8      	ldr	r0, [r7, #8]
 8029156:	f7e1 ff67 	bl	800b028 <lv_obj_get_style_list>
 802915a:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bar_indic);
 802915c:	4b19      	ldr	r3, [pc, #100]	; (80291c4 <theme_apply+0x388>)
 802915e:	681b      	ldr	r3, [r3, #0]
 8029160:	332c      	adds	r3, #44	; 0x2c
 8029162:	4619      	mov	r1, r3
 8029164:	6978      	ldr	r0, [r7, #20]
 8029166:	f7e6 f967 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_SLIDER_PART_KNOB);
 802916a:	2102      	movs	r1, #2
 802916c:	68b8      	ldr	r0, [r7, #8]
 802916e:	f7e1 ff5b 	bl	800b028 <lv_obj_get_style_list>
 8029172:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->slider_knob);
 8029174:	4b13      	ldr	r3, [pc, #76]	; (80291c4 <theme_apply+0x388>)
 8029176:	681b      	ldr	r3, [r3, #0]
 8029178:	3394      	adds	r3, #148	; 0x94
 802917a:	4619      	mov	r1, r3
 802917c:	6978      	ldr	r0, [r7, #20]
 802917e:	f7e6 f95b 	bl	800f438 <_lv_style_list_add_style>
            break;
 8029182:	e337      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_CHECKBOX
        case LV_THEME_CHECKBOX:
            list = lv_obj_get_style_list(obj, LV_CHECKBOX_PART_BG);
 8029184:	2100      	movs	r1, #0
 8029186:	68b8      	ldr	r0, [r7, #8]
 8029188:	f7e1 ff4e 	bl	800b028 <lv_obj_get_style_list>
 802918c:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->cb_bg);
 802918e:	4b0d      	ldr	r3, [pc, #52]	; (80291c4 <theme_apply+0x388>)
 8029190:	681b      	ldr	r3, [r3, #0]
 8029192:	3350      	adds	r3, #80	; 0x50
 8029194:	4619      	mov	r1, r3
 8029196:	6978      	ldr	r0, [r7, #20]
 8029198:	f7e6 f94e 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_CHECKBOX_PART_BULLET);
 802919c:	2140      	movs	r1, #64	; 0x40
 802919e:	68b8      	ldr	r0, [r7, #8]
 80291a0:	f7e1 ff42 	bl	800b028 <lv_obj_get_style_list>
 80291a4:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->btn);
 80291a6:	4b07      	ldr	r3, [pc, #28]	; (80291c4 <theme_apply+0x388>)
 80291a8:	681b      	ldr	r3, [r3, #0]
 80291aa:	3310      	adds	r3, #16
 80291ac:	4619      	mov	r1, r3
 80291ae:	6978      	ldr	r0, [r7, #20]
 80291b0:	f7e6 f942 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->cb_bullet);
 80291b4:	4b03      	ldr	r3, [pc, #12]	; (80291c4 <theme_apply+0x388>)
 80291b6:	681b      	ldr	r3, [r3, #0]
 80291b8:	3354      	adds	r3, #84	; 0x54
 80291ba:	4619      	mov	r1, r3
 80291bc:	6978      	ldr	r0, [r7, #20]
 80291be:	f7e6 f93b 	bl	800f438 <_lv_style_list_add_style>
            break;
 80291c2:	e317      	b.n	80297f4 <theme_apply+0x9b8>
 80291c4:	20012350 	.word	0x20012350
#endif

#if LV_USE_MSGBOX
        case LV_THEME_MSGBOX:
            list = lv_obj_get_style_list(obj, LV_MSGBOX_PART_BG);
 80291c8:	2100      	movs	r1, #0
 80291ca:	68b8      	ldr	r0, [r7, #8]
 80291cc:	f7e1 ff2c 	bl	800b028 <lv_obj_get_style_list>
 80291d0:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 80291d2:	4bb0      	ldr	r3, [pc, #704]	; (8029494 <theme_apply+0x658>)
 80291d4:	681b      	ldr	r3, [r3, #0]
 80291d6:	3304      	adds	r3, #4
 80291d8:	4619      	mov	r1, r3
 80291da:	6978      	ldr	r0, [r7, #20]
 80291dc:	f7e6 f92c 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->mbox_bg);
 80291e0:	4bac      	ldr	r3, [pc, #688]	; (8029494 <theme_apply+0x658>)
 80291e2:	681b      	ldr	r3, [r3, #0]
 80291e4:	3380      	adds	r3, #128	; 0x80
 80291e6:	4619      	mov	r1, r3
 80291e8:	6978      	ldr	r0, [r7, #20]
 80291ea:	f7e6 f925 	bl	800f438 <_lv_style_list_add_style>
            break;
 80291ee:	e301      	b.n	80297f4 <theme_apply+0x9b8>

        case LV_THEME_MSGBOX_BTNS:
            list = lv_obj_get_style_list(obj, LV_MSGBOX_PART_BTN_BG);
 80291f0:	2140      	movs	r1, #64	; 0x40
 80291f2:	68b8      	ldr	r0, [r7, #8]
 80291f4:	f7e1 ff18 	bl	800b028 <lv_obj_get_style_list>
 80291f8:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->pad_small);
 80291fa:	4ba6      	ldr	r3, [pc, #664]	; (8029494 <theme_apply+0x658>)
 80291fc:	681b      	ldr	r3, [r3, #0]
 80291fe:	3318      	adds	r3, #24
 8029200:	4619      	mov	r1, r3
 8029202:	6978      	ldr	r0, [r7, #20]
 8029204:	f7e6 f918 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_MSGBOX_PART_BTN);
 8029208:	2141      	movs	r1, #65	; 0x41
 802920a:	68b8      	ldr	r0, [r7, #8]
 802920c:	f7e1 ff0c 	bl	800b028 <lv_obj_get_style_list>
 8029210:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->btn);
 8029212:	4ba0      	ldr	r3, [pc, #640]	; (8029494 <theme_apply+0x658>)
 8029214:	681b      	ldr	r3, [r3, #0]
 8029216:	3310      	adds	r3, #16
 8029218:	4619      	mov	r1, r3
 802921a:	6978      	ldr	r0, [r7, #20]
 802921c:	f7e6 f90c 	bl	800f438 <_lv_style_list_add_style>
            break;
 8029220:	e2e8      	b.n	80297f4 <theme_apply+0x9b8>

#endif
#if LV_USE_LED
        case LV_THEME_LED:
            list = lv_obj_get_style_list(obj, LV_LED_PART_MAIN);
 8029222:	2100      	movs	r1, #0
 8029224:	68b8      	ldr	r0, [r7, #8]
 8029226:	f7e1 feff 	bl	800b028 <lv_obj_get_style_list>
 802922a:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->led);
 802922c:	4b99      	ldr	r3, [pc, #612]	; (8029494 <theme_apply+0x658>)
 802922e:	681b      	ldr	r3, [r3, #0]
 8029230:	3370      	adds	r3, #112	; 0x70
 8029232:	4619      	mov	r1, r3
 8029234:	6978      	ldr	r0, [r7, #20]
 8029236:	f7e6 f8ff 	bl	800f438 <_lv_style_list_add_style>
            break;
 802923a:	e2db      	b.n	80297f4 <theme_apply+0x9b8>
#endif
#if LV_USE_PAGE
        case LV_THEME_PAGE:
            list = lv_obj_get_style_list(obj, LV_PAGE_PART_BG);
 802923c:	2100      	movs	r1, #0
 802923e:	68b8      	ldr	r0, [r7, #8]
 8029240:	f7e1 fef2 	bl	800b028 <lv_obj_get_style_list>
 8029244:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 8029246:	4b93      	ldr	r3, [pc, #588]	; (8029494 <theme_apply+0x658>)
 8029248:	681b      	ldr	r3, [r3, #0]
 802924a:	3304      	adds	r3, #4
 802924c:	4619      	mov	r1, r3
 802924e:	6978      	ldr	r0, [r7, #20]
 8029250:	f7e6 f8f2 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_PAGE_PART_SCROLLABLE);
 8029254:	2140      	movs	r1, #64	; 0x40
 8029256:	68b8      	ldr	r0, [r7, #8]
 8029258:	f7e1 fee6 	bl	800b028 <lv_obj_get_style_list>
 802925c:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->pad_inner);
 802925e:	4b8d      	ldr	r3, [pc, #564]	; (8029494 <theme_apply+0x658>)
 8029260:	681b      	ldr	r3, [r3, #0]
 8029262:	3314      	adds	r3, #20
 8029264:	4619      	mov	r1, r3
 8029266:	6978      	ldr	r0, [r7, #20]
 8029268:	f7e6 f8e6 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_PAGE_PART_SCROLLBAR);
 802926c:	2101      	movs	r1, #1
 802926e:	68b8      	ldr	r0, [r7, #8]
 8029270:	f7e1 feda 	bl	800b028 <lv_obj_get_style_list>
 8029274:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->sb);
 8029276:	4b87      	ldr	r3, [pc, #540]	; (8029494 <theme_apply+0x658>)
 8029278:	681b      	ldr	r3, [r3, #0]
 802927a:	3384      	adds	r3, #132	; 0x84
 802927c:	4619      	mov	r1, r3
 802927e:	6978      	ldr	r0, [r7, #20]
 8029280:	f7e6 f8da 	bl	800f438 <_lv_style_list_add_style>

#if LV_USE_ANIMATION
            list = lv_obj_get_style_list(obj, LV_PAGE_PART_EDGE_FLASH);
 8029284:	2102      	movs	r1, #2
 8029286:	68b8      	ldr	r0, [r7, #8]
 8029288:	f7e1 fece 	bl	800b028 <lv_obj_get_style_list>
 802928c:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->edge_flash);
 802928e:	4b81      	ldr	r3, [pc, #516]	; (8029494 <theme_apply+0x658>)
 8029290:	681b      	ldr	r3, [r3, #0]
 8029292:	3388      	adds	r3, #136	; 0x88
 8029294:	4619      	mov	r1, r3
 8029296:	6978      	ldr	r0, [r7, #20]
 8029298:	f7e6 f8ce 	bl	800f438 <_lv_style_list_add_style>
#endif
            break;
 802929c:	e2aa      	b.n	80297f4 <theme_apply+0x9b8>
#endif
#if LV_USE_TABVIEW
        case LV_THEME_TABVIEW:
            list = lv_obj_get_style_list(obj, LV_TABVIEW_PART_BG);
 802929e:	2100      	movs	r1, #0
 80292a0:	68b8      	ldr	r0, [r7, #8]
 80292a2:	f7e1 fec1 	bl	800b028 <lv_obj_get_style_list>
 80292a6:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->scr);
 80292a8:	4b7a      	ldr	r3, [pc, #488]	; (8029494 <theme_apply+0x658>)
 80292aa:	681b      	ldr	r3, [r3, #0]
 80292ac:	4619      	mov	r1, r3
 80292ae:	6978      	ldr	r0, [r7, #20]
 80292b0:	f7e6 f8c2 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_TABVIEW_PART_TAB_BG);
 80292b4:	2141      	movs	r1, #65	; 0x41
 80292b6:	68b8      	ldr	r0, [r7, #8]
 80292b8:	f7e1 feb6 	bl	800b028 <lv_obj_get_style_list>
 80292bc:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->tabview_btns_bg);
 80292be:	4b75      	ldr	r3, [pc, #468]	; (8029494 <theme_apply+0x658>)
 80292c0:	681b      	ldr	r3, [r3, #0]
 80292c2:	33ac      	adds	r3, #172	; 0xac
 80292c4:	4619      	mov	r1, r3
 80292c6:	6978      	ldr	r0, [r7, #20]
 80292c8:	f7e6 f8b6 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_TABVIEW_PART_INDIC);
 80292cc:	2143      	movs	r1, #67	; 0x43
 80292ce:	68b8      	ldr	r0, [r7, #8]
 80292d0:	f7e1 feaa 	bl	800b028 <lv_obj_get_style_list>
 80292d4:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->tabview_indic);
 80292d6:	4b6f      	ldr	r3, [pc, #444]	; (8029494 <theme_apply+0x658>)
 80292d8:	681b      	ldr	r3, [r3, #0]
 80292da:	33b0      	adds	r3, #176	; 0xb0
 80292dc:	4619      	mov	r1, r3
 80292de:	6978      	ldr	r0, [r7, #20]
 80292e0:	f7e6 f8aa 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_TABVIEW_PART_TAB_BTN);
 80292e4:	2142      	movs	r1, #66	; 0x42
 80292e6:	68b8      	ldr	r0, [r7, #8]
 80292e8:	f7e1 fe9e 	bl	800b028 <lv_obj_get_style_list>
 80292ec:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->tabview_btns);
 80292ee:	4b69      	ldr	r3, [pc, #420]	; (8029494 <theme_apply+0x658>)
 80292f0:	681b      	ldr	r3, [r3, #0]
 80292f2:	33a8      	adds	r3, #168	; 0xa8
 80292f4:	4619      	mov	r1, r3
 80292f6:	6978      	ldr	r0, [r7, #20]
 80292f8:	f7e6 f89e 	bl	800f438 <_lv_style_list_add_style>
            break;
 80292fc:	e27a      	b.n	80297f4 <theme_apply+0x9b8>

        case LV_THEME_TABVIEW_PAGE:
            list = lv_obj_get_style_list(obj, LV_PAGE_PART_SCROLLABLE);
 80292fe:	2140      	movs	r1, #64	; 0x40
 8029300:	68b8      	ldr	r0, [r7, #8]
 8029302:	f7e1 fe91 	bl	800b028 <lv_obj_get_style_list>
 8029306:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->tabview_page_scrl);
 8029308:	4b62      	ldr	r3, [pc, #392]	; (8029494 <theme_apply+0x658>)
 802930a:	681b      	ldr	r3, [r3, #0]
 802930c:	33b4      	adds	r3, #180	; 0xb4
 802930e:	4619      	mov	r1, r3
 8029310:	6978      	ldr	r0, [r7, #20]
 8029312:	f7e6 f891 	bl	800f438 <_lv_style_list_add_style>

            break;
 8029316:	e26d      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_TILEVIEW
        case LV_THEME_TILEVIEW:
            list = lv_obj_get_style_list(obj, LV_TILEVIEW_PART_BG);
 8029318:	2100      	movs	r1, #0
 802931a:	68b8      	ldr	r0, [r7, #8]
 802931c:	f7e1 fe84 	bl	800b028 <lv_obj_get_style_list>
 8029320:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->scr);
 8029322:	4b5c      	ldr	r3, [pc, #368]	; (8029494 <theme_apply+0x658>)
 8029324:	681b      	ldr	r3, [r3, #0]
 8029326:	4619      	mov	r1, r3
 8029328:	6978      	ldr	r0, [r7, #20]
 802932a:	f7e6 f885 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_TILEVIEW_PART_SCROLLBAR);
 802932e:	2101      	movs	r1, #1
 8029330:	68b8      	ldr	r0, [r7, #8]
 8029332:	f7e1 fe79 	bl	800b028 <lv_obj_get_style_list>
 8029336:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->sb);
 8029338:	4b56      	ldr	r3, [pc, #344]	; (8029494 <theme_apply+0x658>)
 802933a:	681b      	ldr	r3, [r3, #0]
 802933c:	3384      	adds	r3, #132	; 0x84
 802933e:	4619      	mov	r1, r3
 8029340:	6978      	ldr	r0, [r7, #20]
 8029342:	f7e6 f879 	bl	800f438 <_lv_style_list_add_style>

#if LV_USE_ANIMATION
            list = lv_obj_get_style_list(obj, LV_TILEVIEW_PART_EDGE_FLASH);
 8029346:	2102      	movs	r1, #2
 8029348:	68b8      	ldr	r0, [r7, #8]
 802934a:	f7e1 fe6d 	bl	800b028 <lv_obj_get_style_list>
 802934e:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->edge_flash);
 8029350:	4b50      	ldr	r3, [pc, #320]	; (8029494 <theme_apply+0x658>)
 8029352:	681b      	ldr	r3, [r3, #0]
 8029354:	3388      	adds	r3, #136	; 0x88
 8029356:	4619      	mov	r1, r3
 8029358:	6978      	ldr	r0, [r7, #20]
 802935a:	f7e6 f86d 	bl	800f438 <_lv_style_list_add_style>
#endif
            break;
 802935e:	e249      	b.n	80297f4 <theme_apply+0x9b8>
#endif


#if LV_USE_ROLLER
        case LV_THEME_ROLLER:
            list = lv_obj_get_style_list(obj, LV_ROLLER_PART_BG);
 8029360:	2100      	movs	r1, #0
 8029362:	68b8      	ldr	r0, [r7, #8]
 8029364:	f7e1 fe60 	bl	800b028 <lv_obj_get_style_list>
 8029368:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 802936a:	4b4a      	ldr	r3, [pc, #296]	; (8029494 <theme_apply+0x658>)
 802936c:	681b      	ldr	r3, [r3, #0]
 802936e:	3304      	adds	r3, #4
 8029370:	4619      	mov	r1, r3
 8029372:	6978      	ldr	r0, [r7, #20]
 8029374:	f7e6 f860 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->roller_bg);
 8029378:	4b46      	ldr	r3, [pc, #280]	; (8029494 <theme_apply+0x658>)
 802937a:	681b      	ldr	r3, [r3, #0]
 802937c:	338c      	adds	r3, #140	; 0x8c
 802937e:	4619      	mov	r1, r3
 8029380:	6978      	ldr	r0, [r7, #20]
 8029382:	f7e6 f859 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_ROLLER_PART_SELECTED);
 8029386:	2103      	movs	r1, #3
 8029388:	68b8      	ldr	r0, [r7, #8]
 802938a:	f7e1 fe4d 	bl	800b028 <lv_obj_get_style_list>
 802938e:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->roller_sel);
 8029390:	4b40      	ldr	r3, [pc, #256]	; (8029494 <theme_apply+0x658>)
 8029392:	681b      	ldr	r3, [r3, #0]
 8029394:	3390      	adds	r3, #144	; 0x90
 8029396:	4619      	mov	r1, r3
 8029398:	6978      	ldr	r0, [r7, #20]
 802939a:	f7e6 f84d 	bl	800f438 <_lv_style_list_add_style>
            break;
 802939e:	e229      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_OBJMASK
        case LV_THEME_OBJMASK:
            list = lv_obj_get_style_list(obj, LV_OBJMASK_PART_MAIN);
 80293a0:	2100      	movs	r1, #0
 80293a2:	68b8      	ldr	r0, [r7, #8]
 80293a4:	f7e1 fe40 	bl	800b028 <lv_obj_get_style_list>
 80293a8:	6178      	str	r0, [r7, #20]
            break;
 80293aa:	e223      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_LIST
        case LV_THEME_LIST:
            list = lv_obj_get_style_list(obj, LV_LIST_PART_BG);
 80293ac:	2100      	movs	r1, #0
 80293ae:	68b8      	ldr	r0, [r7, #8]
 80293b0:	f7e1 fe3a 	bl	800b028 <lv_obj_get_style_list>
 80293b4:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 80293b6:	4b37      	ldr	r3, [pc, #220]	; (8029494 <theme_apply+0x658>)
 80293b8:	681b      	ldr	r3, [r3, #0]
 80293ba:	3304      	adds	r3, #4
 80293bc:	4619      	mov	r1, r3
 80293be:	6978      	ldr	r0, [r7, #20]
 80293c0:	f7e6 f83a 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->list_bg);
 80293c4:	4b33      	ldr	r3, [pc, #204]	; (8029494 <theme_apply+0x658>)
 80293c6:	681b      	ldr	r3, [r3, #0]
 80293c8:	3378      	adds	r3, #120	; 0x78
 80293ca:	4619      	mov	r1, r3
 80293cc:	6978      	ldr	r0, [r7, #20]
 80293ce:	f7e6 f833 	bl	800f438 <_lv_style_list_add_style>


            list = lv_obj_get_style_list(obj, LV_LIST_PART_SCROLLBAR);
 80293d2:	2101      	movs	r1, #1
 80293d4:	68b8      	ldr	r0, [r7, #8]
 80293d6:	f7e1 fe27 	bl	800b028 <lv_obj_get_style_list>
 80293da:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->sb);
 80293dc:	4b2d      	ldr	r3, [pc, #180]	; (8029494 <theme_apply+0x658>)
 80293de:	681b      	ldr	r3, [r3, #0]
 80293e0:	3384      	adds	r3, #132	; 0x84
 80293e2:	4619      	mov	r1, r3
 80293e4:	6978      	ldr	r0, [r7, #20]
 80293e6:	f7e6 f827 	bl	800f438 <_lv_style_list_add_style>
            break;
 80293ea:	e203      	b.n	80297f4 <theme_apply+0x9b8>

        case LV_THEME_LIST_BTN:
            list = lv_obj_get_style_list(obj, LV_BTN_PART_MAIN);
 80293ec:	2100      	movs	r1, #0
 80293ee:	68b8      	ldr	r0, [r7, #8]
 80293f0:	f7e1 fe1a 	bl	800b028 <lv_obj_get_style_list>
 80293f4:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->list_btn);
 80293f6:	4b27      	ldr	r3, [pc, #156]	; (8029494 <theme_apply+0x658>)
 80293f8:	681b      	ldr	r3, [r3, #0]
 80293fa:	337c      	adds	r3, #124	; 0x7c
 80293fc:	4619      	mov	r1, r3
 80293fe:	6978      	ldr	r0, [r7, #20]
 8029400:	f7e6 f81a 	bl	800f438 <_lv_style_list_add_style>
            break;
 8029404:	e1f6      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_DROPDOWN
        case LV_THEME_DROPDOWN:
            list = lv_obj_get_style_list(obj, LV_DROPDOWN_PART_MAIN);
 8029406:	2100      	movs	r1, #0
 8029408:	68b8      	ldr	r0, [r7, #8]
 802940a:	f7e1 fe0d 	bl	800b028 <lv_obj_get_style_list>
 802940e:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 8029410:	4b20      	ldr	r3, [pc, #128]	; (8029494 <theme_apply+0x658>)
 8029412:	681b      	ldr	r3, [r3, #0]
 8029414:	3304      	adds	r3, #4
 8029416:	4619      	mov	r1, r3
 8029418:	6978      	ldr	r0, [r7, #20]
 802941a:	f7e6 f80d 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->bg_click);
 802941e:	4b1d      	ldr	r3, [pc, #116]	; (8029494 <theme_apply+0x658>)
 8029420:	681b      	ldr	r3, [r3, #0]
 8029422:	3308      	adds	r3, #8
 8029424:	4619      	mov	r1, r3
 8029426:	6978      	ldr	r0, [r7, #20]
 8029428:	f7e6 f806 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->pad_small);
 802942c:	4b19      	ldr	r3, [pc, #100]	; (8029494 <theme_apply+0x658>)
 802942e:	681b      	ldr	r3, [r3, #0]
 8029430:	3318      	adds	r3, #24
 8029432:	4619      	mov	r1, r3
 8029434:	6978      	ldr	r0, [r7, #20]
 8029436:	f7e5 ffff 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_DROPDOWN_PART_LIST);
 802943a:	2140      	movs	r1, #64	; 0x40
 802943c:	68b8      	ldr	r0, [r7, #8]
 802943e:	f7e1 fdf3 	bl	800b028 <lv_obj_get_style_list>
 8029442:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 8029444:	4b13      	ldr	r3, [pc, #76]	; (8029494 <theme_apply+0x658>)
 8029446:	681b      	ldr	r3, [r3, #0]
 8029448:	3304      	adds	r3, #4
 802944a:	4619      	mov	r1, r3
 802944c:	6978      	ldr	r0, [r7, #20]
 802944e:	f7e5 fff3 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->ddlist_page);
 8029452:	4b10      	ldr	r3, [pc, #64]	; (8029494 <theme_apply+0x658>)
 8029454:	681b      	ldr	r3, [r3, #0]
 8029456:	3358      	adds	r3, #88	; 0x58
 8029458:	4619      	mov	r1, r3
 802945a:	6978      	ldr	r0, [r7, #20]
 802945c:	f7e5 ffec 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_DROPDOWN_PART_SCROLLBAR);
 8029460:	2141      	movs	r1, #65	; 0x41
 8029462:	68b8      	ldr	r0, [r7, #8]
 8029464:	f7e1 fde0 	bl	800b028 <lv_obj_get_style_list>
 8029468:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->sb);
 802946a:	4b0a      	ldr	r3, [pc, #40]	; (8029494 <theme_apply+0x658>)
 802946c:	681b      	ldr	r3, [r3, #0]
 802946e:	3384      	adds	r3, #132	; 0x84
 8029470:	4619      	mov	r1, r3
 8029472:	6978      	ldr	r0, [r7, #20]
 8029474:	f7e5 ffe0 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_DROPDOWN_PART_SELECTED);
 8029478:	2142      	movs	r1, #66	; 0x42
 802947a:	68b8      	ldr	r0, [r7, #8]
 802947c:	f7e1 fdd4 	bl	800b028 <lv_obj_get_style_list>
 8029480:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->ddlist_sel);
 8029482:	4b04      	ldr	r3, [pc, #16]	; (8029494 <theme_apply+0x658>)
 8029484:	681b      	ldr	r3, [r3, #0]
 8029486:	335c      	adds	r3, #92	; 0x5c
 8029488:	4619      	mov	r1, r3
 802948a:	6978      	ldr	r0, [r7, #20]
 802948c:	f7e5 ffd4 	bl	800f438 <_lv_style_list_add_style>
            break;
 8029490:	e1b0      	b.n	80297f4 <theme_apply+0x9b8>
 8029492:	bf00      	nop
 8029494:	20012350 	.word	0x20012350
#endif

#if LV_USE_CHART
        case LV_THEME_CHART:
            list = lv_obj_get_style_list(obj, LV_CHART_PART_BG);
 8029498:	2100      	movs	r1, #0
 802949a:	68b8      	ldr	r0, [r7, #8]
 802949c:	f7e1 fdc4 	bl	800b028 <lv_obj_get_style_list>
 80294a0:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 80294a2:	4ba6      	ldr	r3, [pc, #664]	; (802973c <theme_apply+0x900>)
 80294a4:	681b      	ldr	r3, [r3, #0]
 80294a6:	3304      	adds	r3, #4
 80294a8:	4619      	mov	r1, r3
 80294aa:	6978      	ldr	r0, [r7, #20]
 80294ac:	f7e5 ffc4 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->chart_bg);
 80294b0:	4ba2      	ldr	r3, [pc, #648]	; (802973c <theme_apply+0x900>)
 80294b2:	681b      	ldr	r3, [r3, #0]
 80294b4:	3344      	adds	r3, #68	; 0x44
 80294b6:	4619      	mov	r1, r3
 80294b8:	6978      	ldr	r0, [r7, #20]
 80294ba:	f7e5 ffbd 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->pad_small);
 80294be:	4b9f      	ldr	r3, [pc, #636]	; (802973c <theme_apply+0x900>)
 80294c0:	681b      	ldr	r3, [r3, #0]
 80294c2:	3318      	adds	r3, #24
 80294c4:	4619      	mov	r1, r3
 80294c6:	6978      	ldr	r0, [r7, #20]
 80294c8:	f7e5 ffb6 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_CHART_PART_SERIES_BG);
 80294cc:	2101      	movs	r1, #1
 80294ce:	68b8      	ldr	r0, [r7, #8]
 80294d0:	f7e1 fdaa 	bl	800b028 <lv_obj_get_style_list>
 80294d4:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->pad_small);
 80294d6:	4b99      	ldr	r3, [pc, #612]	; (802973c <theme_apply+0x900>)
 80294d8:	681b      	ldr	r3, [r3, #0]
 80294da:	3318      	adds	r3, #24
 80294dc:	4619      	mov	r1, r3
 80294de:	6978      	ldr	r0, [r7, #20]
 80294e0:	f7e5 ffaa 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->chart_series_bg);
 80294e4:	4b95      	ldr	r3, [pc, #596]	; (802973c <theme_apply+0x900>)
 80294e6:	681b      	ldr	r3, [r3, #0]
 80294e8:	3348      	adds	r3, #72	; 0x48
 80294ea:	4619      	mov	r1, r3
 80294ec:	6978      	ldr	r0, [r7, #20]
 80294ee:	f7e5 ffa3 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_CHART_PART_SERIES);
 80294f2:	2102      	movs	r1, #2
 80294f4:	68b8      	ldr	r0, [r7, #8]
 80294f6:	f7e1 fd97 	bl	800b028 <lv_obj_get_style_list>
 80294fa:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->chart_series);
 80294fc:	4b8f      	ldr	r3, [pc, #572]	; (802973c <theme_apply+0x900>)
 80294fe:	681b      	ldr	r3, [r3, #0]
 8029500:	334c      	adds	r3, #76	; 0x4c
 8029502:	4619      	mov	r1, r3
 8029504:	6978      	ldr	r0, [r7, #20]
 8029506:	f7e5 ff97 	bl	800f438 <_lv_style_list_add_style>
            break;
 802950a:	e173      	b.n	80297f4 <theme_apply+0x9b8>
#endif
#if LV_USE_TABLE
        case LV_THEME_TABLE:
            list = lv_obj_get_style_list(obj, LV_TABLE_PART_BG);
 802950c:	2100      	movs	r1, #0
 802950e:	68b8      	ldr	r0, [r7, #8]
 8029510:	f7e1 fd8a 	bl	800b028 <lv_obj_get_style_list>
 8029514:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 8029516:	4b89      	ldr	r3, [pc, #548]	; (802973c <theme_apply+0x900>)
 8029518:	681b      	ldr	r3, [r3, #0]
 802951a:	3304      	adds	r3, #4
 802951c:	4619      	mov	r1, r3
 802951e:	6978      	ldr	r0, [r7, #20]
 8029520:	f7e5 ff8a 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_TABLE_PART_CELL1);
 8029524:	2101      	movs	r1, #1
 8029526:	68b8      	ldr	r0, [r7, #8]
 8029528:	f7e1 fd7e 	bl	800b028 <lv_obj_get_style_list>
 802952c:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->table_cell);
 802952e:	4b83      	ldr	r3, [pc, #524]	; (802973c <theme_apply+0x900>)
 8029530:	681b      	ldr	r3, [r3, #0]
 8029532:	33a4      	adds	r3, #164	; 0xa4
 8029534:	4619      	mov	r1, r3
 8029536:	6978      	ldr	r0, [r7, #20]
 8029538:	f7e5 ff7e 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_TABLE_PART_CELL2);
 802953c:	2102      	movs	r1, #2
 802953e:	68b8      	ldr	r0, [r7, #8]
 8029540:	f7e1 fd72 	bl	800b028 <lv_obj_get_style_list>
 8029544:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->table_cell);
 8029546:	4b7d      	ldr	r3, [pc, #500]	; (802973c <theme_apply+0x900>)
 8029548:	681b      	ldr	r3, [r3, #0]
 802954a:	33a4      	adds	r3, #164	; 0xa4
 802954c:	4619      	mov	r1, r3
 802954e:	6978      	ldr	r0, [r7, #20]
 8029550:	f7e5 ff72 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_TABLE_PART_CELL3);
 8029554:	2103      	movs	r1, #3
 8029556:	68b8      	ldr	r0, [r7, #8]
 8029558:	f7e1 fd66 	bl	800b028 <lv_obj_get_style_list>
 802955c:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->table_cell);
 802955e:	4b77      	ldr	r3, [pc, #476]	; (802973c <theme_apply+0x900>)
 8029560:	681b      	ldr	r3, [r3, #0]
 8029562:	33a4      	adds	r3, #164	; 0xa4
 8029564:	4619      	mov	r1, r3
 8029566:	6978      	ldr	r0, [r7, #20]
 8029568:	f7e5 ff66 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_TABLE_PART_CELL4);
 802956c:	2104      	movs	r1, #4
 802956e:	68b8      	ldr	r0, [r7, #8]
 8029570:	f7e1 fd5a 	bl	800b028 <lv_obj_get_style_list>
 8029574:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->table_cell);
 8029576:	4b71      	ldr	r3, [pc, #452]	; (802973c <theme_apply+0x900>)
 8029578:	681b      	ldr	r3, [r3, #0]
 802957a:	33a4      	adds	r3, #164	; 0xa4
 802957c:	4619      	mov	r1, r3
 802957e:	6978      	ldr	r0, [r7, #20]
 8029580:	f7e5 ff5a 	bl	800f438 <_lv_style_list_add_style>
            break;
 8029584:	e136      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_WIN
        case LV_THEME_WIN:
            list = lv_obj_get_style_list(obj, LV_WIN_PART_BG);
 8029586:	2100      	movs	r1, #0
 8029588:	68b8      	ldr	r0, [r7, #8]
 802958a:	f7e1 fd4d 	bl	800b028 <lv_obj_get_style_list>
 802958e:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->scr);
 8029590:	4b6a      	ldr	r3, [pc, #424]	; (802973c <theme_apply+0x900>)
 8029592:	681b      	ldr	r3, [r3, #0]
 8029594:	4619      	mov	r1, r3
 8029596:	6978      	ldr	r0, [r7, #20]
 8029598:	f7e5 ff4e 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_WIN_PART_SCROLLBAR);
 802959c:	2142      	movs	r1, #66	; 0x42
 802959e:	68b8      	ldr	r0, [r7, #8]
 80295a0:	f7e1 fd42 	bl	800b028 <lv_obj_get_style_list>
 80295a4:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->sb);
 80295a6:	4b65      	ldr	r3, [pc, #404]	; (802973c <theme_apply+0x900>)
 80295a8:	681b      	ldr	r3, [r3, #0]
 80295aa:	3384      	adds	r3, #132	; 0x84
 80295ac:	4619      	mov	r1, r3
 80295ae:	6978      	ldr	r0, [r7, #20]
 80295b0:	f7e5 ff42 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_WIN_PART_CONTENT_SCROLLABLE);
 80295b4:	2141      	movs	r1, #65	; 0x41
 80295b6:	68b8      	ldr	r0, [r7, #8]
 80295b8:	f7e1 fd36 	bl	800b028 <lv_obj_get_style_list>
 80295bc:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->tabview_page_scrl);
 80295be:	4b5f      	ldr	r3, [pc, #380]	; (802973c <theme_apply+0x900>)
 80295c0:	681b      	ldr	r3, [r3, #0]
 80295c2:	33b4      	adds	r3, #180	; 0xb4
 80295c4:	4619      	mov	r1, r3
 80295c6:	6978      	ldr	r0, [r7, #20]
 80295c8:	f7e5 ff36 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_WIN_PART_HEADER);
 80295cc:	2140      	movs	r1, #64	; 0x40
 80295ce:	68b8      	ldr	r0, [r7, #8]
 80295d0:	f7e1 fd2a 	bl	800b028 <lv_obj_get_style_list>
 80295d4:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->tabview_btns_bg);
 80295d6:	4b59      	ldr	r3, [pc, #356]	; (802973c <theme_apply+0x900>)
 80295d8:	681b      	ldr	r3, [r3, #0]
 80295da:	33ac      	adds	r3, #172	; 0xac
 80295dc:	4619      	mov	r1, r3
 80295de:	6978      	ldr	r0, [r7, #20]
 80295e0:	f7e5 ff2a 	bl	800f438 <_lv_style_list_add_style>
            break;
 80295e4:	e106      	b.n	80297f4 <theme_apply+0x9b8>

        case LV_THEME_WIN_BTN:
            list = lv_obj_get_style_list(obj, LV_BTN_PART_MAIN);
 80295e6:	2100      	movs	r1, #0
 80295e8:	68b8      	ldr	r0, [r7, #8]
 80295ea:	f7e1 fd1d 	bl	800b028 <lv_obj_get_style_list>
 80295ee:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->tabview_btns);
 80295f0:	4b52      	ldr	r3, [pc, #328]	; (802973c <theme_apply+0x900>)
 80295f2:	681b      	ldr	r3, [r3, #0]
 80295f4:	33a8      	adds	r3, #168	; 0xa8
 80295f6:	4619      	mov	r1, r3
 80295f8:	6978      	ldr	r0, [r7, #20]
 80295fa:	f7e5 ff1d 	bl	800f438 <_lv_style_list_add_style>
            break;
 80295fe:	e0f9      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_TEXTAREA
        case LV_THEME_TEXTAREA:
            list = lv_obj_get_style_list(obj, LV_TEXTAREA_PART_BG);
 8029600:	2100      	movs	r1, #0
 8029602:	68b8      	ldr	r0, [r7, #8]
 8029604:	f7e1 fd10 	bl	800b028 <lv_obj_get_style_list>
 8029608:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 802960a:	4b4c      	ldr	r3, [pc, #304]	; (802973c <theme_apply+0x900>)
 802960c:	681b      	ldr	r3, [r3, #0]
 802960e:	3304      	adds	r3, #4
 8029610:	4619      	mov	r1, r3
 8029612:	6978      	ldr	r0, [r7, #20]
 8029614:	f7e5 ff10 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->pad_small);
 8029618:	4b48      	ldr	r3, [pc, #288]	; (802973c <theme_apply+0x900>)
 802961a:	681b      	ldr	r3, [r3, #0]
 802961c:	3318      	adds	r3, #24
 802961e:	4619      	mov	r1, r3
 8029620:	6978      	ldr	r0, [r7, #20]
 8029622:	f7e5 ff09 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_TEXTAREA_PART_PLACEHOLDER);
 8029626:	2104      	movs	r1, #4
 8029628:	68b8      	ldr	r0, [r7, #8]
 802962a:	f7e1 fcfd 	bl	800b028 <lv_obj_get_style_list>
 802962e:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->ta_placeholder);
 8029630:	4b42      	ldr	r3, [pc, #264]	; (802973c <theme_apply+0x900>)
 8029632:	681b      	ldr	r3, [r3, #0]
 8029634:	33bc      	adds	r3, #188	; 0xbc
 8029636:	4619      	mov	r1, r3
 8029638:	6978      	ldr	r0, [r7, #20]
 802963a:	f7e5 fefd 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_TEXTAREA_PART_CURSOR);
 802963e:	2103      	movs	r1, #3
 8029640:	68b8      	ldr	r0, [r7, #8]
 8029642:	f7e1 fcf1 	bl	800b028 <lv_obj_get_style_list>
 8029646:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->ta_cursor);
 8029648:	4b3c      	ldr	r3, [pc, #240]	; (802973c <theme_apply+0x900>)
 802964a:	681b      	ldr	r3, [r3, #0]
 802964c:	33b8      	adds	r3, #184	; 0xb8
 802964e:	4619      	mov	r1, r3
 8029650:	6978      	ldr	r0, [r7, #20]
 8029652:	f7e5 fef1 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_TEXTAREA_PART_SCROLLBAR);
 8029656:	2101      	movs	r1, #1
 8029658:	68b8      	ldr	r0, [r7, #8]
 802965a:	f7e1 fce5 	bl	800b028 <lv_obj_get_style_list>
 802965e:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->sb);
 8029660:	4b36      	ldr	r3, [pc, #216]	; (802973c <theme_apply+0x900>)
 8029662:	681b      	ldr	r3, [r3, #0]
 8029664:	3384      	adds	r3, #132	; 0x84
 8029666:	4619      	mov	r1, r3
 8029668:	6978      	ldr	r0, [r7, #20]
 802966a:	f7e5 fee5 	bl	800f438 <_lv_style_list_add_style>
            break;
 802966e:	e0c1      	b.n	80297f4 <theme_apply+0x9b8>
#endif


#if LV_USE_SPINBOX
        case LV_THEME_SPINBOX:
            list = lv_obj_get_style_list(obj, LV_SPINBOX_PART_BG);
 8029670:	2100      	movs	r1, #0
 8029672:	68b8      	ldr	r0, [r7, #8]
 8029674:	f7e1 fcd8 	bl	800b028 <lv_obj_get_style_list>
 8029678:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 802967a:	4b30      	ldr	r3, [pc, #192]	; (802973c <theme_apply+0x900>)
 802967c:	681b      	ldr	r3, [r3, #0]
 802967e:	3304      	adds	r3, #4
 8029680:	4619      	mov	r1, r3
 8029682:	6978      	ldr	r0, [r7, #20]
 8029684:	f7e5 fed8 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->pad_small);
 8029688:	4b2c      	ldr	r3, [pc, #176]	; (802973c <theme_apply+0x900>)
 802968a:	681b      	ldr	r3, [r3, #0]
 802968c:	3318      	adds	r3, #24
 802968e:	4619      	mov	r1, r3
 8029690:	6978      	ldr	r0, [r7, #20]
 8029692:	f7e5 fed1 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_SPINBOX_PART_CURSOR);
 8029696:	2103      	movs	r1, #3
 8029698:	68b8      	ldr	r0, [r7, #8]
 802969a:	f7e1 fcc5 	bl	800b028 <lv_obj_get_style_list>
 802969e:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->spinbox_cursor);
 80296a0:	4b26      	ldr	r3, [pc, #152]	; (802973c <theme_apply+0x900>)
 80296a2:	681b      	ldr	r3, [r3, #0]
 80296a4:	339c      	adds	r3, #156	; 0x9c
 80296a6:	4619      	mov	r1, r3
 80296a8:	6978      	ldr	r0, [r7, #20]
 80296aa:	f7e5 fec5 	bl	800f438 <_lv_style_list_add_style>
            break;
 80296ae:	e0a1      	b.n	80297f4 <theme_apply+0x9b8>

        case LV_THEME_SPINBOX_BTN:
            list = lv_obj_get_style_list(obj, LV_BTN_PART_MAIN);
 80296b0:	2100      	movs	r1, #0
 80296b2:	68b8      	ldr	r0, [r7, #8]
 80296b4:	f7e1 fcb8 	bl	800b028 <lv_obj_get_style_list>
 80296b8:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 80296ba:	4b20      	ldr	r3, [pc, #128]	; (802973c <theme_apply+0x900>)
 80296bc:	681b      	ldr	r3, [r3, #0]
 80296be:	3304      	adds	r3, #4
 80296c0:	4619      	mov	r1, r3
 80296c2:	6978      	ldr	r0, [r7, #20]
 80296c4:	f7e5 feb8 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->bg_click);
 80296c8:	4b1c      	ldr	r3, [pc, #112]	; (802973c <theme_apply+0x900>)
 80296ca:	681b      	ldr	r3, [r3, #0]
 80296cc:	3308      	adds	r3, #8
 80296ce:	4619      	mov	r1, r3
 80296d0:	6978      	ldr	r0, [r7, #20]
 80296d2:	f7e5 feb1 	bl	800f438 <_lv_style_list_add_style>
            break;
 80296d6:	e08d      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_CALENDAR
        case LV_THEME_CALENDAR:
            list = lv_obj_get_style_list(obj, LV_CALENDAR_PART_BG);
 80296d8:	2100      	movs	r1, #0
 80296da:	68b8      	ldr	r0, [r7, #8]
 80296dc:	f7e1 fca4 	bl	800b028 <lv_obj_get_style_list>
 80296e0:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 80296e2:	4b16      	ldr	r3, [pc, #88]	; (802973c <theme_apply+0x900>)
 80296e4:	681b      	ldr	r3, [r3, #0]
 80296e6:	3304      	adds	r3, #4
 80296e8:	4619      	mov	r1, r3
 80296ea:	6978      	ldr	r0, [r7, #20]
 80296ec:	f7e5 fea4 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_CALENDAR_PART_DATE);
 80296f0:	2103      	movs	r1, #3
 80296f2:	68b8      	ldr	r0, [r7, #8]
 80296f4:	f7e1 fc98 	bl	800b028 <lv_obj_get_style_list>
 80296f8:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->calendar_date_nums);
 80296fa:	4b10      	ldr	r3, [pc, #64]	; (802973c <theme_apply+0x900>)
 80296fc:	681b      	ldr	r3, [r3, #0]
 80296fe:	3330      	adds	r3, #48	; 0x30
 8029700:	4619      	mov	r1, r3
 8029702:	6978      	ldr	r0, [r7, #20]
 8029704:	f7e5 fe98 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_CALENDAR_PART_HEADER);
 8029708:	2101      	movs	r1, #1
 802970a:	68b8      	ldr	r0, [r7, #8]
 802970c:	f7e1 fc8c 	bl	800b028 <lv_obj_get_style_list>
 8029710:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->calendar_header);
 8029712:	4b0a      	ldr	r3, [pc, #40]	; (802973c <theme_apply+0x900>)
 8029714:	681b      	ldr	r3, [r3, #0]
 8029716:	3334      	adds	r3, #52	; 0x34
 8029718:	4619      	mov	r1, r3
 802971a:	6978      	ldr	r0, [r7, #20]
 802971c:	f7e5 fe8c 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_CALENDAR_PART_DAY_NAMES);
 8029720:	2102      	movs	r1, #2
 8029722:	68b8      	ldr	r0, [r7, #8]
 8029724:	f7e1 fc80 	bl	800b028 <lv_obj_get_style_list>
 8029728:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->calendar_daynames);
 802972a:	4b04      	ldr	r3, [pc, #16]	; (802973c <theme_apply+0x900>)
 802972c:	681b      	ldr	r3, [r3, #0]
 802972e:	3338      	adds	r3, #56	; 0x38
 8029730:	4619      	mov	r1, r3
 8029732:	6978      	ldr	r0, [r7, #20]
 8029734:	f7e5 fe80 	bl	800f438 <_lv_style_list_add_style>
            break;
 8029738:	e05c      	b.n	80297f4 <theme_apply+0x9b8>
 802973a:	bf00      	nop
 802973c:	20012350 	.word	0x20012350
#endif
#if LV_USE_CPICKER
        case LV_THEME_CPICKER:
            list = lv_obj_get_style_list(obj, LV_CPICKER_PART_MAIN);
 8029740:	2100      	movs	r1, #0
 8029742:	68b8      	ldr	r0, [r7, #8]
 8029744:	f7e1 fc70 	bl	800b028 <lv_obj_get_style_list>
 8029748:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->cpicker_bg);
 802974a:	4b2f      	ldr	r3, [pc, #188]	; (8029808 <theme_apply+0x9cc>)
 802974c:	681b      	ldr	r3, [r3, #0]
 802974e:	333c      	adds	r3, #60	; 0x3c
 8029750:	4619      	mov	r1, r3
 8029752:	6978      	ldr	r0, [r7, #20]
 8029754:	f7e5 fe70 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_CPICKER_PART_KNOB);
 8029758:	2101      	movs	r1, #1
 802975a:	68b8      	ldr	r0, [r7, #8]
 802975c:	f7e1 fc64 	bl	800b028 <lv_obj_get_style_list>
 8029760:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->cpicker_indic);
 8029762:	4b29      	ldr	r3, [pc, #164]	; (8029808 <theme_apply+0x9cc>)
 8029764:	681b      	ldr	r3, [r3, #0]
 8029766:	3340      	adds	r3, #64	; 0x40
 8029768:	4619      	mov	r1, r3
 802976a:	6978      	ldr	r0, [r7, #20]
 802976c:	f7e5 fe64 	bl	800f438 <_lv_style_list_add_style>
            break;
 8029770:	e040      	b.n	80297f4 <theme_apply+0x9b8>
#endif

#if LV_USE_LINEMETER
        case LV_THEME_LINEMETER:
            list = lv_obj_get_style_list(obj, LV_LINEMETER_PART_MAIN);
 8029772:	2100      	movs	r1, #0
 8029774:	68b8      	ldr	r0, [r7, #8]
 8029776:	f7e1 fc57 	bl	800b028 <lv_obj_get_style_list>
 802977a:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 802977c:	4b22      	ldr	r3, [pc, #136]	; (8029808 <theme_apply+0x9cc>)
 802977e:	681b      	ldr	r3, [r3, #0]
 8029780:	3304      	adds	r3, #4
 8029782:	4619      	mov	r1, r3
 8029784:	6978      	ldr	r0, [r7, #20]
 8029786:	f7e5 fe57 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->lmeter);
 802978a:	4b1f      	ldr	r3, [pc, #124]	; (8029808 <theme_apply+0x9cc>)
 802978c:	681b      	ldr	r3, [r3, #0]
 802978e:	3374      	adds	r3, #116	; 0x74
 8029790:	4619      	mov	r1, r3
 8029792:	6978      	ldr	r0, [r7, #20]
 8029794:	f7e5 fe50 	bl	800f438 <_lv_style_list_add_style>
            break;
 8029798:	e02c      	b.n	80297f4 <theme_apply+0x9b8>
#endif
#if LV_USE_GAUGE
        case LV_THEME_GAUGE:
            list = lv_obj_get_style_list(obj, LV_GAUGE_PART_MAIN);
 802979a:	2100      	movs	r1, #0
 802979c:	68b8      	ldr	r0, [r7, #8]
 802979e:	f7e1 fc43 	bl	800b028 <lv_obj_get_style_list>
 80297a2:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->bg);
 80297a4:	4b18      	ldr	r3, [pc, #96]	; (8029808 <theme_apply+0x9cc>)
 80297a6:	681b      	ldr	r3, [r3, #0]
 80297a8:	3304      	adds	r3, #4
 80297aa:	4619      	mov	r1, r3
 80297ac:	6978      	ldr	r0, [r7, #20]
 80297ae:	f7e5 fe43 	bl	800f438 <_lv_style_list_add_style>
            _lv_style_list_add_style(list, &styles->gauge_main);
 80297b2:	4b15      	ldr	r3, [pc, #84]	; (8029808 <theme_apply+0x9cc>)
 80297b4:	681b      	ldr	r3, [r3, #0]
 80297b6:	3360      	adds	r3, #96	; 0x60
 80297b8:	4619      	mov	r1, r3
 80297ba:	6978      	ldr	r0, [r7, #20]
 80297bc:	f7e5 fe3c 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_GAUGE_PART_MAJOR);
 80297c0:	2101      	movs	r1, #1
 80297c2:	68b8      	ldr	r0, [r7, #8]
 80297c4:	f7e1 fc30 	bl	800b028 <lv_obj_get_style_list>
 80297c8:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->gauge_strong);
 80297ca:	4b0f      	ldr	r3, [pc, #60]	; (8029808 <theme_apply+0x9cc>)
 80297cc:	681b      	ldr	r3, [r3, #0]
 80297ce:	3364      	adds	r3, #100	; 0x64
 80297d0:	4619      	mov	r1, r3
 80297d2:	6978      	ldr	r0, [r7, #20]
 80297d4:	f7e5 fe30 	bl	800f438 <_lv_style_list_add_style>

            list = lv_obj_get_style_list(obj, LV_GAUGE_PART_NEEDLE);
 80297d8:	2102      	movs	r1, #2
 80297da:	68b8      	ldr	r0, [r7, #8]
 80297dc:	f7e1 fc24 	bl	800b028 <lv_obj_get_style_list>
 80297e0:	6178      	str	r0, [r7, #20]
            _lv_style_list_add_style(list, &styles->gauge_needle);
 80297e2:	4b09      	ldr	r3, [pc, #36]	; (8029808 <theme_apply+0x9cc>)
 80297e4:	681b      	ldr	r3, [r3, #0]
 80297e6:	3368      	adds	r3, #104	; 0x68
 80297e8:	4619      	mov	r1, r3
 80297ea:	6978      	ldr	r0, [r7, #20]
 80297ec:	f7e5 fe24 	bl	800f438 <_lv_style_list_add_style>
            break;
 80297f0:	e000      	b.n	80297f4 <theme_apply+0x9b8>
#endif
        default:
            break;
 80297f2:	bf00      	nop
    }

    lv_obj_refresh_style(obj, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
 80297f4:	22ff      	movs	r2, #255	; 0xff
 80297f6:	21ff      	movs	r1, #255	; 0xff
 80297f8:	68b8      	ldr	r0, [r7, #8]
 80297fa:	f7e0 fd81 	bl	800a300 <lv_obj_refresh_style>
}
 80297fe:	bf00      	nop
 8029800:	3718      	adds	r7, #24
 8029802:	46bd      	mov	sp, r7
 8029804:	bd80      	pop	{r7, pc}
 8029806:	bf00      	nop
 8029808:	20012350 	.word	0x20012350

0802980c <style_init_reset>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void style_init_reset(lv_style_t * style)
{
 802980c:	b580      	push	{r7, lr}
 802980e:	b082      	sub	sp, #8
 8029810:	af00      	add	r7, sp, #0
 8029812:	6078      	str	r0, [r7, #4]
    if(inited) lv_style_reset(style);
 8029814:	4b07      	ldr	r3, [pc, #28]	; (8029834 <style_init_reset+0x28>)
 8029816:	781b      	ldrb	r3, [r3, #0]
 8029818:	2b00      	cmp	r3, #0
 802981a:	d003      	beq.n	8029824 <style_init_reset+0x18>
 802981c:	6878      	ldr	r0, [r7, #4]
 802981e:	f7e5 ffa6 	bl	800f76e <lv_style_reset>
    else lv_style_init(style);
}
 8029822:	e002      	b.n	802982a <style_init_reset+0x1e>
    else lv_style_init(style);
 8029824:	6878      	ldr	r0, [r7, #4]
 8029826:	f7e5 fc94 	bl	800f152 <lv_style_init>
}
 802982a:	bf00      	nop
 802982c:	3708      	adds	r7, #8
 802982e:	46bd      	mov	sp, r7
 8029830:	bd80      	pop	{r7, pc}
 8029832:	bf00      	nop
 8029834:	20012354 	.word	0x20012354

08029838 <_lv_memcpy_small>:
 * @param dst pointer to the destination buffer
 * @param src pointer to the source buffer
 * @param len number of byte to copy
 */
LV_ATTRIBUTE_FAST_MEM static inline void * _lv_memcpy_small(void * dst, const void * src, size_t len)
{
 8029838:	b480      	push	{r7}
 802983a:	b087      	sub	sp, #28
 802983c:	af00      	add	r7, sp, #0
 802983e:	60f8      	str	r0, [r7, #12]
 8029840:	60b9      	str	r1, [r7, #8]
 8029842:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 8029844:	68fb      	ldr	r3, [r7, #12]
 8029846:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 8029848:	68bb      	ldr	r3, [r7, #8]
 802984a:	613b      	str	r3, [r7, #16]

    while(len) {
 802984c:	e00c      	b.n	8029868 <_lv_memcpy_small+0x30>
        *d8 = *s8;
 802984e:	693b      	ldr	r3, [r7, #16]
 8029850:	781a      	ldrb	r2, [r3, #0]
 8029852:	697b      	ldr	r3, [r7, #20]
 8029854:	701a      	strb	r2, [r3, #0]
        d8++;
 8029856:	697b      	ldr	r3, [r7, #20]
 8029858:	3301      	adds	r3, #1
 802985a:	617b      	str	r3, [r7, #20]
        s8++;
 802985c:	693b      	ldr	r3, [r7, #16]
 802985e:	3301      	adds	r3, #1
 8029860:	613b      	str	r3, [r7, #16]
        len--;
 8029862:	687b      	ldr	r3, [r7, #4]
 8029864:	3b01      	subs	r3, #1
 8029866:	607b      	str	r3, [r7, #4]
    while(len) {
 8029868:	687b      	ldr	r3, [r7, #4]
 802986a:	2b00      	cmp	r3, #0
 802986c:	d1ef      	bne.n	802984e <_lv_memcpy_small+0x16>
    }

    return dst;
 802986e:	68fb      	ldr	r3, [r7, #12]
}
 8029870:	4618      	mov	r0, r3
 8029872:	371c      	adds	r7, #28
 8029874:	46bd      	mov	sp, r7
 8029876:	f85d 7b04 	ldr.w	r7, [sp], #4
 802987a:	4770      	bx	lr

0802987c <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 802987c:	b580      	push	{r7, lr}
 802987e:	b082      	sub	sp, #8
 8029880:	af00      	add	r7, sp, #0
 8029882:	6078      	str	r0, [r7, #4]
 8029884:	6039      	str	r1, [r7, #0]
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
 8029886:	2208      	movs	r2, #8
 8029888:	6839      	ldr	r1, [r7, #0]
 802988a:	6878      	ldr	r0, [r7, #4]
 802988c:	f7ff ffd4 	bl	8029838 <_lv_memcpy_small>
}
 8029890:	bf00      	nop
 8029892:	3708      	adds	r7, #8
 8029894:	46bd      	mov	sp, r7
 8029896:	bd80      	pop	{r7, pc}

08029898 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 8029898:	b480      	push	{r7}
 802989a:	b083      	sub	sp, #12
 802989c:	af00      	add	r7, sp, #0
 802989e:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 80298a0:	687b      	ldr	r3, [r7, #4]
 80298a2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80298a6:	b29a      	uxth	r2, r3
 80298a8:	687b      	ldr	r3, [r7, #4]
 80298aa:	f9b3 3000 	ldrsh.w	r3, [r3]
 80298ae:	b29b      	uxth	r3, r3
 80298b0:	1ad3      	subs	r3, r2, r3
 80298b2:	b29b      	uxth	r3, r3
 80298b4:	3301      	adds	r3, #1
 80298b6:	b29b      	uxth	r3, r3
 80298b8:	b21b      	sxth	r3, r3
}
 80298ba:	4618      	mov	r0, r3
 80298bc:	370c      	adds	r7, #12
 80298be:	46bd      	mov	sp, r7
 80298c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80298c4:	4770      	bx	lr

080298c6 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 80298c6:	b480      	push	{r7}
 80298c8:	b083      	sub	sp, #12
 80298ca:	af00      	add	r7, sp, #0
 80298cc:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 80298ce:	687b      	ldr	r3, [r7, #4]
 80298d0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80298d4:	b29a      	uxth	r2, r3
 80298d6:	687b      	ldr	r3, [r7, #4]
 80298d8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80298dc:	b29b      	uxth	r3, r3
 80298de:	1ad3      	subs	r3, r2, r3
 80298e0:	b29b      	uxth	r3, r3
 80298e2:	3301      	adds	r3, #1
 80298e4:	b29b      	uxth	r3, r3
 80298e6:	b21b      	sxth	r3, r3
}
 80298e8:	4618      	mov	r0, r3
 80298ea:	370c      	adds	r7, #12
 80298ec:	46bd      	mov	sp, r7
 80298ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80298f2:	4770      	bx	lr

080298f4 <lv_obj_get_style_pad_top>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(OPA_SCALE, opa_scale, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
 80298f4:	b580      	push	{r7, lr}
 80298f6:	b082      	sub	sp, #8
 80298f8:	af00      	add	r7, sp, #0
 80298fa:	6078      	str	r0, [r7, #4]
 80298fc:	460b      	mov	r3, r1
 80298fe:	70fb      	strb	r3, [r7, #3]
 8029900:	78fb      	ldrb	r3, [r7, #3]
 8029902:	2210      	movs	r2, #16
 8029904:	4619      	mov	r1, r3
 8029906:	6878      	ldr	r0, [r7, #4]
 8029908:	f7e1 fbb2 	bl	800b070 <_lv_obj_get_style_int>
 802990c:	4603      	mov	r3, r0
 802990e:	4618      	mov	r0, r3
 8029910:	3708      	adds	r7, #8
 8029912:	46bd      	mov	sp, r7
 8029914:	bd80      	pop	{r7, pc}

08029916 <lv_obj_get_style_pad_bottom>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
 8029916:	b580      	push	{r7, lr}
 8029918:	b082      	sub	sp, #8
 802991a:	af00      	add	r7, sp, #0
 802991c:	6078      	str	r0, [r7, #4]
 802991e:	460b      	mov	r3, r1
 8029920:	70fb      	strb	r3, [r7, #3]
 8029922:	78fb      	ldrb	r3, [r7, #3]
 8029924:	2211      	movs	r2, #17
 8029926:	4619      	mov	r1, r3
 8029928:	6878      	ldr	r0, [r7, #4]
 802992a:	f7e1 fba1 	bl	800b070 <_lv_obj_get_style_int>
 802992e:	4603      	mov	r3, r0
 8029930:	4618      	mov	r0, r3
 8029932:	3708      	adds	r7, #8
 8029934:	46bd      	mov	sp, r7
 8029936:	bd80      	pop	{r7, pc}

08029938 <lv_obj_get_style_pad_left>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
 8029938:	b580      	push	{r7, lr}
 802993a:	b082      	sub	sp, #8
 802993c:	af00      	add	r7, sp, #0
 802993e:	6078      	str	r0, [r7, #4]
 8029940:	460b      	mov	r3, r1
 8029942:	70fb      	strb	r3, [r7, #3]
 8029944:	78fb      	ldrb	r3, [r7, #3]
 8029946:	2212      	movs	r2, #18
 8029948:	4619      	mov	r1, r3
 802994a:	6878      	ldr	r0, [r7, #4]
 802994c:	f7e1 fb90 	bl	800b070 <_lv_obj_get_style_int>
 8029950:	4603      	mov	r3, r0
 8029952:	4618      	mov	r0, r3
 8029954:	3708      	adds	r7, #8
 8029956:	46bd      	mov	sp, r7
 8029958:	bd80      	pop	{r7, pc}

0802995a <lv_obj_get_style_pad_right>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
 802995a:	b580      	push	{r7, lr}
 802995c:	b082      	sub	sp, #8
 802995e:	af00      	add	r7, sp, #0
 8029960:	6078      	str	r0, [r7, #4]
 8029962:	460b      	mov	r3, r1
 8029964:	70fb      	strb	r3, [r7, #3]
 8029966:	78fb      	ldrb	r3, [r7, #3]
 8029968:	2213      	movs	r2, #19
 802996a:	4619      	mov	r1, r3
 802996c:	6878      	ldr	r0, [r7, #4]
 802996e:	f7e1 fb7f 	bl	800b070 <_lv_obj_get_style_int>
 8029972:	4603      	mov	r3, r0
 8029974:	4618      	mov	r0, r3
 8029976:	3708      	adds	r7, #8
 8029978:	46bd      	mov	sp, r7
 802997a:	bd80      	pop	{r7, pc}

0802997c <lv_obj_get_style_pad_inner>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_INNER, pad_inner, lv_style_int_t, _int, scalar)
 802997c:	b580      	push	{r7, lr}
 802997e:	b082      	sub	sp, #8
 8029980:	af00      	add	r7, sp, #0
 8029982:	6078      	str	r0, [r7, #4]
 8029984:	460b      	mov	r3, r1
 8029986:	70fb      	strb	r3, [r7, #3]
 8029988:	78fb      	ldrb	r3, [r7, #3]
 802998a:	2214      	movs	r2, #20
 802998c:	4619      	mov	r1, r3
 802998e:	6878      	ldr	r0, [r7, #4]
 8029990:	f7e1 fb6e 	bl	800b070 <_lv_obj_get_style_int>
 8029994:	4603      	mov	r3, r0
 8029996:	4618      	mov	r0, r3
 8029998:	3708      	adds	r7, #8
 802999a:	46bd      	mov	sp, r7
 802999c:	bd80      	pop	{r7, pc}

0802999e <lv_obj_get_style_margin_top>:
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_TOP, margin_top, lv_style_int_t, _int, scalar)
 802999e:	b580      	push	{r7, lr}
 80299a0:	b082      	sub	sp, #8
 80299a2:	af00      	add	r7, sp, #0
 80299a4:	6078      	str	r0, [r7, #4]
 80299a6:	460b      	mov	r3, r1
 80299a8:	70fb      	strb	r3, [r7, #3]
 80299aa:	78fb      	ldrb	r3, [r7, #3]
 80299ac:	2215      	movs	r2, #21
 80299ae:	4619      	mov	r1, r3
 80299b0:	6878      	ldr	r0, [r7, #4]
 80299b2:	f7e1 fb5d 	bl	800b070 <_lv_obj_get_style_int>
 80299b6:	4603      	mov	r3, r0
 80299b8:	4618      	mov	r0, r3
 80299ba:	3708      	adds	r7, #8
 80299bc:	46bd      	mov	sp, r7
 80299be:	bd80      	pop	{r7, pc}

080299c0 <lv_obj_get_style_margin_bottom>:
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_BOTTOM, margin_bottom, lv_style_int_t, _int, scalar)
 80299c0:	b580      	push	{r7, lr}
 80299c2:	b082      	sub	sp, #8
 80299c4:	af00      	add	r7, sp, #0
 80299c6:	6078      	str	r0, [r7, #4]
 80299c8:	460b      	mov	r3, r1
 80299ca:	70fb      	strb	r3, [r7, #3]
 80299cc:	78fb      	ldrb	r3, [r7, #3]
 80299ce:	2216      	movs	r2, #22
 80299d0:	4619      	mov	r1, r3
 80299d2:	6878      	ldr	r0, [r7, #4]
 80299d4:	f7e1 fb4c 	bl	800b070 <_lv_obj_get_style_int>
 80299d8:	4603      	mov	r3, r0
 80299da:	4618      	mov	r0, r3
 80299dc:	3708      	adds	r7, #8
 80299de:	46bd      	mov	sp, r7
 80299e0:	bd80      	pop	{r7, pc}

080299e2 <lv_obj_get_style_margin_left>:
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_LEFT, margin_left, lv_style_int_t, _int, scalar)
 80299e2:	b580      	push	{r7, lr}
 80299e4:	b082      	sub	sp, #8
 80299e6:	af00      	add	r7, sp, #0
 80299e8:	6078      	str	r0, [r7, #4]
 80299ea:	460b      	mov	r3, r1
 80299ec:	70fb      	strb	r3, [r7, #3]
 80299ee:	78fb      	ldrb	r3, [r7, #3]
 80299f0:	2217      	movs	r2, #23
 80299f2:	4619      	mov	r1, r3
 80299f4:	6878      	ldr	r0, [r7, #4]
 80299f6:	f7e1 fb3b 	bl	800b070 <_lv_obj_get_style_int>
 80299fa:	4603      	mov	r3, r0
 80299fc:	4618      	mov	r0, r3
 80299fe:	3708      	adds	r7, #8
 8029a00:	46bd      	mov	sp, r7
 8029a02:	bd80      	pop	{r7, pc}

08029a04 <lv_obj_get_style_margin_right>:
_LV_OBJ_STYLE_SET_GET_DECLARE(MARGIN_RIGHT, margin_right, lv_style_int_t, _int, scalar)
 8029a04:	b580      	push	{r7, lr}
 8029a06:	b082      	sub	sp, #8
 8029a08:	af00      	add	r7, sp, #0
 8029a0a:	6078      	str	r0, [r7, #4]
 8029a0c:	460b      	mov	r3, r1
 8029a0e:	70fb      	strb	r3, [r7, #3]
 8029a10:	78fb      	ldrb	r3, [r7, #3]
 8029a12:	2218      	movs	r2, #24
 8029a14:	4619      	mov	r1, r3
 8029a16:	6878      	ldr	r0, [r7, #4]
 8029a18:	f7e1 fb2a 	bl	800b070 <_lv_obj_get_style_int>
 8029a1c:	4603      	mov	r3, r0
 8029a1e:	4618      	mov	r0, r3
 8029a20:	3708      	adds	r7, #8
 8029a22:	46bd      	mov	sp, r7
 8029a24:	bd80      	pop	{r7, pc}
	...

08029a28 <lv_cont_create>:
 * @param par pointer to an object, it will be the parent of the new container
 * @param copy pointer to a container object, if not NULL then the new object will be copied from it
 * @return pointer to the created container
 */
lv_obj_t * lv_cont_create(lv_obj_t * par, const lv_obj_t * copy)
{
 8029a28:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8029a2c:	b086      	sub	sp, #24
 8029a2e:	af00      	add	r7, sp, #0
 8029a30:	6078      	str	r0, [r7, #4]
 8029a32:	6039      	str	r1, [r7, #0]

    LV_LOG_TRACE("container create started");

    /*Create a basic object*/
    lv_obj_t * cont = lv_obj_create(par, copy);
 8029a34:	6839      	ldr	r1, [r7, #0]
 8029a36:	6878      	ldr	r0, [r7, #4]
 8029a38:	f7df fc7a 	bl	8009330 <lv_obj_create>
 8029a3c:	6178      	str	r0, [r7, #20]
    LV_ASSERT_MEM(cont);
 8029a3e:	6978      	ldr	r0, [r7, #20]
 8029a40:	f7f6 fb56 	bl	80200f0 <lv_debug_check_null>
 8029a44:	4603      	mov	r3, r0
 8029a46:	f083 0301 	eor.w	r3, r3, #1
 8029a4a:	b2db      	uxtb	r3, r3
 8029a4c:	2b00      	cmp	r3, #0
 8029a4e:	d009      	beq.n	8029a64 <lv_cont_create+0x3c>
 8029a50:	697b      	ldr	r3, [r7, #20]
 8029a52:	2200      	movs	r2, #0
 8029a54:	4698      	mov	r8, r3
 8029a56:	4691      	mov	r9, r2
 8029a58:	4642      	mov	r2, r8
 8029a5a:	464b      	mov	r3, r9
 8029a5c:	4854      	ldr	r0, [pc, #336]	; (8029bb0 <lv_cont_create+0x188>)
 8029a5e:	f7f6 fb57 	bl	8020110 <lv_debug_log_error>
 8029a62:	e7fe      	b.n	8029a62 <lv_cont_create+0x3a>
    if(cont == NULL) return NULL;
 8029a64:	697b      	ldr	r3, [r7, #20]
 8029a66:	2b00      	cmp	r3, #0
 8029a68:	d101      	bne.n	8029a6e <lv_cont_create+0x46>
 8029a6a:	2300      	movs	r3, #0
 8029a6c:	e09a      	b.n	8029ba4 <lv_cont_create+0x17c>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(cont);
 8029a6e:	4b51      	ldr	r3, [pc, #324]	; (8029bb4 <lv_cont_create+0x18c>)
 8029a70:	681b      	ldr	r3, [r3, #0]
 8029a72:	2b00      	cmp	r3, #0
 8029a74:	d105      	bne.n	8029a82 <lv_cont_create+0x5a>
 8029a76:	6978      	ldr	r0, [r7, #20]
 8029a78:	f7e1 ffaa 	bl	800b9d0 <lv_obj_get_signal_cb>
 8029a7c:	4603      	mov	r3, r0
 8029a7e:	4a4d      	ldr	r2, [pc, #308]	; (8029bb4 <lv_cont_create+0x18c>)
 8029a80:	6013      	str	r3, [r2, #0]
    if(ancestor_design == NULL) ancestor_design = lv_obj_get_design_cb(cont);
 8029a82:	4b4d      	ldr	r3, [pc, #308]	; (8029bb8 <lv_cont_create+0x190>)
 8029a84:	681b      	ldr	r3, [r3, #0]
 8029a86:	2b00      	cmp	r3, #0
 8029a88:	d105      	bne.n	8029a96 <lv_cont_create+0x6e>
 8029a8a:	6978      	ldr	r0, [r7, #20]
 8029a8c:	f7e1 ffc0 	bl	800ba10 <lv_obj_get_design_cb>
 8029a90:	4603      	mov	r3, r0
 8029a92:	4a49      	ldr	r2, [pc, #292]	; (8029bb8 <lv_cont_create+0x190>)
 8029a94:	6013      	str	r3, [r2, #0]

    lv_obj_allocate_ext_attr(cont, sizeof(lv_cont_ext_t));
 8029a96:	2102      	movs	r1, #2
 8029a98:	6978      	ldr	r0, [r7, #20]
 8029a9a:	f7e1 f86b 	bl	800ab74 <lv_obj_allocate_ext_attr>
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 8029a9e:	6978      	ldr	r0, [r7, #20]
 8029aa0:	f7e1 ffd6 	bl	800ba50 <lv_obj_get_ext_attr>
 8029aa4:	6138      	str	r0, [r7, #16]
    if(ext == NULL) {
 8029aa6:	693b      	ldr	r3, [r7, #16]
 8029aa8:	2b00      	cmp	r3, #0
 8029aaa:	d104      	bne.n	8029ab6 <lv_cont_create+0x8e>
        lv_obj_del(cont);
 8029aac:	6978      	ldr	r0, [r7, #20]
 8029aae:	f7df ff1f 	bl	80098f0 <lv_obj_del>
        return NULL;
 8029ab2:	2300      	movs	r3, #0
 8029ab4:	e076      	b.n	8029ba4 <lv_cont_create+0x17c>
    }

    LV_ASSERT_MEM(ext);
 8029ab6:	6938      	ldr	r0, [r7, #16]
 8029ab8:	f7f6 fb1a 	bl	80200f0 <lv_debug_check_null>
 8029abc:	4603      	mov	r3, r0
 8029abe:	f083 0301 	eor.w	r3, r3, #1
 8029ac2:	b2db      	uxtb	r3, r3
 8029ac4:	2b00      	cmp	r3, #0
 8029ac6:	d009      	beq.n	8029adc <lv_cont_create+0xb4>
 8029ac8:	693b      	ldr	r3, [r7, #16]
 8029aca:	2200      	movs	r2, #0
 8029acc:	461c      	mov	r4, r3
 8029ace:	4615      	mov	r5, r2
 8029ad0:	4622      	mov	r2, r4
 8029ad2:	462b      	mov	r3, r5
 8029ad4:	4836      	ldr	r0, [pc, #216]	; (8029bb0 <lv_cont_create+0x188>)
 8029ad6:	f7f6 fb1b 	bl	8020110 <lv_debug_log_error>
 8029ada:	e7fe      	b.n	8029ada <lv_cont_create+0xb2>
    ext->fit_left   = LV_FIT_NONE;
 8029adc:	693a      	ldr	r2, [r7, #16]
 8029ade:	7813      	ldrb	r3, [r2, #0]
 8029ae0:	f36f 1305 	bfc	r3, #4, #2
 8029ae4:	7013      	strb	r3, [r2, #0]
    ext->fit_right  = LV_FIT_NONE;
 8029ae6:	693a      	ldr	r2, [r7, #16]
 8029ae8:	7813      	ldrb	r3, [r2, #0]
 8029aea:	f36f 1387 	bfc	r3, #6, #2
 8029aee:	7013      	strb	r3, [r2, #0]
    ext->fit_top    = LV_FIT_NONE;
 8029af0:	693a      	ldr	r2, [r7, #16]
 8029af2:	7853      	ldrb	r3, [r2, #1]
 8029af4:	f36f 0301 	bfc	r3, #0, #2
 8029af8:	7053      	strb	r3, [r2, #1]
    ext->fit_bottom = LV_FIT_NONE;
 8029afa:	693a      	ldr	r2, [r7, #16]
 8029afc:	7853      	ldrb	r3, [r2, #1]
 8029afe:	f36f 0383 	bfc	r3, #2, #2
 8029b02:	7053      	strb	r3, [r2, #1]
    ext->layout     = LV_LAYOUT_OFF;
 8029b04:	693a      	ldr	r2, [r7, #16]
 8029b06:	7813      	ldrb	r3, [r2, #0]
 8029b08:	f36f 0303 	bfc	r3, #0, #4
 8029b0c:	7013      	strb	r3, [r2, #0]

    lv_obj_set_signal_cb(cont, lv_cont_signal);
 8029b0e:	492b      	ldr	r1, [pc, #172]	; (8029bbc <lv_cont_create+0x194>)
 8029b10:	6978      	ldr	r0, [r7, #20]
 8029b12:	f7e0 ffcb 	bl	800aaac <lv_obj_set_signal_cb>

    /*Init the new container*/
    if(copy == NULL) {
 8029b16:	683b      	ldr	r3, [r7, #0]
 8029b18:	2b00      	cmp	r3, #0
 8029b1a:	d107      	bne.n	8029b2c <lv_cont_create+0x104>
        /*Set the default styles if it's not screen*/
        if(par != NULL) {
 8029b1c:	687b      	ldr	r3, [r7, #4]
 8029b1e:	2b00      	cmp	r3, #0
 8029b20:	d03f      	beq.n	8029ba2 <lv_cont_create+0x17a>
            lv_theme_apply(cont, LV_THEME_CONT);
 8029b22:	210b      	movs	r1, #11
 8029b24:	6978      	ldr	r0, [r7, #20]
 8029b26:	f7f9 f80b 	bl	8022b40 <lv_theme_apply>
 8029b2a:	e03a      	b.n	8029ba2 <lv_cont_create+0x17a>


    }
    /*Copy an existing object*/
    else {
        lv_cont_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 8029b2c:	6838      	ldr	r0, [r7, #0]
 8029b2e:	f7e1 ff8f 	bl	800ba50 <lv_obj_get_ext_attr>
 8029b32:	60f8      	str	r0, [r7, #12]
        ext->fit_left            = copy_ext->fit_left;
 8029b34:	68fb      	ldr	r3, [r7, #12]
 8029b36:	781b      	ldrb	r3, [r3, #0]
 8029b38:	f3c3 1301 	ubfx	r3, r3, #4, #2
 8029b3c:	b2d9      	uxtb	r1, r3
 8029b3e:	693a      	ldr	r2, [r7, #16]
 8029b40:	7813      	ldrb	r3, [r2, #0]
 8029b42:	f361 1305 	bfi	r3, r1, #4, #2
 8029b46:	7013      	strb	r3, [r2, #0]
        ext->fit_right           = copy_ext->fit_right;
 8029b48:	68fb      	ldr	r3, [r7, #12]
 8029b4a:	781b      	ldrb	r3, [r3, #0]
 8029b4c:	f3c3 1381 	ubfx	r3, r3, #6, #2
 8029b50:	b2d9      	uxtb	r1, r3
 8029b52:	693a      	ldr	r2, [r7, #16]
 8029b54:	7813      	ldrb	r3, [r2, #0]
 8029b56:	f361 1387 	bfi	r3, r1, #6, #2
 8029b5a:	7013      	strb	r3, [r2, #0]
        ext->fit_top             = copy_ext->fit_top;
 8029b5c:	68fb      	ldr	r3, [r7, #12]
 8029b5e:	785b      	ldrb	r3, [r3, #1]
 8029b60:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8029b64:	b2d9      	uxtb	r1, r3
 8029b66:	693a      	ldr	r2, [r7, #16]
 8029b68:	7853      	ldrb	r3, [r2, #1]
 8029b6a:	f361 0301 	bfi	r3, r1, #0, #2
 8029b6e:	7053      	strb	r3, [r2, #1]
        ext->fit_bottom          = copy_ext->fit_bottom;
 8029b70:	68fb      	ldr	r3, [r7, #12]
 8029b72:	785b      	ldrb	r3, [r3, #1]
 8029b74:	f3c3 0381 	ubfx	r3, r3, #2, #2
 8029b78:	b2d9      	uxtb	r1, r3
 8029b7a:	693a      	ldr	r2, [r7, #16]
 8029b7c:	7853      	ldrb	r3, [r2, #1]
 8029b7e:	f361 0383 	bfi	r3, r1, #2, #2
 8029b82:	7053      	strb	r3, [r2, #1]
        ext->layout              = copy_ext->layout;
 8029b84:	68fb      	ldr	r3, [r7, #12]
 8029b86:	781b      	ldrb	r3, [r3, #0]
 8029b88:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8029b8c:	b2d9      	uxtb	r1, r3
 8029b8e:	693a      	ldr	r2, [r7, #16]
 8029b90:	7813      	ldrb	r3, [r2, #0]
 8029b92:	f361 0303 	bfi	r3, r1, #0, #4
 8029b96:	7013      	strb	r3, [r2, #0]

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(cont, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
 8029b98:	22ff      	movs	r2, #255	; 0xff
 8029b9a:	21ff      	movs	r1, #255	; 0xff
 8029b9c:	6978      	ldr	r0, [r7, #20]
 8029b9e:	f7e0 fbaf 	bl	800a300 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("container created");

    return cont;
 8029ba2:	697b      	ldr	r3, [r7, #20]
}
 8029ba4:	4618      	mov	r0, r3
 8029ba6:	3718      	adds	r7, #24
 8029ba8:	46bd      	mov	sp, r7
 8029baa:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 8029bae:	bf00      	nop
 8029bb0:	0802e5a4 	.word	0x0802e5a4
 8029bb4:	2001235c 	.word	0x2001235c
 8029bb8:	20012358 	.word	0x20012358
 8029bbc:	08029d09 	.word	0x08029d09

08029bc0 <lv_cont_set_fit4>:
 * @param right right fit policy from `lv_fit_t`
 * @param top bottom fit policy from `lv_fit_t`
 * @param bottom bottom fit policy from `lv_fit_t`
 */
void lv_cont_set_fit4(lv_obj_t * cont, lv_fit_t left, lv_fit_t right, lv_fit_t top, lv_fit_t bottom)
{
 8029bc0:	b5b0      	push	{r4, r5, r7, lr}
 8029bc2:	b084      	sub	sp, #16
 8029bc4:	af00      	add	r7, sp, #0
 8029bc6:	6078      	str	r0, [r7, #4]
 8029bc8:	4608      	mov	r0, r1
 8029bca:	4611      	mov	r1, r2
 8029bcc:	461a      	mov	r2, r3
 8029bce:	4603      	mov	r3, r0
 8029bd0:	70fb      	strb	r3, [r7, #3]
 8029bd2:	460b      	mov	r3, r1
 8029bd4:	70bb      	strb	r3, [r7, #2]
 8029bd6:	4613      	mov	r3, r2
 8029bd8:	707b      	strb	r3, [r7, #1]
    LV_ASSERT_OBJ(cont, LV_OBJX_NAME);
 8029bda:	6878      	ldr	r0, [r7, #4]
 8029bdc:	f7f6 fa88 	bl	80200f0 <lv_debug_check_null>
 8029be0:	4603      	mov	r3, r0
 8029be2:	f083 0301 	eor.w	r3, r3, #1
 8029be6:	b2db      	uxtb	r3, r3
 8029be8:	2b00      	cmp	r3, #0
 8029bea:	d009      	beq.n	8029c00 <lv_cont_set_fit4+0x40>
 8029bec:	687b      	ldr	r3, [r7, #4]
 8029bee:	2200      	movs	r2, #0
 8029bf0:	461c      	mov	r4, r3
 8029bf2:	4615      	mov	r5, r2
 8029bf4:	4622      	mov	r2, r4
 8029bf6:	462b      	mov	r3, r5
 8029bf8:	482f      	ldr	r0, [pc, #188]	; (8029cb8 <lv_cont_set_fit4+0xf8>)
 8029bfa:	f7f6 fa89 	bl	8020110 <lv_debug_log_error>
 8029bfe:	e7fe      	b.n	8029bfe <lv_cont_set_fit4+0x3e>

    lv_obj_invalidate(cont);
 8029c00:	6878      	ldr	r0, [r7, #4]
 8029c02:	f7df fefd 	bl	8009a00 <lv_obj_invalidate>
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 8029c06:	6878      	ldr	r0, [r7, #4]
 8029c08:	f7e1 ff22 	bl	800ba50 <lv_obj_get_ext_attr>
 8029c0c:	60f8      	str	r0, [r7, #12]
    if(ext->fit_left == left && ext->fit_right == right && ext->fit_top == top && ext->fit_bottom == bottom) {
 8029c0e:	68fb      	ldr	r3, [r7, #12]
 8029c10:	781b      	ldrb	r3, [r3, #0]
 8029c12:	f3c3 1301 	ubfx	r3, r3, #4, #2
 8029c16:	b2db      	uxtb	r3, r3
 8029c18:	461a      	mov	r2, r3
 8029c1a:	78fb      	ldrb	r3, [r7, #3]
 8029c1c:	429a      	cmp	r2, r3
 8029c1e:	d11b      	bne.n	8029c58 <lv_cont_set_fit4+0x98>
 8029c20:	68fb      	ldr	r3, [r7, #12]
 8029c22:	781b      	ldrb	r3, [r3, #0]
 8029c24:	f3c3 1381 	ubfx	r3, r3, #6, #2
 8029c28:	b2db      	uxtb	r3, r3
 8029c2a:	461a      	mov	r2, r3
 8029c2c:	78bb      	ldrb	r3, [r7, #2]
 8029c2e:	429a      	cmp	r2, r3
 8029c30:	d112      	bne.n	8029c58 <lv_cont_set_fit4+0x98>
 8029c32:	68fb      	ldr	r3, [r7, #12]
 8029c34:	785b      	ldrb	r3, [r3, #1]
 8029c36:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8029c3a:	b2db      	uxtb	r3, r3
 8029c3c:	461a      	mov	r2, r3
 8029c3e:	787b      	ldrb	r3, [r7, #1]
 8029c40:	429a      	cmp	r2, r3
 8029c42:	d109      	bne.n	8029c58 <lv_cont_set_fit4+0x98>
 8029c44:	68fb      	ldr	r3, [r7, #12]
 8029c46:	785b      	ldrb	r3, [r3, #1]
 8029c48:	f3c3 0381 	ubfx	r3, r3, #2, #2
 8029c4c:	b2db      	uxtb	r3, r3
 8029c4e:	461a      	mov	r2, r3
 8029c50:	f897 3020 	ldrb.w	r3, [r7, #32]
 8029c54:	429a      	cmp	r2, r3
 8029c56:	d02b      	beq.n	8029cb0 <lv_cont_set_fit4+0xf0>
        return;
    }

    ext->fit_left   = left;
 8029c58:	78fb      	ldrb	r3, [r7, #3]
 8029c5a:	f003 0303 	and.w	r3, r3, #3
 8029c5e:	b2d9      	uxtb	r1, r3
 8029c60:	68fa      	ldr	r2, [r7, #12]
 8029c62:	7813      	ldrb	r3, [r2, #0]
 8029c64:	f361 1305 	bfi	r3, r1, #4, #2
 8029c68:	7013      	strb	r3, [r2, #0]
    ext->fit_right  = right;
 8029c6a:	78bb      	ldrb	r3, [r7, #2]
 8029c6c:	f003 0303 	and.w	r3, r3, #3
 8029c70:	b2d9      	uxtb	r1, r3
 8029c72:	68fa      	ldr	r2, [r7, #12]
 8029c74:	7813      	ldrb	r3, [r2, #0]
 8029c76:	f361 1387 	bfi	r3, r1, #6, #2
 8029c7a:	7013      	strb	r3, [r2, #0]
    ext->fit_top    = top;
 8029c7c:	787b      	ldrb	r3, [r7, #1]
 8029c7e:	f003 0303 	and.w	r3, r3, #3
 8029c82:	b2d9      	uxtb	r1, r3
 8029c84:	68fa      	ldr	r2, [r7, #12]
 8029c86:	7853      	ldrb	r3, [r2, #1]
 8029c88:	f361 0301 	bfi	r3, r1, #0, #2
 8029c8c:	7053      	strb	r3, [r2, #1]
    ext->fit_bottom = bottom;
 8029c8e:	f897 3020 	ldrb.w	r3, [r7, #32]
 8029c92:	f003 0303 	and.w	r3, r3, #3
 8029c96:	b2d9      	uxtb	r1, r3
 8029c98:	68fa      	ldr	r2, [r7, #12]
 8029c9a:	7853      	ldrb	r3, [r2, #1]
 8029c9c:	f361 0383 	bfi	r3, r1, #2, #2
 8029ca0:	7053      	strb	r3, [r2, #1]

    /*Send a signal to refresh the layout*/
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
 8029ca2:	687b      	ldr	r3, [r7, #4]
 8029ca4:	69db      	ldr	r3, [r3, #28]
 8029ca6:	2200      	movs	r2, #0
 8029ca8:	2101      	movs	r1, #1
 8029caa:	6878      	ldr	r0, [r7, #4]
 8029cac:	4798      	blx	r3
 8029cae:	e000      	b.n	8029cb2 <lv_cont_set_fit4+0xf2>
        return;
 8029cb0:	bf00      	nop
}
 8029cb2:	3710      	adds	r7, #16
 8029cb4:	46bd      	mov	sp, r7
 8029cb6:	bdb0      	pop	{r4, r5, r7, pc}
 8029cb8:	0802e5b4 	.word	0x0802e5b4

08029cbc <lv_cont_get_layout>:
 * Get the layout of a container
 * @param cont pointer to container object
 * @return the layout from 'lv_cont_layout_t'
 */
lv_layout_t lv_cont_get_layout(const lv_obj_t * cont)
{
 8029cbc:	b5b0      	push	{r4, r5, r7, lr}
 8029cbe:	b084      	sub	sp, #16
 8029cc0:	af00      	add	r7, sp, #0
 8029cc2:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(cont, LV_OBJX_NAME);
 8029cc4:	6878      	ldr	r0, [r7, #4]
 8029cc6:	f7f6 fa13 	bl	80200f0 <lv_debug_check_null>
 8029cca:	4603      	mov	r3, r0
 8029ccc:	f083 0301 	eor.w	r3, r3, #1
 8029cd0:	b2db      	uxtb	r3, r3
 8029cd2:	2b00      	cmp	r3, #0
 8029cd4:	d009      	beq.n	8029cea <lv_cont_get_layout+0x2e>
 8029cd6:	687b      	ldr	r3, [r7, #4]
 8029cd8:	2200      	movs	r2, #0
 8029cda:	461c      	mov	r4, r3
 8029cdc:	4615      	mov	r5, r2
 8029cde:	4622      	mov	r2, r4
 8029ce0:	462b      	mov	r3, r5
 8029ce2:	4808      	ldr	r0, [pc, #32]	; (8029d04 <lv_cont_get_layout+0x48>)
 8029ce4:	f7f6 fa14 	bl	8020110 <lv_debug_log_error>
 8029ce8:	e7fe      	b.n	8029ce8 <lv_cont_get_layout+0x2c>

    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 8029cea:	6878      	ldr	r0, [r7, #4]
 8029cec:	f7e1 feb0 	bl	800ba50 <lv_obj_get_ext_attr>
 8029cf0:	60f8      	str	r0, [r7, #12]
    return ext->layout;
 8029cf2:	68fb      	ldr	r3, [r7, #12]
 8029cf4:	781b      	ldrb	r3, [r3, #0]
 8029cf6:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8029cfa:	b2db      	uxtb	r3, r3
}
 8029cfc:	4618      	mov	r0, r3
 8029cfe:	3710      	adds	r7, #16
 8029d00:	46bd      	mov	sp, r7
 8029d02:	bdb0      	pop	{r4, r5, r7, pc}
 8029d04:	0802e5b4 	.word	0x0802e5b4

08029d08 <lv_cont_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_cont_signal(lv_obj_t * cont, lv_signal_t sign, void * param)
{
 8029d08:	b590      	push	{r4, r7, lr}
 8029d0a:	b087      	sub	sp, #28
 8029d0c:	af00      	add	r7, sp, #0
 8029d0e:	60f8      	str	r0, [r7, #12]
 8029d10:	460b      	mov	r3, r1
 8029d12:	607a      	str	r2, [r7, #4]
 8029d14:	72fb      	strb	r3, [r7, #11]
    if(sign == LV_SIGNAL_GET_STYLE) {
 8029d16:	7afb      	ldrb	r3, [r7, #11]
 8029d18:	2b08      	cmp	r3, #8
 8029d1a:	d118      	bne.n	8029d4e <lv_cont_signal+0x46>
        lv_get_style_info_t * info = param;
 8029d1c:	687b      	ldr	r3, [r7, #4]
 8029d1e:	613b      	str	r3, [r7, #16]
        info->result = lv_cont_get_style(cont, info->part);
 8029d20:	693b      	ldr	r3, [r7, #16]
 8029d22:	781b      	ldrb	r3, [r3, #0]
 8029d24:	4619      	mov	r1, r3
 8029d26:	68f8      	ldr	r0, [r7, #12]
 8029d28:	f000 f86a 	bl	8029e00 <lv_cont_get_style>
 8029d2c:	4602      	mov	r2, r0
 8029d2e:	693b      	ldr	r3, [r7, #16]
 8029d30:	605a      	str	r2, [r3, #4]
        if(info->result != NULL) return LV_RES_OK;
 8029d32:	693b      	ldr	r3, [r7, #16]
 8029d34:	685b      	ldr	r3, [r3, #4]
 8029d36:	2b00      	cmp	r3, #0
 8029d38:	d001      	beq.n	8029d3e <lv_cont_signal+0x36>
 8029d3a:	2301      	movs	r3, #1
 8029d3c:	e058      	b.n	8029df0 <lv_cont_signal+0xe8>
        else return ancestor_signal(cont, sign, param);
 8029d3e:	4b2e      	ldr	r3, [pc, #184]	; (8029df8 <lv_cont_signal+0xf0>)
 8029d40:	681b      	ldr	r3, [r3, #0]
 8029d42:	7af9      	ldrb	r1, [r7, #11]
 8029d44:	687a      	ldr	r2, [r7, #4]
 8029d46:	68f8      	ldr	r0, [r7, #12]
 8029d48:	4798      	blx	r3
 8029d4a:	4603      	mov	r3, r0
 8029d4c:	e050      	b.n	8029df0 <lv_cont_signal+0xe8>
    }

    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(cont, sign, param);
 8029d4e:	4b2a      	ldr	r3, [pc, #168]	; (8029df8 <lv_cont_signal+0xf0>)
 8029d50:	681b      	ldr	r3, [r3, #0]
 8029d52:	7af9      	ldrb	r1, [r7, #11]
 8029d54:	687a      	ldr	r2, [r7, #4]
 8029d56:	68f8      	ldr	r0, [r7, #12]
 8029d58:	4798      	blx	r3
 8029d5a:	4603      	mov	r3, r0
 8029d5c:	75fb      	strb	r3, [r7, #23]
    if(res != LV_RES_OK) return res;
 8029d5e:	7dfb      	ldrb	r3, [r7, #23]
 8029d60:	2b01      	cmp	r3, #1
 8029d62:	d001      	beq.n	8029d68 <lv_cont_signal+0x60>
 8029d64:	7dfb      	ldrb	r3, [r7, #23]
 8029d66:	e043      	b.n	8029df0 <lv_cont_signal+0xe8>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
 8029d68:	7afb      	ldrb	r3, [r7, #11]
 8029d6a:	2b07      	cmp	r3, #7
 8029d6c:	d105      	bne.n	8029d7a <lv_cont_signal+0x72>
 8029d6e:	4923      	ldr	r1, [pc, #140]	; (8029dfc <lv_cont_signal+0xf4>)
 8029d70:	6878      	ldr	r0, [r7, #4]
 8029d72:	f7e1 ff24 	bl	800bbbe <lv_obj_handle_get_type_signal>
 8029d76:	4603      	mov	r3, r0
 8029d78:	e03a      	b.n	8029df0 <lv_cont_signal+0xe8>

    if(sign == LV_SIGNAL_STYLE_CHG) { /*Recalculate the padding if the style changed*/
 8029d7a:	7afb      	ldrb	r3, [r7, #11]
 8029d7c:	2b04      	cmp	r3, #4
 8029d7e:	d106      	bne.n	8029d8e <lv_cont_signal+0x86>
        lv_cont_refr_layout(cont);
 8029d80:	68f8      	ldr	r0, [r7, #12]
 8029d82:	f000 f853 	bl	8029e2c <lv_cont_refr_layout>
        lv_cont_refr_autofit(cont);
 8029d86:	68f8      	ldr	r0, [r7, #12]
 8029d88:	f000 fd13 	bl	802a7b2 <lv_cont_refr_autofit>
 8029d8c:	e02f      	b.n	8029dee <lv_cont_signal+0xe6>
    }
    else if(sign == LV_SIGNAL_CHILD_CHG) {
 8029d8e:	7afb      	ldrb	r3, [r7, #11]
 8029d90:	2b01      	cmp	r3, #1
 8029d92:	d106      	bne.n	8029da2 <lv_cont_signal+0x9a>
        lv_cont_refr_layout(cont);
 8029d94:	68f8      	ldr	r0, [r7, #12]
 8029d96:	f000 f849 	bl	8029e2c <lv_cont_refr_layout>
        lv_cont_refr_autofit(cont);
 8029d9a:	68f8      	ldr	r0, [r7, #12]
 8029d9c:	f000 fd09 	bl	802a7b2 <lv_cont_refr_autofit>
 8029da0:	e025      	b.n	8029dee <lv_cont_signal+0xe6>
    }
    else if(sign == LV_SIGNAL_COORD_CHG) {
 8029da2:	7afb      	ldrb	r3, [r7, #11]
 8029da4:	2b02      	cmp	r3, #2
 8029da6:	d11c      	bne.n	8029de2 <lv_cont_signal+0xda>
        if(lv_obj_get_width(cont) != lv_area_get_width(param) || lv_obj_get_height(cont) != lv_area_get_height(param)) {
 8029da8:	68f8      	ldr	r0, [r7, #12]
 8029daa:	f7e1 f897 	bl	800aedc <lv_obj_get_width>
 8029dae:	4603      	mov	r3, r0
 8029db0:	461c      	mov	r4, r3
 8029db2:	6878      	ldr	r0, [r7, #4]
 8029db4:	f7ff fd70 	bl	8029898 <lv_area_get_width>
 8029db8:	4603      	mov	r3, r0
 8029dba:	429c      	cmp	r4, r3
 8029dbc:	d10a      	bne.n	8029dd4 <lv_cont_signal+0xcc>
 8029dbe:	68f8      	ldr	r0, [r7, #12]
 8029dc0:	f7e1 f8b0 	bl	800af24 <lv_obj_get_height>
 8029dc4:	4603      	mov	r3, r0
 8029dc6:	461c      	mov	r4, r3
 8029dc8:	6878      	ldr	r0, [r7, #4]
 8029dca:	f7ff fd7c 	bl	80298c6 <lv_area_get_height>
 8029dce:	4603      	mov	r3, r0
 8029dd0:	429c      	cmp	r4, r3
 8029dd2:	d00c      	beq.n	8029dee <lv_cont_signal+0xe6>
            lv_cont_refr_layout(cont);
 8029dd4:	68f8      	ldr	r0, [r7, #12]
 8029dd6:	f000 f829 	bl	8029e2c <lv_cont_refr_layout>
            lv_cont_refr_autofit(cont);
 8029dda:	68f8      	ldr	r0, [r7, #12]
 8029ddc:	f000 fce9 	bl	802a7b2 <lv_cont_refr_autofit>
 8029de0:	e005      	b.n	8029dee <lv_cont_signal+0xe6>
        }
    }
    else if(sign == LV_SIGNAL_PARENT_SIZE_CHG) {
 8029de2:	7afb      	ldrb	r3, [r7, #11]
 8029de4:	2b03      	cmp	r3, #3
 8029de6:	d102      	bne.n	8029dee <lv_cont_signal+0xe6>
        /*MAX and EDGE fit needs to be refreshed if the parent's size has changed*/
        lv_cont_refr_autofit(cont);
 8029de8:	68f8      	ldr	r0, [r7, #12]
 8029dea:	f000 fce2 	bl	802a7b2 <lv_cont_refr_autofit>
    }

    return res;
 8029dee:	7dfb      	ldrb	r3, [r7, #23]
}
 8029df0:	4618      	mov	r0, r3
 8029df2:	371c      	adds	r7, #28
 8029df4:	46bd      	mov	sp, r7
 8029df6:	bd90      	pop	{r4, r7, pc}
 8029df8:	2001235c 	.word	0x2001235c
 8029dfc:	0802e5c4 	.word	0x0802e5c4

08029e00 <lv_cont_get_style>:


static lv_style_list_t * lv_cont_get_style(lv_obj_t * cont, uint8_t type)
{
 8029e00:	b480      	push	{r7}
 8029e02:	b085      	sub	sp, #20
 8029e04:	af00      	add	r7, sp, #0
 8029e06:	6078      	str	r0, [r7, #4]
 8029e08:	460b      	mov	r3, r1
 8029e0a:	70fb      	strb	r3, [r7, #3]
    lv_style_list_t * style_dsc_p;
    switch(type) {
 8029e0c:	78fb      	ldrb	r3, [r7, #3]
 8029e0e:	2b00      	cmp	r3, #0
 8029e10:	d103      	bne.n	8029e1a <lv_cont_get_style+0x1a>
        case LV_CONT_PART_MAIN:
            style_dsc_p = &cont->style_list;
 8029e12:	687b      	ldr	r3, [r7, #4]
 8029e14:	3328      	adds	r3, #40	; 0x28
 8029e16:	60fb      	str	r3, [r7, #12]
            break;
 8029e18:	e001      	b.n	8029e1e <lv_cont_get_style+0x1e>
        default:
            style_dsc_p = NULL;
 8029e1a:	2300      	movs	r3, #0
 8029e1c:	60fb      	str	r3, [r7, #12]
    }

    return style_dsc_p;
 8029e1e:	68fb      	ldr	r3, [r7, #12]
}
 8029e20:	4618      	mov	r0, r3
 8029e22:	3714      	adds	r7, #20
 8029e24:	46bd      	mov	sp, r7
 8029e26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8029e2a:	4770      	bx	lr

08029e2c <lv_cont_refr_layout>:
/**
 * Refresh the layout of a container
 * @param cont pointer to an object which layout should be refreshed
 */
static void lv_cont_refr_layout(lv_obj_t * cont)
{
 8029e2c:	b580      	push	{r7, lr}
 8029e2e:	b084      	sub	sp, #16
 8029e30:	af00      	add	r7, sp, #0
 8029e32:	6078      	str	r0, [r7, #4]
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
 8029e34:	2101      	movs	r1, #1
 8029e36:	6878      	ldr	r0, [r7, #4]
 8029e38:	f7e1 fd6e 	bl	800b918 <lv_obj_is_protected>
 8029e3c:	4603      	mov	r3, r0
 8029e3e:	2b00      	cmp	r3, #0
 8029e40:	d143      	bne.n	8029eca <lv_cont_refr_layout+0x9e>
    lv_layout_t type = lv_cont_get_layout(cont);
 8029e42:	6878      	ldr	r0, [r7, #4]
 8029e44:	f7ff ff3a 	bl	8029cbc <lv_cont_get_layout>
 8029e48:	4603      	mov	r3, r0
 8029e4a:	73fb      	strb	r3, [r7, #15]

    /*'cont' has to be at least 1 child*/
    if(lv_obj_get_child(cont, NULL) == NULL) return;
 8029e4c:	2100      	movs	r1, #0
 8029e4e:	6878      	ldr	r0, [r7, #4]
 8029e50:	f7e0 ff82 	bl	800ad58 <lv_obj_get_child>
 8029e54:	4603      	mov	r3, r0
 8029e56:	2b00      	cmp	r3, #0
 8029e58:	d039      	beq.n	8029ece <lv_cont_refr_layout+0xa2>

    if(type == LV_LAYOUT_OFF) return;
 8029e5a:	7bfb      	ldrb	r3, [r7, #15]
 8029e5c:	2b00      	cmp	r3, #0
 8029e5e:	d038      	beq.n	8029ed2 <lv_cont_refr_layout+0xa6>

    if(type == LV_LAYOUT_CENTER) {
 8029e60:	7bfb      	ldrb	r3, [r7, #15]
 8029e62:	2b01      	cmp	r3, #1
 8029e64:	d103      	bne.n	8029e6e <lv_cont_refr_layout+0x42>
        lv_cont_layout_center(cont);
 8029e66:	6878      	ldr	r0, [r7, #4]
 8029e68:	f000 f997 	bl	802a19a <lv_cont_layout_center>
 8029e6c:	e032      	b.n	8029ed4 <lv_cont_refr_layout+0xa8>
    }
    else if(type == LV_LAYOUT_COLUMN_LEFT || type == LV_LAYOUT_COLUMN_MID || type == LV_LAYOUT_COLUMN_RIGHT) {
 8029e6e:	7bfb      	ldrb	r3, [r7, #15]
 8029e70:	2b02      	cmp	r3, #2
 8029e72:	d005      	beq.n	8029e80 <lv_cont_refr_layout+0x54>
 8029e74:	7bfb      	ldrb	r3, [r7, #15]
 8029e76:	2b03      	cmp	r3, #3
 8029e78:	d002      	beq.n	8029e80 <lv_cont_refr_layout+0x54>
 8029e7a:	7bfb      	ldrb	r3, [r7, #15]
 8029e7c:	2b04      	cmp	r3, #4
 8029e7e:	d103      	bne.n	8029e88 <lv_cont_refr_layout+0x5c>
        lv_cont_layout_col(cont);
 8029e80:	6878      	ldr	r0, [r7, #4]
 8029e82:	f000 f82a 	bl	8029eda <lv_cont_layout_col>
 8029e86:	e025      	b.n	8029ed4 <lv_cont_refr_layout+0xa8>
    }
    else if(type == LV_LAYOUT_ROW_TOP || type == LV_LAYOUT_ROW_MID || type == LV_LAYOUT_ROW_BOTTOM) {
 8029e88:	7bfb      	ldrb	r3, [r7, #15]
 8029e8a:	2b05      	cmp	r3, #5
 8029e8c:	d005      	beq.n	8029e9a <lv_cont_refr_layout+0x6e>
 8029e8e:	7bfb      	ldrb	r3, [r7, #15]
 8029e90:	2b06      	cmp	r3, #6
 8029e92:	d002      	beq.n	8029e9a <lv_cont_refr_layout+0x6e>
 8029e94:	7bfb      	ldrb	r3, [r7, #15]
 8029e96:	2b07      	cmp	r3, #7
 8029e98:	d103      	bne.n	8029ea2 <lv_cont_refr_layout+0x76>
        lv_cont_layout_row(cont);
 8029e9a:	6878      	ldr	r0, [r7, #4]
 8029e9c:	f000 f8c7 	bl	802a02e <lv_cont_layout_row>
 8029ea0:	e018      	b.n	8029ed4 <lv_cont_refr_layout+0xa8>
    }
    else if(type == LV_LAYOUT_PRETTY_MID || type == LV_LAYOUT_PRETTY_TOP || type == LV_LAYOUT_PRETTY_BOTTOM) {
 8029ea2:	7bfb      	ldrb	r3, [r7, #15]
 8029ea4:	2b09      	cmp	r3, #9
 8029ea6:	d005      	beq.n	8029eb4 <lv_cont_refr_layout+0x88>
 8029ea8:	7bfb      	ldrb	r3, [r7, #15]
 8029eaa:	2b08      	cmp	r3, #8
 8029eac:	d002      	beq.n	8029eb4 <lv_cont_refr_layout+0x88>
 8029eae:	7bfb      	ldrb	r3, [r7, #15]
 8029eb0:	2b0a      	cmp	r3, #10
 8029eb2:	d103      	bne.n	8029ebc <lv_cont_refr_layout+0x90>
        lv_cont_layout_pretty(cont);
 8029eb4:	6878      	ldr	r0, [r7, #4]
 8029eb6:	f000 fa0e 	bl	802a2d6 <lv_cont_layout_pretty>
 8029eba:	e00b      	b.n	8029ed4 <lv_cont_refr_layout+0xa8>
    }
    else if(type == LV_LAYOUT_GRID) {
 8029ebc:	7bfb      	ldrb	r3, [r7, #15]
 8029ebe:	2b0b      	cmp	r3, #11
 8029ec0:	d108      	bne.n	8029ed4 <lv_cont_refr_layout+0xa8>
        lv_cont_layout_grid(cont);
 8029ec2:	6878      	ldr	r0, [r7, #4]
 8029ec4:	f000 fbf6 	bl	802a6b4 <lv_cont_layout_grid>
 8029ec8:	e004      	b.n	8029ed4 <lv_cont_refr_layout+0xa8>
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
 8029eca:	bf00      	nop
 8029ecc:	e002      	b.n	8029ed4 <lv_cont_refr_layout+0xa8>
    if(lv_obj_get_child(cont, NULL) == NULL) return;
 8029ece:	bf00      	nop
 8029ed0:	e000      	b.n	8029ed4 <lv_cont_refr_layout+0xa8>
    if(type == LV_LAYOUT_OFF) return;
 8029ed2:	bf00      	nop
    }
}
 8029ed4:	3710      	adds	r7, #16
 8029ed6:	46bd      	mov	sp, r7
 8029ed8:	bd80      	pop	{r7, pc}

08029eda <lv_cont_layout_col>:
/**
 * Handle column type layouts
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_col(lv_obj_t * cont)
{
 8029eda:	b580      	push	{r7, lr}
 8029edc:	b08c      	sub	sp, #48	; 0x30
 8029ede:	af02      	add	r7, sp, #8
 8029ee0:	6078      	str	r0, [r7, #4]
    lv_coord_t left = lv_obj_get_style_pad_left(cont, LV_CONT_PART_MAIN);
 8029ee2:	2100      	movs	r1, #0
 8029ee4:	6878      	ldr	r0, [r7, #4]
 8029ee6:	f7ff fd27 	bl	8029938 <lv_obj_get_style_pad_left>
 8029eea:	4603      	mov	r3, r0
 8029eec:	83bb      	strh	r3, [r7, #28]
    lv_coord_t right = lv_obj_get_style_pad_right(cont, LV_CONT_PART_MAIN);
 8029eee:	2100      	movs	r1, #0
 8029ef0:	6878      	ldr	r0, [r7, #4]
 8029ef2:	f7ff fd32 	bl	802995a <lv_obj_get_style_pad_right>
 8029ef6:	4603      	mov	r3, r0
 8029ef8:	837b      	strh	r3, [r7, #26]
    lv_coord_t top = lv_obj_get_style_pad_top(cont, LV_CONT_PART_MAIN);
 8029efa:	2100      	movs	r1, #0
 8029efc:	6878      	ldr	r0, [r7, #4]
 8029efe:	f7ff fcf9 	bl	80298f4 <lv_obj_get_style_pad_top>
 8029f02:	4603      	mov	r3, r0
 8029f04:	833b      	strh	r3, [r7, #24]
    lv_coord_t inner = lv_obj_get_style_pad_inner(cont, LV_CONT_PART_MAIN);
 8029f06:	2100      	movs	r1, #0
 8029f08:	6878      	ldr	r0, [r7, #4]
 8029f0a:	f7ff fd37 	bl	802997c <lv_obj_get_style_pad_inner>
 8029f0e:	4603      	mov	r3, r0
 8029f10:	82fb      	strh	r3, [r7, #22]

    lv_layout_t type = lv_cont_get_layout(cont);
 8029f12:	6878      	ldr	r0, [r7, #4]
 8029f14:	f7ff fed2 	bl	8029cbc <lv_cont_get_layout>
 8029f18:	4603      	mov	r3, r0
 8029f1a:	757b      	strb	r3, [r7, #21]

    /*Adjust margin and get the alignment type*/
    lv_align_t align;
    lv_coord_t hpad_corr;

    switch(type) {
 8029f1c:	7d7b      	ldrb	r3, [r7, #21]
 8029f1e:	2b04      	cmp	r3, #4
 8029f20:	d012      	beq.n	8029f48 <lv_cont_layout_col+0x6e>
 8029f22:	2b04      	cmp	r3, #4
 8029f24:	dc18      	bgt.n	8029f58 <lv_cont_layout_col+0x7e>
 8029f26:	2b02      	cmp	r3, #2
 8029f28:	d002      	beq.n	8029f30 <lv_cont_layout_col+0x56>
 8029f2a:	2b03      	cmp	r3, #3
 8029f2c:	d006      	beq.n	8029f3c <lv_cont_layout_col+0x62>
 8029f2e:	e013      	b.n	8029f58 <lv_cont_layout_col+0x7e>
        case LV_LAYOUT_COLUMN_LEFT:
            hpad_corr = left;
 8029f30:	8bbb      	ldrh	r3, [r7, #28]
 8029f32:	843b      	strh	r3, [r7, #32]
            align     = LV_ALIGN_IN_TOP_LEFT;
 8029f34:	2301      	movs	r3, #1
 8029f36:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            break;
 8029f3a:	e013      	b.n	8029f64 <lv_cont_layout_col+0x8a>
        case LV_LAYOUT_COLUMN_MID:
            hpad_corr = 0;
 8029f3c:	2300      	movs	r3, #0
 8029f3e:	843b      	strh	r3, [r7, #32]
            align     = LV_ALIGN_IN_TOP_MID;
 8029f40:	2302      	movs	r3, #2
 8029f42:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            break;
 8029f46:	e00d      	b.n	8029f64 <lv_cont_layout_col+0x8a>
        case LV_LAYOUT_COLUMN_RIGHT:
            hpad_corr = -right;
 8029f48:	8b7b      	ldrh	r3, [r7, #26]
 8029f4a:	425b      	negs	r3, r3
 8029f4c:	b29b      	uxth	r3, r3
 8029f4e:	843b      	strh	r3, [r7, #32]
            align     = LV_ALIGN_IN_TOP_RIGHT;
 8029f50:	2303      	movs	r3, #3
 8029f52:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            break;
 8029f56:	e005      	b.n	8029f64 <lv_cont_layout_col+0x8a>
        default:
            hpad_corr = 0;
 8029f58:	2300      	movs	r3, #0
 8029f5a:	843b      	strh	r3, [r7, #32]
            align     = LV_ALIGN_IN_TOP_LEFT;
 8029f5c:	2301      	movs	r3, #1
 8029f5e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            break;
 8029f62:	bf00      	nop
    }

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
 8029f64:	2101      	movs	r1, #1
 8029f66:	6878      	ldr	r0, [r7, #4]
 8029f68:	f7e0 fafa 	bl	800a560 <lv_obj_add_protect>
    /* Align the children */
    lv_coord_t last_cord = top;
 8029f6c:	8b3b      	ldrh	r3, [r7, #24]
 8029f6e:	83fb      	strh	r3, [r7, #30]
    _LV_LL_READ_BACK(cont->child_ll, child) {
 8029f70:	687b      	ldr	r3, [r7, #4]
 8029f72:	3304      	adds	r3, #4
 8029f74:	4618      	mov	r0, r3
 8029f76:	f7f6 fc84 	bl	8020882 <_lv_ll_get_tail>
 8029f7a:	6278      	str	r0, [r7, #36]	; 0x24
 8029f7c:	e04c      	b.n	802a018 <lv_cont_layout_col+0x13e>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 8029f7e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8029f80:	f7e1 fc6e 	bl	800b860 <lv_obj_get_hidden>
 8029f84:	4603      	mov	r3, r0
 8029f86:	2b00      	cmp	r3, #0
 8029f88:	d13e      	bne.n	802a008 <lv_cont_layout_col+0x12e>
 8029f8a:	2104      	movs	r1, #4
 8029f8c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8029f8e:	f7e1 fcc3 	bl	800b918 <lv_obj_is_protected>
 8029f92:	4603      	mov	r3, r0
 8029f94:	2b00      	cmp	r3, #0
 8029f96:	d137      	bne.n	802a008 <lv_cont_layout_col+0x12e>
        lv_style_int_t mtop = lv_obj_get_style_margin_top(child, LV_OBJ_PART_MAIN);
 8029f98:	2100      	movs	r1, #0
 8029f9a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8029f9c:	f7ff fcff 	bl	802999e <lv_obj_get_style_margin_top>
 8029fa0:	4603      	mov	r3, r0
 8029fa2:	827b      	strh	r3, [r7, #18]
        lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(child, LV_OBJ_PART_MAIN);
 8029fa4:	2100      	movs	r1, #0
 8029fa6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8029fa8:	f7ff fd0a 	bl	80299c0 <lv_obj_get_style_margin_bottom>
 8029fac:	4603      	mov	r3, r0
 8029fae:	823b      	strh	r3, [r7, #16]
        lv_style_int_t mleft = lv_obj_get_style_margin_left(child, LV_OBJ_PART_MAIN);
 8029fb0:	2100      	movs	r1, #0
 8029fb2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8029fb4:	f7ff fd15 	bl	80299e2 <lv_obj_get_style_margin_left>
 8029fb8:	4603      	mov	r3, r0
 8029fba:	81fb      	strh	r3, [r7, #14]
        lv_obj_align(child, cont, align, hpad_corr + mleft, last_cord + mtop);
 8029fbc:	8c3a      	ldrh	r2, [r7, #32]
 8029fbe:	89fb      	ldrh	r3, [r7, #14]
 8029fc0:	4413      	add	r3, r2
 8029fc2:	b29b      	uxth	r3, r3
 8029fc4:	b219      	sxth	r1, r3
 8029fc6:	8bfa      	ldrh	r2, [r7, #30]
 8029fc8:	8a7b      	ldrh	r3, [r7, #18]
 8029fca:	4413      	add	r3, r2
 8029fcc:	b29b      	uxth	r3, r3
 8029fce:	b21b      	sxth	r3, r3
 8029fd0:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 8029fd4:	9300      	str	r3, [sp, #0]
 8029fd6:	460b      	mov	r3, r1
 8029fd8:	6879      	ldr	r1, [r7, #4]
 8029fda:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8029fdc:	f7df fffe 	bl	8009fdc <lv_obj_align>
        last_cord += lv_obj_get_height(child) + inner + mtop + mbottom;
 8029fe0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8029fe2:	f7e0 ff9f 	bl	800af24 <lv_obj_get_height>
 8029fe6:	4603      	mov	r3, r0
 8029fe8:	461a      	mov	r2, r3
 8029fea:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8029fee:	441a      	add	r2, r3
 8029ff0:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8029ff4:	441a      	add	r2, r3
 8029ff6:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8029ffa:	4413      	add	r3, r2
 8029ffc:	b29a      	uxth	r2, r3
 8029ffe:	8bfb      	ldrh	r3, [r7, #30]
 802a000:	4413      	add	r3, r2
 802a002:	b29b      	uxth	r3, r3
 802a004:	83fb      	strh	r3, [r7, #30]
 802a006:	e000      	b.n	802a00a <lv_cont_layout_col+0x130>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 802a008:	bf00      	nop
    _LV_LL_READ_BACK(cont->child_ll, child) {
 802a00a:	687b      	ldr	r3, [r7, #4]
 802a00c:	3304      	adds	r3, #4
 802a00e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 802a010:	4618      	mov	r0, r3
 802a012:	f7f6 fc63 	bl	80208dc <_lv_ll_get_prev>
 802a016:	6278      	str	r0, [r7, #36]	; 0x24
 802a018:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802a01a:	2b00      	cmp	r3, #0
 802a01c:	d1af      	bne.n	8029f7e <lv_cont_layout_col+0xa4>
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 802a01e:	2101      	movs	r1, #1
 802a020:	6878      	ldr	r0, [r7, #4]
 802a022:	f7e0 fac5 	bl	800a5b0 <lv_obj_clear_protect>
}
 802a026:	bf00      	nop
 802a028:	3728      	adds	r7, #40	; 0x28
 802a02a:	46bd      	mov	sp, r7
 802a02c:	bd80      	pop	{r7, pc}

0802a02e <lv_cont_layout_row>:
/**
 * Handle row type layouts
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_row(lv_obj_t * cont)
{
 802a02e:	b580      	push	{r7, lr}
 802a030:	b088      	sub	sp, #32
 802a032:	af02      	add	r7, sp, #8
 802a034:	6078      	str	r0, [r7, #4]

    lv_layout_t type = lv_cont_get_layout(cont);
 802a036:	6878      	ldr	r0, [r7, #4]
 802a038:	f7ff fe40 	bl	8029cbc <lv_cont_get_layout>
 802a03c:	4603      	mov	r3, r0
 802a03e:	737b      	strb	r3, [r7, #13]
    lv_obj_t * child;

    /*Adjust margin and get the alignment type*/
    lv_align_t align;
    lv_coord_t vpad_corr;
    lv_bidi_dir_t base_dir = lv_obj_get_base_dir(cont);
 802a040:	6878      	ldr	r0, [r7, #4]
 802a042:	f7e1 fc4b 	bl	800b8dc <lv_obj_get_base_dir>
 802a046:	4603      	mov	r3, r0
 802a048:	733b      	strb	r3, [r7, #12]
    switch(type) {
 802a04a:	7b7b      	ldrb	r3, [r7, #13]
 802a04c:	2b07      	cmp	r3, #7
 802a04e:	d01e      	beq.n	802a08e <lv_cont_layout_row+0x60>
 802a050:	2b07      	cmp	r3, #7
 802a052:	dc2d      	bgt.n	802a0b0 <lv_cont_layout_row+0x82>
 802a054:	2b05      	cmp	r3, #5
 802a056:	d002      	beq.n	802a05e <lv_cont_layout_row+0x30>
 802a058:	2b06      	cmp	r3, #6
 802a05a:	d00e      	beq.n	802a07a <lv_cont_layout_row+0x4c>
 802a05c:	e028      	b.n	802a0b0 <lv_cont_layout_row+0x82>
        case LV_LAYOUT_ROW_TOP:
            vpad_corr = lv_obj_get_style_pad_top(cont, LV_CONT_PART_MAIN);
 802a05e:	2100      	movs	r1, #0
 802a060:	6878      	ldr	r0, [r7, #4]
 802a062:	f7ff fc47 	bl	80298f4 <lv_obj_get_style_pad_top>
 802a066:	4603      	mov	r3, r0
 802a068:	823b      	strh	r3, [r7, #16]
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_TOP_RIGHT : LV_ALIGN_IN_TOP_LEFT;
 802a06a:	7b3b      	ldrb	r3, [r7, #12]
 802a06c:	2b01      	cmp	r3, #1
 802a06e:	d101      	bne.n	802a074 <lv_cont_layout_row+0x46>
 802a070:	2303      	movs	r3, #3
 802a072:	e000      	b.n	802a076 <lv_cont_layout_row+0x48>
 802a074:	2301      	movs	r3, #1
 802a076:	74fb      	strb	r3, [r7, #19]
            break;
 802a078:	e024      	b.n	802a0c4 <lv_cont_layout_row+0x96>
        case LV_LAYOUT_ROW_MID:
            vpad_corr = 0;
 802a07a:	2300      	movs	r3, #0
 802a07c:	823b      	strh	r3, [r7, #16]
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_RIGHT_MID : LV_ALIGN_IN_LEFT_MID;
 802a07e:	7b3b      	ldrb	r3, [r7, #12]
 802a080:	2b01      	cmp	r3, #1
 802a082:	d101      	bne.n	802a088 <lv_cont_layout_row+0x5a>
 802a084:	2308      	movs	r3, #8
 802a086:	e000      	b.n	802a08a <lv_cont_layout_row+0x5c>
 802a088:	2307      	movs	r3, #7
 802a08a:	74fb      	strb	r3, [r7, #19]
            break;
 802a08c:	e01a      	b.n	802a0c4 <lv_cont_layout_row+0x96>
        case LV_LAYOUT_ROW_BOTTOM:
            vpad_corr = -lv_obj_get_style_pad_bottom(cont, LV_CONT_PART_MAIN);
 802a08e:	2100      	movs	r1, #0
 802a090:	6878      	ldr	r0, [r7, #4]
 802a092:	f7ff fc40 	bl	8029916 <lv_obj_get_style_pad_bottom>
 802a096:	4603      	mov	r3, r0
 802a098:	b29b      	uxth	r3, r3
 802a09a:	425b      	negs	r3, r3
 802a09c:	b29b      	uxth	r3, r3
 802a09e:	823b      	strh	r3, [r7, #16]
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_BOTTOM_RIGHT : LV_ALIGN_IN_BOTTOM_LEFT;
 802a0a0:	7b3b      	ldrb	r3, [r7, #12]
 802a0a2:	2b01      	cmp	r3, #1
 802a0a4:	d101      	bne.n	802a0aa <lv_cont_layout_row+0x7c>
 802a0a6:	2306      	movs	r3, #6
 802a0a8:	e000      	b.n	802a0ac <lv_cont_layout_row+0x7e>
 802a0aa:	2304      	movs	r3, #4
 802a0ac:	74fb      	strb	r3, [r7, #19]
            break;
 802a0ae:	e009      	b.n	802a0c4 <lv_cont_layout_row+0x96>
        default:
            vpad_corr = 0;
 802a0b0:	2300      	movs	r3, #0
 802a0b2:	823b      	strh	r3, [r7, #16]
            align     = base_dir == LV_BIDI_DIR_RTL ? LV_ALIGN_IN_TOP_RIGHT : LV_ALIGN_IN_TOP_LEFT;
 802a0b4:	7b3b      	ldrb	r3, [r7, #12]
 802a0b6:	2b01      	cmp	r3, #1
 802a0b8:	d101      	bne.n	802a0be <lv_cont_layout_row+0x90>
 802a0ba:	2303      	movs	r3, #3
 802a0bc:	e000      	b.n	802a0c0 <lv_cont_layout_row+0x92>
 802a0be:	2301      	movs	r3, #1
 802a0c0:	74fb      	strb	r3, [r7, #19]
            break;
 802a0c2:	bf00      	nop
    }

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
 802a0c4:	2101      	movs	r1, #1
 802a0c6:	6878      	ldr	r0, [r7, #4]
 802a0c8:	f7e0 fa4a 	bl	800a560 <lv_obj_add_protect>

    /* Align the children */
    lv_coord_t last_cord;
    if(base_dir == LV_BIDI_DIR_RTL) last_cord = lv_obj_get_style_pad_right(cont, LV_CONT_PART_MAIN);
 802a0cc:	7b3b      	ldrb	r3, [r7, #12]
 802a0ce:	2b01      	cmp	r3, #1
 802a0d0:	d106      	bne.n	802a0e0 <lv_cont_layout_row+0xb2>
 802a0d2:	2100      	movs	r1, #0
 802a0d4:	6878      	ldr	r0, [r7, #4]
 802a0d6:	f7ff fc40 	bl	802995a <lv_obj_get_style_pad_right>
 802a0da:	4603      	mov	r3, r0
 802a0dc:	81fb      	strh	r3, [r7, #14]
 802a0de:	e005      	b.n	802a0ec <lv_cont_layout_row+0xbe>
    else last_cord = lv_obj_get_style_pad_left(cont, LV_CONT_PART_MAIN);
 802a0e0:	2100      	movs	r1, #0
 802a0e2:	6878      	ldr	r0, [r7, #4]
 802a0e4:	f7ff fc28 	bl	8029938 <lv_obj_get_style_pad_left>
 802a0e8:	4603      	mov	r3, r0
 802a0ea:	81fb      	strh	r3, [r7, #14]

    lv_coord_t inner = lv_obj_get_style_pad_inner(cont, LV_CONT_PART_MAIN);
 802a0ec:	2100      	movs	r1, #0
 802a0ee:	6878      	ldr	r0, [r7, #4]
 802a0f0:	f7ff fc44 	bl	802997c <lv_obj_get_style_pad_inner>
 802a0f4:	4603      	mov	r3, r0
 802a0f6:	817b      	strh	r3, [r7, #10]

    _LV_LL_READ_BACK(cont->child_ll, child) {
 802a0f8:	687b      	ldr	r3, [r7, #4]
 802a0fa:	3304      	adds	r3, #4
 802a0fc:	4618      	mov	r0, r3
 802a0fe:	f7f6 fbc0 	bl	8020882 <_lv_ll_get_tail>
 802a102:	6178      	str	r0, [r7, #20]
 802a104:	e03e      	b.n	802a184 <lv_cont_layout_row+0x156>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 802a106:	6978      	ldr	r0, [r7, #20]
 802a108:	f7e1 fbaa 	bl	800b860 <lv_obj_get_hidden>
 802a10c:	4603      	mov	r3, r0
 802a10e:	2b00      	cmp	r3, #0
 802a110:	d130      	bne.n	802a174 <lv_cont_layout_row+0x146>
 802a112:	2104      	movs	r1, #4
 802a114:	6978      	ldr	r0, [r7, #20]
 802a116:	f7e1 fbff 	bl	800b918 <lv_obj_is_protected>
 802a11a:	4603      	mov	r3, r0
 802a11c:	2b00      	cmp	r3, #0
 802a11e:	d129      	bne.n	802a174 <lv_cont_layout_row+0x146>

        if(base_dir == LV_BIDI_DIR_RTL) lv_obj_align(child, cont, align, -last_cord, vpad_corr);
 802a120:	7b3b      	ldrb	r3, [r7, #12]
 802a122:	2b01      	cmp	r3, #1
 802a124:	d10d      	bne.n	802a142 <lv_cont_layout_row+0x114>
 802a126:	89fb      	ldrh	r3, [r7, #14]
 802a128:	425b      	negs	r3, r3
 802a12a:	b29b      	uxth	r3, r3
 802a12c:	b219      	sxth	r1, r3
 802a12e:	7cfa      	ldrb	r2, [r7, #19]
 802a130:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 802a134:	9300      	str	r3, [sp, #0]
 802a136:	460b      	mov	r3, r1
 802a138:	6879      	ldr	r1, [r7, #4]
 802a13a:	6978      	ldr	r0, [r7, #20]
 802a13c:	f7df ff4e 	bl	8009fdc <lv_obj_align>
 802a140:	e00a      	b.n	802a158 <lv_cont_layout_row+0x12a>
        else lv_obj_align(child, cont, align, last_cord, vpad_corr);
 802a142:	f9b7 100e 	ldrsh.w	r1, [r7, #14]
 802a146:	7cfa      	ldrb	r2, [r7, #19]
 802a148:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 802a14c:	9300      	str	r3, [sp, #0]
 802a14e:	460b      	mov	r3, r1
 802a150:	6879      	ldr	r1, [r7, #4]
 802a152:	6978      	ldr	r0, [r7, #20]
 802a154:	f7df ff42 	bl	8009fdc <lv_obj_align>

        last_cord += lv_obj_get_width(child) + inner;
 802a158:	6978      	ldr	r0, [r7, #20]
 802a15a:	f7e0 febf 	bl	800aedc <lv_obj_get_width>
 802a15e:	4603      	mov	r3, r0
 802a160:	461a      	mov	r2, r3
 802a162:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 802a166:	4413      	add	r3, r2
 802a168:	b29a      	uxth	r2, r3
 802a16a:	89fb      	ldrh	r3, [r7, #14]
 802a16c:	4413      	add	r3, r2
 802a16e:	b29b      	uxth	r3, r3
 802a170:	81fb      	strh	r3, [r7, #14]
 802a172:	e000      	b.n	802a176 <lv_cont_layout_row+0x148>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 802a174:	bf00      	nop
    _LV_LL_READ_BACK(cont->child_ll, child) {
 802a176:	687b      	ldr	r3, [r7, #4]
 802a178:	3304      	adds	r3, #4
 802a17a:	6979      	ldr	r1, [r7, #20]
 802a17c:	4618      	mov	r0, r3
 802a17e:	f7f6 fbad 	bl	80208dc <_lv_ll_get_prev>
 802a182:	6178      	str	r0, [r7, #20]
 802a184:	697b      	ldr	r3, [r7, #20]
 802a186:	2b00      	cmp	r3, #0
 802a188:	d1bd      	bne.n	802a106 <lv_cont_layout_row+0xd8>
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 802a18a:	2101      	movs	r1, #1
 802a18c:	6878      	ldr	r0, [r7, #4]
 802a18e:	f7e0 fa0f 	bl	800a5b0 <lv_obj_clear_protect>
}
 802a192:	bf00      	nop
 802a194:	3718      	adds	r7, #24
 802a196:	46bd      	mov	sp, r7
 802a198:	bd80      	pop	{r7, pc}

0802a19a <lv_cont_layout_center>:
/**
 * Handle the center layout
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_center(lv_obj_t * cont)
{
 802a19a:	b580      	push	{r7, lr}
 802a19c:	b088      	sub	sp, #32
 802a19e:	af02      	add	r7, sp, #8
 802a1a0:	6078      	str	r0, [r7, #4]
    lv_obj_t * child;
    uint32_t obj_num         = 0;
 802a1a2:	2300      	movs	r3, #0
 802a1a4:	613b      	str	r3, [r7, #16]
    lv_coord_t h_tot         = 0;
 802a1a6:	2300      	movs	r3, #0
 802a1a8:	81fb      	strh	r3, [r7, #14]

    lv_coord_t inner = lv_obj_get_style_pad_inner(cont, LV_CONT_PART_MAIN);
 802a1aa:	2100      	movs	r1, #0
 802a1ac:	6878      	ldr	r0, [r7, #4]
 802a1ae:	f7ff fbe5 	bl	802997c <lv_obj_get_style_pad_inner>
 802a1b2:	4603      	mov	r3, r0
 802a1b4:	817b      	strh	r3, [r7, #10]
    _LV_LL_READ(cont->child_ll, child) {
 802a1b6:	687b      	ldr	r3, [r7, #4]
 802a1b8:	3304      	adds	r3, #4
 802a1ba:	4618      	mov	r0, r3
 802a1bc:	f7f6 fb4e 	bl	802085c <_lv_ll_get_head>
 802a1c0:	6178      	str	r0, [r7, #20]
 802a1c2:	e025      	b.n	802a210 <lv_cont_layout_center+0x76>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 802a1c4:	6978      	ldr	r0, [r7, #20]
 802a1c6:	f7e1 fb4b 	bl	800b860 <lv_obj_get_hidden>
 802a1ca:	4603      	mov	r3, r0
 802a1cc:	2b00      	cmp	r3, #0
 802a1ce:	d117      	bne.n	802a200 <lv_cont_layout_center+0x66>
 802a1d0:	2104      	movs	r1, #4
 802a1d2:	6978      	ldr	r0, [r7, #20]
 802a1d4:	f7e1 fba0 	bl	800b918 <lv_obj_is_protected>
 802a1d8:	4603      	mov	r3, r0
 802a1da:	2b00      	cmp	r3, #0
 802a1dc:	d110      	bne.n	802a200 <lv_cont_layout_center+0x66>
        h_tot += lv_obj_get_height(child) + inner;
 802a1de:	6978      	ldr	r0, [r7, #20]
 802a1e0:	f7e0 fea0 	bl	800af24 <lv_obj_get_height>
 802a1e4:	4603      	mov	r3, r0
 802a1e6:	461a      	mov	r2, r3
 802a1e8:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 802a1ec:	4413      	add	r3, r2
 802a1ee:	b29a      	uxth	r2, r3
 802a1f0:	89fb      	ldrh	r3, [r7, #14]
 802a1f2:	4413      	add	r3, r2
 802a1f4:	b29b      	uxth	r3, r3
 802a1f6:	81fb      	strh	r3, [r7, #14]
        obj_num++;
 802a1f8:	693b      	ldr	r3, [r7, #16]
 802a1fa:	3301      	adds	r3, #1
 802a1fc:	613b      	str	r3, [r7, #16]
 802a1fe:	e000      	b.n	802a202 <lv_cont_layout_center+0x68>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 802a200:	bf00      	nop
    _LV_LL_READ(cont->child_ll, child) {
 802a202:	687b      	ldr	r3, [r7, #4]
 802a204:	3304      	adds	r3, #4
 802a206:	6979      	ldr	r1, [r7, #20]
 802a208:	4618      	mov	r0, r3
 802a20a:	f7f6 fb4d 	bl	80208a8 <_lv_ll_get_next>
 802a20e:	6178      	str	r0, [r7, #20]
 802a210:	697b      	ldr	r3, [r7, #20]
 802a212:	2b00      	cmp	r3, #0
 802a214:	d1d6      	bne.n	802a1c4 <lv_cont_layout_center+0x2a>
    }

    if(obj_num == 0) return;
 802a216:	693b      	ldr	r3, [r7, #16]
 802a218:	2b00      	cmp	r3, #0
 802a21a:	d058      	beq.n	802a2ce <lv_cont_layout_center+0x134>

    h_tot -= inner;
 802a21c:	89fa      	ldrh	r2, [r7, #14]
 802a21e:	897b      	ldrh	r3, [r7, #10]
 802a220:	1ad3      	subs	r3, r2, r3
 802a222:	b29b      	uxth	r3, r3
 802a224:	81fb      	strh	r3, [r7, #14]

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
 802a226:	2101      	movs	r1, #1
 802a228:	6878      	ldr	r0, [r7, #4]
 802a22a:	f7e0 f999 	bl	800a560 <lv_obj_add_protect>

    /* Align the children */
    lv_coord_t last_cord = -(h_tot / 2);
 802a22e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 802a232:	0fda      	lsrs	r2, r3, #31
 802a234:	4413      	add	r3, r2
 802a236:	105b      	asrs	r3, r3, #1
 802a238:	b21b      	sxth	r3, r3
 802a23a:	b29b      	uxth	r3, r3
 802a23c:	425b      	negs	r3, r3
 802a23e:	b29b      	uxth	r3, r3
 802a240:	81bb      	strh	r3, [r7, #12]
    _LV_LL_READ_BACK(cont->child_ll, child) {
 802a242:	687b      	ldr	r3, [r7, #4]
 802a244:	3304      	adds	r3, #4
 802a246:	4618      	mov	r0, r3
 802a248:	f7f6 fb1b 	bl	8020882 <_lv_ll_get_tail>
 802a24c:	6178      	str	r0, [r7, #20]
 802a24e:	e036      	b.n	802a2be <lv_cont_layout_center+0x124>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 802a250:	6978      	ldr	r0, [r7, #20]
 802a252:	f7e1 fb05 	bl	800b860 <lv_obj_get_hidden>
 802a256:	4603      	mov	r3, r0
 802a258:	2b00      	cmp	r3, #0
 802a25a:	d128      	bne.n	802a2ae <lv_cont_layout_center+0x114>
 802a25c:	2104      	movs	r1, #4
 802a25e:	6978      	ldr	r0, [r7, #20]
 802a260:	f7e1 fb5a 	bl	800b918 <lv_obj_is_protected>
 802a264:	4603      	mov	r3, r0
 802a266:	2b00      	cmp	r3, #0
 802a268:	d121      	bne.n	802a2ae <lv_cont_layout_center+0x114>

        lv_obj_align(child, cont, LV_ALIGN_CENTER, 0, last_cord + lv_obj_get_height(child) / 2);
 802a26a:	6978      	ldr	r0, [r7, #20]
 802a26c:	f7e0 fe5a 	bl	800af24 <lv_obj_get_height>
 802a270:	4603      	mov	r3, r0
 802a272:	0fda      	lsrs	r2, r3, #31
 802a274:	4413      	add	r3, r2
 802a276:	105b      	asrs	r3, r3, #1
 802a278:	b21b      	sxth	r3, r3
 802a27a:	b29a      	uxth	r2, r3
 802a27c:	89bb      	ldrh	r3, [r7, #12]
 802a27e:	4413      	add	r3, r2
 802a280:	b29b      	uxth	r3, r3
 802a282:	b21b      	sxth	r3, r3
 802a284:	9300      	str	r3, [sp, #0]
 802a286:	2300      	movs	r3, #0
 802a288:	2200      	movs	r2, #0
 802a28a:	6879      	ldr	r1, [r7, #4]
 802a28c:	6978      	ldr	r0, [r7, #20]
 802a28e:	f7df fea5 	bl	8009fdc <lv_obj_align>
        last_cord += lv_obj_get_height(child) + inner;
 802a292:	6978      	ldr	r0, [r7, #20]
 802a294:	f7e0 fe46 	bl	800af24 <lv_obj_get_height>
 802a298:	4603      	mov	r3, r0
 802a29a:	461a      	mov	r2, r3
 802a29c:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 802a2a0:	4413      	add	r3, r2
 802a2a2:	b29a      	uxth	r2, r3
 802a2a4:	89bb      	ldrh	r3, [r7, #12]
 802a2a6:	4413      	add	r3, r2
 802a2a8:	b29b      	uxth	r3, r3
 802a2aa:	81bb      	strh	r3, [r7, #12]
 802a2ac:	e000      	b.n	802a2b0 <lv_cont_layout_center+0x116>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 802a2ae:	bf00      	nop
    _LV_LL_READ_BACK(cont->child_ll, child) {
 802a2b0:	687b      	ldr	r3, [r7, #4]
 802a2b2:	3304      	adds	r3, #4
 802a2b4:	6979      	ldr	r1, [r7, #20]
 802a2b6:	4618      	mov	r0, r3
 802a2b8:	f7f6 fb10 	bl	80208dc <_lv_ll_get_prev>
 802a2bc:	6178      	str	r0, [r7, #20]
 802a2be:	697b      	ldr	r3, [r7, #20]
 802a2c0:	2b00      	cmp	r3, #0
 802a2c2:	d1c5      	bne.n	802a250 <lv_cont_layout_center+0xb6>
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 802a2c4:	2101      	movs	r1, #1
 802a2c6:	6878      	ldr	r0, [r7, #4]
 802a2c8:	f7e0 f972 	bl	800a5b0 <lv_obj_clear_protect>
 802a2cc:	e000      	b.n	802a2d0 <lv_cont_layout_center+0x136>
    if(obj_num == 0) return;
 802a2ce:	bf00      	nop
}
 802a2d0:	3718      	adds	r7, #24
 802a2d2:	46bd      	mov	sp, r7
 802a2d4:	bd80      	pop	{r7, pc}

0802a2d6 <lv_cont_layout_pretty>:
 * Handle the pretty layout. Put as many object as possible in row
 * then begin a new row
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_pretty(lv_obj_t * cont)
{
 802a2d6:	b5b0      	push	{r4, r5, r7, lr}
 802a2d8:	b090      	sub	sp, #64	; 0x40
 802a2da:	af02      	add	r7, sp, #8
 802a2dc:	6078      	str	r0, [r7, #4]
    lv_layout_t type = lv_cont_get_layout(cont);
 802a2de:	6878      	ldr	r0, [r7, #4]
 802a2e0:	f7ff fcec 	bl	8029cbc <lv_cont_get_layout>
 802a2e4:	4603      	mov	r3, r0
 802a2e6:	777b      	strb	r3, [r7, #29]

    lv_obj_t * child_rs;  /* Row starter child */
    lv_obj_t * child_rc;  /* Row closer child */
    lv_obj_t * child_tmp; /* Temporary child */
    lv_coord_t w_obj         = lv_obj_get_width(cont);
 802a2e8:	6878      	ldr	r0, [r7, #4]
 802a2ea:	f7e0 fdf7 	bl	800aedc <lv_obj_get_width>
 802a2ee:	4603      	mov	r3, r0
 802a2f0:	837b      	strh	r3, [r7, #26]
    lv_coord_t act_y         =  lv_obj_get_style_pad_top(cont, LV_CONT_PART_MAIN);
 802a2f2:	2100      	movs	r1, #0
 802a2f4:	6878      	ldr	r0, [r7, #4]
 802a2f6:	f7ff fafd 	bl	80298f4 <lv_obj_get_style_pad_top>
 802a2fa:	4603      	mov	r3, r0
 802a2fc:	857b      	strh	r3, [r7, #42]	; 0x2a
    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/

    child_rs = _lv_ll_get_tail(&cont->child_ll); /*Set the row starter child*/
 802a2fe:	687b      	ldr	r3, [r7, #4]
 802a300:	3304      	adds	r3, #4
 802a302:	4618      	mov	r0, r3
 802a304:	f7f6 fabd 	bl	8020882 <_lv_ll_get_tail>
 802a308:	6378      	str	r0, [r7, #52]	; 0x34
    if(child_rs == NULL) return;                /*Return if no child*/
 802a30a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802a30c:	2b00      	cmp	r3, #0
 802a30e:	f000 81cd 	beq.w	802a6ac <lv_cont_layout_pretty+0x3d6>

    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
 802a312:	2101      	movs	r1, #1
 802a314:	6878      	ldr	r0, [r7, #4]
 802a316:	f7e0 f923 	bl	800a560 <lv_obj_add_protect>
    lv_coord_t pleft          =  lv_obj_get_style_pad_left(cont, LV_CONT_PART_MAIN);
 802a31a:	2100      	movs	r1, #0
 802a31c:	6878      	ldr	r0, [r7, #4]
 802a31e:	f7ff fb0b 	bl	8029938 <lv_obj_get_style_pad_left>
 802a322:	4603      	mov	r3, r0
 802a324:	833b      	strh	r3, [r7, #24]
    lv_coord_t pright         =  lv_obj_get_style_pad_right(cont, LV_CONT_PART_MAIN);
 802a326:	2100      	movs	r1, #0
 802a328:	6878      	ldr	r0, [r7, #4]
 802a32a:	f7ff fb16 	bl	802995a <lv_obj_get_style_pad_right>
 802a32e:	4603      	mov	r3, r0
 802a330:	82fb      	strh	r3, [r7, #22]
    lv_coord_t pinner = lv_obj_get_style_pad_inner(cont, LV_CONT_PART_MAIN);
 802a332:	2100      	movs	r1, #0
 802a334:	6878      	ldr	r0, [r7, #4]
 802a336:	f7ff fb21 	bl	802997c <lv_obj_get_style_pad_inner>
 802a33a:	4603      	mov	r3, r0
 802a33c:	82bb      	strh	r3, [r7, #20]

    child_rc = child_rs; /*Initially the the row starter and closer is the same*/
 802a33e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802a340:	633b      	str	r3, [r7, #48]	; 0x30
    while(child_rs != NULL) {
 802a342:	e1a8      	b.n	802a696 <lv_cont_layout_pretty+0x3c0>
        lv_coord_t h_row = 0;
 802a344:	2300      	movs	r3, #0
 802a346:	853b      	strh	r3, [r7, #40]	; 0x28
        lv_coord_t w_row = pleft + pright; /*The width is at least the left+right pad*/
 802a348:	8b3a      	ldrh	r2, [r7, #24]
 802a34a:	8afb      	ldrh	r3, [r7, #22]
 802a34c:	4413      	add	r3, r2
 802a34e:	b29b      	uxth	r3, r3
 802a350:	84fb      	strh	r3, [r7, #38]	; 0x26
        uint32_t obj_num = 0;
 802a352:	2300      	movs	r3, #0
 802a354:	623b      	str	r3, [r7, #32]

        /*Find the row closer object and collect some data*/
        do {
            if(lv_obj_get_hidden(child_rc) == false && lv_obj_is_protected(child_rc, LV_PROTECT_POS) == false) {
 802a356:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a358:	f7e1 fa82 	bl	800b860 <lv_obj_get_hidden>
 802a35c:	4603      	mov	r3, r0
 802a35e:	f083 0301 	eor.w	r3, r3, #1
 802a362:	b2db      	uxtb	r3, r3
 802a364:	2b00      	cmp	r3, #0
 802a366:	d06c      	beq.n	802a442 <lv_cont_layout_pretty+0x16c>
 802a368:	2104      	movs	r1, #4
 802a36a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a36c:	f7e1 fad4 	bl	800b918 <lv_obj_is_protected>
 802a370:	4603      	mov	r3, r0
 802a372:	f083 0301 	eor.w	r3, r3, #1
 802a376:	b2db      	uxtb	r3, r3
 802a378:	2b00      	cmp	r3, #0
 802a37a:	d062      	beq.n	802a442 <lv_cont_layout_pretty+0x16c>
                /*If this object is already not fit then break*/
                lv_coord_t w = lv_obj_get_width(child_rc);
 802a37c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a37e:	f7e0 fdad 	bl	800aedc <lv_obj_get_width>
 802a382:	4603      	mov	r3, r0
 802a384:	827b      	strh	r3, [r7, #18]
                w += lv_obj_get_style_margin_left(child_rc, LV_OBJ_PART_MAIN);
 802a386:	2100      	movs	r1, #0
 802a388:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a38a:	f7ff fb2a 	bl	80299e2 <lv_obj_get_style_margin_left>
 802a38e:	4603      	mov	r3, r0
 802a390:	b29a      	uxth	r2, r3
 802a392:	8a7b      	ldrh	r3, [r7, #18]
 802a394:	4413      	add	r3, r2
 802a396:	b29b      	uxth	r3, r3
 802a398:	827b      	strh	r3, [r7, #18]
                w += lv_obj_get_style_margin_right(child_rc, LV_OBJ_PART_MAIN);
 802a39a:	2100      	movs	r1, #0
 802a39c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a39e:	f7ff fb31 	bl	8029a04 <lv_obj_get_style_margin_right>
 802a3a2:	4603      	mov	r3, r0
 802a3a4:	b29a      	uxth	r2, r3
 802a3a6:	8a7b      	ldrh	r3, [r7, #18]
 802a3a8:	4413      	add	r3, r2
 802a3aa:	b29b      	uxth	r3, r3
 802a3ac:	827b      	strh	r3, [r7, #18]
                if(w_row + w > w_obj) {
 802a3ae:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 802a3b2:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 802a3b6:	441a      	add	r2, r3
 802a3b8:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 802a3bc:	429a      	cmp	r2, r3
 802a3be:	dd0d      	ble.n	802a3dc <lv_cont_layout_pretty+0x106>
                    /*Step back one child because the last already not fit, so the previous is the
                     * closer*/
                    if(child_rc != NULL && obj_num != 0) {
 802a3c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802a3c2:	2b00      	cmp	r3, #0
 802a3c4:	d04e      	beq.n	802a464 <lv_cont_layout_pretty+0x18e>
 802a3c6:	6a3b      	ldr	r3, [r7, #32]
 802a3c8:	2b00      	cmp	r3, #0
 802a3ca:	d04b      	beq.n	802a464 <lv_cont_layout_pretty+0x18e>
                        child_rc = _lv_ll_get_next(&cont->child_ll, child_rc);
 802a3cc:	687b      	ldr	r3, [r7, #4]
 802a3ce:	3304      	adds	r3, #4
 802a3d0:	6b39      	ldr	r1, [r7, #48]	; 0x30
 802a3d2:	4618      	mov	r0, r3
 802a3d4:	f7f6 fa68 	bl	80208a8 <_lv_ll_get_next>
 802a3d8:	6338      	str	r0, [r7, #48]	; 0x30
                    }
                    break;
 802a3da:	e043      	b.n	802a464 <lv_cont_layout_pretty+0x18e>
                }
                w_row += w + pinner; /*Add the object width + inner padding*/
 802a3dc:	8a7a      	ldrh	r2, [r7, #18]
 802a3de:	8abb      	ldrh	r3, [r7, #20]
 802a3e0:	4413      	add	r3, r2
 802a3e2:	b29a      	uxth	r2, r3
 802a3e4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 802a3e6:	4413      	add	r3, r2
 802a3e8:	b29b      	uxth	r3, r3
 802a3ea:	84fb      	strh	r3, [r7, #38]	; 0x26

                lv_coord_t h = lv_obj_get_height(child_rc);
 802a3ec:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a3ee:	f7e0 fd99 	bl	800af24 <lv_obj_get_height>
 802a3f2:	4603      	mov	r3, r0
 802a3f4:	823b      	strh	r3, [r7, #16]
                h += lv_obj_get_style_margin_top(child_rc, LV_OBJ_PART_MAIN);
 802a3f6:	2100      	movs	r1, #0
 802a3f8:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a3fa:	f7ff fad0 	bl	802999e <lv_obj_get_style_margin_top>
 802a3fe:	4603      	mov	r3, r0
 802a400:	b29a      	uxth	r2, r3
 802a402:	8a3b      	ldrh	r3, [r7, #16]
 802a404:	4413      	add	r3, r2
 802a406:	b29b      	uxth	r3, r3
 802a408:	823b      	strh	r3, [r7, #16]
                h += lv_obj_get_style_margin_bottom(child_rc, LV_OBJ_PART_MAIN);
 802a40a:	2100      	movs	r1, #0
 802a40c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a40e:	f7ff fad7 	bl	80299c0 <lv_obj_get_style_margin_bottom>
 802a412:	4603      	mov	r3, r0
 802a414:	b29a      	uxth	r2, r3
 802a416:	8a3b      	ldrh	r3, [r7, #16]
 802a418:	4413      	add	r3, r2
 802a41a:	b29b      	uxth	r3, r3
 802a41c:	823b      	strh	r3, [r7, #16]
                h_row = LV_MATH_MAX(h_row, h);         /*Search the highest object*/
 802a41e:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 802a422:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 802a426:	4293      	cmp	r3, r2
 802a428:	bfb8      	it	lt
 802a42a:	4613      	movlt	r3, r2
 802a42c:	853b      	strh	r3, [r7, #40]	; 0x28
                obj_num++;
 802a42e:	6a3b      	ldr	r3, [r7, #32]
 802a430:	3301      	adds	r3, #1
 802a432:	623b      	str	r3, [r7, #32]
                if(lv_obj_is_protected(child_rc, LV_PROTECT_FOLLOW))
 802a434:	2108      	movs	r1, #8
 802a436:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a438:	f7e1 fa6e 	bl	800b918 <lv_obj_is_protected>
 802a43c:	4603      	mov	r3, r0
 802a43e:	2b00      	cmp	r3, #0
 802a440:	d112      	bne.n	802a468 <lv_cont_layout_pretty+0x192>
                    break; /*If can not be followed by an other object then break here*/
            }
            child_rc = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Load the next object*/
 802a442:	687b      	ldr	r3, [r7, #4]
 802a444:	3304      	adds	r3, #4
 802a446:	6b39      	ldr	r1, [r7, #48]	; 0x30
 802a448:	4618      	mov	r0, r3
 802a44a:	f7f6 fa47 	bl	80208dc <_lv_ll_get_prev>
 802a44e:	6338      	str	r0, [r7, #48]	; 0x30
            if(obj_num == 0)
 802a450:	6a3b      	ldr	r3, [r7, #32]
 802a452:	2b00      	cmp	r3, #0
 802a454:	d101      	bne.n	802a45a <lv_cont_layout_pretty+0x184>
                child_rs = child_rc; /*If the first object was hidden (or too long) then set the
 802a456:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802a458:	637b      	str	r3, [r7, #52]	; 0x34
                                        next as first */
        } while(child_rc != NULL);
 802a45a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802a45c:	2b00      	cmp	r3, #0
 802a45e:	f47f af7a 	bne.w	802a356 <lv_cont_layout_pretty+0x80>
 802a462:	e002      	b.n	802a46a <lv_cont_layout_pretty+0x194>
                    break;
 802a464:	bf00      	nop
 802a466:	e000      	b.n	802a46a <lv_cont_layout_pretty+0x194>
                    break; /*If can not be followed by an other object then break here*/
 802a468:	bf00      	nop

        /*If the object is too long then align it to the middle*/
        if(obj_num == 0) {
 802a46a:	6a3b      	ldr	r3, [r7, #32]
 802a46c:	2b00      	cmp	r3, #0
 802a46e:	d12a      	bne.n	802a4c6 <lv_cont_layout_pretty+0x1f0>
            if(child_rc != NULL) {
 802a470:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802a472:	2b00      	cmp	r3, #0
 802a474:	f000 80fb 	beq.w	802a66e <lv_cont_layout_pretty+0x398>
                lv_style_int_t mtop = lv_obj_get_style_margin_top(child_rc, LV_OBJ_PART_MAIN);
 802a478:	2100      	movs	r1, #0
 802a47a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a47c:	f7ff fa8f 	bl	802999e <lv_obj_get_style_margin_top>
 802a480:	4603      	mov	r3, r0
 802a482:	813b      	strh	r3, [r7, #8]

                lv_obj_align(child_rc, cont, LV_ALIGN_IN_TOP_MID, 0, act_y + mtop);
 802a484:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 802a486:	893b      	ldrh	r3, [r7, #8]
 802a488:	4413      	add	r3, r2
 802a48a:	b29b      	uxth	r3, r3
 802a48c:	b21b      	sxth	r3, r3
 802a48e:	9300      	str	r3, [sp, #0]
 802a490:	2300      	movs	r3, #0
 802a492:	2202      	movs	r2, #2
 802a494:	6879      	ldr	r1, [r7, #4]
 802a496:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a498:	f7df fda0 	bl	8009fdc <lv_obj_align>
                h_row = lv_obj_get_height(child_rc); /*Not set previously because of the early break*/
 802a49c:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a49e:	f7e0 fd41 	bl	800af24 <lv_obj_get_height>
 802a4a2:	4603      	mov	r3, r0
 802a4a4:	853b      	strh	r3, [r7, #40]	; 0x28
                h_row += mtop;
 802a4a6:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 802a4a8:	893b      	ldrh	r3, [r7, #8]
 802a4aa:	4413      	add	r3, r2
 802a4ac:	b29b      	uxth	r3, r3
 802a4ae:	853b      	strh	r3, [r7, #40]	; 0x28
                h_row += lv_obj_get_style_margin_bottom(child_rc, LV_OBJ_PART_MAIN);
 802a4b0:	2100      	movs	r1, #0
 802a4b2:	6b38      	ldr	r0, [r7, #48]	; 0x30
 802a4b4:	f7ff fa84 	bl	80299c0 <lv_obj_get_style_margin_bottom>
 802a4b8:	4603      	mov	r3, r0
 802a4ba:	b29a      	uxth	r2, r3
 802a4bc:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 802a4be:	4413      	add	r3, r2
 802a4c0:	b29b      	uxth	r3, r3
 802a4c2:	853b      	strh	r3, [r7, #40]	; 0x28
 802a4c4:	e0d3      	b.n	802a66e <lv_cont_layout_pretty+0x398>
            }
        }
        /*If there is only one object in the row then align it to the middle*/
        else if(obj_num == 1) {
 802a4c6:	6a3b      	ldr	r3, [r7, #32]
 802a4c8:	2b01      	cmp	r3, #1
 802a4ca:	d111      	bne.n	802a4f0 <lv_cont_layout_pretty+0x21a>
            lv_obj_align(child_rs, cont, LV_ALIGN_IN_TOP_MID,
                         0,
                         act_y + lv_obj_get_style_margin_top(child_rs, LV_OBJ_PART_MAIN));
 802a4cc:	2100      	movs	r1, #0
 802a4ce:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802a4d0:	f7ff fa65 	bl	802999e <lv_obj_get_style_margin_top>
 802a4d4:	4603      	mov	r3, r0
 802a4d6:	b29a      	uxth	r2, r3
 802a4d8:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 802a4da:	4413      	add	r3, r2
 802a4dc:	b29b      	uxth	r3, r3
            lv_obj_align(child_rs, cont, LV_ALIGN_IN_TOP_MID,
 802a4de:	b21b      	sxth	r3, r3
 802a4e0:	9300      	str	r3, [sp, #0]
 802a4e2:	2300      	movs	r3, #0
 802a4e4:	2202      	movs	r2, #2
 802a4e6:	6879      	ldr	r1, [r7, #4]
 802a4e8:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802a4ea:	f7df fd77 	bl	8009fdc <lv_obj_align>
 802a4ee:	e0be      	b.n	802a66e <lv_cont_layout_pretty+0x398>
        }
        /* Align the children (from child_rs to child_rc)*/
        else {
            w_row -= pinner * obj_num;
 802a4f0:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 802a4f2:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 802a4f6:	b299      	uxth	r1, r3
 802a4f8:	6a3b      	ldr	r3, [r7, #32]
 802a4fa:	b29b      	uxth	r3, r3
 802a4fc:	fb11 f303 	smulbb	r3, r1, r3
 802a500:	b29b      	uxth	r3, r3
 802a502:	1ad3      	subs	r3, r2, r3
 802a504:	b29b      	uxth	r3, r3
 802a506:	84fb      	strh	r3, [r7, #38]	; 0x26
            lv_coord_t new_pinner = (w_obj - w_row) / (obj_num - 1);
 802a508:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 802a50c:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 802a510:	1ad3      	subs	r3, r2, r3
 802a512:	461a      	mov	r2, r3
 802a514:	6a3b      	ldr	r3, [r7, #32]
 802a516:	3b01      	subs	r3, #1
 802a518:	fbb2 f3f3 	udiv	r3, r2, r3
 802a51c:	81fb      	strh	r3, [r7, #14]
            lv_coord_t act_x    = pleft; /*x init*/
 802a51e:	8b3b      	ldrh	r3, [r7, #24]
 802a520:	83fb      	strh	r3, [r7, #30]
            child_tmp           = child_rs;
 802a522:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802a524:	62fb      	str	r3, [r7, #44]	; 0x2c
            while(child_tmp != NULL) {
 802a526:	e09c      	b.n	802a662 <lv_cont_layout_pretty+0x38c>
                if(lv_obj_get_hidden(child_tmp) == false && lv_obj_is_protected(child_tmp, LV_PROTECT_POS) == false) {
 802a528:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a52a:	f7e1 f999 	bl	800b860 <lv_obj_get_hidden>
 802a52e:	4603      	mov	r3, r0
 802a530:	f083 0301 	eor.w	r3, r3, #1
 802a534:	b2db      	uxtb	r3, r3
 802a536:	2b00      	cmp	r3, #0
 802a538:	f000 8088 	beq.w	802a64c <lv_cont_layout_pretty+0x376>
 802a53c:	2104      	movs	r1, #4
 802a53e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a540:	f7e1 f9ea 	bl	800b918 <lv_obj_is_protected>
 802a544:	4603      	mov	r3, r0
 802a546:	f083 0301 	eor.w	r3, r3, #1
 802a54a:	b2db      	uxtb	r3, r3
 802a54c:	2b00      	cmp	r3, #0
 802a54e:	d07d      	beq.n	802a64c <lv_cont_layout_pretty+0x376>
                    lv_coord_t mleft = lv_obj_get_style_margin_left(child_tmp, LV_OBJ_PART_MAIN);
 802a550:	2100      	movs	r1, #0
 802a552:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a554:	f7ff fa45 	bl	80299e2 <lv_obj_get_style_margin_left>
 802a558:	4603      	mov	r3, r0
 802a55a:	81bb      	strh	r3, [r7, #12]
                    lv_coord_t mright = lv_obj_get_style_margin_right(child_tmp, LV_OBJ_PART_MAIN);
 802a55c:	2100      	movs	r1, #0
 802a55e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a560:	f7ff fa50 	bl	8029a04 <lv_obj_get_style_margin_right>
 802a564:	4603      	mov	r3, r0
 802a566:	817b      	strh	r3, [r7, #10]
                    switch(type) {
 802a568:	7f7b      	ldrb	r3, [r7, #29]
 802a56a:	2b0a      	cmp	r3, #10
 802a56c:	d039      	beq.n	802a5e2 <lv_cont_layout_pretty+0x30c>
 802a56e:	2b0a      	cmp	r3, #10
 802a570:	dc58      	bgt.n	802a624 <lv_cont_layout_pretty+0x34e>
 802a572:	2b08      	cmp	r3, #8
 802a574:	d002      	beq.n	802a57c <lv_cont_layout_pretty+0x2a6>
 802a576:	2b09      	cmp	r3, #9
 802a578:	d017      	beq.n	802a5aa <lv_cont_layout_pretty+0x2d4>
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
                                         act_x + mleft,
                                         act_y + h_row - lv_obj_get_height(child_tmp) - lv_obj_get_style_margin_bottom(child_tmp, LV_OBJ_PART_MAIN));
                            break;
                        default:
                            break;
 802a57a:	e053      	b.n	802a624 <lv_cont_layout_pretty+0x34e>
                                         act_x + mleft,
 802a57c:	8bfa      	ldrh	r2, [r7, #30]
 802a57e:	89bb      	ldrh	r3, [r7, #12]
 802a580:	4413      	add	r3, r2
 802a582:	b29b      	uxth	r3, r3
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
 802a584:	b21c      	sxth	r4, r3
                                         act_y + lv_obj_get_style_margin_top(child_tmp, LV_OBJ_PART_MAIN));
 802a586:	2100      	movs	r1, #0
 802a588:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a58a:	f7ff fa08 	bl	802999e <lv_obj_get_style_margin_top>
 802a58e:	4603      	mov	r3, r0
 802a590:	b29a      	uxth	r2, r3
 802a592:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 802a594:	4413      	add	r3, r2
 802a596:	b29b      	uxth	r3, r3
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
 802a598:	b21b      	sxth	r3, r3
 802a59a:	9300      	str	r3, [sp, #0]
 802a59c:	4623      	mov	r3, r4
 802a59e:	2201      	movs	r2, #1
 802a5a0:	6879      	ldr	r1, [r7, #4]
 802a5a2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a5a4:	f7df fd1a 	bl	8009fdc <lv_obj_align>
                            break;
 802a5a8:	e03d      	b.n	802a626 <lv_cont_layout_pretty+0x350>
                                         act_x + mleft,
 802a5aa:	8bfa      	ldrh	r2, [r7, #30]
 802a5ac:	89bb      	ldrh	r3, [r7, #12]
 802a5ae:	4413      	add	r3, r2
 802a5b0:	b29b      	uxth	r3, r3
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
 802a5b2:	b21d      	sxth	r5, r3
                                         act_y + (h_row - lv_obj_get_height(child_tmp)) / 2);
 802a5b4:	f9b7 4028 	ldrsh.w	r4, [r7, #40]	; 0x28
 802a5b8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a5ba:	f7e0 fcb3 	bl	800af24 <lv_obj_get_height>
 802a5be:	4603      	mov	r3, r0
 802a5c0:	1ae3      	subs	r3, r4, r3
 802a5c2:	0fda      	lsrs	r2, r3, #31
 802a5c4:	4413      	add	r3, r2
 802a5c6:	105b      	asrs	r3, r3, #1
 802a5c8:	b29a      	uxth	r2, r3
 802a5ca:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 802a5cc:	4413      	add	r3, r2
 802a5ce:	b29b      	uxth	r3, r3
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
 802a5d0:	b21b      	sxth	r3, r3
 802a5d2:	9300      	str	r3, [sp, #0]
 802a5d4:	462b      	mov	r3, r5
 802a5d6:	2201      	movs	r2, #1
 802a5d8:	6879      	ldr	r1, [r7, #4]
 802a5da:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a5dc:	f7df fcfe 	bl	8009fdc <lv_obj_align>
                            break;
 802a5e0:	e021      	b.n	802a626 <lv_cont_layout_pretty+0x350>
                                         act_x + mleft,
 802a5e2:	8bfa      	ldrh	r2, [r7, #30]
 802a5e4:	89bb      	ldrh	r3, [r7, #12]
 802a5e6:	4413      	add	r3, r2
 802a5e8:	b29b      	uxth	r3, r3
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
 802a5ea:	b21d      	sxth	r5, r3
                                         act_y + h_row - lv_obj_get_height(child_tmp) - lv_obj_get_style_margin_bottom(child_tmp, LV_OBJ_PART_MAIN));
 802a5ec:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 802a5ee:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 802a5f0:	4413      	add	r3, r2
 802a5f2:	b29c      	uxth	r4, r3
 802a5f4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a5f6:	f7e0 fc95 	bl	800af24 <lv_obj_get_height>
 802a5fa:	4603      	mov	r3, r0
 802a5fc:	b29b      	uxth	r3, r3
 802a5fe:	1ae3      	subs	r3, r4, r3
 802a600:	b29c      	uxth	r4, r3
 802a602:	2100      	movs	r1, #0
 802a604:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a606:	f7ff f9db 	bl	80299c0 <lv_obj_get_style_margin_bottom>
 802a60a:	4603      	mov	r3, r0
 802a60c:	b29b      	uxth	r3, r3
 802a60e:	1ae3      	subs	r3, r4, r3
 802a610:	b29b      	uxth	r3, r3
                            lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT,
 802a612:	b21b      	sxth	r3, r3
 802a614:	9300      	str	r3, [sp, #0]
 802a616:	462b      	mov	r3, r5
 802a618:	2201      	movs	r2, #1
 802a61a:	6879      	ldr	r1, [r7, #4]
 802a61c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a61e:	f7df fcdd 	bl	8009fdc <lv_obj_align>
                            break;
 802a622:	e000      	b.n	802a626 <lv_cont_layout_pretty+0x350>
                            break;
 802a624:	bf00      	nop
                    }

                    act_x += lv_obj_get_width(child_tmp) + new_pinner + mleft + mright;
 802a626:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 802a628:	f7e0 fc58 	bl	800aedc <lv_obj_get_width>
 802a62c:	4603      	mov	r3, r0
 802a62e:	461a      	mov	r2, r3
 802a630:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 802a634:	441a      	add	r2, r3
 802a636:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 802a63a:	441a      	add	r2, r3
 802a63c:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 802a640:	4413      	add	r3, r2
 802a642:	b29a      	uxth	r2, r3
 802a644:	8bfb      	ldrh	r3, [r7, #30]
 802a646:	4413      	add	r3, r2
 802a648:	b29b      	uxth	r3, r3
 802a64a:	83fb      	strh	r3, [r7, #30]
                }
                if(child_tmp == child_rc) break;
 802a64c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 802a64e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802a650:	429a      	cmp	r2, r3
 802a652:	d00b      	beq.n	802a66c <lv_cont_layout_pretty+0x396>
                child_tmp = _lv_ll_get_prev(&cont->child_ll, child_tmp);
 802a654:	687b      	ldr	r3, [r7, #4]
 802a656:	3304      	adds	r3, #4
 802a658:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 802a65a:	4618      	mov	r0, r3
 802a65c:	f7f6 f93e 	bl	80208dc <_lv_ll_get_prev>
 802a660:	62f8      	str	r0, [r7, #44]	; 0x2c
            while(child_tmp != NULL) {
 802a662:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802a664:	2b00      	cmp	r3, #0
 802a666:	f47f af5f 	bne.w	802a528 <lv_cont_layout_pretty+0x252>
 802a66a:	e000      	b.n	802a66e <lv_cont_layout_pretty+0x398>
                if(child_tmp == child_rc) break;
 802a66c:	bf00      	nop
            }
        }

        if(child_rc == NULL) break;
 802a66e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802a670:	2b00      	cmp	r3, #0
 802a672:	d015      	beq.n	802a6a0 <lv_cont_layout_pretty+0x3ca>
        act_y += pinner + h_row;           /*y increment*/
 802a674:	8aba      	ldrh	r2, [r7, #20]
 802a676:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 802a678:	4413      	add	r3, r2
 802a67a:	b29a      	uxth	r2, r3
 802a67c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 802a67e:	4413      	add	r3, r2
 802a680:	b29b      	uxth	r3, r3
 802a682:	857b      	strh	r3, [r7, #42]	; 0x2a
        child_rs = _lv_ll_get_prev(&cont->child_ll, child_rc); /*Go to the next object*/
 802a684:	687b      	ldr	r3, [r7, #4]
 802a686:	3304      	adds	r3, #4
 802a688:	6b39      	ldr	r1, [r7, #48]	; 0x30
 802a68a:	4618      	mov	r0, r3
 802a68c:	f7f6 f926 	bl	80208dc <_lv_ll_get_prev>
 802a690:	6378      	str	r0, [r7, #52]	; 0x34
        child_rc = child_rs;
 802a692:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802a694:	633b      	str	r3, [r7, #48]	; 0x30
    while(child_rs != NULL) {
 802a696:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802a698:	2b00      	cmp	r3, #0
 802a69a:	f47f ae53 	bne.w	802a344 <lv_cont_layout_pretty+0x6e>
 802a69e:	e000      	b.n	802a6a2 <lv_cont_layout_pretty+0x3cc>
        if(child_rc == NULL) break;
 802a6a0:	bf00      	nop
    }
    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 802a6a2:	2101      	movs	r1, #1
 802a6a4:	6878      	ldr	r0, [r7, #4]
 802a6a6:	f7df ff83 	bl	800a5b0 <lv_obj_clear_protect>
 802a6aa:	e000      	b.n	802a6ae <lv_cont_layout_pretty+0x3d8>
    if(child_rs == NULL) return;                /*Return if no child*/
 802a6ac:	bf00      	nop
}
 802a6ae:	3738      	adds	r7, #56	; 0x38
 802a6b0:	46bd      	mov	sp, r7
 802a6b2:	bdb0      	pop	{r4, r5, r7, pc}

0802a6b4 <lv_cont_layout_grid>:
/**
 * Handle the grid layout. Align same-sized objects in a grid
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_grid(lv_obj_t * cont)
{
 802a6b4:	b580      	push	{r7, lr}
 802a6b6:	b088      	sub	sp, #32
 802a6b8:	af00      	add	r7, sp, #0
 802a6ba:	6078      	str	r0, [r7, #4]
    lv_coord_t w_fit         =  lv_obj_get_width_fit(cont);
 802a6bc:	6878      	ldr	r0, [r7, #4]
 802a6be:	f7e0 fc55 	bl	800af6c <lv_obj_get_width_fit>
 802a6c2:	4603      	mov	r3, r0
 802a6c4:	82fb      	strh	r3, [r7, #22]
    lv_coord_t inner = lv_obj_get_style_pad_inner(cont, LV_CONT_PART_MAIN);
 802a6c6:	2100      	movs	r1, #0
 802a6c8:	6878      	ldr	r0, [r7, #4]
 802a6ca:	f7ff f957 	bl	802997c <lv_obj_get_style_pad_inner>
 802a6ce:	4603      	mov	r3, r0
 802a6d0:	82bb      	strh	r3, [r7, #20]
    lv_coord_t y_ofs = inner + lv_obj_get_height(lv_obj_get_child(cont, NULL));
 802a6d2:	2100      	movs	r1, #0
 802a6d4:	6878      	ldr	r0, [r7, #4]
 802a6d6:	f7e0 fb3f 	bl	800ad58 <lv_obj_get_child>
 802a6da:	4603      	mov	r3, r0
 802a6dc:	4618      	mov	r0, r3
 802a6de:	f7e0 fc21 	bl	800af24 <lv_obj_get_height>
 802a6e2:	4603      	mov	r3, r0
 802a6e4:	b29a      	uxth	r2, r3
 802a6e6:	8abb      	ldrh	r3, [r7, #20]
 802a6e8:	4413      	add	r3, r2
 802a6ea:	b29b      	uxth	r3, r3
 802a6ec:	827b      	strh	r3, [r7, #18]

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_add_protect(cont, LV_PROTECT_CHILD_CHG);
 802a6ee:	2101      	movs	r1, #1
 802a6f0:	6878      	ldr	r0, [r7, #4]
 802a6f2:	f7df ff35 	bl	800a560 <lv_obj_add_protect>

    /* Align the children */
    lv_coord_t left = lv_obj_get_style_pad_left(cont, LV_CONT_PART_MAIN);
 802a6f6:	2100      	movs	r1, #0
 802a6f8:	6878      	ldr	r0, [r7, #4]
 802a6fa:	f7ff f91d 	bl	8029938 <lv_obj_get_style_pad_left>
 802a6fe:	4603      	mov	r3, r0
 802a700:	823b      	strh	r3, [r7, #16]
    lv_coord_t act_x = left;
 802a702:	8a3b      	ldrh	r3, [r7, #16]
 802a704:	83fb      	strh	r3, [r7, #30]
    lv_coord_t act_y = lv_obj_get_style_pad_top(cont, LV_CONT_PART_MAIN);
 802a706:	2100      	movs	r1, #0
 802a708:	6878      	ldr	r0, [r7, #4]
 802a70a:	f7ff f8f3 	bl	80298f4 <lv_obj_get_style_pad_top>
 802a70e:	4603      	mov	r3, r0
 802a710:	83bb      	strh	r3, [r7, #28]
    lv_obj_t * child;
    _LV_LL_READ_BACK(cont->child_ll, child) {
 802a712:	687b      	ldr	r3, [r7, #4]
 802a714:	3304      	adds	r3, #4
 802a716:	4618      	mov	r0, r3
 802a718:	f7f6 f8b3 	bl	8020882 <_lv_ll_get_tail>
 802a71c:	61b8      	str	r0, [r7, #24]
 802a71e:	e03d      	b.n	802a79c <lv_cont_layout_grid+0xe8>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 802a720:	69b8      	ldr	r0, [r7, #24]
 802a722:	f7e1 f89d 	bl	800b860 <lv_obj_get_hidden>
 802a726:	4603      	mov	r3, r0
 802a728:	2b00      	cmp	r3, #0
 802a72a:	d12f      	bne.n	802a78c <lv_cont_layout_grid+0xd8>
 802a72c:	2104      	movs	r1, #4
 802a72e:	69b8      	ldr	r0, [r7, #24]
 802a730:	f7e1 f8f2 	bl	800b918 <lv_obj_is_protected>
 802a734:	4603      	mov	r3, r0
 802a736:	2b00      	cmp	r3, #0
 802a738:	d128      	bne.n	802a78c <lv_cont_layout_grid+0xd8>
        lv_coord_t obj_w = lv_obj_get_width(child);
 802a73a:	69b8      	ldr	r0, [r7, #24]
 802a73c:	f7e0 fbce 	bl	800aedc <lv_obj_get_width>
 802a740:	4603      	mov	r3, r0
 802a742:	81fb      	strh	r3, [r7, #14]
        if(act_x + obj_w > w_fit + left) {
 802a744:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 802a748:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 802a74c:	441a      	add	r2, r3
 802a74e:	f9b7 1016 	ldrsh.w	r1, [r7, #22]
 802a752:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 802a756:	440b      	add	r3, r1
 802a758:	429a      	cmp	r2, r3
 802a75a:	dd06      	ble.n	802a76a <lv_cont_layout_grid+0xb6>
            act_x = left;
 802a75c:	8a3b      	ldrh	r3, [r7, #16]
 802a75e:	83fb      	strh	r3, [r7, #30]
            act_y += y_ofs;
 802a760:	8bba      	ldrh	r2, [r7, #28]
 802a762:	8a7b      	ldrh	r3, [r7, #18]
 802a764:	4413      	add	r3, r2
 802a766:	b29b      	uxth	r3, r3
 802a768:	83bb      	strh	r3, [r7, #28]
        }

        lv_obj_set_pos(child, act_x, act_y);
 802a76a:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 802a76e:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 802a772:	4619      	mov	r1, r3
 802a774:	69b8      	ldr	r0, [r7, #24]
 802a776:	f7df fa6b 	bl	8009c50 <lv_obj_set_pos>
        act_x += inner + obj_w;
 802a77a:	8aba      	ldrh	r2, [r7, #20]
 802a77c:	89fb      	ldrh	r3, [r7, #14]
 802a77e:	4413      	add	r3, r2
 802a780:	b29a      	uxth	r2, r3
 802a782:	8bfb      	ldrh	r3, [r7, #30]
 802a784:	4413      	add	r3, r2
 802a786:	b29b      	uxth	r3, r3
 802a788:	83fb      	strh	r3, [r7, #30]
 802a78a:	e000      	b.n	802a78e <lv_cont_layout_grid+0xda>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 802a78c:	bf00      	nop
    _LV_LL_READ_BACK(cont->child_ll, child) {
 802a78e:	687b      	ldr	r3, [r7, #4]
 802a790:	3304      	adds	r3, #4
 802a792:	69b9      	ldr	r1, [r7, #24]
 802a794:	4618      	mov	r0, r3
 802a796:	f7f6 f8a1 	bl	80208dc <_lv_ll_get_prev>
 802a79a:	61b8      	str	r0, [r7, #24]
 802a79c:	69bb      	ldr	r3, [r7, #24]
 802a79e:	2b00      	cmp	r3, #0
 802a7a0:	d1be      	bne.n	802a720 <lv_cont_layout_grid+0x6c>
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 802a7a2:	2101      	movs	r1, #1
 802a7a4:	6878      	ldr	r0, [r7, #4]
 802a7a6:	f7df ff03 	bl	800a5b0 <lv_obj_clear_protect>
}
 802a7aa:	bf00      	nop
 802a7ac:	3720      	adds	r7, #32
 802a7ae:	46bd      	mov	sp, r7
 802a7b0:	bd80      	pop	{r7, pc}

0802a7b2 <lv_cont_refr_autofit>:
/**
 * Handle auto fit. Set the size of the object to involve all children.
 * @param cont pointer to an object which size will be modified
 */
static void lv_cont_refr_autofit(lv_obj_t * cont)
{
 802a7b2:	b580      	push	{r7, lr}
 802a7b4:	b090      	sub	sp, #64	; 0x40
 802a7b6:	af00      	add	r7, sp, #0
 802a7b8:	6078      	str	r0, [r7, #4]
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
 802a7ba:	2101      	movs	r1, #1
 802a7bc:	6878      	ldr	r0, [r7, #4]
 802a7be:	f7e1 f8ab 	bl	800b918 <lv_obj_is_protected>
 802a7c2:	4603      	mov	r3, r0
 802a7c4:	2b00      	cmp	r3, #0
 802a7c6:	f040 824b 	bne.w	802ac60 <lv_cont_refr_autofit+0x4ae>
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 802a7ca:	6878      	ldr	r0, [r7, #4]
 802a7cc:	f7e1 f940 	bl	800ba50 <lv_obj_get_ext_attr>
 802a7d0:	63b8      	str	r0, [r7, #56]	; 0x38

    if(ext->fit_left == LV_FIT_NONE && ext->fit_right == LV_FIT_NONE && ext->fit_top == LV_FIT_NONE &&
 802a7d2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802a7d4:	781b      	ldrb	r3, [r3, #0]
 802a7d6:	f003 0330 	and.w	r3, r3, #48	; 0x30
 802a7da:	b2db      	uxtb	r3, r3
 802a7dc:	2b00      	cmp	r3, #0
 802a7de:	d115      	bne.n	802a80c <lv_cont_refr_autofit+0x5a>
 802a7e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802a7e2:	781b      	ldrb	r3, [r3, #0]
 802a7e4:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 802a7e8:	b2db      	uxtb	r3, r3
 802a7ea:	2b00      	cmp	r3, #0
 802a7ec:	d10e      	bne.n	802a80c <lv_cont_refr_autofit+0x5a>
 802a7ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802a7f0:	785b      	ldrb	r3, [r3, #1]
 802a7f2:	f003 0303 	and.w	r3, r3, #3
 802a7f6:	b2db      	uxtb	r3, r3
 802a7f8:	2b00      	cmp	r3, #0
 802a7fa:	d107      	bne.n	802a80c <lv_cont_refr_autofit+0x5a>
       ext->fit_bottom == LV_FIT_NONE) {
 802a7fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802a7fe:	785b      	ldrb	r3, [r3, #1]
 802a800:	f003 030c 	and.w	r3, r3, #12
 802a804:	b2db      	uxtb	r3, r3
    if(ext->fit_left == LV_FIT_NONE && ext->fit_right == LV_FIT_NONE && ext->fit_top == LV_FIT_NONE &&
 802a806:	2b00      	cmp	r3, #0
 802a808:	f000 822c 	beq.w	802ac64 <lv_cont_refr_autofit+0x4b2>

    lv_area_t tight_area;
    lv_area_t ori;
    lv_obj_t * child_i;

    lv_obj_t * par               = lv_obj_get_parent(cont);
 802a80c:	6878      	ldr	r0, [r7, #4]
 802a80e:	f7e0 fa83 	bl	800ad18 <lv_obj_get_parent>
 802a812:	6378      	str	r0, [r7, #52]	; 0x34
    lv_area_t parent_area;
    lv_area_copy(&parent_area, &par->coords);
 802a814:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802a816:	f103 0210 	add.w	r2, r3, #16
 802a81a:	f107 0310 	add.w	r3, r7, #16
 802a81e:	4611      	mov	r1, r2
 802a820:	4618      	mov	r0, r3
 802a822:	f7ff f82b 	bl	802987c <lv_area_copy>
    parent_area.x1 += lv_obj_get_style_pad_left(par, LV_OBJ_PART_MAIN);
 802a826:	2100      	movs	r1, #0
 802a828:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802a82a:	f7ff f885 	bl	8029938 <lv_obj_get_style_pad_left>
 802a82e:	4603      	mov	r3, r0
 802a830:	4619      	mov	r1, r3
 802a832:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 802a836:	b29a      	uxth	r2, r3
 802a838:	b28b      	uxth	r3, r1
 802a83a:	4413      	add	r3, r2
 802a83c:	b29b      	uxth	r3, r3
 802a83e:	b21b      	sxth	r3, r3
 802a840:	823b      	strh	r3, [r7, #16]
    parent_area.x2 -= lv_obj_get_style_pad_right(par, LV_OBJ_PART_MAIN);
 802a842:	2100      	movs	r1, #0
 802a844:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802a846:	f7ff f888 	bl	802995a <lv_obj_get_style_pad_right>
 802a84a:	4603      	mov	r3, r0
 802a84c:	4619      	mov	r1, r3
 802a84e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 802a852:	b29a      	uxth	r2, r3
 802a854:	b28b      	uxth	r3, r1
 802a856:	1ad3      	subs	r3, r2, r3
 802a858:	b29b      	uxth	r3, r3
 802a85a:	b21b      	sxth	r3, r3
 802a85c:	82bb      	strh	r3, [r7, #20]
    parent_area.y1 += lv_obj_get_style_pad_top(par, LV_OBJ_PART_MAIN);
 802a85e:	2100      	movs	r1, #0
 802a860:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802a862:	f7ff f847 	bl	80298f4 <lv_obj_get_style_pad_top>
 802a866:	4603      	mov	r3, r0
 802a868:	4619      	mov	r1, r3
 802a86a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 802a86e:	b29a      	uxth	r2, r3
 802a870:	b28b      	uxth	r3, r1
 802a872:	4413      	add	r3, r2
 802a874:	b29b      	uxth	r3, r3
 802a876:	b21b      	sxth	r3, r3
 802a878:	827b      	strh	r3, [r7, #18]
    parent_area.y2 -= lv_obj_get_style_pad_bottom(par, LV_OBJ_PART_MAIN);
 802a87a:	2100      	movs	r1, #0
 802a87c:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802a87e:	f7ff f84a 	bl	8029916 <lv_obj_get_style_pad_bottom>
 802a882:	4603      	mov	r3, r0
 802a884:	4619      	mov	r1, r3
 802a886:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 802a88a:	b29a      	uxth	r2, r3
 802a88c:	b28b      	uxth	r3, r1
 802a88e:	1ad3      	subs	r3, r2, r3
 802a890:	b29b      	uxth	r3, r3
 802a892:	b21b      	sxth	r3, r3
 802a894:	82fb      	strh	r3, [r7, #22]

    /*Search the side coordinates of the children*/
    lv_obj_get_coords(cont, &ori);
 802a896:	f107 0318 	add.w	r3, r7, #24
 802a89a:	4619      	mov	r1, r3
 802a89c:	6878      	ldr	r0, [r7, #4]
 802a89e:	f7e0 fa8d 	bl	800adbc <lv_obj_get_coords>
    lv_obj_get_coords(cont, &tight_area);
 802a8a2:	f107 0320 	add.w	r3, r7, #32
 802a8a6:	4619      	mov	r1, r3
 802a8a8:	6878      	ldr	r0, [r7, #4]
 802a8aa:	f7e0 fa87 	bl	800adbc <lv_obj_get_coords>

    bool has_children = _lv_ll_is_empty(&cont->child_ll) ? false : true;
 802a8ae:	687b      	ldr	r3, [r7, #4]
 802a8b0:	3304      	adds	r3, #4
 802a8b2:	4618      	mov	r0, r3
 802a8b4:	f7f6 f871 	bl	802099a <_lv_ll_is_empty>
 802a8b8:	4603      	mov	r3, r0
 802a8ba:	f083 0301 	eor.w	r3, r3, #1
 802a8be:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

    if(has_children) {
 802a8c2:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 802a8c6:	2b00      	cmp	r3, #0
 802a8c8:	f000 80c9 	beq.w	802aa5e <lv_cont_refr_autofit+0x2ac>
        tight_area.x1 = LV_COORD_MAX;
 802a8cc:	f647 4318 	movw	r3, #31768	; 0x7c18
 802a8d0:	843b      	strh	r3, [r7, #32]
        tight_area.y1 = LV_COORD_MAX;
 802a8d2:	f647 4318 	movw	r3, #31768	; 0x7c18
 802a8d6:	847b      	strh	r3, [r7, #34]	; 0x22
        tight_area.x2 = LV_COORD_MIN;
 802a8d8:	f248 33e8 	movw	r3, #33768	; 0x83e8
 802a8dc:	84bb      	strh	r3, [r7, #36]	; 0x24
        tight_area.y2 = LV_COORD_MIN;
 802a8de:	f248 33e8 	movw	r3, #33768	; 0x83e8
 802a8e2:	84fb      	strh	r3, [r7, #38]	; 0x26

        _LV_LL_READ(cont->child_ll, child_i) {
 802a8e4:	687b      	ldr	r3, [r7, #4]
 802a8e6:	3304      	adds	r3, #4
 802a8e8:	4618      	mov	r0, r3
 802a8ea:	f7f5 ffb7 	bl	802085c <_lv_ll_get_head>
 802a8ee:	63f8      	str	r0, [r7, #60]	; 0x3c
 802a8f0:	e07a      	b.n	802a9e8 <lv_cont_refr_autofit+0x236>
            if(lv_obj_get_hidden(child_i) != false) continue;
 802a8f2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 802a8f4:	f7e0 ffb4 	bl	800b860 <lv_obj_get_hidden>
 802a8f8:	4603      	mov	r3, r0
 802a8fa:	2b00      	cmp	r3, #0
 802a8fc:	d16c      	bne.n	802a9d8 <lv_cont_refr_autofit+0x226>

            if(ext->fit_left != LV_FIT_PARENT) {
 802a8fe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802a900:	781b      	ldrb	r3, [r3, #0]
 802a902:	f003 0330 	and.w	r3, r3, #48	; 0x30
 802a906:	b2db      	uxtb	r3, r3
 802a908:	2b20      	cmp	r3, #32
 802a90a:	d013      	beq.n	802a934 <lv_cont_refr_autofit+0x182>
                lv_style_int_t mleft = lv_obj_get_style_margin_left(child_i, LV_OBJ_PART_MAIN);
 802a90c:	2100      	movs	r1, #0
 802a90e:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 802a910:	f7ff f867 	bl	80299e2 <lv_obj_get_style_margin_left>
 802a914:	4603      	mov	r3, r0
 802a916:	863b      	strh	r3, [r7, #48]	; 0x30
                tight_area.x1 = LV_MATH_MIN(tight_area.x1, child_i->coords.x1 - mleft);
 802a918:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a91a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802a91e:	461a      	mov	r2, r3
 802a920:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 802a924:	1ad3      	subs	r3, r2, r3
 802a926:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 802a92a:	4293      	cmp	r3, r2
 802a92c:	bfa8      	it	ge
 802a92e:	4613      	movge	r3, r2
 802a930:	b21b      	sxth	r3, r3
 802a932:	843b      	strh	r3, [r7, #32]
            }

            if(ext->fit_right != LV_FIT_PARENT) {
 802a934:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802a936:	781b      	ldrb	r3, [r3, #0]
 802a938:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 802a93c:	b2db      	uxtb	r3, r3
 802a93e:	2b80      	cmp	r3, #128	; 0x80
 802a940:	d013      	beq.n	802a96a <lv_cont_refr_autofit+0x1b8>
                lv_style_int_t mright = lv_obj_get_style_margin_right(child_i, LV_OBJ_PART_MAIN);
 802a942:	2100      	movs	r1, #0
 802a944:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 802a946:	f7ff f85d 	bl	8029a04 <lv_obj_get_style_margin_right>
 802a94a:	4603      	mov	r3, r0
 802a94c:	85fb      	strh	r3, [r7, #46]	; 0x2e
                tight_area.x2 = LV_MATH_MAX(tight_area.x2, child_i->coords.x2 + mright);
 802a94e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a950:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 802a954:	461a      	mov	r2, r3
 802a956:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 802a95a:	4413      	add	r3, r2
 802a95c:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 802a960:	4293      	cmp	r3, r2
 802a962:	bfb8      	it	lt
 802a964:	4613      	movlt	r3, r2
 802a966:	b21b      	sxth	r3, r3
 802a968:	84bb      	strh	r3, [r7, #36]	; 0x24
            }

            if(ext->fit_top != LV_FIT_PARENT) {
 802a96a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802a96c:	785b      	ldrb	r3, [r3, #1]
 802a96e:	f003 0303 	and.w	r3, r3, #3
 802a972:	b2db      	uxtb	r3, r3
 802a974:	2b02      	cmp	r3, #2
 802a976:	d013      	beq.n	802a9a0 <lv_cont_refr_autofit+0x1ee>
                lv_style_int_t mtop = lv_obj_get_style_margin_top(child_i, LV_OBJ_PART_MAIN);
 802a978:	2100      	movs	r1, #0
 802a97a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 802a97c:	f7ff f80f 	bl	802999e <lv_obj_get_style_margin_top>
 802a980:	4603      	mov	r3, r0
 802a982:	85bb      	strh	r3, [r7, #44]	; 0x2c
                tight_area.y1 = LV_MATH_MIN(tight_area.y1, child_i->coords.y1 - mtop);
 802a984:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a986:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802a98a:	461a      	mov	r2, r3
 802a98c:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 802a990:	1ad3      	subs	r3, r2, r3
 802a992:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 802a996:	4293      	cmp	r3, r2
 802a998:	bfa8      	it	ge
 802a99a:	4613      	movge	r3, r2
 802a99c:	b21b      	sxth	r3, r3
 802a99e:	847b      	strh	r3, [r7, #34]	; 0x22
            }

            if(ext->fit_bottom != LV_FIT_PARENT) {
 802a9a0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802a9a2:	785b      	ldrb	r3, [r3, #1]
 802a9a4:	f003 030c 	and.w	r3, r3, #12
 802a9a8:	b2db      	uxtb	r3, r3
 802a9aa:	2b08      	cmp	r3, #8
 802a9ac:	d015      	beq.n	802a9da <lv_cont_refr_autofit+0x228>
                lv_style_int_t mbottom = lv_obj_get_style_margin_bottom(child_i, LV_OBJ_PART_MAIN);
 802a9ae:	2100      	movs	r1, #0
 802a9b0:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 802a9b2:	f7ff f805 	bl	80299c0 <lv_obj_get_style_margin_bottom>
 802a9b6:	4603      	mov	r3, r0
 802a9b8:	857b      	strh	r3, [r7, #42]	; 0x2a
                tight_area.y2 = LV_MATH_MAX(tight_area.y2, child_i->coords.y2 + mbottom);
 802a9ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a9bc:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 802a9c0:	461a      	mov	r2, r3
 802a9c2:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 802a9c6:	4413      	add	r3, r2
 802a9c8:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 802a9cc:	4293      	cmp	r3, r2
 802a9ce:	bfb8      	it	lt
 802a9d0:	4613      	movlt	r3, r2
 802a9d2:	b21b      	sxth	r3, r3
 802a9d4:	84fb      	strh	r3, [r7, #38]	; 0x26
 802a9d6:	e000      	b.n	802a9da <lv_cont_refr_autofit+0x228>
            if(lv_obj_get_hidden(child_i) != false) continue;
 802a9d8:	bf00      	nop
        _LV_LL_READ(cont->child_ll, child_i) {
 802a9da:	687b      	ldr	r3, [r7, #4]
 802a9dc:	3304      	adds	r3, #4
 802a9de:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 802a9e0:	4618      	mov	r0, r3
 802a9e2:	f7f5 ff61 	bl	80208a8 <_lv_ll_get_next>
 802a9e6:	63f8      	str	r0, [r7, #60]	; 0x3c
 802a9e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802a9ea:	2b00      	cmp	r3, #0
 802a9ec:	d181      	bne.n	802a8f2 <lv_cont_refr_autofit+0x140>
            }
        }

        tight_area.x1 -= lv_obj_get_style_pad_left(cont, LV_CONT_PART_MAIN);
 802a9ee:	2100      	movs	r1, #0
 802a9f0:	6878      	ldr	r0, [r7, #4]
 802a9f2:	f7fe ffa1 	bl	8029938 <lv_obj_get_style_pad_left>
 802a9f6:	4603      	mov	r3, r0
 802a9f8:	4619      	mov	r1, r3
 802a9fa:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 802a9fe:	b29a      	uxth	r2, r3
 802aa00:	b28b      	uxth	r3, r1
 802aa02:	1ad3      	subs	r3, r2, r3
 802aa04:	b29b      	uxth	r3, r3
 802aa06:	b21b      	sxth	r3, r3
 802aa08:	843b      	strh	r3, [r7, #32]
        tight_area.x2 += lv_obj_get_style_pad_right(cont, LV_CONT_PART_MAIN);
 802aa0a:	2100      	movs	r1, #0
 802aa0c:	6878      	ldr	r0, [r7, #4]
 802aa0e:	f7fe ffa4 	bl	802995a <lv_obj_get_style_pad_right>
 802aa12:	4603      	mov	r3, r0
 802aa14:	4619      	mov	r1, r3
 802aa16:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 802aa1a:	b29a      	uxth	r2, r3
 802aa1c:	b28b      	uxth	r3, r1
 802aa1e:	4413      	add	r3, r2
 802aa20:	b29b      	uxth	r3, r3
 802aa22:	b21b      	sxth	r3, r3
 802aa24:	84bb      	strh	r3, [r7, #36]	; 0x24
        tight_area.y1 -= lv_obj_get_style_pad_top(cont, LV_CONT_PART_MAIN);
 802aa26:	2100      	movs	r1, #0
 802aa28:	6878      	ldr	r0, [r7, #4]
 802aa2a:	f7fe ff63 	bl	80298f4 <lv_obj_get_style_pad_top>
 802aa2e:	4603      	mov	r3, r0
 802aa30:	4619      	mov	r1, r3
 802aa32:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 802aa36:	b29a      	uxth	r2, r3
 802aa38:	b28b      	uxth	r3, r1
 802aa3a:	1ad3      	subs	r3, r2, r3
 802aa3c:	b29b      	uxth	r3, r3
 802aa3e:	b21b      	sxth	r3, r3
 802aa40:	847b      	strh	r3, [r7, #34]	; 0x22
        tight_area.y2 += lv_obj_get_style_pad_bottom(cont, LV_CONT_PART_MAIN);
 802aa42:	2100      	movs	r1, #0
 802aa44:	6878      	ldr	r0, [r7, #4]
 802aa46:	f7fe ff66 	bl	8029916 <lv_obj_get_style_pad_bottom>
 802aa4a:	4603      	mov	r3, r0
 802aa4c:	4619      	mov	r1, r3
 802aa4e:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 802aa52:	b29a      	uxth	r2, r3
 802aa54:	b28b      	uxth	r3, r1
 802aa56:	4413      	add	r3, r2
 802aa58:	b29b      	uxth	r3, r3
 802aa5a:	b21b      	sxth	r3, r3
 802aa5c:	84fb      	strh	r3, [r7, #38]	; 0x26
    }

    lv_area_t new_area;
    lv_area_copy(&new_area, &ori);
 802aa5e:	f107 0218 	add.w	r2, r7, #24
 802aa62:	f107 0308 	add.w	r3, r7, #8
 802aa66:	4611      	mov	r1, r2
 802aa68:	4618      	mov	r0, r3
 802aa6a:	f7fe ff07 	bl	802987c <lv_area_copy>

    switch(ext->fit_left) {
 802aa6e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802aa70:	781b      	ldrb	r3, [r3, #0]
 802aa72:	f3c3 1301 	ubfx	r3, r3, #4, #2
 802aa76:	b2db      	uxtb	r3, r3
 802aa78:	2b03      	cmp	r3, #3
 802aa7a:	d00e      	beq.n	802aa9a <lv_cont_refr_autofit+0x2e8>
 802aa7c:	2b03      	cmp	r3, #3
 802aa7e:	dc1d      	bgt.n	802aabc <lv_cont_refr_autofit+0x30a>
 802aa80:	2b01      	cmp	r3, #1
 802aa82:	d002      	beq.n	802aa8a <lv_cont_refr_autofit+0x2d8>
 802aa84:	2b02      	cmp	r3, #2
 802aa86:	d004      	beq.n	802aa92 <lv_cont_refr_autofit+0x2e0>
            break;
        case LV_FIT_MAX:
            new_area.x1 = has_children ? LV_MATH_MIN(tight_area.x1, parent_area.x1) : parent_area.x1;
            break;
        default:
            break;
 802aa88:	e018      	b.n	802aabc <lv_cont_refr_autofit+0x30a>
            new_area.x1 = tight_area.x1;
 802aa8a:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 802aa8e:	813b      	strh	r3, [r7, #8]
            break;
 802aa90:	e015      	b.n	802aabe <lv_cont_refr_autofit+0x30c>
            new_area.x1 = parent_area.x1;
 802aa92:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 802aa96:	813b      	strh	r3, [r7, #8]
            break;
 802aa98:	e011      	b.n	802aabe <lv_cont_refr_autofit+0x30c>
            new_area.x1 = has_children ? LV_MATH_MIN(tight_area.x1, parent_area.x1) : parent_area.x1;
 802aa9a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 802aa9e:	2b00      	cmp	r3, #0
 802aaa0:	d008      	beq.n	802aab4 <lv_cont_refr_autofit+0x302>
 802aaa2:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 802aaa6:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 802aaaa:	4293      	cmp	r3, r2
 802aaac:	bfa8      	it	ge
 802aaae:	4613      	movge	r3, r2
 802aab0:	b21b      	sxth	r3, r3
 802aab2:	e001      	b.n	802aab8 <lv_cont_refr_autofit+0x306>
 802aab4:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 802aab8:	813b      	strh	r3, [r7, #8]
            break;
 802aaba:	e000      	b.n	802aabe <lv_cont_refr_autofit+0x30c>
            break;
 802aabc:	bf00      	nop
    }

    switch(ext->fit_right) {
 802aabe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802aac0:	781b      	ldrb	r3, [r3, #0]
 802aac2:	f3c3 1381 	ubfx	r3, r3, #6, #2
 802aac6:	b2db      	uxtb	r3, r3
 802aac8:	2b03      	cmp	r3, #3
 802aaca:	d00e      	beq.n	802aaea <lv_cont_refr_autofit+0x338>
 802aacc:	2b03      	cmp	r3, #3
 802aace:	dc1d      	bgt.n	802ab0c <lv_cont_refr_autofit+0x35a>
 802aad0:	2b01      	cmp	r3, #1
 802aad2:	d002      	beq.n	802aada <lv_cont_refr_autofit+0x328>
 802aad4:	2b02      	cmp	r3, #2
 802aad6:	d004      	beq.n	802aae2 <lv_cont_refr_autofit+0x330>
            break;
        case LV_FIT_MAX:
            new_area.x2 = has_children ? LV_MATH_MAX(tight_area.x2, parent_area.x2) : parent_area.x2;
            break;
        default:
            break;
 802aad8:	e018      	b.n	802ab0c <lv_cont_refr_autofit+0x35a>
            new_area.x2 = tight_area.x2;
 802aada:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 802aade:	81bb      	strh	r3, [r7, #12]
            break;
 802aae0:	e015      	b.n	802ab0e <lv_cont_refr_autofit+0x35c>
            new_area.x2 = parent_area.x2;
 802aae2:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 802aae6:	81bb      	strh	r3, [r7, #12]
            break;
 802aae8:	e011      	b.n	802ab0e <lv_cont_refr_autofit+0x35c>
            new_area.x2 = has_children ? LV_MATH_MAX(tight_area.x2, parent_area.x2) : parent_area.x2;
 802aaea:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 802aaee:	2b00      	cmp	r3, #0
 802aaf0:	d008      	beq.n	802ab04 <lv_cont_refr_autofit+0x352>
 802aaf2:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 802aaf6:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 802aafa:	4293      	cmp	r3, r2
 802aafc:	bfb8      	it	lt
 802aafe:	4613      	movlt	r3, r2
 802ab00:	b21b      	sxth	r3, r3
 802ab02:	e001      	b.n	802ab08 <lv_cont_refr_autofit+0x356>
 802ab04:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 802ab08:	81bb      	strh	r3, [r7, #12]
            break;
 802ab0a:	e000      	b.n	802ab0e <lv_cont_refr_autofit+0x35c>
            break;
 802ab0c:	bf00      	nop
    }

    switch(ext->fit_top) {
 802ab0e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802ab10:	785b      	ldrb	r3, [r3, #1]
 802ab12:	f3c3 0301 	ubfx	r3, r3, #0, #2
 802ab16:	b2db      	uxtb	r3, r3
 802ab18:	2b03      	cmp	r3, #3
 802ab1a:	d00e      	beq.n	802ab3a <lv_cont_refr_autofit+0x388>
 802ab1c:	2b03      	cmp	r3, #3
 802ab1e:	dc1d      	bgt.n	802ab5c <lv_cont_refr_autofit+0x3aa>
 802ab20:	2b01      	cmp	r3, #1
 802ab22:	d002      	beq.n	802ab2a <lv_cont_refr_autofit+0x378>
 802ab24:	2b02      	cmp	r3, #2
 802ab26:	d004      	beq.n	802ab32 <lv_cont_refr_autofit+0x380>
            break;
        case LV_FIT_MAX:
            new_area.y1 = has_children ? LV_MATH_MIN(tight_area.y1, parent_area.y1) : parent_area.y1;
            break;
        default:
            break;
 802ab28:	e018      	b.n	802ab5c <lv_cont_refr_autofit+0x3aa>
            new_area.y1 = tight_area.y1;
 802ab2a:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 802ab2e:	817b      	strh	r3, [r7, #10]
            break;
 802ab30:	e015      	b.n	802ab5e <lv_cont_refr_autofit+0x3ac>
            new_area.y1 = parent_area.y1;
 802ab32:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 802ab36:	817b      	strh	r3, [r7, #10]
            break;
 802ab38:	e011      	b.n	802ab5e <lv_cont_refr_autofit+0x3ac>
            new_area.y1 = has_children ? LV_MATH_MIN(tight_area.y1, parent_area.y1) : parent_area.y1;
 802ab3a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 802ab3e:	2b00      	cmp	r3, #0
 802ab40:	d008      	beq.n	802ab54 <lv_cont_refr_autofit+0x3a2>
 802ab42:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 802ab46:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 802ab4a:	4293      	cmp	r3, r2
 802ab4c:	bfa8      	it	ge
 802ab4e:	4613      	movge	r3, r2
 802ab50:	b21b      	sxth	r3, r3
 802ab52:	e001      	b.n	802ab58 <lv_cont_refr_autofit+0x3a6>
 802ab54:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 802ab58:	817b      	strh	r3, [r7, #10]
            break;
 802ab5a:	e000      	b.n	802ab5e <lv_cont_refr_autofit+0x3ac>
            break;
 802ab5c:	bf00      	nop
    }

    switch(ext->fit_bottom) {
 802ab5e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802ab60:	785b      	ldrb	r3, [r3, #1]
 802ab62:	f3c3 0381 	ubfx	r3, r3, #2, #2
 802ab66:	b2db      	uxtb	r3, r3
 802ab68:	2b03      	cmp	r3, #3
 802ab6a:	d00e      	beq.n	802ab8a <lv_cont_refr_autofit+0x3d8>
 802ab6c:	2b03      	cmp	r3, #3
 802ab6e:	dc1d      	bgt.n	802abac <lv_cont_refr_autofit+0x3fa>
 802ab70:	2b01      	cmp	r3, #1
 802ab72:	d002      	beq.n	802ab7a <lv_cont_refr_autofit+0x3c8>
 802ab74:	2b02      	cmp	r3, #2
 802ab76:	d004      	beq.n	802ab82 <lv_cont_refr_autofit+0x3d0>
            break;
        case LV_FIT_MAX:
            new_area.y2 = has_children ? LV_MATH_MAX(tight_area.y2, parent_area.y2) : parent_area.y2;
            break;
        default:
            break;
 802ab78:	e018      	b.n	802abac <lv_cont_refr_autofit+0x3fa>
            new_area.y2 = tight_area.y2;
 802ab7a:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 802ab7e:	81fb      	strh	r3, [r7, #14]
            break;
 802ab80:	e015      	b.n	802abae <lv_cont_refr_autofit+0x3fc>
            new_area.y2 = parent_area.y2;
 802ab82:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 802ab86:	81fb      	strh	r3, [r7, #14]
            break;
 802ab88:	e011      	b.n	802abae <lv_cont_refr_autofit+0x3fc>
            new_area.y2 = has_children ? LV_MATH_MAX(tight_area.y2, parent_area.y2) : parent_area.y2;
 802ab8a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 802ab8e:	2b00      	cmp	r3, #0
 802ab90:	d008      	beq.n	802aba4 <lv_cont_refr_autofit+0x3f2>
 802ab92:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 802ab96:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 802ab9a:	4293      	cmp	r3, r2
 802ab9c:	bfb8      	it	lt
 802ab9e:	4613      	movlt	r3, r2
 802aba0:	b21b      	sxth	r3, r3
 802aba2:	e001      	b.n	802aba8 <lv_cont_refr_autofit+0x3f6>
 802aba4:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 802aba8:	81fb      	strh	r3, [r7, #14]
            break;
 802abaa:	e000      	b.n	802abae <lv_cont_refr_autofit+0x3fc>
            break;
 802abac:	bf00      	nop
    }

    /*Do nothing if the coordinates are not changed*/
    if(cont->coords.x1 != new_area.x1 || cont->coords.y1 != new_area.y1 || cont->coords.x2 != new_area.x2 ||
 802abae:	687b      	ldr	r3, [r7, #4]
 802abb0:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 802abb4:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 802abb8:	429a      	cmp	r2, r3
 802abba:	d114      	bne.n	802abe6 <lv_cont_refr_autofit+0x434>
 802abbc:	687b      	ldr	r3, [r7, #4]
 802abbe:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 802abc2:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 802abc6:	429a      	cmp	r2, r3
 802abc8:	d10d      	bne.n	802abe6 <lv_cont_refr_autofit+0x434>
 802abca:	687b      	ldr	r3, [r7, #4]
 802abcc:	f9b3 2014 	ldrsh.w	r2, [r3, #20]
 802abd0:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 802abd4:	429a      	cmp	r2, r3
 802abd6:	d106      	bne.n	802abe6 <lv_cont_refr_autofit+0x434>
       cont->coords.y2 != new_area.y2) {
 802abd8:	687b      	ldr	r3, [r7, #4]
 802abda:	f9b3 2016 	ldrsh.w	r2, [r3, #22]
 802abde:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    if(cont->coords.x1 != new_area.x1 || cont->coords.y1 != new_area.y1 || cont->coords.x2 != new_area.x2 ||
 802abe2:	429a      	cmp	r2, r3
 802abe4:	d03f      	beq.n	802ac66 <lv_cont_refr_autofit+0x4b4>

        lv_obj_invalidate(cont);
 802abe6:	6878      	ldr	r0, [r7, #4]
 802abe8:	f7de ff0a 	bl	8009a00 <lv_obj_invalidate>
        lv_area_copy(&cont->coords, &new_area);
 802abec:	687b      	ldr	r3, [r7, #4]
 802abee:	3310      	adds	r3, #16
 802abf0:	f107 0208 	add.w	r2, r7, #8
 802abf4:	4611      	mov	r1, r2
 802abf6:	4618      	mov	r0, r3
 802abf8:	f7fe fe40 	bl	802987c <lv_area_copy>
        lv_obj_invalidate(cont);
 802abfc:	6878      	ldr	r0, [r7, #4]
 802abfe:	f7de feff 	bl	8009a00 <lv_obj_invalidate>

        /*Notify the object about its new coordinates*/
        cont->signal_cb(cont, LV_SIGNAL_COORD_CHG, &ori);
 802ac02:	687b      	ldr	r3, [r7, #4]
 802ac04:	69db      	ldr	r3, [r3, #28]
 802ac06:	f107 0218 	add.w	r2, r7, #24
 802ac0a:	2102      	movs	r1, #2
 802ac0c:	6878      	ldr	r0, [r7, #4]
 802ac0e:	4798      	blx	r3

        /*Inform the parent about the new coordinates*/
        par->signal_cb(par, LV_SIGNAL_CHILD_CHG, cont);
 802ac10:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802ac12:	69db      	ldr	r3, [r3, #28]
 802ac14:	687a      	ldr	r2, [r7, #4]
 802ac16:	2101      	movs	r1, #1
 802ac18:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802ac1a:	4798      	blx	r3

        if(lv_obj_get_auto_realign(cont)) {
 802ac1c:	6878      	ldr	r0, [r7, #4]
 802ac1e:	f7e0 f9db 	bl	800afd8 <lv_obj_get_auto_realign>
 802ac22:	4603      	mov	r3, r0
 802ac24:	2b00      	cmp	r3, #0
 802ac26:	d002      	beq.n	802ac2e <lv_cont_refr_autofit+0x47c>
            lv_obj_realign(cont);
 802ac28:	6878      	ldr	r0, [r7, #4]
 802ac2a:	f7df fa9f 	bl	800a16c <lv_obj_realign>
        }

        /*Tell the children the parent's size has changed*/
        _LV_LL_READ(cont->child_ll, child_i) {
 802ac2e:	687b      	ldr	r3, [r7, #4]
 802ac30:	3304      	adds	r3, #4
 802ac32:	4618      	mov	r0, r3
 802ac34:	f7f5 fe12 	bl	802085c <_lv_ll_get_head>
 802ac38:	63f8      	str	r0, [r7, #60]	; 0x3c
 802ac3a:	e00d      	b.n	802ac58 <lv_cont_refr_autofit+0x4a6>
            child_i->signal_cb(child_i, LV_SIGNAL_PARENT_SIZE_CHG, &ori);
 802ac3c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802ac3e:	69db      	ldr	r3, [r3, #28]
 802ac40:	f107 0218 	add.w	r2, r7, #24
 802ac44:	2103      	movs	r1, #3
 802ac46:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 802ac48:	4798      	blx	r3
        _LV_LL_READ(cont->child_ll, child_i) {
 802ac4a:	687b      	ldr	r3, [r7, #4]
 802ac4c:	3304      	adds	r3, #4
 802ac4e:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 802ac50:	4618      	mov	r0, r3
 802ac52:	f7f5 fe29 	bl	80208a8 <_lv_ll_get_next>
 802ac56:	63f8      	str	r0, [r7, #60]	; 0x3c
 802ac58:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802ac5a:	2b00      	cmp	r3, #0
 802ac5c:	d1ee      	bne.n	802ac3c <lv_cont_refr_autofit+0x48a>
 802ac5e:	e002      	b.n	802ac66 <lv_cont_refr_autofit+0x4b4>
    if(lv_obj_is_protected(cont, LV_PROTECT_CHILD_CHG)) return;
 802ac60:	bf00      	nop
 802ac62:	e000      	b.n	802ac66 <lv_cont_refr_autofit+0x4b4>
        return;
 802ac64:	bf00      	nop
        }
    }
}
 802ac66:	3740      	adds	r7, #64	; 0x40
 802ac68:	46bd      	mov	sp, r7
 802ac6a:	bd80      	pop	{r7, pc}

0802ac6c <lv_area_get_width>:
{
 802ac6c:	b480      	push	{r7}
 802ac6e:	b083      	sub	sp, #12
 802ac70:	af00      	add	r7, sp, #0
 802ac72:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 802ac74:	687b      	ldr	r3, [r7, #4]
 802ac76:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 802ac7a:	b29a      	uxth	r2, r3
 802ac7c:	687b      	ldr	r3, [r7, #4]
 802ac7e:	f9b3 3000 	ldrsh.w	r3, [r3]
 802ac82:	b29b      	uxth	r3, r3
 802ac84:	1ad3      	subs	r3, r2, r3
 802ac86:	b29b      	uxth	r3, r3
 802ac88:	3301      	adds	r3, #1
 802ac8a:	b29b      	uxth	r3, r3
 802ac8c:	b21b      	sxth	r3, r3
}
 802ac8e:	4618      	mov	r0, r3
 802ac90:	370c      	adds	r7, #12
 802ac92:	46bd      	mov	sp, r7
 802ac94:	f85d 7b04 	ldr.w	r7, [sp], #4
 802ac98:	4770      	bx	lr

0802ac9a <lv_area_get_height>:
{
 802ac9a:	b480      	push	{r7}
 802ac9c:	b083      	sub	sp, #12
 802ac9e:	af00      	add	r7, sp, #0
 802aca0:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 802aca2:	687b      	ldr	r3, [r7, #4]
 802aca4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 802aca8:	b29a      	uxth	r2, r3
 802acaa:	687b      	ldr	r3, [r7, #4]
 802acac:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 802acb0:	b29b      	uxth	r3, r3
 802acb2:	1ad3      	subs	r3, r2, r3
 802acb4:	b29b      	uxth	r3, r3
 802acb6:	3301      	adds	r3, #1
 802acb8:	b29b      	uxth	r3, r3
 802acba:	b21b      	sxth	r3, r3
}
 802acbc:	4618      	mov	r0, r3
 802acbe:	370c      	adds	r7, #12
 802acc0:	46bd      	mov	sp, r7
 802acc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 802acc6:	4770      	bx	lr

0802acc8 <lv_obj_get_style_radius>:
_LV_OBJ_STYLE_SET_GET_DECLARE(RADIUS, radius, lv_style_int_t, _int, scalar)
 802acc8:	b580      	push	{r7, lr}
 802acca:	b082      	sub	sp, #8
 802accc:	af00      	add	r7, sp, #0
 802acce:	6078      	str	r0, [r7, #4]
 802acd0:	460b      	mov	r3, r1
 802acd2:	70fb      	strb	r3, [r7, #3]
 802acd4:	78fb      	ldrb	r3, [r7, #3]
 802acd6:	2201      	movs	r2, #1
 802acd8:	4619      	mov	r1, r3
 802acda:	6878      	ldr	r0, [r7, #4]
 802acdc:	f7e0 f9c8 	bl	800b070 <_lv_obj_get_style_int>
 802ace0:	4603      	mov	r3, r0
 802ace2:	4618      	mov	r0, r3
 802ace4:	3708      	adds	r7, #8
 802ace6:	46bd      	mov	sp, r7
 802ace8:	bd80      	pop	{r7, pc}

0802acea <lv_obj_get_style_clip_corner>:
_LV_OBJ_STYLE_SET_GET_DECLARE(CLIP_CORNER, clip_corner, bool, _int, scalar)
 802acea:	b580      	push	{r7, lr}
 802acec:	b082      	sub	sp, #8
 802acee:	af00      	add	r7, sp, #0
 802acf0:	6078      	str	r0, [r7, #4]
 802acf2:	460b      	mov	r3, r1
 802acf4:	70fb      	strb	r3, [r7, #3]
 802acf6:	78fb      	ldrb	r3, [r7, #3]
 802acf8:	2202      	movs	r2, #2
 802acfa:	4619      	mov	r1, r3
 802acfc:	6878      	ldr	r0, [r7, #4]
 802acfe:	f7e0 f9b7 	bl	800b070 <_lv_obj_get_style_int>
 802ad02:	4603      	mov	r3, r0
 802ad04:	2b00      	cmp	r3, #0
 802ad06:	bf14      	ite	ne
 802ad08:	2301      	movne	r3, #1
 802ad0a:	2300      	moveq	r3, #0
 802ad0c:	b2db      	uxtb	r3, r3
 802ad0e:	4618      	mov	r0, r3
 802ad10:	3708      	adds	r7, #8
 802ad12:	46bd      	mov	sp, r7
 802ad14:	bd80      	pop	{r7, pc}

0802ad16 <lv_obj_get_style_transform_angle>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ANGLE, transform_angle, lv_style_int_t, _int, scalar)
 802ad16:	b580      	push	{r7, lr}
 802ad18:	b082      	sub	sp, #8
 802ad1a:	af00      	add	r7, sp, #0
 802ad1c:	6078      	str	r0, [r7, #4]
 802ad1e:	460b      	mov	r3, r1
 802ad20:	70fb      	strb	r3, [r7, #3]
 802ad22:	78fb      	ldrb	r3, [r7, #3]
 802ad24:	2206      	movs	r2, #6
 802ad26:	4619      	mov	r1, r3
 802ad28:	6878      	ldr	r0, [r7, #4]
 802ad2a:	f7e0 f9a1 	bl	800b070 <_lv_obj_get_style_int>
 802ad2e:	4603      	mov	r3, r0
 802ad30:	4618      	mov	r0, r3
 802ad32:	3708      	adds	r7, #8
 802ad34:	46bd      	mov	sp, r7
 802ad36:	bd80      	pop	{r7, pc}

0802ad38 <lv_obj_get_style_transform_zoom>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_ZOOM, transform_zoom, lv_style_int_t, _int, scalar)
 802ad38:	b580      	push	{r7, lr}
 802ad3a:	b082      	sub	sp, #8
 802ad3c:	af00      	add	r7, sp, #0
 802ad3e:	6078      	str	r0, [r7, #4]
 802ad40:	460b      	mov	r3, r1
 802ad42:	70fb      	strb	r3, [r7, #3]
 802ad44:	78fb      	ldrb	r3, [r7, #3]
 802ad46:	2207      	movs	r2, #7
 802ad48:	4619      	mov	r1, r3
 802ad4a:	6878      	ldr	r0, [r7, #4]
 802ad4c:	f7e0 f990 	bl	800b070 <_lv_obj_get_style_int>
 802ad50:	4603      	mov	r3, r0
 802ad52:	4618      	mov	r0, r3
 802ad54:	3708      	adds	r7, #8
 802ad56:	46bd      	mov	sp, r7
 802ad58:	bd80      	pop	{r7, pc}

0802ad5a <lv_obj_get_style_pad_top>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
 802ad5a:	b580      	push	{r7, lr}
 802ad5c:	b082      	sub	sp, #8
 802ad5e:	af00      	add	r7, sp, #0
 802ad60:	6078      	str	r0, [r7, #4]
 802ad62:	460b      	mov	r3, r1
 802ad64:	70fb      	strb	r3, [r7, #3]
 802ad66:	78fb      	ldrb	r3, [r7, #3]
 802ad68:	2210      	movs	r2, #16
 802ad6a:	4619      	mov	r1, r3
 802ad6c:	6878      	ldr	r0, [r7, #4]
 802ad6e:	f7e0 f97f 	bl	800b070 <_lv_obj_get_style_int>
 802ad72:	4603      	mov	r3, r0
 802ad74:	4618      	mov	r0, r3
 802ad76:	3708      	adds	r7, #8
 802ad78:	46bd      	mov	sp, r7
 802ad7a:	bd80      	pop	{r7, pc}

0802ad7c <lv_obj_get_style_pad_bottom>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
 802ad7c:	b580      	push	{r7, lr}
 802ad7e:	b082      	sub	sp, #8
 802ad80:	af00      	add	r7, sp, #0
 802ad82:	6078      	str	r0, [r7, #4]
 802ad84:	460b      	mov	r3, r1
 802ad86:	70fb      	strb	r3, [r7, #3]
 802ad88:	78fb      	ldrb	r3, [r7, #3]
 802ad8a:	2211      	movs	r2, #17
 802ad8c:	4619      	mov	r1, r3
 802ad8e:	6878      	ldr	r0, [r7, #4]
 802ad90:	f7e0 f96e 	bl	800b070 <_lv_obj_get_style_int>
 802ad94:	4603      	mov	r3, r0
 802ad96:	4618      	mov	r0, r3
 802ad98:	3708      	adds	r7, #8
 802ad9a:	46bd      	mov	sp, r7
 802ad9c:	bd80      	pop	{r7, pc}

0802ad9e <lv_obj_get_style_pad_left>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
 802ad9e:	b580      	push	{r7, lr}
 802ada0:	b082      	sub	sp, #8
 802ada2:	af00      	add	r7, sp, #0
 802ada4:	6078      	str	r0, [r7, #4]
 802ada6:	460b      	mov	r3, r1
 802ada8:	70fb      	strb	r3, [r7, #3]
 802adaa:	78fb      	ldrb	r3, [r7, #3]
 802adac:	2212      	movs	r2, #18
 802adae:	4619      	mov	r1, r3
 802adb0:	6878      	ldr	r0, [r7, #4]
 802adb2:	f7e0 f95d 	bl	800b070 <_lv_obj_get_style_int>
 802adb6:	4603      	mov	r3, r0
 802adb8:	4618      	mov	r0, r3
 802adba:	3708      	adds	r7, #8
 802adbc:	46bd      	mov	sp, r7
 802adbe:	bd80      	pop	{r7, pc}

0802adc0 <lv_obj_get_style_pad_right>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
 802adc0:	b580      	push	{r7, lr}
 802adc2:	b082      	sub	sp, #8
 802adc4:	af00      	add	r7, sp, #0
 802adc6:	6078      	str	r0, [r7, #4]
 802adc8:	460b      	mov	r3, r1
 802adca:	70fb      	strb	r3, [r7, #3]
 802adcc:	78fb      	ldrb	r3, [r7, #3]
 802adce:	2213      	movs	r2, #19
 802add0:	4619      	mov	r1, r3
 802add2:	6878      	ldr	r0, [r7, #4]
 802add4:	f7e0 f94c 	bl	800b070 <_lv_obj_get_style_int>
 802add8:	4603      	mov	r3, r0
 802adda:	4618      	mov	r0, r3
 802addc:	3708      	adds	r7, #8
 802adde:	46bd      	mov	sp, r7
 802ade0:	bd80      	pop	{r7, pc}

0802ade2 <lv_obj_get_style_bg_blend_mode>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_BLEND_MODE, bg_blend_mode, lv_blend_mode_t, _int, scalar)
 802ade2:	b580      	push	{r7, lr}
 802ade4:	b082      	sub	sp, #8
 802ade6:	af00      	add	r7, sp, #0
 802ade8:	6078      	str	r0, [r7, #4]
 802adea:	460b      	mov	r3, r1
 802adec:	70fb      	strb	r3, [r7, #3]
 802adee:	78fb      	ldrb	r3, [r7, #3]
 802adf0:	2220      	movs	r2, #32
 802adf2:	4619      	mov	r1, r3
 802adf4:	6878      	ldr	r0, [r7, #4]
 802adf6:	f7e0 f93b 	bl	800b070 <_lv_obj_get_style_int>
 802adfa:	4603      	mov	r3, r0
 802adfc:	b2db      	uxtb	r3, r3
 802adfe:	4618      	mov	r0, r3
 802ae00:	3708      	adds	r7, #8
 802ae02:	46bd      	mov	sp, r7
 802ae04:	bd80      	pop	{r7, pc}

0802ae06 <lv_obj_get_style_border_post>:
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_GRAD_COLOR, bg_grad_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BG_OPA, bg_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_WIDTH, border_width, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_SIDE, border_side, lv_border_side_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_BLEND_MODE, border_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(BORDER_POST, border_post, bool, _int, scalar)
 802ae06:	b580      	push	{r7, lr}
 802ae08:	b082      	sub	sp, #8
 802ae0a:	af00      	add	r7, sp, #0
 802ae0c:	6078      	str	r0, [r7, #4]
 802ae0e:	460b      	mov	r3, r1
 802ae10:	70fb      	strb	r3, [r7, #3]
 802ae12:	78fb      	ldrb	r3, [r7, #3]
 802ae14:	2233      	movs	r2, #51	; 0x33
 802ae16:	4619      	mov	r1, r3
 802ae18:	6878      	ldr	r0, [r7, #4]
 802ae1a:	f7e0 f929 	bl	800b070 <_lv_obj_get_style_int>
 802ae1e:	4603      	mov	r3, r0
 802ae20:	2b00      	cmp	r3, #0
 802ae22:	bf14      	ite	ne
 802ae24:	2301      	movne	r3, #1
 802ae26:	2300      	moveq	r3, #0
 802ae28:	b2db      	uxtb	r3, r3
 802ae2a:	4618      	mov	r0, r3
 802ae2c:	3708      	adds	r7, #8
 802ae2e:	46bd      	mov	sp, r7
 802ae30:	bd80      	pop	{r7, pc}

0802ae32 <lv_obj_get_style_text_letter_space>:
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_ALIGN, value_align, lv_align_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_COLOR, value_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_OPA, value_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_FONT, value_font, const lv_font_t *, _ptr, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(VALUE_STR, value_str, const char *, _ptr, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
 802ae32:	b580      	push	{r7, lr}
 802ae34:	b082      	sub	sp, #8
 802ae36:	af00      	add	r7, sp, #0
 802ae38:	6078      	str	r0, [r7, #4]
 802ae3a:	460b      	mov	r3, r1
 802ae3c:	70fb      	strb	r3, [r7, #3]
 802ae3e:	78fb      	ldrb	r3, [r7, #3]
 802ae40:	f248 0280 	movw	r2, #32896	; 0x8080
 802ae44:	4619      	mov	r1, r3
 802ae46:	6878      	ldr	r0, [r7, #4]
 802ae48:	f7e0 f912 	bl	800b070 <_lv_obj_get_style_int>
 802ae4c:	4603      	mov	r3, r0
 802ae4e:	4618      	mov	r0, r3
 802ae50:	3708      	adds	r7, #8
 802ae52:	46bd      	mov	sp, r7
 802ae54:	bd80      	pop	{r7, pc}

0802ae56 <lv_obj_get_style_text_line_space>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
 802ae56:	b580      	push	{r7, lr}
 802ae58:	b082      	sub	sp, #8
 802ae5a:	af00      	add	r7, sp, #0
 802ae5c:	6078      	str	r0, [r7, #4]
 802ae5e:	460b      	mov	r3, r1
 802ae60:	70fb      	strb	r3, [r7, #3]
 802ae62:	78fb      	ldrb	r3, [r7, #3]
 802ae64:	f248 0281 	movw	r2, #32897	; 0x8081
 802ae68:	4619      	mov	r1, r3
 802ae6a:	6878      	ldr	r0, [r7, #4]
 802ae6c:	f7e0 f900 	bl	800b070 <_lv_obj_get_style_int>
 802ae70:	4603      	mov	r3, r0
 802ae72:	4618      	mov	r0, r3
 802ae74:	3708      	adds	r7, #8
 802ae76:	46bd      	mov	sp, r7
 802ae78:	bd80      	pop	{r7, pc}

0802ae7a <lv_obj_get_style_text_font>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_DECOR, text_decor, lv_text_decor_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_BLEND_MODE, text_blend_mode, lv_blend_mode_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_COLOR, text_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_SEL_COLOR, text_sel_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_OPA, text_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
 802ae7a:	b580      	push	{r7, lr}
 802ae7c:	b082      	sub	sp, #8
 802ae7e:	af00      	add	r7, sp, #0
 802ae80:	6078      	str	r0, [r7, #4]
 802ae82:	460b      	mov	r3, r1
 802ae84:	70fb      	strb	r3, [r7, #3]
 802ae86:	78fb      	ldrb	r3, [r7, #3]
 802ae88:	f248 028e 	movw	r2, #32910	; 0x808e
 802ae8c:	4619      	mov	r1, r3
 802ae8e:	6878      	ldr	r0, [r7, #4]
 802ae90:	f7e0 fc26 	bl	800b6e0 <_lv_obj_get_style_ptr>
 802ae94:	4603      	mov	r3, r0
 802ae96:	4618      	mov	r0, r3
 802ae98:	3708      	adds	r7, #8
 802ae9a:	46bd      	mov	sp, r7
 802ae9c:	bd80      	pop	{r7, pc}

0802ae9e <lv_obj_get_style_image_blend_mode>:
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_DASH_WIDTH, line_dash_width, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_DASH_GAP, line_dash_gap, lv_style_int_t, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_ROUNDED, line_rounded, bool, _int, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_COLOR, line_color, lv_color_t, _color, nonscalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(LINE_OPA, line_opa, lv_opa_t, _opa, scalar)
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_BLEND_MODE, image_blend_mode, lv_blend_mode_t, _int, scalar)
 802ae9e:	b580      	push	{r7, lr}
 802aea0:	b082      	sub	sp, #8
 802aea2:	af00      	add	r7, sp, #0
 802aea4:	6078      	str	r0, [r7, #4]
 802aea6:	460b      	mov	r3, r1
 802aea8:	70fb      	strb	r3, [r7, #3]
 802aeaa:	78fb      	ldrb	r3, [r7, #3]
 802aeac:	f248 02a0 	movw	r2, #32928	; 0x80a0
 802aeb0:	4619      	mov	r1, r3
 802aeb2:	6878      	ldr	r0, [r7, #4]
 802aeb4:	f7e0 f8dc 	bl	800b070 <_lv_obj_get_style_int>
 802aeb8:	4603      	mov	r3, r0
 802aeba:	b2db      	uxtb	r3, r3
 802aebc:	4618      	mov	r0, r3
 802aebe:	3708      	adds	r7, #8
 802aec0:	46bd      	mov	sp, r7
 802aec2:	bd80      	pop	{r7, pc}

0802aec4 <lv_obj_get_style_image_recolor>:
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_RECOLOR, image_recolor, lv_color_t, _color, nonscalar)
 802aec4:	b580      	push	{r7, lr}
 802aec6:	b082      	sub	sp, #8
 802aec8:	af00      	add	r7, sp, #0
 802aeca:	6078      	str	r0, [r7, #4]
 802aecc:	460b      	mov	r3, r1
 802aece:	70fb      	strb	r3, [r7, #3]
 802aed0:	78fb      	ldrb	r3, [r7, #3]
 802aed2:	f248 02a9 	movw	r2, #32937	; 0x80a9
 802aed6:	4619      	mov	r1, r3
 802aed8:	6878      	ldr	r0, [r7, #4]
 802aeda:	f7e0 fadd 	bl	800b498 <_lv_obj_get_style_color>
 802aede:	4603      	mov	r3, r0
 802aee0:	4618      	mov	r0, r3
 802aee2:	3708      	adds	r7, #8
 802aee4:	46bd      	mov	sp, r7
 802aee6:	bd80      	pop	{r7, pc}

0802aee8 <lv_obj_get_style_image_opa>:
_LV_OBJ_STYLE_SET_GET_DECLARE(IMAGE_OPA, image_opa, lv_opa_t, _opa, scalar)
 802aee8:	b580      	push	{r7, lr}
 802aeea:	b082      	sub	sp, #8
 802aeec:	af00      	add	r7, sp, #0
 802aeee:	6078      	str	r0, [r7, #4]
 802aef0:	460b      	mov	r3, r1
 802aef2:	70fb      	strb	r3, [r7, #3]
 802aef4:	78fb      	ldrb	r3, [r7, #3]
 802aef6:	f248 02ac 	movw	r2, #32940	; 0x80ac
 802aefa:	4619      	mov	r1, r3
 802aefc:	6878      	ldr	r0, [r7, #4]
 802aefe:	f7e0 fb2b 	bl	800b558 <_lv_obj_get_style_opa>
 802af02:	4603      	mov	r3, r0
 802af04:	4618      	mov	r0, r3
 802af06:	3708      	adds	r7, #8
 802af08:	46bd      	mov	sp, r7
 802af0a:	bd80      	pop	{r7, pc}

0802af0c <lv_img_create>:
 * @param par pointer to an object, it will be the parent of the new button
 * @param copy pointer to a image object, if not NULL then the new object will be copied from it
 * @return pointer to the created image
 */
lv_obj_t * lv_img_create(lv_obj_t * par, const lv_obj_t * copy)
{
 802af0c:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 802af10:	b086      	sub	sp, #24
 802af12:	af00      	add	r7, sp, #0
 802af14:	6078      	str	r0, [r7, #4]
 802af16:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("image create started");

    /*Create a basic object*/
    lv_obj_t * img = lv_obj_create(par, copy);
 802af18:	6839      	ldr	r1, [r7, #0]
 802af1a:	6878      	ldr	r0, [r7, #4]
 802af1c:	f7de fa08 	bl	8009330 <lv_obj_create>
 802af20:	6178      	str	r0, [r7, #20]
    LV_ASSERT_MEM(img);
 802af22:	6978      	ldr	r0, [r7, #20]
 802af24:	f7f5 f8e4 	bl	80200f0 <lv_debug_check_null>
 802af28:	4603      	mov	r3, r0
 802af2a:	f083 0301 	eor.w	r3, r3, #1
 802af2e:	b2db      	uxtb	r3, r3
 802af30:	2b00      	cmp	r3, #0
 802af32:	d009      	beq.n	802af48 <lv_img_create+0x3c>
 802af34:	697b      	ldr	r3, [r7, #20]
 802af36:	2200      	movs	r2, #0
 802af38:	4698      	mov	r8, r3
 802af3a:	4691      	mov	r9, r2
 802af3c:	4642      	mov	r2, r8
 802af3e:	464b      	mov	r3, r9
 802af40:	486a      	ldr	r0, [pc, #424]	; (802b0ec <lv_img_create+0x1e0>)
 802af42:	f7f5 f8e5 	bl	8020110 <lv_debug_log_error>
 802af46:	e7fe      	b.n	802af46 <lv_img_create+0x3a>
    if(img == NULL) return NULL;
 802af48:	697b      	ldr	r3, [r7, #20]
 802af4a:	2b00      	cmp	r3, #0
 802af4c:	d101      	bne.n	802af52 <lv_img_create+0x46>
 802af4e:	2300      	movs	r3, #0
 802af50:	e0c7      	b.n	802b0e2 <lv_img_create+0x1d6>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(img);
 802af52:	4b67      	ldr	r3, [pc, #412]	; (802b0f0 <lv_img_create+0x1e4>)
 802af54:	681b      	ldr	r3, [r3, #0]
 802af56:	2b00      	cmp	r3, #0
 802af58:	d105      	bne.n	802af66 <lv_img_create+0x5a>
 802af5a:	6978      	ldr	r0, [r7, #20]
 802af5c:	f7e0 fd38 	bl	800b9d0 <lv_obj_get_signal_cb>
 802af60:	4603      	mov	r3, r0
 802af62:	4a63      	ldr	r2, [pc, #396]	; (802b0f0 <lv_img_create+0x1e4>)
 802af64:	6013      	str	r3, [r2, #0]

    /*Extend the basic object to image object*/
    lv_img_ext_t * ext = lv_obj_allocate_ext_attr(img, sizeof(lv_img_ext_t));
 802af66:	2118      	movs	r1, #24
 802af68:	6978      	ldr	r0, [r7, #20]
 802af6a:	f7df fe03 	bl	800ab74 <lv_obj_allocate_ext_attr>
 802af6e:	6138      	str	r0, [r7, #16]
    LV_ASSERT_MEM(ext);
 802af70:	6938      	ldr	r0, [r7, #16]
 802af72:	f7f5 f8bd 	bl	80200f0 <lv_debug_check_null>
 802af76:	4603      	mov	r3, r0
 802af78:	f083 0301 	eor.w	r3, r3, #1
 802af7c:	b2db      	uxtb	r3, r3
 802af7e:	2b00      	cmp	r3, #0
 802af80:	d009      	beq.n	802af96 <lv_img_create+0x8a>
 802af82:	693b      	ldr	r3, [r7, #16]
 802af84:	2200      	movs	r2, #0
 802af86:	461c      	mov	r4, r3
 802af88:	4615      	mov	r5, r2
 802af8a:	4622      	mov	r2, r4
 802af8c:	462b      	mov	r3, r5
 802af8e:	4857      	ldr	r0, [pc, #348]	; (802b0ec <lv_img_create+0x1e0>)
 802af90:	f7f5 f8be 	bl	8020110 <lv_debug_log_error>
 802af94:	e7fe      	b.n	802af94 <lv_img_create+0x88>
    if(ext == NULL) {
 802af96:	693b      	ldr	r3, [r7, #16]
 802af98:	2b00      	cmp	r3, #0
 802af9a:	d104      	bne.n	802afa6 <lv_img_create+0x9a>
        lv_obj_del(img);
 802af9c:	6978      	ldr	r0, [r7, #20]
 802af9e:	f7de fca7 	bl	80098f0 <lv_obj_del>
        return NULL;
 802afa2:	2300      	movs	r3, #0
 802afa4:	e09d      	b.n	802b0e2 <lv_img_create+0x1d6>
    }

    ext->src       = NULL;
 802afa6:	693b      	ldr	r3, [r7, #16]
 802afa8:	2200      	movs	r2, #0
 802afaa:	601a      	str	r2, [r3, #0]
    ext->src_type  = LV_IMG_SRC_UNKNOWN;
 802afac:	693a      	ldr	r2, [r7, #16]
 802afae:	7d13      	ldrb	r3, [r2, #20]
 802afb0:	f043 0303 	orr.w	r3, r3, #3
 802afb4:	7513      	strb	r3, [r2, #20]
    ext->cf        = LV_IMG_CF_UNKNOWN;
 802afb6:	693a      	ldr	r2, [r7, #16]
 802afb8:	7d13      	ldrb	r3, [r2, #20]
 802afba:	f36f 03c7 	bfc	r3, #3, #5
 802afbe:	7513      	strb	r3, [r2, #20]
    ext->w         = lv_obj_get_width(img);
 802afc0:	6978      	ldr	r0, [r7, #20]
 802afc2:	f7df ff8b 	bl	800aedc <lv_obj_get_width>
 802afc6:	4603      	mov	r3, r0
 802afc8:	461a      	mov	r2, r3
 802afca:	693b      	ldr	r3, [r7, #16]
 802afcc:	811a      	strh	r2, [r3, #8]
    ext->h         = lv_obj_get_height(img);
 802afce:	6978      	ldr	r0, [r7, #20]
 802afd0:	f7df ffa8 	bl	800af24 <lv_obj_get_height>
 802afd4:	4603      	mov	r3, r0
 802afd6:	461a      	mov	r2, r3
 802afd8:	693b      	ldr	r3, [r7, #16]
 802afda:	815a      	strh	r2, [r3, #10]
    ext->angle = 0;
 802afdc:	693b      	ldr	r3, [r7, #16]
 802afde:	2200      	movs	r2, #0
 802afe0:	819a      	strh	r2, [r3, #12]
    ext->zoom = LV_IMG_ZOOM_NONE;
 802afe2:	693b      	ldr	r3, [r7, #16]
 802afe4:	f44f 7280 	mov.w	r2, #256	; 0x100
 802afe8:	825a      	strh	r2, [r3, #18]
    ext->antialias = LV_ANTIALIAS ? 1 : 0;
 802afea:	693a      	ldr	r2, [r7, #16]
 802afec:	7d53      	ldrb	r3, [r2, #21]
 802afee:	f043 0301 	orr.w	r3, r3, #1
 802aff2:	7553      	strb	r3, [r2, #21]
    ext->auto_size = 1;
 802aff4:	693a      	ldr	r2, [r7, #16]
 802aff6:	7d13      	ldrb	r3, [r2, #20]
 802aff8:	f043 0304 	orr.w	r3, r3, #4
 802affc:	7513      	strb	r3, [r2, #20]
    ext->offset.x  = 0;
 802affe:	693b      	ldr	r3, [r7, #16]
 802b000:	2200      	movs	r2, #0
 802b002:	809a      	strh	r2, [r3, #4]
    ext->offset.y  = 0;
 802b004:	693b      	ldr	r3, [r7, #16]
 802b006:	2200      	movs	r2, #0
 802b008:	80da      	strh	r2, [r3, #6]
    ext->pivot.x = 0;
 802b00a:	693b      	ldr	r3, [r7, #16]
 802b00c:	2200      	movs	r2, #0
 802b00e:	81da      	strh	r2, [r3, #14]
    ext->pivot.y = 0;
 802b010:	693b      	ldr	r3, [r7, #16]
 802b012:	2200      	movs	r2, #0
 802b014:	821a      	strh	r2, [r3, #16]

    /*Init the new object*/
    lv_obj_set_signal_cb(img, lv_img_signal);
 802b016:	4937      	ldr	r1, [pc, #220]	; (802b0f4 <lv_img_create+0x1e8>)
 802b018:	6978      	ldr	r0, [r7, #20]
 802b01a:	f7df fd47 	bl	800aaac <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(img, lv_img_design);
 802b01e:	4936      	ldr	r1, [pc, #216]	; (802b0f8 <lv_img_create+0x1ec>)
 802b020:	6978      	ldr	r0, [r7, #20]
 802b022:	f7df fd85 	bl	800ab30 <lv_obj_set_design_cb>

    if(copy == NULL) {
 802b026:	683b      	ldr	r3, [r7, #0]
 802b028:	2b00      	cmp	r3, #0
 802b02a:	d11a      	bne.n	802b062 <lv_img_create+0x156>
        lv_theme_apply(img, LV_THEME_IMAGE);
 802b02c:	210f      	movs	r1, #15
 802b02e:	6978      	ldr	r0, [r7, #20]
 802b030:	f7f7 fd86 	bl	8022b40 <lv_theme_apply>
        lv_obj_set_click(img, false);
 802b034:	2100      	movs	r1, #0
 802b036:	6978      	ldr	r0, [r7, #20]
 802b038:	f7df fa6a 	bl	800a510 <lv_obj_set_click>
        lv_obj_set_adv_hittest(img, true); /*Images have fast hit-testing*/
 802b03c:	2101      	movs	r1, #1
 802b03e:	6978      	ldr	r0, [r7, #20]
 802b040:	f7df fa36 	bl	800a4b0 <lv_obj_set_adv_hittest>
        /* Enable auto size for non screens
         * because image screens are wallpapers
         * and must be screen sized*/
        if(par != NULL) {
 802b044:	687b      	ldr	r3, [r7, #4]
 802b046:	2b00      	cmp	r3, #0
 802b048:	d005      	beq.n	802b056 <lv_img_create+0x14a>
            ext->auto_size = 1;
 802b04a:	693a      	ldr	r2, [r7, #16]
 802b04c:	7d13      	ldrb	r3, [r2, #20]
 802b04e:	f043 0304 	orr.w	r3, r3, #4
 802b052:	7513      	strb	r3, [r2, #20]
 802b054:	e044      	b.n	802b0e0 <lv_img_create+0x1d4>
        }
        else {
            ext->auto_size = 0;
 802b056:	693a      	ldr	r2, [r7, #16]
 802b058:	7d13      	ldrb	r3, [r2, #20]
 802b05a:	f36f 0382 	bfc	r3, #2, #1
 802b05e:	7513      	strb	r3, [r2, #20]
 802b060:	e03e      	b.n	802b0e0 <lv_img_create+0x1d4>
        }
    }
    else {
        lv_img_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 802b062:	6838      	ldr	r0, [r7, #0]
 802b064:	f7e0 fcf4 	bl	800ba50 <lv_obj_get_ext_attr>
 802b068:	60f8      	str	r0, [r7, #12]
        ext->auto_size     = copy_ext->auto_size;
 802b06a:	68fb      	ldr	r3, [r7, #12]
 802b06c:	7d1b      	ldrb	r3, [r3, #20]
 802b06e:	f3c3 0380 	ubfx	r3, r3, #2, #1
 802b072:	b2d9      	uxtb	r1, r3
 802b074:	693a      	ldr	r2, [r7, #16]
 802b076:	7d13      	ldrb	r3, [r2, #20]
 802b078:	f361 0382 	bfi	r3, r1, #2, #1
 802b07c:	7513      	strb	r3, [r2, #20]
        ext->zoom          = copy_ext->zoom;
 802b07e:	68fb      	ldr	r3, [r7, #12]
 802b080:	8a5a      	ldrh	r2, [r3, #18]
 802b082:	693b      	ldr	r3, [r7, #16]
 802b084:	825a      	strh	r2, [r3, #18]
        ext->angle         = copy_ext->angle;
 802b086:	68fb      	ldr	r3, [r7, #12]
 802b088:	899a      	ldrh	r2, [r3, #12]
 802b08a:	693b      	ldr	r3, [r7, #16]
 802b08c:	819a      	strh	r2, [r3, #12]
        ext->antialias     = copy_ext->antialias;
 802b08e:	68fb      	ldr	r3, [r7, #12]
 802b090:	7d5b      	ldrb	r3, [r3, #21]
 802b092:	f3c3 0300 	ubfx	r3, r3, #0, #1
 802b096:	b2d9      	uxtb	r1, r3
 802b098:	693a      	ldr	r2, [r7, #16]
 802b09a:	7d53      	ldrb	r3, [r2, #21]
 802b09c:	f361 0300 	bfi	r3, r1, #0, #1
 802b0a0:	7553      	strb	r3, [r2, #21]
        ext->offset.x     = copy_ext->offset.x;
 802b0a2:	68fb      	ldr	r3, [r7, #12]
 802b0a4:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 802b0a8:	693b      	ldr	r3, [r7, #16]
 802b0aa:	809a      	strh	r2, [r3, #4]
        ext->offset.y     = copy_ext->offset.y;
 802b0ac:	68fb      	ldr	r3, [r7, #12]
 802b0ae:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 802b0b2:	693b      	ldr	r3, [r7, #16]
 802b0b4:	80da      	strh	r2, [r3, #6]
        ext->pivot.x     = copy_ext->pivot.x;
 802b0b6:	68fb      	ldr	r3, [r7, #12]
 802b0b8:	f9b3 200e 	ldrsh.w	r2, [r3, #14]
 802b0bc:	693b      	ldr	r3, [r7, #16]
 802b0be:	81da      	strh	r2, [r3, #14]
        ext->pivot.y     = copy_ext->pivot.y;
 802b0c0:	68fb      	ldr	r3, [r7, #12]
 802b0c2:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 802b0c6:	693b      	ldr	r3, [r7, #16]
 802b0c8:	821a      	strh	r2, [r3, #16]
        lv_img_set_src(img, copy_ext->src);
 802b0ca:	68fb      	ldr	r3, [r7, #12]
 802b0cc:	681b      	ldr	r3, [r3, #0]
 802b0ce:	4619      	mov	r1, r3
 802b0d0:	6978      	ldr	r0, [r7, #20]
 802b0d2:	f000 f813 	bl	802b0fc <lv_img_set_src>

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(img, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
 802b0d6:	22ff      	movs	r2, #255	; 0xff
 802b0d8:	21ff      	movs	r1, #255	; 0xff
 802b0da:	6978      	ldr	r0, [r7, #20]
 802b0dc:	f7df f910 	bl	800a300 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("image created");

    return img;
 802b0e0:	697b      	ldr	r3, [r7, #20]
}
 802b0e2:	4618      	mov	r0, r3
 802b0e4:	3718      	adds	r7, #24
 802b0e6:	46bd      	mov	sp, r7
 802b0e8:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 802b0ec:	0802e5cc 	.word	0x0802e5cc
 802b0f0:	20012360 	.word	0x20012360
 802b0f4:	0802bd65 	.word	0x0802bd65
 802b0f8:	0802b3e5 	.word	0x0802b3e5

0802b0fc <lv_img_set_src>:
 * Set the pixel map to display by the image
 * @param img pointer to an image object
 * @param data the image data
 */
void lv_img_set_src(lv_obj_t * img, const void * src_img)
{
 802b0fc:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 802b100:	b08e      	sub	sp, #56	; 0x38
 802b102:	af04      	add	r7, sp, #16
 802b104:	6078      	str	r0, [r7, #4]
 802b106:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(img, LV_OBJX_NAME);
 802b108:	6878      	ldr	r0, [r7, #4]
 802b10a:	f7f4 fff1 	bl	80200f0 <lv_debug_check_null>
 802b10e:	4603      	mov	r3, r0
 802b110:	f083 0301 	eor.w	r3, r3, #1
 802b114:	b2db      	uxtb	r3, r3
 802b116:	2b00      	cmp	r3, #0
 802b118:	d009      	beq.n	802b12e <lv_img_set_src+0x32>
 802b11a:	687b      	ldr	r3, [r7, #4]
 802b11c:	2200      	movs	r2, #0
 802b11e:	4698      	mov	r8, r3
 802b120:	4691      	mov	r9, r2
 802b122:	4642      	mov	r2, r8
 802b124:	464b      	mov	r3, r9
 802b126:	4897      	ldr	r0, [pc, #604]	; (802b384 <lv_img_set_src+0x288>)
 802b128:	f7f4 fff2 	bl	8020110 <lv_debug_log_error>
 802b12c:	e7fe      	b.n	802b12c <lv_img_set_src+0x30>

    lv_img_src_t src_type = lv_img_src_get_type(src_img);
 802b12e:	6838      	ldr	r0, [r7, #0]
 802b130:	f7e7 fa51 	bl	80125d6 <lv_img_src_get_type>
 802b134:	4603      	mov	r3, r0
 802b136:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    lv_img_ext_t * ext    = lv_obj_get_ext_attr(img);
 802b13a:	6878      	ldr	r0, [r7, #4]
 802b13c:	f7e0 fc88 	bl	800ba50 <lv_obj_get_ext_attr>
 802b140:	61f8      	str	r0, [r7, #28]
            LV_LOG_WARN("lv_img_set_src: unknown type");
    }
#endif

    /*If the new source type is unknown free the memories of the old source*/
    if(src_type == LV_IMG_SRC_UNKNOWN) {
 802b142:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 802b146:	2b03      	cmp	r3, #3
 802b148:	d11b      	bne.n	802b182 <lv_img_set_src+0x86>
        LV_LOG_WARN("lv_img_set_src: unknown image type");
        if(ext->src_type == LV_IMG_SRC_SYMBOL || ext->src_type == LV_IMG_SRC_FILE) {
 802b14a:	69fb      	ldr	r3, [r7, #28]
 802b14c:	7d1b      	ldrb	r3, [r3, #20]
 802b14e:	f003 0303 	and.w	r3, r3, #3
 802b152:	b2db      	uxtb	r3, r3
 802b154:	2b02      	cmp	r3, #2
 802b156:	d006      	beq.n	802b166 <lv_img_set_src+0x6a>
 802b158:	69fb      	ldr	r3, [r7, #28]
 802b15a:	7d1b      	ldrb	r3, [r3, #20]
 802b15c:	f003 0303 	and.w	r3, r3, #3
 802b160:	b2db      	uxtb	r3, r3
 802b162:	2b01      	cmp	r3, #1
 802b164:	d104      	bne.n	802b170 <lv_img_set_src+0x74>
            lv_mem_free(ext->src);
 802b166:	69fb      	ldr	r3, [r7, #28]
 802b168:	681b      	ldr	r3, [r3, #0]
 802b16a:	4618      	mov	r0, r3
 802b16c:	f7f5 fd7c 	bl	8020c68 <lv_mem_free>
        }
        ext->src      = NULL;
 802b170:	69fb      	ldr	r3, [r7, #28]
 802b172:	2200      	movs	r2, #0
 802b174:	601a      	str	r2, [r3, #0]
        ext->src_type = LV_IMG_SRC_UNKNOWN;
 802b176:	69fa      	ldr	r2, [r7, #28]
 802b178:	7d13      	ldrb	r3, [r2, #20]
 802b17a:	f043 0303 	orr.w	r3, r3, #3
 802b17e:	7513      	strb	r3, [r2, #20]
        return;
 802b180:	e0fb      	b.n	802b37a <lv_img_set_src+0x27e>
    }

    lv_img_header_t header;
    lv_img_decoder_get_info(src_img, &header);
 802b182:	f107 030c 	add.w	r3, r7, #12
 802b186:	4619      	mov	r1, r3
 802b188:	6838      	ldr	r0, [r7, #0]
 802b18a:	f7f1 fc4f 	bl	801ca2c <lv_img_decoder_get_info>

    /*Save the source*/
    if(src_type == LV_IMG_SRC_VARIABLE) {
 802b18e:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 802b192:	2b00      	cmp	r3, #0
 802b194:	d116      	bne.n	802b1c4 <lv_img_set_src+0xc8>
        LV_LOG_INFO("lv_img_set_src:  `LV_IMG_SRC_VARIABLE` type found");

        /*If memory was allocated because of the previous `src_type` then free it*/
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
 802b196:	69fb      	ldr	r3, [r7, #28]
 802b198:	7d1b      	ldrb	r3, [r3, #20]
 802b19a:	f003 0303 	and.w	r3, r3, #3
 802b19e:	b2db      	uxtb	r3, r3
 802b1a0:	2b01      	cmp	r3, #1
 802b1a2:	d006      	beq.n	802b1b2 <lv_img_set_src+0xb6>
 802b1a4:	69fb      	ldr	r3, [r7, #28]
 802b1a6:	7d1b      	ldrb	r3, [r3, #20]
 802b1a8:	f003 0303 	and.w	r3, r3, #3
 802b1ac:	b2db      	uxtb	r3, r3
 802b1ae:	2b02      	cmp	r3, #2
 802b1b0:	d104      	bne.n	802b1bc <lv_img_set_src+0xc0>
            lv_mem_free(ext->src);
 802b1b2:	69fb      	ldr	r3, [r7, #28]
 802b1b4:	681b      	ldr	r3, [r3, #0]
 802b1b6:	4618      	mov	r0, r3
 802b1b8:	f7f5 fd56 	bl	8020c68 <lv_mem_free>
        }
        ext->src = src_img;
 802b1bc:	69fb      	ldr	r3, [r7, #28]
 802b1be:	683a      	ldr	r2, [r7, #0]
 802b1c0:	601a      	str	r2, [r3, #0]
 802b1c2:	e04c      	b.n	802b25e <lv_img_set_src+0x162>
    }
    else if(src_type == LV_IMG_SRC_FILE || src_type == LV_IMG_SRC_SYMBOL) {
 802b1c4:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 802b1c8:	2b01      	cmp	r3, #1
 802b1ca:	d003      	beq.n	802b1d4 <lv_img_set_src+0xd8>
 802b1cc:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 802b1d0:	2b02      	cmp	r3, #2
 802b1d2:	d144      	bne.n	802b25e <lv_img_set_src+0x162>
        /* If the new and the old src are the same then it was only a refresh.*/
        if(ext->src != src_img) {
 802b1d4:	69fb      	ldr	r3, [r7, #28]
 802b1d6:	681b      	ldr	r3, [r3, #0]
 802b1d8:	683a      	ldr	r2, [r7, #0]
 802b1da:	429a      	cmp	r2, r3
 802b1dc:	d03f      	beq.n	802b25e <lv_img_set_src+0x162>
            const void * old_src = NULL;
 802b1de:	2300      	movs	r3, #0
 802b1e0:	627b      	str	r3, [r7, #36]	; 0x24
            /* If memory was allocated because of the previous `src_type` then save its pointer and free after allocation.
             * It's important to allocate first to be sure the new data will be on a new address.
             * Else `img_cache` wouldn't see the change in source.*/
            if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
 802b1e2:	69fb      	ldr	r3, [r7, #28]
 802b1e4:	7d1b      	ldrb	r3, [r3, #20]
 802b1e6:	f003 0303 	and.w	r3, r3, #3
 802b1ea:	b2db      	uxtb	r3, r3
 802b1ec:	2b01      	cmp	r3, #1
 802b1ee:	d006      	beq.n	802b1fe <lv_img_set_src+0x102>
 802b1f0:	69fb      	ldr	r3, [r7, #28]
 802b1f2:	7d1b      	ldrb	r3, [r3, #20]
 802b1f4:	f003 0303 	and.w	r3, r3, #3
 802b1f8:	b2db      	uxtb	r3, r3
 802b1fa:	2b02      	cmp	r3, #2
 802b1fc:	d102      	bne.n	802b204 <lv_img_set_src+0x108>
                old_src = ext->src;
 802b1fe:	69fb      	ldr	r3, [r7, #28]
 802b200:	681b      	ldr	r3, [r3, #0]
 802b202:	627b      	str	r3, [r7, #36]	; 0x24
            }
            char * new_str = lv_mem_alloc(strlen(src_img) + 1);
 802b204:	6838      	ldr	r0, [r7, #0]
 802b206:	f7d4 fffb 	bl	8000200 <strlen>
 802b20a:	4603      	mov	r3, r0
 802b20c:	3301      	adds	r3, #1
 802b20e:	4618      	mov	r0, r3
 802b210:	f7f5 fce0 	bl	8020bd4 <lv_mem_alloc>
 802b214:	61b8      	str	r0, [r7, #24]
            LV_ASSERT_MEM(new_str);
 802b216:	69b8      	ldr	r0, [r7, #24]
 802b218:	f7f4 ff6a 	bl	80200f0 <lv_debug_check_null>
 802b21c:	4603      	mov	r3, r0
 802b21e:	f083 0301 	eor.w	r3, r3, #1
 802b222:	b2db      	uxtb	r3, r3
 802b224:	2b00      	cmp	r3, #0
 802b226:	d009      	beq.n	802b23c <lv_img_set_src+0x140>
 802b228:	69bb      	ldr	r3, [r7, #24]
 802b22a:	2200      	movs	r2, #0
 802b22c:	461c      	mov	r4, r3
 802b22e:	4615      	mov	r5, r2
 802b230:	4622      	mov	r2, r4
 802b232:	462b      	mov	r3, r5
 802b234:	4854      	ldr	r0, [pc, #336]	; (802b388 <lv_img_set_src+0x28c>)
 802b236:	f7f4 ff6b 	bl	8020110 <lv_debug_log_error>
 802b23a:	e7fe      	b.n	802b23a <lv_img_set_src+0x13e>
            if(new_str == NULL) return;
 802b23c:	69bb      	ldr	r3, [r7, #24]
 802b23e:	2b00      	cmp	r3, #0
 802b240:	f000 809a 	beq.w	802b378 <lv_img_set_src+0x27c>
            strcpy(new_str, src_img);
 802b244:	6839      	ldr	r1, [r7, #0]
 802b246:	69b8      	ldr	r0, [r7, #24]
 802b248:	f003 f852 	bl	802e2f0 <strcpy>
            ext->src = new_str;
 802b24c:	69fb      	ldr	r3, [r7, #28]
 802b24e:	69ba      	ldr	r2, [r7, #24]
 802b250:	601a      	str	r2, [r3, #0]

            if(old_src) lv_mem_free(old_src);
 802b252:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802b254:	2b00      	cmp	r3, #0
 802b256:	d002      	beq.n	802b25e <lv_img_set_src+0x162>
 802b258:	6a78      	ldr	r0, [r7, #36]	; 0x24
 802b25a:	f7f5 fd05 	bl	8020c68 <lv_mem_free>
        }
    }

    if(src_type == LV_IMG_SRC_SYMBOL) {
 802b25e:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 802b262:	2b02      	cmp	r3, #2
 802b264:	d133      	bne.n	802b2ce <lv_img_set_src+0x1d2>
        /*`lv_img_dsc_get_info` couldn't set the with and height of a font so set it here*/
        const lv_font_t * font = lv_obj_get_style_text_font(img, LV_IMG_PART_MAIN);
 802b266:	2100      	movs	r1, #0
 802b268:	6878      	ldr	r0, [r7, #4]
 802b26a:	f7ff fe06 	bl	802ae7a <lv_obj_get_style_text_font>
 802b26e:	6178      	str	r0, [r7, #20]
        lv_style_int_t letter_space = lv_obj_get_style_text_letter_space(img, LV_IMG_PART_MAIN);
 802b270:	2100      	movs	r1, #0
 802b272:	6878      	ldr	r0, [r7, #4]
 802b274:	f7ff fddd 	bl	802ae32 <lv_obj_get_style_text_letter_space>
 802b278:	4603      	mov	r3, r0
 802b27a:	827b      	strh	r3, [r7, #18]
        lv_style_int_t line_space = lv_obj_get_style_text_line_space(img, LV_IMG_PART_MAIN);
 802b27c:	2100      	movs	r1, #0
 802b27e:	6878      	ldr	r0, [r7, #4]
 802b280:	f7ff fde9 	bl	802ae56 <lv_obj_get_style_text_line_space>
 802b284:	4603      	mov	r3, r0
 802b286:	823b      	strh	r3, [r7, #16]
        lv_point_t size;
        _lv_txt_get_size(&size, src_img, font, letter_space, line_space,
 802b288:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 802b28c:	f107 0008 	add.w	r0, r7, #8
 802b290:	2300      	movs	r3, #0
 802b292:	9302      	str	r3, [sp, #8]
 802b294:	f647 4318 	movw	r3, #31768	; 0x7c18
 802b298:	9301      	str	r3, [sp, #4]
 802b29a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 802b29e:	9300      	str	r3, [sp, #0]
 802b2a0:	4613      	mov	r3, r2
 802b2a2:	697a      	ldr	r2, [r7, #20]
 802b2a4:	6839      	ldr	r1, [r7, #0]
 802b2a6:	f7f6 fef1 	bl	802208c <_lv_txt_get_size>
                         LV_COORD_MAX, LV_TXT_FLAG_NONE);
        header.w = size.x;
 802b2aa:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 802b2ae:	f3c3 030a 	ubfx	r3, r3, #0, #11
 802b2b2:	b29a      	uxth	r2, r3
 802b2b4:	68fb      	ldr	r3, [r7, #12]
 802b2b6:	f362 2394 	bfi	r3, r2, #10, #11
 802b2ba:	60fb      	str	r3, [r7, #12]
        header.h = size.y;
 802b2bc:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 802b2c0:	f3c3 030a 	ubfx	r3, r3, #0, #11
 802b2c4:	b29a      	uxth	r2, r3
 802b2c6:	89fb      	ldrh	r3, [r7, #14]
 802b2c8:	f362 134f 	bfi	r3, r2, #5, #11
 802b2cc:	81fb      	strh	r3, [r7, #14]
    }

    ext->src_type = src_type;
 802b2ce:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 802b2d2:	f003 0303 	and.w	r3, r3, #3
 802b2d6:	b2d9      	uxtb	r1, r3
 802b2d8:	69fa      	ldr	r2, [r7, #28]
 802b2da:	7d13      	ldrb	r3, [r2, #20]
 802b2dc:	f361 0301 	bfi	r3, r1, #0, #2
 802b2e0:	7513      	strb	r3, [r2, #20]
    ext->w        = header.w;
 802b2e2:	68fb      	ldr	r3, [r7, #12]
 802b2e4:	f3c3 238a 	ubfx	r3, r3, #10, #11
 802b2e8:	b29b      	uxth	r3, r3
 802b2ea:	b21a      	sxth	r2, r3
 802b2ec:	69fb      	ldr	r3, [r7, #28]
 802b2ee:	811a      	strh	r2, [r3, #8]
    ext->h        = header.h;
 802b2f0:	89fb      	ldrh	r3, [r7, #14]
 802b2f2:	f3c3 134a 	ubfx	r3, r3, #5, #11
 802b2f6:	b29b      	uxth	r3, r3
 802b2f8:	b21a      	sxth	r2, r3
 802b2fa:	69fb      	ldr	r3, [r7, #28]
 802b2fc:	815a      	strh	r2, [r3, #10]
    ext->cf       = header.cf;
 802b2fe:	7b3b      	ldrb	r3, [r7, #12]
 802b300:	f3c3 0304 	ubfx	r3, r3, #0, #5
 802b304:	b2d9      	uxtb	r1, r3
 802b306:	69fa      	ldr	r2, [r7, #28]
 802b308:	7d13      	ldrb	r3, [r2, #20]
 802b30a:	f361 03c7 	bfi	r3, r1, #3, #5
 802b30e:	7513      	strb	r3, [r2, #20]
    ext->pivot.x = header.w / 2;
 802b310:	68fb      	ldr	r3, [r7, #12]
 802b312:	f3c3 238a 	ubfx	r3, r3, #10, #11
 802b316:	b29b      	uxth	r3, r3
 802b318:	0fda      	lsrs	r2, r3, #31
 802b31a:	4413      	add	r3, r2
 802b31c:	105b      	asrs	r3, r3, #1
 802b31e:	b21a      	sxth	r2, r3
 802b320:	69fb      	ldr	r3, [r7, #28]
 802b322:	81da      	strh	r2, [r3, #14]
    ext->pivot.y = header.h / 2;
 802b324:	89fb      	ldrh	r3, [r7, #14]
 802b326:	f3c3 134a 	ubfx	r3, r3, #5, #11
 802b32a:	b29b      	uxth	r3, r3
 802b32c:	0fda      	lsrs	r2, r3, #31
 802b32e:	4413      	add	r3, r2
 802b330:	105b      	asrs	r3, r3, #1
 802b332:	b21a      	sxth	r2, r3
 802b334:	69fb      	ldr	r3, [r7, #28]
 802b336:	821a      	strh	r2, [r3, #16]

    if(lv_img_get_auto_size(img) != false) {
 802b338:	6878      	ldr	r0, [r7, #4]
 802b33a:	f000 f827 	bl	802b38c <lv_img_get_auto_size>
 802b33e:	4603      	mov	r3, r0
 802b340:	2b00      	cmp	r3, #0
 802b342:	d009      	beq.n	802b358 <lv_img_set_src+0x25c>
        lv_obj_set_size(img, ext->w, ext->h);
 802b344:	69fb      	ldr	r3, [r7, #28]
 802b346:	f9b3 1008 	ldrsh.w	r1, [r3, #8]
 802b34a:	69fb      	ldr	r3, [r7, #28]
 802b34c:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 802b350:	461a      	mov	r2, r3
 802b352:	6878      	ldr	r0, [r7, #4]
 802b354:	f7de fd76 	bl	8009e44 <lv_obj_set_size>
    }

    /*Provide enough room for the rotated corners*/
    if(ext->angle || ext->zoom != LV_IMG_ZOOM_NONE) lv_obj_refresh_ext_draw_pad(img);
 802b358:	69fb      	ldr	r3, [r7, #28]
 802b35a:	899b      	ldrh	r3, [r3, #12]
 802b35c:	2b00      	cmp	r3, #0
 802b35e:	d104      	bne.n	802b36a <lv_img_set_src+0x26e>
 802b360:	69fb      	ldr	r3, [r7, #28]
 802b362:	8a5b      	ldrh	r3, [r3, #18]
 802b364:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802b368:	d002      	beq.n	802b370 <lv_img_set_src+0x274>
 802b36a:	6878      	ldr	r0, [r7, #4]
 802b36c:	f7df fc34 	bl	800abd8 <lv_obj_refresh_ext_draw_pad>

    lv_obj_invalidate(img);
 802b370:	6878      	ldr	r0, [r7, #4]
 802b372:	f7de fb45 	bl	8009a00 <lv_obj_invalidate>
 802b376:	e000      	b.n	802b37a <lv_img_set_src+0x27e>
            if(new_str == NULL) return;
 802b378:	bf00      	nop
}
 802b37a:	3728      	adds	r7, #40	; 0x28
 802b37c:	46bd      	mov	sp, r7
 802b37e:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 802b382:	bf00      	nop
 802b384:	0802e5dc 	.word	0x0802e5dc
 802b388:	0802e5cc 	.word	0x0802e5cc

0802b38c <lv_img_get_auto_size>:
 * Get the auto size enable attribute
 * @param img pointer to an image
 * @return true: auto size is enabled, false: auto size is disabled
 */
bool lv_img_get_auto_size(const lv_obj_t * img)
{
 802b38c:	b5b0      	push	{r4, r5, r7, lr}
 802b38e:	b084      	sub	sp, #16
 802b390:	af00      	add	r7, sp, #0
 802b392:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(img, LV_OBJX_NAME);
 802b394:	6878      	ldr	r0, [r7, #4]
 802b396:	f7f4 feab 	bl	80200f0 <lv_debug_check_null>
 802b39a:	4603      	mov	r3, r0
 802b39c:	f083 0301 	eor.w	r3, r3, #1
 802b3a0:	b2db      	uxtb	r3, r3
 802b3a2:	2b00      	cmp	r3, #0
 802b3a4:	d009      	beq.n	802b3ba <lv_img_get_auto_size+0x2e>
 802b3a6:	687b      	ldr	r3, [r7, #4]
 802b3a8:	2200      	movs	r2, #0
 802b3aa:	461c      	mov	r4, r3
 802b3ac:	4615      	mov	r5, r2
 802b3ae:	4622      	mov	r2, r4
 802b3b0:	462b      	mov	r3, r5
 802b3b2:	480b      	ldr	r0, [pc, #44]	; (802b3e0 <lv_img_get_auto_size+0x54>)
 802b3b4:	f7f4 feac 	bl	8020110 <lv_debug_log_error>
 802b3b8:	e7fe      	b.n	802b3b8 <lv_img_get_auto_size+0x2c>

    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
 802b3ba:	6878      	ldr	r0, [r7, #4]
 802b3bc:	f7e0 fb48 	bl	800ba50 <lv_obj_get_ext_attr>
 802b3c0:	60f8      	str	r0, [r7, #12]

    return ext->auto_size == 0 ? false : true;
 802b3c2:	68fb      	ldr	r3, [r7, #12]
 802b3c4:	7d1b      	ldrb	r3, [r3, #20]
 802b3c6:	f003 0304 	and.w	r3, r3, #4
 802b3ca:	b2db      	uxtb	r3, r3
 802b3cc:	2b00      	cmp	r3, #0
 802b3ce:	bf14      	ite	ne
 802b3d0:	2301      	movne	r3, #1
 802b3d2:	2300      	moveq	r3, #0
 802b3d4:	b2db      	uxtb	r3, r3
}
 802b3d6:	4618      	mov	r0, r3
 802b3d8:	3710      	adds	r7, #16
 802b3da:	46bd      	mov	sp, r7
 802b3dc:	bdb0      	pop	{r4, r5, r7, pc}
 802b3de:	bf00      	nop
 802b3e0:	0802e5dc 	.word	0x0802e5dc

0802b3e4 <lv_img_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return an element of `lv_design_res_t`
 */
static lv_design_res_t lv_img_design(lv_obj_t * img, const lv_area_t * clip_area, lv_design_mode_t mode)
{
 802b3e4:	b5b0      	push	{r4, r5, r7, lr}
 802b3e6:	b0c0      	sub	sp, #256	; 0x100
 802b3e8:	af02      	add	r7, sp, #8
 802b3ea:	60f8      	str	r0, [r7, #12]
 802b3ec:	60b9      	str	r1, [r7, #8]
 802b3ee:	4613      	mov	r3, r2
 802b3f0:	71fb      	strb	r3, [r7, #7]
    lv_img_ext_t * ext       = lv_obj_get_ext_attr(img);
 802b3f2:	68f8      	ldr	r0, [r7, #12]
 802b3f4:	f7e0 fb2c 	bl	800ba50 <lv_obj_get_ext_attr>
 802b3f8:	f8c7 00f4 	str.w	r0, [r7, #244]	; 0xf4

    if(mode == LV_DESIGN_COVER_CHK) {
 802b3fc:	79fb      	ldrb	r3, [r7, #7]
 802b3fe:	2b02      	cmp	r3, #2
 802b400:	f040 80e4 	bne.w	802b5cc <lv_img_design+0x1e8>
        if(lv_obj_get_style_clip_corner(img, LV_IMG_PART_MAIN)) return LV_DESIGN_RES_MASKED;
 802b404:	2100      	movs	r1, #0
 802b406:	68f8      	ldr	r0, [r7, #12]
 802b408:	f7ff fc6f 	bl	802acea <lv_obj_get_style_clip_corner>
 802b40c:	4603      	mov	r3, r0
 802b40e:	2b00      	cmp	r3, #0
 802b410:	d002      	beq.n	802b418 <lv_img_design+0x34>
 802b412:	2303      	movs	r3, #3
 802b414:	f000 bca2 	b.w	802bd5c <lv_img_design+0x978>

        if(ext->src_type == LV_IMG_SRC_UNKNOWN || ext->src_type == LV_IMG_SRC_SYMBOL) return LV_DESIGN_RES_NOT_COVER;
 802b418:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b41c:	7d1b      	ldrb	r3, [r3, #20]
 802b41e:	f003 0303 	and.w	r3, r3, #3
 802b422:	b2db      	uxtb	r3, r3
 802b424:	2b03      	cmp	r3, #3
 802b426:	d007      	beq.n	802b438 <lv_img_design+0x54>
 802b428:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b42c:	7d1b      	ldrb	r3, [r3, #20]
 802b42e:	f003 0303 	and.w	r3, r3, #3
 802b432:	b2db      	uxtb	r3, r3
 802b434:	2b02      	cmp	r3, #2
 802b436:	d102      	bne.n	802b43e <lv_img_design+0x5a>
 802b438:	2302      	movs	r3, #2
 802b43a:	f000 bc8f 	b.w	802bd5c <lv_img_design+0x978>

        /*Non true color format might have "holes"*/
        if(ext->cf != LV_IMG_CF_TRUE_COLOR && ext->cf != LV_IMG_CF_RAW) return LV_DESIGN_RES_NOT_COVER;
 802b43e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b442:	7d1b      	ldrb	r3, [r3, #20]
 802b444:	f023 0307 	bic.w	r3, r3, #7
 802b448:	b2db      	uxtb	r3, r3
 802b44a:	2b20      	cmp	r3, #32
 802b44c:	d00a      	beq.n	802b464 <lv_img_design+0x80>
 802b44e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b452:	7d1b      	ldrb	r3, [r3, #20]
 802b454:	f023 0307 	bic.w	r3, r3, #7
 802b458:	b2db      	uxtb	r3, r3
 802b45a:	2b08      	cmp	r3, #8
 802b45c:	d002      	beq.n	802b464 <lv_img_design+0x80>
 802b45e:	2302      	movs	r3, #2
 802b460:	f000 bc7c 	b.w	802bd5c <lv_img_design+0x978>

        /*With not LV_OPA_COVER images acn't cover an area */
        if(lv_obj_get_style_image_opa(img, LV_IMG_PART_MAIN) != LV_OPA_COVER) return LV_DESIGN_RES_NOT_COVER;
 802b464:	2100      	movs	r1, #0
 802b466:	68f8      	ldr	r0, [r7, #12]
 802b468:	f7ff fd3e 	bl	802aee8 <lv_obj_get_style_image_opa>
 802b46c:	4603      	mov	r3, r0
 802b46e:	2bff      	cmp	r3, #255	; 0xff
 802b470:	d002      	beq.n	802b478 <lv_img_design+0x94>
 802b472:	2302      	movs	r3, #2
 802b474:	f000 bc72 	b.w	802bd5c <lv_img_design+0x978>

        int32_t angle_final = lv_obj_get_style_transform_angle(img, LV_IMG_PART_MAIN);
 802b478:	2100      	movs	r1, #0
 802b47a:	68f8      	ldr	r0, [r7, #12]
 802b47c:	f7ff fc4b 	bl	802ad16 <lv_obj_get_style_transform_angle>
 802b480:	4603      	mov	r3, r0
 802b482:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
        angle_final += ext->angle;
 802b486:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b48a:	899b      	ldrh	r3, [r3, #12]
 802b48c:	461a      	mov	r2, r3
 802b48e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 802b492:	4413      	add	r3, r2
 802b494:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc

        if(angle_final != 0) return LV_DESIGN_RES_NOT_COVER;
 802b498:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 802b49c:	2b00      	cmp	r3, #0
 802b49e:	d002      	beq.n	802b4a6 <lv_img_design+0xc2>
 802b4a0:	2302      	movs	r3, #2
 802b4a2:	f000 bc5b 	b.w	802bd5c <lv_img_design+0x978>

        int32_t zoom_final = lv_obj_get_style_transform_zoom(img, LV_IMG_PART_MAIN);
 802b4a6:	2100      	movs	r1, #0
 802b4a8:	68f8      	ldr	r0, [r7, #12]
 802b4aa:	f7ff fc45 	bl	802ad38 <lv_obj_get_style_transform_zoom>
 802b4ae:	4603      	mov	r3, r0
 802b4b0:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
        zoom_final = (zoom_final * ext->zoom) >> 8;
 802b4b4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b4b8:	8a5b      	ldrh	r3, [r3, #18]
 802b4ba:	461a      	mov	r2, r3
 802b4bc:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 802b4c0:	fb02 f303 	mul.w	r3, r2, r3
 802b4c4:	121b      	asrs	r3, r3, #8
 802b4c6:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8

        if(zoom_final == LV_IMG_ZOOM_NONE) {
 802b4ca:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 802b4ce:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802b4d2:	d10f      	bne.n	802b4f4 <lv_img_design+0x110>
            if(_lv_area_is_in(clip_area, &img->coords, 0) == false) return LV_DESIGN_RES_NOT_COVER;
 802b4d4:	68fb      	ldr	r3, [r7, #12]
 802b4d6:	3310      	adds	r3, #16
 802b4d8:	2200      	movs	r2, #0
 802b4da:	4619      	mov	r1, r3
 802b4dc:	68b8      	ldr	r0, [r7, #8]
 802b4de:	f7f4 f9a7 	bl	801f830 <_lv_area_is_in>
 802b4e2:	4603      	mov	r3, r0
 802b4e4:	f083 0301 	eor.w	r3, r3, #1
 802b4e8:	b2db      	uxtb	r3, r3
 802b4ea:	2b00      	cmp	r3, #0
 802b4ec:	d05a      	beq.n	802b5a4 <lv_img_design+0x1c0>
 802b4ee:	2302      	movs	r3, #2
 802b4f0:	f000 bc34 	b.w	802bd5c <lv_img_design+0x978>
        }
        else {
            lv_area_t a;
            _lv_img_buf_get_transformed_area(&a, lv_obj_get_width(img), lv_obj_get_height(img), 0, zoom_final, &ext->pivot);
 802b4f4:	68f8      	ldr	r0, [r7, #12]
 802b4f6:	f7df fcf1 	bl	800aedc <lv_obj_get_width>
 802b4fa:	4603      	mov	r3, r0
 802b4fc:	461c      	mov	r4, r3
 802b4fe:	68f8      	ldr	r0, [r7, #12]
 802b500:	f7df fd10 	bl	800af24 <lv_obj_get_height>
 802b504:	4603      	mov	r3, r0
 802b506:	4619      	mov	r1, r3
 802b508:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 802b50c:	b29b      	uxth	r3, r3
 802b50e:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 802b512:	320e      	adds	r2, #14
 802b514:	f107 00c0 	add.w	r0, r7, #192	; 0xc0
 802b518:	9201      	str	r2, [sp, #4]
 802b51a:	9300      	str	r3, [sp, #0]
 802b51c:	2300      	movs	r3, #0
 802b51e:	460a      	mov	r2, r1
 802b520:	4621      	mov	r1, r4
 802b522:	f7f0 fb59 	bl	801bbd8 <_lv_img_buf_get_transformed_area>
            a.x1 += img->coords.x1;
 802b526:	f9b7 30c0 	ldrsh.w	r3, [r7, #192]	; 0xc0
 802b52a:	b29a      	uxth	r2, r3
 802b52c:	68fb      	ldr	r3, [r7, #12]
 802b52e:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802b532:	b29b      	uxth	r3, r3
 802b534:	4413      	add	r3, r2
 802b536:	b29b      	uxth	r3, r3
 802b538:	b21b      	sxth	r3, r3
 802b53a:	f8a7 30c0 	strh.w	r3, [r7, #192]	; 0xc0
            a.y1 += img->coords.y1;
 802b53e:	f9b7 30c2 	ldrsh.w	r3, [r7, #194]	; 0xc2
 802b542:	b29a      	uxth	r2, r3
 802b544:	68fb      	ldr	r3, [r7, #12]
 802b546:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802b54a:	b29b      	uxth	r3, r3
 802b54c:	4413      	add	r3, r2
 802b54e:	b29b      	uxth	r3, r3
 802b550:	b21b      	sxth	r3, r3
 802b552:	f8a7 30c2 	strh.w	r3, [r7, #194]	; 0xc2
            a.x2 += img->coords.x1;
 802b556:	f9b7 30c4 	ldrsh.w	r3, [r7, #196]	; 0xc4
 802b55a:	b29a      	uxth	r2, r3
 802b55c:	68fb      	ldr	r3, [r7, #12]
 802b55e:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802b562:	b29b      	uxth	r3, r3
 802b564:	4413      	add	r3, r2
 802b566:	b29b      	uxth	r3, r3
 802b568:	b21b      	sxth	r3, r3
 802b56a:	f8a7 30c4 	strh.w	r3, [r7, #196]	; 0xc4
            a.y2 += img->coords.y1;
 802b56e:	f9b7 30c6 	ldrsh.w	r3, [r7, #198]	; 0xc6
 802b572:	b29a      	uxth	r2, r3
 802b574:	68fb      	ldr	r3, [r7, #12]
 802b576:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802b57a:	b29b      	uxth	r3, r3
 802b57c:	4413      	add	r3, r2
 802b57e:	b29b      	uxth	r3, r3
 802b580:	b21b      	sxth	r3, r3
 802b582:	f8a7 30c6 	strh.w	r3, [r7, #198]	; 0xc6

            if(_lv_area_is_in(clip_area, &a, 0) == false) return LV_DESIGN_RES_NOT_COVER;
 802b586:	f107 03c0 	add.w	r3, r7, #192	; 0xc0
 802b58a:	2200      	movs	r2, #0
 802b58c:	4619      	mov	r1, r3
 802b58e:	68b8      	ldr	r0, [r7, #8]
 802b590:	f7f4 f94e 	bl	801f830 <_lv_area_is_in>
 802b594:	4603      	mov	r3, r0
 802b596:	f083 0301 	eor.w	r3, r3, #1
 802b59a:	b2db      	uxtb	r3, r3
 802b59c:	2b00      	cmp	r3, #0
 802b59e:	d001      	beq.n	802b5a4 <lv_img_design+0x1c0>
 802b5a0:	2302      	movs	r3, #2
 802b5a2:	e3db      	b.n	802bd5c <lv_img_design+0x978>
        }

#if LV_USE_BLEND_MODES
        if(lv_obj_get_style_bg_blend_mode(img, LV_IMG_PART_MAIN) != LV_BLEND_MODE_NORMAL) return LV_DESIGN_RES_NOT_COVER;
 802b5a4:	2100      	movs	r1, #0
 802b5a6:	68f8      	ldr	r0, [r7, #12]
 802b5a8:	f7ff fc1b 	bl	802ade2 <lv_obj_get_style_bg_blend_mode>
 802b5ac:	4603      	mov	r3, r0
 802b5ae:	2b00      	cmp	r3, #0
 802b5b0:	d001      	beq.n	802b5b6 <lv_img_design+0x1d2>
 802b5b2:	2302      	movs	r3, #2
 802b5b4:	e3d2      	b.n	802bd5c <lv_img_design+0x978>
        if(lv_obj_get_style_image_blend_mode(img, LV_IMG_PART_MAIN) != LV_BLEND_MODE_NORMAL) return LV_DESIGN_RES_NOT_COVER;
 802b5b6:	2100      	movs	r1, #0
 802b5b8:	68f8      	ldr	r0, [r7, #12]
 802b5ba:	f7ff fc70 	bl	802ae9e <lv_obj_get_style_image_blend_mode>
 802b5be:	4603      	mov	r3, r0
 802b5c0:	2b00      	cmp	r3, #0
 802b5c2:	d001      	beq.n	802b5c8 <lv_img_design+0x1e4>
 802b5c4:	2302      	movs	r3, #2
 802b5c6:	e3c9      	b.n	802bd5c <lv_img_design+0x978>
#endif

        return LV_DESIGN_RES_COVER;
 802b5c8:	2301      	movs	r3, #1
 802b5ca:	e3c7      	b.n	802bd5c <lv_img_design+0x978>
    }
    else if(mode == LV_DESIGN_DRAW_MAIN) {
 802b5cc:	79fb      	ldrb	r3, [r7, #7]
 802b5ce:	2b00      	cmp	r3, #0
 802b5d0:	f040 82d9 	bne.w	802bb86 <lv_img_design+0x7a2>
        if(ext->h == 0 || ext->w == 0) return true;
 802b5d4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b5d8:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 802b5dc:	2b00      	cmp	r3, #0
 802b5de:	d005      	beq.n	802b5ec <lv_img_design+0x208>
 802b5e0:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b5e4:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 802b5e8:	2b00      	cmp	r3, #0
 802b5ea:	d101      	bne.n	802b5f0 <lv_img_design+0x20c>
 802b5ec:	2301      	movs	r3, #1
 802b5ee:	e3b5      	b.n	802bd5c <lv_img_design+0x978>

        lv_draw_rect_dsc_t bg_dsc;
        lv_draw_rect_dsc_init(&bg_dsc);
 802b5f0:	f107 0334 	add.w	r3, r7, #52	; 0x34
 802b5f4:	4618      	mov	r0, r3
 802b5f6:	f7ec f905 	bl	8017804 <lv_draw_rect_dsc_init>
        lv_obj_init_draw_rect_dsc(img, LV_IMG_PART_MAIN, &bg_dsc);
 802b5fa:	f107 0334 	add.w	r3, r7, #52	; 0x34
 802b5fe:	461a      	mov	r2, r3
 802b600:	2100      	movs	r1, #0
 802b602:	68f8      	ldr	r0, [r7, #12]
 802b604:	f7e0 fafd 	bl	800bc02 <lv_obj_init_draw_rect_dsc>

        /*If the border is drawn later disable loading its properties*/
        if(lv_obj_get_style_border_post(img, LV_OBJ_PART_MAIN)) {
 802b608:	2100      	movs	r1, #0
 802b60a:	68f8      	ldr	r0, [r7, #12]
 802b60c:	f7ff fbfb 	bl	802ae06 <lv_obj_get_style_border_post>
 802b610:	4603      	mov	r3, r0
 802b612:	2b00      	cmp	r3, #0
 802b614:	d002      	beq.n	802b61c <lv_img_design+0x238>
            bg_dsc.border_opa = LV_OPA_TRANSP;
 802b616:	2300      	movs	r3, #0
 802b618:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
        }


        int32_t zoom_final = lv_obj_get_style_transform_zoom(img, LV_IMG_PART_MAIN);
 802b61c:	2100      	movs	r1, #0
 802b61e:	68f8      	ldr	r0, [r7, #12]
 802b620:	f7ff fb8a 	bl	802ad38 <lv_obj_get_style_transform_zoom>
 802b624:	4603      	mov	r3, r0
 802b626:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
        zoom_final = (zoom_final * ext->zoom) >> 8;
 802b62a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b62e:	8a5b      	ldrh	r3, [r3, #18]
 802b630:	461a      	mov	r2, r3
 802b632:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 802b636:	fb02 f303 	mul.w	r3, r2, r3
 802b63a:	121b      	asrs	r3, r3, #8
 802b63c:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4

        int32_t angle_final = lv_obj_get_style_transform_angle(img, LV_IMG_PART_MAIN);
 802b640:	2100      	movs	r1, #0
 802b642:	68f8      	ldr	r0, [r7, #12]
 802b644:	f7ff fb67 	bl	802ad16 <lv_obj_get_style_transform_angle>
 802b648:	4603      	mov	r3, r0
 802b64a:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
        angle_final += ext->angle;
 802b64e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b652:	899b      	ldrh	r3, [r3, #12]
 802b654:	461a      	mov	r2, r3
 802b656:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 802b65a:	4413      	add	r3, r2
 802b65c:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0

        lv_coord_t obj_w = lv_obj_get_width(img);
 802b660:	68f8      	ldr	r0, [r7, #12]
 802b662:	f7df fc3b 	bl	800aedc <lv_obj_get_width>
 802b666:	4603      	mov	r3, r0
 802b668:	f8a7 30de 	strh.w	r3, [r7, #222]	; 0xde
        lv_coord_t obj_h = lv_obj_get_height(img);
 802b66c:	68f8      	ldr	r0, [r7, #12]
 802b66e:	f7df fc59 	bl	800af24 <lv_obj_get_height>
 802b672:	4603      	mov	r3, r0
 802b674:	f8a7 30dc 	strh.w	r3, [r7, #220]	; 0xdc

        lv_area_t bg_coords;
        _lv_img_buf_get_transformed_area(&bg_coords, obj_w, obj_h,
 802b678:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 802b67c:	b21d      	sxth	r5, r3
 802b67e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 802b682:	b29b      	uxth	r3, r3
                                         angle_final, zoom_final, &ext->pivot);
 802b684:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 802b688:	320e      	adds	r2, #14
        _lv_img_buf_get_transformed_area(&bg_coords, obj_w, obj_h,
 802b68a:	f9b7 40dc 	ldrsh.w	r4, [r7, #220]	; 0xdc
 802b68e:	f9b7 10de 	ldrsh.w	r1, [r7, #222]	; 0xde
 802b692:	f107 00b8 	add.w	r0, r7, #184	; 0xb8
 802b696:	9201      	str	r2, [sp, #4]
 802b698:	9300      	str	r3, [sp, #0]
 802b69a:	462b      	mov	r3, r5
 802b69c:	4622      	mov	r2, r4
 802b69e:	f7f0 fa9b 	bl	801bbd8 <_lv_img_buf_get_transformed_area>
        bg_coords.x1 += img->coords.x1;
 802b6a2:	f9b7 30b8 	ldrsh.w	r3, [r7, #184]	; 0xb8
 802b6a6:	b29a      	uxth	r2, r3
 802b6a8:	68fb      	ldr	r3, [r7, #12]
 802b6aa:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802b6ae:	b29b      	uxth	r3, r3
 802b6b0:	4413      	add	r3, r2
 802b6b2:	b29b      	uxth	r3, r3
 802b6b4:	b21b      	sxth	r3, r3
 802b6b6:	f8a7 30b8 	strh.w	r3, [r7, #184]	; 0xb8
        bg_coords.y1 += img->coords.y1;
 802b6ba:	f9b7 30ba 	ldrsh.w	r3, [r7, #186]	; 0xba
 802b6be:	b29a      	uxth	r2, r3
 802b6c0:	68fb      	ldr	r3, [r7, #12]
 802b6c2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802b6c6:	b29b      	uxth	r3, r3
 802b6c8:	4413      	add	r3, r2
 802b6ca:	b29b      	uxth	r3, r3
 802b6cc:	b21b      	sxth	r3, r3
 802b6ce:	f8a7 30ba 	strh.w	r3, [r7, #186]	; 0xba
        bg_coords.x2 += img->coords.x1;
 802b6d2:	f9b7 30bc 	ldrsh.w	r3, [r7, #188]	; 0xbc
 802b6d6:	b29a      	uxth	r2, r3
 802b6d8:	68fb      	ldr	r3, [r7, #12]
 802b6da:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802b6de:	b29b      	uxth	r3, r3
 802b6e0:	4413      	add	r3, r2
 802b6e2:	b29b      	uxth	r3, r3
 802b6e4:	b21b      	sxth	r3, r3
 802b6e6:	f8a7 30bc 	strh.w	r3, [r7, #188]	; 0xbc
        bg_coords.y2 += img->coords.y1;
 802b6ea:	f9b7 30be 	ldrsh.w	r3, [r7, #190]	; 0xbe
 802b6ee:	b29a      	uxth	r2, r3
 802b6f0:	68fb      	ldr	r3, [r7, #12]
 802b6f2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802b6f6:	b29b      	uxth	r3, r3
 802b6f8:	4413      	add	r3, r2
 802b6fa:	b29b      	uxth	r3, r3
 802b6fc:	b21b      	sxth	r3, r3
 802b6fe:	f8a7 30be 	strh.w	r3, [r7, #190]	; 0xbe
        bg_coords.x1 -= lv_obj_get_style_pad_left(img, LV_IMG_PART_MAIN);
 802b702:	2100      	movs	r1, #0
 802b704:	68f8      	ldr	r0, [r7, #12]
 802b706:	f7ff fb4a 	bl	802ad9e <lv_obj_get_style_pad_left>
 802b70a:	4603      	mov	r3, r0
 802b70c:	4619      	mov	r1, r3
 802b70e:	f9b7 30b8 	ldrsh.w	r3, [r7, #184]	; 0xb8
 802b712:	b29a      	uxth	r2, r3
 802b714:	b28b      	uxth	r3, r1
 802b716:	1ad3      	subs	r3, r2, r3
 802b718:	b29b      	uxth	r3, r3
 802b71a:	b21b      	sxth	r3, r3
 802b71c:	f8a7 30b8 	strh.w	r3, [r7, #184]	; 0xb8
        bg_coords.x2 += lv_obj_get_style_pad_right(img, LV_IMG_PART_MAIN);
 802b720:	2100      	movs	r1, #0
 802b722:	68f8      	ldr	r0, [r7, #12]
 802b724:	f7ff fb4c 	bl	802adc0 <lv_obj_get_style_pad_right>
 802b728:	4603      	mov	r3, r0
 802b72a:	4619      	mov	r1, r3
 802b72c:	f9b7 30bc 	ldrsh.w	r3, [r7, #188]	; 0xbc
 802b730:	b29a      	uxth	r2, r3
 802b732:	b28b      	uxth	r3, r1
 802b734:	4413      	add	r3, r2
 802b736:	b29b      	uxth	r3, r3
 802b738:	b21b      	sxth	r3, r3
 802b73a:	f8a7 30bc 	strh.w	r3, [r7, #188]	; 0xbc
        bg_coords.y1 -= lv_obj_get_style_pad_top(img, LV_IMG_PART_MAIN);
 802b73e:	2100      	movs	r1, #0
 802b740:	68f8      	ldr	r0, [r7, #12]
 802b742:	f7ff fb0a 	bl	802ad5a <lv_obj_get_style_pad_top>
 802b746:	4603      	mov	r3, r0
 802b748:	4619      	mov	r1, r3
 802b74a:	f9b7 30ba 	ldrsh.w	r3, [r7, #186]	; 0xba
 802b74e:	b29a      	uxth	r2, r3
 802b750:	b28b      	uxth	r3, r1
 802b752:	1ad3      	subs	r3, r2, r3
 802b754:	b29b      	uxth	r3, r3
 802b756:	b21b      	sxth	r3, r3
 802b758:	f8a7 30ba 	strh.w	r3, [r7, #186]	; 0xba
        bg_coords.y2 += lv_obj_get_style_pad_bottom(img, LV_IMG_PART_MAIN);
 802b75c:	2100      	movs	r1, #0
 802b75e:	68f8      	ldr	r0, [r7, #12]
 802b760:	f7ff fb0c 	bl	802ad7c <lv_obj_get_style_pad_bottom>
 802b764:	4603      	mov	r3, r0
 802b766:	4619      	mov	r1, r3
 802b768:	f9b7 30be 	ldrsh.w	r3, [r7, #190]	; 0xbe
 802b76c:	b29a      	uxth	r2, r3
 802b76e:	b28b      	uxth	r3, r1
 802b770:	4413      	add	r3, r2
 802b772:	b29b      	uxth	r3, r3
 802b774:	b21b      	sxth	r3, r3
 802b776:	f8a7 30be 	strh.w	r3, [r7, #190]	; 0xbe

        lv_draw_rect(&bg_coords, clip_area, &bg_dsc);
 802b77a:	f107 0234 	add.w	r2, r7, #52	; 0x34
 802b77e:	f107 03b8 	add.w	r3, r7, #184	; 0xb8
 802b782:	68b9      	ldr	r1, [r7, #8]
 802b784:	4618      	mov	r0, r3
 802b786:	f7ec f8cb 	bl	8017920 <lv_draw_rect>

        if(zoom_final == 0) return LV_DESIGN_RES_OK;
 802b78a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 802b78e:	2b00      	cmp	r3, #0
 802b790:	d101      	bne.n	802b796 <lv_img_design+0x3b2>
 802b792:	2300      	movs	r3, #0
 802b794:	e2e2      	b.n	802bd5c <lv_img_design+0x978>

        if(lv_obj_get_style_clip_corner(img, LV_OBJ_PART_MAIN)) {
 802b796:	2100      	movs	r1, #0
 802b798:	68f8      	ldr	r0, [r7, #12]
 802b79a:	f7ff faa6 	bl	802acea <lv_obj_get_style_clip_corner>
 802b79e:	4603      	mov	r3, r0
 802b7a0:	2b00      	cmp	r3, #0
 802b7a2:	d01c      	beq.n	802b7de <lv_img_design+0x3fa>
            lv_draw_mask_radius_param_t * mp = _lv_mem_buf_get(sizeof(lv_draw_mask_radius_param_t));
 802b7a4:	201c      	movs	r0, #28
 802b7a6:	f7f5 fb73 	bl	8020e90 <_lv_mem_buf_get>
 802b7aa:	f8c7 00d8 	str.w	r0, [r7, #216]	; 0xd8

            lv_coord_t r = lv_obj_get_style_radius(img, LV_OBJ_PART_MAIN);
 802b7ae:	2100      	movs	r1, #0
 802b7b0:	68f8      	ldr	r0, [r7, #12]
 802b7b2:	f7ff fa89 	bl	802acc8 <lv_obj_get_style_radius>
 802b7b6:	4603      	mov	r3, r0
 802b7b8:	f8a7 30d6 	strh.w	r3, [r7, #214]	; 0xd6

            lv_draw_mask_radius_init(mp, &bg_coords, r, false);
 802b7bc:	f9b7 20d6 	ldrsh.w	r2, [r7, #214]	; 0xd6
 802b7c0:	f107 01b8 	add.w	r1, r7, #184	; 0xb8
 802b7c4:	2300      	movs	r3, #0
 802b7c6:	f8d7 00d8 	ldr.w	r0, [r7, #216]	; 0xd8
 802b7ca:	f7ea fddb 	bl	8016384 <lv_draw_mask_radius_init>
            /*Add the mask and use `img+8` as custom id. Don't use `obj` directly because it might be used by the user*/
            lv_draw_mask_add(mp, img + 8);
 802b7ce:	68fb      	ldr	r3, [r7, #12]
 802b7d0:	f503 7318 	add.w	r3, r3, #608	; 0x260
 802b7d4:	4619      	mov	r1, r3
 802b7d6:	f8d7 00d8 	ldr.w	r0, [r7, #216]	; 0xd8
 802b7da:	f7ea fbb9 	bl	8015f50 <lv_draw_mask_add>
        }

        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_VARIABLE) {
 802b7de:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b7e2:	7d1b      	ldrb	r3, [r3, #20]
 802b7e4:	f003 0303 	and.w	r3, r3, #3
 802b7e8:	b2db      	uxtb	r3, r3
 802b7ea:	2b01      	cmp	r3, #1
 802b7ec:	d008      	beq.n	802b800 <lv_img_design+0x41c>
 802b7ee:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b7f2:	7d1b      	ldrb	r3, [r3, #20]
 802b7f4:	f003 0303 	and.w	r3, r3, #3
 802b7f8:	b2db      	uxtb	r3, r3
 802b7fa:	2b00      	cmp	r3, #0
 802b7fc:	f040 8193 	bne.w	802bb26 <lv_img_design+0x742>
            LV_LOG_TRACE("lv_img_design: start to draw image");

            lv_draw_img_dsc_t img_dsc;
            lv_draw_img_dsc_init(&img_dsc);
 802b800:	f107 03a8 	add.w	r3, r7, #168	; 0xa8
 802b804:	4618      	mov	r0, r3
 802b806:	f7e6 fe01 	bl	801240c <lv_draw_img_dsc_init>
            lv_obj_init_draw_img_dsc(img, LV_IMG_PART_MAIN, &img_dsc);
 802b80a:	f107 03a8 	add.w	r3, r7, #168	; 0xa8
 802b80e:	461a      	mov	r2, r3
 802b810:	2100      	movs	r1, #0
 802b812:	68f8      	ldr	r0, [r7, #12]
 802b814:	f7e0 fcc2 	bl	800c19c <lv_obj_init_draw_img_dsc>

            img_dsc.zoom = zoom_final;
 802b818:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 802b81c:	b29b      	uxth	r3, r3
 802b81e:	f8a7 30b0 	strh.w	r3, [r7, #176]	; 0xb0

            if(img_dsc.zoom == 0) return LV_DESIGN_RES_OK;
 802b822:	f8b7 30b0 	ldrh.w	r3, [r7, #176]	; 0xb0
 802b826:	2b00      	cmp	r3, #0
 802b828:	d101      	bne.n	802b82e <lv_img_design+0x44a>
 802b82a:	2300      	movs	r3, #0
 802b82c:	e296      	b.n	802bd5c <lv_img_design+0x978>

            img_dsc.angle = angle_final;
 802b82e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 802b832:	b29b      	uxth	r3, r3
 802b834:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa

            img_dsc.pivot.x = ext->pivot.x;
 802b838:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b83c:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 802b840:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac
            img_dsc.pivot.y = ext->pivot.y;
 802b844:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b848:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802b84c:	f8a7 30ae 	strh.w	r3, [r7, #174]	; 0xae
            img_dsc.antialias = ext->antialias;
 802b850:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b854:	7d5b      	ldrb	r3, [r3, #21]
 802b856:	f3c3 0300 	ubfx	r3, r3, #0, #1
 802b85a:	b2da      	uxtb	r2, r3
 802b85c:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 802b860:	f362 0300 	bfi	r3, r2, #0, #1
 802b864:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7

            lv_coord_t zoomed_src_w = (int32_t)((int32_t)ext->w * zoom_final) >> 8;
 802b868:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b86c:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 802b870:	461a      	mov	r2, r3
 802b872:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 802b876:	fb02 f303 	mul.w	r3, r2, r3
 802b87a:	121b      	asrs	r3, r3, #8
 802b87c:	f8a7 30d4 	strh.w	r3, [r7, #212]	; 0xd4
            if(zoomed_src_w <= 0) return LV_DESIGN_RES_OK;
 802b880:	f9b7 30d4 	ldrsh.w	r3, [r7, #212]	; 0xd4
 802b884:	2b00      	cmp	r3, #0
 802b886:	dc01      	bgt.n	802b88c <lv_img_design+0x4a8>
 802b888:	2300      	movs	r3, #0
 802b88a:	e14b      	b.n	802bb24 <lv_img_design+0x740>
            lv_coord_t zoomed_src_h = (int32_t)((int32_t)ext->h * zoom_final) >> 8;
 802b88c:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b890:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 802b894:	461a      	mov	r2, r3
 802b896:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 802b89a:	fb02 f303 	mul.w	r3, r2, r3
 802b89e:	121b      	asrs	r3, r3, #8
 802b8a0:	f8a7 30d2 	strh.w	r3, [r7, #210]	; 0xd2
            if(zoomed_src_h <= 0) return LV_DESIGN_RES_OK;
 802b8a4:	f9b7 30d2 	ldrsh.w	r3, [r7, #210]	; 0xd2
 802b8a8:	2b00      	cmp	r3, #0
 802b8aa:	dc01      	bgt.n	802b8b0 <lv_img_design+0x4cc>
 802b8ac:	2300      	movs	r3, #0
 802b8ae:	e139      	b.n	802bb24 <lv_img_design+0x740>
            lv_area_t zommed_coords;
            lv_obj_get_coords(img, &zommed_coords);
 802b8b0:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 802b8b4:	4619      	mov	r1, r3
 802b8b6:	68f8      	ldr	r0, [r7, #12]
 802b8b8:	f7df fa80 	bl	800adbc <lv_obj_get_coords>

            zommed_coords.x1 += (int32_t)((int32_t)ext->offset.x * zoom_final) >> 8;
 802b8bc:	f9b7 30a0 	ldrsh.w	r3, [r7, #160]	; 0xa0
 802b8c0:	b29a      	uxth	r2, r3
 802b8c2:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b8c6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 802b8ca:	4619      	mov	r1, r3
 802b8cc:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 802b8d0:	fb01 f303 	mul.w	r3, r1, r3
 802b8d4:	121b      	asrs	r3, r3, #8
 802b8d6:	b29b      	uxth	r3, r3
 802b8d8:	4413      	add	r3, r2
 802b8da:	b29b      	uxth	r3, r3
 802b8dc:	b21b      	sxth	r3, r3
 802b8de:	f8a7 30a0 	strh.w	r3, [r7, #160]	; 0xa0
            zommed_coords.y1 += (int32_t)((int32_t)ext->offset.y * zoom_final) >> 8;
 802b8e2:	f9b7 30a2 	ldrsh.w	r3, [r7, #162]	; 0xa2
 802b8e6:	b29a      	uxth	r2, r3
 802b8e8:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b8ec:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 802b8f0:	4619      	mov	r1, r3
 802b8f2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 802b8f6:	fb01 f303 	mul.w	r3, r1, r3
 802b8fa:	121b      	asrs	r3, r3, #8
 802b8fc:	b29b      	uxth	r3, r3
 802b8fe:	4413      	add	r3, r2
 802b900:	b29b      	uxth	r3, r3
 802b902:	b21b      	sxth	r3, r3
 802b904:	f8a7 30a2 	strh.w	r3, [r7, #162]	; 0xa2
            zommed_coords.x2 = zommed_coords.x1 + ((int32_t)((int32_t)(obj_w - 1) * zoom_final) >> 8);
 802b908:	f9b7 30a0 	ldrsh.w	r3, [r7, #160]	; 0xa0
 802b90c:	b29a      	uxth	r2, r3
 802b90e:	f9b7 30de 	ldrsh.w	r3, [r7, #222]	; 0xde
 802b912:	3b01      	subs	r3, #1
 802b914:	f8d7 10e4 	ldr.w	r1, [r7, #228]	; 0xe4
 802b918:	fb01 f303 	mul.w	r3, r1, r3
 802b91c:	121b      	asrs	r3, r3, #8
 802b91e:	b29b      	uxth	r3, r3
 802b920:	4413      	add	r3, r2
 802b922:	b29b      	uxth	r3, r3
 802b924:	b21b      	sxth	r3, r3
 802b926:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
            zommed_coords.y2 = zommed_coords.y1 + ((int32_t)((int32_t)(obj_h - 1) * zoom_final) >> 8);
 802b92a:	f9b7 30a2 	ldrsh.w	r3, [r7, #162]	; 0xa2
 802b92e:	b29a      	uxth	r2, r3
 802b930:	f9b7 30dc 	ldrsh.w	r3, [r7, #220]	; 0xdc
 802b934:	3b01      	subs	r3, #1
 802b936:	f8d7 10e4 	ldr.w	r1, [r7, #228]	; 0xe4
 802b93a:	fb01 f303 	mul.w	r3, r1, r3
 802b93e:	121b      	asrs	r3, r3, #8
 802b940:	b29b      	uxth	r3, r3
 802b942:	4413      	add	r3, r2
 802b944:	b29b      	uxth	r3, r3
 802b946:	b21b      	sxth	r3, r3
 802b948:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6

            if(zommed_coords.x1 > img->coords.x1) zommed_coords.x1 -= ext->w;
 802b94c:	f9b7 20a0 	ldrsh.w	r2, [r7, #160]	; 0xa0
 802b950:	68fb      	ldr	r3, [r7, #12]
 802b952:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802b956:	429a      	cmp	r2, r3
 802b958:	dd0c      	ble.n	802b974 <lv_img_design+0x590>
 802b95a:	f9b7 30a0 	ldrsh.w	r3, [r7, #160]	; 0xa0
 802b95e:	b29a      	uxth	r2, r3
 802b960:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b964:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 802b968:	b29b      	uxth	r3, r3
 802b96a:	1ad3      	subs	r3, r2, r3
 802b96c:	b29b      	uxth	r3, r3
 802b96e:	b21b      	sxth	r3, r3
 802b970:	f8a7 30a0 	strh.w	r3, [r7, #160]	; 0xa0
            if(zommed_coords.y1 > img->coords.y1) zommed_coords.y1 -= ext->h;
 802b974:	f9b7 20a2 	ldrsh.w	r2, [r7, #162]	; 0xa2
 802b978:	68fb      	ldr	r3, [r7, #12]
 802b97a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802b97e:	429a      	cmp	r2, r3
 802b980:	dd0c      	ble.n	802b99c <lv_img_design+0x5b8>
 802b982:	f9b7 30a2 	ldrsh.w	r3, [r7, #162]	; 0xa2
 802b986:	b29a      	uxth	r2, r3
 802b988:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802b98c:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 802b990:	b29b      	uxth	r3, r3
 802b992:	1ad3      	subs	r3, r2, r3
 802b994:	b29b      	uxth	r3, r3
 802b996:	b21b      	sxth	r3, r3
 802b998:	f8a7 30a2 	strh.w	r3, [r7, #162]	; 0xa2

            lv_area_t clip_real;
            _lv_img_buf_get_transformed_area(&clip_real, lv_obj_get_width(img), lv_obj_get_height(img), angle_final, zoom_final,
 802b99c:	68f8      	ldr	r0, [r7, #12]
 802b99e:	f7df fa9d 	bl	800aedc <lv_obj_get_width>
 802b9a2:	4603      	mov	r3, r0
 802b9a4:	461c      	mov	r4, r3
 802b9a6:	68f8      	ldr	r0, [r7, #12]
 802b9a8:	f7df fabc 	bl	800af24 <lv_obj_get_height>
 802b9ac:	4603      	mov	r3, r0
 802b9ae:	461d      	mov	r5, r3
 802b9b0:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 802b9b4:	b219      	sxth	r1, r3
 802b9b6:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 802b9ba:	b29b      	uxth	r3, r3
                                             &ext->pivot);
 802b9bc:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 802b9c0:	320e      	adds	r2, #14
            _lv_img_buf_get_transformed_area(&clip_real, lv_obj_get_width(img), lv_obj_get_height(img), angle_final, zoom_final,
 802b9c2:	f107 0098 	add.w	r0, r7, #152	; 0x98
 802b9c6:	9201      	str	r2, [sp, #4]
 802b9c8:	9300      	str	r3, [sp, #0]
 802b9ca:	460b      	mov	r3, r1
 802b9cc:	462a      	mov	r2, r5
 802b9ce:	4621      	mov	r1, r4
 802b9d0:	f7f0 f902 	bl	801bbd8 <_lv_img_buf_get_transformed_area>
            clip_real.x1 += img->coords.x1;
 802b9d4:	f9b7 3098 	ldrsh.w	r3, [r7, #152]	; 0x98
 802b9d8:	b29a      	uxth	r2, r3
 802b9da:	68fb      	ldr	r3, [r7, #12]
 802b9dc:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802b9e0:	b29b      	uxth	r3, r3
 802b9e2:	4413      	add	r3, r2
 802b9e4:	b29b      	uxth	r3, r3
 802b9e6:	b21b      	sxth	r3, r3
 802b9e8:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98
            clip_real.x2 += img->coords.x1;
 802b9ec:	f9b7 309c 	ldrsh.w	r3, [r7, #156]	; 0x9c
 802b9f0:	b29a      	uxth	r2, r3
 802b9f2:	68fb      	ldr	r3, [r7, #12]
 802b9f4:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802b9f8:	b29b      	uxth	r3, r3
 802b9fa:	4413      	add	r3, r2
 802b9fc:	b29b      	uxth	r3, r3
 802b9fe:	b21b      	sxth	r3, r3
 802ba00:	f8a7 309c 	strh.w	r3, [r7, #156]	; 0x9c
            clip_real.y1 += img->coords.y1;
 802ba04:	f9b7 309a 	ldrsh.w	r3, [r7, #154]	; 0x9a
 802ba08:	b29a      	uxth	r2, r3
 802ba0a:	68fb      	ldr	r3, [r7, #12]
 802ba0c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802ba10:	b29b      	uxth	r3, r3
 802ba12:	4413      	add	r3, r2
 802ba14:	b29b      	uxth	r3, r3
 802ba16:	b21b      	sxth	r3, r3
 802ba18:	f8a7 309a 	strh.w	r3, [r7, #154]	; 0x9a
            clip_real.y2 += img->coords.y1;
 802ba1c:	f9b7 309e 	ldrsh.w	r3, [r7, #158]	; 0x9e
 802ba20:	b29a      	uxth	r2, r3
 802ba22:	68fb      	ldr	r3, [r7, #12]
 802ba24:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802ba28:	b29b      	uxth	r3, r3
 802ba2a:	4413      	add	r3, r2
 802ba2c:	b29b      	uxth	r3, r3
 802ba2e:	b21b      	sxth	r3, r3
 802ba30:	f8a7 309e 	strh.w	r3, [r7, #158]	; 0x9e

            if(_lv_area_intersect(&clip_real, &clip_real, clip_area) == false) return LV_DESIGN_RES_OK;
 802ba34:	f107 0198 	add.w	r1, r7, #152	; 0x98
 802ba38:	f107 0398 	add.w	r3, r7, #152	; 0x98
 802ba3c:	68ba      	ldr	r2, [r7, #8]
 802ba3e:	4618      	mov	r0, r3
 802ba40:	f7f3 fd14 	bl	801f46c <_lv_area_intersect>
 802ba44:	4603      	mov	r3, r0
 802ba46:	f083 0301 	eor.w	r3, r3, #1
 802ba4a:	b2db      	uxtb	r3, r3
 802ba4c:	2b00      	cmp	r3, #0
 802ba4e:	d001      	beq.n	802ba54 <lv_img_design+0x670>
 802ba50:	2300      	movs	r3, #0
 802ba52:	e067      	b.n	802bb24 <lv_img_design+0x740>

            lv_area_t coords_tmp;
            coords_tmp.y1 = zommed_coords.y1;
 802ba54:	f9b7 30a2 	ldrsh.w	r3, [r7, #162]	; 0xa2
 802ba58:	f8a7 3092 	strh.w	r3, [r7, #146]	; 0x92
            coords_tmp.y2 = zommed_coords.y1 + ext->h - 1;
 802ba5c:	f9b7 30a2 	ldrsh.w	r3, [r7, #162]	; 0xa2
 802ba60:	b29a      	uxth	r2, r3
 802ba62:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802ba66:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 802ba6a:	b29b      	uxth	r3, r3
 802ba6c:	4413      	add	r3, r2
 802ba6e:	b29b      	uxth	r3, r3
 802ba70:	3b01      	subs	r3, #1
 802ba72:	b29b      	uxth	r3, r3
 802ba74:	b21b      	sxth	r3, r3
 802ba76:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96

            for(; coords_tmp.y1 < zommed_coords.y2; coords_tmp.y1 += zoomed_src_h, coords_tmp.y2 += zoomed_src_h) {
 802ba7a:	e04c      	b.n	802bb16 <lv_img_design+0x732>
                coords_tmp.x1 = zommed_coords.x1;
 802ba7c:	f9b7 30a0 	ldrsh.w	r3, [r7, #160]	; 0xa0
 802ba80:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
                coords_tmp.x2 = zommed_coords.x1 + ext->w - 1;
 802ba84:	f9b7 30a0 	ldrsh.w	r3, [r7, #160]	; 0xa0
 802ba88:	b29a      	uxth	r2, r3
 802ba8a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802ba8e:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 802ba92:	b29b      	uxth	r3, r3
 802ba94:	4413      	add	r3, r2
 802ba96:	b29b      	uxth	r3, r3
 802ba98:	3b01      	subs	r3, #1
 802ba9a:	b29b      	uxth	r3, r3
 802ba9c:	b21b      	sxth	r3, r3
 802ba9e:	f8a7 3094 	strh.w	r3, [r7, #148]	; 0x94
                for(; coords_tmp.x1 < zommed_coords.x2; coords_tmp.x1 += zoomed_src_w, coords_tmp.x2 += zoomed_src_w) {
 802baa2:	e01e      	b.n	802bae2 <lv_img_design+0x6fe>
                    lv_draw_img(&coords_tmp, &clip_real, ext->src, &img_dsc);
 802baa4:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802baa8:	681a      	ldr	r2, [r3, #0]
 802baaa:	f107 03a8 	add.w	r3, r7, #168	; 0xa8
 802baae:	f107 0198 	add.w	r1, r7, #152	; 0x98
 802bab2:	f107 0090 	add.w	r0, r7, #144	; 0x90
 802bab6:	f7e6 fcd1 	bl	801245c <lv_draw_img>
                for(; coords_tmp.x1 < zommed_coords.x2; coords_tmp.x1 += zoomed_src_w, coords_tmp.x2 += zoomed_src_w) {
 802baba:	f9b7 3090 	ldrsh.w	r3, [r7, #144]	; 0x90
 802babe:	b29a      	uxth	r2, r3
 802bac0:	f8b7 30d4 	ldrh.w	r3, [r7, #212]	; 0xd4
 802bac4:	4413      	add	r3, r2
 802bac6:	b29b      	uxth	r3, r3
 802bac8:	b21b      	sxth	r3, r3
 802baca:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
 802bace:	f9b7 3094 	ldrsh.w	r3, [r7, #148]	; 0x94
 802bad2:	b29a      	uxth	r2, r3
 802bad4:	f8b7 30d4 	ldrh.w	r3, [r7, #212]	; 0xd4
 802bad8:	4413      	add	r3, r2
 802bada:	b29b      	uxth	r3, r3
 802badc:	b21b      	sxth	r3, r3
 802bade:	f8a7 3094 	strh.w	r3, [r7, #148]	; 0x94
 802bae2:	f9b7 2090 	ldrsh.w	r2, [r7, #144]	; 0x90
 802bae6:	f9b7 30a4 	ldrsh.w	r3, [r7, #164]	; 0xa4
 802baea:	429a      	cmp	r2, r3
 802baec:	dbda      	blt.n	802baa4 <lv_img_design+0x6c0>
            for(; coords_tmp.y1 < zommed_coords.y2; coords_tmp.y1 += zoomed_src_h, coords_tmp.y2 += zoomed_src_h) {
 802baee:	f9b7 3092 	ldrsh.w	r3, [r7, #146]	; 0x92
 802baf2:	b29a      	uxth	r2, r3
 802baf4:	f8b7 30d2 	ldrh.w	r3, [r7, #210]	; 0xd2
 802baf8:	4413      	add	r3, r2
 802bafa:	b29b      	uxth	r3, r3
 802bafc:	b21b      	sxth	r3, r3
 802bafe:	f8a7 3092 	strh.w	r3, [r7, #146]	; 0x92
 802bb02:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 802bb06:	b29a      	uxth	r2, r3
 802bb08:	f8b7 30d2 	ldrh.w	r3, [r7, #210]	; 0xd2
 802bb0c:	4413      	add	r3, r2
 802bb0e:	b29b      	uxth	r3, r3
 802bb10:	b21b      	sxth	r3, r3
 802bb12:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96
 802bb16:	f9b7 2092 	ldrsh.w	r2, [r7, #146]	; 0x92
 802bb1a:	f9b7 30a6 	ldrsh.w	r3, [r7, #166]	; 0xa6
 802bb1e:	429a      	cmp	r2, r3
 802bb20:	dbac      	blt.n	802ba7c <lv_img_design+0x698>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_VARIABLE) {
 802bb22:	e11a      	b.n	802bd5a <lv_img_design+0x976>
        if(ext->h == 0 || ext->w == 0) return true;
 802bb24:	e11a      	b.n	802bd5c <lv_img_design+0x978>
                }
            }
        }
        else if(ext->src_type == LV_IMG_SRC_SYMBOL) {
 802bb26:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802bb2a:	7d1b      	ldrb	r3, [r3, #20]
 802bb2c:	f003 0303 	and.w	r3, r3, #3
 802bb30:	b2db      	uxtb	r3, r3
 802bb32:	2b02      	cmp	r3, #2
 802bb34:	d11e      	bne.n	802bb74 <lv_img_design+0x790>
            LV_LOG_TRACE("lv_img_design: start to draw symbol");
            lv_draw_label_dsc_t label_dsc;
            lv_draw_label_dsc_init(&label_dsc);
 802bb36:	f107 0314 	add.w	r3, r7, #20
 802bb3a:	4618      	mov	r0, r3
 802bb3c:	f7e7 fc0c 	bl	8013358 <lv_draw_label_dsc_init>
            lv_obj_init_draw_label_dsc(img, LV_IMG_PART_MAIN, &label_dsc);
 802bb40:	f107 0314 	add.w	r3, r7, #20
 802bb44:	461a      	mov	r2, r3
 802bb46:	2100      	movs	r1, #0
 802bb48:	68f8      	ldr	r0, [r7, #12]
 802bb4a:	f7e0 faab 	bl	800c0a4 <lv_obj_init_draw_label_dsc>

            label_dsc.color = lv_obj_get_style_image_recolor(img, LV_IMG_PART_MAIN);
 802bb4e:	2100      	movs	r1, #0
 802bb50:	68f8      	ldr	r0, [r7, #12]
 802bb52:	f7ff f9b7 	bl	802aec4 <lv_obj_get_style_image_recolor>
 802bb56:	82b8      	strh	r0, [r7, #20]
            lv_draw_label(&img->coords, clip_area, &label_dsc, ext->src, NULL);
 802bb58:	68fb      	ldr	r3, [r7, #12]
 802bb5a:	f103 0010 	add.w	r0, r3, #16
 802bb5e:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802bb62:	681b      	ldr	r3, [r3, #0]
 802bb64:	f107 0214 	add.w	r2, r7, #20
 802bb68:	2100      	movs	r1, #0
 802bb6a:	9100      	str	r1, [sp, #0]
 802bb6c:	68b9      	ldr	r1, [r7, #8]
 802bb6e:	f7e7 fc31 	bl	80133d4 <lv_draw_label>
 802bb72:	e0f2      	b.n	802bd5a <lv_img_design+0x976>
        }
        else {
            /*Trigger the error handler of image drawer*/
            LV_LOG_WARN("lv_img_design: image source type is unknown");
            lv_draw_img(&img->coords, clip_area, NULL, NULL);
 802bb74:	68fb      	ldr	r3, [r7, #12]
 802bb76:	f103 0010 	add.w	r0, r3, #16
 802bb7a:	2300      	movs	r3, #0
 802bb7c:	2200      	movs	r2, #0
 802bb7e:	68b9      	ldr	r1, [r7, #8]
 802bb80:	f7e6 fc6c 	bl	801245c <lv_draw_img>
 802bb84:	e0e9      	b.n	802bd5a <lv_img_design+0x976>
        }
    }
    else if(mode == LV_DESIGN_DRAW_POST) {
 802bb86:	79fb      	ldrb	r3, [r7, #7]
 802bb88:	2b01      	cmp	r3, #1
 802bb8a:	f040 80e6 	bne.w	802bd5a <lv_img_design+0x976>
        if(lv_obj_get_style_clip_corner(img, LV_OBJ_PART_MAIN)) {
 802bb8e:	2100      	movs	r1, #0
 802bb90:	68f8      	ldr	r0, [r7, #12]
 802bb92:	f7ff f8aa 	bl	802acea <lv_obj_get_style_clip_corner>
 802bb96:	4603      	mov	r3, r0
 802bb98:	2b00      	cmp	r3, #0
 802bb9a:	d00b      	beq.n	802bbb4 <lv_img_design+0x7d0>
            lv_draw_mask_radius_param_t * param = lv_draw_mask_remove_custom(img + 8);
 802bb9c:	68fb      	ldr	r3, [r7, #12]
 802bb9e:	f503 7318 	add.w	r3, r3, #608	; 0x260
 802bba2:	4618      	mov	r0, r3
 802bba4:	f7ea fa72 	bl	801608c <lv_draw_mask_remove_custom>
 802bba8:	f8c7 00f0 	str.w	r0, [r7, #240]	; 0xf0
            _lv_mem_buf_release(param);
 802bbac:	f8d7 00f0 	ldr.w	r0, [r7, #240]	; 0xf0
 802bbb0:	f7f5 fa4e 	bl	8021050 <_lv_mem_buf_release>
        }

        /*If the border is drawn later disable loading other properties*/
        if(lv_obj_get_style_border_post(img, LV_OBJ_PART_MAIN)) {
 802bbb4:	2100      	movs	r1, #0
 802bbb6:	68f8      	ldr	r0, [r7, #12]
 802bbb8:	f7ff f925 	bl	802ae06 <lv_obj_get_style_border_post>
 802bbbc:	4603      	mov	r3, r0
 802bbbe:	2b00      	cmp	r3, #0
 802bbc0:	f000 80cb 	beq.w	802bd5a <lv_img_design+0x976>
            lv_draw_rect_dsc_t draw_dsc;
            lv_draw_rect_dsc_init(&draw_dsc);
 802bbc4:	f107 0334 	add.w	r3, r7, #52	; 0x34
 802bbc8:	4618      	mov	r0, r3
 802bbca:	f7eb fe1b 	bl	8017804 <lv_draw_rect_dsc_init>
            draw_dsc.bg_opa = LV_OPA_TRANSP;
 802bbce:	2300      	movs	r3, #0
 802bbd0:	f887 3040 	strb.w	r3, [r7, #64]	; 0x40
            draw_dsc.pattern_opa = LV_OPA_TRANSP;
 802bbd4:	2300      	movs	r3, #0
 802bbd6:	f887 306a 	strb.w	r3, [r7, #106]	; 0x6a
            draw_dsc.shadow_opa = LV_OPA_TRANSP;
 802bbda:	2300      	movs	r3, #0
 802bbdc:	f887 305e 	strb.w	r3, [r7, #94]	; 0x5e
            lv_obj_init_draw_rect_dsc(img, LV_OBJ_PART_MAIN, &draw_dsc);
 802bbe0:	f107 0334 	add.w	r3, r7, #52	; 0x34
 802bbe4:	461a      	mov	r2, r3
 802bbe6:	2100      	movs	r1, #0
 802bbe8:	68f8      	ldr	r0, [r7, #12]
 802bbea:	f7e0 f80a 	bl	800bc02 <lv_obj_init_draw_rect_dsc>

            int32_t zoom_final = lv_obj_get_style_transform_zoom(img, LV_IMG_PART_MAIN);
 802bbee:	2100      	movs	r1, #0
 802bbf0:	68f8      	ldr	r0, [r7, #12]
 802bbf2:	f7ff f8a1 	bl	802ad38 <lv_obj_get_style_transform_zoom>
 802bbf6:	4603      	mov	r3, r0
 802bbf8:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
            zoom_final = (zoom_final * ext->zoom) >> 8;
 802bbfc:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802bc00:	8a5b      	ldrh	r3, [r3, #18]
 802bc02:	461a      	mov	r2, r3
 802bc04:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 802bc08:	fb02 f303 	mul.w	r3, r2, r3
 802bc0c:	121b      	asrs	r3, r3, #8
 802bc0e:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec

            int32_t angle_final = lv_obj_get_style_transform_angle(img, LV_IMG_PART_MAIN);
 802bc12:	2100      	movs	r1, #0
 802bc14:	68f8      	ldr	r0, [r7, #12]
 802bc16:	f7ff f87e 	bl	802ad16 <lv_obj_get_style_transform_angle>
 802bc1a:	4603      	mov	r3, r0
 802bc1c:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
            angle_final += ext->angle;
 802bc20:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 802bc24:	899b      	ldrh	r3, [r3, #12]
 802bc26:	461a      	mov	r2, r3
 802bc28:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 802bc2c:	4413      	add	r3, r2
 802bc2e:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8

            lv_area_t bg_coords;
            _lv_img_buf_get_transformed_area(&bg_coords, lv_area_get_width(&img->coords), lv_area_get_height(&img->coords),
 802bc32:	68fb      	ldr	r3, [r7, #12]
 802bc34:	3310      	adds	r3, #16
 802bc36:	4618      	mov	r0, r3
 802bc38:	f7ff f818 	bl	802ac6c <lv_area_get_width>
 802bc3c:	4603      	mov	r3, r0
 802bc3e:	461c      	mov	r4, r3
 802bc40:	68fb      	ldr	r3, [r7, #12]
 802bc42:	3310      	adds	r3, #16
 802bc44:	4618      	mov	r0, r3
 802bc46:	f7ff f828 	bl	802ac9a <lv_area_get_height>
 802bc4a:	4603      	mov	r3, r0
 802bc4c:	461d      	mov	r5, r3
 802bc4e:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 802bc52:	b219      	sxth	r1, r3
 802bc54:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 802bc58:	b29b      	uxth	r3, r3
                                             angle_final, zoom_final, &ext->pivot);
 802bc5a:	f8d7 20f4 	ldr.w	r2, [r7, #244]	; 0xf4
 802bc5e:	320e      	adds	r2, #14
            _lv_img_buf_get_transformed_area(&bg_coords, lv_area_get_width(&img->coords), lv_area_get_height(&img->coords),
 802bc60:	f107 0088 	add.w	r0, r7, #136	; 0x88
 802bc64:	9201      	str	r2, [sp, #4]
 802bc66:	9300      	str	r3, [sp, #0]
 802bc68:	460b      	mov	r3, r1
 802bc6a:	462a      	mov	r2, r5
 802bc6c:	4621      	mov	r1, r4
 802bc6e:	f7ef ffb3 	bl	801bbd8 <_lv_img_buf_get_transformed_area>
            bg_coords.x1 += img->coords.x1;
 802bc72:	f9b7 3088 	ldrsh.w	r3, [r7, #136]	; 0x88
 802bc76:	b29a      	uxth	r2, r3
 802bc78:	68fb      	ldr	r3, [r7, #12]
 802bc7a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802bc7e:	b29b      	uxth	r3, r3
 802bc80:	4413      	add	r3, r2
 802bc82:	b29b      	uxth	r3, r3
 802bc84:	b21b      	sxth	r3, r3
 802bc86:	f8a7 3088 	strh.w	r3, [r7, #136]	; 0x88
            bg_coords.y1 += img->coords.y1;
 802bc8a:	f9b7 308a 	ldrsh.w	r3, [r7, #138]	; 0x8a
 802bc8e:	b29a      	uxth	r2, r3
 802bc90:	68fb      	ldr	r3, [r7, #12]
 802bc92:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802bc96:	b29b      	uxth	r3, r3
 802bc98:	4413      	add	r3, r2
 802bc9a:	b29b      	uxth	r3, r3
 802bc9c:	b21b      	sxth	r3, r3
 802bc9e:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a
            bg_coords.x2 += img->coords.x1;
 802bca2:	f9b7 308c 	ldrsh.w	r3, [r7, #140]	; 0x8c
 802bca6:	b29a      	uxth	r2, r3
 802bca8:	68fb      	ldr	r3, [r7, #12]
 802bcaa:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802bcae:	b29b      	uxth	r3, r3
 802bcb0:	4413      	add	r3, r2
 802bcb2:	b29b      	uxth	r3, r3
 802bcb4:	b21b      	sxth	r3, r3
 802bcb6:	f8a7 308c 	strh.w	r3, [r7, #140]	; 0x8c
            bg_coords.y2 += img->coords.y1;
 802bcba:	f9b7 308e 	ldrsh.w	r3, [r7, #142]	; 0x8e
 802bcbe:	b29a      	uxth	r2, r3
 802bcc0:	68fb      	ldr	r3, [r7, #12]
 802bcc2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802bcc6:	b29b      	uxth	r3, r3
 802bcc8:	4413      	add	r3, r2
 802bcca:	b29b      	uxth	r3, r3
 802bccc:	b21b      	sxth	r3, r3
 802bcce:	f8a7 308e 	strh.w	r3, [r7, #142]	; 0x8e
            bg_coords.x1 -= lv_obj_get_style_pad_left(img, LV_IMG_PART_MAIN);
 802bcd2:	2100      	movs	r1, #0
 802bcd4:	68f8      	ldr	r0, [r7, #12]
 802bcd6:	f7ff f862 	bl	802ad9e <lv_obj_get_style_pad_left>
 802bcda:	4603      	mov	r3, r0
 802bcdc:	4619      	mov	r1, r3
 802bcde:	f9b7 3088 	ldrsh.w	r3, [r7, #136]	; 0x88
 802bce2:	b29a      	uxth	r2, r3
 802bce4:	b28b      	uxth	r3, r1
 802bce6:	1ad3      	subs	r3, r2, r3
 802bce8:	b29b      	uxth	r3, r3
 802bcea:	b21b      	sxth	r3, r3
 802bcec:	f8a7 3088 	strh.w	r3, [r7, #136]	; 0x88
            bg_coords.x2 += lv_obj_get_style_pad_right(img, LV_IMG_PART_MAIN);
 802bcf0:	2100      	movs	r1, #0
 802bcf2:	68f8      	ldr	r0, [r7, #12]
 802bcf4:	f7ff f864 	bl	802adc0 <lv_obj_get_style_pad_right>
 802bcf8:	4603      	mov	r3, r0
 802bcfa:	4619      	mov	r1, r3
 802bcfc:	f9b7 308c 	ldrsh.w	r3, [r7, #140]	; 0x8c
 802bd00:	b29a      	uxth	r2, r3
 802bd02:	b28b      	uxth	r3, r1
 802bd04:	4413      	add	r3, r2
 802bd06:	b29b      	uxth	r3, r3
 802bd08:	b21b      	sxth	r3, r3
 802bd0a:	f8a7 308c 	strh.w	r3, [r7, #140]	; 0x8c
            bg_coords.y1 -= lv_obj_get_style_pad_top(img, LV_IMG_PART_MAIN);
 802bd0e:	2100      	movs	r1, #0
 802bd10:	68f8      	ldr	r0, [r7, #12]
 802bd12:	f7ff f822 	bl	802ad5a <lv_obj_get_style_pad_top>
 802bd16:	4603      	mov	r3, r0
 802bd18:	4619      	mov	r1, r3
 802bd1a:	f9b7 308a 	ldrsh.w	r3, [r7, #138]	; 0x8a
 802bd1e:	b29a      	uxth	r2, r3
 802bd20:	b28b      	uxth	r3, r1
 802bd22:	1ad3      	subs	r3, r2, r3
 802bd24:	b29b      	uxth	r3, r3
 802bd26:	b21b      	sxth	r3, r3
 802bd28:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a
            bg_coords.y2 += lv_obj_get_style_pad_bottom(img, LV_IMG_PART_MAIN);
 802bd2c:	2100      	movs	r1, #0
 802bd2e:	68f8      	ldr	r0, [r7, #12]
 802bd30:	f7ff f824 	bl	802ad7c <lv_obj_get_style_pad_bottom>
 802bd34:	4603      	mov	r3, r0
 802bd36:	4619      	mov	r1, r3
 802bd38:	f9b7 308e 	ldrsh.w	r3, [r7, #142]	; 0x8e
 802bd3c:	b29a      	uxth	r2, r3
 802bd3e:	b28b      	uxth	r3, r1
 802bd40:	4413      	add	r3, r2
 802bd42:	b29b      	uxth	r3, r3
 802bd44:	b21b      	sxth	r3, r3
 802bd46:	f8a7 308e 	strh.w	r3, [r7, #142]	; 0x8e

            lv_draw_rect(&img->coords, clip_area, &draw_dsc);
 802bd4a:	68fb      	ldr	r3, [r7, #12]
 802bd4c:	3310      	adds	r3, #16
 802bd4e:	f107 0234 	add.w	r2, r7, #52	; 0x34
 802bd52:	68b9      	ldr	r1, [r7, #8]
 802bd54:	4618      	mov	r0, r3
 802bd56:	f7eb fde3 	bl	8017920 <lv_draw_rect>
        }
    }

    return LV_DESIGN_RES_OK;
 802bd5a:	2300      	movs	r3, #0
}
 802bd5c:	4618      	mov	r0, r3
 802bd5e:	37f8      	adds	r7, #248	; 0xf8
 802bd60:	46bd      	mov	sp, r7
 802bd62:	bdb0      	pop	{r4, r5, r7, pc}

0802bd64 <lv_img_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_img_signal(lv_obj_t * img, lv_signal_t sign, void * param)
{
 802bd64:	b5b0      	push	{r4, r5, r7, lr}
 802bd66:	b096      	sub	sp, #88	; 0x58
 802bd68:	af02      	add	r7, sp, #8
 802bd6a:	60f8      	str	r0, [r7, #12]
 802bd6c:	460b      	mov	r3, r1
 802bd6e:	607a      	str	r2, [r7, #4]
 802bd70:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;
    if(sign == LV_SIGNAL_GET_STYLE) {
 802bd72:	7afb      	ldrb	r3, [r7, #11]
 802bd74:	2b08      	cmp	r3, #8
 802bd76:	d118      	bne.n	802bdaa <lv_img_signal+0x46>

        lv_get_style_info_t * info = param;
 802bd78:	687b      	ldr	r3, [r7, #4]
 802bd7a:	627b      	str	r3, [r7, #36]	; 0x24
        info->result = lv_img_get_style(img, info->part);
 802bd7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802bd7e:	781b      	ldrb	r3, [r3, #0]
 802bd80:	4619      	mov	r1, r3
 802bd82:	68f8      	ldr	r0, [r7, #12]
 802bd84:	f000 f9ea 	bl	802c15c <lv_img_get_style>
 802bd88:	4602      	mov	r2, r0
 802bd8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802bd8c:	605a      	str	r2, [r3, #4]
        if(info->result != NULL) return LV_RES_OK;
 802bd8e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802bd90:	685b      	ldr	r3, [r3, #4]
 802bd92:	2b00      	cmp	r3, #0
 802bd94:	d001      	beq.n	802bd9a <lv_img_signal+0x36>
 802bd96:	2301      	movs	r3, #1
 802bd98:	e1db      	b.n	802c152 <lv_img_signal+0x3ee>
        else return ancestor_signal(img, sign, param);
 802bd9a:	4b8f      	ldr	r3, [pc, #572]	; (802bfd8 <lv_img_signal+0x274>)
 802bd9c:	681b      	ldr	r3, [r3, #0]
 802bd9e:	7af9      	ldrb	r1, [r7, #11]
 802bda0:	687a      	ldr	r2, [r7, #4]
 802bda2:	68f8      	ldr	r0, [r7, #12]
 802bda4:	4798      	blx	r3
 802bda6:	4603      	mov	r3, r0
 802bda8:	e1d3      	b.n	802c152 <lv_img_signal+0x3ee>
    }

    /* Include the ancient signal function */
    res = ancestor_signal(img, sign, param);
 802bdaa:	4b8b      	ldr	r3, [pc, #556]	; (802bfd8 <lv_img_signal+0x274>)
 802bdac:	681b      	ldr	r3, [r3, #0]
 802bdae:	7af9      	ldrb	r1, [r7, #11]
 802bdb0:	687a      	ldr	r2, [r7, #4]
 802bdb2:	68f8      	ldr	r0, [r7, #12]
 802bdb4:	4798      	blx	r3
 802bdb6:	4603      	mov	r3, r0
 802bdb8:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
    if(res != LV_RES_OK) return res;
 802bdbc:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 802bdc0:	2b01      	cmp	r3, #1
 802bdc2:	d002      	beq.n	802bdca <lv_img_signal+0x66>
 802bdc4:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 802bdc8:	e1c3      	b.n	802c152 <lv_img_signal+0x3ee>

    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
 802bdca:	7afb      	ldrb	r3, [r7, #11]
 802bdcc:	2b07      	cmp	r3, #7
 802bdce:	d105      	bne.n	802bddc <lv_img_signal+0x78>
 802bdd0:	4982      	ldr	r1, [pc, #520]	; (802bfdc <lv_img_signal+0x278>)
 802bdd2:	6878      	ldr	r0, [r7, #4]
 802bdd4:	f7df fef3 	bl	800bbbe <lv_obj_handle_get_type_signal>
 802bdd8:	4603      	mov	r3, r0
 802bdda:	e1ba      	b.n	802c152 <lv_img_signal+0x3ee>

    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
 802bddc:	68f8      	ldr	r0, [r7, #12]
 802bdde:	f7df fe37 	bl	800ba50 <lv_obj_get_ext_attr>
 802bde2:	64b8      	str	r0, [r7, #72]	; 0x48
    if(sign == LV_SIGNAL_CLEANUP) {
 802bde4:	7afb      	ldrb	r3, [r7, #11]
 802bde6:	2b00      	cmp	r3, #0
 802bde8:	d11c      	bne.n	802be24 <lv_img_signal+0xc0>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
 802bdea:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802bdec:	7d1b      	ldrb	r3, [r3, #20]
 802bdee:	f003 0303 	and.w	r3, r3, #3
 802bdf2:	b2db      	uxtb	r3, r3
 802bdf4:	2b01      	cmp	r3, #1
 802bdf6:	d007      	beq.n	802be08 <lv_img_signal+0xa4>
 802bdf8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802bdfa:	7d1b      	ldrb	r3, [r3, #20]
 802bdfc:	f003 0303 	and.w	r3, r3, #3
 802be00:	b2db      	uxtb	r3, r3
 802be02:	2b02      	cmp	r3, #2
 802be04:	f040 81a3 	bne.w	802c14e <lv_img_signal+0x3ea>
            lv_mem_free(ext->src);
 802be08:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802be0a:	681b      	ldr	r3, [r3, #0]
 802be0c:	4618      	mov	r0, r3
 802be0e:	f7f4 ff2b 	bl	8020c68 <lv_mem_free>
            ext->src      = NULL;
 802be12:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802be14:	2200      	movs	r2, #0
 802be16:	601a      	str	r2, [r3, #0]
            ext->src_type = LV_IMG_SRC_UNKNOWN;
 802be18:	6cba      	ldr	r2, [r7, #72]	; 0x48
 802be1a:	7d13      	ldrb	r3, [r2, #20]
 802be1c:	f043 0303 	orr.w	r3, r3, #3
 802be20:	7513      	strb	r3, [r2, #20]
 802be22:	e194      	b.n	802c14e <lv_img_signal+0x3ea>
        }
    }
    else if(sign == LV_SIGNAL_STYLE_CHG) {
 802be24:	7afb      	ldrb	r3, [r7, #11]
 802be26:	2b04      	cmp	r3, #4
 802be28:	d10e      	bne.n	802be48 <lv_img_signal+0xe4>
        /*Refresh the file name to refresh the symbol text size*/
        if(ext->src_type == LV_IMG_SRC_SYMBOL) {
 802be2a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802be2c:	7d1b      	ldrb	r3, [r3, #20]
 802be2e:	f003 0303 	and.w	r3, r3, #3
 802be32:	b2db      	uxtb	r3, r3
 802be34:	2b02      	cmp	r3, #2
 802be36:	f040 818a 	bne.w	802c14e <lv_img_signal+0x3ea>
            lv_img_set_src(img, ext->src);
 802be3a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802be3c:	681b      	ldr	r3, [r3, #0]
 802be3e:	4619      	mov	r1, r3
 802be40:	68f8      	ldr	r0, [r7, #12]
 802be42:	f7ff f95b 	bl	802b0fc <lv_img_set_src>
 802be46:	e182      	b.n	802c14e <lv_img_signal+0x3ea>
        }
    }
    else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 802be48:	7afb      	ldrb	r3, [r7, #11]
 802be4a:	2b06      	cmp	r3, #6
 802be4c:	f040 80c8 	bne.w	802bfe0 <lv_img_signal+0x27c>

        lv_style_int_t transf_zoom = lv_obj_get_style_transform_zoom(img, LV_IMG_PART_MAIN);
 802be50:	2100      	movs	r1, #0
 802be52:	68f8      	ldr	r0, [r7, #12]
 802be54:	f7fe ff70 	bl	802ad38 <lv_obj_get_style_transform_zoom>
 802be58:	4603      	mov	r3, r0
 802be5a:	877b      	strh	r3, [r7, #58]	; 0x3a
        transf_zoom = (transf_zoom * ext->zoom) >> 8;
 802be5c:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 802be60:	6cba      	ldr	r2, [r7, #72]	; 0x48
 802be62:	8a52      	ldrh	r2, [r2, #18]
 802be64:	fb02 f303 	mul.w	r3, r2, r3
 802be68:	121b      	asrs	r3, r3, #8
 802be6a:	877b      	strh	r3, [r7, #58]	; 0x3a

        lv_style_int_t transf_angle = lv_obj_get_style_transform_angle(img, LV_IMG_PART_MAIN);
 802be6c:	2100      	movs	r1, #0
 802be6e:	68f8      	ldr	r0, [r7, #12]
 802be70:	f7fe ff51 	bl	802ad16 <lv_obj_get_style_transform_angle>
 802be74:	4603      	mov	r3, r0
 802be76:	873b      	strh	r3, [r7, #56]	; 0x38
        transf_angle += ext->angle;
 802be78:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802be7a:	899a      	ldrh	r2, [r3, #12]
 802be7c:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 802be7e:	4413      	add	r3, r2
 802be80:	b29b      	uxth	r3, r3
 802be82:	873b      	strh	r3, [r7, #56]	; 0x38

        /*If the image has angle provide enough room for the rotated corners */
        if(transf_angle || transf_zoom != LV_IMG_ZOOM_NONE) {
 802be84:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 802be88:	2b00      	cmp	r3, #0
 802be8a:	d104      	bne.n	802be96 <lv_img_signal+0x132>
 802be8c:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 802be90:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802be94:	d05b      	beq.n	802bf4e <lv_img_signal+0x1ea>
            lv_area_t a;
            lv_coord_t w = lv_obj_get_width(img);
 802be96:	68f8      	ldr	r0, [r7, #12]
 802be98:	f7df f820 	bl	800aedc <lv_obj_get_width>
 802be9c:	4603      	mov	r3, r0
 802be9e:	86fb      	strh	r3, [r7, #54]	; 0x36
            lv_coord_t h = lv_obj_get_height(img);
 802bea0:	68f8      	ldr	r0, [r7, #12]
 802bea2:	f7df f83f 	bl	800af24 <lv_obj_get_height>
 802bea6:	4603      	mov	r3, r0
 802bea8:	86bb      	strh	r3, [r7, #52]	; 0x34
            _lv_img_buf_get_transformed_area(&a, w, h, transf_angle, transf_zoom, &ext->pivot);
 802beaa:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 802beac:	6cba      	ldr	r2, [r7, #72]	; 0x48
 802beae:	320e      	adds	r2, #14
 802beb0:	f9b7 5038 	ldrsh.w	r5, [r7, #56]	; 0x38
 802beb4:	f9b7 4034 	ldrsh.w	r4, [r7, #52]	; 0x34
 802beb8:	f9b7 1036 	ldrsh.w	r1, [r7, #54]	; 0x36
 802bebc:	f107 001c 	add.w	r0, r7, #28
 802bec0:	9201      	str	r2, [sp, #4]
 802bec2:	9300      	str	r3, [sp, #0]
 802bec4:	462b      	mov	r3, r5
 802bec6:	4622      	mov	r2, r4
 802bec8:	f7ef fe86 	bl	801bbd8 <_lv_img_buf_get_transformed_area>
            lv_coord_t pad_ori = img->ext_draw_pad;
 802becc:	68fb      	ldr	r3, [r7, #12]
 802bece:	8e5b      	ldrh	r3, [r3, #50]	; 0x32
 802bed0:	867b      	strh	r3, [r7, #50]	; 0x32
            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori - a.x1);
 802bed2:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 802bed6:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 802beda:	1a9b      	subs	r3, r3, r2
 802bedc:	68fa      	ldr	r2, [r7, #12]
 802bede:	f9b2 2032 	ldrsh.w	r2, [r2, #50]	; 0x32
 802bee2:	4293      	cmp	r3, r2
 802bee4:	bfb8      	it	lt
 802bee6:	4613      	movlt	r3, r2
 802bee8:	b21a      	sxth	r2, r3
 802beea:	68fb      	ldr	r3, [r7, #12]
 802beec:	865a      	strh	r2, [r3, #50]	; 0x32
            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori - a.y1);
 802beee:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 802bef2:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 802bef6:	1a9b      	subs	r3, r3, r2
 802bef8:	68fa      	ldr	r2, [r7, #12]
 802befa:	f9b2 2032 	ldrsh.w	r2, [r2, #50]	; 0x32
 802befe:	4293      	cmp	r3, r2
 802bf00:	bfb8      	it	lt
 802bf02:	4613      	movlt	r3, r2
 802bf04:	b21a      	sxth	r2, r3
 802bf06:	68fb      	ldr	r3, [r7, #12]
 802bf08:	865a      	strh	r2, [r3, #50]	; 0x32
            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori + a.x2 - w);
 802bf0a:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 802bf0e:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 802bf12:	441a      	add	r2, r3
 802bf14:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 802bf18:	1ad3      	subs	r3, r2, r3
 802bf1a:	68fa      	ldr	r2, [r7, #12]
 802bf1c:	f9b2 2032 	ldrsh.w	r2, [r2, #50]	; 0x32
 802bf20:	4293      	cmp	r3, r2
 802bf22:	bfb8      	it	lt
 802bf24:	4613      	movlt	r3, r2
 802bf26:	b21a      	sxth	r2, r3
 802bf28:	68fb      	ldr	r3, [r7, #12]
 802bf2a:	865a      	strh	r2, [r3, #50]	; 0x32
            img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, pad_ori + a.y2 - h);
 802bf2c:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 802bf30:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 802bf34:	441a      	add	r2, r3
 802bf36:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 802bf3a:	1ad3      	subs	r3, r2, r3
 802bf3c:	68fa      	ldr	r2, [r7, #12]
 802bf3e:	f9b2 2032 	ldrsh.w	r2, [r2, #50]	; 0x32
 802bf42:	4293      	cmp	r3, r2
 802bf44:	bfb8      	it	lt
 802bf46:	4613      	movlt	r3, r2
 802bf48:	b21a      	sxth	r2, r3
 802bf4a:	68fb      	ldr	r3, [r7, #12]
 802bf4c:	865a      	strh	r2, [r3, #50]	; 0x32
        }

        /*Handle the padding of the background*/
        lv_style_int_t left = lv_obj_get_style_pad_left(img, LV_IMG_PART_MAIN);
 802bf4e:	2100      	movs	r1, #0
 802bf50:	68f8      	ldr	r0, [r7, #12]
 802bf52:	f7fe ff24 	bl	802ad9e <lv_obj_get_style_pad_left>
 802bf56:	4603      	mov	r3, r0
 802bf58:	863b      	strh	r3, [r7, #48]	; 0x30
        lv_style_int_t right = lv_obj_get_style_pad_right(img, LV_IMG_PART_MAIN);
 802bf5a:	2100      	movs	r1, #0
 802bf5c:	68f8      	ldr	r0, [r7, #12]
 802bf5e:	f7fe ff2f 	bl	802adc0 <lv_obj_get_style_pad_right>
 802bf62:	4603      	mov	r3, r0
 802bf64:	85fb      	strh	r3, [r7, #46]	; 0x2e
        lv_style_int_t top = lv_obj_get_style_pad_top(img, LV_IMG_PART_MAIN);
 802bf66:	2100      	movs	r1, #0
 802bf68:	68f8      	ldr	r0, [r7, #12]
 802bf6a:	f7fe fef6 	bl	802ad5a <lv_obj_get_style_pad_top>
 802bf6e:	4603      	mov	r3, r0
 802bf70:	85bb      	strh	r3, [r7, #44]	; 0x2c
        lv_style_int_t bottom = lv_obj_get_style_pad_bottom(img, LV_IMG_PART_MAIN);
 802bf72:	2100      	movs	r1, #0
 802bf74:	68f8      	ldr	r0, [r7, #12]
 802bf76:	f7fe ff01 	bl	802ad7c <lv_obj_get_style_pad_bottom>
 802bf7a:	4603      	mov	r3, r0
 802bf7c:	857b      	strh	r3, [r7, #42]	; 0x2a

        img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, left);
 802bf7e:	68fb      	ldr	r3, [r7, #12]
 802bf80:	f9b3 3032 	ldrsh.w	r3, [r3, #50]	; 0x32
 802bf84:	f9b7 2030 	ldrsh.w	r2, [r7, #48]	; 0x30
 802bf88:	4293      	cmp	r3, r2
 802bf8a:	bfb8      	it	lt
 802bf8c:	4613      	movlt	r3, r2
 802bf8e:	b21a      	sxth	r2, r3
 802bf90:	68fb      	ldr	r3, [r7, #12]
 802bf92:	865a      	strh	r2, [r3, #50]	; 0x32
        img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, right);
 802bf94:	68fb      	ldr	r3, [r7, #12]
 802bf96:	f9b3 3032 	ldrsh.w	r3, [r3, #50]	; 0x32
 802bf9a:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 802bf9e:	4293      	cmp	r3, r2
 802bfa0:	bfb8      	it	lt
 802bfa2:	4613      	movlt	r3, r2
 802bfa4:	b21a      	sxth	r2, r3
 802bfa6:	68fb      	ldr	r3, [r7, #12]
 802bfa8:	865a      	strh	r2, [r3, #50]	; 0x32
        img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, top);
 802bfaa:	68fb      	ldr	r3, [r7, #12]
 802bfac:	f9b3 3032 	ldrsh.w	r3, [r3, #50]	; 0x32
 802bfb0:	f9b7 202c 	ldrsh.w	r2, [r7, #44]	; 0x2c
 802bfb4:	4293      	cmp	r3, r2
 802bfb6:	bfb8      	it	lt
 802bfb8:	4613      	movlt	r3, r2
 802bfba:	b21a      	sxth	r2, r3
 802bfbc:	68fb      	ldr	r3, [r7, #12]
 802bfbe:	865a      	strh	r2, [r3, #50]	; 0x32
        img->ext_draw_pad = LV_MATH_MAX(img->ext_draw_pad, bottom);
 802bfc0:	68fb      	ldr	r3, [r7, #12]
 802bfc2:	f9b3 3032 	ldrsh.w	r3, [r3, #50]	; 0x32
 802bfc6:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 802bfca:	4293      	cmp	r3, r2
 802bfcc:	bfb8      	it	lt
 802bfce:	4613      	movlt	r3, r2
 802bfd0:	b21a      	sxth	r2, r3
 802bfd2:	68fb      	ldr	r3, [r7, #12]
 802bfd4:	865a      	strh	r2, [r3, #50]	; 0x32
 802bfd6:	e0ba      	b.n	802c14e <lv_img_signal+0x3ea>
 802bfd8:	20012360 	.word	0x20012360
 802bfdc:	0802e5f0 	.word	0x0802e5f0


    }
    else if(sign == LV_SIGNAL_HIT_TEST) {
 802bfe0:	7afb      	ldrb	r3, [r7, #11]
 802bfe2:	2b0a      	cmp	r3, #10
 802bfe4:	f040 80b3 	bne.w	802c14e <lv_img_signal+0x3ea>
        lv_hit_test_info_t * info = param;
 802bfe8:	687b      	ldr	r3, [r7, #4]
 802bfea:	647b      	str	r3, [r7, #68]	; 0x44
        lv_style_int_t zoom = lv_obj_get_style_transform_zoom(img, LV_IMG_PART_MAIN);
 802bfec:	2100      	movs	r1, #0
 802bfee:	68f8      	ldr	r0, [r7, #12]
 802bff0:	f7fe fea2 	bl	802ad38 <lv_obj_get_style_transform_zoom>
 802bff4:	4603      	mov	r3, r0
 802bff6:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
        zoom = (zoom * ext->zoom) >> 8;
 802bffa:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 802bffe:	6cba      	ldr	r2, [r7, #72]	; 0x48
 802c000:	8a52      	ldrh	r2, [r2, #18]
 802c002:	fb02 f303 	mul.w	r3, r2, r3
 802c006:	121b      	asrs	r3, r3, #8
 802c008:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42

        lv_style_int_t angle = lv_obj_get_style_transform_angle(img, LV_IMG_PART_MAIN);
 802c00c:	2100      	movs	r1, #0
 802c00e:	68f8      	ldr	r0, [r7, #12]
 802c010:	f7fe fe81 	bl	802ad16 <lv_obj_get_style_transform_angle>
 802c014:	4603      	mov	r3, r0
 802c016:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
        angle += ext->angle;
 802c01a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802c01c:	899a      	ldrh	r2, [r3, #12]
 802c01e:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 802c022:	4413      	add	r3, r2
 802c024:	b29b      	uxth	r3, r3
 802c026:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40

        /* If the object is exactly image sized (not cropped, not mosaic) and transformed
         * perform hit test on it's transformed area */
        if(ext->w == lv_obj_get_width(img) && ext->h == lv_obj_get_height(img) &&
 802c02a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802c02c:	f9b3 4008 	ldrsh.w	r4, [r3, #8]
 802c030:	68f8      	ldr	r0, [r7, #12]
 802c032:	f7de ff53 	bl	800aedc <lv_obj_get_width>
 802c036:	4603      	mov	r3, r0
 802c038:	429c      	cmp	r4, r3
 802c03a:	d17e      	bne.n	802c13a <lv_img_signal+0x3d6>
 802c03c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802c03e:	f9b3 400a 	ldrsh.w	r4, [r3, #10]
 802c042:	68f8      	ldr	r0, [r7, #12]
 802c044:	f7de ff6e 	bl	800af24 <lv_obj_get_height>
 802c048:	4603      	mov	r3, r0
 802c04a:	429c      	cmp	r4, r3
 802c04c:	d175      	bne.n	802c13a <lv_img_signal+0x3d6>
 802c04e:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 802c052:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 802c056:	d11b      	bne.n	802c090 <lv_img_signal+0x32c>
           (zoom != LV_IMG_ZOOM_NONE || angle != 0 || ext->pivot.x != ext->w / 2 || ext->pivot.y != ext->h / 2)) {
 802c058:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 802c05c:	2b00      	cmp	r3, #0
 802c05e:	d117      	bne.n	802c090 <lv_img_signal+0x32c>
 802c060:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802c062:	f9b3 200e 	ldrsh.w	r2, [r3, #14]
 802c066:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802c068:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 802c06c:	0fd9      	lsrs	r1, r3, #31
 802c06e:	440b      	add	r3, r1
 802c070:	105b      	asrs	r3, r3, #1
 802c072:	b21b      	sxth	r3, r3
 802c074:	429a      	cmp	r2, r3
 802c076:	d10b      	bne.n	802c090 <lv_img_signal+0x32c>
 802c078:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802c07a:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 802c07e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802c080:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 802c084:	0fd9      	lsrs	r1, r3, #31
 802c086:	440b      	add	r3, r1
 802c088:	105b      	asrs	r3, r3, #1
 802c08a:	b21b      	sxth	r3, r3
 802c08c:	429a      	cmp	r2, r3
 802c08e:	d054      	beq.n	802c13a <lv_img_signal+0x3d6>

            lv_coord_t w = lv_obj_get_width(img);
 802c090:	68f8      	ldr	r0, [r7, #12]
 802c092:	f7de ff23 	bl	800aedc <lv_obj_get_width>
 802c096:	4603      	mov	r3, r0
 802c098:	87fb      	strh	r3, [r7, #62]	; 0x3e
            lv_coord_t h = lv_obj_get_height(img);
 802c09a:	68f8      	ldr	r0, [r7, #12]
 802c09c:	f7de ff42 	bl	800af24 <lv_obj_get_height>
 802c0a0:	4603      	mov	r3, r0
 802c0a2:	87bb      	strh	r3, [r7, #60]	; 0x3c
            lv_area_t coords;
            _lv_img_buf_get_transformed_area(&coords, w, h, angle, zoom, &ext->pivot);
 802c0a4:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 802c0a8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 802c0aa:	320e      	adds	r2, #14
 802c0ac:	f9b7 5040 	ldrsh.w	r5, [r7, #64]	; 0x40
 802c0b0:	f9b7 403c 	ldrsh.w	r4, [r7, #60]	; 0x3c
 802c0b4:	f9b7 103e 	ldrsh.w	r1, [r7, #62]	; 0x3e
 802c0b8:	f107 0014 	add.w	r0, r7, #20
 802c0bc:	9201      	str	r2, [sp, #4]
 802c0be:	9300      	str	r3, [sp, #0]
 802c0c0:	462b      	mov	r3, r5
 802c0c2:	4622      	mov	r2, r4
 802c0c4:	f7ef fd88 	bl	801bbd8 <_lv_img_buf_get_transformed_area>
            coords.x1 += img->coords.x1;
 802c0c8:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 802c0cc:	b29a      	uxth	r2, r3
 802c0ce:	68fb      	ldr	r3, [r7, #12]
 802c0d0:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802c0d4:	b29b      	uxth	r3, r3
 802c0d6:	4413      	add	r3, r2
 802c0d8:	b29b      	uxth	r3, r3
 802c0da:	b21b      	sxth	r3, r3
 802c0dc:	82bb      	strh	r3, [r7, #20]
            coords.y1 += img->coords.y1;
 802c0de:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 802c0e2:	b29a      	uxth	r2, r3
 802c0e4:	68fb      	ldr	r3, [r7, #12]
 802c0e6:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802c0ea:	b29b      	uxth	r3, r3
 802c0ec:	4413      	add	r3, r2
 802c0ee:	b29b      	uxth	r3, r3
 802c0f0:	b21b      	sxth	r3, r3
 802c0f2:	82fb      	strh	r3, [r7, #22]
            coords.x2 += img->coords.x1;
 802c0f4:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 802c0f8:	b29a      	uxth	r2, r3
 802c0fa:	68fb      	ldr	r3, [r7, #12]
 802c0fc:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802c100:	b29b      	uxth	r3, r3
 802c102:	4413      	add	r3, r2
 802c104:	b29b      	uxth	r3, r3
 802c106:	b21b      	sxth	r3, r3
 802c108:	833b      	strh	r3, [r7, #24]
            coords.y2 += img->coords.y1;
 802c10a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 802c10e:	b29a      	uxth	r2, r3
 802c110:	68fb      	ldr	r3, [r7, #12]
 802c112:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802c116:	b29b      	uxth	r3, r3
 802c118:	4413      	add	r3, r2
 802c11a:	b29b      	uxth	r3, r3
 802c11c:	b21b      	sxth	r3, r3
 802c11e:	837b      	strh	r3, [r7, #26]

            info->result = _lv_area_is_point_on(&coords, info->point, 0);
 802c120:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802c122:	6819      	ldr	r1, [r3, #0]
 802c124:	f107 0314 	add.w	r3, r7, #20
 802c128:	2200      	movs	r2, #0
 802c12a:	4618      	mov	r0, r3
 802c12c:	f7f3 fa2b 	bl	801f586 <_lv_area_is_point_on>
 802c130:	4603      	mov	r3, r0
 802c132:	461a      	mov	r2, r3
 802c134:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802c136:	711a      	strb	r2, [r3, #4]
           (zoom != LV_IMG_ZOOM_NONE || angle != 0 || ext->pivot.x != ext->w / 2 || ext->pivot.y != ext->h / 2)) {
 802c138:	e009      	b.n	802c14e <lv_img_signal+0x3ea>
        }
        else
            info->result = lv_obj_is_point_on_coords(img, info->point);
 802c13a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802c13c:	681b      	ldr	r3, [r3, #0]
 802c13e:	4619      	mov	r1, r3
 802c140:	68f8      	ldr	r0, [r7, #12]
 802c142:	f7df fcf3 	bl	800bb2c <lv_obj_is_point_on_coords>
 802c146:	4603      	mov	r3, r0
 802c148:	461a      	mov	r2, r3
 802c14a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802c14c:	711a      	strb	r2, [r3, #4]
    }

    return res;
 802c14e:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
}
 802c152:	4618      	mov	r0, r3
 802c154:	3750      	adds	r7, #80	; 0x50
 802c156:	46bd      	mov	sp, r7
 802c158:	bdb0      	pop	{r4, r5, r7, pc}
 802c15a:	bf00      	nop

0802c15c <lv_img_get_style>:


static lv_style_list_t * lv_img_get_style(lv_obj_t * img, uint8_t type)
{
 802c15c:	b480      	push	{r7}
 802c15e:	b085      	sub	sp, #20
 802c160:	af00      	add	r7, sp, #0
 802c162:	6078      	str	r0, [r7, #4]
 802c164:	460b      	mov	r3, r1
 802c166:	70fb      	strb	r3, [r7, #3]
    lv_style_list_t * style_dsc_p;
    switch(type) {
 802c168:	78fb      	ldrb	r3, [r7, #3]
 802c16a:	2b00      	cmp	r3, #0
 802c16c:	d103      	bne.n	802c176 <lv_img_get_style+0x1a>
        case LV_IMG_PART_MAIN:
            style_dsc_p = &img->style_list;
 802c16e:	687b      	ldr	r3, [r7, #4]
 802c170:	3328      	adds	r3, #40	; 0x28
 802c172:	60fb      	str	r3, [r7, #12]
            break;
 802c174:	e001      	b.n	802c17a <lv_img_get_style+0x1e>
        default:
            style_dsc_p = NULL;
 802c176:	2300      	movs	r3, #0
 802c178:	60fb      	str	r3, [r7, #12]
    }

    return style_dsc_p;
 802c17a:	68fb      	ldr	r3, [r7, #12]
}
 802c17c:	4618      	mov	r0, r3
 802c17e:	3714      	adds	r7, #20
 802c180:	46bd      	mov	sp, r7
 802c182:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c186:	4770      	bx	lr

0802c188 <_lv_memcpy_small>:
{
 802c188:	b480      	push	{r7}
 802c18a:	b087      	sub	sp, #28
 802c18c:	af00      	add	r7, sp, #0
 802c18e:	60f8      	str	r0, [r7, #12]
 802c190:	60b9      	str	r1, [r7, #8]
 802c192:	607a      	str	r2, [r7, #4]
    uint8_t * d8 = (uint8_t *)dst;
 802c194:	68fb      	ldr	r3, [r7, #12]
 802c196:	617b      	str	r3, [r7, #20]
    const uint8_t * s8 = (const uint8_t *)src;
 802c198:	68bb      	ldr	r3, [r7, #8]
 802c19a:	613b      	str	r3, [r7, #16]
    while(len) {
 802c19c:	e00c      	b.n	802c1b8 <_lv_memcpy_small+0x30>
        *d8 = *s8;
 802c19e:	693b      	ldr	r3, [r7, #16]
 802c1a0:	781a      	ldrb	r2, [r3, #0]
 802c1a2:	697b      	ldr	r3, [r7, #20]
 802c1a4:	701a      	strb	r2, [r3, #0]
        d8++;
 802c1a6:	697b      	ldr	r3, [r7, #20]
 802c1a8:	3301      	adds	r3, #1
 802c1aa:	617b      	str	r3, [r7, #20]
        s8++;
 802c1ac:	693b      	ldr	r3, [r7, #16]
 802c1ae:	3301      	adds	r3, #1
 802c1b0:	613b      	str	r3, [r7, #16]
        len--;
 802c1b2:	687b      	ldr	r3, [r7, #4]
 802c1b4:	3b01      	subs	r3, #1
 802c1b6:	607b      	str	r3, [r7, #4]
    while(len) {
 802c1b8:	687b      	ldr	r3, [r7, #4]
 802c1ba:	2b00      	cmp	r3, #0
 802c1bc:	d1ef      	bne.n	802c19e <_lv_memcpy_small+0x16>
    return dst;
 802c1be:	68fb      	ldr	r3, [r7, #12]
}
 802c1c0:	4618      	mov	r0, r3
 802c1c2:	371c      	adds	r7, #28
 802c1c4:	46bd      	mov	sp, r7
 802c1c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c1ca:	4770      	bx	lr

0802c1cc <lv_area_copy>:
{
 802c1cc:	b580      	push	{r7, lr}
 802c1ce:	b082      	sub	sp, #8
 802c1d0:	af00      	add	r7, sp, #0
 802c1d2:	6078      	str	r0, [r7, #4]
 802c1d4:	6039      	str	r1, [r7, #0]
    _lv_memcpy_small(dest, src, sizeof(lv_area_t));
 802c1d6:	2208      	movs	r2, #8
 802c1d8:	6839      	ldr	r1, [r7, #0]
 802c1da:	6878      	ldr	r0, [r7, #4]
 802c1dc:	f7ff ffd4 	bl	802c188 <_lv_memcpy_small>
}
 802c1e0:	bf00      	nop
 802c1e2:	3708      	adds	r7, #8
 802c1e4:	46bd      	mov	sp, r7
 802c1e6:	bd80      	pop	{r7, pc}

0802c1e8 <lv_area_get_width>:
{
 802c1e8:	b480      	push	{r7}
 802c1ea:	b083      	sub	sp, #12
 802c1ec:	af00      	add	r7, sp, #0
 802c1ee:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->x2 - area_p->x1 + 1);
 802c1f0:	687b      	ldr	r3, [r7, #4]
 802c1f2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 802c1f6:	b29a      	uxth	r2, r3
 802c1f8:	687b      	ldr	r3, [r7, #4]
 802c1fa:	f9b3 3000 	ldrsh.w	r3, [r3]
 802c1fe:	b29b      	uxth	r3, r3
 802c200:	1ad3      	subs	r3, r2, r3
 802c202:	b29b      	uxth	r3, r3
 802c204:	3301      	adds	r3, #1
 802c206:	b29b      	uxth	r3, r3
 802c208:	b21b      	sxth	r3, r3
}
 802c20a:	4618      	mov	r0, r3
 802c20c:	370c      	adds	r7, #12
 802c20e:	46bd      	mov	sp, r7
 802c210:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c214:	4770      	bx	lr

0802c216 <lv_area_get_height>:
{
 802c216:	b480      	push	{r7}
 802c218:	b083      	sub	sp, #12
 802c21a:	af00      	add	r7, sp, #0
 802c21c:	6078      	str	r0, [r7, #4]
    return (lv_coord_t)(area_p->y2 - area_p->y1 + 1);
 802c21e:	687b      	ldr	r3, [r7, #4]
 802c220:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 802c224:	b29a      	uxth	r2, r3
 802c226:	687b      	ldr	r3, [r7, #4]
 802c228:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 802c22c:	b29b      	uxth	r3, r3
 802c22e:	1ad3      	subs	r3, r2, r3
 802c230:	b29b      	uxth	r3, r3
 802c232:	3301      	adds	r3, #1
 802c234:	b29b      	uxth	r3, r3
 802c236:	b21b      	sxth	r3, r3
}
 802c238:	4618      	mov	r0, r3
 802c23a:	370c      	adds	r7, #12
 802c23c:	46bd      	mov	sp, r7
 802c23e:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c242:	4770      	bx	lr

0802c244 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline lv_coord_t lv_font_get_line_height(const lv_font_t * font_p)
{
 802c244:	b480      	push	{r7}
 802c246:	b083      	sub	sp, #12
 802c248:	af00      	add	r7, sp, #0
 802c24a:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 802c24c:	687b      	ldr	r3, [r7, #4]
 802c24e:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
}
 802c252:	4618      	mov	r0, r3
 802c254:	370c      	adds	r7, #12
 802c256:	46bd      	mov	sp, r7
 802c258:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c25c:	4770      	bx	lr

0802c25e <lv_anim_set_var>:
 * Set a variable to animate
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param var pointer to a variable to animate
 */
static inline void lv_anim_set_var(lv_anim_t * a, void * var)
{
 802c25e:	b480      	push	{r7}
 802c260:	b083      	sub	sp, #12
 802c262:	af00      	add	r7, sp, #0
 802c264:	6078      	str	r0, [r7, #4]
 802c266:	6039      	str	r1, [r7, #0]
    a->var     = var;
 802c268:	687b      	ldr	r3, [r7, #4]
 802c26a:	683a      	ldr	r2, [r7, #0]
 802c26c:	601a      	str	r2, [r3, #0]
}
 802c26e:	bf00      	nop
 802c270:	370c      	adds	r7, #12
 802c272:	46bd      	mov	sp, r7
 802c274:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c278:	4770      	bx	lr

0802c27a <lv_anim_set_exec_cb>:
 * @param exec_cb a function to execute during animation
 *                LittelvGL's built-in functions can be used.
 *                E.g. lv_obj_set_x
 */
static inline void lv_anim_set_exec_cb(lv_anim_t * a, lv_anim_exec_xcb_t exec_cb)
{
 802c27a:	b480      	push	{r7}
 802c27c:	b083      	sub	sp, #12
 802c27e:	af00      	add	r7, sp, #0
 802c280:	6078      	str	r0, [r7, #4]
 802c282:	6039      	str	r1, [r7, #0]
    a->exec_cb = exec_cb;
 802c284:	687b      	ldr	r3, [r7, #4]
 802c286:	683a      	ldr	r2, [r7, #0]
 802c288:	605a      	str	r2, [r3, #4]
}
 802c28a:	bf00      	nop
 802c28c:	370c      	adds	r7, #12
 802c28e:	46bd      	mov	sp, r7
 802c290:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c294:	4770      	bx	lr

0802c296 <lv_anim_set_time>:
 * Set the duration of an animation
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param duration duration of the animation in milliseconds
 */
static inline void lv_anim_set_time(lv_anim_t * a, uint32_t duration)
{
 802c296:	b480      	push	{r7}
 802c298:	b083      	sub	sp, #12
 802c29a:	af00      	add	r7, sp, #0
 802c29c:	6078      	str	r0, [r7, #4]
 802c29e:	6039      	str	r1, [r7, #0]
    a->time     = duration;
 802c2a0:	683a      	ldr	r2, [r7, #0]
 802c2a2:	687b      	ldr	r3, [r7, #4]
 802c2a4:	625a      	str	r2, [r3, #36]	; 0x24
}
 802c2a6:	bf00      	nop
 802c2a8:	370c      	adds	r7, #12
 802c2aa:	46bd      	mov	sp, r7
 802c2ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c2b0:	4770      	bx	lr

0802c2b2 <lv_anim_set_values>:
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param start the start value
 * @param end the end value
 */
static inline void lv_anim_set_values(lv_anim_t * a, lv_anim_value_t start, lv_anim_value_t end)
{
 802c2b2:	b480      	push	{r7}
 802c2b4:	b083      	sub	sp, #12
 802c2b6:	af00      	add	r7, sp, #0
 802c2b8:	6078      	str	r0, [r7, #4]
 802c2ba:	460b      	mov	r3, r1
 802c2bc:	807b      	strh	r3, [r7, #2]
 802c2be:	4613      	mov	r3, r2
 802c2c0:	803b      	strh	r3, [r7, #0]
    a->start = start;
 802c2c2:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 802c2c6:	687b      	ldr	r3, [r7, #4]
 802c2c8:	619a      	str	r2, [r3, #24]
    a->current = start;
 802c2ca:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 802c2ce:	687b      	ldr	r3, [r7, #4]
 802c2d0:	61da      	str	r2, [r3, #28]
    a->end   = end;
 802c2d2:	f9b7 2000 	ldrsh.w	r2, [r7]
 802c2d6:	687b      	ldr	r3, [r7, #4]
 802c2d8:	621a      	str	r2, [r3, #32]
}
 802c2da:	bf00      	nop
 802c2dc:	370c      	adds	r7, #12
 802c2de:	46bd      	mov	sp, r7
 802c2e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c2e4:	4770      	bx	lr

0802c2e6 <lv_anim_set_playback_time>:
 * Make the animation to play back to when the forward direction is ready
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param time the duration of the playback animation in in milliseconds. 0: disable playback
 */
static inline void lv_anim_set_playback_time(lv_anim_t * a, uint16_t time)
{
 802c2e6:	b480      	push	{r7}
 802c2e8:	b083      	sub	sp, #12
 802c2ea:	af00      	add	r7, sp, #0
 802c2ec:	6078      	str	r0, [r7, #4]
 802c2ee:	460b      	mov	r3, r1
 802c2f0:	807b      	strh	r3, [r7, #2]
    a->playback_time = time;
 802c2f2:	887a      	ldrh	r2, [r7, #2]
 802c2f4:	687b      	ldr	r3, [r7, #4]
 802c2f6:	631a      	str	r2, [r3, #48]	; 0x30
}
 802c2f8:	bf00      	nop
 802c2fa:	370c      	adds	r7, #12
 802c2fc:	46bd      	mov	sp, r7
 802c2fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c302:	4770      	bx	lr

0802c304 <lv_anim_set_playback_delay>:
 * Make the animation to play back to when the forward direction is ready
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param delay delay in milliseconds before starting the playback animation.
 */
static inline void lv_anim_set_playback_delay(lv_anim_t * a, uint16_t delay)
{
 802c304:	b480      	push	{r7}
 802c306:	b083      	sub	sp, #12
 802c308:	af00      	add	r7, sp, #0
 802c30a:	6078      	str	r0, [r7, #4]
 802c30c:	460b      	mov	r3, r1
 802c30e:	807b      	strh	r3, [r7, #2]
    a->playback_delay = delay;
 802c310:	887a      	ldrh	r2, [r7, #2]
 802c312:	687b      	ldr	r3, [r7, #4]
 802c314:	62da      	str	r2, [r3, #44]	; 0x2c
}
 802c316:	bf00      	nop
 802c318:	370c      	adds	r7, #12
 802c31a:	46bd      	mov	sp, r7
 802c31c:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c320:	4770      	bx	lr

0802c322 <lv_anim_set_repeat_count>:
 * Make the animation repeat itself.
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param cnt repeat count or `LV_ANIM_REPEAT_INFINITE` for infinite repetition. 0: to disable repetition.
 */
static inline void lv_anim_set_repeat_count(lv_anim_t * a, uint16_t cnt)
{
 802c322:	b480      	push	{r7}
 802c324:	b083      	sub	sp, #12
 802c326:	af00      	add	r7, sp, #0
 802c328:	6078      	str	r0, [r7, #4]
 802c32a:	460b      	mov	r3, r1
 802c32c:	807b      	strh	r3, [r7, #2]
    a->repeat_cnt       = cnt;
 802c32e:	687b      	ldr	r3, [r7, #4]
 802c330:	887a      	ldrh	r2, [r7, #2]
 802c332:	871a      	strh	r2, [r3, #56]	; 0x38
}
 802c334:	bf00      	nop
 802c336:	370c      	adds	r7, #12
 802c338:	46bd      	mov	sp, r7
 802c33a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c33e:	4770      	bx	lr

0802c340 <lv_anim_set_repeat_delay>:
 * Set a delay before repeating the animation.
 * @param a pointer to an initialized `lv_anim_t` variable
 * @param delay delay in milliseconds before repeating the animation.
 */
static inline void lv_anim_set_repeat_delay(lv_anim_t * a, uint16_t delay)
{
 802c340:	b480      	push	{r7}
 802c342:	b083      	sub	sp, #12
 802c344:	af00      	add	r7, sp, #0
 802c346:	6078      	str	r0, [r7, #4]
 802c348:	460b      	mov	r3, r1
 802c34a:	807b      	strh	r3, [r7, #2]
    a->repeat_delay = delay;
 802c34c:	887a      	ldrh	r2, [r7, #2]
 802c34e:	687b      	ldr	r3, [r7, #4]
 802c350:	635a      	str	r2, [r3, #52]	; 0x34
}
 802c352:	bf00      	nop
 802c354:	370c      	adds	r7, #12
 802c356:	46bd      	mov	sp, r7
 802c358:	f85d 7b04 	ldr.w	r7, [sp], #4
 802c35c:	4770      	bx	lr

0802c35e <lv_obj_get_style_transform_width>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_WIDTH, transform_width, lv_style_int_t, _int, scalar)
 802c35e:	b580      	push	{r7, lr}
 802c360:	b082      	sub	sp, #8
 802c362:	af00      	add	r7, sp, #0
 802c364:	6078      	str	r0, [r7, #4]
 802c366:	460b      	mov	r3, r1
 802c368:	70fb      	strb	r3, [r7, #3]
 802c36a:	78fb      	ldrb	r3, [r7, #3]
 802c36c:	2204      	movs	r2, #4
 802c36e:	4619      	mov	r1, r3
 802c370:	6878      	ldr	r0, [r7, #4]
 802c372:	f7de fe7d 	bl	800b070 <_lv_obj_get_style_int>
 802c376:	4603      	mov	r3, r0
 802c378:	4618      	mov	r0, r3
 802c37a:	3708      	adds	r7, #8
 802c37c:	46bd      	mov	sp, r7
 802c37e:	bd80      	pop	{r7, pc}

0802c380 <lv_obj_get_style_transform_height>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TRANSFORM_HEIGHT, transform_height, lv_style_int_t, _int, scalar)
 802c380:	b580      	push	{r7, lr}
 802c382:	b082      	sub	sp, #8
 802c384:	af00      	add	r7, sp, #0
 802c386:	6078      	str	r0, [r7, #4]
 802c388:	460b      	mov	r3, r1
 802c38a:	70fb      	strb	r3, [r7, #3]
 802c38c:	78fb      	ldrb	r3, [r7, #3]
 802c38e:	2205      	movs	r2, #5
 802c390:	4619      	mov	r1, r3
 802c392:	6878      	ldr	r0, [r7, #4]
 802c394:	f7de fe6c 	bl	800b070 <_lv_obj_get_style_int>
 802c398:	4603      	mov	r3, r0
 802c39a:	4618      	mov	r0, r3
 802c39c:	3708      	adds	r7, #8
 802c39e:	46bd      	mov	sp, r7
 802c3a0:	bd80      	pop	{r7, pc}

0802c3a2 <lv_obj_get_style_pad_top>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_TOP, pad_top, lv_style_int_t, _int, scalar)
 802c3a2:	b580      	push	{r7, lr}
 802c3a4:	b082      	sub	sp, #8
 802c3a6:	af00      	add	r7, sp, #0
 802c3a8:	6078      	str	r0, [r7, #4]
 802c3aa:	460b      	mov	r3, r1
 802c3ac:	70fb      	strb	r3, [r7, #3]
 802c3ae:	78fb      	ldrb	r3, [r7, #3]
 802c3b0:	2210      	movs	r2, #16
 802c3b2:	4619      	mov	r1, r3
 802c3b4:	6878      	ldr	r0, [r7, #4]
 802c3b6:	f7de fe5b 	bl	800b070 <_lv_obj_get_style_int>
 802c3ba:	4603      	mov	r3, r0
 802c3bc:	4618      	mov	r0, r3
 802c3be:	3708      	adds	r7, #8
 802c3c0:	46bd      	mov	sp, r7
 802c3c2:	bd80      	pop	{r7, pc}

0802c3c4 <lv_obj_get_style_pad_bottom>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_BOTTOM, pad_bottom, lv_style_int_t, _int, scalar)
 802c3c4:	b580      	push	{r7, lr}
 802c3c6:	b082      	sub	sp, #8
 802c3c8:	af00      	add	r7, sp, #0
 802c3ca:	6078      	str	r0, [r7, #4]
 802c3cc:	460b      	mov	r3, r1
 802c3ce:	70fb      	strb	r3, [r7, #3]
 802c3d0:	78fb      	ldrb	r3, [r7, #3]
 802c3d2:	2211      	movs	r2, #17
 802c3d4:	4619      	mov	r1, r3
 802c3d6:	6878      	ldr	r0, [r7, #4]
 802c3d8:	f7de fe4a 	bl	800b070 <_lv_obj_get_style_int>
 802c3dc:	4603      	mov	r3, r0
 802c3de:	4618      	mov	r0, r3
 802c3e0:	3708      	adds	r7, #8
 802c3e2:	46bd      	mov	sp, r7
 802c3e4:	bd80      	pop	{r7, pc}

0802c3e6 <lv_obj_get_style_pad_left>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_LEFT, pad_left, lv_style_int_t, _int, scalar)
 802c3e6:	b580      	push	{r7, lr}
 802c3e8:	b082      	sub	sp, #8
 802c3ea:	af00      	add	r7, sp, #0
 802c3ec:	6078      	str	r0, [r7, #4]
 802c3ee:	460b      	mov	r3, r1
 802c3f0:	70fb      	strb	r3, [r7, #3]
 802c3f2:	78fb      	ldrb	r3, [r7, #3]
 802c3f4:	2212      	movs	r2, #18
 802c3f6:	4619      	mov	r1, r3
 802c3f8:	6878      	ldr	r0, [r7, #4]
 802c3fa:	f7de fe39 	bl	800b070 <_lv_obj_get_style_int>
 802c3fe:	4603      	mov	r3, r0
 802c400:	4618      	mov	r0, r3
 802c402:	3708      	adds	r7, #8
 802c404:	46bd      	mov	sp, r7
 802c406:	bd80      	pop	{r7, pc}

0802c408 <lv_obj_get_style_pad_right>:
_LV_OBJ_STYLE_SET_GET_DECLARE(PAD_RIGHT, pad_right, lv_style_int_t, _int, scalar)
 802c408:	b580      	push	{r7, lr}
 802c40a:	b082      	sub	sp, #8
 802c40c:	af00      	add	r7, sp, #0
 802c40e:	6078      	str	r0, [r7, #4]
 802c410:	460b      	mov	r3, r1
 802c412:	70fb      	strb	r3, [r7, #3]
 802c414:	78fb      	ldrb	r3, [r7, #3]
 802c416:	2213      	movs	r2, #19
 802c418:	4619      	mov	r1, r3
 802c41a:	6878      	ldr	r0, [r7, #4]
 802c41c:	f7de fe28 	bl	800b070 <_lv_obj_get_style_int>
 802c420:	4603      	mov	r3, r0
 802c422:	4618      	mov	r0, r3
 802c424:	3708      	adds	r7, #8
 802c426:	46bd      	mov	sp, r7
 802c428:	bd80      	pop	{r7, pc}

0802c42a <lv_obj_get_style_text_letter_space>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LETTER_SPACE, text_letter_space, lv_style_int_t, _int, scalar)
 802c42a:	b580      	push	{r7, lr}
 802c42c:	b082      	sub	sp, #8
 802c42e:	af00      	add	r7, sp, #0
 802c430:	6078      	str	r0, [r7, #4]
 802c432:	460b      	mov	r3, r1
 802c434:	70fb      	strb	r3, [r7, #3]
 802c436:	78fb      	ldrb	r3, [r7, #3]
 802c438:	f248 0280 	movw	r2, #32896	; 0x8080
 802c43c:	4619      	mov	r1, r3
 802c43e:	6878      	ldr	r0, [r7, #4]
 802c440:	f7de fe16 	bl	800b070 <_lv_obj_get_style_int>
 802c444:	4603      	mov	r3, r0
 802c446:	4618      	mov	r0, r3
 802c448:	3708      	adds	r7, #8
 802c44a:	46bd      	mov	sp, r7
 802c44c:	bd80      	pop	{r7, pc}

0802c44e <lv_obj_get_style_text_line_space>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_LINE_SPACE, text_line_space, lv_style_int_t, _int, scalar)
 802c44e:	b580      	push	{r7, lr}
 802c450:	b082      	sub	sp, #8
 802c452:	af00      	add	r7, sp, #0
 802c454:	6078      	str	r0, [r7, #4]
 802c456:	460b      	mov	r3, r1
 802c458:	70fb      	strb	r3, [r7, #3]
 802c45a:	78fb      	ldrb	r3, [r7, #3]
 802c45c:	f248 0281 	movw	r2, #32897	; 0x8081
 802c460:	4619      	mov	r1, r3
 802c462:	6878      	ldr	r0, [r7, #4]
 802c464:	f7de fe04 	bl	800b070 <_lv_obj_get_style_int>
 802c468:	4603      	mov	r3, r0
 802c46a:	4618      	mov	r0, r3
 802c46c:	3708      	adds	r7, #8
 802c46e:	46bd      	mov	sp, r7
 802c470:	bd80      	pop	{r7, pc}

0802c472 <lv_obj_get_style_text_font>:
_LV_OBJ_STYLE_SET_GET_DECLARE(TEXT_FONT, text_font, const lv_font_t *, _ptr, scalar)
 802c472:	b580      	push	{r7, lr}
 802c474:	b082      	sub	sp, #8
 802c476:	af00      	add	r7, sp, #0
 802c478:	6078      	str	r0, [r7, #4]
 802c47a:	460b      	mov	r3, r1
 802c47c:	70fb      	strb	r3, [r7, #3]
 802c47e:	78fb      	ldrb	r3, [r7, #3]
 802c480:	f248 028e 	movw	r2, #32910	; 0x808e
 802c484:	4619      	mov	r1, r3
 802c486:	6878      	ldr	r0, [r7, #4]
 802c488:	f7df f92a 	bl	800b6e0 <_lv_obj_get_style_ptr>
 802c48c:	4603      	mov	r3, r0
 802c48e:	4618      	mov	r0, r3
 802c490:	3708      	adds	r7, #8
 802c492:	46bd      	mov	sp, r7
 802c494:	bd80      	pop	{r7, pc}
	...

0802c498 <lv_label_create>:
 * @param par pointer to an object, it will be the parent of the new label
 * @param copy pointer to a label object, if not NULL then the new object will be copied from it
 * @return pointer to the created button
 */
lv_obj_t * lv_label_create(lv_obj_t * par, const lv_obj_t * copy)
{
 802c498:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802c49c:	b087      	sub	sp, #28
 802c49e:	af00      	add	r7, sp, #0
 802c4a0:	6078      	str	r0, [r7, #4]
 802c4a2:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("label create started");

    /*Create a basic object*/
    lv_obj_t * new_label = lv_obj_create(par, copy);
 802c4a4:	6839      	ldr	r1, [r7, #0]
 802c4a6:	6878      	ldr	r0, [r7, #4]
 802c4a8:	f7dc ff42 	bl	8009330 <lv_obj_create>
 802c4ac:	6178      	str	r0, [r7, #20]
    LV_ASSERT_MEM(new_label);
 802c4ae:	6978      	ldr	r0, [r7, #20]
 802c4b0:	f7f3 fe1e 	bl	80200f0 <lv_debug_check_null>
 802c4b4:	4603      	mov	r3, r0
 802c4b6:	f083 0301 	eor.w	r3, r3, #1
 802c4ba:	b2db      	uxtb	r3, r3
 802c4bc:	2b00      	cmp	r3, #0
 802c4be:	d009      	beq.n	802c4d4 <lv_label_create+0x3c>
 802c4c0:	697b      	ldr	r3, [r7, #20]
 802c4c2:	2200      	movs	r2, #0
 802c4c4:	469a      	mov	sl, r3
 802c4c6:	4693      	mov	fp, r2
 802c4c8:	4652      	mov	r2, sl
 802c4ca:	465b      	mov	r3, fp
 802c4cc:	4896      	ldr	r0, [pc, #600]	; (802c728 <lv_label_create+0x290>)
 802c4ce:	f7f3 fe1f 	bl	8020110 <lv_debug_log_error>
 802c4d2:	e7fe      	b.n	802c4d2 <lv_label_create+0x3a>
    if(new_label == NULL) return NULL;
 802c4d4:	697b      	ldr	r3, [r7, #20]
 802c4d6:	2b00      	cmp	r3, #0
 802c4d8:	d101      	bne.n	802c4de <lv_label_create+0x46>
 802c4da:	2300      	movs	r3, #0
 802c4dc:	e11f      	b.n	802c71e <lv_label_create+0x286>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_label);
 802c4de:	4b93      	ldr	r3, [pc, #588]	; (802c72c <lv_label_create+0x294>)
 802c4e0:	681b      	ldr	r3, [r3, #0]
 802c4e2:	2b00      	cmp	r3, #0
 802c4e4:	d105      	bne.n	802c4f2 <lv_label_create+0x5a>
 802c4e6:	6978      	ldr	r0, [r7, #20]
 802c4e8:	f7df fa72 	bl	800b9d0 <lv_obj_get_signal_cb>
 802c4ec:	4603      	mov	r3, r0
 802c4ee:	4a8f      	ldr	r2, [pc, #572]	; (802c72c <lv_label_create+0x294>)
 802c4f0:	6013      	str	r3, [r2, #0]

    /*Extend the basic object to a label object*/
    lv_obj_allocate_ext_attr(new_label, sizeof(lv_label_ext_t));
 802c4f2:	2114      	movs	r1, #20
 802c4f4:	6978      	ldr	r0, [r7, #20]
 802c4f6:	f7de fb3d 	bl	800ab74 <lv_obj_allocate_ext_attr>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(new_label);
 802c4fa:	6978      	ldr	r0, [r7, #20]
 802c4fc:	f7df faa8 	bl	800ba50 <lv_obj_get_ext_attr>
 802c500:	6138      	str	r0, [r7, #16]
    LV_ASSERT_MEM(ext);
 802c502:	6938      	ldr	r0, [r7, #16]
 802c504:	f7f3 fdf4 	bl	80200f0 <lv_debug_check_null>
 802c508:	4603      	mov	r3, r0
 802c50a:	f083 0301 	eor.w	r3, r3, #1
 802c50e:	b2db      	uxtb	r3, r3
 802c510:	2b00      	cmp	r3, #0
 802c512:	d009      	beq.n	802c528 <lv_label_create+0x90>
 802c514:	693b      	ldr	r3, [r7, #16]
 802c516:	2200      	movs	r2, #0
 802c518:	4698      	mov	r8, r3
 802c51a:	4691      	mov	r9, r2
 802c51c:	4642      	mov	r2, r8
 802c51e:	464b      	mov	r3, r9
 802c520:	4881      	ldr	r0, [pc, #516]	; (802c728 <lv_label_create+0x290>)
 802c522:	f7f3 fdf5 	bl	8020110 <lv_debug_log_error>
 802c526:	e7fe      	b.n	802c526 <lv_label_create+0x8e>
    if(ext == NULL) {
 802c528:	693b      	ldr	r3, [r7, #16]
 802c52a:	2b00      	cmp	r3, #0
 802c52c:	d104      	bne.n	802c538 <lv_label_create+0xa0>
        lv_obj_del(new_label);
 802c52e:	6978      	ldr	r0, [r7, #20]
 802c530:	f7dd f9de 	bl	80098f0 <lv_obj_del>
        return NULL;
 802c534:	2300      	movs	r3, #0
 802c536:	e0f2      	b.n	802c71e <lv_label_create+0x286>
    }

    ext->text       = NULL;
 802c538:	693b      	ldr	r3, [r7, #16]
 802c53a:	2200      	movs	r2, #0
 802c53c:	601a      	str	r2, [r3, #0]
    ext->static_txt = 0;
 802c53e:	693a      	ldr	r2, [r7, #16]
 802c540:	7c93      	ldrb	r3, [r2, #18]
 802c542:	f36f 03c3 	bfc	r3, #3, #1
 802c546:	7493      	strb	r3, [r2, #18]
    ext->recolor    = 0;
 802c548:	693a      	ldr	r2, [r7, #16]
 802c54a:	7c93      	ldrb	r3, [r2, #18]
 802c54c:	f36f 1386 	bfc	r3, #6, #1
 802c550:	7493      	strb	r3, [r2, #18]
    ext->align      = LV_LABEL_ALIGN_AUTO;
 802c552:	693a      	ldr	r2, [r7, #16]
 802c554:	7c93      	ldrb	r3, [r2, #18]
 802c556:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 802c55a:	7493      	strb	r3, [r2, #18]
    ext->dot_end    = LV_LABEL_DOT_END_INV;
 802c55c:	693b      	ldr	r3, [r7, #16]
 802c55e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 802c562:	609a      	str	r2, [r3, #8]
    ext->long_mode  = LV_LABEL_LONG_EXPAND;
 802c564:	693a      	ldr	r2, [r7, #16]
 802c566:	7c93      	ldrb	r3, [r2, #18]
 802c568:	f36f 0302 	bfc	r3, #0, #3
 802c56c:	7493      	strb	r3, [r2, #18]
#if LV_USE_ANIMATION
    ext->anim_speed = LV_LABEL_DEF_SCROLL_SPEED;
 802c56e:	693b      	ldr	r3, [r7, #16]
 802c570:	2219      	movs	r2, #25
 802c572:	819a      	strh	r2, [r3, #12]
#endif
    ext->offset.x = 0;
 802c574:	693b      	ldr	r3, [r7, #16]
 802c576:	2200      	movs	r2, #0
 802c578:	81da      	strh	r2, [r3, #14]
    ext->offset.y = 0;
 802c57a:	693b      	ldr	r3, [r7, #16]
 802c57c:	2200      	movs	r2, #0
 802c57e:	821a      	strh	r2, [r3, #16]

#if LV_LABEL_TEXT_SEL
    ext->sel_start = LV_DRAW_LABEL_NO_TXT_SEL;
    ext->sel_end   = LV_DRAW_LABEL_NO_TXT_SEL;
#endif
    ext->dot.tmp_ptr   = NULL;
 802c580:	693b      	ldr	r3, [r7, #16]
 802c582:	2200      	movs	r2, #0
 802c584:	605a      	str	r2, [r3, #4]
    ext->dot_tmp_alloc = 0;
 802c586:	693a      	ldr	r2, [r7, #16]
 802c588:	7cd3      	ldrb	r3, [r2, #19]
 802c58a:	f36f 0300 	bfc	r3, #0, #1
 802c58e:	74d3      	strb	r3, [r2, #19]


    lv_obj_set_design_cb(new_label, lv_label_design);
 802c590:	4967      	ldr	r1, [pc, #412]	; (802c730 <lv_label_create+0x298>)
 802c592:	6978      	ldr	r0, [r7, #20]
 802c594:	f7de facc 	bl	800ab30 <lv_obj_set_design_cb>
    lv_obj_set_signal_cb(new_label, lv_label_signal);
 802c598:	4966      	ldr	r1, [pc, #408]	; (802c734 <lv_label_create+0x29c>)
 802c59a:	6978      	ldr	r0, [r7, #20]
 802c59c:	f7de fa86 	bl	800aaac <lv_obj_set_signal_cb>

    /*Init the new label*/
    if(copy == NULL) {
 802c5a0:	683b      	ldr	r3, [r7, #0]
 802c5a2:	2b00      	cmp	r3, #0
 802c5a4:	d110      	bne.n	802c5c8 <lv_label_create+0x130>
        lv_theme_apply(new_label, LV_THEME_LABEL);
 802c5a6:	2112      	movs	r1, #18
 802c5a8:	6978      	ldr	r0, [r7, #20]
 802c5aa:	f7f6 fac9 	bl	8022b40 <lv_theme_apply>
        lv_obj_set_click(new_label, false);
 802c5ae:	2100      	movs	r1, #0
 802c5b0:	6978      	ldr	r0, [r7, #20]
 802c5b2:	f7dd ffad 	bl	800a510 <lv_obj_set_click>
        lv_label_set_long_mode(new_label, LV_LABEL_LONG_EXPAND);
 802c5b6:	2100      	movs	r1, #0
 802c5b8:	6978      	ldr	r0, [r7, #20]
 802c5ba:	f000 f9c7 	bl	802c94c <lv_label_set_long_mode>
        lv_label_set_text(new_label, "Text");
 802c5be:	495e      	ldr	r1, [pc, #376]	; (802c738 <lv_label_create+0x2a0>)
 802c5c0:	6978      	ldr	r0, [r7, #20]
 802c5c2:	f000 f8bb 	bl	802c73c <lv_label_set_text>
 802c5c6:	e0a9      	b.n	802c71c <lv_label_create+0x284>
    }
    /*Copy 'copy' if not NULL*/
    else {
        lv_label_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 802c5c8:	6838      	ldr	r0, [r7, #0]
 802c5ca:	f7df fa41 	bl	800ba50 <lv_obj_get_ext_attr>
 802c5ce:	60f8      	str	r0, [r7, #12]
        lv_label_set_long_mode(new_label, lv_label_get_long_mode(copy));
 802c5d0:	6838      	ldr	r0, [r7, #0]
 802c5d2:	f000 fac9 	bl	802cb68 <lv_label_get_long_mode>
 802c5d6:	4603      	mov	r3, r0
 802c5d8:	4619      	mov	r1, r3
 802c5da:	6978      	ldr	r0, [r7, #20]
 802c5dc:	f000 f9b6 	bl	802c94c <lv_label_set_long_mode>
        lv_label_set_recolor(new_label, lv_label_get_recolor(copy));
 802c5e0:	6838      	ldr	r0, [r7, #0]
 802c5e2:	f000 fb15 	bl	802cc10 <lv_label_get_recolor>
 802c5e6:	4603      	mov	r3, r0
 802c5e8:	4619      	mov	r1, r3
 802c5ea:	6978      	ldr	r0, [r7, #20]
 802c5ec:	f000 fa5a 	bl	802caa4 <lv_label_set_recolor>
        lv_label_set_align(new_label, lv_label_get_align(copy));
 802c5f0:	6838      	ldr	r0, [r7, #0]
 802c5f2:	f000 fadf 	bl	802cbb4 <lv_label_get_align>
 802c5f6:	4603      	mov	r3, r0
 802c5f8:	4619      	mov	r1, r3
 802c5fa:	6978      	ldr	r0, [r7, #20]
 802c5fc:	f000 fa18 	bl	802ca30 <lv_label_set_align>
        if(copy_ext->static_txt == 0)
 802c600:	68fb      	ldr	r3, [r7, #12]
 802c602:	7c9b      	ldrb	r3, [r3, #18]
 802c604:	f003 0308 	and.w	r3, r3, #8
 802c608:	b2db      	uxtb	r3, r3
 802c60a:	2b00      	cmp	r3, #0
 802c60c:	d108      	bne.n	802c620 <lv_label_create+0x188>
            lv_label_set_text(new_label, lv_label_get_text(copy));
 802c60e:	6838      	ldr	r0, [r7, #0]
 802c610:	f000 fa86 	bl	802cb20 <lv_label_get_text>
 802c614:	4603      	mov	r3, r0
 802c616:	4619      	mov	r1, r3
 802c618:	6978      	ldr	r0, [r7, #20]
 802c61a:	f000 f88f 	bl	802c73c <lv_label_set_text>
 802c61e:	e007      	b.n	802c630 <lv_label_create+0x198>
        else
            lv_label_set_text_static(new_label, lv_label_get_text(copy));
 802c620:	6838      	ldr	r0, [r7, #0]
 802c622:	f000 fa7d 	bl	802cb20 <lv_label_get_text>
 802c626:	4603      	mov	r3, r0
 802c628:	4619      	mov	r1, r3
 802c62a:	6978      	ldr	r0, [r7, #20]
 802c62c:	f000 f94a 	bl	802c8c4 <lv_label_set_text_static>

        /*In DOT mode save the text byte-to-byte because a '\0' can be in the middle*/
        if(copy_ext->long_mode == LV_LABEL_LONG_DOT) {
 802c630:	68fb      	ldr	r3, [r7, #12]
 802c632:	7c9b      	ldrb	r3, [r3, #18]
 802c634:	f003 0307 	and.w	r3, r3, #7
 802c638:	b2db      	uxtb	r3, r3
 802c63a:	2b02      	cmp	r3, #2
 802c63c:	d13a      	bne.n	802c6b4 <lv_label_create+0x21c>
            ext->text = lv_mem_realloc(ext->text, _lv_mem_get_size(copy_ext->text));
 802c63e:	693b      	ldr	r3, [r7, #16]
 802c640:	681e      	ldr	r6, [r3, #0]
 802c642:	68fb      	ldr	r3, [r7, #12]
 802c644:	681b      	ldr	r3, [r3, #0]
 802c646:	4618      	mov	r0, r3
 802c648:	f7f4 fc04 	bl	8020e54 <_lv_mem_get_size>
 802c64c:	4603      	mov	r3, r0
 802c64e:	4619      	mov	r1, r3
 802c650:	4630      	mov	r0, r6
 802c652:	f7f4 fb5f 	bl	8020d14 <lv_mem_realloc>
 802c656:	4602      	mov	r2, r0
 802c658:	693b      	ldr	r3, [r7, #16]
 802c65a:	601a      	str	r2, [r3, #0]
            LV_ASSERT_MEM(ext->text);
 802c65c:	693b      	ldr	r3, [r7, #16]
 802c65e:	681b      	ldr	r3, [r3, #0]
 802c660:	4618      	mov	r0, r3
 802c662:	f7f3 fd45 	bl	80200f0 <lv_debug_check_null>
 802c666:	4603      	mov	r3, r0
 802c668:	f083 0301 	eor.w	r3, r3, #1
 802c66c:	b2db      	uxtb	r3, r3
 802c66e:	2b00      	cmp	r3, #0
 802c670:	d00b      	beq.n	802c68a <lv_label_create+0x1f2>
 802c672:	693b      	ldr	r3, [r7, #16]
 802c674:	681b      	ldr	r3, [r3, #0]
 802c676:	461a      	mov	r2, r3
 802c678:	2300      	movs	r3, #0
 802c67a:	4614      	mov	r4, r2
 802c67c:	461d      	mov	r5, r3
 802c67e:	4622      	mov	r2, r4
 802c680:	462b      	mov	r3, r5
 802c682:	4829      	ldr	r0, [pc, #164]	; (802c728 <lv_label_create+0x290>)
 802c684:	f7f3 fd44 	bl	8020110 <lv_debug_log_error>
 802c688:	e7fe      	b.n	802c688 <lv_label_create+0x1f0>
            if(ext->text == NULL) return NULL;
 802c68a:	693b      	ldr	r3, [r7, #16]
 802c68c:	681b      	ldr	r3, [r3, #0]
 802c68e:	2b00      	cmp	r3, #0
 802c690:	d101      	bne.n	802c696 <lv_label_create+0x1fe>
 802c692:	2300      	movs	r3, #0
 802c694:	e043      	b.n	802c71e <lv_label_create+0x286>
            _lv_memcpy(ext->text, copy_ext->text, _lv_mem_get_size(copy_ext->text));
 802c696:	693b      	ldr	r3, [r7, #16]
 802c698:	681c      	ldr	r4, [r3, #0]
 802c69a:	68fb      	ldr	r3, [r7, #12]
 802c69c:	681d      	ldr	r5, [r3, #0]
 802c69e:	68fb      	ldr	r3, [r7, #12]
 802c6a0:	681b      	ldr	r3, [r3, #0]
 802c6a2:	4618      	mov	r0, r3
 802c6a4:	f7f4 fbd6 	bl	8020e54 <_lv_mem_get_size>
 802c6a8:	4603      	mov	r3, r0
 802c6aa:	461a      	mov	r2, r3
 802c6ac:	4629      	mov	r1, r5
 802c6ae:	4620      	mov	r0, r4
 802c6b0:	f7f4 fd54 	bl	802115c <_lv_memcpy>
        }

        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
 802c6b4:	68fb      	ldr	r3, [r7, #12]
 802c6b6:	7cdb      	ldrb	r3, [r3, #19]
 802c6b8:	f003 0301 	and.w	r3, r3, #1
 802c6bc:	b2db      	uxtb	r3, r3
 802c6be:	2b00      	cmp	r3, #0
 802c6c0:	d011      	beq.n	802c6e6 <lv_label_create+0x24e>
 802c6c2:	68fb      	ldr	r3, [r7, #12]
 802c6c4:	685b      	ldr	r3, [r3, #4]
 802c6c6:	2b00      	cmp	r3, #0
 802c6c8:	d00d      	beq.n	802c6e6 <lv_label_create+0x24e>
            uint32_t len = (uint32_t)strlen(copy_ext->dot.tmp_ptr);
 802c6ca:	68fb      	ldr	r3, [r7, #12]
 802c6cc:	685b      	ldr	r3, [r3, #4]
 802c6ce:	4618      	mov	r0, r3
 802c6d0:	f7d3 fd96 	bl	8000200 <strlen>
 802c6d4:	60b8      	str	r0, [r7, #8]
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
 802c6d6:	693b      	ldr	r3, [r7, #16]
 802c6d8:	685b      	ldr	r3, [r3, #4]
 802c6da:	68ba      	ldr	r2, [r7, #8]
 802c6dc:	4619      	mov	r1, r3
 802c6de:	6978      	ldr	r0, [r7, #20]
 802c6e0:	f001 fc2a 	bl	802df38 <lv_label_set_dot_tmp>
        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
 802c6e4:	e007      	b.n	802c6f6 <lv_label_create+0x25e>
        }
        else {
            _lv_memcpy(ext->dot.tmp, copy_ext->dot.tmp, sizeof(ext->dot.tmp));
 802c6e6:	693b      	ldr	r3, [r7, #16]
 802c6e8:	1d18      	adds	r0, r3, #4
 802c6ea:	68fb      	ldr	r3, [r7, #12]
 802c6ec:	3304      	adds	r3, #4
 802c6ee:	2204      	movs	r2, #4
 802c6f0:	4619      	mov	r1, r3
 802c6f2:	f7f4 fd33 	bl	802115c <_lv_memcpy>
        }
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
 802c6f6:	68fb      	ldr	r3, [r7, #12]
 802c6f8:	7cdb      	ldrb	r3, [r3, #19]
 802c6fa:	f3c3 0300 	ubfx	r3, r3, #0, #1
 802c6fe:	b2d9      	uxtb	r1, r3
 802c700:	693a      	ldr	r2, [r7, #16]
 802c702:	7cd3      	ldrb	r3, [r2, #19]
 802c704:	f361 0300 	bfi	r3, r1, #0, #1
 802c708:	74d3      	strb	r3, [r2, #19]
        ext->dot_end       = copy_ext->dot_end;
 802c70a:	68fb      	ldr	r3, [r7, #12]
 802c70c:	689a      	ldr	r2, [r3, #8]
 802c70e:	693b      	ldr	r3, [r7, #16]
 802c710:	609a      	str	r2, [r3, #8]

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_label, LV_OBJ_PART_ALL, LV_STYLE_PROP_ALL);
 802c712:	22ff      	movs	r2, #255	; 0xff
 802c714:	21ff      	movs	r1, #255	; 0xff
 802c716:	6978      	ldr	r0, [r7, #20]
 802c718:	f7dd fdf2 	bl	800a300 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("label created");

    return new_label;
 802c71c:	697b      	ldr	r3, [r7, #20]
}
 802c71e:	4618      	mov	r0, r3
 802c720:	371c      	adds	r7, #28
 802c722:	46bd      	mov	sp, r7
 802c724:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802c728:	0802e5f8 	.word	0x0802e5f8
 802c72c:	20012364 	.word	0x20012364
 802c730:	0802d0b5 	.word	0x0802d0b5
 802c734:	0802d465 	.word	0x0802d465
 802c738:	0802e608 	.word	0x0802e608

0802c73c <lv_label_set_text>:
 * Set a new text for a label. Memory will be allocated to store the text by the label.
 * @param label pointer to a label object
 * @param text '\0' terminated character string. NULL to refresh with the current text.
 */
void lv_label_set_text(lv_obj_t * label, const char * text)
{
 802c73c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 802c740:	b086      	sub	sp, #24
 802c742:	af00      	add	r7, sp, #0
 802c744:	60f8      	str	r0, [r7, #12]
 802c746:	60b9      	str	r1, [r7, #8]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802c748:	68f8      	ldr	r0, [r7, #12]
 802c74a:	f7f3 fcd1 	bl	80200f0 <lv_debug_check_null>
 802c74e:	4603      	mov	r3, r0
 802c750:	f083 0301 	eor.w	r3, r3, #1
 802c754:	b2db      	uxtb	r3, r3
 802c756:	2b00      	cmp	r3, #0
 802c758:	d009      	beq.n	802c76e <lv_label_set_text+0x32>
 802c75a:	68fb      	ldr	r3, [r7, #12]
 802c75c:	2200      	movs	r2, #0
 802c75e:	603b      	str	r3, [r7, #0]
 802c760:	607a      	str	r2, [r7, #4]
 802c762:	e9d7 2300 	ldrd	r2, r3, [r7]
 802c766:	4855      	ldr	r0, [pc, #340]	; (802c8bc <lv_label_set_text+0x180>)
 802c768:	f7f3 fcd2 	bl	8020110 <lv_debug_log_error>
 802c76c:	e7fe      	b.n	802c76c <lv_label_set_text+0x30>

    lv_obj_invalidate(label);
 802c76e:	68f8      	ldr	r0, [r7, #12]
 802c770:	f7dd f946 	bl	8009a00 <lv_obj_invalidate>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802c774:	68f8      	ldr	r0, [r7, #12]
 802c776:	f7df f96b 	bl	800ba50 <lv_obj_get_ext_attr>
 802c77a:	6178      	str	r0, [r7, #20]

    /*If text is NULL then refresh */
    if(text == NULL) {
 802c77c:	68bb      	ldr	r3, [r7, #8]
 802c77e:	2b00      	cmp	r3, #0
 802c780:	d103      	bne.n	802c78a <lv_label_set_text+0x4e>
        lv_label_refr_text(label);
 802c782:	68f8      	ldr	r0, [r7, #12]
 802c784:	f000 ff16 	bl	802d5b4 <lv_label_refr_text>
        return;
 802c788:	e094      	b.n	802c8b4 <lv_label_set_text+0x178>
    }

    LV_ASSERT_STR(text);
 802c78a:	68b8      	ldr	r0, [r7, #8]
 802c78c:	f7f3 fcb0 	bl	80200f0 <lv_debug_check_null>
 802c790:	4603      	mov	r3, r0
 802c792:	f083 0301 	eor.w	r3, r3, #1
 802c796:	b2db      	uxtb	r3, r3
 802c798:	2b00      	cmp	r3, #0
 802c79a:	d009      	beq.n	802c7b0 <lv_label_set_text+0x74>
 802c79c:	68bb      	ldr	r3, [r7, #8]
 802c79e:	2200      	movs	r2, #0
 802c7a0:	469a      	mov	sl, r3
 802c7a2:	4693      	mov	fp, r2
 802c7a4:	4652      	mov	r2, sl
 802c7a6:	465b      	mov	r3, fp
 802c7a8:	4844      	ldr	r0, [pc, #272]	; (802c8bc <lv_label_set_text+0x180>)
 802c7aa:	f7f3 fcb1 	bl	8020110 <lv_debug_log_error>
 802c7ae:	e7fe      	b.n	802c7ae <lv_label_set_text+0x72>

    if(ext->text == text && ext->static_txt == 0) {
 802c7b0:	697b      	ldr	r3, [r7, #20]
 802c7b2:	681b      	ldr	r3, [r3, #0]
 802c7b4:	68ba      	ldr	r2, [r7, #8]
 802c7b6:	429a      	cmp	r2, r3
 802c7b8:	d132      	bne.n	802c820 <lv_label_set_text+0xe4>
 802c7ba:	697b      	ldr	r3, [r7, #20]
 802c7bc:	7c9b      	ldrb	r3, [r3, #18]
 802c7be:	f003 0308 	and.w	r3, r3, #8
 802c7c2:	b2db      	uxtb	r3, r3
 802c7c4:	2b00      	cmp	r3, #0
 802c7c6:	d12b      	bne.n	802c820 <lv_label_set_text+0xe4>
        LV_ASSERT_MEM(ext->text);
        if(ext->text == NULL) return;

        _lv_txt_ap_proc(ext->text, ext->text);
#else
        ext->text = lv_mem_realloc(ext->text, strlen(ext->text) + 1);
 802c7c8:	697b      	ldr	r3, [r7, #20]
 802c7ca:	681c      	ldr	r4, [r3, #0]
 802c7cc:	697b      	ldr	r3, [r7, #20]
 802c7ce:	681b      	ldr	r3, [r3, #0]
 802c7d0:	4618      	mov	r0, r3
 802c7d2:	f7d3 fd15 	bl	8000200 <strlen>
 802c7d6:	4603      	mov	r3, r0
 802c7d8:	3301      	adds	r3, #1
 802c7da:	4619      	mov	r1, r3
 802c7dc:	4620      	mov	r0, r4
 802c7de:	f7f4 fa99 	bl	8020d14 <lv_mem_realloc>
 802c7e2:	4602      	mov	r2, r0
 802c7e4:	697b      	ldr	r3, [r7, #20]
 802c7e6:	601a      	str	r2, [r3, #0]
#endif

        LV_ASSERT_MEM(ext->text);
 802c7e8:	697b      	ldr	r3, [r7, #20]
 802c7ea:	681b      	ldr	r3, [r3, #0]
 802c7ec:	4618      	mov	r0, r3
 802c7ee:	f7f3 fc7f 	bl	80200f0 <lv_debug_check_null>
 802c7f2:	4603      	mov	r3, r0
 802c7f4:	f083 0301 	eor.w	r3, r3, #1
 802c7f8:	b2db      	uxtb	r3, r3
 802c7fa:	2b00      	cmp	r3, #0
 802c7fc:	d00b      	beq.n	802c816 <lv_label_set_text+0xda>
 802c7fe:	697b      	ldr	r3, [r7, #20]
 802c800:	681b      	ldr	r3, [r3, #0]
 802c802:	461a      	mov	r2, r3
 802c804:	2300      	movs	r3, #0
 802c806:	4690      	mov	r8, r2
 802c808:	4699      	mov	r9, r3
 802c80a:	4642      	mov	r2, r8
 802c80c:	464b      	mov	r3, r9
 802c80e:	482c      	ldr	r0, [pc, #176]	; (802c8c0 <lv_label_set_text+0x184>)
 802c810:	f7f3 fc7e 	bl	8020110 <lv_debug_log_error>
 802c814:	e7fe      	b.n	802c814 <lv_label_set_text+0xd8>
        if(ext->text == NULL) return;
 802c816:	697b      	ldr	r3, [r7, #20]
 802c818:	681b      	ldr	r3, [r3, #0]
 802c81a:	2b00      	cmp	r3, #0
 802c81c:	d145      	bne.n	802c8aa <lv_label_set_text+0x16e>
 802c81e:	e049      	b.n	802c8b4 <lv_label_set_text+0x178>
    }
    else {
        /*Free the old text*/
        if(ext->text != NULL && ext->static_txt == 0) {
 802c820:	697b      	ldr	r3, [r7, #20]
 802c822:	681b      	ldr	r3, [r3, #0]
 802c824:	2b00      	cmp	r3, #0
 802c826:	d00e      	beq.n	802c846 <lv_label_set_text+0x10a>
 802c828:	697b      	ldr	r3, [r7, #20]
 802c82a:	7c9b      	ldrb	r3, [r3, #18]
 802c82c:	f003 0308 	and.w	r3, r3, #8
 802c830:	b2db      	uxtb	r3, r3
 802c832:	2b00      	cmp	r3, #0
 802c834:	d107      	bne.n	802c846 <lv_label_set_text+0x10a>
            lv_mem_free(ext->text);
 802c836:	697b      	ldr	r3, [r7, #20]
 802c838:	681b      	ldr	r3, [r3, #0]
 802c83a:	4618      	mov	r0, r3
 802c83c:	f7f4 fa14 	bl	8020c68 <lv_mem_free>
            ext->text = NULL;
 802c840:	697b      	ldr	r3, [r7, #20]
 802c842:	2200      	movs	r2, #0
 802c844:	601a      	str	r2, [r3, #0]
        if(ext->text == NULL) return;

        _lv_txt_ap_proc(text, ext->text);
#else
        /*Get the size of the text*/
        size_t len = strlen(text) + 1;
 802c846:	68b8      	ldr	r0, [r7, #8]
 802c848:	f7d3 fcda 	bl	8000200 <strlen>
 802c84c:	4603      	mov	r3, r0
 802c84e:	3301      	adds	r3, #1
 802c850:	613b      	str	r3, [r7, #16]

        /*Allocate space for the new text*/
        ext->text = lv_mem_alloc(len);
 802c852:	6938      	ldr	r0, [r7, #16]
 802c854:	f7f4 f9be 	bl	8020bd4 <lv_mem_alloc>
 802c858:	4602      	mov	r2, r0
 802c85a:	697b      	ldr	r3, [r7, #20]
 802c85c:	601a      	str	r2, [r3, #0]
        LV_ASSERT_MEM(ext->text);
 802c85e:	697b      	ldr	r3, [r7, #20]
 802c860:	681b      	ldr	r3, [r3, #0]
 802c862:	4618      	mov	r0, r3
 802c864:	f7f3 fc44 	bl	80200f0 <lv_debug_check_null>
 802c868:	4603      	mov	r3, r0
 802c86a:	f083 0301 	eor.w	r3, r3, #1
 802c86e:	b2db      	uxtb	r3, r3
 802c870:	2b00      	cmp	r3, #0
 802c872:	d00b      	beq.n	802c88c <lv_label_set_text+0x150>
 802c874:	697b      	ldr	r3, [r7, #20]
 802c876:	681b      	ldr	r3, [r3, #0]
 802c878:	461a      	mov	r2, r3
 802c87a:	2300      	movs	r3, #0
 802c87c:	4614      	mov	r4, r2
 802c87e:	461d      	mov	r5, r3
 802c880:	4622      	mov	r2, r4
 802c882:	462b      	mov	r3, r5
 802c884:	480e      	ldr	r0, [pc, #56]	; (802c8c0 <lv_label_set_text+0x184>)
 802c886:	f7f3 fc43 	bl	8020110 <lv_debug_log_error>
 802c88a:	e7fe      	b.n	802c88a <lv_label_set_text+0x14e>
        if(ext->text == NULL) return;
 802c88c:	697b      	ldr	r3, [r7, #20]
 802c88e:	681b      	ldr	r3, [r3, #0]
 802c890:	2b00      	cmp	r3, #0
 802c892:	d00e      	beq.n	802c8b2 <lv_label_set_text+0x176>
        strcpy(ext->text, text);
 802c894:	697b      	ldr	r3, [r7, #20]
 802c896:	681b      	ldr	r3, [r3, #0]
 802c898:	68b9      	ldr	r1, [r7, #8]
 802c89a:	4618      	mov	r0, r3
 802c89c:	f001 fd28 	bl	802e2f0 <strcpy>
#endif

        /*Now the text is dynamically allocated*/
        ext->static_txt = 0;
 802c8a0:	697a      	ldr	r2, [r7, #20]
 802c8a2:	7c93      	ldrb	r3, [r2, #18]
 802c8a4:	f36f 03c3 	bfc	r3, #3, #1
 802c8a8:	7493      	strb	r3, [r2, #18]
    }

    lv_label_refr_text(label);
 802c8aa:	68f8      	ldr	r0, [r7, #12]
 802c8ac:	f000 fe82 	bl	802d5b4 <lv_label_refr_text>
 802c8b0:	e000      	b.n	802c8b4 <lv_label_set_text+0x178>
        if(ext->text == NULL) return;
 802c8b2:	bf00      	nop
}
 802c8b4:	3718      	adds	r7, #24
 802c8b6:	46bd      	mov	sp, r7
 802c8b8:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 802c8bc:	0802e610 	.word	0x0802e610
 802c8c0:	0802e5f8 	.word	0x0802e5f8

0802c8c4 <lv_label_set_text_static>:
 * has to be 'alive' while the label exist.
 * @param label pointer to a label object
 * @param text pointer to a text. NULL to refresh with the current text.
 */
void lv_label_set_text_static(lv_obj_t * label, const char * text)
{
 802c8c4:	b5b0      	push	{r4, r5, r7, lr}
 802c8c6:	b084      	sub	sp, #16
 802c8c8:	af00      	add	r7, sp, #0
 802c8ca:	6078      	str	r0, [r7, #4]
 802c8cc:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802c8ce:	6878      	ldr	r0, [r7, #4]
 802c8d0:	f7f3 fc0e 	bl	80200f0 <lv_debug_check_null>
 802c8d4:	4603      	mov	r3, r0
 802c8d6:	f083 0301 	eor.w	r3, r3, #1
 802c8da:	b2db      	uxtb	r3, r3
 802c8dc:	2b00      	cmp	r3, #0
 802c8de:	d009      	beq.n	802c8f4 <lv_label_set_text_static+0x30>
 802c8e0:	687b      	ldr	r3, [r7, #4]
 802c8e2:	2200      	movs	r2, #0
 802c8e4:	461c      	mov	r4, r3
 802c8e6:	4615      	mov	r5, r2
 802c8e8:	4622      	mov	r2, r4
 802c8ea:	462b      	mov	r3, r5
 802c8ec:	4816      	ldr	r0, [pc, #88]	; (802c948 <lv_label_set_text_static+0x84>)
 802c8ee:	f7f3 fc0f 	bl	8020110 <lv_debug_log_error>
 802c8f2:	e7fe      	b.n	802c8f2 <lv_label_set_text_static+0x2e>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802c8f4:	6878      	ldr	r0, [r7, #4]
 802c8f6:	f7df f8ab 	bl	800ba50 <lv_obj_get_ext_attr>
 802c8fa:	60f8      	str	r0, [r7, #12]
    if(ext->static_txt == 0 && ext->text != NULL) {
 802c8fc:	68fb      	ldr	r3, [r7, #12]
 802c8fe:	7c9b      	ldrb	r3, [r3, #18]
 802c900:	f003 0308 	and.w	r3, r3, #8
 802c904:	b2db      	uxtb	r3, r3
 802c906:	2b00      	cmp	r3, #0
 802c908:	d10b      	bne.n	802c922 <lv_label_set_text_static+0x5e>
 802c90a:	68fb      	ldr	r3, [r7, #12]
 802c90c:	681b      	ldr	r3, [r3, #0]
 802c90e:	2b00      	cmp	r3, #0
 802c910:	d007      	beq.n	802c922 <lv_label_set_text_static+0x5e>
        lv_mem_free(ext->text);
 802c912:	68fb      	ldr	r3, [r7, #12]
 802c914:	681b      	ldr	r3, [r3, #0]
 802c916:	4618      	mov	r0, r3
 802c918:	f7f4 f9a6 	bl	8020c68 <lv_mem_free>
        ext->text = NULL;
 802c91c:	68fb      	ldr	r3, [r7, #12]
 802c91e:	2200      	movs	r2, #0
 802c920:	601a      	str	r2, [r3, #0]
    }

    if(text != NULL) {
 802c922:	683b      	ldr	r3, [r7, #0]
 802c924:	2b00      	cmp	r3, #0
 802c926:	d007      	beq.n	802c938 <lv_label_set_text_static+0x74>
        ext->static_txt = 1;
 802c928:	68fa      	ldr	r2, [r7, #12]
 802c92a:	7c93      	ldrb	r3, [r2, #18]
 802c92c:	f043 0308 	orr.w	r3, r3, #8
 802c930:	7493      	strb	r3, [r2, #18]
        ext->text       = (char *)text;
 802c932:	68fb      	ldr	r3, [r7, #12]
 802c934:	683a      	ldr	r2, [r7, #0]
 802c936:	601a      	str	r2, [r3, #0]
    }

    lv_label_refr_text(label);
 802c938:	6878      	ldr	r0, [r7, #4]
 802c93a:	f000 fe3b 	bl	802d5b4 <lv_label_refr_text>
}
 802c93e:	bf00      	nop
 802c940:	3710      	adds	r7, #16
 802c942:	46bd      	mov	sp, r7
 802c944:	bdb0      	pop	{r4, r5, r7, pc}
 802c946:	bf00      	nop
 802c948:	0802e610 	.word	0x0802e610

0802c94c <lv_label_set_long_mode>:
 * @param long_mode the new mode from 'lv_label_long_mode' enum.
 *                  In LV_LONG_BREAK/LONG/ROLL the size of the label should be set AFTER this
 * function
 */
void lv_label_set_long_mode(lv_obj_t * label, lv_label_long_mode_t long_mode)
{
 802c94c:	b5b0      	push	{r4, r5, r7, lr}
 802c94e:	b084      	sub	sp, #16
 802c950:	af00      	add	r7, sp, #0
 802c952:	6078      	str	r0, [r7, #4]
 802c954:	460b      	mov	r3, r1
 802c956:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802c958:	6878      	ldr	r0, [r7, #4]
 802c95a:	f7f3 fbc9 	bl	80200f0 <lv_debug_check_null>
 802c95e:	4603      	mov	r3, r0
 802c960:	f083 0301 	eor.w	r3, r3, #1
 802c964:	b2db      	uxtb	r3, r3
 802c966:	2b00      	cmp	r3, #0
 802c968:	d009      	beq.n	802c97e <lv_label_set_long_mode+0x32>
 802c96a:	687b      	ldr	r3, [r7, #4]
 802c96c:	2200      	movs	r2, #0
 802c96e:	461c      	mov	r4, r3
 802c970:	4615      	mov	r5, r2
 802c972:	4622      	mov	r2, r4
 802c974:	462b      	mov	r3, r5
 802c976:	4829      	ldr	r0, [pc, #164]	; (802ca1c <lv_label_set_long_mode+0xd0>)
 802c978:	f7f3 fbca 	bl	8020110 <lv_debug_log_error>
 802c97c:	e7fe      	b.n	802c97c <lv_label_set_long_mode+0x30>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802c97e:	6878      	ldr	r0, [r7, #4]
 802c980:	f7df f866 	bl	800ba50 <lv_obj_get_ext_attr>
 802c984:	60f8      	str	r0, [r7, #12]

#if LV_USE_ANIMATION
    /*Delete the old animation (if exists)*/
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_obj_set_x);
 802c986:	4926      	ldr	r1, [pc, #152]	; (802ca20 <lv_label_set_long_mode+0xd4>)
 802c988:	6878      	ldr	r0, [r7, #4]
 802c98a:	f7f2 fac1 	bl	801ef10 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_obj_set_y);
 802c98e:	4925      	ldr	r1, [pc, #148]	; (802ca24 <lv_label_set_long_mode+0xd8>)
 802c990:	6878      	ldr	r0, [r7, #4]
 802c992:	f7f2 fabd 	bl	801ef10 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 802c996:	4924      	ldr	r1, [pc, #144]	; (802ca28 <lv_label_set_long_mode+0xdc>)
 802c998:	6878      	ldr	r0, [r7, #4]
 802c99a:	f7f2 fab9 	bl	801ef10 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 802c99e:	4923      	ldr	r1, [pc, #140]	; (802ca2c <lv_label_set_long_mode+0xe0>)
 802c9a0:	6878      	ldr	r0, [r7, #4]
 802c9a2:	f7f2 fab5 	bl	801ef10 <lv_anim_del>
#endif
    ext->offset.x = 0;
 802c9a6:	68fb      	ldr	r3, [r7, #12]
 802c9a8:	2200      	movs	r2, #0
 802c9aa:	81da      	strh	r2, [r3, #14]
    ext->offset.y = 0;
 802c9ac:	68fb      	ldr	r3, [r7, #12]
 802c9ae:	2200      	movs	r2, #0
 802c9b0:	821a      	strh	r2, [r3, #16]

    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
 802c9b2:	78fb      	ldrb	r3, [r7, #3]
 802c9b4:	2b03      	cmp	r3, #3
 802c9b6:	d005      	beq.n	802c9c4 <lv_label_set_long_mode+0x78>
 802c9b8:	78fb      	ldrb	r3, [r7, #3]
 802c9ba:	2b04      	cmp	r3, #4
 802c9bc:	d002      	beq.n	802c9c4 <lv_label_set_long_mode+0x78>
 802c9be:	78fb      	ldrb	r3, [r7, #3]
 802c9c0:	2b05      	cmp	r3, #5
 802c9c2:	d105      	bne.n	802c9d0 <lv_label_set_long_mode+0x84>
        ext->expand = 1;
 802c9c4:	68fa      	ldr	r2, [r7, #12]
 802c9c6:	7c93      	ldrb	r3, [r2, #18]
 802c9c8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802c9cc:	7493      	strb	r3, [r2, #18]
 802c9ce:	e004      	b.n	802c9da <lv_label_set_long_mode+0x8e>
    else
        ext->expand = 0;
 802c9d0:	68fa      	ldr	r2, [r7, #12]
 802c9d2:	7c93      	ldrb	r3, [r2, #18]
 802c9d4:	f36f 13c7 	bfc	r3, #7, #1
 802c9d8:	7493      	strb	r3, [r2, #18]

    /*Restore the character under the dots*/
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
 802c9da:	68fb      	ldr	r3, [r7, #12]
 802c9dc:	7c9b      	ldrb	r3, [r3, #18]
 802c9de:	f003 0307 	and.w	r3, r3, #7
 802c9e2:	b2db      	uxtb	r3, r3
 802c9e4:	2b02      	cmp	r3, #2
 802c9e6:	d108      	bne.n	802c9fa <lv_label_set_long_mode+0xae>
 802c9e8:	68fb      	ldr	r3, [r7, #12]
 802c9ea:	689b      	ldr	r3, [r3, #8]
 802c9ec:	f64f 72ff 	movw	r2, #65535	; 0xffff
 802c9f0:	4293      	cmp	r3, r2
 802c9f2:	d002      	beq.n	802c9fa <lv_label_set_long_mode+0xae>
        lv_label_revert_dots(label);
 802c9f4:	6878      	ldr	r0, [r7, #4]
 802c9f6:	f001 fa1d 	bl	802de34 <lv_label_revert_dots>
    }

    ext->long_mode = long_mode;
 802c9fa:	78fb      	ldrb	r3, [r7, #3]
 802c9fc:	f003 0307 	and.w	r3, r3, #7
 802ca00:	b2d9      	uxtb	r1, r3
 802ca02:	68fa      	ldr	r2, [r7, #12]
 802ca04:	7c93      	ldrb	r3, [r2, #18]
 802ca06:	f361 0302 	bfi	r3, r1, #0, #3
 802ca0a:	7493      	strb	r3, [r2, #18]
    lv_label_refr_text(label);
 802ca0c:	6878      	ldr	r0, [r7, #4]
 802ca0e:	f000 fdd1 	bl	802d5b4 <lv_label_refr_text>
}
 802ca12:	bf00      	nop
 802ca14:	3710      	adds	r7, #16
 802ca16:	46bd      	mov	sp, r7
 802ca18:	bdb0      	pop	{r4, r5, r7, pc}
 802ca1a:	bf00      	nop
 802ca1c:	0802e610 	.word	0x0802e610
 802ca20:	08009d9d 	.word	0x08009d9d
 802ca24:	08009df1 	.word	0x08009df1
 802ca28:	0802dee9 	.word	0x0802dee9
 802ca2c:	0802df11 	.word	0x0802df11

0802ca30 <lv_label_set_align>:
 * Set the align of the label (left or center)
 * @param label pointer to a label object
 * @param align 'LV_LABEL_ALIGN_LEFT' or 'LV_LABEL_ALIGN_LEFT'
 */
void lv_label_set_align(lv_obj_t * label, lv_label_align_t align)
{
 802ca30:	b5b0      	push	{r4, r5, r7, lr}
 802ca32:	b084      	sub	sp, #16
 802ca34:	af00      	add	r7, sp, #0
 802ca36:	6078      	str	r0, [r7, #4]
 802ca38:	460b      	mov	r3, r1
 802ca3a:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802ca3c:	6878      	ldr	r0, [r7, #4]
 802ca3e:	f7f3 fb57 	bl	80200f0 <lv_debug_check_null>
 802ca42:	4603      	mov	r3, r0
 802ca44:	f083 0301 	eor.w	r3, r3, #1
 802ca48:	b2db      	uxtb	r3, r3
 802ca4a:	2b00      	cmp	r3, #0
 802ca4c:	d009      	beq.n	802ca62 <lv_label_set_align+0x32>
 802ca4e:	687b      	ldr	r3, [r7, #4]
 802ca50:	2200      	movs	r2, #0
 802ca52:	461c      	mov	r4, r3
 802ca54:	4615      	mov	r5, r2
 802ca56:	4622      	mov	r2, r4
 802ca58:	462b      	mov	r3, r5
 802ca5a:	4811      	ldr	r0, [pc, #68]	; (802caa0 <lv_label_set_align+0x70>)
 802ca5c:	f7f3 fb58 	bl	8020110 <lv_debug_log_error>
 802ca60:	e7fe      	b.n	802ca60 <lv_label_set_align+0x30>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802ca62:	6878      	ldr	r0, [r7, #4]
 802ca64:	f7de fff4 	bl	800ba50 <lv_obj_get_ext_attr>
 802ca68:	60f8      	str	r0, [r7, #12]
    if(ext->align == align) return;
 802ca6a:	68fb      	ldr	r3, [r7, #12]
 802ca6c:	7c9b      	ldrb	r3, [r3, #18]
 802ca6e:	f3c3 1301 	ubfx	r3, r3, #4, #2
 802ca72:	b2db      	uxtb	r3, r3
 802ca74:	461a      	mov	r2, r3
 802ca76:	78fb      	ldrb	r3, [r7, #3]
 802ca78:	429a      	cmp	r2, r3
 802ca7a:	d00c      	beq.n	802ca96 <lv_label_set_align+0x66>

    ext->align = align;
 802ca7c:	78fb      	ldrb	r3, [r7, #3]
 802ca7e:	f003 0303 	and.w	r3, r3, #3
 802ca82:	b2d9      	uxtb	r1, r3
 802ca84:	68fa      	ldr	r2, [r7, #12]
 802ca86:	7c93      	ldrb	r3, [r2, #18]
 802ca88:	f361 1305 	bfi	r3, r1, #4, #2
 802ca8c:	7493      	strb	r3, [r2, #18]

    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
 802ca8e:	6878      	ldr	r0, [r7, #4]
 802ca90:	f7dc ffb6 	bl	8009a00 <lv_obj_invalidate>
 802ca94:	e000      	b.n	802ca98 <lv_label_set_align+0x68>
    if(ext->align == align) return;
 802ca96:	bf00      	nop
                                 (lv_refr_label_text() not required)*/
}
 802ca98:	3710      	adds	r7, #16
 802ca9a:	46bd      	mov	sp, r7
 802ca9c:	bdb0      	pop	{r4, r5, r7, pc}
 802ca9e:	bf00      	nop
 802caa0:	0802e610 	.word	0x0802e610

0802caa4 <lv_label_set_recolor>:
 * Enable the recoloring by in-line commands
 * @param label pointer to a label object
 * @param en true: enable recoloring, false: disable
 */
void lv_label_set_recolor(lv_obj_t * label, bool en)
{
 802caa4:	b5b0      	push	{r4, r5, r7, lr}
 802caa6:	b084      	sub	sp, #16
 802caa8:	af00      	add	r7, sp, #0
 802caaa:	6078      	str	r0, [r7, #4]
 802caac:	460b      	mov	r3, r1
 802caae:	70fb      	strb	r3, [r7, #3]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802cab0:	6878      	ldr	r0, [r7, #4]
 802cab2:	f7f3 fb1d 	bl	80200f0 <lv_debug_check_null>
 802cab6:	4603      	mov	r3, r0
 802cab8:	f083 0301 	eor.w	r3, r3, #1
 802cabc:	b2db      	uxtb	r3, r3
 802cabe:	2b00      	cmp	r3, #0
 802cac0:	d009      	beq.n	802cad6 <lv_label_set_recolor+0x32>
 802cac2:	687b      	ldr	r3, [r7, #4]
 802cac4:	2200      	movs	r2, #0
 802cac6:	461c      	mov	r4, r3
 802cac8:	4615      	mov	r5, r2
 802caca:	4622      	mov	r2, r4
 802cacc:	462b      	mov	r3, r5
 802cace:	4813      	ldr	r0, [pc, #76]	; (802cb1c <lv_label_set_recolor+0x78>)
 802cad0:	f7f3 fb1e 	bl	8020110 <lv_debug_log_error>
 802cad4:	e7fe      	b.n	802cad4 <lv_label_set_recolor+0x30>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802cad6:	6878      	ldr	r0, [r7, #4]
 802cad8:	f7de ffba 	bl	800ba50 <lv_obj_get_ext_attr>
 802cadc:	60f8      	str	r0, [r7, #12]
    if(ext->recolor == en) return;
 802cade:	68fb      	ldr	r3, [r7, #12]
 802cae0:	7c9b      	ldrb	r3, [r3, #18]
 802cae2:	f3c3 1380 	ubfx	r3, r3, #6, #1
 802cae6:	b2db      	uxtb	r3, r3
 802cae8:	78fa      	ldrb	r2, [r7, #3]
 802caea:	429a      	cmp	r2, r3
 802caec:	d011      	beq.n	802cb12 <lv_label_set_recolor+0x6e>

    ext->recolor = en == false ? 0 : 1;
 802caee:	78fb      	ldrb	r3, [r7, #3]
 802caf0:	f083 0301 	eor.w	r3, r3, #1
 802caf4:	b2db      	uxtb	r3, r3
 802caf6:	2b00      	cmp	r3, #0
 802caf8:	d001      	beq.n	802cafe <lv_label_set_recolor+0x5a>
 802cafa:	2100      	movs	r1, #0
 802cafc:	e000      	b.n	802cb00 <lv_label_set_recolor+0x5c>
 802cafe:	2101      	movs	r1, #1
 802cb00:	68fa      	ldr	r2, [r7, #12]
 802cb02:	7c93      	ldrb	r3, [r2, #18]
 802cb04:	f361 1386 	bfi	r3, r1, #6, #1
 802cb08:	7493      	strb	r3, [r2, #18]

    lv_label_refr_text(label); /*Refresh the text because the potential color codes in text needs to
 802cb0a:	6878      	ldr	r0, [r7, #4]
 802cb0c:	f000 fd52 	bl	802d5b4 <lv_label_refr_text>
 802cb10:	e000      	b.n	802cb14 <lv_label_set_recolor+0x70>
    if(ext->recolor == en) return;
 802cb12:	bf00      	nop
                                  be hided or revealed*/
}
 802cb14:	3710      	adds	r7, #16
 802cb16:	46bd      	mov	sp, r7
 802cb18:	bdb0      	pop	{r4, r5, r7, pc}
 802cb1a:	bf00      	nop
 802cb1c:	0802e610 	.word	0x0802e610

0802cb20 <lv_label_get_text>:
 * Get the text of a label
 * @param label pointer to a label object
 * @return the text of the label
 */
char * lv_label_get_text(const lv_obj_t * label)
{
 802cb20:	b5b0      	push	{r4, r5, r7, lr}
 802cb22:	b084      	sub	sp, #16
 802cb24:	af00      	add	r7, sp, #0
 802cb26:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802cb28:	6878      	ldr	r0, [r7, #4]
 802cb2a:	f7f3 fae1 	bl	80200f0 <lv_debug_check_null>
 802cb2e:	4603      	mov	r3, r0
 802cb30:	f083 0301 	eor.w	r3, r3, #1
 802cb34:	b2db      	uxtb	r3, r3
 802cb36:	2b00      	cmp	r3, #0
 802cb38:	d009      	beq.n	802cb4e <lv_label_get_text+0x2e>
 802cb3a:	687b      	ldr	r3, [r7, #4]
 802cb3c:	2200      	movs	r2, #0
 802cb3e:	461c      	mov	r4, r3
 802cb40:	4615      	mov	r5, r2
 802cb42:	4622      	mov	r2, r4
 802cb44:	462b      	mov	r3, r5
 802cb46:	4807      	ldr	r0, [pc, #28]	; (802cb64 <lv_label_get_text+0x44>)
 802cb48:	f7f3 fae2 	bl	8020110 <lv_debug_log_error>
 802cb4c:	e7fe      	b.n	802cb4c <lv_label_get_text+0x2c>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802cb4e:	6878      	ldr	r0, [r7, #4]
 802cb50:	f7de ff7e 	bl	800ba50 <lv_obj_get_ext_attr>
 802cb54:	60f8      	str	r0, [r7, #12]

    return ext->text;
 802cb56:	68fb      	ldr	r3, [r7, #12]
 802cb58:	681b      	ldr	r3, [r3, #0]
}
 802cb5a:	4618      	mov	r0, r3
 802cb5c:	3710      	adds	r7, #16
 802cb5e:	46bd      	mov	sp, r7
 802cb60:	bdb0      	pop	{r4, r5, r7, pc}
 802cb62:	bf00      	nop
 802cb64:	0802e610 	.word	0x0802e610

0802cb68 <lv_label_get_long_mode>:
 * Get the long mode of a label
 * @param label pointer to a label object
 * @return the long mode
 */
lv_label_long_mode_t lv_label_get_long_mode(const lv_obj_t * label)
{
 802cb68:	b5b0      	push	{r4, r5, r7, lr}
 802cb6a:	b084      	sub	sp, #16
 802cb6c:	af00      	add	r7, sp, #0
 802cb6e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802cb70:	6878      	ldr	r0, [r7, #4]
 802cb72:	f7f3 fabd 	bl	80200f0 <lv_debug_check_null>
 802cb76:	4603      	mov	r3, r0
 802cb78:	f083 0301 	eor.w	r3, r3, #1
 802cb7c:	b2db      	uxtb	r3, r3
 802cb7e:	2b00      	cmp	r3, #0
 802cb80:	d009      	beq.n	802cb96 <lv_label_get_long_mode+0x2e>
 802cb82:	687b      	ldr	r3, [r7, #4]
 802cb84:	2200      	movs	r2, #0
 802cb86:	461c      	mov	r4, r3
 802cb88:	4615      	mov	r5, r2
 802cb8a:	4622      	mov	r2, r4
 802cb8c:	462b      	mov	r3, r5
 802cb8e:	4808      	ldr	r0, [pc, #32]	; (802cbb0 <lv_label_get_long_mode+0x48>)
 802cb90:	f7f3 fabe 	bl	8020110 <lv_debug_log_error>
 802cb94:	e7fe      	b.n	802cb94 <lv_label_get_long_mode+0x2c>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802cb96:	6878      	ldr	r0, [r7, #4]
 802cb98:	f7de ff5a 	bl	800ba50 <lv_obj_get_ext_attr>
 802cb9c:	60f8      	str	r0, [r7, #12]
    return ext->long_mode;
 802cb9e:	68fb      	ldr	r3, [r7, #12]
 802cba0:	7c9b      	ldrb	r3, [r3, #18]
 802cba2:	f3c3 0302 	ubfx	r3, r3, #0, #3
 802cba6:	b2db      	uxtb	r3, r3
}
 802cba8:	4618      	mov	r0, r3
 802cbaa:	3710      	adds	r7, #16
 802cbac:	46bd      	mov	sp, r7
 802cbae:	bdb0      	pop	{r4, r5, r7, pc}
 802cbb0:	0802e610 	.word	0x0802e610

0802cbb4 <lv_label_get_align>:
 * Get the align attribute
 * @param label pointer to a label object
 * @return LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER
 */
lv_label_align_t lv_label_get_align(const lv_obj_t * label)
{
 802cbb4:	b5b0      	push	{r4, r5, r7, lr}
 802cbb6:	b084      	sub	sp, #16
 802cbb8:	af00      	add	r7, sp, #0
 802cbba:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802cbbc:	6878      	ldr	r0, [r7, #4]
 802cbbe:	f7f3 fa97 	bl	80200f0 <lv_debug_check_null>
 802cbc2:	4603      	mov	r3, r0
 802cbc4:	f083 0301 	eor.w	r3, r3, #1
 802cbc8:	b2db      	uxtb	r3, r3
 802cbca:	2b00      	cmp	r3, #0
 802cbcc:	d009      	beq.n	802cbe2 <lv_label_get_align+0x2e>
 802cbce:	687b      	ldr	r3, [r7, #4]
 802cbd0:	2200      	movs	r2, #0
 802cbd2:	461c      	mov	r4, r3
 802cbd4:	4615      	mov	r5, r2
 802cbd6:	4622      	mov	r2, r4
 802cbd8:	462b      	mov	r3, r5
 802cbda:	480c      	ldr	r0, [pc, #48]	; (802cc0c <lv_label_get_align+0x58>)
 802cbdc:	f7f3 fa98 	bl	8020110 <lv_debug_log_error>
 802cbe0:	e7fe      	b.n	802cbe0 <lv_label_get_align+0x2c>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802cbe2:	6878      	ldr	r0, [r7, #4]
 802cbe4:	f7de ff34 	bl	800ba50 <lv_obj_get_ext_attr>
 802cbe8:	60b8      	str	r0, [r7, #8]

    lv_label_align_t align = ext->align;
 802cbea:	68bb      	ldr	r3, [r7, #8]
 802cbec:	7c9b      	ldrb	r3, [r3, #18]
 802cbee:	f3c3 1301 	ubfx	r3, r3, #4, #2
 802cbf2:	b2db      	uxtb	r3, r3
 802cbf4:	73fb      	strb	r3, [r7, #15]

    if(align == LV_LABEL_ALIGN_AUTO) {
 802cbf6:	7bfb      	ldrb	r3, [r7, #15]
 802cbf8:	2b03      	cmp	r3, #3
 802cbfa:	d101      	bne.n	802cc00 <lv_label_get_align+0x4c>
        if(base_dir == LV_BIDI_DIR_AUTO) base_dir = _lv_bidi_detect_base_dir(ext->text);

        if(base_dir == LV_BIDI_DIR_LTR) align = LV_LABEL_ALIGN_LEFT;
        else if(base_dir == LV_BIDI_DIR_RTL) align = LV_LABEL_ALIGN_RIGHT;
#else
        align = LV_LABEL_ALIGN_LEFT;
 802cbfc:	2300      	movs	r3, #0
 802cbfe:	73fb      	strb	r3, [r7, #15]
#endif
    }

    return align;
 802cc00:	7bfb      	ldrb	r3, [r7, #15]
}
 802cc02:	4618      	mov	r0, r3
 802cc04:	3710      	adds	r7, #16
 802cc06:	46bd      	mov	sp, r7
 802cc08:	bdb0      	pop	{r4, r5, r7, pc}
 802cc0a:	bf00      	nop
 802cc0c:	0802e610 	.word	0x0802e610

0802cc10 <lv_label_get_recolor>:
 * Get the recoloring attribute
 * @param label pointer to a label object
 * @return true: recoloring is enabled, false: disable
 */
bool lv_label_get_recolor(const lv_obj_t * label)
{
 802cc10:	b5b0      	push	{r4, r5, r7, lr}
 802cc12:	b084      	sub	sp, #16
 802cc14:	af00      	add	r7, sp, #0
 802cc16:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802cc18:	6878      	ldr	r0, [r7, #4]
 802cc1a:	f7f3 fa69 	bl	80200f0 <lv_debug_check_null>
 802cc1e:	4603      	mov	r3, r0
 802cc20:	f083 0301 	eor.w	r3, r3, #1
 802cc24:	b2db      	uxtb	r3, r3
 802cc26:	2b00      	cmp	r3, #0
 802cc28:	d009      	beq.n	802cc3e <lv_label_get_recolor+0x2e>
 802cc2a:	687b      	ldr	r3, [r7, #4]
 802cc2c:	2200      	movs	r2, #0
 802cc2e:	461c      	mov	r4, r3
 802cc30:	4615      	mov	r5, r2
 802cc32:	4622      	mov	r2, r4
 802cc34:	462b      	mov	r3, r5
 802cc36:	480b      	ldr	r0, [pc, #44]	; (802cc64 <lv_label_get_recolor+0x54>)
 802cc38:	f7f3 fa6a 	bl	8020110 <lv_debug_log_error>
 802cc3c:	e7fe      	b.n	802cc3c <lv_label_get_recolor+0x2c>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802cc3e:	6878      	ldr	r0, [r7, #4]
 802cc40:	f7de ff06 	bl	800ba50 <lv_obj_get_ext_attr>
 802cc44:	60f8      	str	r0, [r7, #12]
    return ext->recolor == 0 ? false : true;
 802cc46:	68fb      	ldr	r3, [r7, #12]
 802cc48:	7c9b      	ldrb	r3, [r3, #18]
 802cc4a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802cc4e:	b2db      	uxtb	r3, r3
 802cc50:	2b00      	cmp	r3, #0
 802cc52:	bf14      	ite	ne
 802cc54:	2301      	movne	r3, #1
 802cc56:	2300      	moveq	r3, #0
 802cc58:	b2db      	uxtb	r3, r3
}
 802cc5a:	4618      	mov	r0, r3
 802cc5c:	3710      	adds	r7, #16
 802cc5e:	46bd      	mov	sp, r7
 802cc60:	bdb0      	pop	{r4, r5, r7, pc}
 802cc62:	bf00      	nop
 802cc64:	0802e610 	.word	0x0802e610

0802cc68 <lv_label_get_letter_on>:
 * @param pos pointer to point with coordinates on a the label
 * @return the index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter)
 * Expressed in character index and not byte index (different in UTF-8)
 */
uint32_t lv_label_get_letter_on(const lv_obj_t * label, lv_point_t * pos)
{
 802cc68:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 802cc6c:	b09c      	sub	sp, #112	; 0x70
 802cc6e:	af02      	add	r7, sp, #8
 802cc70:	6078      	str	r0, [r7, #4]
 802cc72:	6039      	str	r1, [r7, #0]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802cc74:	6878      	ldr	r0, [r7, #4]
 802cc76:	f7f3 fa3b 	bl	80200f0 <lv_debug_check_null>
 802cc7a:	4603      	mov	r3, r0
 802cc7c:	f083 0301 	eor.w	r3, r3, #1
 802cc80:	b2db      	uxtb	r3, r3
 802cc82:	2b00      	cmp	r3, #0
 802cc84:	d009      	beq.n	802cc9a <lv_label_get_letter_on+0x32>
 802cc86:	687b      	ldr	r3, [r7, #4]
 802cc88:	2200      	movs	r2, #0
 802cc8a:	4698      	mov	r8, r3
 802cc8c:	4691      	mov	r9, r2
 802cc8e:	4642      	mov	r2, r8
 802cc90:	464b      	mov	r3, r9
 802cc92:	48b1      	ldr	r0, [pc, #708]	; (802cf58 <lv_label_get_letter_on+0x2f0>)
 802cc94:	f7f3 fa3c 	bl	8020110 <lv_debug_log_error>
 802cc98:	e7fe      	b.n	802cc98 <lv_label_get_letter_on+0x30>
    LV_ASSERT_NULL(pos);
 802cc9a:	6838      	ldr	r0, [r7, #0]
 802cc9c:	f7f3 fa28 	bl	80200f0 <lv_debug_check_null>
 802cca0:	4603      	mov	r3, r0
 802cca2:	f083 0301 	eor.w	r3, r3, #1
 802cca6:	b2db      	uxtb	r3, r3
 802cca8:	2b00      	cmp	r3, #0
 802ccaa:	d009      	beq.n	802ccc0 <lv_label_get_letter_on+0x58>
 802ccac:	683b      	ldr	r3, [r7, #0]
 802ccae:	2200      	movs	r2, #0
 802ccb0:	461c      	mov	r4, r3
 802ccb2:	4615      	mov	r5, r2
 802ccb4:	4622      	mov	r2, r4
 802ccb6:	462b      	mov	r3, r5
 802ccb8:	48a7      	ldr	r0, [pc, #668]	; (802cf58 <lv_label_get_letter_on+0x2f0>)
 802ccba:	f7f3 fa29 	bl	8020110 <lv_debug_log_error>
 802ccbe:	e7fe      	b.n	802ccbe <lv_label_get_letter_on+0x56>

    lv_area_t txt_coords;
    get_txt_coords(label, &txt_coords);
 802ccc0:	f107 0318 	add.w	r3, r7, #24
 802ccc4:	4619      	mov	r1, r3
 802ccc6:	6878      	ldr	r0, [r7, #4]
 802ccc8:	f001 f9b4 	bl	802e034 <get_txt_coords>
    const char * txt         = lv_label_get_text(label);
 802cccc:	6878      	ldr	r0, [r7, #4]
 802ccce:	f7ff ff27 	bl	802cb20 <lv_label_get_text>
 802ccd2:	6538      	str	r0, [r7, #80]	; 0x50
    lv_label_ext_t * ext     = lv_obj_get_ext_attr(label);
 802ccd4:	6878      	ldr	r0, [r7, #4]
 802ccd6:	f7de febb 	bl	800ba50 <lv_obj_get_ext_attr>
 802ccda:	64f8      	str	r0, [r7, #76]	; 0x4c
    uint32_t line_start      = 0;
 802ccdc:	2300      	movs	r3, #0
 802ccde:	667b      	str	r3, [r7, #100]	; 0x64
    uint32_t new_line_start  = 0;
 802cce0:	2300      	movs	r3, #0
 802cce2:	663b      	str	r3, [r7, #96]	; 0x60
    lv_coord_t max_w         = lv_area_get_width(&txt_coords);
 802cce4:	f107 0318 	add.w	r3, r7, #24
 802cce8:	4618      	mov	r0, r3
 802ccea:	f7ff fa7d 	bl	802c1e8 <lv_area_get_width>
 802ccee:	4603      	mov	r3, r0
 802ccf0:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    const lv_font_t * font   = lv_obj_get_style_text_font(label, LV_LABEL_PART_MAIN);
 802ccf4:	2100      	movs	r1, #0
 802ccf6:	6878      	ldr	r0, [r7, #4]
 802ccf8:	f7ff fbbb 	bl	802c472 <lv_obj_get_style_text_font>
 802ccfc:	6478      	str	r0, [r7, #68]	; 0x44
    lv_style_int_t line_space = lv_obj_get_style_text_line_space(label, LV_LABEL_PART_MAIN);
 802ccfe:	2100      	movs	r1, #0
 802cd00:	6878      	ldr	r0, [r7, #4]
 802cd02:	f7ff fba4 	bl	802c44e <lv_obj_get_style_text_line_space>
 802cd06:	4603      	mov	r3, r0
 802cd08:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
    lv_style_int_t letter_space = lv_obj_get_style_text_letter_space(label, LV_LABEL_PART_MAIN);
 802cd0c:	2100      	movs	r1, #0
 802cd0e:	6878      	ldr	r0, [r7, #4]
 802cd10:	f7ff fb8b 	bl	802c42a <lv_obj_get_style_text_letter_space>
 802cd14:	4603      	mov	r3, r0
 802cd16:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
    lv_coord_t letter_height    = lv_font_get_line_height(font);
 802cd1a:	6c78      	ldr	r0, [r7, #68]	; 0x44
 802cd1c:	f7ff fa92 	bl	802c244 <lv_font_get_line_height>
 802cd20:	4603      	mov	r3, r0
 802cd22:	87fb      	strh	r3, [r7, #62]	; 0x3e
    lv_coord_t y             = 0;
 802cd24:	2300      	movs	r3, #0
 802cd26:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
    lv_txt_flag_t flag       = LV_TXT_FLAG_NONE;
 802cd2a:	2300      	movs	r3, #0
 802cd2c:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    uint32_t logical_pos;
    char * bidi_txt;

    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 802cd30:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802cd32:	7c9b      	ldrb	r3, [r3, #18]
 802cd34:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802cd38:	b2db      	uxtb	r3, r3
 802cd3a:	2b00      	cmp	r3, #0
 802cd3c:	d005      	beq.n	802cd4a <lv_label_get_letter_on+0xe2>
 802cd3e:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 802cd42:	f043 0301 	orr.w	r3, r3, #1
 802cd46:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 802cd4a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802cd4c:	7c9b      	ldrb	r3, [r3, #18]
 802cd4e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 802cd52:	b2db      	uxtb	r3, r3
 802cd54:	2b00      	cmp	r3, #0
 802cd56:	d005      	beq.n	802cd64 <lv_label_get_letter_on+0xfc>
 802cd58:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 802cd5c:	f043 0302 	orr.w	r3, r3, #2
 802cd60:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) flag |= LV_TXT_FLAG_FIT;
 802cd64:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802cd66:	7c9b      	ldrb	r3, [r3, #18]
 802cd68:	f003 0307 	and.w	r3, r3, #7
 802cd6c:	b2db      	uxtb	r3, r3
 802cd6e:	2b00      	cmp	r3, #0
 802cd70:	d105      	bne.n	802cd7e <lv_label_get_letter_on+0x116>
 802cd72:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 802cd76:	f043 0310 	orr.w	r3, r3, #16
 802cd7a:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d

    lv_label_align_t align = lv_label_get_align(label);
 802cd7e:	6878      	ldr	r0, [r7, #4]
 802cd80:	f7ff ff18 	bl	802cbb4 <lv_label_get_align>
 802cd84:	4603      	mov	r3, r0
 802cd86:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
    if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
 802cd8a:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 802cd8e:	2b01      	cmp	r3, #1
 802cd90:	d105      	bne.n	802cd9e <lv_label_get_letter_on+0x136>
 802cd92:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 802cd96:	f043 0304 	orr.w	r3, r3, #4
 802cd9a:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
 802cd9e:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 802cda2:	2b02      	cmp	r3, #2
 802cda4:	d147      	bne.n	802ce36 <lv_label_get_letter_on+0x1ce>
 802cda6:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 802cdaa:	f043 0308 	orr.w	r3, r3, #8
 802cdae:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d

    /*Search the line of the index letter */;
    while(txt[line_start] != '\0') {
 802cdb2:	e040      	b.n	802ce36 <lv_label_get_letter_on+0x1ce>
        new_line_start += _lv_txt_get_next_line(&txt[line_start], font, letter_space, max_w, flag);
 802cdb4:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 802cdb6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802cdb8:	18d0      	adds	r0, r2, r3
 802cdba:	f9b7 104a 	ldrsh.w	r1, [r7, #74]	; 0x4a
 802cdbe:	f9b7 2040 	ldrsh.w	r2, [r7, #64]	; 0x40
 802cdc2:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 802cdc6:	9300      	str	r3, [sp, #0]
 802cdc8:	460b      	mov	r3, r1
 802cdca:	6c79      	ldr	r1, [r7, #68]	; 0x44
 802cdcc:	f7f5 faf8 	bl	80223c0 <_lv_txt_get_next_line>
 802cdd0:	4602      	mov	r2, r0
 802cdd2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 802cdd4:	4413      	add	r3, r2
 802cdd6:	663b      	str	r3, [r7, #96]	; 0x60

        if(pos->y <= y + letter_height) {
 802cdd8:	683b      	ldr	r3, [r7, #0]
 802cdda:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 802cdde:	4619      	mov	r1, r3
 802cde0:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 802cde4:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 802cde8:	4413      	add	r3, r2
 802cdea:	4299      	cmp	r1, r3
 802cdec:	dc16      	bgt.n	802ce1c <lv_label_get_letter_on+0x1b4>
            /*The line is found (stored in 'line_start')*/
            /* Include the NULL terminator in the last line */
            uint32_t tmp = new_line_start;
 802cdee:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 802cdf0:	60fb      	str	r3, [r7, #12]
            uint32_t letter;
            letter = _lv_txt_encoded_prev(txt, &tmp);
 802cdf2:	4b5a      	ldr	r3, [pc, #360]	; (802cf5c <lv_label_get_letter_on+0x2f4>)
 802cdf4:	681b      	ldr	r3, [r3, #0]
 802cdf6:	f107 020c 	add.w	r2, r7, #12
 802cdfa:	4611      	mov	r1, r2
 802cdfc:	6d38      	ldr	r0, [r7, #80]	; 0x50
 802cdfe:	4798      	blx	r3
 802ce00:	63b8      	str	r0, [r7, #56]	; 0x38
            if(letter != '\n' && txt[new_line_start] == '\0') new_line_start++;
 802ce02:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802ce04:	2b0a      	cmp	r3, #10
 802ce06:	d01d      	beq.n	802ce44 <lv_label_get_letter_on+0x1dc>
 802ce08:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 802ce0a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 802ce0c:	4413      	add	r3, r2
 802ce0e:	781b      	ldrb	r3, [r3, #0]
 802ce10:	2b00      	cmp	r3, #0
 802ce12:	d117      	bne.n	802ce44 <lv_label_get_letter_on+0x1dc>
 802ce14:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 802ce16:	3301      	adds	r3, #1
 802ce18:	663b      	str	r3, [r7, #96]	; 0x60
            break;
 802ce1a:	e013      	b.n	802ce44 <lv_label_get_letter_on+0x1dc>
        }
        y += letter_height + line_space;
 802ce1c:	8ffa      	ldrh	r2, [r7, #62]	; 0x3e
 802ce1e:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 802ce22:	4413      	add	r3, r2
 802ce24:	b29a      	uxth	r2, r3
 802ce26:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 802ce2a:	4413      	add	r3, r2
 802ce2c:	b29b      	uxth	r3, r3
 802ce2e:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e

        line_start = new_line_start;
 802ce32:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 802ce34:	667b      	str	r3, [r7, #100]	; 0x64
    while(txt[line_start] != '\0') {
 802ce36:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 802ce38:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802ce3a:	4413      	add	r3, r2
 802ce3c:	781b      	ldrb	r3, [r3, #0]
 802ce3e:	2b00      	cmp	r3, #0
 802ce40:	d1b8      	bne.n	802cdb4 <lv_label_get_letter_on+0x14c>
 802ce42:	e000      	b.n	802ce46 <lv_label_get_letter_on+0x1de>
            break;
 802ce44:	bf00      	nop
    bidi_txt = _lv_mem_buf_get(new_line_start - line_start + 1);
    uint32_t txt_len = new_line_start - line_start;
    if(new_line_start > 0 && txt[new_line_start - 1] == '\0' && txt_len > 0) txt_len--;
    _lv_bidi_process_paragraph(txt + line_start, bidi_txt, txt_len, lv_obj_get_base_dir(label), NULL, 0);
#else
    bidi_txt = (char *)txt + line_start;
 802ce46:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 802ce48:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802ce4a:	4413      	add	r3, r2
 802ce4c:	637b      	str	r3, [r7, #52]	; 0x34
#endif

    /*Calculate the x coordinate*/
    lv_coord_t x = 0;
 802ce4e:	2300      	movs	r3, #0
 802ce50:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
    if(align == LV_LABEL_ALIGN_CENTER) {
 802ce54:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 802ce58:	2b01      	cmp	r3, #1
 802ce5a:	d128      	bne.n	802ceae <lv_label_get_letter_on+0x246>
        lv_coord_t line_w;
        line_w = _lv_txt_get_width(bidi_txt, new_line_start - line_start, font, letter_space, flag);
 802ce5c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 802ce5e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802ce60:	1ad1      	subs	r1, r2, r3
 802ce62:	f9b7 2040 	ldrsh.w	r2, [r7, #64]	; 0x40
 802ce66:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 802ce6a:	9300      	str	r3, [sp, #0]
 802ce6c:	4613      	mov	r3, r2
 802ce6e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 802ce70:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802ce72:	f7f5 fb63 	bl	802253c <_lv_txt_get_width>
 802ce76:	4603      	mov	r3, r0
 802ce78:	863b      	strh	r3, [r7, #48]	; 0x30
        x += lv_area_get_width(&txt_coords) / 2 - line_w / 2;
 802ce7a:	f107 0318 	add.w	r3, r7, #24
 802ce7e:	4618      	mov	r0, r3
 802ce80:	f7ff f9b2 	bl	802c1e8 <lv_area_get_width>
 802ce84:	4603      	mov	r3, r0
 802ce86:	0fda      	lsrs	r2, r3, #31
 802ce88:	4413      	add	r3, r2
 802ce8a:	105b      	asrs	r3, r3, #1
 802ce8c:	b21b      	sxth	r3, r3
 802ce8e:	4619      	mov	r1, r3
 802ce90:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 802ce94:	0fda      	lsrs	r2, r3, #31
 802ce96:	4413      	add	r3, r2
 802ce98:	105b      	asrs	r3, r3, #1
 802ce9a:	b21b      	sxth	r3, r3
 802ce9c:	1acb      	subs	r3, r1, r3
 802ce9e:	b29a      	uxth	r2, r3
 802cea0:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 802cea4:	4413      	add	r3, r2
 802cea6:	b29b      	uxth	r3, r3
 802cea8:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
 802ceac:	e023      	b.n	802cef6 <lv_label_get_letter_on+0x28e>
    }
    else if(align == LV_LABEL_ALIGN_RIGHT) {
 802ceae:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 802ceb2:	2b02      	cmp	r3, #2
 802ceb4:	d11f      	bne.n	802cef6 <lv_label_get_letter_on+0x28e>
        lv_coord_t line_w;
        line_w = _lv_txt_get_width(bidi_txt, new_line_start - line_start, font, letter_space, flag);
 802ceb6:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 802ceb8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802ceba:	1ad1      	subs	r1, r2, r3
 802cebc:	f9b7 2040 	ldrsh.w	r2, [r7, #64]	; 0x40
 802cec0:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 802cec4:	9300      	str	r3, [sp, #0]
 802cec6:	4613      	mov	r3, r2
 802cec8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 802ceca:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802cecc:	f7f5 fb36 	bl	802253c <_lv_txt_get_width>
 802ced0:	4603      	mov	r3, r0
 802ced2:	867b      	strh	r3, [r7, #50]	; 0x32
        x += lv_area_get_width(&txt_coords) - line_w;
 802ced4:	f107 0318 	add.w	r3, r7, #24
 802ced8:	4618      	mov	r0, r3
 802ceda:	f7ff f985 	bl	802c1e8 <lv_area_get_width>
 802cede:	4603      	mov	r3, r0
 802cee0:	461a      	mov	r2, r3
 802cee2:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 802cee6:	1ad3      	subs	r3, r2, r3
 802cee8:	b29a      	uxth	r2, r3
 802ceea:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 802ceee:	4413      	add	r3, r2
 802cef0:	b29b      	uxth	r3, r3
 802cef2:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
    }

    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 802cef6:	2300      	movs	r3, #0
 802cef8:	75fb      	strb	r3, [r7, #23]

    uint32_t i = 0;
 802cefa:	2300      	movs	r3, #0
 802cefc:	613b      	str	r3, [r7, #16]
    uint32_t i_act = i;
 802cefe:	693b      	ldr	r3, [r7, #16]
 802cf00:	657b      	str	r3, [r7, #84]	; 0x54

    if(new_line_start > 0) {
 802cf02:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 802cf04:	2b00      	cmp	r3, #0
 802cf06:	d069      	beq.n	802cfdc <lv_label_get_letter_on+0x374>
        while(i + line_start < new_line_start) {
 802cf08:	e062      	b.n	802cfd0 <lv_label_get_letter_on+0x368>
            /* Get the current letter.*/
            uint32_t letter = _lv_txt_encoded_next(bidi_txt, &i);
 802cf0a:	4b15      	ldr	r3, [pc, #84]	; (802cf60 <lv_label_get_letter_on+0x2f8>)
 802cf0c:	681b      	ldr	r3, [r3, #0]
 802cf0e:	f107 0210 	add.w	r2, r7, #16
 802cf12:	4611      	mov	r1, r2
 802cf14:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802cf16:	4798      	blx	r3
 802cf18:	62f8      	str	r0, [r7, #44]	; 0x2c

            /*Get the next letter too for kerning*/
            uint32_t letter_next = _lv_txt_encoded_next(&bidi_txt[i], NULL);
 802cf1a:	4b11      	ldr	r3, [pc, #68]	; (802cf60 <lv_label_get_letter_on+0x2f8>)
 802cf1c:	681b      	ldr	r3, [r3, #0]
 802cf1e:	693a      	ldr	r2, [r7, #16]
 802cf20:	6b79      	ldr	r1, [r7, #52]	; 0x34
 802cf22:	440a      	add	r2, r1
 802cf24:	2100      	movs	r1, #0
 802cf26:	4610      	mov	r0, r2
 802cf28:	4798      	blx	r3
 802cf2a:	62b8      	str	r0, [r7, #40]	; 0x28

            /*Handle the recolor command*/
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 802cf2c:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 802cf30:	f003 0301 	and.w	r3, r3, #1
 802cf34:	2b00      	cmp	r3, #0
 802cf36:	d015      	beq.n	802cf64 <lv_label_get_letter_on+0x2fc>
                if(_lv_txt_is_cmd(&cmd_state, bidi_txt[i]) != false) {
 802cf38:	693b      	ldr	r3, [r7, #16]
 802cf3a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 802cf3c:	4413      	add	r3, r2
 802cf3e:	781b      	ldrb	r3, [r3, #0]
 802cf40:	461a      	mov	r2, r3
 802cf42:	f107 0317 	add.w	r3, r7, #23
 802cf46:	4611      	mov	r1, r2
 802cf48:	4618      	mov	r0, r3
 802cf4a:	f7f5 fb5d 	bl	8022608 <_lv_txt_is_cmd>
 802cf4e:	4603      	mov	r3, r0
 802cf50:	2b00      	cmp	r3, #0
 802cf52:	d007      	beq.n	802cf64 <lv_label_get_letter_on+0x2fc>
                    continue; /*Skip the letter is it is part of a command*/
 802cf54:	e03c      	b.n	802cfd0 <lv_label_get_letter_on+0x368>
 802cf56:	bf00      	nop
 802cf58:	0802e610 	.word	0x0802e610
 802cf5c:	20000208 	.word	0x20000208
 802cf60:	20000204 	.word	0x20000204
                }
            }

            lv_coord_t gw = lv_font_get_glyph_width(font, letter, letter_next);
 802cf64:	6aba      	ldr	r2, [r7, #40]	; 0x28
 802cf66:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 802cf68:	6c78      	ldr	r0, [r7, #68]	; 0x44
 802cf6a:	f7f0 fdaf 	bl	801dacc <lv_font_get_glyph_width>
 802cf6e:	4603      	mov	r3, r0
 802cf70:	84fb      	strh	r3, [r7, #38]	; 0x26

            /*Finish if the x position or the last char of the next line is reached*/
            if(pos->x < x + (gw >> 1) || i + line_start == new_line_start ||  txt[i_act + line_start] == '\0') {
 802cf72:	683b      	ldr	r3, [r7, #0]
 802cf74:	f9b3 3000 	ldrsh.w	r3, [r3]
 802cf78:	4619      	mov	r1, r3
 802cf7a:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 802cf7e:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 802cf82:	1052      	asrs	r2, r2, #1
 802cf84:	b212      	sxth	r2, r2
 802cf86:	4413      	add	r3, r2
 802cf88:	4299      	cmp	r1, r3
 802cf8a:	db0d      	blt.n	802cfa8 <lv_label_get_letter_on+0x340>
 802cf8c:	693a      	ldr	r2, [r7, #16]
 802cf8e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802cf90:	4413      	add	r3, r2
 802cf92:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 802cf94:	429a      	cmp	r2, r3
 802cf96:	d007      	beq.n	802cfa8 <lv_label_get_letter_on+0x340>
 802cf98:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 802cf9a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802cf9c:	4413      	add	r3, r2
 802cf9e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 802cfa0:	4413      	add	r3, r2
 802cfa2:	781b      	ldrb	r3, [r3, #0]
 802cfa4:	2b00      	cmp	r3, #0
 802cfa6:	d102      	bne.n	802cfae <lv_label_get_letter_on+0x346>
                i = i_act;
 802cfa8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 802cfaa:	613b      	str	r3, [r7, #16]
                break;
 802cfac:	e016      	b.n	802cfdc <lv_label_get_letter_on+0x374>
            }
            x += gw;
 802cfae:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 802cfb2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 802cfb4:	4413      	add	r3, r2
 802cfb6:	b29b      	uxth	r3, r3
 802cfb8:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
            x += letter_space;
 802cfbc:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 802cfc0:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 802cfc4:	4413      	add	r3, r2
 802cfc6:	b29b      	uxth	r3, r3
 802cfc8:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
            i_act = i;
 802cfcc:	693b      	ldr	r3, [r7, #16]
 802cfce:	657b      	str	r3, [r7, #84]	; 0x54
        while(i + line_start < new_line_start) {
 802cfd0:	693a      	ldr	r2, [r7, #16]
 802cfd2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802cfd4:	4413      	add	r3, r2
 802cfd6:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 802cfd8:	429a      	cmp	r2, r3
 802cfda:	d896      	bhi.n	802cf0a <lv_label_get_letter_on+0x2a2>
                                               txt_len, lv_obj_get_base_dir(label), cid, &is_rtl);
        if(is_rtl) logical_pos++;
        _lv_mem_buf_release(bidi_txt);
    }
#else
    logical_pos = _lv_txt_encoded_get_char_id(bidi_txt, i);
 802cfdc:	4b09      	ldr	r3, [pc, #36]	; (802d004 <lv_label_get_letter_on+0x39c>)
 802cfde:	681b      	ldr	r3, [r3, #0]
 802cfe0:	693a      	ldr	r2, [r7, #16]
 802cfe2:	4611      	mov	r1, r2
 802cfe4:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802cfe6:	4798      	blx	r3
 802cfe8:	6238      	str	r0, [r7, #32]
#endif

    return  logical_pos + _lv_txt_encoded_get_char_id(txt, line_start);
 802cfea:	4b06      	ldr	r3, [pc, #24]	; (802d004 <lv_label_get_letter_on+0x39c>)
 802cfec:	681b      	ldr	r3, [r3, #0]
 802cfee:	6e79      	ldr	r1, [r7, #100]	; 0x64
 802cff0:	6d38      	ldr	r0, [r7, #80]	; 0x50
 802cff2:	4798      	blx	r3
 802cff4:	4602      	mov	r2, r0
 802cff6:	6a3b      	ldr	r3, [r7, #32]
 802cff8:	4413      	add	r3, r2
}
 802cffa:	4618      	mov	r0, r3
 802cffc:	3768      	adds	r7, #104	; 0x68
 802cffe:	46bd      	mov	sp, r7
 802d000:	e8bd 83b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, pc}
 802d004:	20000210 	.word	0x20000210

0802d008 <lv_label_get_text_sel_start>:
 * @brief Get the selection start index.
 * @param label pointer to a label object.
 * @return selection start index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected.
 */
uint32_t lv_label_get_text_sel_start(const lv_obj_t * label)
{
 802d008:	b5b0      	push	{r4, r5, r7, lr}
 802d00a:	b082      	sub	sp, #8
 802d00c:	af00      	add	r7, sp, #0
 802d00e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802d010:	6878      	ldr	r0, [r7, #4]
 802d012:	f7f3 f86d 	bl	80200f0 <lv_debug_check_null>
 802d016:	4603      	mov	r3, r0
 802d018:	f083 0301 	eor.w	r3, r3, #1
 802d01c:	b2db      	uxtb	r3, r3
 802d01e:	2b00      	cmp	r3, #0
 802d020:	d009      	beq.n	802d036 <lv_label_get_text_sel_start+0x2e>
 802d022:	687b      	ldr	r3, [r7, #4]
 802d024:	2200      	movs	r2, #0
 802d026:	461c      	mov	r4, r3
 802d028:	4615      	mov	r5, r2
 802d02a:	4622      	mov	r2, r4
 802d02c:	462b      	mov	r3, r5
 802d02e:	4805      	ldr	r0, [pc, #20]	; (802d044 <lv_label_get_text_sel_start+0x3c>)
 802d030:	f7f3 f86e 	bl	8020110 <lv_debug_log_error>
 802d034:	e7fe      	b.n	802d034 <lv_label_get_text_sel_start+0x2c>
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    return ext->sel_start;

#else
    (void)label;    /*Unused*/
    return LV_LABEL_TEXT_SEL_OFF;
 802d036:	f64f 73ff 	movw	r3, #65535	; 0xffff
#endif
}
 802d03a:	4618      	mov	r0, r3
 802d03c:	3708      	adds	r7, #8
 802d03e:	46bd      	mov	sp, r7
 802d040:	bdb0      	pop	{r4, r5, r7, pc}
 802d042:	bf00      	nop
 802d044:	0802e610 	.word	0x0802e610

0802d048 <lv_label_get_text_sel_end>:
 * @brief Get the selection end index.
 * @param label pointer to a label object.
 * @return selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected.
 */
uint32_t lv_label_get_text_sel_end(const lv_obj_t * label)
{
 802d048:	b5b0      	push	{r4, r5, r7, lr}
 802d04a:	b082      	sub	sp, #8
 802d04c:	af00      	add	r7, sp, #0
 802d04e:	6078      	str	r0, [r7, #4]
    LV_ASSERT_OBJ(label, LV_OBJX_NAME);
 802d050:	6878      	ldr	r0, [r7, #4]
 802d052:	f7f3 f84d 	bl	80200f0 <lv_debug_check_null>
 802d056:	4603      	mov	r3, r0
 802d058:	f083 0301 	eor.w	r3, r3, #1
 802d05c:	b2db      	uxtb	r3, r3
 802d05e:	2b00      	cmp	r3, #0
 802d060:	d009      	beq.n	802d076 <lv_label_get_text_sel_end+0x2e>
 802d062:	687b      	ldr	r3, [r7, #4]
 802d064:	2200      	movs	r2, #0
 802d066:	461c      	mov	r4, r3
 802d068:	4615      	mov	r5, r2
 802d06a:	4622      	mov	r2, r4
 802d06c:	462b      	mov	r3, r5
 802d06e:	4805      	ldr	r0, [pc, #20]	; (802d084 <lv_label_get_text_sel_end+0x3c>)
 802d070:	f7f3 f84e 	bl	8020110 <lv_debug_log_error>
 802d074:	e7fe      	b.n	802d074 <lv_label_get_text_sel_end+0x2c>
#if LV_LABEL_TEXT_SEL
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    return ext->sel_end;
#else
    (void)label; /*Unused*/
    return LV_LABEL_TEXT_SEL_OFF;
 802d076:	f64f 73ff 	movw	r3, #65535	; 0xffff
#endif
}
 802d07a:	4618      	mov	r0, r3
 802d07c:	3708      	adds	r7, #8
 802d07e:	46bd      	mov	sp, r7
 802d080:	bdb0      	pop	{r4, r5, r7, pc}
 802d082:	bf00      	nop
 802d084:	0802e610 	.word	0x0802e610

0802d088 <lv_label_get_style>:
    int32_t max_diff = lv_font_get_glyph_width(font, letter, letter_next) + letter_space + 1;
    return (pos->x >= (last_x - letter_space) && pos->x <= (last_x + max_diff));
}

lv_style_list_t * lv_label_get_style(lv_obj_t * label, uint8_t type)
{
 802d088:	b480      	push	{r7}
 802d08a:	b085      	sub	sp, #20
 802d08c:	af00      	add	r7, sp, #0
 802d08e:	6078      	str	r0, [r7, #4]
 802d090:	460b      	mov	r3, r1
 802d092:	70fb      	strb	r3, [r7, #3]
    lv_style_list_t * style_dsc_p;
    switch(type) {
 802d094:	78fb      	ldrb	r3, [r7, #3]
 802d096:	2b00      	cmp	r3, #0
 802d098:	d103      	bne.n	802d0a2 <lv_label_get_style+0x1a>
        case LV_LABEL_PART_MAIN:
            style_dsc_p = &label->style_list;
 802d09a:	687b      	ldr	r3, [r7, #4]
 802d09c:	3328      	adds	r3, #40	; 0x28
 802d09e:	60fb      	str	r3, [r7, #12]
            break;
 802d0a0:	e001      	b.n	802d0a6 <lv_label_get_style+0x1e>
        default:
            style_dsc_p = NULL;
 802d0a2:	2300      	movs	r3, #0
 802d0a4:	60fb      	str	r3, [r7, #12]
    }

    return style_dsc_p;
 802d0a6:	68fb      	ldr	r3, [r7, #12]
}
 802d0a8:	4618      	mov	r0, r3
 802d0aa:	3714      	adds	r7, #20
 802d0ac:	46bd      	mov	sp, r7
 802d0ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 802d0b2:	4770      	bx	lr

0802d0b4 <lv_label_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return an element of `lv_design_res_t`
 */
static lv_design_res_t lv_label_design(lv_obj_t * label, const lv_area_t * clip_area, lv_design_mode_t mode)
{
 802d0b4:	b5b0      	push	{r4, r5, r7, lr}
 802d0b6:	b0b2      	sub	sp, #200	; 0xc8
 802d0b8:	af04      	add	r7, sp, #16
 802d0ba:	60f8      	str	r0, [r7, #12]
 802d0bc:	60b9      	str	r1, [r7, #8]
 802d0be:	4613      	mov	r3, r2
 802d0c0:	71fb      	strb	r3, [r7, #7]
    /* A label never covers an area */
    if(mode == LV_DESIGN_COVER_CHK)
 802d0c2:	79fb      	ldrb	r3, [r7, #7]
 802d0c4:	2b02      	cmp	r3, #2
 802d0c6:	d101      	bne.n	802d0cc <lv_label_design+0x18>
        return LV_DESIGN_RES_NOT_COVER;
 802d0c8:	2302      	movs	r3, #2
 802d0ca:	e1c6      	b.n	802d45a <lv_label_design+0x3a6>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
 802d0cc:	79fb      	ldrb	r3, [r7, #7]
 802d0ce:	2b00      	cmp	r3, #0
 802d0d0:	f040 81c2 	bne.w	802d458 <lv_label_design+0x3a4>
        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802d0d4:	68f8      	ldr	r0, [r7, #12]
 802d0d6:	f7de fcbb 	bl	800ba50 <lv_obj_get_ext_attr>
 802d0da:	f8c7 00b0 	str.w	r0, [r7, #176]	; 0xb0

        lv_coord_t w = lv_obj_get_style_transform_width(label, LV_LABEL_PART_MAIN);
 802d0de:	2100      	movs	r1, #0
 802d0e0:	68f8      	ldr	r0, [r7, #12]
 802d0e2:	f7ff f93c 	bl	802c35e <lv_obj_get_style_transform_width>
 802d0e6:	4603      	mov	r3, r0
 802d0e8:	f8a7 30ae 	strh.w	r3, [r7, #174]	; 0xae
        lv_coord_t h = lv_obj_get_style_transform_height(label, LV_LABEL_PART_MAIN);
 802d0ec:	2100      	movs	r1, #0
 802d0ee:	68f8      	ldr	r0, [r7, #12]
 802d0f0:	f7ff f946 	bl	802c380 <lv_obj_get_style_transform_height>
 802d0f4:	4603      	mov	r3, r0
 802d0f6:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac
        lv_area_t bg_coords;
        lv_area_copy(&bg_coords, &label->coords);
 802d0fa:	68fb      	ldr	r3, [r7, #12]
 802d0fc:	f103 0210 	add.w	r2, r3, #16
 802d100:	f107 039c 	add.w	r3, r7, #156	; 0x9c
 802d104:	4611      	mov	r1, r2
 802d106:	4618      	mov	r0, r3
 802d108:	f7ff f860 	bl	802c1cc <lv_area_copy>
        bg_coords.x1 -= w;
 802d10c:	f9b7 309c 	ldrsh.w	r3, [r7, #156]	; 0x9c
 802d110:	b29a      	uxth	r2, r3
 802d112:	f8b7 30ae 	ldrh.w	r3, [r7, #174]	; 0xae
 802d116:	1ad3      	subs	r3, r2, r3
 802d118:	b29b      	uxth	r3, r3
 802d11a:	b21b      	sxth	r3, r3
 802d11c:	f8a7 309c 	strh.w	r3, [r7, #156]	; 0x9c
        bg_coords.x2 += w;
 802d120:	f9b7 30a0 	ldrsh.w	r3, [r7, #160]	; 0xa0
 802d124:	b29a      	uxth	r2, r3
 802d126:	f8b7 30ae 	ldrh.w	r3, [r7, #174]	; 0xae
 802d12a:	4413      	add	r3, r2
 802d12c:	b29b      	uxth	r3, r3
 802d12e:	b21b      	sxth	r3, r3
 802d130:	f8a7 30a0 	strh.w	r3, [r7, #160]	; 0xa0
        bg_coords.y1 -= h;
 802d134:	f9b7 309e 	ldrsh.w	r3, [r7, #158]	; 0x9e
 802d138:	b29a      	uxth	r2, r3
 802d13a:	f8b7 30ac 	ldrh.w	r3, [r7, #172]	; 0xac
 802d13e:	1ad3      	subs	r3, r2, r3
 802d140:	b29b      	uxth	r3, r3
 802d142:	b21b      	sxth	r3, r3
 802d144:	f8a7 309e 	strh.w	r3, [r7, #158]	; 0x9e
        bg_coords.y2 += h;
 802d148:	f9b7 30a2 	ldrsh.w	r3, [r7, #162]	; 0xa2
 802d14c:	b29a      	uxth	r2, r3
 802d14e:	f8b7 30ac 	ldrh.w	r3, [r7, #172]	; 0xac
 802d152:	4413      	add	r3, r2
 802d154:	b29b      	uxth	r3, r3
 802d156:	b21b      	sxth	r3, r3
 802d158:	f8a7 30a2 	strh.w	r3, [r7, #162]	; 0xa2

        lv_draw_rect_dsc_t draw_rect_dsc;
        lv_draw_rect_dsc_init(&draw_rect_dsc);
 802d15c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 802d160:	4618      	mov	r0, r3
 802d162:	f7ea fb4f 	bl	8017804 <lv_draw_rect_dsc_init>
        lv_obj_init_draw_rect_dsc(label, LV_LABEL_PART_MAIN, &draw_rect_dsc);
 802d166:	f107 0330 	add.w	r3, r7, #48	; 0x30
 802d16a:	461a      	mov	r2, r3
 802d16c:	2100      	movs	r1, #0
 802d16e:	68f8      	ldr	r0, [r7, #12]
 802d170:	f7de fd47 	bl	800bc02 <lv_obj_init_draw_rect_dsc>

        lv_draw_rect(&bg_coords, clip_area, &draw_rect_dsc);
 802d174:	f107 0230 	add.w	r2, r7, #48	; 0x30
 802d178:	f107 039c 	add.w	r3, r7, #156	; 0x9c
 802d17c:	68b9      	ldr	r1, [r7, #8]
 802d17e:	4618      	mov	r0, r3
 802d180:	f7ea fbce 	bl	8017920 <lv_draw_rect>

        lv_area_t txt_coords;
        get_txt_coords(label, &txt_coords);
 802d184:	f107 0394 	add.w	r3, r7, #148	; 0x94
 802d188:	4619      	mov	r1, r3
 802d18a:	68f8      	ldr	r0, [r7, #12]
 802d18c:	f000 ff52 	bl	802e034 <get_txt_coords>

        lv_area_t txt_clip;
        bool is_common = _lv_area_intersect(&txt_clip, clip_area, &txt_coords);
 802d190:	f107 0294 	add.w	r2, r7, #148	; 0x94
 802d194:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 802d198:	68b9      	ldr	r1, [r7, #8]
 802d19a:	4618      	mov	r0, r3
 802d19c:	f7f2 f966 	bl	801f46c <_lv_area_intersect>
 802d1a0:	4603      	mov	r3, r0
 802d1a2:	f887 30ab 	strb.w	r3, [r7, #171]	; 0xab
        if(!is_common) return LV_DESIGN_RES_OK;
 802d1a6:	f897 30ab 	ldrb.w	r3, [r7, #171]	; 0xab
 802d1aa:	f083 0301 	eor.w	r3, r3, #1
 802d1ae:	b2db      	uxtb	r3, r3
 802d1b0:	2b00      	cmp	r3, #0
 802d1b2:	d001      	beq.n	802d1b8 <lv_label_design+0x104>
 802d1b4:	2300      	movs	r3, #0
 802d1b6:	e150      	b.n	802d45a <lv_label_design+0x3a6>

        lv_label_align_t align = lv_label_get_align(label);
 802d1b8:	68f8      	ldr	r0, [r7, #12]
 802d1ba:	f7ff fcfb 	bl	802cbb4 <lv_label_get_align>
 802d1be:	4603      	mov	r3, r0
 802d1c0:	f887 30aa 	strb.w	r3, [r7, #170]	; 0xaa

        lv_txt_flag_t flag = LV_TXT_FLAG_NONE;
 802d1c4:	2300      	movs	r3, #0
 802d1c6:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 802d1ca:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d1ce:	7c9b      	ldrb	r3, [r3, #18]
 802d1d0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802d1d4:	b2db      	uxtb	r3, r3
 802d1d6:	2b00      	cmp	r3, #0
 802d1d8:	d005      	beq.n	802d1e6 <lv_label_design+0x132>
 802d1da:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 802d1de:	f043 0301 	orr.w	r3, r3, #1
 802d1e2:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 802d1e6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d1ea:	7c9b      	ldrb	r3, [r3, #18]
 802d1ec:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 802d1f0:	b2db      	uxtb	r3, r3
 802d1f2:	2b00      	cmp	r3, #0
 802d1f4:	d005      	beq.n	802d202 <lv_label_design+0x14e>
 802d1f6:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 802d1fa:	f043 0302 	orr.w	r3, r3, #2
 802d1fe:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
        if(ext->long_mode == LV_LABEL_LONG_EXPAND) flag |= LV_TXT_FLAG_FIT;
 802d202:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d206:	7c9b      	ldrb	r3, [r3, #18]
 802d208:	f003 0307 	and.w	r3, r3, #7
 802d20c:	b2db      	uxtb	r3, r3
 802d20e:	2b00      	cmp	r3, #0
 802d210:	d105      	bne.n	802d21e <lv_label_design+0x16a>
 802d212:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 802d216:	f043 0310 	orr.w	r3, r3, #16
 802d21a:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
        if(align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
 802d21e:	f897 30aa 	ldrb.w	r3, [r7, #170]	; 0xaa
 802d222:	2b01      	cmp	r3, #1
 802d224:	d105      	bne.n	802d232 <lv_label_design+0x17e>
 802d226:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 802d22a:	f043 0304 	orr.w	r3, r3, #4
 802d22e:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
        if(align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
 802d232:	f897 30aa 	ldrb.w	r3, [r7, #170]	; 0xaa
 802d236:	2b02      	cmp	r3, #2
 802d238:	d105      	bne.n	802d246 <lv_label_design+0x192>
 802d23a:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 802d23e:	f043 0308 	orr.w	r3, r3, #8
 802d242:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7

        lv_draw_label_dsc_t label_draw_dsc;
        lv_draw_label_dsc_init(&label_draw_dsc);
 802d246:	f107 0310 	add.w	r3, r7, #16
 802d24a:	4618      	mov	r0, r3
 802d24c:	f7e6 f884 	bl	8013358 <lv_draw_label_dsc_init>

        label_draw_dsc.sel_start = lv_label_get_text_sel_start(label);
 802d250:	68f8      	ldr	r0, [r7, #12]
 802d252:	f7ff fed9 	bl	802d008 <lv_label_get_text_sel_start>
 802d256:	4603      	mov	r3, r0
 802d258:	623b      	str	r3, [r7, #32]
        label_draw_dsc.sel_end = lv_label_get_text_sel_end(label);
 802d25a:	68f8      	ldr	r0, [r7, #12]
 802d25c:	f7ff fef4 	bl	802d048 <lv_label_get_text_sel_end>
 802d260:	4603      	mov	r3, r0
 802d262:	627b      	str	r3, [r7, #36]	; 0x24
        label_draw_dsc.ofs_x = ext->offset.x;
 802d264:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d268:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 802d26c:	853b      	strh	r3, [r7, #40]	; 0x28
        label_draw_dsc.ofs_y = ext->offset.y;
 802d26e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d272:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802d276:	857b      	strh	r3, [r7, #42]	; 0x2a
        label_draw_dsc.flag = flag;
 802d278:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 802d27c:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
        lv_obj_init_draw_label_dsc(label, LV_LABEL_PART_MAIN, &label_draw_dsc);
 802d280:	f107 0310 	add.w	r3, r7, #16
 802d284:	461a      	mov	r2, r3
 802d286:	2100      	movs	r1, #0
 802d288:	68f8      	ldr	r0, [r7, #12]
 802d28a:	f7de ff0b 	bl	800c0a4 <lv_obj_init_draw_label_dsc>

        /* In SCROLL and SCROLL_CIRC mode the CENTER and RIGHT are pointless so remove them.
         * (In addition they will result misalignment is this case)*/
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
 802d28e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d292:	7c9b      	ldrb	r3, [r3, #18]
 802d294:	f003 0307 	and.w	r3, r3, #7
 802d298:	b2db      	uxtb	r3, r3
 802d29a:	2b03      	cmp	r3, #3
 802d29c:	d007      	beq.n	802d2ae <lv_label_design+0x1fa>
 802d29e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d2a2:	7c9b      	ldrb	r3, [r3, #18]
 802d2a4:	f003 0307 	and.w	r3, r3, #7
 802d2a8:	b2db      	uxtb	r3, r3
 802d2aa:	2b04      	cmp	r3, #4
 802d2ac:	d13c      	bne.n	802d328 <lv_label_design+0x274>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
 802d2ae:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d2b2:	7c9b      	ldrb	r3, [r3, #18]
 802d2b4:	f003 0330 	and.w	r3, r3, #48	; 0x30
 802d2b8:	b2db      	uxtb	r3, r3
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
 802d2ba:	2b10      	cmp	r3, #16
 802d2bc:	d007      	beq.n	802d2ce <lv_label_design+0x21a>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
 802d2be:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d2c2:	7c9b      	ldrb	r3, [r3, #18]
 802d2c4:	f003 0330 	and.w	r3, r3, #48	; 0x30
 802d2c8:	b2db      	uxtb	r3, r3
 802d2ca:	2b20      	cmp	r3, #32
 802d2cc:	d12c      	bne.n	802d328 <lv_label_design+0x274>
            lv_point_t size;
            _lv_txt_get_size(&size, ext->text, label_draw_dsc.font, label_draw_dsc.letter_space, label_draw_dsc.line_space,
 802d2ce:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d2d2:	6819      	ldr	r1, [r3, #0]
 802d2d4:	697c      	ldr	r4, [r7, #20]
 802d2d6:	f9b7 501c 	ldrsh.w	r5, [r7, #28]
 802d2da:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 802d2de:	f107 0088 	add.w	r0, r7, #136	; 0x88
 802d2e2:	f897 20b7 	ldrb.w	r2, [r7, #183]	; 0xb7
 802d2e6:	9202      	str	r2, [sp, #8]
 802d2e8:	f647 4218 	movw	r2, #31768	; 0x7c18
 802d2ec:	9201      	str	r2, [sp, #4]
 802d2ee:	9300      	str	r3, [sp, #0]
 802d2f0:	462b      	mov	r3, r5
 802d2f2:	4622      	mov	r2, r4
 802d2f4:	f7f4 feca 	bl	802208c <_lv_txt_get_size>
                             LV_COORD_MAX, flag);
            if(size.x > lv_area_get_width(&txt_coords)) {
 802d2f8:	f9b7 4088 	ldrsh.w	r4, [r7, #136]	; 0x88
 802d2fc:	f107 0394 	add.w	r3, r7, #148	; 0x94
 802d300:	4618      	mov	r0, r3
 802d302:	f7fe ff71 	bl	802c1e8 <lv_area_get_width>
 802d306:	4603      	mov	r3, r0
 802d308:	429c      	cmp	r4, r3
 802d30a:	dd0d      	ble.n	802d328 <lv_label_design+0x274>
                label_draw_dsc.flag &= ~LV_TXT_FLAG_RIGHT;
 802d30c:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
 802d310:	f023 0308 	bic.w	r3, r3, #8
 802d314:	b2db      	uxtb	r3, r3
 802d316:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
                label_draw_dsc.flag &= ~LV_TXT_FLAG_CENTER;
 802d31a:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
 802d31e:	f023 0304 	bic.w	r3, r3, #4
 802d322:	b2db      	uxtb	r3, r3
 802d324:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC || lv_area_get_height(&txt_coords) < LV_LABEL_HINT_HEIGHT_LIMIT)
            hint = NULL;

#else
        /*Just for compatibility*/
        lv_draw_label_hint_t * hint = NULL;
 802d328:	2300      	movs	r3, #0
 802d32a:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
#endif

        lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
 802d32e:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d332:	681c      	ldr	r4, [r3, #0]
 802d334:	f107 0210 	add.w	r2, r7, #16
 802d338:	f107 018c 	add.w	r1, r7, #140	; 0x8c
 802d33c:	f107 0094 	add.w	r0, r7, #148	; 0x94
 802d340:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 802d344:	9300      	str	r3, [sp, #0]
 802d346:	4623      	mov	r3, r4
 802d348:	f7e6 f844 	bl	80133d4 <lv_draw_label>

        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
 802d34c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d350:	7c9b      	ldrb	r3, [r3, #18]
 802d352:	f003 0307 	and.w	r3, r3, #7
 802d356:	b2db      	uxtb	r3, r3
 802d358:	2b04      	cmp	r3, #4
 802d35a:	d17d      	bne.n	802d458 <lv_label_design+0x3a4>
            lv_point_t size;
            _lv_txt_get_size(&size, ext->text, label_draw_dsc.font, label_draw_dsc.letter_space, label_draw_dsc.line_space,
 802d35c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d360:	6819      	ldr	r1, [r3, #0]
 802d362:	697c      	ldr	r4, [r7, #20]
 802d364:	f9b7 501c 	ldrsh.w	r5, [r7, #28]
 802d368:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 802d36c:	f107 0084 	add.w	r0, r7, #132	; 0x84
 802d370:	f897 20b7 	ldrb.w	r2, [r7, #183]	; 0xb7
 802d374:	9202      	str	r2, [sp, #8]
 802d376:	f647 4218 	movw	r2, #31768	; 0x7c18
 802d37a:	9201      	str	r2, [sp, #4]
 802d37c:	9300      	str	r3, [sp, #0]
 802d37e:	462b      	mov	r3, r5
 802d380:	4622      	mov	r2, r4
 802d382:	f7f4 fe83 	bl	802208c <_lv_txt_get_size>
                             LV_COORD_MAX, flag);

            /*Draw the text again next to the original to make an circular effect */
            if(size.x > lv_area_get_width(&txt_coords)) {
 802d386:	f9b7 4084 	ldrsh.w	r4, [r7, #132]	; 0x84
 802d38a:	f107 0394 	add.w	r3, r7, #148	; 0x94
 802d38e:	4618      	mov	r0, r3
 802d390:	f7fe ff2a 	bl	802c1e8 <lv_area_get_width>
 802d394:	4603      	mov	r3, r0
 802d396:	429c      	cmp	r4, r3
 802d398:	dd2c      	ble.n	802d3f4 <lv_label_design+0x340>
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
 802d39a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d39e:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 802d3a2:	b29a      	uxth	r2, r3
 802d3a4:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 802d3a8:	b29b      	uxth	r3, r3
 802d3aa:	4413      	add	r3, r2
 802d3ac:	b29c      	uxth	r4, r3
                                       lv_font_get_glyph_width(label_draw_dsc.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
 802d3ae:	697b      	ldr	r3, [r7, #20]
 802d3b0:	2220      	movs	r2, #32
 802d3b2:	2120      	movs	r1, #32
 802d3b4:	4618      	mov	r0, r3
 802d3b6:	f7f0 fb89 	bl	801dacc <lv_font_get_glyph_width>
 802d3ba:	4603      	mov	r3, r0
                label_draw_dsc.ofs_x = ext->offset.x + size.x +
 802d3bc:	461a      	mov	r2, r3
 802d3be:	0052      	lsls	r2, r2, #1
 802d3c0:	4413      	add	r3, r2
 802d3c2:	b29b      	uxth	r3, r3
 802d3c4:	4423      	add	r3, r4
 802d3c6:	b29b      	uxth	r3, r3
 802d3c8:	b21b      	sxth	r3, r3
 802d3ca:	853b      	strh	r3, [r7, #40]	; 0x28
                label_draw_dsc.ofs_y = ext->offset.y;
 802d3cc:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d3d0:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802d3d4:	857b      	strh	r3, [r7, #42]	; 0x2a

                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
 802d3d6:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d3da:	681c      	ldr	r4, [r3, #0]
 802d3dc:	f107 0210 	add.w	r2, r7, #16
 802d3e0:	f107 018c 	add.w	r1, r7, #140	; 0x8c
 802d3e4:	f107 0094 	add.w	r0, r7, #148	; 0x94
 802d3e8:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 802d3ec:	9300      	str	r3, [sp, #0]
 802d3ee:	4623      	mov	r3, r4
 802d3f0:	f7e5 fff0 	bl	80133d4 <lv_draw_label>
            }

            /*Draw the text again below the original to make an circular effect */
            if(size.y > lv_area_get_height(&txt_coords)) {
 802d3f4:	f9b7 4086 	ldrsh.w	r4, [r7, #134]	; 0x86
 802d3f8:	f107 0394 	add.w	r3, r7, #148	; 0x94
 802d3fc:	4618      	mov	r0, r3
 802d3fe:	f7fe ff0a 	bl	802c216 <lv_area_get_height>
 802d402:	4603      	mov	r3, r0
 802d404:	429c      	cmp	r4, r3
 802d406:	dd27      	ble.n	802d458 <lv_label_design+0x3a4>
                label_draw_dsc.ofs_x = ext->offset.x;
 802d408:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d40c:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 802d410:	853b      	strh	r3, [r7, #40]	; 0x28
                label_draw_dsc.ofs_y = ext->offset.y + size.y + lv_font_get_line_height(label_draw_dsc.font);
 802d412:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d416:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802d41a:	b29a      	uxth	r2, r3
 802d41c:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 802d420:	b29b      	uxth	r3, r3
 802d422:	4413      	add	r3, r2
 802d424:	b29c      	uxth	r4, r3
 802d426:	697b      	ldr	r3, [r7, #20]
 802d428:	4618      	mov	r0, r3
 802d42a:	f7fe ff0b 	bl	802c244 <lv_font_get_line_height>
 802d42e:	4603      	mov	r3, r0
 802d430:	b29b      	uxth	r3, r3
 802d432:	4423      	add	r3, r4
 802d434:	b29b      	uxth	r3, r3
 802d436:	b21b      	sxth	r3, r3
 802d438:	857b      	strh	r3, [r7, #42]	; 0x2a

                lv_draw_label(&txt_coords, &txt_clip, &label_draw_dsc, ext->text, hint);
 802d43a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d43e:	681c      	ldr	r4, [r3, #0]
 802d440:	f107 0210 	add.w	r2, r7, #16
 802d444:	f107 018c 	add.w	r1, r7, #140	; 0x8c
 802d448:	f107 0094 	add.w	r0, r7, #148	; 0x94
 802d44c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 802d450:	9300      	str	r3, [sp, #0]
 802d452:	4623      	mov	r3, r4
 802d454:	f7e5 ffbe 	bl	80133d4 <lv_draw_label>
            }
        }
    }

    return LV_DESIGN_RES_OK;
 802d458:	2300      	movs	r3, #0
}
 802d45a:	4618      	mov	r0, r3
 802d45c:	37b8      	adds	r7, #184	; 0xb8
 802d45e:	46bd      	mov	sp, r7
 802d460:	bdb0      	pop	{r4, r5, r7, pc}
	...

0802d464 <lv_label_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_label_signal(lv_obj_t * label, lv_signal_t sign, void * param)
{
 802d464:	b590      	push	{r4, r7, lr}
 802d466:	b089      	sub	sp, #36	; 0x24
 802d468:	af00      	add	r7, sp, #0
 802d46a:	60f8      	str	r0, [r7, #12]
 802d46c:	460b      	mov	r3, r1
 802d46e:	607a      	str	r2, [r7, #4]
 802d470:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    if(sign == LV_SIGNAL_GET_STYLE) {
 802d472:	7afb      	ldrb	r3, [r7, #11]
 802d474:	2b08      	cmp	r3, #8
 802d476:	d118      	bne.n	802d4aa <lv_label_signal+0x46>
        lv_get_style_info_t * info = param;
 802d478:	687b      	ldr	r3, [r7, #4]
 802d47a:	613b      	str	r3, [r7, #16]
        info->result = lv_label_get_style(label, info->part);
 802d47c:	693b      	ldr	r3, [r7, #16]
 802d47e:	781b      	ldrb	r3, [r3, #0]
 802d480:	4619      	mov	r1, r3
 802d482:	68f8      	ldr	r0, [r7, #12]
 802d484:	f7ff fe00 	bl	802d088 <lv_label_get_style>
 802d488:	4602      	mov	r2, r0
 802d48a:	693b      	ldr	r3, [r7, #16]
 802d48c:	605a      	str	r2, [r3, #4]
        if(info->result != NULL) return LV_RES_OK;
 802d48e:	693b      	ldr	r3, [r7, #16]
 802d490:	685b      	ldr	r3, [r3, #4]
 802d492:	2b00      	cmp	r3, #0
 802d494:	d001      	beq.n	802d49a <lv_label_signal+0x36>
 802d496:	2301      	movs	r3, #1
 802d498:	e084      	b.n	802d5a4 <lv_label_signal+0x140>
        else return ancestor_signal(label, sign, param);
 802d49a:	4b44      	ldr	r3, [pc, #272]	; (802d5ac <lv_label_signal+0x148>)
 802d49c:	681b      	ldr	r3, [r3, #0]
 802d49e:	7af9      	ldrb	r1, [r7, #11]
 802d4a0:	687a      	ldr	r2, [r7, #4]
 802d4a2:	68f8      	ldr	r0, [r7, #12]
 802d4a4:	4798      	blx	r3
 802d4a6:	4603      	mov	r3, r0
 802d4a8:	e07c      	b.n	802d5a4 <lv_label_signal+0x140>
    }

    /* Include the ancient signal function */
    res = ancestor_signal(label, sign, param);
 802d4aa:	4b40      	ldr	r3, [pc, #256]	; (802d5ac <lv_label_signal+0x148>)
 802d4ac:	681b      	ldr	r3, [r3, #0]
 802d4ae:	7af9      	ldrb	r1, [r7, #11]
 802d4b0:	687a      	ldr	r2, [r7, #4]
 802d4b2:	68f8      	ldr	r0, [r7, #12]
 802d4b4:	4798      	blx	r3
 802d4b6:	4603      	mov	r3, r0
 802d4b8:	77bb      	strb	r3, [r7, #30]
    if(res != LV_RES_OK) return res;
 802d4ba:	7fbb      	ldrb	r3, [r7, #30]
 802d4bc:	2b01      	cmp	r3, #1
 802d4be:	d001      	beq.n	802d4c4 <lv_label_signal+0x60>
 802d4c0:	7fbb      	ldrb	r3, [r7, #30]
 802d4c2:	e06f      	b.n	802d5a4 <lv_label_signal+0x140>
    if(sign == LV_SIGNAL_GET_TYPE) return lv_obj_handle_get_type_signal(param, LV_OBJX_NAME);
 802d4c4:	7afb      	ldrb	r3, [r7, #11]
 802d4c6:	2b07      	cmp	r3, #7
 802d4c8:	d105      	bne.n	802d4d6 <lv_label_signal+0x72>
 802d4ca:	4939      	ldr	r1, [pc, #228]	; (802d5b0 <lv_label_signal+0x14c>)
 802d4cc:	6878      	ldr	r0, [r7, #4]
 802d4ce:	f7de fb76 	bl	800bbbe <lv_obj_handle_get_type_signal>
 802d4d2:	4603      	mov	r3, r0
 802d4d4:	e066      	b.n	802d5a4 <lv_label_signal+0x140>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802d4d6:	68f8      	ldr	r0, [r7, #12]
 802d4d8:	f7de faba 	bl	800ba50 <lv_obj_get_ext_attr>
 802d4dc:	61b8      	str	r0, [r7, #24]
    if(sign == LV_SIGNAL_CLEANUP) {
 802d4de:	7afb      	ldrb	r3, [r7, #11]
 802d4e0:	2b00      	cmp	r3, #0
 802d4e2:	d112      	bne.n	802d50a <lv_label_signal+0xa6>
        if(ext->static_txt == 0) {
 802d4e4:	69bb      	ldr	r3, [r7, #24]
 802d4e6:	7c9b      	ldrb	r3, [r3, #18]
 802d4e8:	f003 0308 	and.w	r3, r3, #8
 802d4ec:	b2db      	uxtb	r3, r3
 802d4ee:	2b00      	cmp	r3, #0
 802d4f0:	d107      	bne.n	802d502 <lv_label_signal+0x9e>
            lv_mem_free(ext->text);
 802d4f2:	69bb      	ldr	r3, [r7, #24]
 802d4f4:	681b      	ldr	r3, [r3, #0]
 802d4f6:	4618      	mov	r0, r3
 802d4f8:	f7f3 fbb6 	bl	8020c68 <lv_mem_free>
            ext->text = NULL;
 802d4fc:	69bb      	ldr	r3, [r7, #24]
 802d4fe:	2200      	movs	r2, #0
 802d500:	601a      	str	r2, [r3, #0]
        }
        lv_label_dot_tmp_free(label);
 802d502:	68f8      	ldr	r0, [r7, #12]
 802d504:	f000 fd72 	bl	802dfec <lv_label_dot_tmp_free>
 802d508:	e04b      	b.n	802d5a2 <lv_label_signal+0x13e>
    }
    else if(sign == LV_SIGNAL_STYLE_CHG) {
 802d50a:	7afb      	ldrb	r3, [r7, #11]
 802d50c:	2b04      	cmp	r3, #4
 802d50e:	d106      	bne.n	802d51e <lv_label_signal+0xba>
        /*Revert dots for proper refresh*/
        lv_label_revert_dots(label);
 802d510:	68f8      	ldr	r0, [r7, #12]
 802d512:	f000 fc8f 	bl	802de34 <lv_label_revert_dots>
        lv_label_refr_text(label);
 802d516:	68f8      	ldr	r0, [r7, #12]
 802d518:	f000 f84c 	bl	802d5b4 <lv_label_refr_text>
 802d51c:	e041      	b.n	802d5a2 <lv_label_signal+0x13e>
    }
    else if(sign == LV_SIGNAL_COORD_CHG) {
 802d51e:	7afb      	ldrb	r3, [r7, #11]
 802d520:	2b02      	cmp	r3, #2
 802d522:	d120      	bne.n	802d566 <lv_label_signal+0x102>
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
 802d524:	68fb      	ldr	r3, [r7, #12]
 802d526:	3310      	adds	r3, #16
 802d528:	4618      	mov	r0, r3
 802d52a:	f7fe fe5d 	bl	802c1e8 <lv_area_get_width>
 802d52e:	4603      	mov	r3, r0
 802d530:	461c      	mov	r4, r3
 802d532:	6878      	ldr	r0, [r7, #4]
 802d534:	f7fe fe58 	bl	802c1e8 <lv_area_get_width>
 802d538:	4603      	mov	r3, r0
 802d53a:	429c      	cmp	r4, r3
 802d53c:	d10c      	bne.n	802d558 <lv_label_signal+0xf4>
           lv_area_get_height(&label->coords) != lv_area_get_height(param)) {
 802d53e:	68fb      	ldr	r3, [r7, #12]
 802d540:	3310      	adds	r3, #16
 802d542:	4618      	mov	r0, r3
 802d544:	f7fe fe67 	bl	802c216 <lv_area_get_height>
 802d548:	4603      	mov	r3, r0
 802d54a:	461c      	mov	r4, r3
 802d54c:	6878      	ldr	r0, [r7, #4]
 802d54e:	f7fe fe62 	bl	802c216 <lv_area_get_height>
 802d552:	4603      	mov	r3, r0
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
 802d554:	429c      	cmp	r4, r3
 802d556:	d024      	beq.n	802d5a2 <lv_label_signal+0x13e>
            lv_label_revert_dots(label);
 802d558:	68f8      	ldr	r0, [r7, #12]
 802d55a:	f000 fc6b 	bl	802de34 <lv_label_revert_dots>
            lv_label_refr_text(label);
 802d55e:	68f8      	ldr	r0, [r7, #12]
 802d560:	f000 f828 	bl	802d5b4 <lv_label_refr_text>
 802d564:	e01d      	b.n	802d5a2 <lv_label_signal+0x13e>
        }
    }
    else if(sign == LV_SIGNAL_BASE_DIR_CHG) {
 802d566:	7afb      	ldrb	r3, [r7, #11]
 802d568:	2b05      	cmp	r3, #5
 802d56a:	d01a      	beq.n	802d5a2 <lv_label_signal+0x13e>
#if LV_USE_BIDI
        if(ext->static_txt == 0) lv_label_set_text(label, NULL);
#endif
    }
    else if(sign == LV_SIGNAL_GET_TYPE) {
 802d56c:	7afb      	ldrb	r3, [r7, #11]
 802d56e:	2b07      	cmp	r3, #7
 802d570:	d117      	bne.n	802d5a2 <lv_label_signal+0x13e>
        lv_obj_type_t * buf = param;
 802d572:	687b      	ldr	r3, [r7, #4]
 802d574:	617b      	str	r3, [r7, #20]
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 802d576:	2300      	movs	r3, #0
 802d578:	77fb      	strb	r3, [r7, #31]
 802d57a:	e008      	b.n	802d58e <lv_label_signal+0x12a>
            if(buf->type[i] == NULL) break;
 802d57c:	7ffa      	ldrb	r2, [r7, #31]
 802d57e:	697b      	ldr	r3, [r7, #20]
 802d580:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802d584:	2b00      	cmp	r3, #0
 802d586:	d006      	beq.n	802d596 <lv_label_signal+0x132>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 802d588:	7ffb      	ldrb	r3, [r7, #31]
 802d58a:	3301      	adds	r3, #1
 802d58c:	77fb      	strb	r3, [r7, #31]
 802d58e:	7ffb      	ldrb	r3, [r7, #31]
 802d590:	2b06      	cmp	r3, #6
 802d592:	d9f3      	bls.n	802d57c <lv_label_signal+0x118>
 802d594:	e000      	b.n	802d598 <lv_label_signal+0x134>
            if(buf->type[i] == NULL) break;
 802d596:	bf00      	nop
        }
        buf->type[i] = "lv_label";
 802d598:	7ffa      	ldrb	r2, [r7, #31]
 802d59a:	697b      	ldr	r3, [r7, #20]
 802d59c:	4904      	ldr	r1, [pc, #16]	; (802d5b0 <lv_label_signal+0x14c>)
 802d59e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    return res;
 802d5a2:	7fbb      	ldrb	r3, [r7, #30]
}
 802d5a4:	4618      	mov	r0, r3
 802d5a6:	3724      	adds	r7, #36	; 0x24
 802d5a8:	46bd      	mov	sp, r7
 802d5aa:	bd90      	pop	{r4, r7, pc}
 802d5ac:	20012364 	.word	0x20012364
 802d5b0:	0802e620 	.word	0x0802e620

0802d5b4 <lv_label_refr_text>:
/**
 * Refresh the label with its text stored in its extended data
 * @param label pointer to a label object
 */
static void lv_label_refr_text(lv_obj_t * label)
{
 802d5b4:	b590      	push	{r4, r7, lr}
 802d5b6:	b0b3      	sub	sp, #204	; 0xcc
 802d5b8:	af04      	add	r7, sp, #16
 802d5ba:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802d5bc:	6878      	ldr	r0, [r7, #4]
 802d5be:	f7de fa47 	bl	800ba50 <lv_obj_get_ext_attr>
 802d5c2:	f8c7 0094 	str.w	r0, [r7, #148]	; 0x94

    if(ext->text == NULL) return;
 802d5c6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d5ca:	681b      	ldr	r3, [r3, #0]
 802d5cc:	2b00      	cmp	r3, #0
 802d5ce:	f000 842c 	beq.w	802de2a <lv_label_refr_text+0x876>
#if LV_LABEL_LONG_TXT_HINT
    ext->hint.line_start = -1; /*The hint is invalid if the text changes*/
#endif

    lv_area_t txt_coords;
    get_txt_coords(label, &txt_coords);
 802d5d2:	f107 0358 	add.w	r3, r7, #88	; 0x58
 802d5d6:	4619      	mov	r1, r3
 802d5d8:	6878      	ldr	r0, [r7, #4]
 802d5da:	f000 fd2b 	bl	802e034 <get_txt_coords>
    lv_coord_t max_w         = lv_area_get_width(&txt_coords);
 802d5de:	f107 0358 	add.w	r3, r7, #88	; 0x58
 802d5e2:	4618      	mov	r0, r3
 802d5e4:	f7fe fe00 	bl	802c1e8 <lv_area_get_width>
 802d5e8:	4603      	mov	r3, r0
 802d5ea:	f8a7 3092 	strh.w	r3, [r7, #146]	; 0x92
    const lv_font_t * font   = lv_obj_get_style_text_font(label, LV_LABEL_PART_MAIN);
 802d5ee:	2100      	movs	r1, #0
 802d5f0:	6878      	ldr	r0, [r7, #4]
 802d5f2:	f7fe ff3e 	bl	802c472 <lv_obj_get_style_text_font>
 802d5f6:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c
    lv_style_int_t line_space = lv_obj_get_style_text_line_space(label, LV_LABEL_PART_MAIN);
 802d5fa:	2100      	movs	r1, #0
 802d5fc:	6878      	ldr	r0, [r7, #4]
 802d5fe:	f7fe ff26 	bl	802c44e <lv_obj_get_style_text_line_space>
 802d602:	4603      	mov	r3, r0
 802d604:	f8a7 308a 	strh.w	r3, [r7, #138]	; 0x8a
    lv_style_int_t letter_space = lv_obj_get_style_text_letter_space(label, LV_LABEL_PART_MAIN);
 802d608:	2100      	movs	r1, #0
 802d60a:	6878      	ldr	r0, [r7, #4]
 802d60c:	f7fe ff0d 	bl	802c42a <lv_obj_get_style_text_letter_space>
 802d610:	4603      	mov	r3, r0
 802d612:	f8a7 3088 	strh.w	r3, [r7, #136]	; 0x88

    /*Calc. the height and longest line*/
    lv_point_t size;
    lv_txt_flag_t flag = LV_TXT_FLAG_NONE;
 802d616:	2300      	movs	r3, #0
 802d618:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 802d61c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d620:	7c9b      	ldrb	r3, [r3, #18]
 802d622:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802d626:	b2db      	uxtb	r3, r3
 802d628:	2b00      	cmp	r3, #0
 802d62a:	d005      	beq.n	802d638 <lv_label_refr_text+0x84>
 802d62c:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 802d630:	f043 0301 	orr.w	r3, r3, #1
 802d634:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 802d638:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d63c:	7c9b      	ldrb	r3, [r3, #18]
 802d63e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 802d642:	b2db      	uxtb	r3, r3
 802d644:	2b00      	cmp	r3, #0
 802d646:	d005      	beq.n	802d654 <lv_label_refr_text+0xa0>
 802d648:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 802d64c:	f043 0302 	orr.w	r3, r3, #2
 802d650:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) flag |= LV_TXT_FLAG_FIT;
 802d654:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d658:	7c9b      	ldrb	r3, [r3, #18]
 802d65a:	f003 0307 	and.w	r3, r3, #7
 802d65e:	b2db      	uxtb	r3, r3
 802d660:	2b00      	cmp	r3, #0
 802d662:	d105      	bne.n	802d670 <lv_label_refr_text+0xbc>
 802d664:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 802d668:	f043 0310 	orr.w	r3, r3, #16
 802d66c:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
    _lv_txt_get_size(&size, ext->text, font, letter_space, line_space, max_w, flag);
 802d670:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d674:	6819      	ldr	r1, [r3, #0]
 802d676:	f9b7 2088 	ldrsh.w	r2, [r7, #136]	; 0x88
 802d67a:	f107 0054 	add.w	r0, r7, #84	; 0x54
 802d67e:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
 802d682:	9302      	str	r3, [sp, #8]
 802d684:	f9b7 3092 	ldrsh.w	r3, [r7, #146]	; 0x92
 802d688:	9301      	str	r3, [sp, #4]
 802d68a:	f9b7 308a 	ldrsh.w	r3, [r7, #138]	; 0x8a
 802d68e:	9300      	str	r3, [sp, #0]
 802d690:	4613      	mov	r3, r2
 802d692:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 802d696:	f7f4 fcf9 	bl	802208c <_lv_txt_get_size>

    /*Set the full size in expand mode*/
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
 802d69a:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d69e:	7c9b      	ldrb	r3, [r3, #18]
 802d6a0:	f003 0307 	and.w	r3, r3, #7
 802d6a4:	b2db      	uxtb	r3, r3
 802d6a6:	2b00      	cmp	r3, #0
 802d6a8:	d132      	bne.n	802d710 <lv_label_refr_text+0x15c>
        size.x += lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_right(label, LV_LABEL_PART_MAIN);
 802d6aa:	2100      	movs	r1, #0
 802d6ac:	6878      	ldr	r0, [r7, #4]
 802d6ae:	f7fe fe9a 	bl	802c3e6 <lv_obj_get_style_pad_left>
 802d6b2:	4603      	mov	r3, r0
 802d6b4:	461c      	mov	r4, r3
 802d6b6:	2100      	movs	r1, #0
 802d6b8:	6878      	ldr	r0, [r7, #4]
 802d6ba:	f7fe fea5 	bl	802c408 <lv_obj_get_style_pad_right>
 802d6be:	4603      	mov	r3, r0
 802d6c0:	4423      	add	r3, r4
 802d6c2:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 802d6c6:	b292      	uxth	r2, r2
 802d6c8:	b29b      	uxth	r3, r3
 802d6ca:	4413      	add	r3, r2
 802d6cc:	b29b      	uxth	r3, r3
 802d6ce:	b21b      	sxth	r3, r3
 802d6d0:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
 802d6d4:	2100      	movs	r1, #0
 802d6d6:	6878      	ldr	r0, [r7, #4]
 802d6d8:	f7fe fe63 	bl	802c3a2 <lv_obj_get_style_pad_top>
 802d6dc:	4603      	mov	r3, r0
 802d6de:	461c      	mov	r4, r3
 802d6e0:	2100      	movs	r1, #0
 802d6e2:	6878      	ldr	r0, [r7, #4]
 802d6e4:	f7fe fe6e 	bl	802c3c4 <lv_obj_get_style_pad_bottom>
 802d6e8:	4603      	mov	r3, r0
 802d6ea:	4423      	add	r3, r4
 802d6ec:	f9b7 2056 	ldrsh.w	r2, [r7, #86]	; 0x56
 802d6f0:	b292      	uxth	r2, r2
 802d6f2:	b29b      	uxth	r3, r3
 802d6f4:	4413      	add	r3, r2
 802d6f6:	b29b      	uxth	r3, r3
 802d6f8:	b21b      	sxth	r3, r3
 802d6fa:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
        lv_obj_set_size(label, size.x, size.y);
 802d6fe:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 802d702:	f9b7 2056 	ldrsh.w	r2, [r7, #86]	; 0x56
 802d706:	4619      	mov	r1, r3
 802d708:	6878      	ldr	r0, [r7, #4]
 802d70a:	f7dc fb9b 	bl	8009e44 <lv_obj_set_size>
 802d70e:	e388      	b.n	802de22 <lv_label_refr_text+0x86e>
    }
    /*In roll mode keep the size but start offset animations*/
    else if(ext->long_mode == LV_LABEL_LONG_SROLL) {
 802d710:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d714:	7c9b      	ldrb	r3, [r3, #18]
 802d716:	f003 0307 	and.w	r3, r3, #7
 802d71a:	b2db      	uxtb	r3, r3
 802d71c:	2b03      	cmp	r3, #3
 802d71e:	f040 815e 	bne.w	802d9de <lv_label_refr_text+0x42a>
#if LV_USE_ANIMATION
        lv_anim_t a;
        lv_anim_init(&a);
 802d722:	f107 0308 	add.w	r3, r7, #8
 802d726:	4618      	mov	r0, r3
 802d728:	f7f1 fb62 	bl	801edf0 <lv_anim_init>
        lv_anim_set_var(&a, label);
 802d72c:	f107 0308 	add.w	r3, r7, #8
 802d730:	6879      	ldr	r1, [r7, #4]
 802d732:	4618      	mov	r0, r3
 802d734:	f7fe fd93 	bl	802c25e <lv_anim_set_var>
        lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);
 802d738:	f107 0308 	add.w	r3, r7, #8
 802d73c:	f64f 71ff 	movw	r1, #65535	; 0xffff
 802d740:	4618      	mov	r0, r3
 802d742:	f7fe fdee 	bl	802c322 <lv_anim_set_repeat_count>
        lv_anim_set_playback_delay(&a, (((lv_font_get_glyph_width(font, ' ', ' ') + letter_space) * 1000) /
 802d746:	2220      	movs	r2, #32
 802d748:	2120      	movs	r1, #32
 802d74a:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 802d74e:	f7f0 f9bd 	bl	801dacc <lv_font_get_glyph_width>
 802d752:	4603      	mov	r3, r0
 802d754:	461a      	mov	r2, r3
 802d756:	f9b7 3088 	ldrsh.w	r3, [r7, #136]	; 0x88
 802d75a:	4413      	add	r3, r2
 802d75c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 802d760:	fb02 f303 	mul.w	r3, r2, r3
                                        ext->anim_speed) *
 802d764:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 802d768:	8992      	ldrh	r2, [r2, #12]
        lv_anim_set_playback_delay(&a, (((lv_font_get_glyph_width(font, ' ', ' ') + letter_space) * 1000) /
 802d76a:	fb93 f3f2 	sdiv	r3, r3, r2
 802d76e:	b29b      	uxth	r3, r3
 802d770:	461a      	mov	r2, r3
 802d772:	0052      	lsls	r2, r2, #1
 802d774:	4413      	add	r3, r2
 802d776:	b29a      	uxth	r2, r3
 802d778:	f107 0308 	add.w	r3, r7, #8
 802d77c:	4611      	mov	r1, r2
 802d77e:	4618      	mov	r0, r3
 802d780:	f7fe fdc0 	bl	802c304 <lv_anim_set_playback_delay>
                                   LV_LABEL_WAIT_CHAR_COUNT);
        lv_anim_set_repeat_delay(&a, a.playback_delay);
 802d784:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802d786:	b29a      	uxth	r2, r3
 802d788:	f107 0308 	add.w	r3, r7, #8
 802d78c:	4611      	mov	r1, r2
 802d78e:	4618      	mov	r0, r3
 802d790:	f7fe fdd6 	bl	802c340 <lv_anim_set_repeat_delay>

        bool hor_anim = false;
 802d794:	2300      	movs	r3, #0
 802d796:	f887 30b6 	strb.w	r3, [r7, #182]	; 0xb6
        if(size.x > lv_area_get_width(&txt_coords)) {
 802d79a:	f9b7 4054 	ldrsh.w	r4, [r7, #84]	; 0x54
 802d79e:	f107 0358 	add.w	r3, r7, #88	; 0x58
 802d7a2:	4618      	mov	r0, r3
 802d7a4:	f7fe fd20 	bl	802c1e8 <lv_area_get_width>
 802d7a8:	4603      	mov	r3, r0
 802d7aa:	429c      	cmp	r4, r3
 802d7ac:	dd77      	ble.n	802d89e <lv_label_refr_text+0x2ea>
            lv_anim_set_values(&a, 0, lv_area_get_width(&txt_coords) - size.x);
 802d7ae:	f107 0358 	add.w	r3, r7, #88	; 0x58
 802d7b2:	4618      	mov	r0, r3
 802d7b4:	f7fe fd18 	bl	802c1e8 <lv_area_get_width>
 802d7b8:	4603      	mov	r3, r0
 802d7ba:	b29a      	uxth	r2, r3
 802d7bc:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 802d7c0:	b29b      	uxth	r3, r3
 802d7c2:	1ad3      	subs	r3, r2, r3
 802d7c4:	b29b      	uxth	r3, r3
 802d7c6:	b21a      	sxth	r2, r3
 802d7c8:	f107 0308 	add.w	r3, r7, #8
 802d7cc:	2100      	movs	r1, #0
 802d7ce:	4618      	mov	r0, r3
 802d7d0:	f7fe fd6f 	bl	802c2b2 <lv_anim_set_values>
            lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 802d7d4:	f107 0308 	add.w	r3, r7, #8
 802d7d8:	49bd      	ldr	r1, [pc, #756]	; (802dad0 <lv_label_refr_text+0x51c>)
 802d7da:	4618      	mov	r0, r3
 802d7dc:	f7fe fd4d 	bl	802c27a <lv_anim_set_exec_cb>
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
 802d7e0:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d7e4:	899b      	ldrh	r3, [r3, #12]
 802d7e6:	6a3a      	ldr	r2, [r7, #32]
 802d7e8:	b211      	sxth	r1, r2
 802d7ea:	6aba      	ldr	r2, [r7, #40]	; 0x28
 802d7ec:	b212      	sxth	r2, r2
 802d7ee:	4618      	mov	r0, r3
 802d7f0:	f7f1 fbea 	bl	801efc8 <lv_anim_speed_to_time>
 802d7f4:	4603      	mov	r3, r0
 802d7f6:	461a      	mov	r2, r3
 802d7f8:	f107 0308 	add.w	r3, r7, #8
 802d7fc:	4611      	mov	r1, r2
 802d7fe:	4618      	mov	r0, r3
 802d800:	f7fe fd49 	bl	802c296 <lv_anim_set_time>
            lv_anim_set_playback_time(&a, a.time);
 802d804:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802d806:	b29a      	uxth	r2, r3
 802d808:	f107 0308 	add.w	r3, r7, #8
 802d80c:	4611      	mov	r1, r2
 802d80e:	4618      	mov	r0, r3
 802d810:	f7fe fd69 	bl	802c2e6 <lv_anim_set_playback_time>

            lv_anim_t * anim_cur = lv_anim_get(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 802d814:	49ae      	ldr	r1, [pc, #696]	; (802dad0 <lv_label_refr_text+0x51c>)
 802d816:	6878      	ldr	r0, [r7, #4]
 802d818:	f7f1 fbb0 	bl	801ef7c <lv_anim_get>
 802d81c:	66f8      	str	r0, [r7, #108]	; 0x6c
            int32_t act_time = 0;
 802d81e:	2300      	movs	r3, #0
 802d820:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
            bool playback_now = false;
 802d824:	2300      	movs	r3, #0
 802d826:	f887 30af 	strb.w	r3, [r7, #175]	; 0xaf
            if(anim_cur) {
 802d82a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 802d82c:	2b00      	cmp	r3, #0
 802d82e:	d00f      	beq.n	802d850 <lv_label_refr_text+0x29c>
                act_time = anim_cur->act_time;
 802d830:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 802d832:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802d834:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
                playback_now = anim_cur->playback_now;
 802d838:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 802d83a:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 802d83e:	f3c3 0300 	ubfx	r3, r3, #0, #1
 802d842:	b2db      	uxtb	r3, r3
 802d844:	2b00      	cmp	r3, #0
 802d846:	bf14      	ite	ne
 802d848:	2301      	movne	r3, #1
 802d84a:	2300      	moveq	r3, #0
 802d84c:	f887 30af 	strb.w	r3, [r7, #175]	; 0xaf
            }
            if(act_time < a.time) {
 802d850:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802d852:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 802d856:	429a      	cmp	r2, r3
 802d858:	da18      	bge.n	802d88c <lv_label_refr_text+0x2d8>
                a.act_time = act_time;      /*To keep the old position*/
 802d85a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 802d85e:	633b      	str	r3, [r7, #48]	; 0x30
                a.early_apply = 0;
 802d860:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 802d864:	f36f 0300 	bfc	r3, #0, #1
 802d868:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
                if(playback_now) {
 802d86c:	f897 30af 	ldrb.w	r3, [r7, #175]	; 0xaf
 802d870:	2b00      	cmp	r3, #0
 802d872:	d00b      	beq.n	802d88c <lv_label_refr_text+0x2d8>
                    a.playback_now = 1;
 802d874:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 802d878:	f043 0301 	orr.w	r3, r3, #1
 802d87c:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
                    /*Swap the start and end values*/
                    int32_t tmp;
                    tmp      = a.start;
 802d880:	6a3b      	ldr	r3, [r7, #32]
 802d882:	66bb      	str	r3, [r7, #104]	; 0x68
                    a.start = a.end;
 802d884:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802d886:	623b      	str	r3, [r7, #32]
                    a.end   = tmp;
 802d888:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 802d88a:	62bb      	str	r3, [r7, #40]	; 0x28
                }
            }

            lv_anim_start(&a);
 802d88c:	f107 0308 	add.w	r3, r7, #8
 802d890:	4618      	mov	r0, r3
 802d892:	f7f1 fad7 	bl	801ee44 <lv_anim_start>
            hor_anim = true;
 802d896:	2301      	movs	r3, #1
 802d898:	f887 30b6 	strb.w	r3, [r7, #182]	; 0xb6
 802d89c:	e007      	b.n	802d8ae <lv_label_refr_text+0x2fa>
        }
        else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 802d89e:	498c      	ldr	r1, [pc, #560]	; (802dad0 <lv_label_refr_text+0x51c>)
 802d8a0:	6878      	ldr	r0, [r7, #4]
 802d8a2:	f7f1 fb35 	bl	801ef10 <lv_anim_del>
            ext->offset.x = 0;
 802d8a6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d8aa:	2200      	movs	r2, #0
 802d8ac:	81da      	strh	r2, [r3, #14]
        }

        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {
 802d8ae:	f9b7 4056 	ldrsh.w	r4, [r7, #86]	; 0x56
 802d8b2:	f107 0358 	add.w	r3, r7, #88	; 0x58
 802d8b6:	4618      	mov	r0, r3
 802d8b8:	f7fe fcad 	bl	802c216 <lv_area_get_height>
 802d8bc:	4603      	mov	r3, r0
 802d8be:	429c      	cmp	r4, r3
 802d8c0:	f340 8084 	ble.w	802d9cc <lv_label_refr_text+0x418>
 802d8c4:	f897 30b6 	ldrb.w	r3, [r7, #182]	; 0xb6
 802d8c8:	f083 0301 	eor.w	r3, r3, #1
 802d8cc:	b2db      	uxtb	r3, r3
 802d8ce:	2b00      	cmp	r3, #0
 802d8d0:	d07c      	beq.n	802d9cc <lv_label_refr_text+0x418>
            lv_anim_set_values(&a, 0, lv_area_get_height(&txt_coords) - size.y - (lv_font_get_line_height(font)));
 802d8d2:	f107 0358 	add.w	r3, r7, #88	; 0x58
 802d8d6:	4618      	mov	r0, r3
 802d8d8:	f7fe fc9d 	bl	802c216 <lv_area_get_height>
 802d8dc:	4603      	mov	r3, r0
 802d8de:	b29a      	uxth	r2, r3
 802d8e0:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 802d8e4:	b29b      	uxth	r3, r3
 802d8e6:	1ad3      	subs	r3, r2, r3
 802d8e8:	b29c      	uxth	r4, r3
 802d8ea:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 802d8ee:	f7fe fca9 	bl	802c244 <lv_font_get_line_height>
 802d8f2:	4603      	mov	r3, r0
 802d8f4:	b29b      	uxth	r3, r3
 802d8f6:	1ae3      	subs	r3, r4, r3
 802d8f8:	b29b      	uxth	r3, r3
 802d8fa:	b21a      	sxth	r2, r3
 802d8fc:	f107 0308 	add.w	r3, r7, #8
 802d900:	2100      	movs	r1, #0
 802d902:	4618      	mov	r0, r3
 802d904:	f7fe fcd5 	bl	802c2b2 <lv_anim_set_values>
            lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 802d908:	f107 0308 	add.w	r3, r7, #8
 802d90c:	4971      	ldr	r1, [pc, #452]	; (802dad4 <lv_label_refr_text+0x520>)
 802d90e:	4618      	mov	r0, r3
 802d910:	f7fe fcb3 	bl	802c27a <lv_anim_set_exec_cb>
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
 802d914:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d918:	899b      	ldrh	r3, [r3, #12]
 802d91a:	6a3a      	ldr	r2, [r7, #32]
 802d91c:	b211      	sxth	r1, r2
 802d91e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 802d920:	b212      	sxth	r2, r2
 802d922:	4618      	mov	r0, r3
 802d924:	f7f1 fb50 	bl	801efc8 <lv_anim_speed_to_time>
 802d928:	4603      	mov	r3, r0
 802d92a:	461a      	mov	r2, r3
 802d92c:	f107 0308 	add.w	r3, r7, #8
 802d930:	4611      	mov	r1, r2
 802d932:	4618      	mov	r0, r3
 802d934:	f7fe fcaf 	bl	802c296 <lv_anim_set_time>
            lv_anim_set_playback_time(&a, a.time);
 802d938:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802d93a:	b29a      	uxth	r2, r3
 802d93c:	f107 0308 	add.w	r3, r7, #8
 802d940:	4611      	mov	r1, r2
 802d942:	4618      	mov	r0, r3
 802d944:	f7fe fccf 	bl	802c2e6 <lv_anim_set_playback_time>

            lv_anim_t * anim_cur = lv_anim_get(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 802d948:	4962      	ldr	r1, [pc, #392]	; (802dad4 <lv_label_refr_text+0x520>)
 802d94a:	6878      	ldr	r0, [r7, #4]
 802d94c:	f7f1 fb16 	bl	801ef7c <lv_anim_get>
 802d950:	6678      	str	r0, [r7, #100]	; 0x64
            int32_t act_time = 0;
 802d952:	2300      	movs	r3, #0
 802d954:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
            bool playback_now = false;
 802d958:	2300      	movs	r3, #0
 802d95a:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
            if(anim_cur) {
 802d95e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802d960:	2b00      	cmp	r3, #0
 802d962:	d00f      	beq.n	802d984 <lv_label_refr_text+0x3d0>
                act_time = anim_cur->act_time;
 802d964:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802d966:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802d968:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
                playback_now = anim_cur->playback_now;
 802d96c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802d96e:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 802d972:	f3c3 0300 	ubfx	r3, r3, #0, #1
 802d976:	b2db      	uxtb	r3, r3
 802d978:	2b00      	cmp	r3, #0
 802d97a:	bf14      	ite	ne
 802d97c:	2301      	movne	r3, #1
 802d97e:	2300      	moveq	r3, #0
 802d980:	f887 30a7 	strb.w	r3, [r7, #167]	; 0xa7
            }
            if(act_time < a.time) {
 802d984:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802d986:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 802d98a:	429a      	cmp	r2, r3
 802d98c:	da18      	bge.n	802d9c0 <lv_label_refr_text+0x40c>
                a.act_time = act_time;      /*To keep the old position*/
 802d98e:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 802d992:	633b      	str	r3, [r7, #48]	; 0x30
                a.early_apply = 0;
 802d994:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 802d998:	f36f 0300 	bfc	r3, #0, #1
 802d99c:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
                if(playback_now) {
 802d9a0:	f897 30a7 	ldrb.w	r3, [r7, #167]	; 0xa7
 802d9a4:	2b00      	cmp	r3, #0
 802d9a6:	d00b      	beq.n	802d9c0 <lv_label_refr_text+0x40c>
                    a.playback_now = 1;
 802d9a8:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 802d9ac:	f043 0301 	orr.w	r3, r3, #1
 802d9b0:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
                    /*Swap the start and end values*/
                    int32_t tmp;
                    tmp      = a.start;
 802d9b4:	6a3b      	ldr	r3, [r7, #32]
 802d9b6:	663b      	str	r3, [r7, #96]	; 0x60
                    a.start = a.end;
 802d9b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802d9ba:	623b      	str	r3, [r7, #32]
                    a.end   = tmp;
 802d9bc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 802d9be:	62bb      	str	r3, [r7, #40]	; 0x28
                }
            }

            lv_anim_start(&a);
 802d9c0:	f107 0308 	add.w	r3, r7, #8
 802d9c4:	4618      	mov	r0, r3
 802d9c6:	f7f1 fa3d 	bl	801ee44 <lv_anim_start>
        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {
 802d9ca:	e22a      	b.n	802de22 <lv_label_refr_text+0x86e>
        }
        else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 802d9cc:	4941      	ldr	r1, [pc, #260]	; (802dad4 <lv_label_refr_text+0x520>)
 802d9ce:	6878      	ldr	r0, [r7, #4]
 802d9d0:	f7f1 fa9e 	bl	801ef10 <lv_anim_del>
            ext->offset.y = 0;
 802d9d4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d9d8:	2200      	movs	r2, #0
 802d9da:	821a      	strh	r2, [r3, #16]
 802d9dc:	e221      	b.n	802de22 <lv_label_refr_text+0x86e>
        }
#endif
    }
    /*In roll inf. mode keep the size but start offset animations*/
    else if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
 802d9de:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802d9e2:	7c9b      	ldrb	r3, [r3, #18]
 802d9e4:	f003 0307 	and.w	r3, r3, #7
 802d9e8:	b2db      	uxtb	r3, r3
 802d9ea:	2b04      	cmp	r3, #4
 802d9ec:	f040 80e1 	bne.w	802dbb2 <lv_label_refr_text+0x5fe>
#if LV_USE_ANIMATION
        lv_anim_t a;
        lv_anim_init(&a);
 802d9f0:	f107 0308 	add.w	r3, r7, #8
 802d9f4:	4618      	mov	r0, r3
 802d9f6:	f7f1 f9fb 	bl	801edf0 <lv_anim_init>
        lv_anim_set_var(&a, label);
 802d9fa:	f107 0308 	add.w	r3, r7, #8
 802d9fe:	6879      	ldr	r1, [r7, #4]
 802da00:	4618      	mov	r0, r3
 802da02:	f7fe fc2c 	bl	802c25e <lv_anim_set_var>
        lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);
 802da06:	f107 0308 	add.w	r3, r7, #8
 802da0a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 802da0e:	4618      	mov	r0, r3
 802da10:	f7fe fc87 	bl	802c322 <lv_anim_set_repeat_count>

        bool hor_anim = false;
 802da14:	2300      	movs	r3, #0
 802da16:	f887 30a6 	strb.w	r3, [r7, #166]	; 0xa6
        if(size.x > lv_area_get_width(&txt_coords)) {
 802da1a:	f9b7 4054 	ldrsh.w	r4, [r7, #84]	; 0x54
 802da1e:	f107 0358 	add.w	r3, r7, #88	; 0x58
 802da22:	4618      	mov	r0, r3
 802da24:	f7fe fbe0 	bl	802c1e8 <lv_area_get_width>
 802da28:	4603      	mov	r3, r0
 802da2a:	429c      	cmp	r4, r3
 802da2c:	dd54      	ble.n	802dad8 <lv_label_refr_text+0x524>
            lv_anim_set_values(&a, 0, -size.x - lv_font_get_glyph_width(font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT);
 802da2e:	2220      	movs	r2, #32
 802da30:	2120      	movs	r1, #32
 802da32:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 802da36:	f7f0 f849 	bl	801dacc <lv_font_get_glyph_width>
 802da3a:	4603      	mov	r3, r0
 802da3c:	461a      	mov	r2, r3
 802da3e:	009b      	lsls	r3, r3, #2
 802da40:	1ad3      	subs	r3, r2, r3
 802da42:	b29a      	uxth	r2, r3
 802da44:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 802da48:	b29b      	uxth	r3, r3
 802da4a:	1ad3      	subs	r3, r2, r3
 802da4c:	b29b      	uxth	r3, r3
 802da4e:	b21a      	sxth	r2, r3
 802da50:	f107 0308 	add.w	r3, r7, #8
 802da54:	2100      	movs	r1, #0
 802da56:	4618      	mov	r0, r3
 802da58:	f7fe fc2b 	bl	802c2b2 <lv_anim_set_values>
            lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 802da5c:	f107 0308 	add.w	r3, r7, #8
 802da60:	491b      	ldr	r1, [pc, #108]	; (802dad0 <lv_label_refr_text+0x51c>)
 802da62:	4618      	mov	r0, r3
 802da64:	f7fe fc09 	bl	802c27a <lv_anim_set_exec_cb>
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
 802da68:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802da6c:	899b      	ldrh	r3, [r3, #12]
 802da6e:	6a3a      	ldr	r2, [r7, #32]
 802da70:	b211      	sxth	r1, r2
 802da72:	6aba      	ldr	r2, [r7, #40]	; 0x28
 802da74:	b212      	sxth	r2, r2
 802da76:	4618      	mov	r0, r3
 802da78:	f7f1 faa6 	bl	801efc8 <lv_anim_speed_to_time>
 802da7c:	4603      	mov	r3, r0
 802da7e:	461a      	mov	r2, r3
 802da80:	f107 0308 	add.w	r3, r7, #8
 802da84:	4611      	mov	r1, r2
 802da86:	4618      	mov	r0, r3
 802da88:	f7fe fc05 	bl	802c296 <lv_anim_set_time>

            lv_anim_t * anim_cur = lv_anim_get(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 802da8c:	4910      	ldr	r1, [pc, #64]	; (802dad0 <lv_label_refr_text+0x51c>)
 802da8e:	6878      	ldr	r0, [r7, #4]
 802da90:	f7f1 fa74 	bl	801ef7c <lv_anim_get>
 802da94:	67f8      	str	r0, [r7, #124]	; 0x7c
            int32_t act_time = anim_cur ? anim_cur->act_time : 0;
 802da96:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 802da98:	2b00      	cmp	r3, #0
 802da9a:	d002      	beq.n	802daa2 <lv_label_refr_text+0x4ee>
 802da9c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 802da9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802daa0:	e000      	b.n	802daa4 <lv_label_refr_text+0x4f0>
 802daa2:	2300      	movs	r3, #0
 802daa4:	67bb      	str	r3, [r7, #120]	; 0x78
            if(act_time < a.time) {
 802daa6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802daa8:	6fba      	ldr	r2, [r7, #120]	; 0x78
 802daaa:	429a      	cmp	r2, r3
 802daac:	da07      	bge.n	802dabe <lv_label_refr_text+0x50a>
                a.act_time = act_time;      /*To keep the old position*/
 802daae:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 802dab0:	633b      	str	r3, [r7, #48]	; 0x30
                a.early_apply = 0;
 802dab2:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 802dab6:	f36f 0300 	bfc	r3, #0, #1
 802daba:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
            }

            lv_anim_start(&a);
 802dabe:	f107 0308 	add.w	r3, r7, #8
 802dac2:	4618      	mov	r0, r3
 802dac4:	f7f1 f9be 	bl	801ee44 <lv_anim_start>
            hor_anim = true;
 802dac8:	2301      	movs	r3, #1
 802daca:	f887 30a6 	strb.w	r3, [r7, #166]	; 0xa6
 802dace:	e00b      	b.n	802dae8 <lv_label_refr_text+0x534>
 802dad0:	0802dee9 	.word	0x0802dee9
 802dad4:	0802df11 	.word	0x0802df11
        }
        else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 802dad8:	49ba      	ldr	r1, [pc, #744]	; (802ddc4 <lv_label_refr_text+0x810>)
 802dada:	6878      	ldr	r0, [r7, #4]
 802dadc:	f7f1 fa18 	bl	801ef10 <lv_anim_del>
            ext->offset.x = 0;
 802dae0:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802dae4:	2200      	movs	r2, #0
 802dae6:	81da      	strh	r2, [r3, #14]
        }

        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {
 802dae8:	f9b7 4056 	ldrsh.w	r4, [r7, #86]	; 0x56
 802daec:	f107 0358 	add.w	r3, r7, #88	; 0x58
 802daf0:	4618      	mov	r0, r3
 802daf2:	f7fe fb90 	bl	802c216 <lv_area_get_height>
 802daf6:	4603      	mov	r3, r0
 802daf8:	429c      	cmp	r4, r3
 802dafa:	dd51      	ble.n	802dba0 <lv_label_refr_text+0x5ec>
 802dafc:	f897 30a6 	ldrb.w	r3, [r7, #166]	; 0xa6
 802db00:	f083 0301 	eor.w	r3, r3, #1
 802db04:	b2db      	uxtb	r3, r3
 802db06:	2b00      	cmp	r3, #0
 802db08:	d04a      	beq.n	802dba0 <lv_label_refr_text+0x5ec>
            lv_anim_set_values(&a, 0, -size.y - (lv_font_get_line_height(font)));
 802db0a:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 802db0e:	b29b      	uxth	r3, r3
 802db10:	425b      	negs	r3, r3
 802db12:	b29c      	uxth	r4, r3
 802db14:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 802db18:	f7fe fb94 	bl	802c244 <lv_font_get_line_height>
 802db1c:	4603      	mov	r3, r0
 802db1e:	b29b      	uxth	r3, r3
 802db20:	1ae3      	subs	r3, r4, r3
 802db22:	b29b      	uxth	r3, r3
 802db24:	b21a      	sxth	r2, r3
 802db26:	f107 0308 	add.w	r3, r7, #8
 802db2a:	2100      	movs	r1, #0
 802db2c:	4618      	mov	r0, r3
 802db2e:	f7fe fbc0 	bl	802c2b2 <lv_anim_set_values>
            lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 802db32:	f107 0308 	add.w	r3, r7, #8
 802db36:	49a4      	ldr	r1, [pc, #656]	; (802ddc8 <lv_label_refr_text+0x814>)
 802db38:	4618      	mov	r0, r3
 802db3a:	f7fe fb9e 	bl	802c27a <lv_anim_set_exec_cb>
            lv_anim_set_time(&a, lv_anim_speed_to_time(ext->anim_speed, a.start, a.end));
 802db3e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802db42:	899b      	ldrh	r3, [r3, #12]
 802db44:	6a3a      	ldr	r2, [r7, #32]
 802db46:	b211      	sxth	r1, r2
 802db48:	6aba      	ldr	r2, [r7, #40]	; 0x28
 802db4a:	b212      	sxth	r2, r2
 802db4c:	4618      	mov	r0, r3
 802db4e:	f7f1 fa3b 	bl	801efc8 <lv_anim_speed_to_time>
 802db52:	4603      	mov	r3, r0
 802db54:	461a      	mov	r2, r3
 802db56:	f107 0308 	add.w	r3, r7, #8
 802db5a:	4611      	mov	r1, r2
 802db5c:	4618      	mov	r0, r3
 802db5e:	f7fe fb9a 	bl	802c296 <lv_anim_set_time>

            lv_anim_t * anim_cur = lv_anim_get(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 802db62:	4999      	ldr	r1, [pc, #612]	; (802ddc8 <lv_label_refr_text+0x814>)
 802db64:	6878      	ldr	r0, [r7, #4]
 802db66:	f7f1 fa09 	bl	801ef7c <lv_anim_get>
 802db6a:	6778      	str	r0, [r7, #116]	; 0x74
            int32_t act_time = anim_cur ? anim_cur->act_time : 0;
 802db6c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 802db6e:	2b00      	cmp	r3, #0
 802db70:	d002      	beq.n	802db78 <lv_label_refr_text+0x5c4>
 802db72:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 802db74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 802db76:	e000      	b.n	802db7a <lv_label_refr_text+0x5c6>
 802db78:	2300      	movs	r3, #0
 802db7a:	673b      	str	r3, [r7, #112]	; 0x70
            if(act_time < a.time) {
 802db7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802db7e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 802db80:	429a      	cmp	r2, r3
 802db82:	da07      	bge.n	802db94 <lv_label_refr_text+0x5e0>
                a.act_time = act_time;      /*To keep the old position*/
 802db84:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 802db86:	633b      	str	r3, [r7, #48]	; 0x30
                a.early_apply = 0;
 802db88:	f897 3042 	ldrb.w	r3, [r7, #66]	; 0x42
 802db8c:	f36f 0300 	bfc	r3, #0, #1
 802db90:	f887 3042 	strb.w	r3, [r7, #66]	; 0x42
            }

            lv_anim_start(&a);
 802db94:	f107 0308 	add.w	r3, r7, #8
 802db98:	4618      	mov	r0, r3
 802db9a:	f7f1 f953 	bl	801ee44 <lv_anim_start>
        if(size.y > lv_area_get_height(&txt_coords) && hor_anim == false) {
 802db9e:	e140      	b.n	802de22 <lv_label_refr_text+0x86e>
        }
        else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 802dba0:	4989      	ldr	r1, [pc, #548]	; (802ddc8 <lv_label_refr_text+0x814>)
 802dba2:	6878      	ldr	r0, [r7, #4]
 802dba4:	f7f1 f9b4 	bl	801ef10 <lv_anim_del>
            ext->offset.y = 0;
 802dba8:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802dbac:	2200      	movs	r2, #0
 802dbae:	821a      	strh	r2, [r3, #16]
 802dbb0:	e137      	b.n	802de22 <lv_label_refr_text+0x86e>
        }
#endif
    }
    else if(ext->long_mode == LV_LABEL_LONG_DOT) {
 802dbb2:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802dbb6:	7c9b      	ldrb	r3, [r3, #18]
 802dbb8:	f003 0307 	and.w	r3, r3, #7
 802dbbc:	b2db      	uxtb	r3, r3
 802dbbe:	2b02      	cmp	r3, #2
 802dbc0:	f040 810c 	bne.w	802dddc <lv_label_refr_text+0x828>
        if(size.y <= lv_area_get_height(&txt_coords)) { /*No dots are required, the text is short enough*/
 802dbc4:	f9b7 4056 	ldrsh.w	r4, [r7, #86]	; 0x56
 802dbc8:	f107 0358 	add.w	r3, r7, #88	; 0x58
 802dbcc:	4618      	mov	r0, r3
 802dbce:	f7fe fb22 	bl	802c216 <lv_area_get_height>
 802dbd2:	4603      	mov	r3, r0
 802dbd4:	429c      	cmp	r4, r3
 802dbd6:	dc05      	bgt.n	802dbe4 <lv_label_refr_text+0x630>
            ext->dot_end = LV_LABEL_DOT_END_INV;
 802dbd8:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802dbdc:	f64f 72ff 	movw	r2, #65535	; 0xffff
 802dbe0:	609a      	str	r2, [r3, #8]
 802dbe2:	e11e      	b.n	802de22 <lv_label_refr_text+0x86e>
        }
        else if(_lv_txt_get_encoded_length(ext->text) <= LV_LABEL_DOT_NUM) {   /*Don't turn to dots all the characters*/
 802dbe4:	4b79      	ldr	r3, [pc, #484]	; (802ddcc <lv_label_refr_text+0x818>)
 802dbe6:	681b      	ldr	r3, [r3, #0]
 802dbe8:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 802dbec:	6812      	ldr	r2, [r2, #0]
 802dbee:	4610      	mov	r0, r2
 802dbf0:	4798      	blx	r3
 802dbf2:	4603      	mov	r3, r0
 802dbf4:	2b03      	cmp	r3, #3
 802dbf6:	d805      	bhi.n	802dc04 <lv_label_refr_text+0x650>
            ext->dot_end = LV_LABEL_DOT_END_INV;
 802dbf8:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802dbfc:	f64f 72ff 	movw	r2, #65535	; 0xffff
 802dc00:	609a      	str	r2, [r3, #8]
 802dc02:	e10e      	b.n	802de22 <lv_label_refr_text+0x86e>
        }
        else {
            lv_point_t p;
            p.x = lv_area_get_width(&txt_coords) -
 802dc04:	f107 0358 	add.w	r3, r7, #88	; 0x58
 802dc08:	4618      	mov	r0, r3
 802dc0a:	f7fe faed 	bl	802c1e8 <lv_area_get_width>
 802dc0e:	4603      	mov	r3, r0
 802dc10:	b29c      	uxth	r4, r3
                  (lv_font_get_glyph_width(font, '.', '.') + letter_space) *
 802dc12:	222e      	movs	r2, #46	; 0x2e
 802dc14:	212e      	movs	r1, #46	; 0x2e
 802dc16:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 802dc1a:	f7ef ff57 	bl	801dacc <lv_font_get_glyph_width>
 802dc1e:	4603      	mov	r3, r0
 802dc20:	461a      	mov	r2, r3
 802dc22:	f9b7 3088 	ldrsh.w	r3, [r7, #136]	; 0x88
 802dc26:	4413      	add	r3, r2
            p.x = lv_area_get_width(&txt_coords) -
 802dc28:	b29b      	uxth	r3, r3
 802dc2a:	461a      	mov	r2, r3
 802dc2c:	009b      	lsls	r3, r3, #2
 802dc2e:	1ad3      	subs	r3, r2, r3
 802dc30:	b29b      	uxth	r3, r3
 802dc32:	4423      	add	r3, r4
 802dc34:	b29b      	uxth	r3, r3
 802dc36:	b21b      	sxth	r3, r3
 802dc38:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                  LV_LABEL_DOT_NUM; /*Shrink with dots*/
            p.y = lv_area_get_height(&txt_coords);
 802dc3c:	f107 0358 	add.w	r3, r7, #88	; 0x58
 802dc40:	4618      	mov	r0, r3
 802dc42:	f7fe fae8 	bl	802c216 <lv_area_get_height>
 802dc46:	4603      	mov	r3, r0
 802dc48:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            p.y -= p.y %
 802dc4c:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 802dc50:	461c      	mov	r4, r3
                   (lv_font_get_line_height(font) + line_space); /*Round down to the last line*/
 802dc52:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
 802dc56:	f7fe faf5 	bl	802c244 <lv_font_get_line_height>
 802dc5a:	4603      	mov	r3, r0
 802dc5c:	461a      	mov	r2, r3
 802dc5e:	f9b7 308a 	ldrsh.w	r3, [r7, #138]	; 0x8a
 802dc62:	4413      	add	r3, r2
            p.y -= p.y %
 802dc64:	fb94 f2f3 	sdiv	r2, r4, r3
 802dc68:	fb02 f303 	mul.w	r3, r2, r3
 802dc6c:	1ae3      	subs	r3, r4, r3
 802dc6e:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 802dc72:	b292      	uxth	r2, r2
 802dc74:	b29b      	uxth	r3, r3
 802dc76:	1ad3      	subs	r3, r2, r3
 802dc78:	b29b      	uxth	r3, r3
 802dc7a:	b21b      	sxth	r3, r3
 802dc7c:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            p.y -= line_space;                                               /*Trim the last line space*/
 802dc80:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 802dc84:	b29a      	uxth	r2, r3
 802dc86:	f8b7 308a 	ldrh.w	r3, [r7, #138]	; 0x8a
 802dc8a:	1ad3      	subs	r3, r2, r3
 802dc8c:	b29b      	uxth	r3, r3
 802dc8e:	b21b      	sxth	r3, r3
 802dc90:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
 802dc94:	f107 0350 	add.w	r3, r7, #80	; 0x50
 802dc98:	4619      	mov	r1, r3
 802dc9a:	6878      	ldr	r0, [r7, #4]
 802dc9c:	f7fe ffe4 	bl	802cc68 <lv_label_get_letter_on>
 802dca0:	f8c7 00a0 	str.w	r0, [r7, #160]	; 0xa0


            /*Be sure there is space for the dots*/
            size_t txt_len = strlen(ext->text);
 802dca4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802dca8:	681b      	ldr	r3, [r3, #0]
 802dcaa:	4618      	mov	r0, r3
 802dcac:	f7d2 faa8 	bl	8000200 <strlen>
 802dcb0:	f8c7 0084 	str.w	r0, [r7, #132]	; 0x84
            uint32_t byte_id     = _lv_txt_encoded_get_byte_id(ext->text, letter_id);
 802dcb4:	4b46      	ldr	r3, [pc, #280]	; (802ddd0 <lv_label_refr_text+0x81c>)
 802dcb6:	681b      	ldr	r3, [r3, #0]
 802dcb8:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 802dcbc:	6812      	ldr	r2, [r2, #0]
 802dcbe:	f8d7 10a0 	ldr.w	r1, [r7, #160]	; 0xa0
 802dcc2:	4610      	mov	r0, r2
 802dcc4:	4798      	blx	r3
 802dcc6:	4603      	mov	r3, r0
 802dcc8:	64fb      	str	r3, [r7, #76]	; 0x4c
            while(byte_id + LV_LABEL_DOT_NUM > txt_len) {
 802dcca:	e012      	b.n	802dcf2 <lv_label_refr_text+0x73e>
                byte_id -= _lv_txt_encoded_size(&ext->text[byte_id]);
 802dccc:	4b41      	ldr	r3, [pc, #260]	; (802ddd4 <lv_label_refr_text+0x820>)
 802dcce:	681b      	ldr	r3, [r3, #0]
 802dcd0:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 802dcd4:	6811      	ldr	r1, [r2, #0]
 802dcd6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 802dcd8:	440a      	add	r2, r1
 802dcda:	4610      	mov	r0, r2
 802dcdc:	4798      	blx	r3
 802dcde:	4603      	mov	r3, r0
 802dce0:	461a      	mov	r2, r3
 802dce2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802dce4:	1a9b      	subs	r3, r3, r2
 802dce6:	64fb      	str	r3, [r7, #76]	; 0x4c
                letter_id--;
 802dce8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 802dcec:	3b01      	subs	r3, #1
 802dcee:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
            while(byte_id + LV_LABEL_DOT_NUM > txt_len) {
 802dcf2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802dcf4:	3303      	adds	r3, #3
 802dcf6:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 802dcfa:	429a      	cmp	r2, r3
 802dcfc:	d3e6      	bcc.n	802dccc <lv_label_refr_text+0x718>
            }

            /*Save letters under the dots and replace them with dots*/
            uint32_t byte_id_ori = byte_id;
 802dcfe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802dd00:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
            uint32_t i;
            uint8_t len          = 0;
 802dd04:	2300      	movs	r3, #0
 802dd06:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
 802dd0a:	2300      	movs	r3, #0
 802dd0c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 802dd10:	e01d      	b.n	802dd4e <lv_label_refr_text+0x79a>
                len += _lv_txt_encoded_size(&ext->text[byte_id]);
 802dd12:	4b30      	ldr	r3, [pc, #192]	; (802ddd4 <lv_label_refr_text+0x820>)
 802dd14:	681b      	ldr	r3, [r3, #0]
 802dd16:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 802dd1a:	6811      	ldr	r1, [r2, #0]
 802dd1c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 802dd1e:	440a      	add	r2, r1
 802dd20:	4610      	mov	r0, r2
 802dd22:	4798      	blx	r3
 802dd24:	4603      	mov	r3, r0
 802dd26:	461a      	mov	r2, r3
 802dd28:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 802dd2c:	4413      	add	r3, r2
 802dd2e:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
                _lv_txt_encoded_next(ext->text, &byte_id);
 802dd32:	4b29      	ldr	r3, [pc, #164]	; (802ddd8 <lv_label_refr_text+0x824>)
 802dd34:	681b      	ldr	r3, [r3, #0]
 802dd36:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 802dd3a:	6812      	ldr	r2, [r2, #0]
 802dd3c:	f107 014c 	add.w	r1, r7, #76	; 0x4c
 802dd40:	4610      	mov	r0, r2
 802dd42:	4798      	blx	r3
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
 802dd44:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 802dd48:	3301      	adds	r3, #1
 802dd4a:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 802dd4e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 802dd52:	2b03      	cmp	r3, #3
 802dd54:	d9dd      	bls.n	802dd12 <lv_label_refr_text+0x75e>
            }

            if(lv_label_set_dot_tmp(label, &ext->text[byte_id_ori], len)) {
 802dd56:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802dd5a:	681a      	ldr	r2, [r3, #0]
 802dd5c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 802dd60:	4413      	add	r3, r2
 802dd62:	f897 209b 	ldrb.w	r2, [r7, #155]	; 0x9b
 802dd66:	4619      	mov	r1, r3
 802dd68:	6878      	ldr	r0, [r7, #4]
 802dd6a:	f000 f8e5 	bl	802df38 <lv_label_set_dot_tmp>
 802dd6e:	4603      	mov	r3, r0
 802dd70:	2b00      	cmp	r3, #0
 802dd72:	d056      	beq.n	802de22 <lv_label_refr_text+0x86e>
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
 802dd74:	2300      	movs	r3, #0
 802dd76:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 802dd7a:	e00f      	b.n	802dd9c <lv_label_refr_text+0x7e8>
                    ext->text[byte_id_ori + i] = '.';
 802dd7c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802dd80:	681a      	ldr	r2, [r3, #0]
 802dd82:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
 802dd86:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 802dd8a:	440b      	add	r3, r1
 802dd8c:	4413      	add	r3, r2
 802dd8e:	222e      	movs	r2, #46	; 0x2e
 802dd90:	701a      	strb	r2, [r3, #0]
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
 802dd92:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 802dd96:	3301      	adds	r3, #1
 802dd98:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
 802dd9c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 802dda0:	2b02      	cmp	r3, #2
 802dda2:	d9eb      	bls.n	802dd7c <lv_label_refr_text+0x7c8>
                }
                ext->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
 802dda4:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802dda8:	681a      	ldr	r2, [r3, #0]
 802ddaa:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 802ddae:	3303      	adds	r3, #3
 802ddb0:	4413      	add	r3, r2
 802ddb2:	2200      	movs	r2, #0
 802ddb4:	701a      	strb	r2, [r3, #0]
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
 802ddb6:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 802ddba:	1cda      	adds	r2, r3, #3
 802ddbc:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802ddc0:	609a      	str	r2, [r3, #8]
 802ddc2:	e02e      	b.n	802de22 <lv_label_refr_text+0x86e>
 802ddc4:	0802dee9 	.word	0x0802dee9
 802ddc8:	0802df11 	.word	0x0802df11
 802ddcc:	20000214 	.word	0x20000214
 802ddd0:	2000020c 	.word	0x2000020c
 802ddd4:	20000200 	.word	0x20000200
 802ddd8:	20000204 	.word	0x20000204
            }
        }
    }
    /*In break mode only the height can change*/
    else if(ext->long_mode == LV_LABEL_LONG_BREAK) {
 802dddc:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 802dde0:	7c9b      	ldrb	r3, [r3, #18]
 802dde2:	f003 0307 	and.w	r3, r3, #7
 802dde6:	b2db      	uxtb	r3, r3
 802dde8:	2b01      	cmp	r3, #1
 802ddea:	d11a      	bne.n	802de22 <lv_label_refr_text+0x86e>
        size.y += lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN) + lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
 802ddec:	2100      	movs	r1, #0
 802ddee:	6878      	ldr	r0, [r7, #4]
 802ddf0:	f7fe fad7 	bl	802c3a2 <lv_obj_get_style_pad_top>
 802ddf4:	4603      	mov	r3, r0
 802ddf6:	461c      	mov	r4, r3
 802ddf8:	2100      	movs	r1, #0
 802ddfa:	6878      	ldr	r0, [r7, #4]
 802ddfc:	f7fe fae2 	bl	802c3c4 <lv_obj_get_style_pad_bottom>
 802de00:	4603      	mov	r3, r0
 802de02:	4423      	add	r3, r4
 802de04:	f9b7 2056 	ldrsh.w	r2, [r7, #86]	; 0x56
 802de08:	b292      	uxth	r2, r2
 802de0a:	b29b      	uxth	r3, r3
 802de0c:	4413      	add	r3, r2
 802de0e:	b29b      	uxth	r3, r3
 802de10:	b21b      	sxth	r3, r3
 802de12:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
        lv_obj_set_height(label, size.y);
 802de16:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 802de1a:	4619      	mov	r1, r3
 802de1c:	6878      	ldr	r0, [r7, #4]
 802de1e:	f7dc f8b3 	bl	8009f88 <lv_obj_set_height>
    /*Do not set the size in Clip mode*/
    else if(ext->long_mode == LV_LABEL_LONG_CROP) {
        /*Do nothing*/
    }

    lv_obj_invalidate(label);
 802de22:	6878      	ldr	r0, [r7, #4]
 802de24:	f7db fdec 	bl	8009a00 <lv_obj_invalidate>
 802de28:	e000      	b.n	802de2c <lv_label_refr_text+0x878>
    if(ext->text == NULL) return;
 802de2a:	bf00      	nop
}
 802de2c:	37bc      	adds	r7, #188	; 0xbc
 802de2e:	46bd      	mov	sp, r7
 802de30:	bd90      	pop	{r4, r7, pc}
 802de32:	bf00      	nop

0802de34 <lv_label_revert_dots>:

static void lv_label_revert_dots(lv_obj_t * label)
{
 802de34:	b580      	push	{r7, lr}
 802de36:	b088      	sub	sp, #32
 802de38:	af00      	add	r7, sp, #0
 802de3a:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802de3c:	6878      	ldr	r0, [r7, #4]
 802de3e:	f7dd fe07 	bl	800ba50 <lv_obj_get_ext_attr>
 802de42:	61b8      	str	r0, [r7, #24]
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
 802de44:	69bb      	ldr	r3, [r7, #24]
 802de46:	7c9b      	ldrb	r3, [r3, #18]
 802de48:	f003 0307 	and.w	r3, r3, #7
 802de4c:	b2db      	uxtb	r3, r3
 802de4e:	2b02      	cmp	r3, #2
 802de50:	d142      	bne.n	802ded8 <lv_label_revert_dots+0xa4>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
 802de52:	69bb      	ldr	r3, [r7, #24]
 802de54:	689b      	ldr	r3, [r3, #8]
 802de56:	f64f 72ff 	movw	r2, #65535	; 0xffff
 802de5a:	4293      	cmp	r3, r2
 802de5c:	d03e      	beq.n	802dedc <lv_label_revert_dots+0xa8>
    uint32_t letter_i = ext->dot_end - LV_LABEL_DOT_NUM;
 802de5e:	69bb      	ldr	r3, [r7, #24]
 802de60:	689b      	ldr	r3, [r3, #8]
 802de62:	3b03      	subs	r3, #3
 802de64:	617b      	str	r3, [r7, #20]
    uint32_t byte_i   = _lv_txt_encoded_get_byte_id(ext->text, letter_i);
 802de66:	4b1f      	ldr	r3, [pc, #124]	; (802dee4 <lv_label_revert_dots+0xb0>)
 802de68:	681b      	ldr	r3, [r3, #0]
 802de6a:	69ba      	ldr	r2, [r7, #24]
 802de6c:	6812      	ldr	r2, [r2, #0]
 802de6e:	6979      	ldr	r1, [r7, #20]
 802de70:	4610      	mov	r0, r2
 802de72:	4798      	blx	r3
 802de74:	6138      	str	r0, [r7, #16]

    /*Restore the characters*/
    uint8_t i      = 0;
 802de76:	2300      	movs	r3, #0
 802de78:	77fb      	strb	r3, [r7, #31]
    char * dot_tmp = lv_label_get_dot_tmp(label);
 802de7a:	6878      	ldr	r0, [r7, #4]
 802de7c:	f000 f89e 	bl	802dfbc <lv_label_get_dot_tmp>
 802de80:	60f8      	str	r0, [r7, #12]
    while(ext->text[byte_i + i] != '\0') {
 802de82:	e00d      	b.n	802dea0 <lv_label_revert_dots+0x6c>
        ext->text[byte_i + i] = dot_tmp[i];
 802de84:	7ffb      	ldrb	r3, [r7, #31]
 802de86:	68fa      	ldr	r2, [r7, #12]
 802de88:	441a      	add	r2, r3
 802de8a:	69bb      	ldr	r3, [r7, #24]
 802de8c:	6819      	ldr	r1, [r3, #0]
 802de8e:	7ff8      	ldrb	r0, [r7, #31]
 802de90:	693b      	ldr	r3, [r7, #16]
 802de92:	4403      	add	r3, r0
 802de94:	440b      	add	r3, r1
 802de96:	7812      	ldrb	r2, [r2, #0]
 802de98:	701a      	strb	r2, [r3, #0]
        i++;
 802de9a:	7ffb      	ldrb	r3, [r7, #31]
 802de9c:	3301      	adds	r3, #1
 802de9e:	77fb      	strb	r3, [r7, #31]
    while(ext->text[byte_i + i] != '\0') {
 802dea0:	69bb      	ldr	r3, [r7, #24]
 802dea2:	681a      	ldr	r2, [r3, #0]
 802dea4:	7ff9      	ldrb	r1, [r7, #31]
 802dea6:	693b      	ldr	r3, [r7, #16]
 802dea8:	440b      	add	r3, r1
 802deaa:	4413      	add	r3, r2
 802deac:	781b      	ldrb	r3, [r3, #0]
 802deae:	2b00      	cmp	r3, #0
 802deb0:	d1e8      	bne.n	802de84 <lv_label_revert_dots+0x50>
    }
    ext->text[byte_i + i] = dot_tmp[i];
 802deb2:	7ffb      	ldrb	r3, [r7, #31]
 802deb4:	68fa      	ldr	r2, [r7, #12]
 802deb6:	441a      	add	r2, r3
 802deb8:	69bb      	ldr	r3, [r7, #24]
 802deba:	6819      	ldr	r1, [r3, #0]
 802debc:	7ff8      	ldrb	r0, [r7, #31]
 802debe:	693b      	ldr	r3, [r7, #16]
 802dec0:	4403      	add	r3, r0
 802dec2:	440b      	add	r3, r1
 802dec4:	7812      	ldrb	r2, [r2, #0]
 802dec6:	701a      	strb	r2, [r3, #0]
    lv_label_dot_tmp_free(label);
 802dec8:	6878      	ldr	r0, [r7, #4]
 802deca:	f000 f88f 	bl	802dfec <lv_label_dot_tmp_free>

    ext->dot_end = LV_LABEL_DOT_END_INV;
 802dece:	69bb      	ldr	r3, [r7, #24]
 802ded0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 802ded4:	609a      	str	r2, [r3, #8]
 802ded6:	e002      	b.n	802dede <lv_label_revert_dots+0xaa>
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
 802ded8:	bf00      	nop
 802deda:	e000      	b.n	802dede <lv_label_revert_dots+0xaa>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
 802dedc:	bf00      	nop
}
 802dede:	3720      	adds	r7, #32
 802dee0:	46bd      	mov	sp, r7
 802dee2:	bd80      	pop	{r7, pc}
 802dee4:	2000020c 	.word	0x2000020c

0802dee8 <lv_label_set_offset_x>:

#if LV_USE_ANIMATION
static void lv_label_set_offset_x(lv_obj_t * label, lv_coord_t x)
{
 802dee8:	b580      	push	{r7, lr}
 802deea:	b084      	sub	sp, #16
 802deec:	af00      	add	r7, sp, #0
 802deee:	6078      	str	r0, [r7, #4]
 802def0:	460b      	mov	r3, r1
 802def2:	807b      	strh	r3, [r7, #2]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802def4:	6878      	ldr	r0, [r7, #4]
 802def6:	f7dd fdab 	bl	800ba50 <lv_obj_get_ext_attr>
 802defa:	60f8      	str	r0, [r7, #12]
    ext->offset.x        = x;
 802defc:	68fb      	ldr	r3, [r7, #12]
 802defe:	887a      	ldrh	r2, [r7, #2]
 802df00:	81da      	strh	r2, [r3, #14]
    lv_obj_invalidate(label);
 802df02:	6878      	ldr	r0, [r7, #4]
 802df04:	f7db fd7c 	bl	8009a00 <lv_obj_invalidate>
}
 802df08:	bf00      	nop
 802df0a:	3710      	adds	r7, #16
 802df0c:	46bd      	mov	sp, r7
 802df0e:	bd80      	pop	{r7, pc}

0802df10 <lv_label_set_offset_y>:

static void lv_label_set_offset_y(lv_obj_t * label, lv_coord_t y)
{
 802df10:	b580      	push	{r7, lr}
 802df12:	b084      	sub	sp, #16
 802df14:	af00      	add	r7, sp, #0
 802df16:	6078      	str	r0, [r7, #4]
 802df18:	460b      	mov	r3, r1
 802df1a:	807b      	strh	r3, [r7, #2]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802df1c:	6878      	ldr	r0, [r7, #4]
 802df1e:	f7dd fd97 	bl	800ba50 <lv_obj_get_ext_attr>
 802df22:	60f8      	str	r0, [r7, #12]
    ext->offset.y        = y;
 802df24:	68fb      	ldr	r3, [r7, #12]
 802df26:	887a      	ldrh	r2, [r7, #2]
 802df28:	821a      	strh	r2, [r3, #16]
    lv_obj_invalidate(label);
 802df2a:	6878      	ldr	r0, [r7, #4]
 802df2c:	f7db fd68 	bl	8009a00 <lv_obj_invalidate>
}
 802df30:	bf00      	nop
 802df32:	3710      	adds	r7, #16
 802df34:	46bd      	mov	sp, r7
 802df36:	bd80      	pop	{r7, pc}

0802df38 <lv_label_set_dot_tmp>:
 * @param label pointer to label object
 * @param len Number of characters to store.
 * @return true on success.
 */
static bool lv_label_set_dot_tmp(lv_obj_t * label, char * data, uint32_t len)
{
 802df38:	b580      	push	{r7, lr}
 802df3a:	b086      	sub	sp, #24
 802df3c:	af00      	add	r7, sp, #0
 802df3e:	60f8      	str	r0, [r7, #12]
 802df40:	60b9      	str	r1, [r7, #8]
 802df42:	607a      	str	r2, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802df44:	68f8      	ldr	r0, [r7, #12]
 802df46:	f7dd fd83 	bl	800ba50 <lv_obj_get_ext_attr>
 802df4a:	6178      	str	r0, [r7, #20]
    lv_label_dot_tmp_free(label); /* Deallocate any existing space */
 802df4c:	68f8      	ldr	r0, [r7, #12]
 802df4e:	f000 f84d 	bl	802dfec <lv_label_dot_tmp_free>
    if(len > sizeof(char *)) {
 802df52:	687b      	ldr	r3, [r7, #4]
 802df54:	2b04      	cmp	r3, #4
 802df56:	d920      	bls.n	802df9a <lv_label_set_dot_tmp+0x62>
        /* Memory needs to be allocated. Allocates an additional byte
         * for a NULL-terminator so it can be copied. */
        ext->dot.tmp_ptr = lv_mem_alloc(len + 1);
 802df58:	687b      	ldr	r3, [r7, #4]
 802df5a:	3301      	adds	r3, #1
 802df5c:	4618      	mov	r0, r3
 802df5e:	f7f2 fe39 	bl	8020bd4 <lv_mem_alloc>
 802df62:	4602      	mov	r2, r0
 802df64:	697b      	ldr	r3, [r7, #20]
 802df66:	605a      	str	r2, [r3, #4]
        if(ext->dot.tmp_ptr == NULL) {
 802df68:	697b      	ldr	r3, [r7, #20]
 802df6a:	685b      	ldr	r3, [r3, #4]
 802df6c:	2b00      	cmp	r3, #0
 802df6e:	d101      	bne.n	802df74 <lv_label_set_dot_tmp+0x3c>
            LV_LOG_ERROR("Failed to allocate memory for dot_tmp_ptr");
            return false;
 802df70:	2300      	movs	r3, #0
 802df72:	e01f      	b.n	802dfb4 <lv_label_set_dot_tmp+0x7c>
        }
        _lv_memcpy(ext->dot.tmp_ptr, data, len);
 802df74:	697b      	ldr	r3, [r7, #20]
 802df76:	685b      	ldr	r3, [r3, #4]
 802df78:	687a      	ldr	r2, [r7, #4]
 802df7a:	68b9      	ldr	r1, [r7, #8]
 802df7c:	4618      	mov	r0, r3
 802df7e:	f7f3 f8ed 	bl	802115c <_lv_memcpy>
        ext->dot.tmp_ptr[len] = '\0';
 802df82:	697b      	ldr	r3, [r7, #20]
 802df84:	685a      	ldr	r2, [r3, #4]
 802df86:	687b      	ldr	r3, [r7, #4]
 802df88:	4413      	add	r3, r2
 802df8a:	2200      	movs	r2, #0
 802df8c:	701a      	strb	r2, [r3, #0]
        ext->dot_tmp_alloc    = true;
 802df8e:	697a      	ldr	r2, [r7, #20]
 802df90:	7cd3      	ldrb	r3, [r2, #19]
 802df92:	f043 0301 	orr.w	r3, r3, #1
 802df96:	74d3      	strb	r3, [r2, #19]
 802df98:	e00b      	b.n	802dfb2 <lv_label_set_dot_tmp+0x7a>
    }
    else {
        /* Characters can be directly stored in object */
        ext->dot_tmp_alloc = false;
 802df9a:	697a      	ldr	r2, [r7, #20]
 802df9c:	7cd3      	ldrb	r3, [r2, #19]
 802df9e:	f36f 0300 	bfc	r3, #0, #1
 802dfa2:	74d3      	strb	r3, [r2, #19]
        _lv_memcpy(ext->dot.tmp, data, len);
 802dfa4:	697b      	ldr	r3, [r7, #20]
 802dfa6:	3304      	adds	r3, #4
 802dfa8:	687a      	ldr	r2, [r7, #4]
 802dfaa:	68b9      	ldr	r1, [r7, #8]
 802dfac:	4618      	mov	r0, r3
 802dfae:	f7f3 f8d5 	bl	802115c <_lv_memcpy>
    }
    return true;
 802dfb2:	2301      	movs	r3, #1
}
 802dfb4:	4618      	mov	r0, r3
 802dfb6:	3718      	adds	r7, #24
 802dfb8:	46bd      	mov	sp, r7
 802dfba:	bd80      	pop	{r7, pc}

0802dfbc <lv_label_get_dot_tmp>:
 * Get the stored dot_tmp characters
 * @param label pointer to label object
 * @return char pointer to a stored characters. Is *not* necessarily NULL-terminated.
 */
static char * lv_label_get_dot_tmp(lv_obj_t * label)
{
 802dfbc:	b580      	push	{r7, lr}
 802dfbe:	b084      	sub	sp, #16
 802dfc0:	af00      	add	r7, sp, #0
 802dfc2:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802dfc4:	6878      	ldr	r0, [r7, #4]
 802dfc6:	f7dd fd43 	bl	800ba50 <lv_obj_get_ext_attr>
 802dfca:	60f8      	str	r0, [r7, #12]
    if(ext->dot_tmp_alloc) {
 802dfcc:	68fb      	ldr	r3, [r7, #12]
 802dfce:	7cdb      	ldrb	r3, [r3, #19]
 802dfd0:	f003 0301 	and.w	r3, r3, #1
 802dfd4:	b2db      	uxtb	r3, r3
 802dfd6:	2b00      	cmp	r3, #0
 802dfd8:	d002      	beq.n	802dfe0 <lv_label_get_dot_tmp+0x24>
        return ext->dot.tmp_ptr;
 802dfda:	68fb      	ldr	r3, [r7, #12]
 802dfdc:	685b      	ldr	r3, [r3, #4]
 802dfde:	e001      	b.n	802dfe4 <lv_label_get_dot_tmp+0x28>
    }
    else {
        return ext->dot.tmp;
 802dfe0:	68fb      	ldr	r3, [r7, #12]
 802dfe2:	3304      	adds	r3, #4
    }
}
 802dfe4:	4618      	mov	r0, r3
 802dfe6:	3710      	adds	r7, #16
 802dfe8:	46bd      	mov	sp, r7
 802dfea:	bd80      	pop	{r7, pc}

0802dfec <lv_label_dot_tmp_free>:
 * Free the dot_tmp_ptr field if it was previously allocated.
 * Always clears the field
 * @param label pointer to label object.
 */
static void lv_label_dot_tmp_free(lv_obj_t * label)
{
 802dfec:	b580      	push	{r7, lr}
 802dfee:	b084      	sub	sp, #16
 802dff0:	af00      	add	r7, sp, #0
 802dff2:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802dff4:	6878      	ldr	r0, [r7, #4]
 802dff6:	f7dd fd2b 	bl	800ba50 <lv_obj_get_ext_attr>
 802dffa:	60f8      	str	r0, [r7, #12]
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
 802dffc:	68fb      	ldr	r3, [r7, #12]
 802dffe:	7cdb      	ldrb	r3, [r3, #19]
 802e000:	f003 0301 	and.w	r3, r3, #1
 802e004:	b2db      	uxtb	r3, r3
 802e006:	2b00      	cmp	r3, #0
 802e008:	d008      	beq.n	802e01c <lv_label_dot_tmp_free+0x30>
 802e00a:	68fb      	ldr	r3, [r7, #12]
 802e00c:	685b      	ldr	r3, [r3, #4]
 802e00e:	2b00      	cmp	r3, #0
 802e010:	d004      	beq.n	802e01c <lv_label_dot_tmp_free+0x30>
        lv_mem_free(ext->dot.tmp_ptr);
 802e012:	68fb      	ldr	r3, [r7, #12]
 802e014:	685b      	ldr	r3, [r3, #4]
 802e016:	4618      	mov	r0, r3
 802e018:	f7f2 fe26 	bl	8020c68 <lv_mem_free>
    }
    ext->dot_tmp_alloc = false;
 802e01c:	68fa      	ldr	r2, [r7, #12]
 802e01e:	7cd3      	ldrb	r3, [r2, #19]
 802e020:	f36f 0300 	bfc	r3, #0, #1
 802e024:	74d3      	strb	r3, [r2, #19]
    ext->dot.tmp_ptr   = NULL;
 802e026:	68fb      	ldr	r3, [r7, #12]
 802e028:	2200      	movs	r2, #0
 802e02a:	605a      	str	r2, [r3, #4]
}
 802e02c:	bf00      	nop
 802e02e:	3710      	adds	r7, #16
 802e030:	46bd      	mov	sp, r7
 802e032:	bd80      	pop	{r7, pc}

0802e034 <get_txt_coords>:

static void get_txt_coords(const lv_obj_t * label, lv_area_t * area)
{
 802e034:	b580      	push	{r7, lr}
 802e036:	b084      	sub	sp, #16
 802e038:	af00      	add	r7, sp, #0
 802e03a:	6078      	str	r0, [r7, #4]
 802e03c:	6039      	str	r1, [r7, #0]
    lv_obj_get_coords(label, area);
 802e03e:	6839      	ldr	r1, [r7, #0]
 802e040:	6878      	ldr	r0, [r7, #4]
 802e042:	f7dc febb 	bl	800adbc <lv_obj_get_coords>

    lv_coord_t left   = lv_obj_get_style_pad_left(label, LV_LABEL_PART_MAIN);
 802e046:	2100      	movs	r1, #0
 802e048:	6878      	ldr	r0, [r7, #4]
 802e04a:	f7fe f9cc 	bl	802c3e6 <lv_obj_get_style_pad_left>
 802e04e:	4603      	mov	r3, r0
 802e050:	81fb      	strh	r3, [r7, #14]
    lv_coord_t right  = lv_obj_get_style_pad_right(label, LV_LABEL_PART_MAIN);
 802e052:	2100      	movs	r1, #0
 802e054:	6878      	ldr	r0, [r7, #4]
 802e056:	f7fe f9d7 	bl	802c408 <lv_obj_get_style_pad_right>
 802e05a:	4603      	mov	r3, r0
 802e05c:	81bb      	strh	r3, [r7, #12]
    lv_coord_t top    = lv_obj_get_style_pad_top(label, LV_LABEL_PART_MAIN);
 802e05e:	2100      	movs	r1, #0
 802e060:	6878      	ldr	r0, [r7, #4]
 802e062:	f7fe f99e 	bl	802c3a2 <lv_obj_get_style_pad_top>
 802e066:	4603      	mov	r3, r0
 802e068:	817b      	strh	r3, [r7, #10]
    lv_coord_t bottom = lv_obj_get_style_pad_bottom(label, LV_LABEL_PART_MAIN);
 802e06a:	2100      	movs	r1, #0
 802e06c:	6878      	ldr	r0, [r7, #4]
 802e06e:	f7fe f9a9 	bl	802c3c4 <lv_obj_get_style_pad_bottom>
 802e072:	4603      	mov	r3, r0
 802e074:	813b      	strh	r3, [r7, #8]
    area->x1 += left;
 802e076:	683b      	ldr	r3, [r7, #0]
 802e078:	f9b3 3000 	ldrsh.w	r3, [r3]
 802e07c:	b29a      	uxth	r2, r3
 802e07e:	89fb      	ldrh	r3, [r7, #14]
 802e080:	4413      	add	r3, r2
 802e082:	b29b      	uxth	r3, r3
 802e084:	b21a      	sxth	r2, r3
 802e086:	683b      	ldr	r3, [r7, #0]
 802e088:	801a      	strh	r2, [r3, #0]
    area->x2 -= right;
 802e08a:	683b      	ldr	r3, [r7, #0]
 802e08c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 802e090:	b29a      	uxth	r2, r3
 802e092:	89bb      	ldrh	r3, [r7, #12]
 802e094:	1ad3      	subs	r3, r2, r3
 802e096:	b29b      	uxth	r3, r3
 802e098:	b21a      	sxth	r2, r3
 802e09a:	683b      	ldr	r3, [r7, #0]
 802e09c:	809a      	strh	r2, [r3, #4]
    area->y1 += top;
 802e09e:	683b      	ldr	r3, [r7, #0]
 802e0a0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 802e0a4:	b29a      	uxth	r2, r3
 802e0a6:	897b      	ldrh	r3, [r7, #10]
 802e0a8:	4413      	add	r3, r2
 802e0aa:	b29b      	uxth	r3, r3
 802e0ac:	b21a      	sxth	r2, r3
 802e0ae:	683b      	ldr	r3, [r7, #0]
 802e0b0:	805a      	strh	r2, [r3, #2]
    area->y2 -= bottom;
 802e0b2:	683b      	ldr	r3, [r7, #0]
 802e0b4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 802e0b8:	b29a      	uxth	r2, r3
 802e0ba:	893b      	ldrh	r3, [r7, #8]
 802e0bc:	1ad3      	subs	r3, r2, r3
 802e0be:	b29b      	uxth	r3, r3
 802e0c0:	b21a      	sxth	r2, r3
 802e0c2:	683b      	ldr	r3, [r7, #0]
 802e0c4:	80da      	strh	r2, [r3, #6]
}
 802e0c6:	bf00      	nop
 802e0c8:	3710      	adds	r7, #16
 802e0ca:	46bd      	mov	sp, r7
 802e0cc:	bd80      	pop	{r7, pc}
	...

0802e0d0 <malloc>:
 802e0d0:	4b02      	ldr	r3, [pc, #8]	; (802e0dc <malloc+0xc>)
 802e0d2:	4601      	mov	r1, r0
 802e0d4:	6818      	ldr	r0, [r3, #0]
 802e0d6:	f000 b82b 	b.w	802e130 <_malloc_r>
 802e0da:	bf00      	nop
 802e0dc:	20000264 	.word	0x20000264

0802e0e0 <free>:
 802e0e0:	4b02      	ldr	r3, [pc, #8]	; (802e0ec <free+0xc>)
 802e0e2:	4601      	mov	r1, r0
 802e0e4:	6818      	ldr	r0, [r3, #0]
 802e0e6:	f000 b90b 	b.w	802e300 <_free_r>
 802e0ea:	bf00      	nop
 802e0ec:	20000264 	.word	0x20000264

0802e0f0 <sbrk_aligned>:
 802e0f0:	b570      	push	{r4, r5, r6, lr}
 802e0f2:	4e0e      	ldr	r6, [pc, #56]	; (802e12c <sbrk_aligned+0x3c>)
 802e0f4:	460c      	mov	r4, r1
 802e0f6:	6831      	ldr	r1, [r6, #0]
 802e0f8:	4605      	mov	r5, r0
 802e0fa:	b911      	cbnz	r1, 802e102 <sbrk_aligned+0x12>
 802e0fc:	f000 f8bc 	bl	802e278 <_sbrk_r>
 802e100:	6030      	str	r0, [r6, #0]
 802e102:	4621      	mov	r1, r4
 802e104:	4628      	mov	r0, r5
 802e106:	f000 f8b7 	bl	802e278 <_sbrk_r>
 802e10a:	1c43      	adds	r3, r0, #1
 802e10c:	d00a      	beq.n	802e124 <sbrk_aligned+0x34>
 802e10e:	1cc4      	adds	r4, r0, #3
 802e110:	f024 0403 	bic.w	r4, r4, #3
 802e114:	42a0      	cmp	r0, r4
 802e116:	d007      	beq.n	802e128 <sbrk_aligned+0x38>
 802e118:	1a21      	subs	r1, r4, r0
 802e11a:	4628      	mov	r0, r5
 802e11c:	f000 f8ac 	bl	802e278 <_sbrk_r>
 802e120:	3001      	adds	r0, #1
 802e122:	d101      	bne.n	802e128 <sbrk_aligned+0x38>
 802e124:	f04f 34ff 	mov.w	r4, #4294967295
 802e128:	4620      	mov	r0, r4
 802e12a:	bd70      	pop	{r4, r5, r6, pc}
 802e12c:	2001236c 	.word	0x2001236c

0802e130 <_malloc_r>:
 802e130:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802e134:	1ccd      	adds	r5, r1, #3
 802e136:	f025 0503 	bic.w	r5, r5, #3
 802e13a:	3508      	adds	r5, #8
 802e13c:	2d0c      	cmp	r5, #12
 802e13e:	bf38      	it	cc
 802e140:	250c      	movcc	r5, #12
 802e142:	2d00      	cmp	r5, #0
 802e144:	4607      	mov	r7, r0
 802e146:	db01      	blt.n	802e14c <_malloc_r+0x1c>
 802e148:	42a9      	cmp	r1, r5
 802e14a:	d905      	bls.n	802e158 <_malloc_r+0x28>
 802e14c:	230c      	movs	r3, #12
 802e14e:	603b      	str	r3, [r7, #0]
 802e150:	2600      	movs	r6, #0
 802e152:	4630      	mov	r0, r6
 802e154:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802e158:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 802e22c <_malloc_r+0xfc>
 802e15c:	f000 f868 	bl	802e230 <__malloc_lock>
 802e160:	f8d8 3000 	ldr.w	r3, [r8]
 802e164:	461c      	mov	r4, r3
 802e166:	bb5c      	cbnz	r4, 802e1c0 <_malloc_r+0x90>
 802e168:	4629      	mov	r1, r5
 802e16a:	4638      	mov	r0, r7
 802e16c:	f7ff ffc0 	bl	802e0f0 <sbrk_aligned>
 802e170:	1c43      	adds	r3, r0, #1
 802e172:	4604      	mov	r4, r0
 802e174:	d155      	bne.n	802e222 <_malloc_r+0xf2>
 802e176:	f8d8 4000 	ldr.w	r4, [r8]
 802e17a:	4626      	mov	r6, r4
 802e17c:	2e00      	cmp	r6, #0
 802e17e:	d145      	bne.n	802e20c <_malloc_r+0xdc>
 802e180:	2c00      	cmp	r4, #0
 802e182:	d048      	beq.n	802e216 <_malloc_r+0xe6>
 802e184:	6823      	ldr	r3, [r4, #0]
 802e186:	4631      	mov	r1, r6
 802e188:	4638      	mov	r0, r7
 802e18a:	eb04 0903 	add.w	r9, r4, r3
 802e18e:	f000 f873 	bl	802e278 <_sbrk_r>
 802e192:	4581      	cmp	r9, r0
 802e194:	d13f      	bne.n	802e216 <_malloc_r+0xe6>
 802e196:	6821      	ldr	r1, [r4, #0]
 802e198:	1a6d      	subs	r5, r5, r1
 802e19a:	4629      	mov	r1, r5
 802e19c:	4638      	mov	r0, r7
 802e19e:	f7ff ffa7 	bl	802e0f0 <sbrk_aligned>
 802e1a2:	3001      	adds	r0, #1
 802e1a4:	d037      	beq.n	802e216 <_malloc_r+0xe6>
 802e1a6:	6823      	ldr	r3, [r4, #0]
 802e1a8:	442b      	add	r3, r5
 802e1aa:	6023      	str	r3, [r4, #0]
 802e1ac:	f8d8 3000 	ldr.w	r3, [r8]
 802e1b0:	2b00      	cmp	r3, #0
 802e1b2:	d038      	beq.n	802e226 <_malloc_r+0xf6>
 802e1b4:	685a      	ldr	r2, [r3, #4]
 802e1b6:	42a2      	cmp	r2, r4
 802e1b8:	d12b      	bne.n	802e212 <_malloc_r+0xe2>
 802e1ba:	2200      	movs	r2, #0
 802e1bc:	605a      	str	r2, [r3, #4]
 802e1be:	e00f      	b.n	802e1e0 <_malloc_r+0xb0>
 802e1c0:	6822      	ldr	r2, [r4, #0]
 802e1c2:	1b52      	subs	r2, r2, r5
 802e1c4:	d41f      	bmi.n	802e206 <_malloc_r+0xd6>
 802e1c6:	2a0b      	cmp	r2, #11
 802e1c8:	d917      	bls.n	802e1fa <_malloc_r+0xca>
 802e1ca:	1961      	adds	r1, r4, r5
 802e1cc:	42a3      	cmp	r3, r4
 802e1ce:	6025      	str	r5, [r4, #0]
 802e1d0:	bf18      	it	ne
 802e1d2:	6059      	strne	r1, [r3, #4]
 802e1d4:	6863      	ldr	r3, [r4, #4]
 802e1d6:	bf08      	it	eq
 802e1d8:	f8c8 1000 	streq.w	r1, [r8]
 802e1dc:	5162      	str	r2, [r4, r5]
 802e1de:	604b      	str	r3, [r1, #4]
 802e1e0:	4638      	mov	r0, r7
 802e1e2:	f104 060b 	add.w	r6, r4, #11
 802e1e6:	f000 f829 	bl	802e23c <__malloc_unlock>
 802e1ea:	f026 0607 	bic.w	r6, r6, #7
 802e1ee:	1d23      	adds	r3, r4, #4
 802e1f0:	1af2      	subs	r2, r6, r3
 802e1f2:	d0ae      	beq.n	802e152 <_malloc_r+0x22>
 802e1f4:	1b9b      	subs	r3, r3, r6
 802e1f6:	50a3      	str	r3, [r4, r2]
 802e1f8:	e7ab      	b.n	802e152 <_malloc_r+0x22>
 802e1fa:	42a3      	cmp	r3, r4
 802e1fc:	6862      	ldr	r2, [r4, #4]
 802e1fe:	d1dd      	bne.n	802e1bc <_malloc_r+0x8c>
 802e200:	f8c8 2000 	str.w	r2, [r8]
 802e204:	e7ec      	b.n	802e1e0 <_malloc_r+0xb0>
 802e206:	4623      	mov	r3, r4
 802e208:	6864      	ldr	r4, [r4, #4]
 802e20a:	e7ac      	b.n	802e166 <_malloc_r+0x36>
 802e20c:	4634      	mov	r4, r6
 802e20e:	6876      	ldr	r6, [r6, #4]
 802e210:	e7b4      	b.n	802e17c <_malloc_r+0x4c>
 802e212:	4613      	mov	r3, r2
 802e214:	e7cc      	b.n	802e1b0 <_malloc_r+0x80>
 802e216:	230c      	movs	r3, #12
 802e218:	603b      	str	r3, [r7, #0]
 802e21a:	4638      	mov	r0, r7
 802e21c:	f000 f80e 	bl	802e23c <__malloc_unlock>
 802e220:	e797      	b.n	802e152 <_malloc_r+0x22>
 802e222:	6025      	str	r5, [r4, #0]
 802e224:	e7dc      	b.n	802e1e0 <_malloc_r+0xb0>
 802e226:	605b      	str	r3, [r3, #4]
 802e228:	deff      	udf	#255	; 0xff
 802e22a:	bf00      	nop
 802e22c:	20012368 	.word	0x20012368

0802e230 <__malloc_lock>:
 802e230:	4801      	ldr	r0, [pc, #4]	; (802e238 <__malloc_lock+0x8>)
 802e232:	f000 b85b 	b.w	802e2ec <__retarget_lock_acquire_recursive>
 802e236:	bf00      	nop
 802e238:	200124ac 	.word	0x200124ac

0802e23c <__malloc_unlock>:
 802e23c:	4801      	ldr	r0, [pc, #4]	; (802e244 <__malloc_unlock+0x8>)
 802e23e:	f000 b856 	b.w	802e2ee <__retarget_lock_release_recursive>
 802e242:	bf00      	nop
 802e244:	200124ac 	.word	0x200124ac

0802e248 <memcmp>:
 802e248:	b510      	push	{r4, lr}
 802e24a:	3901      	subs	r1, #1
 802e24c:	4402      	add	r2, r0
 802e24e:	4290      	cmp	r0, r2
 802e250:	d101      	bne.n	802e256 <memcmp+0xe>
 802e252:	2000      	movs	r0, #0
 802e254:	e005      	b.n	802e262 <memcmp+0x1a>
 802e256:	7803      	ldrb	r3, [r0, #0]
 802e258:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 802e25c:	42a3      	cmp	r3, r4
 802e25e:	d001      	beq.n	802e264 <memcmp+0x1c>
 802e260:	1b18      	subs	r0, r3, r4
 802e262:	bd10      	pop	{r4, pc}
 802e264:	3001      	adds	r0, #1
 802e266:	e7f2      	b.n	802e24e <memcmp+0x6>

0802e268 <memset>:
 802e268:	4402      	add	r2, r0
 802e26a:	4603      	mov	r3, r0
 802e26c:	4293      	cmp	r3, r2
 802e26e:	d100      	bne.n	802e272 <memset+0xa>
 802e270:	4770      	bx	lr
 802e272:	f803 1b01 	strb.w	r1, [r3], #1
 802e276:	e7f9      	b.n	802e26c <memset+0x4>

0802e278 <_sbrk_r>:
 802e278:	b538      	push	{r3, r4, r5, lr}
 802e27a:	4d06      	ldr	r5, [pc, #24]	; (802e294 <_sbrk_r+0x1c>)
 802e27c:	2300      	movs	r3, #0
 802e27e:	4604      	mov	r4, r0
 802e280:	4608      	mov	r0, r1
 802e282:	602b      	str	r3, [r5, #0]
 802e284:	f7d2 ff9a 	bl	80011bc <_sbrk>
 802e288:	1c43      	adds	r3, r0, #1
 802e28a:	d102      	bne.n	802e292 <_sbrk_r+0x1a>
 802e28c:	682b      	ldr	r3, [r5, #0]
 802e28e:	b103      	cbz	r3, 802e292 <_sbrk_r+0x1a>
 802e290:	6023      	str	r3, [r4, #0]
 802e292:	bd38      	pop	{r3, r4, r5, pc}
 802e294:	200124a8 	.word	0x200124a8

0802e298 <__errno>:
 802e298:	4b01      	ldr	r3, [pc, #4]	; (802e2a0 <__errno+0x8>)
 802e29a:	6818      	ldr	r0, [r3, #0]
 802e29c:	4770      	bx	lr
 802e29e:	bf00      	nop
 802e2a0:	20000264 	.word	0x20000264

0802e2a4 <__libc_init_array>:
 802e2a4:	b570      	push	{r4, r5, r6, lr}
 802e2a6:	4d0d      	ldr	r5, [pc, #52]	; (802e2dc <__libc_init_array+0x38>)
 802e2a8:	4c0d      	ldr	r4, [pc, #52]	; (802e2e0 <__libc_init_array+0x3c>)
 802e2aa:	1b64      	subs	r4, r4, r5
 802e2ac:	10a4      	asrs	r4, r4, #2
 802e2ae:	2600      	movs	r6, #0
 802e2b0:	42a6      	cmp	r6, r4
 802e2b2:	d109      	bne.n	802e2c8 <__libc_init_array+0x24>
 802e2b4:	4d0b      	ldr	r5, [pc, #44]	; (802e2e4 <__libc_init_array+0x40>)
 802e2b6:	4c0c      	ldr	r4, [pc, #48]	; (802e2e8 <__libc_init_array+0x44>)
 802e2b8:	f000 f86e 	bl	802e398 <_init>
 802e2bc:	1b64      	subs	r4, r4, r5
 802e2be:	10a4      	asrs	r4, r4, #2
 802e2c0:	2600      	movs	r6, #0
 802e2c2:	42a6      	cmp	r6, r4
 802e2c4:	d105      	bne.n	802e2d2 <__libc_init_array+0x2e>
 802e2c6:	bd70      	pop	{r4, r5, r6, pc}
 802e2c8:	f855 3b04 	ldr.w	r3, [r5], #4
 802e2cc:	4798      	blx	r3
 802e2ce:	3601      	adds	r6, #1
 802e2d0:	e7ee      	b.n	802e2b0 <__libc_init_array+0xc>
 802e2d2:	f855 3b04 	ldr.w	r3, [r5], #4
 802e2d6:	4798      	blx	r3
 802e2d8:	3601      	adds	r6, #1
 802e2da:	e7f2      	b.n	802e2c2 <__libc_init_array+0x1e>
 802e2dc:	080f23e4 	.word	0x080f23e4
 802e2e0:	080f23e4 	.word	0x080f23e4
 802e2e4:	080f23e4 	.word	0x080f23e4
 802e2e8:	080f23e8 	.word	0x080f23e8

0802e2ec <__retarget_lock_acquire_recursive>:
 802e2ec:	4770      	bx	lr

0802e2ee <__retarget_lock_release_recursive>:
 802e2ee:	4770      	bx	lr

0802e2f0 <strcpy>:
 802e2f0:	4603      	mov	r3, r0
 802e2f2:	f811 2b01 	ldrb.w	r2, [r1], #1
 802e2f6:	f803 2b01 	strb.w	r2, [r3], #1
 802e2fa:	2a00      	cmp	r2, #0
 802e2fc:	d1f9      	bne.n	802e2f2 <strcpy+0x2>
 802e2fe:	4770      	bx	lr

0802e300 <_free_r>:
 802e300:	b537      	push	{r0, r1, r2, r4, r5, lr}
 802e302:	2900      	cmp	r1, #0
 802e304:	d044      	beq.n	802e390 <_free_r+0x90>
 802e306:	f851 3c04 	ldr.w	r3, [r1, #-4]
 802e30a:	9001      	str	r0, [sp, #4]
 802e30c:	2b00      	cmp	r3, #0
 802e30e:	f1a1 0404 	sub.w	r4, r1, #4
 802e312:	bfb8      	it	lt
 802e314:	18e4      	addlt	r4, r4, r3
 802e316:	f7ff ff8b 	bl	802e230 <__malloc_lock>
 802e31a:	4a1e      	ldr	r2, [pc, #120]	; (802e394 <_free_r+0x94>)
 802e31c:	9801      	ldr	r0, [sp, #4]
 802e31e:	6813      	ldr	r3, [r2, #0]
 802e320:	b933      	cbnz	r3, 802e330 <_free_r+0x30>
 802e322:	6063      	str	r3, [r4, #4]
 802e324:	6014      	str	r4, [r2, #0]
 802e326:	b003      	add	sp, #12
 802e328:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 802e32c:	f7ff bf86 	b.w	802e23c <__malloc_unlock>
 802e330:	42a3      	cmp	r3, r4
 802e332:	d908      	bls.n	802e346 <_free_r+0x46>
 802e334:	6825      	ldr	r5, [r4, #0]
 802e336:	1961      	adds	r1, r4, r5
 802e338:	428b      	cmp	r3, r1
 802e33a:	bf01      	itttt	eq
 802e33c:	6819      	ldreq	r1, [r3, #0]
 802e33e:	685b      	ldreq	r3, [r3, #4]
 802e340:	1949      	addeq	r1, r1, r5
 802e342:	6021      	streq	r1, [r4, #0]
 802e344:	e7ed      	b.n	802e322 <_free_r+0x22>
 802e346:	461a      	mov	r2, r3
 802e348:	685b      	ldr	r3, [r3, #4]
 802e34a:	b10b      	cbz	r3, 802e350 <_free_r+0x50>
 802e34c:	42a3      	cmp	r3, r4
 802e34e:	d9fa      	bls.n	802e346 <_free_r+0x46>
 802e350:	6811      	ldr	r1, [r2, #0]
 802e352:	1855      	adds	r5, r2, r1
 802e354:	42a5      	cmp	r5, r4
 802e356:	d10b      	bne.n	802e370 <_free_r+0x70>
 802e358:	6824      	ldr	r4, [r4, #0]
 802e35a:	4421      	add	r1, r4
 802e35c:	1854      	adds	r4, r2, r1
 802e35e:	42a3      	cmp	r3, r4
 802e360:	6011      	str	r1, [r2, #0]
 802e362:	d1e0      	bne.n	802e326 <_free_r+0x26>
 802e364:	681c      	ldr	r4, [r3, #0]
 802e366:	685b      	ldr	r3, [r3, #4]
 802e368:	6053      	str	r3, [r2, #4]
 802e36a:	440c      	add	r4, r1
 802e36c:	6014      	str	r4, [r2, #0]
 802e36e:	e7da      	b.n	802e326 <_free_r+0x26>
 802e370:	d902      	bls.n	802e378 <_free_r+0x78>
 802e372:	230c      	movs	r3, #12
 802e374:	6003      	str	r3, [r0, #0]
 802e376:	e7d6      	b.n	802e326 <_free_r+0x26>
 802e378:	6825      	ldr	r5, [r4, #0]
 802e37a:	1961      	adds	r1, r4, r5
 802e37c:	428b      	cmp	r3, r1
 802e37e:	bf04      	itt	eq
 802e380:	6819      	ldreq	r1, [r3, #0]
 802e382:	685b      	ldreq	r3, [r3, #4]
 802e384:	6063      	str	r3, [r4, #4]
 802e386:	bf04      	itt	eq
 802e388:	1949      	addeq	r1, r1, r5
 802e38a:	6021      	streq	r1, [r4, #0]
 802e38c:	6054      	str	r4, [r2, #4]
 802e38e:	e7ca      	b.n	802e326 <_free_r+0x26>
 802e390:	b003      	add	sp, #12
 802e392:	bd30      	pop	{r4, r5, pc}
 802e394:	20012368 	.word	0x20012368

0802e398 <_init>:
 802e398:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802e39a:	bf00      	nop
 802e39c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802e39e:	bc08      	pop	{r3}
 802e3a0:	469e      	mov	lr, r3
 802e3a2:	4770      	bx	lr

0802e3a4 <_fini>:
 802e3a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802e3a6:	bf00      	nop
 802e3a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802e3aa:	bc08      	pop	{r3}
 802e3ac:	469e      	mov	lr, r3
 802e3ae:	4770      	bx	lr
